{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { __decorate } from \"tslib\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n */\n\nvar FreeCameraMouseInput =\n/** @class */\nfunction () {\n  /**\n   * Manage the mouse inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n   * @param touchEnabled Defines if touch is enabled or not\n   */\n  function FreeCameraMouseInput(\n  /**\n   * Define if touch is enabled in the mouse input\n   */\n  touchEnabled) {\n    if (touchEnabled === void 0) {\n      touchEnabled = true;\n    }\n\n    this.touchEnabled = touchEnabled;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n     */\n\n    this.angularSensibility = 2000.0;\n    this._previousPosition = null;\n    /**\n     * Observable for when a pointer move event occurs containing the move offset\n     */\n\n    this.onPointerMovedObservable = new Observable();\n    /**\n     * @hidden\n     * If the camera should be rotated automatically based on pointer movement\n     */\n\n    this._allowCameraRotation = true;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n\n\n  FreeCameraMouseInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this; // eslint-disable-next-line prefer-rest-params\n\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var engine = this.camera.getEngine();\n    var element = engine.getInputElement();\n\n    if (!this._pointerInput) {\n      this._pointerInput = function (p) {\n        var evt = p.event;\n        var isTouch = evt.pointerType === \"touch\";\n\n        if (engine.isInVRExclusivePointerMode) {\n          return;\n        }\n\n        if (!_this.touchEnabled && isTouch) {\n          return;\n        }\n\n        if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n          return;\n        }\n\n        var srcElement = evt.srcElement || evt.target;\n\n        if (p.type === PointerEventTypes.POINTERDOWN && (_this._currentActiveButton === -1 || isTouch)) {\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n          } catch (e) {//Nothing to do with the error. Execution will continue.\n          }\n\n          if (_this._currentActiveButton === -1) {\n            _this._currentActiveButton = evt.button;\n          }\n\n          _this._previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n\n          if (!noPreventDefault) {\n            evt.preventDefault();\n            element && element.focus();\n          } // This is required to move while pointer button is down\n\n\n          if (engine.isPointerLock && _this._onMouseMove) {\n            _this._onMouseMove(p.event);\n          }\n        } else if (p.type === PointerEventTypes.POINTERUP && (_this._currentActiveButton === evt.button || isTouch)) {\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n          } catch (e) {//Nothing to do with the error.\n          }\n\n          _this._currentActiveButton = -1;\n          _this._previousPosition = null;\n\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (engine.isPointerLock && _this._onMouseMove) {\n            _this._onMouseMove(p.event);\n          } else if (_this._previousPosition) {\n            var offsetX = evt.clientX - _this._previousPosition.x;\n            var offsetY = evt.clientY - _this._previousPosition.y;\n\n            if (_this.camera.getScene().useRightHandedSystem) {\n              offsetX *= -1;\n            }\n\n            if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {\n              offsetX *= -1;\n            }\n\n            if (_this._allowCameraRotation) {\n              _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n              _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n            }\n\n            _this.onPointerMovedObservable.notifyObservers({\n              offsetX: offsetX,\n              offsetY: offsetY\n            });\n\n            _this._previousPosition = {\n              x: evt.clientX,\n              y: evt.clientY\n            };\n\n            if (!noPreventDefault) {\n              evt.preventDefault();\n            }\n          }\n        }\n      };\n    }\n\n    this._onMouseMove = function (evt) {\n      if (!engine.isPointerLock) {\n        return;\n      }\n\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n\n      var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n\n      if (_this.camera.getScene().useRightHandedSystem) {\n        offsetX *= -1;\n      }\n\n      if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {\n        offsetX *= -1;\n      }\n\n      _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n      var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n      _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n      _this._previousPosition = null;\n\n      if (!noPreventDefault) {\n        evt.preventDefault();\n      }\n    };\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    if (element) {\n      this._contextMenuBind = this.onContextMenu.bind(this);\n      element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\n    }\n  };\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n\n\n  FreeCameraMouseInput.prototype.onContextMenu = function (evt) {\n    evt.preventDefault();\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  FreeCameraMouseInput.prototype.detachControl = function () {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n\n      if (this._contextMenuBind) {\n        var engine = this.camera.getEngine();\n        var element = engine.getInputElement();\n        element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n\n      if (this.onPointerMovedObservable) {\n        this.onPointerMovedObservable.clear();\n      }\n\n      this._observer = null;\n      this._onMouseMove = null;\n      this._previousPosition = null;\n    }\n\n    this._currentActiveButton = -1;\n  };\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n\n\n  FreeCameraMouseInput.prototype.getClassName = function () {\n    return \"FreeCameraMouseInput\";\n  };\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n\n\n  FreeCameraMouseInput.prototype.getSimpleName = function () {\n    return \"mouse\";\n  };\n\n  __decorate([serialize()], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\n\n  return FreeCameraMouseInput;\n}();\n\nexport { FreeCameraMouseInput };\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;","map":{"version":3,"mappings":"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","names":["Observable","serialize","CameraInputTypes","PointerEventTypes","Tools","touchEnabled","FreeCameraMouseInput","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","camera","getEngine","element","getInputElement","_pointerInput","p","evt","event","isTouch","pointerType","isInVRExclusivePointerMode","_this","type","POINTERMOVE","buttons","indexOf","button","srcElement","target","POINTERDOWN","_currentActiveButton","setPointerCapture","pointerId","e","_previousPosition","x","clientX","y","clientY","preventDefault","focus","isPointerLock","_onMouseMove","POINTERUP","releasePointerCapture","offsetX","offsetY","getScene","useRightHandedSystem","parent","_getWorldMatrixDeterminant","_allowCameraRotation","cameraRotation","angularSensibility","onPointerMovedObservable","notifyObservers","movementX","mozMovementX","webkitMovementX","msMovementX","movementY","mozMovementY","webkitMovementY","msMovementY","_observer","onPointerObservable","add","_contextMenuBind","onContextMenu","bind","addEventListener","remove","removeEventListener","clear","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/freeCameraMouseInput.ts"],"sourcesContent":["import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @hidden\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n\r\n    private _contextMenuBind: () => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (engine.isInVRExclusivePointerMode) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>(evt.srcElement || evt.target);\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        let offsetX = evt.clientX - this._previousPosition.x;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n                        if (this.camera.getScene().useRightHandedSystem) {\r\n                            offsetX *= -1;\r\n                        }\r\n                        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                            offsetX *= -1;\r\n                        }\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            let offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\r\n            if (this.camera.getScene().useRightHandedSystem) {\r\n                offsetX *= -1;\r\n            }\r\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                offsetX *= -1;\r\n            }\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            .onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = this.onContextMenu.bind(this);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n"]},"metadata":{},"sourceType":"module"}