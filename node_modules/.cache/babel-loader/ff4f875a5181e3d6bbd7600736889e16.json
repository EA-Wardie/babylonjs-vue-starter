{"ast":null,"code":"import \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport { DomManagement } from \"../../Misc/domManagement.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { DeviceEventFactory } from \"../Helpers/eventFactory.js\";\nimport { DeviceType, PointerInput } from \"./deviceEnums.js\"; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar MAX_KEYCODES = 255; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\n/** @hidden */\n\nvar WebDeviceInputSystem =\n/** @class */\nfunction () {\n  function WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {\n    var _this = this; // Private Members\n\n\n    this._inputs = [];\n    this._keyboardActive = false;\n    this._pointerActive = false;\n    this._usingSafari = Tools.IsSafari(); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._keyboardDownEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._keyboardUpEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._keyboardBlurEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerMoveEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerDownEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerUpEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerCancelEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerWheelEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._pointerBlurEvent = function (evt) {};\n\n    this._eventsAttached = false;\n    this._mouseId = -1;\n    this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\n    this._maxTouchPoints = 0;\n    this._pointerInputClearObserver = null; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._gamepadConnectedEvent = function (evt) {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._gamepadDisconnectedEvent = function (evt) {};\n\n    this._eventPrefix = Tools.GetPointerPrefix(engine);\n    this._engine = engine;\n    this._onDeviceConnected = onDeviceConnected;\n    this._onDeviceDisconnected = onDeviceDisconnected;\n    this._onInputChanged = onInputChanged;\n\n    this._enableEvents(); // Set callback to enable event handler switching when inputElement changes\n\n\n    if (!this._engine._onEngineViewChanged) {\n      this._engine._onEngineViewChanged = function () {\n        _this._enableEvents();\n      };\n    }\n  } // Public functions\n\n  /**\n   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   * @returns Current value of input\n   */\n\n\n  WebDeviceInputSystem.prototype.pollInput = function (deviceType, deviceSlot, inputIndex) {\n    var device = this._inputs[deviceType][deviceSlot];\n\n    if (!device) {\n      throw \"Unable to find device \".concat(DeviceType[deviceType]);\n    }\n\n    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense && navigator.getGamepads) {\n      this._updateDevice(deviceType, deviceSlot, inputIndex);\n    }\n\n    var currentValue = device[inputIndex];\n\n    if (currentValue === undefined) {\n      throw \"Unable to find input \".concat(inputIndex, \" for device \").concat(DeviceType[deviceType], \" in slot \").concat(deviceSlot);\n    }\n\n    if (inputIndex === PointerInput.Move) {\n      Tools.Warn(\"Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.\");\n    }\n\n    return currentValue;\n  };\n  /**\n   * Check for a specific device in the DeviceInputSystem\n   * @param deviceType Type of device to check for\n   * @returns bool with status of device's existence\n   */\n\n\n  WebDeviceInputSystem.prototype.isDeviceAvailable = function (deviceType) {\n    return this._inputs[deviceType] !== undefined;\n  };\n  /**\n   * Dispose of all the eventlisteners\n   */\n\n\n  WebDeviceInputSystem.prototype.dispose = function () {\n    // Callbacks\n    this._onDeviceConnected = function () {};\n\n    this._onDeviceDisconnected = function () {};\n\n    this._onInputChanged = function () {};\n\n    delete this._engine._onEngineViewChanged;\n\n    if (this._elementToAttachTo) {\n      this._disableEvents();\n    }\n  };\n  /**\n   * Enable listening for user input events\n   */\n\n\n  WebDeviceInputSystem.prototype._enableEvents = function () {\n    var inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();\n\n    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\n      // Remove events before adding to avoid double events or simultaneous events on multiple canvases\n      this._disableEvents(); // If the inputs array has already been created, zero it out to before setting up events\n\n\n      if (this._inputs) {\n        for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {\n          var inputs = _a[_i];\n\n          if (inputs) {\n            for (var deviceSlotKey in inputs) {\n              var deviceSlot = +deviceSlotKey;\n              var device = inputs[deviceSlot];\n\n              if (device) {\n                for (var inputIndex = 0; inputIndex < device.length; inputIndex++) {\n                  device[inputIndex] = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      this._elementToAttachTo = inputElement; // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\n\n      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\n\n      this._handleKeyActions();\n\n      this._handlePointerActions();\n\n      this._handleGamepadActions();\n\n      this._eventsAttached = true; // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\n\n      this._checkForConnectedDevices();\n    }\n  };\n  /**\n   * Disable listening for user input events\n   */\n\n\n  WebDeviceInputSystem.prototype._disableEvents = function () {\n    if (this._elementToAttachTo) {\n      // Blur Events\n      this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\n\n      this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent); // Keyboard Events\n\n\n      this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\n\n      this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent); // Pointer Events\n\n\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n\n      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent); // Gamepad Events\n\n\n      window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n      window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n    }\n\n    if (this._pointerInputClearObserver) {\n      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\n    }\n\n    this._eventsAttached = false;\n  };\n  /**\n   * Checks for existing connections to devices and register them, if necessary\n   * Currently handles gamepads and mouse\n   */\n\n\n  WebDeviceInputSystem.prototype._checkForConnectedDevices = function () {\n    if (navigator.getGamepads) {\n      var gamepads = navigator.getGamepads();\n\n      for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {\n        var gamepad = gamepads_1[_i];\n\n        if (gamepad) {\n          this._addGamePad(gamepad);\n        }\n      }\n    } // If the device in use has mouse capabilities, pre-register mouse\n\n\n    if (matchMedia(\"(pointer:fine)\").matches) {\n      // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\n      // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\n      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\n    }\n  }; // Private functions\n\n  /**\n   * Add a gamepad to the DeviceInputSystem\n   * @param gamepad A single DOM Gamepad object\n   */\n\n\n  WebDeviceInputSystem.prototype._addGamePad = function (gamepad) {\n    var deviceType = this._getGamepadDeviceType(gamepad.id);\n\n    var deviceSlot = gamepad.index;\n    this._gamepads = this._gamepads || new Array(gamepad.index + 1);\n\n    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\n\n    this._gamepads[deviceSlot] = deviceType;\n  };\n  /**\n   * Add pointer device to DeviceInputSystem\n   * @param deviceType Type of Pointer to add\n   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\n   * @param currentX Current X at point of adding\n   * @param currentY Current Y at point of adding\n   */\n\n\n  WebDeviceInputSystem.prototype._addPointerDevice = function (deviceType, deviceSlot, currentX, currentY) {\n    if (!this._pointerActive) {\n      this._pointerActive = true;\n    }\n\n    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n\n    var pointer = this._inputs[deviceType][deviceSlot];\n    /* initialize our pointer position immediately after registration */\n\n    pointer[0] = currentX;\n    pointer[1] = currentY;\n  };\n  /**\n   * Add device and inputs to device array\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param numberOfInputs Number of input entries to create for given device\n   */\n\n\n  WebDeviceInputSystem.prototype._registerDevice = function (deviceType, deviceSlot, numberOfInputs) {\n    if (deviceSlot === undefined) {\n      throw \"Unable to register device \".concat(DeviceType[deviceType], \" to undefined slot.\");\n    }\n\n    if (!this._inputs[deviceType]) {\n      this._inputs[deviceType] = {};\n    }\n\n    if (!this._inputs[deviceType][deviceSlot]) {\n      var device = new Array(numberOfInputs);\n\n      for (var i = 0; i < numberOfInputs; i++) {\n        device[i] = 0;\n        /* set device input as unpressed */\n      }\n\n      this._inputs[deviceType][deviceSlot] = device;\n\n      this._onDeviceConnected(deviceType, deviceSlot);\n    }\n  };\n  /**\n   * Given a specific device name, remove that device from the device map\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   */\n\n\n  WebDeviceInputSystem.prototype._unregisterDevice = function (deviceType, deviceSlot) {\n    if (this._inputs[deviceType][deviceSlot]) {\n      delete this._inputs[deviceType][deviceSlot];\n\n      this._onDeviceDisconnected(deviceType, deviceSlot);\n    }\n  };\n  /**\n   * Handle all actions that come from keyboard interaction\n   */\n\n\n  WebDeviceInputSystem.prototype._handleKeyActions = function () {\n    var _this = this;\n\n    this._keyboardDownEvent = function (evt) {\n      if (!_this._keyboardActive) {\n        _this._keyboardActive = true;\n\n        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n\n      var kbKey = _this._inputs[DeviceType.Keyboard][0];\n\n      if (kbKey) {\n        kbKey[evt.keyCode] = 1;\n        var deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n\n        _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n\n    this._keyboardUpEvent = function (evt) {\n      if (!_this._keyboardActive) {\n        _this._keyboardActive = true;\n\n        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n\n      var kbKey = _this._inputs[DeviceType.Keyboard][0];\n\n      if (kbKey) {\n        kbKey[evt.keyCode] = 0;\n        var deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n\n        _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n\n    this._keyboardBlurEvent = function () {\n      if (_this._keyboardActive) {\n        var kbKey = _this._inputs[DeviceType.Keyboard][0];\n\n        for (var i = 0; i < kbKey.length; i++) {\n          if (kbKey[i] !== 0) {\n            kbKey[i] = 0;\n            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, _this, _this._elementToAttachTo);\n\n            _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n        }\n      }\n    };\n\n    this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\n\n    this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\n\n    this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\n  };\n  /**\n   * Handle all actions that come from pointer interaction\n   */\n\n\n  WebDeviceInputSystem.prototype._handlePointerActions = function () {\n    var _this = this; // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\n\n\n    this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;\n\n    if (!this._activeTouchIds) {\n      this._activeTouchIds = new Array(this._maxTouchPoints);\n    }\n\n    for (var i = 0; i < this._maxTouchPoints; i++) {\n      this._activeTouchIds[i] = -1;\n    }\n\n    this._pointerMoveEvent = function (evt) {\n      var deviceType = _this._getPointerType(evt);\n\n      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);\n\n      if (!_this._inputs[deviceType]) {\n        _this._inputs[deviceType] = {};\n      }\n\n      if (!_this._inputs[deviceType][deviceSlot]) {\n        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      }\n\n      var pointer = _this._inputs[deviceType][deviceSlot];\n\n      if (pointer) {\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        var deviceEvent = evt;\n        deviceEvent.inputIndex = PointerInput.Move;\n\n        _this._onInputChanged(deviceType, deviceSlot, deviceEvent); // Lets Propagate the event for move with same position.\n\n\n        if (!_this._usingSafari && evt.button !== -1) {\n          deviceEvent.inputIndex = evt.button + 2;\n          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n\n    this._pointerDownEvent = function (evt) {\n      var deviceType = _this._getPointerType(evt);\n\n      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\n\n      if (deviceType === DeviceType.Touch) {\n        var idx = _this._activeTouchIds.indexOf(-1);\n\n        if (idx >= 0) {\n          deviceSlot = idx;\n          _this._activeTouchIds[idx] = evt.pointerId;\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(\"Max number of touches exceeded.  Ignoring touches in excess of \".concat(_this._maxTouchPoints));\n          return;\n        }\n      }\n\n      if (!_this._inputs[deviceType]) {\n        _this._inputs[deviceType] = {};\n      }\n\n      if (!_this._inputs[deviceType][deviceSlot]) {\n        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      } else if (deviceType === DeviceType.Touch) {\n        _this._onDeviceConnected(deviceType, deviceSlot);\n      }\n\n      var pointer = _this._inputs[deviceType][deviceSlot];\n\n      if (pointer) {\n        var previousHorizontal = pointer[PointerInput.Horizontal];\n        var previousVertical = pointer[PointerInput.Vertical];\n\n        if (deviceType === DeviceType.Mouse) {\n          // Mouse; Among supported browsers, value is either 1 or 0 for mouse\n          if (_this._mouseId === -1) {\n            if (evt.pointerId === undefined) {\n              // If there is no pointerId (eg. manually dispatched MouseEvent)\n              _this._mouseId = _this._isUsingFirefox ? 0 : 1;\n            } else {\n              _this._mouseId = evt.pointerId;\n            }\n          }\n\n          if (!document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {\n            try {\n              _this._elementToAttachTo.setPointerCapture(_this._mouseId);\n            } catch (e) {// DO NOTHING\n            }\n          }\n        } else {\n          // Touch; Since touches are dynamically assigned, only set capture if we have an id\n          if (evt.pointerId && !document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {\n            try {\n              _this._elementToAttachTo.setPointerCapture(evt.pointerId);\n            } catch (e) {// DO NOTHING\n            }\n          }\n        }\n\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 1;\n        var deviceEvent = evt; // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n\n        deviceEvent.inputIndex = evt.button + 2;\n\n        _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n\n    this._pointerUpEvent = function (evt) {\n      var _a, _b, _c, _d, _e;\n\n      var deviceType = _this._getPointerType(evt);\n\n      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);\n\n      if (deviceType === DeviceType.Touch) {\n        if (deviceSlot === -1) {\n          return;\n        } else {\n          _this._activeTouchIds[deviceSlot] = -1;\n        }\n      }\n\n      var pointer = (_a = _this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];\n\n      if (pointer && pointer[evt.button + 2] !== 0) {\n        var previousHorizontal = pointer[PointerInput.Horizontal];\n        var previousVertical = pointer[PointerInput.Vertical];\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 0;\n        var deviceEvent = evt;\n\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        } // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n\n\n        deviceEvent.inputIndex = evt.button + 2;\n\n        if (deviceType === DeviceType.Mouse && _this._mouseId >= 0 && ((_c = (_b = _this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, _this._mouseId))) {\n          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);\n        } else if (evt.pointerId && ((_e = (_d = _this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {\n          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n\n        _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n\n        if (deviceType === DeviceType.Touch) {\n          _this._onDeviceDisconnected(deviceType, deviceSlot);\n        }\n      }\n    };\n\n    this._pointerCancelEvent = function (evt) {\n      var _a, _b, _c, _d;\n\n      if (evt.pointerType === \"mouse\") {\n        var pointer = _this._inputs[DeviceType.Mouse][0];\n\n        if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {\n          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);\n        }\n\n        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);\n\n            _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      } else {\n        var deviceSlot = _this._activeTouchIds.indexOf(evt.pointerId);\n\n        if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {\n          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n\n        _this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\n        var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);\n\n        _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n\n        _this._activeTouchIds[deviceSlot] = -1;\n\n        _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n      }\n    }; // Set Wheel Event Name, code originally from scene.inputManager\n\n\n    this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n    : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n    : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    // Code originally in scene.inputManager.ts\n    // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\n    // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\n    // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\n\n    var passiveSupported = false;\n\n    var noop = function noop() {};\n\n    try {\n      var options = {\n        passive: {\n          get: function get() {\n            passiveSupported = true;\n          }\n        }\n      };\n\n      this._elementToAttachTo.addEventListener(\"test\", noop, options);\n\n      this._elementToAttachTo.removeEventListener(\"test\", noop, options);\n    } catch (e) {\n      /* */\n    }\n\n    this._pointerBlurEvent = function () {\n      var _a, _b, _c, _d, _e; // Handle mouse buttons\n\n\n      if (_this.isDeviceAvailable(DeviceType.Mouse)) {\n        var pointer = _this._inputs[DeviceType.Mouse][0];\n\n        if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {\n          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);\n        }\n\n        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);\n\n            _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      } // Handle Active Touches\n\n\n      if (_this.isDeviceAvailable(DeviceType.Touch)) {\n        var pointer = _this._inputs[DeviceType.Touch];\n\n        for (var deviceSlot = 0; deviceSlot < _this._activeTouchIds.length; deviceSlot++) {\n          var pointerId = _this._activeTouchIds[deviceSlot];\n\n          if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {\n            _this._elementToAttachTo.releasePointerCapture(pointerId);\n          }\n\n          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {\n            pointer[deviceSlot][PointerInput.LeftClick] = 0;\n            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);\n\n            _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n\n            _this._activeTouchIds[deviceSlot] = -1;\n\n            _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n          }\n        }\n      }\n    };\n\n    this._pointerWheelEvent = function (evt) {\n      var deviceType = DeviceType.Mouse;\n      var deviceSlot = 0;\n\n      if (!_this._inputs[deviceType]) {\n        _this._inputs[deviceType] = [];\n      }\n\n      if (!_this._inputs[deviceType][deviceSlot]) {\n        _this._pointerActive = true;\n\n        _this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n      }\n\n      var pointer = _this._inputs[deviceType][deviceSlot];\n\n      if (pointer) {\n        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\n        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\n        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\n        var deviceEvent = evt;\n\n        if (pointer[PointerInput.MouseWheelX] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelX;\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n\n        if (pointer[PointerInput.MouseWheelY] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelY;\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n\n        if (pointer[PointerInput.MouseWheelZ] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelZ;\n\n          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n\n    this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\n\n    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? {\n      passive: false\n    } : false); // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\n\n\n    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function () {\n      if (_this.isDeviceAvailable(DeviceType.Mouse)) {\n        var pointer = _this._inputs[DeviceType.Mouse][0];\n        pointer[PointerInput.MouseWheelX] = 0;\n        pointer[PointerInput.MouseWheelY] = 0;\n        pointer[PointerInput.MouseWheelZ] = 0;\n      }\n    });\n  };\n  /**\n   * Handle all actions that come from gamepad interaction\n   */\n\n\n  WebDeviceInputSystem.prototype._handleGamepadActions = function () {\n    var _this = this;\n\n    this._gamepadConnectedEvent = function (evt) {\n      _this._addGamePad(evt.gamepad);\n    };\n\n    this._gamepadDisconnectedEvent = function (evt) {\n      if (_this._gamepads) {\n        var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);\n\n        var deviceSlot = evt.gamepad.index;\n\n        _this._unregisterDevice(deviceType, deviceSlot);\n\n        delete _this._gamepads[deviceSlot];\n      }\n    };\n\n    window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n    window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n  };\n  /**\n   * Update all non-event based devices with each frame\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   */\n\n\n  WebDeviceInputSystem.prototype._updateDevice = function (deviceType, deviceSlot, inputIndex) {\n    // Gamepads\n    var gp = navigator.getGamepads()[deviceSlot];\n\n    if (gp && deviceType === this._gamepads[deviceSlot]) {\n      var device = this._inputs[deviceType][deviceSlot];\n\n      if (inputIndex >= gp.buttons.length) {\n        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\n      } else {\n        device[inputIndex] = gp.buttons[inputIndex].value;\n      }\n    }\n  };\n  /**\n   * Gets DeviceType from the device name\n   * @param deviceName Name of Device from DeviceInputSystem\n   * @returns DeviceType enum value\n   */\n\n\n  WebDeviceInputSystem.prototype._getGamepadDeviceType = function (deviceName) {\n    if (deviceName.indexOf(\"054c\") !== -1) {\n      // DualShock 4 Gamepad\n      return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\n    } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\n      // Xbox Gamepad\n      return DeviceType.Xbox;\n    } else if (deviceName.indexOf(\"057e\") !== -1) {\n      // Switch Gamepad\n      return DeviceType.Switch;\n    }\n\n    return DeviceType.Generic;\n  };\n  /**\n   * Get DeviceType from a given pointer/mouse/touch event.\n   * @param evt PointerEvent to evaluate\n   * @returns DeviceType interpreted from event\n   */\n\n\n  WebDeviceInputSystem.prototype._getPointerType = function (evt) {\n    var deviceType = DeviceType.Mouse;\n\n    if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\n      deviceType = DeviceType.Touch;\n    }\n\n    return deviceType;\n  };\n\n  return WebDeviceInputSystem;\n}();\n\nexport { WebDeviceInputSystem };","map":{"version":3,"mappings":"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","names":["DomManagement","Tools","DeviceEventFactory","DeviceType","PointerInput","MAX_KEYCODES","MAX_POINTER_INPUTS","Object","keys","length","engine","onDeviceConnected","onDeviceDisconnected","onInputChanged","IsSafari","evt","IsNavigatorAvailable","navigator","userAgent","indexOf","_eventPrefix","GetPointerPrefix","_engine","_onDeviceConnected","_onDeviceDisconnected","_onInputChanged","_enableEvents","_onEngineViewChanged","_this","WebDeviceInputSystem","deviceType","deviceSlot","inputIndex","device","_inputs","DualShock","DualSense","getGamepads","_updateDevice","currentValue","undefined","concat","Move","Warn","_elementToAttachTo","_disableEvents","inputElement","getInputElement","_eventsAttached","_i","inputs","deviceSlotKey","tabIndex","canvasTabIndex","_handleKeyActions","_handlePointerActions","_handleGamepadActions","_checkForConnectedDevices","removeEventListener","_keyboardBlurEvent","_pointerBlurEvent","_keyboardDownEvent","_keyboardUpEvent","_pointerMoveEvent","_pointerDownEvent","_pointerUpEvent","_pointerCancelEvent","_wheelEventName","_pointerWheelEvent","window","_gamepadConnectedEvent","_gamepadDisconnectedEvent","_pointerInputClearObserver","onEndFrameObservable","remove","gamepads","gamepad","_addGamePad","matchMedia","matches","_addPointerDevice","Mouse","_getGamepadDeviceType","id","index","_gamepads","Array","_registerDevice","buttons","axes","currentX","currentY","_pointerActive","pointer","numberOfInputs","i","_keyboardActive","Keyboard","kbKey","keyCode","deviceEvent","CreateDeviceEvent","addEventListener","_maxTouchPoints","maxTouchPoints","_activeTouchIds","_getPointerType","pointerId","clientX","clientY","Horizontal","Vertical","_usingSafari","button","Touch","idx","previousHorizontal","previousVertical","_mouseId","_isUsingFirefox","document","pointerLockElement","hasPointerCapture","setPointerCapture","e","_a","_c","releasePointerCapture","_e","pointerType","_b","LeftClick","BrowserForward","_d","createElement","onmousewheel","passiveSupported","noop","options","passive","get","isDeviceAvailable","MouseWheelX","deltaX","MouseWheelY","deltaY","wheelDelta","MouseWheelZ","deltaZ","add","_unregisterDevice","gp","valueOf","value","deviceName","search","Xbox","Switch","Generic","touches"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/DeviceInput/InputDevices/webDeviceInputSystem.ts"],"sourcesContent":["import type { Engine } from \"../../Engines/engine\";\r\nimport type { IUIEvent } from \"../../Events/deviceInputEvents\";\r\nimport { DomManagement } from \"../../Misc/domManagement\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { DeviceEventFactory } from \"../Helpers/eventFactory\";\r\nimport { DeviceType, PointerInput } from \"./deviceEnums\";\r\nimport type { IDeviceInputSystem } from \"./inputInterfaces\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_KEYCODES = 255;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\r\n\r\n/** @hidden */\r\nexport class WebDeviceInputSystem implements IDeviceInputSystem {\r\n    // Private Members\r\n    private _inputs: Array<{ [deviceSlot: number]: Array<number> }> = [];\r\n    private _gamepads: Array<DeviceType>;\r\n    private _keyboardActive: boolean = false;\r\n    private _pointerActive: boolean = false;\r\n    private _elementToAttachTo: HTMLElement;\r\n    private readonly _engine: Engine;\r\n    private readonly _usingSafari: boolean = Tools.IsSafari();\r\n\r\n    private _onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardBlurEvent = (evt: any) => {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerMoveEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerCancelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerWheelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerBlurEvent = (evt: any) => {};\r\n    private _wheelEventName: string;\r\n    private _eventsAttached: boolean = false;\r\n\r\n    private _mouseId = -1;\r\n    private readonly _isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\r\n\r\n    // Array to store active Pointer ID values; prevents issues with negative pointerIds\r\n    private _activeTouchIds: Array<number>;\r\n    private _maxTouchPoints: number = 0;\r\n\r\n    private _pointerInputClearObserver: Nullable<Observer<Engine>> = null;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadConnectedEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadDisconnectedEvent = (evt: any) => {};\r\n\r\n    private _eventPrefix: string;\r\n\r\n    constructor(\r\n        engine: Engine,\r\n        onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void\r\n    ) {\r\n        this._eventPrefix = Tools.GetPointerPrefix(engine);\r\n        this._engine = engine;\r\n\r\n        this._onDeviceConnected = onDeviceConnected;\r\n        this._onDeviceDisconnected = onDeviceDisconnected;\r\n        this._onInputChanged = onInputChanged;\r\n\r\n        this._enableEvents();\r\n\r\n        // Set callback to enable event handler switching when inputElement changes\r\n        if (!this._engine._onEngineViewChanged) {\r\n            this._engine._onEngineViewChanged = () => {\r\n                this._enableEvents();\r\n            };\r\n        }\r\n    }\r\n\r\n    // Public functions\r\n    /**\r\n     * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     * @returns Current value of input\r\n     */\r\n    public pollInput(deviceType: DeviceType, deviceSlot: number, inputIndex: number): number {\r\n        const device = this._inputs[deviceType][deviceSlot];\r\n\r\n        if (!device) {\r\n            throw `Unable to find device ${DeviceType[deviceType]}`;\r\n        }\r\n\r\n        if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense && navigator.getGamepads) {\r\n            this._updateDevice(deviceType, deviceSlot, inputIndex);\r\n        }\r\n\r\n        const currentValue = device[inputIndex];\r\n        if (currentValue === undefined) {\r\n            throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\r\n        }\r\n\r\n        if (inputIndex === PointerInput.Move) {\r\n            Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\r\n        }\r\n\r\n        return currentValue;\r\n    }\r\n\r\n    /**\r\n     * Check for a specific device in the DeviceInputSystem\r\n     * @param deviceType Type of device to check for\r\n     * @returns bool with status of device's existence\r\n     */\r\n    public isDeviceAvailable(deviceType: DeviceType): boolean {\r\n        return this._inputs[deviceType] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Dispose of all the eventlisteners\r\n     */\r\n    public dispose(): void {\r\n        // Callbacks\r\n        this._onDeviceConnected = () => {};\r\n        this._onDeviceDisconnected = () => {};\r\n        this._onInputChanged = () => {};\r\n        delete this._engine._onEngineViewChanged;\r\n\r\n        if (this._elementToAttachTo) {\r\n            this._disableEvents();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable listening for user input events\r\n     */\r\n    private _enableEvents(): void {\r\n        const inputElement = this?._engine.getInputElement();\r\n        if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\r\n            // Remove events before adding to avoid double events or simultaneous events on multiple canvases\r\n            this._disableEvents();\r\n\r\n            // If the inputs array has already been created, zero it out to before setting up events\r\n            if (this._inputs) {\r\n                for (const inputs of this._inputs) {\r\n                    if (inputs) {\r\n                        for (const deviceSlotKey in inputs) {\r\n                            const deviceSlot = +deviceSlotKey;\r\n                            const device = inputs[deviceSlot];\r\n                            if (device) {\r\n                                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\r\n                                    device[inputIndex] = 0;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._elementToAttachTo = inputElement;\r\n            // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\r\n            this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\r\n            this._handleKeyActions();\r\n            this._handlePointerActions();\r\n            this._handleGamepadActions();\r\n            this._eventsAttached = true;\r\n\r\n            // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\r\n            this._checkForConnectedDevices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable listening for user input events\r\n     */\r\n    private _disableEvents(): void {\r\n        if (this._elementToAttachTo) {\r\n            // Blur Events\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\r\n\r\n            // Keyboard Events\r\n            this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\r\n            this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\r\n\r\n            // Pointer Events\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n            this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\r\n\r\n            // Gamepad Events\r\n            window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n            window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n        }\r\n\r\n        if (this._pointerInputClearObserver) {\r\n            this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\r\n        }\r\n\r\n        this._eventsAttached = false;\r\n    }\r\n\r\n    /**\r\n     * Checks for existing connections to devices and register them, if necessary\r\n     * Currently handles gamepads and mouse\r\n     */\r\n    private _checkForConnectedDevices(): void {\r\n        if (navigator.getGamepads) {\r\n            const gamepads = navigator.getGamepads();\r\n\r\n            for (const gamepad of gamepads) {\r\n                if (gamepad) {\r\n                    this._addGamePad(gamepad);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the device in use has mouse capabilities, pre-register mouse\r\n        if (matchMedia(\"(pointer:fine)\").matches) {\r\n            // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\r\n            // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\r\n            this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    // Private functions\r\n    /**\r\n     * Add a gamepad to the DeviceInputSystem\r\n     * @param gamepad A single DOM Gamepad object\r\n     */\r\n    private _addGamePad(gamepad: any): void {\r\n        const deviceType = this._getGamepadDeviceType(gamepad.id);\r\n        const deviceSlot = gamepad.index;\r\n\r\n        this._gamepads = this._gamepads || new Array<DeviceType>(gamepad.index + 1);\r\n        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\r\n\r\n        this._gamepads[deviceSlot] = deviceType;\r\n    }\r\n\r\n    /**\r\n     * Add pointer device to DeviceInputSystem\r\n     * @param deviceType Type of Pointer to add\r\n     * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\r\n     * @param currentX Current X at point of adding\r\n     * @param currentY Current Y at point of adding\r\n     */\r\n    private _addPointerDevice(deviceType: DeviceType, deviceSlot: number, currentX: number, currentY: number): void {\r\n        if (!this._pointerActive) {\r\n            this._pointerActive = true;\r\n        }\r\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n        const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\r\n        pointer[0] = currentX;\r\n        pointer[1] = currentY;\r\n    }\r\n\r\n    /**\r\n     * Add device and inputs to device array\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param numberOfInputs Number of input entries to create for given device\r\n     */\r\n    private _registerDevice(deviceType: DeviceType, deviceSlot: number, numberOfInputs: number): void {\r\n        if (deviceSlot === undefined) {\r\n            throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\r\n        }\r\n\r\n        if (!this._inputs[deviceType]) {\r\n            this._inputs[deviceType] = {};\r\n        }\r\n\r\n        if (!this._inputs[deviceType][deviceSlot]) {\r\n            const device = new Array<number>(numberOfInputs);\r\n\r\n            for (let i = 0; i < numberOfInputs; i++) {\r\n                device[i] = 0; /* set device input as unpressed */\r\n            }\r\n\r\n            this._inputs[deviceType][deviceSlot] = device;\r\n            this._onDeviceConnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a specific device name, remove that device from the device map\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     */\r\n    private _unregisterDevice(deviceType: DeviceType, deviceSlot: number): void {\r\n        if (this._inputs[deviceType][deviceSlot]) {\r\n            delete this._inputs[deviceType][deviceSlot];\r\n            this._onDeviceDisconnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from keyboard interaction\r\n     */\r\n    private _handleKeyActions(): void {\r\n        this._keyboardDownEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardUpEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardBlurEvent = () => {\r\n            if (this._keyboardActive) {\r\n                const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n\r\n                for (let i = 0; i < kbKey.length; i++) {\r\n                    if (kbKey[i] !== 0) {\r\n                        kbKey[i] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\r\n        this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from pointer interaction\r\n     */\r\n    private _handlePointerActions(): void {\r\n        // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\r\n        this._maxTouchPoints = (DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints) || 2;\r\n        if (!this._activeTouchIds) {\r\n            this._activeTouchIds = new Array<number>(this._maxTouchPoints);\r\n        }\r\n\r\n        for (let i = 0; i < this._maxTouchPoints; i++) {\r\n            this._activeTouchIds[i] = -1;\r\n        }\r\n\r\n        this._pointerMoveEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = PointerInput.Move;\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                // Lets Propagate the event for move with same position.\r\n                if (!this._usingSafari && evt.button !== -1) {\r\n                    deviceEvent.inputIndex = evt.button + 2;\r\n                    pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerDownEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                const idx = this._activeTouchIds.indexOf(-1);\r\n\r\n                if (idx >= 0) {\r\n                    deviceSlot = idx;\r\n                    this._activeTouchIds[idx] = evt.pointerId;\r\n                } else {\r\n                    // We can't find an open slot to store new pointer so just return (can only support max number of touches)\r\n                    Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            } else if (deviceType === DeviceType.Touch) {\r\n                this._onDeviceConnected(deviceType, deviceSlot);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                if (deviceType === DeviceType.Mouse) {\r\n                    // Mouse; Among supported browsers, value is either 1 or 0 for mouse\r\n                    if (this._mouseId === -1) {\r\n                        if (evt.pointerId === undefined) {\r\n                            // If there is no pointerId (eg. manually dispatched MouseEvent)\r\n                            this._mouseId = this._isUsingFirefox ? 0 : 1;\r\n                        } else {\r\n                            this._mouseId = evt.pointerId;\r\n                        }\r\n                    }\r\n\r\n                    if (!document.pointerLockElement && this._elementToAttachTo.hasPointerCapture) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(this._mouseId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Touch; Since touches are dynamically assigned, only set capture if we have an id\r\n                    if (evt.pointerId && !document.pointerLockElement && this._elementToAttachTo.hasPointerCapture) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(evt.pointerId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                }\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerUpEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                if (deviceSlot === -1) {\r\n                    return;\r\n                } else {\r\n                    this._activeTouchIds[deviceSlot] = -1;\r\n                }\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType]?.[deviceSlot];\r\n            if (pointer && pointer[evt.button + 2] !== 0) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (deviceType === DeviceType.Touch) {\r\n                    this._onDeviceDisconnected(deviceType, deviceSlot);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerCancelEvent = (evt) => {\r\n            if (evt.pointerType === \"mouse\") {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            } else {\r\n                const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n                if (this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\r\n\r\n                this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                this._activeTouchIds[deviceSlot] = -1;\r\n                this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n            }\r\n        };\r\n\r\n        // Set Wheel Event Name, code originally from scene.inputManager\r\n        this._wheelEventName =\r\n            \"onwheel\" in document.createElement(\"div\")\r\n                ? \"wheel\" // Modern browsers support \"wheel\"\r\n                : (<any>document).onmousewheel !== undefined\r\n                ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\r\n                : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n        // Code originally in scene.inputManager.ts\r\n        // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\r\n        // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\r\n        // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\r\n        let passiveSupported = false;\r\n        const noop = function () {};\r\n\r\n        try {\r\n            const options: object = {\r\n                passive: {\r\n                    get: function () {\r\n                        passiveSupported = true;\r\n                    },\r\n                },\r\n            };\r\n\r\n            this._elementToAttachTo.addEventListener(\"test\", noop, options);\r\n            this._elementToAttachTo.removeEventListener(\"test\", noop, options);\r\n        } catch (e) {\r\n            /* */\r\n        }\r\n\r\n        this._pointerBlurEvent = () => {\r\n            // Handle mouse buttons\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Handle Active Touches\r\n            if (this.isDeviceAvailable(DeviceType.Touch)) {\r\n                const pointer = this._inputs[DeviceType.Touch];\r\n\r\n                for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\r\n                    const pointerId = this._activeTouchIds[deviceSlot];\r\n\r\n                    if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {\r\n                        this._elementToAttachTo.releasePointerCapture(pointerId);\r\n                    }\r\n\r\n                    if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {\r\n                        pointer[deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                        this._activeTouchIds[deviceSlot] = -1;\r\n                        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerWheelEvent = (evt) => {\r\n            const deviceType = DeviceType.Mouse;\r\n            const deviceSlot = 0;\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = [];\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._pointerActive = true;\r\n                this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\r\n                pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\r\n                pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                if (pointer[PointerInput.MouseWheelX] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelX;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelY] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelY;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelZ] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelZ;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\r\n        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);\r\n\r\n        // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\r\n        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n                pointer[PointerInput.MouseWheelX] = 0;\r\n                pointer[PointerInput.MouseWheelY] = 0;\r\n                pointer[PointerInput.MouseWheelZ] = 0;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from gamepad interaction\r\n     */\r\n    private _handleGamepadActions(): void {\r\n        this._gamepadConnectedEvent = (evt: any) => {\r\n            this._addGamePad(evt.gamepad);\r\n        };\r\n\r\n        this._gamepadDisconnectedEvent = (evt: any) => {\r\n            if (this._gamepads) {\r\n                const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\r\n                const deviceSlot = evt.gamepad.index;\r\n\r\n                this._unregisterDevice(deviceType, deviceSlot);\r\n                delete this._gamepads[deviceSlot];\r\n            }\r\n        };\r\n\r\n        window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n        window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n    }\r\n\r\n    /**\r\n     * Update all non-event based devices with each frame\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     */\r\n    private _updateDevice(deviceType: DeviceType, deviceSlot: number, inputIndex: number): void {\r\n        // Gamepads\r\n        const gp = navigator.getGamepads()[deviceSlot];\r\n\r\n        if (gp && deviceType === this._gamepads[deviceSlot]) {\r\n            const device = this._inputs[deviceType][deviceSlot];\r\n\r\n            if (inputIndex >= gp.buttons.length) {\r\n                device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\r\n            } else {\r\n                device[inputIndex] = gp.buttons[inputIndex].value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets DeviceType from the device name\r\n     * @param deviceName Name of Device from DeviceInputSystem\r\n     * @returns DeviceType enum value\r\n     */\r\n    private _getGamepadDeviceType(deviceName: string): DeviceType {\r\n        if (deviceName.indexOf(\"054c\") !== -1) {\r\n            // DualShock 4 Gamepad\r\n            return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\r\n        } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\r\n            // Xbox Gamepad\r\n            return DeviceType.Xbox;\r\n        } else if (deviceName.indexOf(\"057e\") !== -1) {\r\n            // Switch Gamepad\r\n            return DeviceType.Switch;\r\n        }\r\n\r\n        return DeviceType.Generic;\r\n    }\r\n\r\n    /**\r\n     * Get DeviceType from a given pointer/mouse/touch event.\r\n     * @param evt PointerEvent to evaluate\r\n     * @returns DeviceType interpreted from event\r\n     */\r\n    private _getPointerType(evt: any): DeviceType {\r\n        let deviceType = DeviceType.Mouse;\r\n\r\n        if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\r\n            deviceType = DeviceType.Touch;\r\n        }\r\n\r\n        return deviceType;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}