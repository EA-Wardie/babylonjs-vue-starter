{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport { __awaiter, __generator } from \"tslib\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools.js\";\n/**\n * Class to bake vertex animation textures.\n * @since 5.0\n */\n\nvar VertexAnimationBaker =\n/** @class */\nfunction () {\n  /**\n   * Create a new VertexAnimationBaker object which can help baking animations into a texture.\n   * @param scene Defines the scene the VAT belongs to\n   * @param mesh Defines the mesh the VAT belongs to\n   */\n  function VertexAnimationBaker(scene, mesh) {\n    this._scene = scene;\n    this._mesh = mesh;\n  }\n  /**\n   * Bakes the animation into the texture. This should be called once, when the\n   * scene starts, so the VAT is generated and associated to the mesh.\n   * @param ranges Defines the ranges in the animation that will be baked.\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n\n\n  VertexAnimationBaker.prototype.bakeVertexData = function (ranges) {\n    return __awaiter(this, void 0, void 0, function () {\n      var boneCount, frameCount, textureIndex, textureSize, vertexData, _i, ranges_1, range, frameIndex;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._mesh.skeleton) {\n              throw new Error(\"No skeleton in this mesh.\");\n            }\n\n            boneCount = this._mesh.skeleton.bones.length;\n            frameCount = ranges.reduce(function (previous, current) {\n              return previous + current.to - current.from + 1;\n            }, 0);\n\n            if (isNaN(frameCount)) {\n              throw new Error(\"Invalid animation ranges.\");\n            }\n\n            textureIndex = 0;\n            textureSize = (boneCount + 1) * 4 * 4 * frameCount;\n            vertexData = new Float32Array(textureSize);\n\n            this._scene.stopAnimation(this._mesh);\n\n            this._mesh.skeleton.returnToRest();\n\n            _i = 0, ranges_1 = ranges;\n            _a.label = 1;\n\n          case 1:\n            if (!(_i < ranges_1.length)) return [3\n            /*break*/\n            , 6];\n            range = ranges_1[_i];\n            frameIndex = range.from;\n            _a.label = 2;\n\n          case 2:\n            if (!(frameIndex <= range.to)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this._executeAnimationFrame(vertexData, frameIndex, textureIndex++)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            frameIndex++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 6:\n            return [2\n            /*return*/\n            , vertexData];\n        }\n      });\n    });\n  };\n  /**\n   * Runs an animation frame and stores its vertex data\n   *\n   * @param vertexData The array to save data to.\n   * @param frameIndex Current frame in the skeleton animation to render.\n   * @param textureIndex Current index of the texture data.\n   */\n\n\n  VertexAnimationBaker.prototype._executeAnimationFrame = function (vertexData, frameIndex, textureIndex) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, _reject) {\n          _this._scene.beginAnimation(_this._mesh.skeleton, frameIndex, frameIndex, false, 1.0, function () {\n            // generate matrices\n            var skeletonMatrices = _this._mesh.skeleton.getTransformMatrices(_this._mesh);\n\n            vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\n            resolve();\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Builds a vertex animation texture given the vertexData in an array.\n   * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\n   * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\n   */\n\n\n  VertexAnimationBaker.prototype.textureFromBakedVertexData = function (vertexData) {\n    if (!this._mesh.skeleton) {\n      throw new Error(\"No skeleton in this mesh.\");\n    }\n\n    var boneCount = this._mesh.skeleton.bones.length;\n    var texture = RawTexture.CreateRGBATexture(vertexData, (boneCount + 1) * 4, vertexData.length / ((boneCount + 1) * 4 * 4), this._scene, false, false, Texture.NEAREST_NEAREST, 1);\n    texture.name = \"VAT\" + this._mesh.skeleton.name;\n    return texture;\n  };\n  /**\n   * Serializes our vertexData to an object, with a nice string for the vertexData.\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a JS dict.\n   */\n\n\n  VertexAnimationBaker.prototype.serializeBakedVertexDataToObject = function (vertexData) {\n    if (!this._mesh.skeleton) {\n      throw new Error(\"No skeleton in this mesh.\");\n    } // this converts the float array to a serialized base64 string, ~1.3x larger\n    // than the original.\n\n\n    var boneCount = this._mesh.skeleton.bones.length;\n    var width = (boneCount + 1) * 4;\n    var height = vertexData.length / ((boneCount + 1) * 4 * 4);\n    var data = {\n      vertexData: EncodeArrayBufferToBase64(vertexData),\n      width: width,\n      height: height\n    };\n    return data;\n  };\n  /**\n   * Loads previously baked data.\n   * @param data The object as serialized by serializeBakedVertexDataToObject()\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n\n\n  VertexAnimationBaker.prototype.loadBakedVertexDataFromObject = function (data) {\n    return new Float32Array(DecodeBase64ToBinary(data.vertexData));\n  };\n  /**\n   * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\n   * Should be called right after bakeVertexData().\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a safe string.\n   */\n\n\n  VertexAnimationBaker.prototype.serializeBakedVertexDataToJSON = function (vertexData) {\n    return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\n  };\n  /**\n   * Loads previously baked data in string format.\n   * @param json The json string as serialized by serializeBakedVertexDataToJSON().\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n\n\n  VertexAnimationBaker.prototype.loadBakedVertexDataFromJSON = function (json) {\n    return this.loadBakedVertexDataFromObject(JSON.parse(json));\n  };\n\n  return VertexAnimationBaker;\n}();\n\nexport { VertexAnimationBaker };","map":{"version":3,"mappings":"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","names":["RawTexture","Texture","EncodeArrayBufferToBase64","DecodeBase64ToBinary","scene","mesh","_scene","_mesh","VertexAnimationBaker","ranges","skeleton","Error","boneCount","bones","length","frameCount","reduce","previous","current","to","from","isNaN","textureIndex","textureSize","vertexData","Float32Array","stopAnimation","returnToRest","ranges_1","_i","range","frameIndex","_executeAnimationFrame","_a","Promise","resolve","_reject","_this","beginAnimation","skeletonMatrices","getTransformMatrices","set","texture","CreateRGBATexture","NEAREST_NEAREST","name","width","height","data","JSON","stringify","serializeBakedVertexDataToObject","json","loadBakedVertexDataFromObject","parse"],"sourceRoot":"","sources":["../../../../../lts/core/generated/BakedVertexAnimation/vertexAnimationBaker.ts"],"sourcesContent":["import type { AnimationRange } from \"../Animations/animationRange\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Class to bake vertex animation textures.\r\n * @since 5.0\r\n */\r\nexport class VertexAnimationBaker {\r\n    private _scene: Scene;\r\n    private _mesh: Mesh;\r\n\r\n    /**\r\n     * Create a new VertexAnimationBaker object which can help baking animations into a texture.\r\n     * @param scene Defines the scene the VAT belongs to\r\n     * @param mesh Defines the mesh the VAT belongs to\r\n     */\r\n    constructor(scene: Scene, mesh: Mesh) {\r\n        this._scene = scene;\r\n        this._mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Bakes the animation into the texture. This should be called once, when the\r\n     * scene starts, so the VAT is generated and associated to the mesh.\r\n     * @param ranges Defines the ranges in the animation that will be baked.\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public async bakeVertexData(ranges: AnimationRange[]): Promise<Float32Array> {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n\r\n        /** total number of frames in our animations */\r\n        const frameCount = ranges.reduce((previous: number, current: AnimationRange) => previous + current.to - current.from + 1, 0);\r\n\r\n        if (isNaN(frameCount)) {\r\n            throw new Error(\"Invalid animation ranges.\");\r\n        }\r\n\r\n        // reset our loop data\r\n        let textureIndex = 0;\r\n        const textureSize = (boneCount + 1) * 4 * 4 * frameCount;\r\n        const vertexData = new Float32Array(textureSize);\r\n        this._scene.stopAnimation(this._mesh);\r\n        this._mesh.skeleton.returnToRest();\r\n\r\n        // render all frames from our slices\r\n        for (const range of ranges) {\r\n            for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {\r\n                await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Runs an animation frame and stores its vertex data\r\n     *\r\n     * @param vertexData The array to save data to.\r\n     * @param frameIndex Current frame in the skeleton animation to render.\r\n     * @param textureIndex Current index of the texture data.\r\n     */\r\n    private async _executeAnimationFrame(vertexData: Float32Array, frameIndex: number, textureIndex: number): Promise<void> {\r\n        return new Promise<void>((resolve, _reject) => {\r\n            this._scene.beginAnimation(this._mesh.skeleton, frameIndex, frameIndex, false, 1.0, () => {\r\n                // generate matrices\r\n                const skeletonMatrices = this._mesh.skeleton!.getTransformMatrices(this._mesh);\r\n                vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\r\n\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Builds a vertex animation texture given the vertexData in an array.\r\n     * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\r\n     * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\r\n     */\r\n    public textureFromBakedVertexData(vertexData: Float32Array): RawTexture {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n\r\n        const texture = RawTexture.CreateRGBATexture(\r\n            vertexData,\r\n            (boneCount + 1) * 4,\r\n            vertexData.length / ((boneCount + 1) * 4 * 4),\r\n            this._scene,\r\n            false,\r\n            false,\r\n            Texture.NEAREST_NEAREST,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        texture.name = \"VAT\" + this._mesh.skeleton.name;\r\n        return texture;\r\n    }\r\n    /**\r\n     * Serializes our vertexData to an object, with a nice string for the vertexData.\r\n     * @param vertexData The vertex array data.\r\n     * @returns This object serialized to a JS dict.\r\n     */\r\n    public serializeBakedVertexDataToObject(vertexData: Float32Array): Record<string, any> {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n\r\n        // this converts the float array to a serialized base64 string, ~1.3x larger\r\n        // than the original.\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n        const width = (boneCount + 1) * 4;\r\n        const height = vertexData.length / ((boneCount + 1) * 4 * 4);\r\n        const data = {\r\n            vertexData: EncodeArrayBufferToBase64(vertexData),\r\n            width,\r\n            height,\r\n        };\r\n        return data;\r\n    }\r\n    /**\r\n     * Loads previously baked data.\r\n     * @param data The object as serialized by serializeBakedVertexDataToObject()\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public loadBakedVertexDataFromObject(data: Record<string, any>): Float32Array {\r\n        return new Float32Array(DecodeBase64ToBinary(data.vertexData));\r\n    }\r\n    /**\r\n     * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\r\n     * Should be called right after bakeVertexData().\r\n     * @param vertexData The vertex array data.\r\n     * @returns This object serialized to a safe string.\r\n     */\r\n    public serializeBakedVertexDataToJSON(vertexData: Float32Array): string {\r\n        return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\r\n    }\r\n    /**\r\n     * Loads previously baked data in string format.\r\n     * @param json The json string as serialized by serializeBakedVertexDataToJSON().\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public loadBakedVertexDataFromJSON(json: string): Float32Array {\r\n        return this.loadBakedVertexDataFromObject(JSON.parse(json));\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}