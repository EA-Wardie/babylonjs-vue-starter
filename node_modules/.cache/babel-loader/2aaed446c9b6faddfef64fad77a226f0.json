{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration.js\";\nimport \"../Shaders/screenSpaceReflection.fragment.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\n */\n\nvar ScreenSpaceReflectionPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(ScreenSpaceReflectionPostProcess, _super);\n  /**\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to calculate reflections.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n\n\n  function ScreenSpaceReflectionPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = false;\n    }\n\n    var _this = _super.call(this, name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation) || this;\n    /**\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\n     */\n\n\n    _this.threshold = 1.2;\n    /**\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\n     */\n\n    _this.strength = 1;\n    /**\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\n     */\n\n    _this.reflectionSpecularFalloffExponent = 3;\n    /**\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\n     */\n\n    _this.step = 1.0;\n    /**\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\n     */\n\n    _this.roughnessFactor = 0.2;\n    _this._forceGeometryBuffer = false;\n    _this._enableSmoothReflections = false;\n    _this._reflectionSamples = 64;\n    _this._smoothSteps = 5;\n    _this._forceGeometryBuffer = forceGeometryBuffer;\n\n    if (_this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      var geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n        }\n      }\n    } else {\n      var prePassRenderer = scene.enablePrePassRenderer();\n      prePassRenderer === null || prePassRenderer === void 0 ? void 0 : prePassRenderer.markAsDirty();\n      _this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n\n    _this._updateEffectDefines(); // On apply, send uniforms\n\n\n    _this.onApply = function (effect) {\n      var geometryBufferRenderer = _this._geometryBufferRenderer;\n      var prePassRenderer = _this._prePassRenderer;\n\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n\n      if (geometryBufferRenderer) {\n        // Samplers\n        var positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        var roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else if (prePassRenderer) {\n        // Samplers\n        var positionIndex = prePassRenderer.getIndex(1);\n        var roughnessIndex = prePassRenderer.getIndex(3);\n        var normalIndex = prePassRenderer.getIndex(6);\n        effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n      } // Uniforms\n\n\n      var camera = scene.activeCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      var viewMatrix = camera.getViewMatrix(true);\n      var projectionMatrix = camera.getProjectionMatrix(true);\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", _this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", _this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", _this.strength);\n      effect.setFloat(\"stepSize\", _this.step);\n      effect.setFloat(\"roughnessFactor\", _this.roughnessFactor);\n    };\n\n    _this._isSceneRightHanded = scene.useRightHandedSystem;\n    return _this;\n  }\n\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"_geometryBufferRenderer\", {\n    get: function get() {\n      if (!this._forceGeometryBuffer) {\n        return null;\n      }\n\n      return this._scene.geometryBufferRenderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"_prePassRenderer\", {\n    get: function get() {\n      if (this._forceGeometryBuffer) {\n        return null;\n      }\n\n      return this._scene.prePassRenderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\n   */\n\n  ScreenSpaceReflectionPostProcess.prototype.getClassName = function () {\n    return \"ScreenSpaceReflectionPostProcess\";\n  };\n\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", {\n    /**\n     * Gets whether or not smoothing reflections is enabled.\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n     */\n    get: function get() {\n      return this._enableSmoothReflections;\n    },\n\n    /**\n     * Sets whether or not smoothing reflections is enabled.\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n     */\n    set: function set(enabled) {\n      if (enabled === this._enableSmoothReflections) {\n        return;\n      }\n\n      this._enableSmoothReflections = enabled;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", {\n    /**\n     * Gets the number of samples taken while computing reflections. More samples count is high,\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n     */\n    get: function get() {\n      return this._reflectionSamples;\n    },\n\n    /**\n     * Sets the number of samples taken while computing reflections. More samples count is high,\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n     */\n    set: function set(samples) {\n      if (samples === this._reflectionSamples) {\n        return;\n      }\n\n      this._reflectionSamples = samples;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", {\n    /**\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\n     * more the post-process will require GPU power and can generate a drop in FPS.\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\n     */\n    get: function get() {\n      return this._smoothSteps;\n    },\n\n    /*\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\n     * more the post-process will require GPU power and can generate a drop in FPS.\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\n     */\n    set: function set(steps) {\n      if (steps === this._smoothSteps) {\n        return;\n      }\n\n      this._smoothSteps = steps;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ScreenSpaceReflectionPostProcess.prototype._updateEffectDefines = function () {\n    var defines = [];\n\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n    }\n\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n\n    if (this._isSceneRightHanded) {\n      defines.push(\"#define RIGHT_HANDED_SCENE\");\n    }\n\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  };\n  /**\n   * @param parsedPostProcess\n   * @param targetCamera\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  ScreenSpaceReflectionPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\n\n  return ScreenSpaceReflectionPostProcess;\n}(PostProcess);\n\nexport { ScreenSpaceReflectionPostProcess };\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);","map":{"version":3,"mappings":"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","names":["PostProcess","GeometryBufferRenderer","serialize","SerializationHelper","ScreenSpaceReflectionsConfiguration","RegisterClass","__extends","name","scene","options","camera","samplingMode","engine","reusable","textureType","blockCompilation","forceGeometryBuffer","_super","undefined","_this","_forceGeometryBuffer","geometryBufferRenderer","enableGeometryBufferRenderer","isSupported","enablePosition","enableReflectivity","prePassRenderer","enablePrePassRenderer","markAsDirty","_prePassEffectConfiguration","_updateEffectDefines","onApply","effect","_geometryBufferRenderer","_prePassRenderer","positionIndex","getTextureIndex","POSITION_TEXTURE_TYPE","roughnessIndex","REFLECTIVITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","normalIndex","getRenderTarget","activeCamera","viewMatrix","getViewMatrix","projectionMatrix","getProjectionMatrix","setMatrix","setFloat","threshold","reflectionSpecularFalloffExponent","strength","step","roughnessFactor","_isSceneRightHanded","useRightHandedSystem","Object","ScreenSpaceReflectionPostProcess","_scene","_enableSmoothReflections","enabled","_reflectionSamples","samples","_smoothSteps","steps","defines","push","updateEffect","join","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/screenSpaceReflectionPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\r\n\r\nimport \"../Shaders/screenSpaceReflection.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n */\r\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\r\n    @serialize()\r\n    public threshold: number = 1.2;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\r\n    @serialize()\r\n    public strength: number = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent: number = 3;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\r\n    @serialize()\r\n    public step: number = 1.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor: number = 0.2;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _enableSmoothReflections: boolean = false;\r\n    private _reflectionSamples: number = 64;\r\n    private _smoothSteps: number = 5;\r\n    private _isSceneRightHanded: boolean;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ScreenSpaceReflectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to calculate reflections.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"screenSpaceReflection\",\r\n            [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"],\r\n            [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this._forceGeometryBuffer) {\r\n            // Get geometry buffer renderer and update effect\r\n            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n            if (geometryBufferRenderer) {\r\n                if (geometryBufferRenderer.isSupported) {\r\n                    geometryBufferRenderer.enablePosition = true;\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n                }\r\n            }\r\n        } else {\r\n            const prePassRenderer = scene.enablePrePassRenderer();\r\n            prePassRenderer?.markAsDirty();\r\n            this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\r\n        }\r\n\r\n        this._updateEffectDefines();\r\n\r\n        // On apply, send uniforms\r\n        this.onApply = (effect: Effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                // Samplers\r\n                const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n            } else if (prePassRenderer) {\r\n                // Samplers\r\n                const positionIndex = prePassRenderer.getIndex(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n            }\r\n\r\n            // Uniforms\r\n            const camera = scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix(true);\r\n            const projectionMatrix = camera.getProjectionMatrix(true);\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setFloat(\"threshold\", this.threshold);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"stepSize\", this.step);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n        };\r\n\r\n        this._isSceneRightHanded = scene.useRightHandedSystem;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    @serialize()\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    @serialize()\r\n    public get reflectionSamples(): number {\r\n        return this._reflectionSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    public set reflectionSamples(samples: number) {\r\n        if (samples === this._reflectionSamples) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionSamples = samples;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    @serialize()\r\n    public get smoothSteps(): number {\r\n        return this._smoothSteps;\r\n    }\r\n\r\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    public set smoothSteps(steps: number) {\r\n        if (steps === this._smoothSteps) {\r\n            return;\r\n        }\r\n\r\n        this._smoothSteps = steps;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\r\n        }\r\n        if (this._isSceneRightHanded) {\r\n            defines.push(\"#define RIGHT_HANDED_SCENE\");\r\n        }\r\n\r\n        defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\r\n        defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\r\n\r\n        this.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    /**\r\n     * @param parsedPostProcess\r\n     * @param targetCamera\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ScreenSpaceReflectionPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);\r\n"]},"metadata":{},"sourceType":"module"}