{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n\nvar WebGPUBindGroupCacheNode =\n/** @class */\nfunction () {\n  function WebGPUBindGroupCacheNode() {\n    this.values = {};\n  }\n\n  return WebGPUBindGroupCacheNode;\n}();\n/** @hidden */\n\n\nvar WebGPUCacheBindGroups =\n/** @class */\nfunction () {\n  function WebGPUCacheBindGroups(device, cacheSampler, engine) {\n    this.disabled = false;\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this._engine = engine;\n  }\n\n  Object.defineProperty(WebGPUCacheBindGroups, \"Statistics\", {\n    get: function get() {\n      return {\n        totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\n        lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\n        lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\n        noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebGPUCacheBindGroups.prototype.endFrame = function () {\n    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  };\n  /**\n   * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\n   * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\n   * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\n   * @param webgpuPipelineContext\n   * @param drawContext\n   * @param materialContext\n   */\n\n\n  WebGPUCacheBindGroups.prototype.getBindGroups = function (webgpuPipelineContext, drawContext, materialContext) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    var bindGroups = undefined;\n    var node = WebGPUCacheBindGroups._Cache;\n    var cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\n\n    if (!cacheIsDisabled) {\n      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\n        return drawContext.bindGroups;\n      }\n\n      for (var _i = 0, _l = webgpuPipelineContext.shaderProcessingContext.bufferNames; _i < _l.length; _i++) {\n        var bufferName = _l[_i];\n        var uboId = (_b = (_a = drawContext.buffers[bufferName]) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : 0;\n        var nextNode = node.values[uboId];\n\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[uboId] = nextNode;\n        }\n\n        node = nextNode;\n      }\n\n      for (var _m = 0, _o = webgpuPipelineContext.shaderProcessingContext.samplerNames; _m < _o.length; _m++) {\n        var samplerName = _o[_m];\n        var samplerHashCode = (_d = (_c = materialContext.samplers[samplerName]) === null || _c === void 0 ? void 0 : _c.hashCode) !== null && _d !== void 0 ? _d : 0;\n        var nextNode = node.values[samplerHashCode];\n\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[samplerHashCode] = nextNode;\n        }\n\n        node = nextNode;\n      }\n\n      for (var _p = 0, _q = webgpuPipelineContext.shaderProcessingContext.textureNames; _p < _q.length; _p++) {\n        var textureName = _q[_p];\n        var textureId = (_g = (_f = (_e = materialContext.textures[textureName]) === null || _e === void 0 ? void 0 : _e.texture) === null || _f === void 0 ? void 0 : _f.uniqueId) !== null && _g !== void 0 ? _g : 0;\n        var nextNode = node.values[textureId];\n\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[textureId] = nextNode;\n        }\n\n        node = nextNode;\n      }\n\n      bindGroups = node.bindGroups;\n    }\n\n    drawContext.resetIsDirty(materialContext.updateId);\n    materialContext.isDirty = false;\n\n    if (bindGroups) {\n      drawContext.bindGroups = bindGroups;\n      WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\n      return bindGroups;\n    }\n\n    bindGroups = [];\n    drawContext.bindGroups = bindGroups;\n\n    if (!cacheIsDisabled) {\n      node.bindGroups = bindGroups;\n    }\n\n    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\n    var bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;\n\n    for (var i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\n      var setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\n      var entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\n\n      for (var j = 0; j < setDefinition.length; j++) {\n        var entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\n        var entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\n        var name_1 = (_h = entryInfo.nameInArrayOfTexture) !== null && _h !== void 0 ? _h : entryInfo.name;\n\n        if (entry.sampler) {\n          var bindingInfo = materialContext.samplers[name_1];\n\n          if (bindingInfo) {\n            var sampler = bindingInfo.sampler;\n\n            if (!sampler) {\n              if (this._engine.dbgSanityChecks) {\n                Logger.Error(\"Trying to bind a null sampler! entry=\".concat(JSON.stringify(entry), \", name=\").concat(name_1, \", bindingInfo=\").concat(JSON.stringify(bindingInfo, function (key, value) {\n                  return key === \"texture\" ? \"<no dump>\" : value;\n                }), \", materialContext.uniqueId=\").concat(materialContext.uniqueId), 50);\n              }\n\n              continue;\n            }\n\n            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\n          } else {\n            Logger.Error(\"Sampler \\\"\".concat(name_1, \"\\\" could not be bound. entry=\").concat(JSON.stringify(entry), \", materialContext=\").concat(JSON.stringify(materialContext, function (key, value) {\n              return key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value;\n            })), 50);\n          }\n        } else if (entry.texture || entry.storageTexture) {\n          var bindingInfo = materialContext.textures[name_1];\n\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(\"Trying to bind a null texture! entry=\".concat(JSON.stringify(entry), \", bindingInfo=\").concat(JSON.stringify(bindingInfo, function (key, value) {\n                return key === \"texture\" ? \"<no dump>\" : value;\n              }), \", materialContext.uniqueId=\").concat(materialContext.uniqueId), 50);\n              continue;\n            }\n\n            var hardwareTexture = bindingInfo.texture._hardwareTexture;\n\n            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {\n              Logger.Error(\"Trying to bind a null gpu texture or view! entry=\".concat(JSON.stringify(entry), \", name=\").concat(name_1, \", bindingInfo=\").concat(JSON.stringify(bindingInfo, function (key, value) {\n                return key === \"texture\" ? \"<no dump>\" : value;\n              }), \", isReady=\").concat((_j = bindingInfo.texture) === null || _j === void 0 ? void 0 : _j.isReady, \", materialContext.uniqueId=\").concat(materialContext.uniqueId), 50);\n              continue;\n            }\n\n            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;\n          } else {\n            Logger.Error(\"Texture \\\"\".concat(name_1, \"\\\" could not be bound. entry=\").concat(JSON.stringify(entry), \", materialContext=\").concat(JSON.stringify(materialContext, function (key, value) {\n              return key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value;\n            })), 50);\n          }\n        } else if (entry.externalTexture) {\n          var bindingInfo = materialContext.textures[name_1];\n\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(\"Trying to bind a null external texture! entry=\".concat(JSON.stringify(entry), \", name=\").concat(name_1, \", bindingInfo=\").concat(JSON.stringify(bindingInfo, function (key, value) {\n                return key === \"texture\" ? \"<no dump>\" : value;\n              }), \", materialContext.uniqueId=\").concat(materialContext.uniqueId), 50);\n              continue;\n            }\n\n            var externalTexture = bindingInfo.texture.underlyingResource;\n\n            if (this._engine.dbgSanityChecks && !externalTexture) {\n              Logger.Error(\"Trying to bind a null gpu external texture! entry=\".concat(JSON.stringify(entry), \", name=\").concat(name_1, \", bindingInfo=\").concat(JSON.stringify(bindingInfo, function (key, value) {\n                return key === \"texture\" ? \"<no dump>\" : value;\n              }), \", isReady=\").concat((_k = bindingInfo.texture) === null || _k === void 0 ? void 0 : _k.isReady, \", materialContext.uniqueId=\").concat(materialContext.uniqueId), 50);\n              continue;\n            }\n\n            entries[j].resource = this._device.importExternalTexture({\n              source: externalTexture\n            });\n          } else {\n            Logger.Error(\"Texture \\\"\".concat(name_1, \"\\\" could not be bound. entry=\").concat(JSON.stringify(entry), \", materialContext=\").concat(JSON.stringify(materialContext, function (key, value) {\n              return key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value;\n            })), 50);\n          }\n        } else if (entry.buffer) {\n          var dataBuffer = drawContext.buffers[name_1];\n\n          if (dataBuffer) {\n            var webgpuBuffer = dataBuffer.underlyingResource;\n            entries[j].resource.buffer = webgpuBuffer;\n            entries[j].resource.size = dataBuffer.capacity;\n          } else {\n            Logger.Error(\"Can't find buffer \\\"\".concat(name_1, \"\\\". entry=\").concat(JSON.stringify(entry), \", buffers=\").concat(JSON.stringify(drawContext.buffers), \", drawContext.uniqueId=\").concat(drawContext.uniqueId), 50);\n          }\n        }\n      }\n\n      var groupLayout = bindGroupLayouts[i];\n      bindGroups[i] = this._device.createBindGroup({\n        layout: groupLayout,\n        entries: entries\n      });\n    }\n\n    return bindGroups;\n  };\n\n  WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\n  WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\n  WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\n  WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\n  WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\n  WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n  WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n  WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  return WebGPUCacheBindGroups;\n}();\n\nexport { WebGPUCacheBindGroups };","map":{"version":3,"mappings":"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","names":["Logger","values","device","cacheSampler","engine","_device","_cacheSampler","_engine","Object","WebGPUCacheBindGroups","totalCreated","NumBindGroupsCreatedTotal","lastFrameCreated","NumBindGroupsCreatedLastFrame","lookupLastFrame","NumBindGroupsLookupLastFrame","noLookupLastFrame","NumBindGroupsNoLookupLastFrame","_NumBindGroupsCreatedCurrentFrame","_NumBindGroupsLookupCurrentFrame","_NumBindGroupsNoLookupCurrentFrame","webgpuPipelineContext","drawContext","materialContext","bindGroups","undefined","node","_Cache","cacheIsDisabled","disabled","forceBindGroupCreation","isDirty","updateId","shaderProcessingContext","bufferNames","_i","bufferName","uboId","buffers","_a","uniqueId","_b","nextNode","WebGPUBindGroupCacheNode","samplerNames","_m","samplerName","samplerHashCode","samplers","_c","hashCode","_d","textureNames","_p","textureName","textureId","textures","_e","texture","_f","_g","resetIsDirty","bindGroupLayouts","i","bindGroupLayoutEntries","length","setDefinition","entries","bindGroupEntries","j","entry","entryInfo","bindGroupLayoutEntryInfo","binding","name_1","nameInArrayOfTexture","_h","name","sampler","bindingInfo","dbgSanityChecks","Error","JSON","stringify","concat","key","value","resource","getSampler","storageTexture","hardwareTexture","_hardwareTexture","view","viewForWriting","_j","isReady","externalTexture","underlyingResource","_k","importExternalTexture","source","buffer","dataBuffer","webgpuBuffer","size","capacity","groupLayout","createBindGroup","layout"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuCacheBindGroups.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @hidden */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = drawContext.buffers[bufferName]?.uniqueId ?? 0;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = materialContext.textures[textureName]?.texture?.uniqueId ?? 0;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key: string, value: any) =>\r\n                                    key === \"texture\" ? \"<no dump>\" : value\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}