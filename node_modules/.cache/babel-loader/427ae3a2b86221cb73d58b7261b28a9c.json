{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\n/**\n * Block used to retrieve the depth (zbuffer) of the scene\n * @since 5.0.0\n */\n\nvar SceneDepthBlock =\n/** @class */\nfunction (_super) {\n  __extends(SceneDepthBlock, _super);\n  /**\n   * Create a new SceneDepthBlock\n   * @param name defines the block name\n   */\n\n\n  function SceneDepthBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n\n    _this._samplerName = \"textureSampler\";\n    /**\n     * Defines if the depth renderer should be setup in non linear mode\n     */\n\n    _this.useNonLinearDepth = false;\n    /**\n     * Defines if the depth renderer should be setup in full 32 bits float mode\n     */\n\n    _this.force32itsFloat = false;\n    _this._isUnique = true;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this._inputs[0]._prioritizeVertex = false;\n    return _this;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  SceneDepthBlock.prototype.getClassName = function () {\n    return \"SceneDepthBlock\";\n  };\n\n  Object.defineProperty(SceneDepthBlock.prototype, \"uv\", {\n    /**\n     * Gets the uv input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneDepthBlock.prototype, \"depth\", {\n    /**\n     * Gets the depth output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n  SceneDepthBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"textureSampler\");\n  };\n\n  Object.defineProperty(SceneDepthBlock.prototype, \"target\", {\n    get: function get() {\n      if (!this.uv.isConnected) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      if (this.uv.sourceBlock.isInput) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      return NodeMaterialBlockTargets.Fragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SceneDepthBlock.prototype._getTexture = function (scene) {\n    var depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat);\n    return depthRenderer.getDepthMap();\n  };\n\n  SceneDepthBlock.prototype.bind = function (effect, nodeMaterial) {\n    var texture = this._getTexture(nodeMaterial.getScene());\n\n    effect.setTexture(this._samplerName, texture);\n  };\n\n  SceneDepthBlock.prototype._injectVertexCode = function (state) {\n    var uvInput = this.uv;\n\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\"));\n      }\n    }\n\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n\n    state.compilationString += \"\".concat(this._mainUVName, \" = \").concat(uvInput.associatedVariableName, \".xy;\\r\\n\");\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInVertexShader;\n    })) {\n      return;\n    }\n\n    this._writeTextureRead(state, true);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\", true);\n      }\n    }\n  };\n\n  SceneDepthBlock.prototype._writeTextureRead = function (state, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    var uvInput = this.uv;\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(this._samplerName, \", \").concat(uvInput.associatedVariableName, \".xy);\\r\\n\");\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(this._samplerName, \", \").concat(uvInput.associatedVariableName, \".xy);\\r\\n\");\n      return;\n    }\n\n    state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(this._samplerName, \", \").concat(this._mainUVName, \");\\r\\n\");\n  };\n\n  SceneDepthBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n      return;\n    }\n\n    state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n  };\n\n  SceneDepthBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n\n    if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\n      state.sharedData.bindableBlocks.push(this);\n    }\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInFragmentShader;\n    })) {\n      return;\n    }\n\n    state._emit2DSampler(this._samplerName);\n\n    this._writeTextureRead(state);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\");\n      }\n    }\n\n    return this;\n  };\n\n  SceneDepthBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.useNonLinearDepth = this.useNonLinearDepth;\n    serializationObject.force32itsFloat = this.force32itsFloat;\n    return serializationObject;\n  };\n\n  SceneDepthBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.useNonLinearDepth = serializationObject.useNonLinearDepth;\n    this.force32itsFloat = serializationObject.force32itsFloat;\n  };\n\n  __decorate([editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    notifiers: {\n      activatePreviewCommand: true,\n      callback: function callback(scene) {\n        return scene.disableDepthRenderer();\n      }\n    }\n  })], SceneDepthBlock.prototype, \"useNonLinearDepth\", void 0);\n\n  __decorate([editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    notifiers: {\n      activatePreviewCommand: true,\n      callback: function callback(scene) {\n        return scene.disableDepthRenderer();\n      }\n    }\n  })], SceneDepthBlock.prototype, \"force32itsFloat\", void 0);\n\n  return SceneDepthBlock;\n}(NodeMaterialBlock);\n\nexport { SceneDepthBlock };\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","__extends","name","_super","VertexAndFragment","_this","_isUnique","registerInput","Vector2","registerOutput","Float","Neutral","_inputs","acceptedConnectionPointTypes","push","Vector3","Vector4","_prioritizeVertex","SceneDepthBlock","Object","_outputs","state","_excludeVariableName","uv","isConnected","sourceBlock","isInput","Fragment","scene","depthRenderer","enableDepthRenderer","undefined","useNonLinearDepth","force32itsFloat","getDepthMap","effect","nodeMaterial","texture","_getTexture","getScene","setTexture","_samplerName","uvInput","connectedPoint","ownerBlock","uvInputOwnerBlock","isAttribute","_emitUniformFromString","associatedVariableName","type","_mainUVName","_emitVaryingFromString","compilationString","concat","some","o","isConnectedInVertexShader","_writeTextureRead","_i","output","hasEndpoints","_writeOutput","vertexMode","target","_tempTextureRead","swizzle","_declareOutput","_buildBlock","call","_getFreeVariableName","sharedData","bindableBlocks","indexOf","_emit2DSampler","_injectVertexCode","isConnectedInFragmentShader","serializationObject","serialize","rootUrl","_deserialize","__decorate","Boolean","notifiers","activatePreviewCommand","callback","disableDepthRenderer"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/sceneDepthBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\n\r\n/**\r\n * Block used to retrieve the depth (zbuffer) of the scene\r\n * @since 5.0.0\r\n */\r\nexport class SceneDepthBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"textureSampler\";\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in non linear mode\r\n     */\r\n    @editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() },\r\n    })\r\n    public useNonLinearDepth = false;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in full 32 bits float mode\r\n     */\r\n    @editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() },\r\n    })\r\n    public force32itsFloat = false;\r\n\r\n    /**\r\n     * Create a new SceneDepthBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SceneDepthBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth output component\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _getTexture(scene: Scene): BaseTexture {\r\n        const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat);\r\n\r\n        return depthRenderer.getDepthMap();\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial) {\r\n        const texture = this._getTexture(nodeMaterial.getScene());\r\n\r\n        effect.setTexture(this._samplerName, texture);\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(\r\n                    uvInput.associatedVariableName,\r\n                    \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\")\r\n                );\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\", true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\r\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\");\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useNonLinearDepth = this.useNonLinearDepth;\r\n        serializationObject.force32itsFloat = this.force32itsFloat;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useNonLinearDepth = serializationObject.useNonLinearDepth;\r\n        this.force32itsFloat = serializationObject.force32itsFloat;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);\r\n"]},"metadata":{},"sourceType":"module"}