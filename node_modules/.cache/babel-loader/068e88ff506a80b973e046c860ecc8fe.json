{"ast":null,"code":"import { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { SubMesh } from \"./subMesh.js\";\n/**\n * @param vector\n * @param positions\n * @param indices\n * @param step\n * @param checkStopper\n * @param ref\n * @hidden\n */\n\nSubMesh.prototype._projectOnTrianglesToRef = function (vector, positions, indices, step, checkStopper, ref) {\n  // Triangles test\n  var proj = TmpVectors.Vector3[0];\n  var tmp = TmpVectors.Vector3[1];\n  var distance = +Infinity;\n\n  for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n    var indexA = indices[index];\n    var indexB = indices[index + 1];\n    var indexC = indices[index + 2];\n\n    if (checkStopper && indexC === 0xffffffff) {\n      index += 2;\n      continue;\n    }\n\n    var p0 = positions[indexA];\n    var p1 = positions[indexB];\n    var p2 = positions[indexC]; // stay defensive and don't check against undefined positions.\n\n    if (!p0 || !p1 || !p2) {\n      continue;\n    }\n\n    var tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\n\n    if (tmpDist < distance) {\n      proj.copyFrom(tmp);\n      distance = tmpDist;\n    }\n  }\n\n  ref.copyFrom(proj);\n  return distance;\n};\n/**\n * @param vector\n * @param positions\n * @param indices\n * @param ref\n * @hidden\n */\n\n\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector, positions, indices, ref) {\n  // Triangles test\n  var proj = TmpVectors.Vector3[0];\n  var tmp = TmpVectors.Vector3[1];\n  var distance = +Infinity;\n\n  for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n    var p0 = positions[index];\n    var p1 = positions[index + 1];\n    var p2 = positions[index + 2];\n    var tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\n\n    if (tmpDist < distance) {\n      proj.copyFrom(tmp);\n      distance = tmpDist;\n    }\n  }\n\n  ref.copyFrom(proj);\n  return distance;\n};\n\nSubMesh.prototype.projectToRef = function (vector, positions, indices, ref) {\n  var material = this.getMaterial();\n\n  if (!material) {\n    return -1;\n  }\n\n  var step = 3;\n  var checkStopper = false;\n\n  switch (material.fillMode) {\n    case 3:\n    case 5:\n    case 6:\n    case 8:\n      return -1;\n\n    case 7:\n      step = 1;\n      checkStopper = true;\n      break;\n\n    default:\n      break;\n  } // LineMesh first as it's also a Mesh...\n\n\n  if (material.fillMode === 4) {\n    return -1;\n  } else {\n    // Check if mesh is unindexed\n    if (!indices.length && this._mesh._unIndexed) {\n      return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\n    }\n\n    return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\n  }\n};","map":{"version":3,"mappings":"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","names":["TmpVectors","Vector3","SubMesh","prototype","_projectOnTrianglesToRef","vector","positions","indices","step","checkStopper","ref","proj","tmp","distance","Infinity","index","indexStart","indexCount","indexA","indexB","indexC","p0","p1","p2","tmpDist","ProjectOnTriangleToRef","copyFrom","_projectOnUnIndexedTrianglesToRef","verticesStart","verticesCount","projectToRef","material","getMaterial","fillMode","length","_mesh","_unIndexed"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/subMesh.project.ts"],"sourcesContent":["import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    export interface SubMesh {\r\n        /** @hidden */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @hidden */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @param vector\r\n * @param positions\r\n * @param indices\r\n * @param step\r\n * @param checkStopper\r\n * @param ref\r\n * @hidden\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @param vector\r\n * @param positions\r\n * @param indices\r\n * @param ref\r\n * @hidden\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}