{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\n\nvar _a;\n\nimport { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nvar handJointReferenceArray = [\"wrist\"\n/* WRIST */\n, \"thumb-metacarpal\"\n/* THUMB_METACARPAL */\n, \"thumb-phalanx-proximal\"\n/* THUMB_PHALANX_PROXIMAL */\n, \"thumb-phalanx-distal\"\n/* THUMB_PHALANX_DISTAL */\n, \"thumb-tip\"\n/* THUMB_TIP */\n, \"index-finger-metacarpal\"\n/* INDEX_FINGER_METACARPAL */\n, \"index-finger-phalanx-proximal\"\n/* INDEX_FINGER_PHALANX_PROXIMAL */\n, \"index-finger-phalanx-intermediate\"\n/* INDEX_FINGER_PHALANX_INTERMEDIATE */\n, \"index-finger-phalanx-distal\"\n/* INDEX_FINGER_PHALANX_DISTAL */\n, \"index-finger-tip\"\n/* INDEX_FINGER_TIP */\n, \"middle-finger-metacarpal\"\n/* MIDDLE_FINGER_METACARPAL */\n, \"middle-finger-phalanx-proximal\"\n/* MIDDLE_FINGER_PHALANX_PROXIMAL */\n, \"middle-finger-phalanx-intermediate\"\n/* MIDDLE_FINGER_PHALANX_INTERMEDIATE */\n, \"middle-finger-phalanx-distal\"\n/* MIDDLE_FINGER_PHALANX_DISTAL */\n, \"middle-finger-tip\"\n/* MIDDLE_FINGER_TIP */\n, \"ring-finger-metacarpal\"\n/* RING_FINGER_METACARPAL */\n, \"ring-finger-phalanx-proximal\"\n/* RING_FINGER_PHALANX_PROXIMAL */\n, \"ring-finger-phalanx-intermediate\"\n/* RING_FINGER_PHALANX_INTERMEDIATE */\n, \"ring-finger-phalanx-distal\"\n/* RING_FINGER_PHALANX_DISTAL */\n, \"ring-finger-tip\"\n/* RING_FINGER_TIP */\n, \"pinky-finger-metacarpal\"\n/* PINKY_FINGER_METACARPAL */\n, \"pinky-finger-phalanx-proximal\"\n/* PINKY_FINGER_PHALANX_PROXIMAL */\n, \"pinky-finger-phalanx-intermediate\"\n/* PINKY_FINGER_PHALANX_INTERMEDIATE */\n, \"pinky-finger-phalanx-distal\"\n/* PINKY_FINGER_PHALANX_DISTAL */\n, \"pinky-finger-tip\"\n/* PINKY_FINGER_TIP */\n];\nvar handPartsDefinition = (_a = {}, _a[\"wrist\"\n/* WRIST */\n] = [\"wrist\"\n/* WRIST */\n], _a[\"thumb\"\n/* THUMB */\n] = [\"thumb-metacarpal\"\n/* THUMB_METACARPAL */\n, \"thumb-phalanx-proximal\"\n/* THUMB_PHALANX_PROXIMAL */\n, \"thumb-phalanx-distal\"\n/* THUMB_PHALANX_DISTAL */\n, \"thumb-tip\"\n/* THUMB_TIP */\n], _a[\"index\"\n/* INDEX */\n] = [\"index-finger-metacarpal\"\n/* INDEX_FINGER_METACARPAL */\n, \"index-finger-phalanx-proximal\"\n/* INDEX_FINGER_PHALANX_PROXIMAL */\n, \"index-finger-phalanx-intermediate\"\n/* INDEX_FINGER_PHALANX_INTERMEDIATE */\n, \"index-finger-phalanx-distal\"\n/* INDEX_FINGER_PHALANX_DISTAL */\n, \"index-finger-tip\"\n/* INDEX_FINGER_TIP */\n], _a[\"middle\"\n/* MIDDLE */\n] = [\"middle-finger-metacarpal\"\n/* MIDDLE_FINGER_METACARPAL */\n, \"middle-finger-phalanx-proximal\"\n/* MIDDLE_FINGER_PHALANX_PROXIMAL */\n, \"middle-finger-phalanx-intermediate\"\n/* MIDDLE_FINGER_PHALANX_INTERMEDIATE */\n, \"middle-finger-phalanx-distal\"\n/* MIDDLE_FINGER_PHALANX_DISTAL */\n, \"middle-finger-tip\"\n/* MIDDLE_FINGER_TIP */\n], _a[\"ring\"\n/* RING */\n] = [\"ring-finger-metacarpal\"\n/* RING_FINGER_METACARPAL */\n, \"ring-finger-phalanx-proximal\"\n/* RING_FINGER_PHALANX_PROXIMAL */\n, \"ring-finger-phalanx-intermediate\"\n/* RING_FINGER_PHALANX_INTERMEDIATE */\n, \"ring-finger-phalanx-distal\"\n/* RING_FINGER_PHALANX_DISTAL */\n, \"ring-finger-tip\"\n/* RING_FINGER_TIP */\n], _a[\"little\"\n/* LITTLE */\n] = [\"pinky-finger-metacarpal\"\n/* PINKY_FINGER_METACARPAL */\n, \"pinky-finger-phalanx-proximal\"\n/* PINKY_FINGER_PHALANX_PROXIMAL */\n, \"pinky-finger-phalanx-intermediate\"\n/* PINKY_FINGER_PHALANX_INTERMEDIATE */\n, \"pinky-finger-phalanx-distal\"\n/* PINKY_FINGER_PHALANX_DISTAL */\n, \"pinky-finger-tip\"\n/* PINKY_FINGER_TIP */\n], _a);\n/**\n * Representing a single hand (with its corresponding native XRHand object)\n */\n\nvar WebXRHand =\n/** @class */\nfunction () {\n  /**\n   * Construct a new hand object\n   * @param xrController The controller to which the hand correlates.\n   * @param _jointMeshes The meshes to be used to track the hand joints.\n   * @param _handMesh An optional hand mesh.\n   * @param rigMapping An optional rig mapping for the hand mesh.\n   *                   If not provided (but a hand mesh is provided),\n   *                   it will be assumed that the hand mesh's bones are named\n   *                   directly after the WebXR bone names.\n   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\n   * @param _jointsInvisible Are the tracked joint meshes visible\n   * @param _jointScaleFactor Scale factor for all joint meshes\n   */\n  function WebXRHand(\n  /** The controller to which the hand correlates. */\n  xrController, _jointMeshes, _handMesh,\n  /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\n   * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\n  rigMapping, _leftHandedMeshes, _jointsInvisible, _jointScaleFactor) {\n    if (_leftHandedMeshes === void 0) {\n      _leftHandedMeshes = false;\n    }\n\n    if (_jointsInvisible === void 0) {\n      _jointsInvisible = false;\n    }\n\n    if (_jointScaleFactor === void 0) {\n      _jointScaleFactor = 1;\n    }\n\n    this.xrController = xrController;\n    this._jointMeshes = _jointMeshes;\n    this._handMesh = _handMesh;\n    this.rigMapping = rigMapping;\n    this._leftHandedMeshes = _leftHandedMeshes;\n    this._jointsInvisible = _jointsInvisible;\n    this._jointScaleFactor = _jointScaleFactor;\n    /**\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\n     */\n\n    this._jointTransforms = new Array(handJointReferenceArray.length);\n    /**\n     * The float array that will directly receive the transform matrix data from WebXR.\n     */\n\n    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\n    this._tempJointMatrix = new Matrix();\n    /**\n     * The float array that will directly receive the joint radii from WebXR.\n     */\n\n    this._jointRadii = new Float32Array(handJointReferenceArray.length);\n    this._scene = _jointMeshes[0].getScene(); // Initialize the joint transform quaternions and link the transforms to the bones.\n\n    for (var jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\n      var jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);\n      jointTransform.rotationQuaternion = new Quaternion(); // Set the rotation quaternion so we can use it later for tracking.\n\n      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\n    }\n\n    if (_handMesh) {\n      // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\n      this.setHandMesh(_handMesh, rigMapping);\n    } // hide the motion controller, if available/loaded\n\n\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.setEnabled(false);\n      } else {\n        this.xrController.motionController.onModelLoadedObservable.add(function (controller) {\n          if (controller.rootMesh) {\n            controller.rootMesh.setEnabled(false);\n          }\n        });\n      }\n    }\n\n    this.xrController.onMotionControllerInitObservable.add(function (motionController) {\n      motionController.onModelLoadedObservable.add(function (controller) {\n        if (controller.rootMesh) {\n          controller.rootMesh.setEnabled(false);\n        }\n      });\n\n      if (motionController.rootMesh) {\n        motionController.rootMesh.setEnabled(false);\n      }\n    });\n  }\n\n  Object.defineProperty(WebXRHand.prototype, \"handMesh\", {\n    /**\n     * Get the hand mesh.\n     */\n    get: function get() {\n      return this._handMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get meshes of part of the hand.\n   * @param part The part of hand to get.\n   * @returns An array of meshes that correlate to the hand part requested.\n   */\n\n  WebXRHand.prototype.getHandPartMeshes = function (part) {\n    var _this = this;\n\n    return handPartsDefinition[part].map(function (name) {\n      return _this._jointMeshes[handJointReferenceArray.indexOf(name)];\n    });\n  };\n  /**\n   * Retrieves a mesh linked to a named joint in the hand.\n   * @param jointName The name of the joint.\n   * @returns An AbstractMesh whose position corresponds with the joint position.\n   */\n\n\n  WebXRHand.prototype.getJointMesh = function (jointName) {\n    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];\n  };\n  /**\n   * Sets the current hand mesh to render for the WebXRHand.\n   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\n   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\n   */\n\n\n  WebXRHand.prototype.setHandMesh = function (handMesh, rigMapping) {\n    var _this = this;\n\n    this._handMesh = handMesh; // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\n\n    handMesh.alwaysSelectAsActiveMesh = true;\n    handMesh.getChildMeshes().forEach(function (mesh) {\n      return mesh.alwaysSelectAsActiveMesh = true;\n    }); // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\n\n    if (this._handMesh.skeleton) {\n      var handMeshSkeleton_1 = this._handMesh.skeleton;\n      handJointReferenceArray.forEach(function (jointName, jointIdx) {\n        var jointBoneIdx = handMeshSkeleton_1.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\n\n        if (jointBoneIdx !== -1) {\n          handMeshSkeleton_1.bones[jointBoneIdx].linkTransformNode(_this._jointTransforms[jointIdx]);\n        }\n      });\n    }\n  };\n  /**\n   * Update this hand from the latest xr frame.\n   * @param xrFrame The latest frame received from WebXR.\n   * @param referenceSpace The current viewer reference space.\n   */\n\n\n  WebXRHand.prototype.updateFromXRFrame = function (xrFrame, referenceSpace) {\n    var _this = this;\n\n    var hand = this.xrController.inputSource.hand;\n\n    if (!hand) {\n      return;\n    } // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\n\n\n    var anyHand = hand;\n    var jointSpaces = handJointReferenceArray.map(function (jointName) {\n      return anyHand[jointName] || hand.get(jointName);\n    });\n    var trackingSuccessful = false;\n\n    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\n      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\n    } else if (xrFrame.getJointPose) {\n      trackingSuccessful = true; // Warning: This codepath is slow by comparison, only here for compat.\n\n      for (var jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\n        var jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\n\n        if (jointPose) {\n          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\n\n          this._jointRadii[jointIdx] = jointPose.radius || 0.008;\n        } else {\n          trackingSuccessful = false;\n          break;\n        }\n      }\n    }\n\n    if (!trackingSuccessful) {\n      return;\n    }\n\n    handJointReferenceArray.forEach(function (_jointName, jointIdx) {\n      var jointTransform = _this._jointTransforms[jointIdx];\n      Matrix.FromArrayToRef(_this._jointTransformMatrices, jointIdx * 16, _this._tempJointMatrix);\n\n      _this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion, jointTransform.position); // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\n\n\n      var scaledJointRadius = _this._jointRadii[jointIdx] * _this._jointScaleFactor;\n      var jointMesh = _this._jointMeshes[jointIdx];\n      jointMesh.isVisible = !_this._handMesh && !_this._jointsInvisible;\n      jointMesh.position.copyFrom(jointTransform.position);\n      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);\n      jointMesh.scaling.setAll(scaledJointRadius); // The WebXR data comes as right-handed, so we might need to do some conversions.\n\n      if (!_this._scene.useRightHandedSystem) {\n        jointMesh.position.z *= -1;\n        jointMesh.rotationQuaternion.z *= -1;\n        jointMesh.rotationQuaternion.w *= -1;\n\n        if (_this._leftHandedMeshes && _this._handMesh) {\n          jointTransform.position.z *= -1;\n          jointTransform.rotationQuaternion.z *= -1;\n          jointTransform.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n\n    if (this._handMesh) {\n      this._handMesh.isVisible = true;\n    }\n  };\n  /**\n   * Dispose this Hand object\n   */\n\n\n  WebXRHand.prototype.dispose = function () {\n    if (this._handMesh) {\n      this._handMesh.isVisible = false;\n    }\n  };\n\n  return WebXRHand;\n}();\n\nexport { WebXRHand };\n/**\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\n */\n\nvar WebXRHandTracking =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHandTracking, _super);\n  /**\n   * Creates a new instance of the XR hand tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   * @param options Options to use when constructing this feature.\n   */\n\n\n  function WebXRHandTracking(_xrSessionManager,\n  /** Options to use when constructing this feature. */\n  options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    _this._attachedHands = {};\n    _this._trackingHands = {\n      left: null,\n      right: null\n    };\n    _this._handResources = {\n      jointMeshes: null,\n      handMeshes: null,\n      rigMappings: null\n    };\n    /**\n     * This observable will notify registered observers when a new hand object was added and initialized\n     */\n\n    _this.onHandAddedObservable = new Observable();\n    /**\n     * This observable will notify its observers right before the hand object is disposed\n     */\n\n    _this.onHandRemovedObservable = new Observable();\n\n    _this._attachHand = function (xrController) {\n      var _a, _b, _c;\n\n      if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !_this._handResources.jointMeshes) {\n        return;\n      }\n\n      var handedness = xrController.inputSource.handedness;\n      var webxrHand = new WebXRHand(xrController, _this._handResources.jointMeshes[handedness], _this._handResources.handMeshes && _this._handResources.handMeshes[handedness], _this._handResources.rigMappings && _this._handResources.rigMappings[handedness], (_a = _this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.invisible, (_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.scaleFactor);\n      _this._attachedHands[xrController.uniqueId] = webxrHand;\n      _this._trackingHands[handedness] = webxrHand;\n\n      _this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n\n    _this._detachHand = function (xrController) {\n      _this._detachHandById(xrController.uniqueId);\n    };\n\n    _this.xrNativeFeatureName = \"hand-tracking\"; // Support legacy versions of the options object by copying over joint mesh properties\n\n    var anyOptions = options;\n    var anyJointMeshOptions = anyOptions.jointMeshes;\n\n    if (anyJointMeshOptions) {\n      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\n      }\n\n      if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\n      }\n\n      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\n      }\n\n      if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        var leftRigMapping = {};\n        var rightRigMapping = {};\n        [[anyJointMeshOptions.rigMapping.left, leftRigMapping], [anyJointMeshOptions.rigMapping.right, rightRigMapping]].forEach(function (rigMappingTuple) {\n          var legacyRigMapping = rigMappingTuple[0];\n          var rigMapping = rigMappingTuple[1];\n          legacyRigMapping.forEach(function (modelJointName, index) {\n            rigMapping[handJointReferenceArray[index]] = modelJointName;\n          });\n        });\n        options.handMeshes.customRigMappings = {\n          left: leftRigMapping,\n          right: rightRigMapping\n        };\n      }\n    }\n\n    return _this;\n  }\n\n  WebXRHandTracking._GenerateTrackedJointMeshes = function (featureOptions) {\n    var meshes = {};\n    [\"left\", \"right\"].map(function (handedness) {\n      var _a, _b, _c, _d, _e;\n\n      var trackedMeshes = [];\n      var originalMesh = ((_a = featureOptions.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\n      originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n\n      for (var i = 0; i < handJointReferenceArray.length; ++i) {\n        var newInstance = originalMesh.createInstance(\"\".concat(handedness, \"-handJoint-\").concat(i));\n\n        if ((_c = featureOptions.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n          var returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);\n\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n\n        newInstance.isPickable = false;\n\n        if ((_d = featureOptions.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n          var props = ((_e = featureOptions.jointMeshes) === null || _e === void 0 ? void 0 : _e.physicsProps) || {}; // downscale the instances so that physics will be initialized correctly\n\n          newInstance.scaling.setAll(0.02);\n          var type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({\n            mass: 0\n          }, props));\n        }\n\n        newInstance.rotationQuaternion = new Quaternion();\n        newInstance.isVisible = false;\n        trackedMeshes.push(newInstance);\n      }\n\n      meshes[handedness] = trackedMeshes;\n    });\n    return {\n      left: meshes.left,\n      right: meshes.right\n    };\n  };\n\n  WebXRHandTracking._GenerateDefaultHandMeshesAsync = function (scene, options) {\n    var _this = this; // eslint-disable-next-line no-async-promise-executor\n\n\n    return new Promise(function (resolve) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var riggedMeshes, handsDefined, handGLBs, handShader, handColors, handNodes;\n\n        var _a, _b, _c, _d, _e;\n\n        return __generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              riggedMeshes = {}; // check the cache, defensive\n\n              if ((_b = (_a = WebXRHandTracking._RightHandGLB) === null || _a === void 0 ? void 0 : _a.meshes[1]) === null || _b === void 0 ? void 0 : _b.isDisposed()) {\n                WebXRHandTracking._RightHandGLB = null;\n              }\n\n              if ((_d = (_c = WebXRHandTracking._LeftHandGLB) === null || _c === void 0 ? void 0 : _c.meshes[1]) === null || _d === void 0 ? void 0 : _d.isDisposed()) {\n                WebXRHandTracking._LeftHandGLB = null;\n              }\n\n              handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\n              return [4\n              /*yield*/\n              , Promise.all([WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene), WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)])];\n\n            case 1:\n              handGLBs = _f.sent();\n              WebXRHandTracking._RightHandGLB = handGLBs[0];\n              WebXRHandTracking._LeftHandGLB = handGLBs[1];\n              handShader = new NodeMaterial(\"handShader\", scene, {\n                emitComments: false\n              });\n              return [4\n              /*yield*/\n              , handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL)];\n\n            case 2:\n              _f.sent(); // depth prepass and alpha mode\n\n\n              handShader.needDepthPrePass = true;\n              handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n              handShader.alphaMode = 2; // build node materials\n\n              handShader.build(false);\n              handColors = __assign({\n                base: Color3.FromInts(116, 63, 203),\n                fresnel: Color3.FromInts(149, 102, 229),\n                fingerColor: Color3.FromInts(177, 130, 255),\n                tipFresnel: Color3.FromInts(220, 200, 255)\n              }, (_e = options === null || options === void 0 ? void 0 : options.handMeshes) === null || _e === void 0 ? void 0 : _e.customColors);\n              handNodes = {\n                base: handShader.getBlockByName(\"baseColor\"),\n                fresnel: handShader.getBlockByName(\"fresnelColor\"),\n                fingerColor: handShader.getBlockByName(\"fingerColor\"),\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n              };\n              handNodes.base.value = handColors.base;\n              handNodes.fresnel.value = handColors.fresnel;\n              handNodes.fingerColor.value = handColors.fingerColor;\n              handNodes.tipFresnel.value = handColors.tipFresnel;\n              [\"left\", \"right\"].forEach(function (handedness) {\n                var handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\n\n                if (!handGLB) {\n                  // this should never happen!\n                  throw new Error(\"Could not load hand model\");\n                }\n\n                var handMesh = handGLB.meshes[1];\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\n                handMesh.material = handShader.clone(\"\".concat(handedness, \"HandShaderClone\"), true);\n                handMesh.isVisible = false;\n                riggedMeshes[handedness] = handMesh; // single change for left handed systems\n\n                if (!handsDefined && !scene.useRightHandedSystem) {\n                  handGLB.meshes[1].rotate(Axis.Y, Math.PI);\n                }\n              });\n              handShader.dispose();\n              resolve({\n                left: riggedMeshes.left,\n                right: riggedMeshes.right\n              });\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\n   * @param handedness The handedness being mapped for.\n   */\n\n\n  WebXRHandTracking._GenerateDefaultHandMeshRigMapping = function (handedness) {\n    var _a;\n\n    var H = handedness == \"right\" ? \"R\" : \"L\";\n    return _a = {}, _a[\"wrist\"\n    /* WRIST */\n    ] = \"wrist_\".concat(H), _a[\"thumb-metacarpal\"\n    /* THUMB_METACARPAL */\n    ] = \"thumb_metacarpal_\".concat(H), _a[\"thumb-phalanx-proximal\"\n    /* THUMB_PHALANX_PROXIMAL */\n    ] = \"thumb_proxPhalanx_\".concat(H), _a[\"thumb-phalanx-distal\"\n    /* THUMB_PHALANX_DISTAL */\n    ] = \"thumb_distPhalanx_\".concat(H), _a[\"thumb-tip\"\n    /* THUMB_TIP */\n    ] = \"thumb_tip_\".concat(H), _a[\"index-finger-metacarpal\"\n    /* INDEX_FINGER_METACARPAL */\n    ] = \"index_metacarpal_\".concat(H), _a[\"index-finger-phalanx-proximal\"\n    /* INDEX_FINGER_PHALANX_PROXIMAL */\n    ] = \"index_proxPhalanx_\".concat(H), _a[\"index-finger-phalanx-intermediate\"\n    /* INDEX_FINGER_PHALANX_INTERMEDIATE */\n    ] = \"index_intPhalanx_\".concat(H), _a[\"index-finger-phalanx-distal\"\n    /* INDEX_FINGER_PHALANX_DISTAL */\n    ] = \"index_distPhalanx_\".concat(H), _a[\"index-finger-tip\"\n    /* INDEX_FINGER_TIP */\n    ] = \"index_tip_\".concat(H), _a[\"middle-finger-metacarpal\"\n    /* MIDDLE_FINGER_METACARPAL */\n    ] = \"middle_metacarpal_\".concat(H), _a[\"middle-finger-phalanx-proximal\"\n    /* MIDDLE_FINGER_PHALANX_PROXIMAL */\n    ] = \"middle_proxPhalanx_\".concat(H), _a[\"middle-finger-phalanx-intermediate\"\n    /* MIDDLE_FINGER_PHALANX_INTERMEDIATE */\n    ] = \"middle_intPhalanx_\".concat(H), _a[\"middle-finger-phalanx-distal\"\n    /* MIDDLE_FINGER_PHALANX_DISTAL */\n    ] = \"middle_distPhalanx_\".concat(H), _a[\"middle-finger-tip\"\n    /* MIDDLE_FINGER_TIP */\n    ] = \"middle_tip_\".concat(H), _a[\"ring-finger-metacarpal\"\n    /* RING_FINGER_METACARPAL */\n    ] = \"ring_metacarpal_\".concat(H), _a[\"ring-finger-phalanx-proximal\"\n    /* RING_FINGER_PHALANX_PROXIMAL */\n    ] = \"ring_proxPhalanx_\".concat(H), _a[\"ring-finger-phalanx-intermediate\"\n    /* RING_FINGER_PHALANX_INTERMEDIATE */\n    ] = \"ring_intPhalanx_\".concat(H), _a[\"ring-finger-phalanx-distal\"\n    /* RING_FINGER_PHALANX_DISTAL */\n    ] = \"ring_distPhalanx_\".concat(H), _a[\"ring-finger-tip\"\n    /* RING_FINGER_TIP */\n    ] = \"ring_tip_\".concat(H), _a[\"pinky-finger-metacarpal\"\n    /* PINKY_FINGER_METACARPAL */\n    ] = \"little_metacarpal_\".concat(H), _a[\"pinky-finger-phalanx-proximal\"\n    /* PINKY_FINGER_PHALANX_PROXIMAL */\n    ] = \"little_proxPhalanx_\".concat(H), _a[\"pinky-finger-phalanx-intermediate\"\n    /* PINKY_FINGER_PHALANX_INTERMEDIATE */\n    ] = \"little_intPhalanx_\".concat(H), _a[\"pinky-finger-phalanx-distal\"\n    /* PINKY_FINGER_PHALANX_DISTAL */\n    ] = \"little_distPhalanx_\".concat(H), _a[\"pinky-finger-tip\"\n    /* PINKY_FINGER_TIP */\n    ] = \"little_tip_\".concat(H), _a;\n  };\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   */\n\n\n  WebXRHandTracking.prototype.isCompatible = function () {\n    return typeof XRHand !== \"undefined\";\n  };\n  /**\n   * Get the hand object according to the controller id\n   * @param controllerId the controller id to which we want to get the hand\n   * @returns null if not found or the WebXRHand object if found\n   */\n\n\n  WebXRHandTracking.prototype.getHandByControllerId = function (controllerId) {\n    return this._attachedHands[controllerId];\n  };\n  /**\n   * Get a hand object according to the requested handedness\n   * @param handedness the handedness to request\n   * @returns null if not found or the WebXRHand object if found\n   */\n\n\n  WebXRHandTracking.prototype.getHandByHandedness = function (handedness) {\n    if (handedness == \"none\") {\n      return null;\n    }\n\n    return this._trackingHands[handedness];\n  };\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRHandTracking.prototype.attach = function () {\n    var _this = this;\n\n    var _a, _b, _c, _d;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._handResources = {\n      jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\n      handMeshes: ((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes) || null,\n      rigMappings: ((_b = this.options.handMeshes) === null || _b === void 0 ? void 0 : _b.customRigMappings) || null\n    }; // If they didn't supply custom meshes and are not disabling the default meshes...\n\n    if (!((_c = this.options.handMeshes) === null || _c === void 0 ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) === null || _d === void 0 ? void 0 : _d.disableDefaultMeshes)) {\n      WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this.options).then(function (defaultHandMeshes) {\n        var _a, _b;\n\n        _this._handResources.handMeshes = defaultHandMeshes;\n        _this._handResources.rigMappings = {\n          left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\n          right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\")\n        }; // Apply meshes to existing hands if already tracking.\n\n        (_a = _this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.setHandMesh(_this._handResources.handMeshes.left, _this._handResources.rigMappings.left);\n        (_b = _this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.setHandMesh(_this._handResources.handMeshes.right, _this._handResources.rigMappings.right);\n      });\n    }\n\n    this.options.xrInput.controllers.forEach(this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\n\n    return true;\n  };\n\n  WebXRHandTracking.prototype._onXRFrame = function (_xrFrame) {\n    var _a, _b;\n\n    (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n    (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n  };\n\n  WebXRHandTracking.prototype._detachHandById = function (controllerId) {\n    var _a;\n\n    var hand = this.getHandByControllerId(controllerId);\n\n    if (hand) {\n      var handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\n\n      if (((_a = this._trackingHands[handedness]) === null || _a === void 0 ? void 0 : _a.xrController.uniqueId) === controllerId) {\n        this._trackingHands[handedness] = null;\n      }\n\n      this.onHandRemovedObservable.notifyObservers(hand);\n      hand.dispose();\n      delete this._attachedHands[controllerId];\n    }\n  };\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRHandTracking.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._attachedHands).forEach(function (uniqueId) {\n      return _this._detachHandById(uniqueId);\n    });\n    return true;\n  };\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n\n\n  WebXRHandTracking.prototype.dispose = function () {\n    var _a;\n\n    _super.prototype.dispose.call(this);\n\n    this.onHandAddedObservable.clear();\n    this.onHandRemovedObservable.clear();\n\n    if (this._handResources.handMeshes && !((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes)) {\n      // this will dispose the cached meshes\n      this._handResources.handMeshes.left.dispose();\n\n      this._handResources.handMeshes.right.dispose(); // remove the cached meshes\n\n\n      WebXRHandTracking._RightHandGLB = null;\n      WebXRHandTracking._LeftHandGLB = null;\n    }\n\n    if (this._handResources.jointMeshes) {\n      this._handResources.jointMeshes.left.forEach(function (trackedMesh) {\n        return trackedMesh.dispose();\n      });\n\n      this._handResources.jointMeshes.right.forEach(function (trackedMesh) {\n        return trackedMesh.dispose();\n      });\n    }\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRHandTracking.Version = 1;\n  /** The base URL for the default hand model. */\n\n  WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\n  /** The filename to use for the default right hand model. */\n\n  WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\n  /** The filename to use for the default left hand model. */\n\n  WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\n  /** The URL pointing to the default hand model NodeMaterial shader. */\n\n  WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\"; // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\n\n  WebXRHandTracking._ICOSPHERE_PARAMS = {\n    radius: 0.5,\n    flat: false,\n    subdivisions: 2\n  };\n  WebXRHandTracking._RightHandGLB = null;\n  WebXRHandTracking._LeftHandGLB = null;\n  return WebXRHandTracking;\n}(WebXRAbstractFeature);\n\nexport { WebXRHandTracking }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHandTracking(xrSessionManager, options);\n  };\n}, WebXRHandTracking.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRAbstractFeature","WebXRFeatureName","WebXRFeaturesManager","Matrix","Quaternion","PhysicsImpostor","Observable","SceneLoader","Color3","NodeMaterial","Material","CreateIcoSphere","TransformNode","Axis","EngineStore","handJointReferenceArray","handPartsDefinition","_a","xrController","_jointMeshes","_handMesh","rigMapping","_leftHandedMeshes","_jointsInvisible","_jointScaleFactor","Array","length","Float32Array","_scene","getScene","jointIdx","_jointTransforms","jointTransform","rotationQuaternion","setHandMesh","motionController","rootMesh","setEnabled","onModelLoadedObservable","add","controller","onMotionControllerInitObservable","Object","WebXRHand","part","map","name","indexOf","jointName","handMesh","alwaysSelectAsActiveMesh","getChildMeshes","forEach","mesh","skeleton","handMeshSkeleton_1","jointBoneIdx","getBoneIndexByName","bones","linkTransformNode","_this","xrFrame","referenceSpace","hand","inputSource","anyHand","jointSpaces","get","trackingSuccessful","fillPoses","fillJointRadii","_jointTransformMatrices","_jointRadii","getJointPose","jointPose","set","transform","matrix","radius","_jointName","FromArrayToRef","_tempJointMatrix","decompose","undefined","position","scaledJointRadius","jointMesh","isVisible","copyFrom","scaling","setAll","useRightHandedSystem","z","w","__extends","_xrSessionManager","options","_super","left","right","jointMeshes","handMeshes","rigMappings","handedness","_handResources","webxrHand","meshesUseLeftHandedCoordinates","_b","invisible","_c","scaleFactor","_attachedHands","uniqueId","_trackingHands","onHandAddedObservable","notifyObservers","_detachHandById","xrNativeFeatureName","anyOptions","anyJointMeshOptions","disableDefaultHandMesh","disableDefaultMeshes","customMeshes","leftHandedSystemMeshes","leftRigMapping","rightRigMapping","rigMappingTuple","legacyRigMapping","modelJointName","index","customRigMappings","WebXRHandTracking","featureOptions","meshes","trackedMeshes","originalMesh","sourceMesh","_ICOSPHERE_PARAMS","keepOriginalVisible","i","newInstance","createInstance","concat","onHandJointMeshGenerated","returnedMesh","dispose","isPickable","_d","enablePhysics","props","_e","physicsProps","type","impostorType","SphereImpostor","physicsImpostor","__assign","mass","push","scene","Promise","resolve","riggedMeshes","_RightHandGLB","isDisposed","_LeftHandGLB","handsDefined","all","ImportMeshAsync","DEFAULT_HAND_MODEL_BASE_URL","DEFAULT_HAND_MODEL_RIGHT_FILENAME","DEFAULT_HAND_MODEL_LEFT_FILENAME","handGLBs","_f","handShader","emitComments","loadAsync","DEFAULT_HAND_MODEL_SHADER_URL","needDepthPrePass","transparencyMode","MATERIAL_ALPHABLEND","alphaMode","build","handColors","base","FromInts","fresnel","fingerColor","tipFresnel","customColors","handNodes","getBlockByName","value","handGLB","Error","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","material","clone","rotate","Y","Math","PI","H","XRHand","controllerId","attach","call","_GenerateTrackedJointMeshes","_GenerateDefaultHandMeshesAsync","LastCreatedScene","then","defaultHandMeshes","_GenerateDefaultHandMeshRigMapping","xrInput","controllers","_attachHand","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","_detachHand","_xrFrame","updateFromXRFrame","getHandByControllerId","onHandRemovedObservable","detach","keys","clear","trackedMesh","HAND_TRACKING","flat","subdivisions","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRHandTracking.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\n\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport type { ISceneLoaderAsyncResult } from \"../../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes.\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false).\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to an icosphere with two subdivisions and smooth lighting.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius.\r\n         */\r\n        sourceMesh?: Mesh;\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed.\r\n         * @param meshInstance An instance of the original joint mesh being used for the joint.\r\n         * @param jointId The joint's index, see https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section for more info.\r\n         * @param hand Which hand (\"left\", \"right\") the joint will be on.\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, hand: XRHandedness) => AbstractMesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible (defaults to false).\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Scale factor for all joint meshes (defaults to 1)\r\n         */\r\n        scaleFactor?: number;\r\n    };\r\n\r\n    /**\r\n     * Configuration object for the hand meshes.\r\n     */\r\n    handMeshes?: {\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultMeshes?: boolean;\r\n        /**\r\n         * Rigged hand meshes that will be tracked to the user's hands. This will override the default hand mesh.\r\n         */\r\n        customMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * Are the meshes prepared for a left-handed system. Default hand meshes are right-handed.\r\n         */\r\n        meshesUseLeftHandedCoordinates?: boolean;\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        customRigMappings?: {\r\n            right: XRHandMeshRigMapping;\r\n            left: XRHandMeshRigMapping;\r\n        };\r\n\r\n        /**\r\n         * Override the colors of the hand meshes.\r\n         */\r\n        customColors?: {\r\n            base?: Color3;\r\n            fresnel?: Color3;\r\n            fingerColor?: Color3;\r\n            tipFresnel?: Color3;\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport const enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The thumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Joints of the hand as defined by the WebXR specification.\r\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\r\n */\r\nexport const enum XRHandJoint {\r\n    /** Wrist */\r\n    WRIST = \"wrist\",\r\n\r\n    /** Thumb near wrist */\r\n    THUMB_METACARPAL = \"thumb-metacarpal\",\r\n    /** Thumb first knuckle */\r\n    THUMB_PHALANX_PROXIMAL = \"thumb-phalanx-proximal\",\r\n    /** Thumb second knuckle */\r\n    THUMB_PHALANX_DISTAL = \"thumb-phalanx-distal\",\r\n    /** Thumb tip */\r\n    THUMB_TIP = \"thumb-tip\",\r\n\r\n    /** Index finger near wrist */\r\n    INDEX_FINGER_METACARPAL = \"index-finger-metacarpal\",\r\n    /** Index finger first knuckle */\r\n    INDEX_FINGER_PHALANX_PROXIMAL = \"index-finger-phalanx-proximal\",\r\n    /** Index finger second knuckle */\r\n    INDEX_FINGER_PHALANX_INTERMEDIATE = \"index-finger-phalanx-intermediate\",\r\n    /** Index finger third knuckle */\r\n    INDEX_FINGER_PHALANX_DISTAL = \"index-finger-phalanx-distal\",\r\n    /** Index finger tip */\r\n    INDEX_FINGER_TIP = \"index-finger-tip\",\r\n\r\n    /** Middle finger near wrist */\r\n    MIDDLE_FINGER_METACARPAL = \"middle-finger-metacarpal\",\r\n    /** Middle finger first knuckle */\r\n    MIDDLE_FINGER_PHALANX_PROXIMAL = \"middle-finger-phalanx-proximal\",\r\n    /** Middle finger second knuckle */\r\n    MIDDLE_FINGER_PHALANX_INTERMEDIATE = \"middle-finger-phalanx-intermediate\",\r\n    /** Middle finger third knuckle */\r\n    MIDDLE_FINGER_PHALANX_DISTAL = \"middle-finger-phalanx-distal\",\r\n    /** Middle finger tip */\r\n    MIDDLE_FINGER_TIP = \"middle-finger-tip\",\r\n\r\n    /** Ring finger near wrist */\r\n    RING_FINGER_METACARPAL = \"ring-finger-metacarpal\",\r\n    /** Ring finger first knuckle */\r\n    RING_FINGER_PHALANX_PROXIMAL = \"ring-finger-phalanx-proximal\",\r\n    /** Ring finger second knuckle */\r\n    RING_FINGER_PHALANX_INTERMEDIATE = \"ring-finger-phalanx-intermediate\",\r\n    /** Ring finger third knuckle */\r\n    RING_FINGER_PHALANX_DISTAL = \"ring-finger-phalanx-distal\",\r\n    /** Ring finger tip */\r\n    RING_FINGER_TIP = \"ring-finger-tip\",\r\n\r\n    /** Pinky finger near wrist */\r\n    PINKY_FINGER_METACARPAL = \"pinky-finger-metacarpal\",\r\n    /** Pinky finger first knuckle */\r\n    PINKY_FINGER_PHALANX_PROXIMAL = \"pinky-finger-phalanx-proximal\",\r\n    /** Pinky finger second knuckle */\r\n    PINKY_FINGER_PHALANX_INTERMEDIATE = \"pinky-finger-phalanx-intermediate\",\r\n    /** Pinky finger third knuckle */\r\n    PINKY_FINGER_PHALANX_DISTAL = \"pinky-finger-phalanx-distal\",\r\n    /** Pinky finger tip */\r\n    PINKY_FINGER_TIP = \"pinky-finger-tip\",\r\n}\r\n\r\n/** A type encapsulating a dictionary mapping WebXR joints to bone names in a rigged hand mesh.  */\r\nexport type XRHandMeshRigMapping = { [webXRJointName in XRHandJoint]: string };\r\n\r\nconst handJointReferenceArray: XRHandJoint[] = [\r\n    XRHandJoint.WRIST,\r\n    XRHandJoint.THUMB_METACARPAL,\r\n    XRHandJoint.THUMB_PHALANX_PROXIMAL,\r\n    XRHandJoint.THUMB_PHALANX_DISTAL,\r\n    XRHandJoint.THUMB_TIP,\r\n    XRHandJoint.INDEX_FINGER_METACARPAL,\r\n    XRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n    XRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n    XRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n    XRHandJoint.INDEX_FINGER_TIP,\r\n    XRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n    XRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n    XRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n    XRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n    XRHandJoint.MIDDLE_FINGER_TIP,\r\n    XRHandJoint.RING_FINGER_METACARPAL,\r\n    XRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n    XRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n    XRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n    XRHandJoint.RING_FINGER_TIP,\r\n    XRHandJoint.PINKY_FINGER_METACARPAL,\r\n    XRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n    XRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n    XRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n    XRHandJoint.PINKY_FINGER_TIP,\r\n];\r\n\r\nconst handPartsDefinition: { [key in HandPart]: XRHandJoint[] } = {\r\n    [HandPart.WRIST]: [XRHandJoint.WRIST],\r\n    [HandPart.THUMB]: [XRHandJoint.THUMB_METACARPAL, XRHandJoint.THUMB_PHALANX_PROXIMAL, XRHandJoint.THUMB_PHALANX_DISTAL, XRHandJoint.THUMB_TIP],\r\n    [HandPart.INDEX]: [\r\n        XRHandJoint.INDEX_FINGER_METACARPAL,\r\n        XRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n        XRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n        XRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n        XRHandJoint.INDEX_FINGER_TIP,\r\n    ],\r\n    [HandPart.MIDDLE]: [\r\n        XRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n        XRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n        XRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n        XRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n        XRHandJoint.MIDDLE_FINGER_TIP,\r\n    ],\r\n    [HandPart.RING]: [\r\n        XRHandJoint.RING_FINGER_METACARPAL,\r\n        XRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n        XRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n        XRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n        XRHandJoint.RING_FINGER_TIP,\r\n    ],\r\n    [HandPart.LITTLE]: [\r\n        XRHandJoint.PINKY_FINGER_METACARPAL,\r\n        XRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n        XRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n        XRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n        XRHandJoint.PINKY_FINGER_TIP,\r\n    ],\r\n};\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\r\n     */\r\n    private _jointTransforms = new Array<TransformNode>(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * The float array that will directly receive the transform matrix data from WebXR.\r\n     */\r\n    private _jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\r\n\r\n    private _tempJointMatrix = new Matrix();\r\n\r\n    /**\r\n     * The float array that will directly receive the joint radii from WebXR.\r\n     */\r\n    private _jointRadii = new Float32Array(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * Get the hand mesh.\r\n     */\r\n    public get handMesh(): Nullable<AbstractMesh> {\r\n        return this._handMesh;\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand.\r\n     * @param part The part of hand to get.\r\n     * @returns An array of meshes that correlate to the hand part requested.\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return handPartsDefinition[part].map((name) => this._jointMeshes[handJointReferenceArray.indexOf(name)]!);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a mesh linked to a named joint in the hand.\r\n     * @param jointName The name of the joint.\r\n     * @returns An AbstractMesh whose position corresponds with the joint position.\r\n     */\r\n    public getJointMesh(jointName: XRHandJoint): AbstractMesh {\r\n        return this._jointMeshes[handJointReferenceArray.indexOf(jointName)!];\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController The controller to which the hand correlates.\r\n     * @param _jointMeshes The meshes to be used to track the hand joints.\r\n     * @param _handMesh An optional hand mesh.\r\n     * @param rigMapping An optional rig mapping for the hand mesh.\r\n     *                   If not provided (but a hand mesh is provided),\r\n     *                   it will be assumed that the hand mesh's bones are named\r\n     *                   directly after the WebXR bone names.\r\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\r\n     * @param _jointsInvisible Are the tracked joint meshes visible\r\n     * @param _jointScaleFactor Scale factor for all joint meshes\r\n     */\r\n    constructor(\r\n        /** The controller to which the hand correlates. */\r\n        public readonly xrController: WebXRInputSource,\r\n        private readonly _jointMeshes: AbstractMesh[],\r\n        private _handMesh: Nullable<AbstractMesh>,\r\n        /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\r\n         * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\r\n        readonly rigMapping: Nullable<XRHandMeshRigMapping>,\r\n        private readonly _leftHandedMeshes: boolean = false,\r\n        private readonly _jointsInvisible: boolean = false,\r\n        private readonly _jointScaleFactor: number = 1\r\n    ) {\r\n        this._scene = _jointMeshes[0].getScene();\r\n\r\n        // Initialize the joint transform quaternions and link the transforms to the bones.\r\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\r\n            const jointTransform = (this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene));\r\n            jointTransform.rotationQuaternion = new Quaternion();\r\n\r\n            // Set the rotation quaternion so we can use it later for tracking.\r\n            _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        if (_handMesh) {\r\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\r\n            this.setHandMesh(_handMesh, rigMapping);\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.setEnabled(false);\r\n            } else {\r\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\r\n                    if (controller.rootMesh) {\r\n                        controller.rootMesh.setEnabled(false);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController.onModelLoadedObservable.add((controller) => {\r\n                if (controller.rootMesh) {\r\n                    controller.rootMesh.setEnabled(false);\r\n                }\r\n            });\r\n            if (motionController.rootMesh) {\r\n                motionController.rootMesh.setEnabled(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current hand mesh to render for the WebXRHand.\r\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\r\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\r\n     */\r\n    public setHandMesh(handMesh: AbstractMesh, rigMapping: Nullable<XRHandMeshRigMapping>) {\r\n        this._handMesh = handMesh;\r\n\r\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\r\n        handMesh.alwaysSelectAsActiveMesh = true;\r\n        handMesh.getChildMeshes().forEach((mesh) => (mesh.alwaysSelectAsActiveMesh = true));\r\n\r\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\r\n        if (this._handMesh.skeleton) {\r\n            const handMeshSkeleton = this._handMesh.skeleton;\r\n            handJointReferenceArray.forEach((jointName, jointIdx) => {\r\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\r\n                if (jointBoneIdx !== -1) {\r\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame.\r\n     * @param xrFrame The latest frame received from WebXR.\r\n     * @param referenceSpace The current viewer reference space.\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n\r\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\r\n        const anyHand: any = hand;\r\n        const jointSpaces: XRJointSpace[] = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\r\n        let trackingSuccessful = false;\r\n\r\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\r\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\r\n        } else if (xrFrame.getJointPose) {\r\n            trackingSuccessful = true;\r\n            // Warning: This codepath is slow by comparison, only here for compat.\r\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\r\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\r\n                if (jointPose) {\r\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\r\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\r\n                } else {\r\n                    trackingSuccessful = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!trackingSuccessful) {\r\n            return;\r\n        }\r\n\r\n        handJointReferenceArray.forEach((_jointName, jointIdx) => {\r\n            const jointTransform = this._jointTransforms[jointIdx];\r\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\r\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion!, jointTransform.position);\r\n\r\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\r\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\r\n\r\n            const jointMesh = this._jointMeshes[jointIdx];\r\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\r\n            jointMesh.position.copyFrom(jointTransform.position);\r\n            jointMesh.rotationQuaternion!.copyFrom(jointTransform.rotationQuaternion!);\r\n            jointMesh.scaling.setAll(scaledJointRadius);\r\n\r\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\r\n            if (!this._scene.useRightHandedSystem) {\r\n                jointMesh.position.z *= -1;\r\n                jointMesh.rotationQuaternion!.z *= -1;\r\n                jointMesh.rotationQuaternion!.w *= -1;\r\n\r\n                if (this._leftHandedMeshes && this._handMesh) {\r\n                    jointTransform.position.z *= -1;\r\n                    jointTransform.rotationQuaternion!.z *= -1;\r\n                    jointTransform.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     */\r\n    public dispose() {\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /** The base URL for the default hand model. */\r\n    public static DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\r\n    /** The filename to use for the default right hand model. */\r\n    public static DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\r\n    /** The filename to use for the default left hand model. */\r\n    public static DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\r\n    /** The URL pointing to the default hand model NodeMaterial shader. */\r\n    public static DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\r\n\r\n    // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\r\n    private static readonly _ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\r\n\r\n    private static _RightHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n    private static _LeftHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n\r\n    private static _GenerateTrackedJointMeshes(featureOptions: IWebXRHandTrackingOptions): { left: AbstractMesh[]; right: AbstractMesh[] } {\r\n        const meshes: { [handedness: string]: AbstractMesh[] } = {};\r\n        [\"left\" as XRHandedness, \"right\" as XRHandedness].map((handedness) => {\r\n            const trackedMeshes = [];\r\n            const originalMesh = featureOptions.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\r\n            originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\r\n            for (let i = 0; i < handJointReferenceArray.length; ++i) {\r\n                let newInstance: AbstractMesh = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\r\n                if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\r\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, handedness);\r\n                    if (returnedMesh) {\r\n                        if (returnedMesh !== newInstance) {\r\n                            newInstance.dispose();\r\n                            newInstance = returnedMesh;\r\n                        }\r\n                    }\r\n                }\r\n                newInstance.isPickable = false;\r\n                if (featureOptions.jointMeshes?.enablePhysics) {\r\n                    const props = featureOptions.jointMeshes?.physicsProps || {};\r\n                    // downscale the instances so that physics will be initialized correctly\r\n                    newInstance.scaling.setAll(0.02);\r\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n                }\r\n                newInstance.rotationQuaternion = new Quaternion();\r\n                newInstance.isVisible = false;\r\n                trackedMeshes.push(newInstance);\r\n            }\r\n\r\n            meshes[handedness] = trackedMeshes;\r\n        });\r\n        return { left: meshes.left, right: meshes.right };\r\n    }\r\n\r\n    private static _GenerateDefaultHandMeshesAsync(scene: Scene, options?: IWebXRHandTrackingOptions): Promise<{ left: AbstractMesh; right: AbstractMesh }> {\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        return new Promise(async (resolve) => {\r\n            const riggedMeshes: { [handedness: string]: AbstractMesh } = {};\r\n            // check the cache, defensive\r\n            if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._RightHandGLB = null;\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._LeftHandGLB = null;\r\n            }\r\n\r\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\r\n            // load them in parallel\r\n            const handGLBs = await Promise.all([\r\n                WebXRHandTracking._RightHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\r\n                WebXRHandTracking._LeftHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\r\n            ]);\r\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\r\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\r\n\r\n            const handShader = new NodeMaterial(\"handShader\", scene, { emitComments: false });\r\n            await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n                ...options?.handMeshes?.customColors,\r\n            };\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n\r\n            [\"left\", \"right\"].forEach((handedness) => {\r\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\r\n                if (!handGLB) {\r\n                    // this should never happen!\r\n                    throw new Error(\"Could not load hand model\");\r\n                }\r\n                const handMesh = handGLB.meshes[1];\r\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\r\n                handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\r\n                handMesh.isVisible = false;\r\n\r\n                riggedMeshes[handedness] = handMesh;\r\n\r\n                // single change for left handed systems\r\n                if (!handsDefined && !scene.useRightHandedSystem) {\r\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\r\n                }\r\n            });\r\n\r\n            handShader.dispose();\r\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\r\n     * @param handedness The handedness being mapped for.\r\n     */\r\n    private static _GenerateDefaultHandMeshRigMapping(handedness: XRHandedness): XRHandMeshRigMapping {\r\n        const H = handedness == \"right\" ? \"R\" : \"L\";\r\n        return {\r\n            [XRHandJoint.WRIST]: `wrist_${H}`,\r\n            [XRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\r\n            [XRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\r\n            [XRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\r\n            [XRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\r\n            [XRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\r\n            [XRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\r\n            [XRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\r\n            [XRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\r\n            [XRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\r\n            [XRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\r\n            [XRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\r\n            [XRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\r\n            [XRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\r\n            [XRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\r\n            [XRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\r\n            [XRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\r\n            [XRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\r\n            [XRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\r\n            [XRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\r\n            [XRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\r\n            [XRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\r\n            [XRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\r\n            [XRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\r\n            [XRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`,\r\n        };\r\n    }\r\n\r\n    private _attachedHands: {\r\n        [uniqueId: string]: WebXRHand;\r\n    } = {};\r\n\r\n    private _trackingHands: {\r\n        left: Nullable<WebXRHand>;\r\n        right: Nullable<WebXRHand>;\r\n    } = { left: null, right: null };\r\n\r\n    private _handResources: {\r\n        jointMeshes: Nullable<{ left: AbstractMesh[]; right: AbstractMesh[] }>;\r\n        handMeshes: Nullable<{ left: AbstractMesh; right: AbstractMesh }>;\r\n        rigMappings: Nullable<{ left: XRHandMeshRigMapping; right: XRHandMeshRigMapping }>;\r\n    } = { jointMeshes: null, handMeshes: null, rigMappings: null };\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._attachedHands[controllerId];\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        if (handedness == \"none\") {\r\n            return null;\r\n        }\r\n        return this._trackingHands[handedness];\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the XR hand tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     * @param options Options to use when constructing this feature.\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /** Options to use when constructing this feature. */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n\r\n        // Support legacy versions of the options object by copying over joint mesh properties\r\n        const anyOptions = options as any;\r\n        const anyJointMeshOptions = anyOptions.jointMeshes;\r\n        if (anyJointMeshOptions) {\r\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\r\n            }\r\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                const leftRigMapping = {};\r\n                const rightRigMapping = {};\r\n                [\r\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\r\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\r\n                ].forEach((rigMappingTuple) => {\r\n                    const legacyRigMapping = rigMappingTuple[0] as string[];\r\n                    const rigMapping = rigMappingTuple[1] as XRHandMeshRigMapping;\r\n                    legacyRigMapping.forEach((modelJointName, index) => {\r\n                        rigMapping[handJointReferenceArray[index]] = modelJointName;\r\n                    });\r\n                });\r\n                options.handMeshes.customRigMappings = {\r\n                    left: leftRigMapping as XRHandMeshRigMapping,\r\n                    right: rightRigMapping as XRHandMeshRigMapping,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._handResources = {\r\n            jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\r\n            handMeshes: this.options.handMeshes?.customMeshes || null,\r\n            rigMappings: this.options.handMeshes?.customRigMappings || null,\r\n        };\r\n\r\n        // If they didn't supply custom meshes and are not disabling the default meshes...\r\n        if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\r\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene!, this.options).then((defaultHandMeshes) => {\r\n                this._handResources.handMeshes = defaultHandMeshes;\r\n                this._handResources.rigMappings = {\r\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\r\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\r\n                };\r\n\r\n                // Apply meshes to existing hands if already tracking.\r\n                this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\r\n                this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\r\n            });\r\n        }\r\n\r\n        this.options.xrInput.controllers.forEach(this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n        this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\r\n            return;\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness;\r\n        const webxrHand = new WebXRHand(\r\n            xrController,\r\n            this._handResources.jointMeshes[handedness],\r\n            this._handResources.handMeshes && this._handResources.handMeshes[handedness],\r\n            this._handResources.rigMappings && this._handResources.rigMappings[handedness],\r\n            this.options.handMeshes?.meshesUseLeftHandedCoordinates,\r\n            this.options.jointMeshes?.invisible,\r\n            this.options.jointMeshes?.scaleFactor\r\n        );\r\n\r\n        this._attachedHands[xrController.uniqueId] = webxrHand;\r\n        this._trackingHands[handedness] = webxrHand;\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHandById(controllerId: string) {\r\n        const hand = this.getHandByControllerId(controllerId);\r\n        if (hand) {\r\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\r\n            if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\r\n                this._trackingHands[handedness] = null;\r\n            }\r\n            this.onHandRemovedObservable.notifyObservers(hand);\r\n            hand.dispose();\r\n            delete this._attachedHands[controllerId];\r\n        }\r\n    }\r\n\r\n    private _detachHand = (xrController: WebXRInputSource) => {\r\n        this._detachHandById(xrController.uniqueId);\r\n    };\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n        this.onHandRemovedObservable.clear();\r\n\r\n        if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\r\n            // this will dispose the cached meshes\r\n            this._handResources.handMeshes.left.dispose();\r\n            this._handResources.handMeshes.right.dispose();\r\n            // remove the cached meshes\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n        }\r\n\r\n        if (this._handResources.jointMeshes) {\r\n            this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());\r\n            this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}