{"ast":null,"code":"import \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\n\nvar PanoramaToCubeMapTools =\n/** @class */\nfunction () {\n  function PanoramaToCubeMapTools() {}\n  /**\n   * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n   *\n   * @param float32Array The source data.\n   * @param inputWidth The width of the input panorama.\n   * @param inputHeight The height of the input panorama.\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n   * @return The cubemap data\n   */\n\n\n  PanoramaToCubeMapTools.ConvertPanoramaToCubemap = function (float32Array, inputWidth, inputHeight, size) {\n    if (!float32Array) {\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n\n    var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n    var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n    var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n    var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n    var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n    var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  };\n\n  PanoramaToCubeMapTools.CreateCubemapTexture = function (texSize, faceData, float32Array, inputWidth, inputHeight) {\n    var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    var textureArray = new Float32Array(buffer);\n    var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n    var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n    var dy = 1 / texSize;\n    var fy = 0;\n\n    for (var y = 0; y < texSize; y++) {\n      var xv1 = faceData[0];\n      var xv2 = faceData[2];\n\n      for (var x = 0; x < texSize; x++) {\n        var v = xv2.subtract(xv1).scale(fy).add(xv1);\n        v.normalize();\n        var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight); // 3 channels per pixels\n\n        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\n        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\n        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\n        xv1 = xv1.add(rotDX1);\n        xv2 = xv2.add(rotDX2);\n      }\n\n      fy += dy;\n    }\n\n    return textureArray;\n  };\n\n  PanoramaToCubeMapTools.CalcProjectionSpherical = function (vDir, float32Array, inputWidth, inputHeight) {\n    var theta = Math.atan2(vDir.z, vDir.x);\n    var phi = Math.acos(vDir.y);\n\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n\n    var dx = theta / Math.PI;\n    var dy = phi / Math.PI; // recenter.\n\n    dx = dx * 0.5 + 0.5;\n    var px = Math.round(dx * inputWidth);\n\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n\n    var py = Math.round(dy * inputHeight);\n\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n\n    var inputY = inputHeight - py - 1;\n    var r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    var g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    var b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  };\n\n  PanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n  return PanoramaToCubeMapTools;\n}();\n\nexport { PanoramaToCubeMapTools };","map":{"version":3,"mappings":"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","names":["Vector3","PanoramaToCubeMapTools","float32Array","inputWidth","inputHeight","size","length","textureFront","CreateCubemapTexture","FACE_FRONT","textureBack","FACE_BACK","textureLeft","FACE_LEFT","textureRight","FACE_RIGHT","textureUp","FACE_UP","textureDown","FACE_DOWN","front","back","left","right","up","down","type","format","gammaSpace","texSize","faceData","buffer","ArrayBuffer","textureArray","Float32Array","rotDX1","subtract","scale","rotDX2","dy","fy","y","xv1","xv2","x","v","add","normalize","color","CalcProjectionSpherical","r","g","b","vDir","theta","Math","atan2","z","phi","acos","PI","dx","px","round","py","inputY"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Misc/HighDynamicRange/panoramaToCubemap.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @return The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            let xv1 = faceData[0];\r\n            let xv2 = faceData[2];\r\n\r\n            for (let x = 0; x < texSize; x++) {\r\n                const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                v.normalize();\r\n\r\n                const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                // 3 channels per pixels\r\n                textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\r\n                textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\r\n                textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\r\n\r\n                xv1 = xv1.add(rotDX1);\r\n                xv2 = xv2.add(rotDX2);\r\n            }\r\n\r\n            fy += dy;\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}