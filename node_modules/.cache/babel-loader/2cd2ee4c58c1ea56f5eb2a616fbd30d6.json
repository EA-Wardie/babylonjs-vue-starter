{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nvar name = \"particlesVertexShader\";\nvar shader = \"attribute vec3 position;\\nattribute vec4 color;\\nattribute float angle;\\nattribute vec2 size;\\n#ifdef ANIMATESHEET\\nattribute float cellIndex;\\n#endif\\n#ifndef BILLBOARD\\nattribute vec3 direction;\\n#endif\\n#ifdef BILLBOARDSTRETCHED\\nattribute vec3 direction;\\n#endif\\n#ifdef RAMPGRADIENT\\nattribute vec4 remapData;\\n#endif\\nattribute vec2 offset;\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 translationPivot;\\n#ifdef ANIMATESHEET\\nuniform vec3 particlesInfos; \\n#endif\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\nvarying vec3 vPositionW;\\n#ifdef RAMPGRADIENT\\nvarying vec4 remapRanges;\\n#endif\\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\\nuniform mat4 invView;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#ifdef BILLBOARD\\nuniform vec3 eyePosition;\\n#endif\\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\\nvec3 zaxis=normalize(cross(yaxis,xaxis));\\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner;\\n}\\n#ifdef BILLBOARDSTRETCHED\\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\\nvec3 normalizedToCamera=normalize(toCamera);\\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner;\\n}\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec2 cornerPos;\\ncornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;\\n#ifdef BILLBOARD\\nvec3 rotatedCorner;\\n#ifdef BILLBOARDY\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=position-eyePosition;\\nyaxis.y=0.;\\nvPositionW=rotate(normalize(yaxis),rotatedCorner);\\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\\n#elif defined(BILLBOARDSTRETCHED)\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 toCamera=position-eyePosition;\\nvPositionW=rotateAlign(toCamera,rotatedCorner);\\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\\n#else\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\\nvPositionW=(invView*vec4(viewPos,1)).xyz;\\n#endif\\n#ifdef RAMPGRADIENT\\nremapRanges=remapData;\\n#endif\\ngl_Position=projection*vec4(viewPos,1.0);\\n#else\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=normalize(direction);\\nvPositionW=rotate(yaxis,rotatedCorner);\\ngl_Position=projection*view*vec4(vPositionW,1.0);\\n#endif\\nvColor=color;\\n#ifdef ANIMATESHEET\\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\\nfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\\nvec2 uvScale=particlesInfos.xy;\\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\\n#else\\nvUV=offset;\\n#endif\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nvec4 worldPos=vec4(vPositionW,1.0);\\n#endif\\n#include<clipPlaneVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\"; // Sideeffect\n\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\n\nexport var particlesVertexShader = {\n  name: name,\n  shader: shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAT,QAA4B,2BAA5B;AACA,OAAO,gDAAP;AACA,OAAO,qCAAP;AAEA,IAAMC,IAAI,GAAG,uBAAb;AACA,IAAMC,MAAM,GAAG,23HAAf,C,CAqHA;;AACAF,WAAW,CAACG,YAAZ,CAAyBF,IAAzB,IAAiCC,MAAjC;AACA;;AACA,OAAO,IAAME,qBAAqB,GAAG;AAAEH,MAAI,MAAN;AAAQC,QAAM;AAAd,CAA9B","names":["ShaderStore","name","shader","ShadersStore","particlesVertexShader"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/particles.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"particlesVertexShader\";\nconst shader = `attribute vec3 position;\rattribute vec4 color;\rattribute float angle;\rattribute vec2 size;\r#ifdef ANIMATESHEET\nattribute float cellIndex;\r#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\r#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\r#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\r#endif\nattribute vec2 offset;\runiform mat4 view;\runiform mat4 projection;\runiform vec2 translationPivot;\r#ifdef ANIMATESHEET\nuniform vec3 particlesInfos; \r#endif\nvarying vec2 vUV;\rvarying vec4 vColor;\rvarying vec3 vPositionW;\r#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\r#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\r#endif\n#include<clipPlaneVertexDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\r#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\rvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\rvec3 zaxis=normalize(cross(yaxis,xaxis));\rvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\rvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\rvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\rmat3 rotMatrix= mat3(row0,row1,row2);\rvec3 alignedCorner=rotMatrix*rotatedCorner;\rreturn position+alignedCorner;\r}\r#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\rvec3 normalizedToCamera=normalize(toCamera);\rvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\rvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\rvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\rvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\rvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\rmat3 rotMatrix= mat3(row0,row1,row2);\rvec3 alignedCorner=rotMatrix*rotatedCorner;\rreturn position+alignedCorner;\r}\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 cornerPos;\rcornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;\r#ifdef BILLBOARD\nvec3 rotatedCorner;\r#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.y=0.;\rvec3 yaxis=position-eyePosition;\ryaxis.y=0.;\rvPositionW=rotate(normalize(yaxis),rotatedCorner);\rvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\r#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.z=0.;\rvec3 toCamera=position-eyePosition;\rvPositionW=rotateAlign(toCamera,rotatedCorner);\rvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\r#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.z=0.;\rvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\rvPositionW=(invView*vec4(viewPos,1)).xyz;\r#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\r#endif\ngl_Position=projection*vec4(viewPos,1.0);\r#else\nvec3 rotatedCorner;\rrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.y=0.;\rvec3 yaxis=normalize(direction);\rvPositionW=rotate(yaxis,rotatedCorner);\rgl_Position=projection*view*vec4(vPositionW,1.0);\r#endif\nvColor=color;\r#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\rfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\rvec2 uvScale=particlesInfos.xy;\rvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\rvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\r#else\nvUV=offset;\r#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\r#endif\n#include<clipPlaneVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const particlesVertexShader = { name, shader };\n"]},"metadata":{},"sourceType":"module"}