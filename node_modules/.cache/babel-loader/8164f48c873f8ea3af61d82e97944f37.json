{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools.js\";\nimport \"../Engines/Extensions/engine.cubeTexture.js\"; // Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\nvar DDS_MAGIC = 0x20534444;\nvar //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000; //DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\n\nvar DDSCAPS2_CUBEMAP = 0x200; // DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\n\nvar //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4,\n    DDPF_RGB = 0x40,\n    //DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\n\nfunction FourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\n\nfunction Int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}\n\nvar FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nvar FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nvar FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nvar FOURCC_DX10 = FourCCToInt32(\"DX10\");\nvar FOURCC_D3DFMT_R16G16B16A16F = 113;\nvar FOURCC_D3DFMT_R32G32B32A32F = 116;\nvar DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nvar DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nvar DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nvar headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\n\nvar off_magic = 0;\nvar off_size = 1;\nvar off_flags = 2;\nvar off_height = 3;\nvar off_width = 4;\nvar off_mipmapCount = 7;\nvar off_pfFlags = 20;\nvar off_pfFourCC = 21;\nvar off_RGBbpp = 22;\nvar off_RMask = 23;\nvar off_GMask = 24;\nvar off_BMask = 25;\nvar off_AMask = 26; // var off_caps1 = 27;\n\nvar off_caps2 = 28; // var off_caps3 = 29;\n// var off_caps4 = 30;\n\nvar off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\n\nvar DDSTools =\n/** @class */\nfunction () {\n  function DDSTools() {}\n  /**\n   * Gets DDS information from an array buffer\n   * @param data defines the array buffer view to read data from\n   * @returns the DDS information\n   */\n\n\n  DDSTools.GetDDSInfo = function (data) {\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n    var mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var fourCC = header[off_pfFourCC];\n    var dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n    var textureType = 0;\n\n    switch (fourCC) {\n      case FOURCC_D3DFMT_R16G16B16A16F:\n        textureType = 2;\n        break;\n\n      case FOURCC_D3DFMT_R32G32B32A32F:\n        textureType = 1;\n        break;\n\n      case FOURCC_DX10:\n        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n          textureType = 2;\n          break;\n        }\n\n        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n          textureType = 1;\n          break;\n        }\n\n    }\n\n    return {\n      width: header[off_width],\n      height: header[off_height],\n      mipmapCount: mipmapCount,\n      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n      dxgiFormat: dxgiFormat,\n      textureType: textureType\n    };\n  };\n\n  DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Float32Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = FromHalfFloat(srcData[srcPos]);\n        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Uint16Array(dataLength);\n      var srcData = new Uint16Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = ToHalfFloat(lod);\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Float32Array(dataLength);\n      var srcData = new Float32Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = lod;\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Float32Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint16Array(dataLength);\n    var srcData = new Float32Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        destArray[index] = ToHalfFloat(srcData[index]);\n        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = ToHalfFloat(lod);\n        } else {\n          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Float32Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        byteArray[index + 3] = srcData[srcPos + aOffset];\n        index += 4;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._ExtractLongWordOrder = function (value) {\n    if (value === 0 || value === 255 || value === -16777216) {\n      return 0;\n    }\n\n    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n  };\n\n  DDSTools._GetRGBArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 3;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        index += 3;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._GetLuminanceArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = x + y * width;\n        byteArray[index] = srcData[srcPos];\n        index++;\n      }\n    }\n\n    return byteArray;\n  };\n  /**\n   * Uploads DDS Levels to a Babylon Texture\n   * @param engine\n   * @param texture\n   * @param data\n   * @param info\n   * @param loadMipmaps\n   * @param faces\n   * @param lodIndex\n   * @param currentFace\n   * @param destTypeMustBeFilterable\n   * @hidden\n   */\n\n\n  DDSTools.UploadDDSLevels = function (engine, texture, data, info, loadMipmaps, faces, lodIndex, currentFace, destTypeMustBeFilterable) {\n    if (lodIndex === void 0) {\n      lodIndex = -1;\n    }\n\n    if (destTypeMustBeFilterable === void 0) {\n      destTypeMustBeFilterable = true;\n    }\n\n    var sphericalPolynomialFaces = null;\n\n    if (info.sphericalPolynomial) {\n      sphericalPolynomialFaces = new Array();\n    }\n\n    var ext = !!engine.getCaps().s3tc; // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n\n    texture.generateMipMaps = loadMipmaps;\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var fourCC,\n        width,\n        height,\n        dataLength = 0,\n        dataOffset;\n    var byteArray, mipmapCount, mip;\n    var internalCompressedFormat = 0;\n    var blockBytes = 1;\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      Logger.Error(\"Invalid magic number in DDS header\");\n      return;\n    }\n\n    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n      Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n      return;\n    }\n\n    if (info.isCompressed && !ext) {\n      Logger.Error(\"Compressed textures are not supported on this platform.\");\n      return;\n    }\n\n    var bpp = header[off_RGBbpp];\n    dataOffset = header[off_size] + 4;\n    var computeFormats = false;\n\n    if (info.isFourCC) {\n      fourCC = header[off_pfFourCC];\n\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          internalCompressedFormat = 33777;\n          break;\n\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          internalCompressedFormat = 33778;\n          break;\n\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          internalCompressedFormat = 33779;\n          break;\n\n        case FOURCC_D3DFMT_R16G16B16A16F:\n          computeFormats = true;\n          bpp = 64;\n          break;\n\n        case FOURCC_D3DFMT_R32G32B32A32F:\n          computeFormats = true;\n          bpp = 128;\n          break;\n\n        case FOURCC_DX10:\n          {\n            // There is an additionnal header so dataOffset need to be changed\n            dataOffset += 5 * 4; // 5 uints\n\n            var supported = false;\n\n            switch (info.dxgiFormat) {\n              case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                computeFormats = true;\n                bpp = 64;\n                supported = true;\n                break;\n\n              case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                computeFormats = true;\n                bpp = 128;\n                supported = true;\n                break;\n\n              case DXGI_FORMAT_B8G8R8X8_UNORM:\n                info.isRGB = true;\n                info.isFourCC = false;\n                bpp = 32;\n                supported = true;\n                break;\n            }\n\n            if (supported) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n\n        default:\n          console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n          return;\n      }\n    }\n\n    var rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n\n    var gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n\n    var bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n\n    var aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n\n    if (computeFormats) {\n      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n    }\n\n    mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var startFace = currentFace || 0;\n    var caps = engine.getCaps();\n\n    for (var face = startFace; face < faces; face++) {\n      width = header[off_width];\n      height = header[off_height];\n\n      for (mip = 0; mip < mipmapCount; ++mip) {\n        if (lodIndex === -1 || lodIndex === mip) {\n          // In case of fixed LOD, if the lod has just been uploaded, early exit.\n          var i = lodIndex === -1 ? mip : 0;\n\n          if (!info.isCompressed && info.isFourCC) {\n            texture.format = 5;\n            dataLength = width * height * 4;\n            var floatArray = null;\n\n            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {\n              // Required because iOS has many issues with float and half float generation\n              if (bpp === 128) {\n                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              } else if (bpp === 64) {\n                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              }\n\n              texture.type = 0;\n            } else {\n              var floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);\n              var halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);\n              var destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;\n              var dataGetter = void 0;\n              var dataGetterPolynomial = null;\n\n              switch (bpp) {\n                case 128:\n                  {\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n\n                      case 2:\n                        dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n\n                      case 0:\n                        dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n                    }\n\n                    break;\n                  }\n\n                default:\n                  {\n                    // 64 bpp\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n\n                      case 2:\n                        dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n\n                      case 0:\n                        dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n                    }\n\n                    break;\n                  }\n              }\n\n              texture.type = destType;\n              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n              if (sphericalPolynomialFaces && i == 0) {\n                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n              }\n            }\n\n            if (floatArray) {\n              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n            }\n          } else if (info.isRGB) {\n            texture.type = 0;\n\n            if (bpp === 24) {\n              texture.format = 4;\n              dataLength = width * height * 3;\n              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            } else {\n              // 32\n              texture.format = 5;\n              dataLength = width * height * 4;\n              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            }\n          } else if (info.isLuminance) {\n            var unpackAlignment = engine._getUnpackAlignement();\n\n            var unpaddedRowSize = width;\n            var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n            texture.format = 1;\n            texture.type = 0;\n\n            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n            texture.type = 0;\n\n            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n          }\n        }\n\n        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n        width *= 0.5;\n        height *= 0.5;\n        width = Math.max(1.0, width);\n        height = Math.max(1.0, height);\n      }\n\n      if (currentFace !== undefined) {\n        // Loading a single face\n        break;\n      }\n    }\n\n    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n        size: header[off_width],\n        right: sphericalPolynomialFaces[0],\n        left: sphericalPolynomialFaces[1],\n        up: sphericalPolynomialFaces[2],\n        down: sphericalPolynomialFaces[3],\n        front: sphericalPolynomialFaces[4],\n        back: sphericalPolynomialFaces[5],\n        format: 5,\n        type: 1,\n        gammaSpace: false\n      });\n    } else {\n      info.sphericalPolynomial = undefined;\n    }\n  };\n  /**\n   * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n   */\n\n\n  DDSTools.StoreLODInAlphaChannel = false;\n  return DDSTools;\n}();\n\nexport { DDSTools };\n/**\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\n * @param rootUrl defines the url where the file to load is located\n * @param scene defines the current scene\n * @param lodScale defines scale to apply to the mip map selection\n * @param lodOffset defines offset to apply to the mip map selection\n * @param onLoad defines an optional callback raised when the texture is loaded\n * @param onError defines an optional callback raised if there is an issue to load the texture\n * @param format defines the format of the data\n * @param forcedExtension defines the extension to use to pick the right loader\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\n * @returns the cube texture as an InternalTexture\n */\n\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, createPolynomials) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = true;\n  }\n\n  var callback = function callback(loadData) {\n    if (!loadData) {\n      if (onLoad) {\n        onLoad(null);\n      }\n\n      return;\n    }\n\n    var texture = loadData.texture;\n\n    if (!createPolynomials) {\n      texture._sphericalPolynomial = new SphericalPolynomial();\n    } else if (loadData.info.sphericalPolynomial) {\n      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n    }\n\n    texture._source = InternalTextureSource.CubePrefiltered;\n\n    if (_this.getCaps().textureLOD) {\n      // Do not add extra process if texture lod is supported.\n      if (onLoad) {\n        onLoad(texture);\n      }\n\n      return;\n    }\n\n    var mipSlices = 3;\n    var gl = _this._gl;\n    var width = loadData.width;\n\n    if (!width) {\n      return;\n    }\n\n    var textures = [];\n\n    for (var i = 0; i < mipSlices; i++) {\n      //compute LOD from even spacing in smoothness (matching shader calculation)\n      var smoothness = i / (mipSlices - 1);\n      var roughness = 1 - smoothness;\n      var minLODIndex = lodOffset; // roughness = 0\n\n      var maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n\n      var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n      var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n      var glTextureFromLod = new InternalTexture(_this, InternalTextureSource.Temp);\n      glTextureFromLod.type = texture.type;\n      glTextureFromLod.format = texture.format;\n      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n      glTextureFromLod.height = glTextureFromLod.width;\n      glTextureFromLod.isCube = true;\n      glTextureFromLod._cachedWrapU = 0;\n      glTextureFromLod._cachedWrapV = 0;\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n\n      glTextureFromLod.samplingMode = 2;\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      if (loadData.isDDS) {\n        var info = loadData.info;\n        var data = loadData.data;\n\n        _this._unpackFlipY(info.isCompressed);\n\n        DDSTools.UploadDDSLevels(_this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n      } else {\n        Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null); // Wrap in a base texture for easy binding.\n\n\n      var lodTexture = new BaseTexture(scene);\n      lodTexture.isCube = true;\n      lodTexture._texture = glTextureFromLod;\n      glTextureFromLod.isReady = true;\n      textures.push(lodTexture);\n    }\n\n    texture._lodTextureHigh = textures[2];\n    texture._lodTextureMid = textures[1];\n    texture._lodTextureLow = textures[0];\n\n    if (onLoad) {\n      onLoad(texture);\n    }\n  };\n\n  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};","map":{"version":3,"mappings":"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","names":["Scalar","SphericalPolynomial","InternalTexture","InternalTextureSource","Logger","CubeMapToSphericalPolynomialTools","BaseTexture","ThinEngine","FromHalfFloat","ToHalfFloat","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDPF_FOURCC","DDPF_RGB","DDPF_LUMINANCE","FourCCToInt32","value","charCodeAt","Int32ToFourCC","String","fromCharCode","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","FOURCC_D3DFMT_R16G16B16A16F","FOURCC_D3DFMT_R32G32B32A32F","DXGI_FORMAT_R32G32B32A32_FLOAT","DXGI_FORMAT_R16G16B16A16_FLOAT","DXGI_FORMAT_B8G8R8X8_UNORM","headerLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFlags","off_pfFourCC","off_RGBbpp","off_RMask","off_GMask","off_BMask","off_AMask","off_caps2","off_dxgiFormat","DDSTools","data","header","Int32Array","buffer","byteOffset","extendedHeader","mipmapCount","Math","max","fourCC","dxgiFormat","textureType","width","height","isFourCC","isRGB","isLuminance","isCube","isCompressed","dataOffset","dataLength","arrayBuffer","lod","destArray","Float32Array","srcData","Uint16Array","index","y","x","srcPos","StoreLODInAlphaChannel","Uint8Array","Clamp","rOffset","gOffset","bOffset","aOffset","byteArray","_ExtractLongWordOrder","engine","texture","info","loadMipmaps","faces","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","sphericalPolynomial","Array","ext","getCaps","s3tc","generateMipMaps","mip","internalCompressedFormat","blockBytes","Error","bpp","computeFormats","supported","console","error","_getRGBABufferInternalSizedFormat","startFace","caps","face","i","format","floatArray","_badOS","_badDesktopOS","textureHalfFloat","textureFloat","_GetFloatAsUIntRGBAArrayBuffer","push","_GetFloatRGBAArrayBuffer","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetHalfFloatAsFloatRGBAArrayBuffer","type","floatAvailable","textureFloatLinearFiltering","halfFloatAvailable","textureHalfFloatLinearFiltering","destType","dataGetter","dataGetterPolynomial","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetHalfFloatRGBAArrayBuffer","_uploadDataToTextureDirectly","_GetRGBArrayBuffer","_GetRGBAArrayBuffer","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","paddedRowSize","floor","_GetLuminanceArrayBuffer","_uploadCompressedDataToTextureDirectly","undefined","length","ConvertCubeMapToSphericalPolynomial","size","right","left","up","down","front","back","gammaSpace","prototype","createPrefilteredCubeTexture","rootUrl","scene","lodScale","lodOffset","onLoad","onError","forcedExtension","createPolynomials","callback","loadData","_sphericalPolynomial","_source","CubePrefiltered","_this","textureLOD","mipSlices","gl","_gl","textures","smoothness","roughness","minLODIndex","maxLODIndex","Log2","mipmapIndex","round","min","glTextureFromLod","Temp","pow","_cachedWrapU","_cachedWrapV","_bindTextureDirectly","TEXTURE_CUBE_MAP","samplingMode","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","isDDS","_unpackFlipY","UploadDDSLevels","Warn","lodTexture","_texture","isReady","_lodTextureHigh","_lodTextureMid","_lodTextureLow","createCubeTexture"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/dds.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { Scene } from \"../scene\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\r\n\r\nimport \"../Engines/Extensions/engine.cubeTexture\";\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nconst DDS_MAGIC = 0x20534444;\r\n\r\nconst //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nconst DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nconst //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\r\n}\r\n\r\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nconst headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nconst off_magic = 0;\r\n\r\nconst off_size = 1;\r\nconst off_flags = 2;\r\nconst off_height = 3;\r\nconst off_width = 4;\r\n\r\nconst off_mipmapCount = 7;\r\n\r\nconst off_pfFlags = 20;\r\nconst off_pfFourCC = 21;\r\nconst off_RGBbpp = 22;\r\nconst off_RMask = 23;\r\nconst off_GMask = 24;\r\nconst off_BMask = 25;\r\nconst off_AMask = 26;\r\n// var off_caps1 = 27;\r\nconst off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nconst off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        let mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const fourCC = header[off_pfFourCC];\r\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_FLOAT;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType,\r\n        };\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        const destArray = new Float32Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Uint16Array(dataLength);\r\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Float32Array(dataLength);\r\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        const destArray = new Uint16Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                destArray[index] = ToHalfFloat(srcData[index]);\r\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\r\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                } else {\r\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number,\r\n        aOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = x + y * width;\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @param engine\r\n     * @param texture\r\n     * @param data\r\n     * @param info\r\n     * @param loadMipmaps\r\n     * @param faces\r\n     * @param lodIndex\r\n     * @param currentFace\r\n     * @param destTypeMustBeFilterable\r\n     * @hidden\r\n     */\r\n    public static UploadDDSLevels(\r\n        engine: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView,\r\n        info: DDSInfo,\r\n        loadMipmaps: boolean,\r\n        faces: number,\r\n        lodIndex = -1,\r\n        currentFace?: number,\r\n        destTypeMustBeFilterable = true\r\n    ) {\r\n        let sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = new Array<ArrayBufferView>();\r\n        }\r\n        const ext = !!engine.getCaps().s3tc;\r\n\r\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\r\n        texture.generateMipMaps = loadMipmaps;\r\n\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        let fourCC: number,\r\n            width: number,\r\n            height: number,\r\n            dataLength: number = 0,\r\n            dataOffset: number;\r\n        let byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        let bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    bpp = 64;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    bpp = 128;\r\n                    break;\r\n                case FOURCC_DX10: {\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 64;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 128;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                default:\r\n                    console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        const caps = engine.getCaps();\r\n        for (let face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = lodIndex === -1 ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                        dataLength = width * height * 4;\r\n                        let floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\r\n                            // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            } else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(\r\n                                        DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i)\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        } else {\r\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n\r\n                            const destType =\r\n                                (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\r\n                                    ? Constants.TEXTURETYPE_FLOAT\r\n                                    : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\r\n                                    ? Constants.TEXTURETYPE_HALF_FLOAT\r\n                                    : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                            let dataGetter: (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView;\r\n                            let dataGetterPolynomial: Nullable<\r\n                                (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView\r\n                            > = null;\r\n\r\n                            switch (bpp) {\r\n                                case 128: {\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    // 64 bpp\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            texture.type = destType;\r\n\r\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n\r\n                            if (sphericalPolynomialFaces && i == 0) {\r\n                                sphericalPolynomialFaces.push(\r\n                                    dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        if (bpp === 24) {\r\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else {\r\n                            // 32\r\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        const unpackAlignment = engine._getUnpackAlignement();\r\n                        const unpaddedRowSize = width;\r\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                type: Constants.TEXTURETYPE_FLOAT,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n\r\ndeclare module \"../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number,\r\n            forcedExtension?: any,\r\n            createPolynomials?: boolean\r\n        ): InternalTexture;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\r\nThinEngine.prototype.createPrefilteredCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    lodScale: number,\r\n    lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = true\r\n): InternalTexture {\r\n    const callback = (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        } else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        const gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            const smoothness = i / (mipSlices - 1);\r\n            const roughness = 1 - smoothness;\r\n\r\n            const minLODIndex = lodOffset; // roughness = 0\r\n            const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            glTextureFromLod._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            glTextureFromLod._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                const info: DDSInfo = loadData.info;\r\n                const data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            } else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture.isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}