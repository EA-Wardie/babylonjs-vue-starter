{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Color4 } from \"../Maths/math.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext.js\";\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL.js\";\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL.js\";\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper.js\";\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager.js\";\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper.js\";\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler.js\";\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree.js\";\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer.js\";\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext.js\";\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext.js\";\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups.js\";\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad.js\";\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList.js\";\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery.js\";\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM.js\";\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\n/**\n * The web GPU engine class provides support for WebGPU version of babylon.js.\n * @since 5.0.0\n */\n\nvar WebGPUEngine =\n/** @class */\nfunction (_super) {\n  __extends(WebGPUEngine, _super);\n  /**\n   * Create a new instance of the gpu engine.\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   */\n\n\n  function WebGPUEngine(canvas, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = this;\n\n    var _a, _b, _c, _d;\n\n    _this = _super.call(this, null) || this; // Page Life cycle and constants\n\n    _this._uploadEncoderDescriptor = {\n      label: \"upload\"\n    };\n    _this._renderEncoderDescriptor = {\n      label: \"render\"\n    };\n    _this._renderTargetEncoderDescriptor = {\n      label: \"renderTarget\"\n    };\n    /** @hidden */\n\n    _this._clearDepthValue = 1;\n    /** @hidden */\n\n    _this._clearReverseDepthValue = 0;\n    /** @hidden */\n\n    _this._clearStencilValue = 0;\n    _this._defaultSampleCount = 4; // Only supported value for now.\n\n    _this._glslang = null;\n    _this._tintWASM = null;\n    /** @hidden */\n\n    _this._compiledComputeEffects = {};\n    /** @hidden */\n\n    _this._counters = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Counters from last frame\n     */\n\n    _this.countersLastFrame = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Max number of uncaptured error messages to log\n     */\n\n    _this.numMaxUncapturedErrors = 20;\n    _this._commandBuffers = [null, null, null]; // Frame Buffer Life Cycle (recreated for each render target pass)\n\n    /** @hidden */\n\n    _this._currentRenderPass = null;\n    /** @hidden */\n\n    _this._mainRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @hidden */\n\n    _this._rttRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @hidden */\n\n    _this._pendingDebugCommands = [];\n    /** @hidden */\n\n    _this._onAfterUnbindFrameBufferObservable = new Observable();\n    _this._currentOverrideVertexBuffers = null;\n    _this._currentIndexBuffer = null;\n    _this._colorWriteLocal = true;\n    _this._forceEnableEffect = false; // TODO WEBGPU remove those variables when code stabilized\n\n    /** @hidden */\n\n    _this.dbgShowShaderCode = false;\n    /** @hidden */\n\n    _this.dbgSanityChecks = true;\n    /** @hidden */\n\n    _this.dbgVerboseLogsForFirstFrames = false;\n    /** @hidden */\n\n    _this.dbgVerboseLogsNumFrames = 10;\n    /** @hidden */\n\n    _this.dbgLogIfNotDrawWrapper = true;\n    /** @hidden */\n\n    _this.dbgShowEmptyEnableEffectCalls = true; //------------------------------------------------------------------------------\n    //                              Dynamic WebGPU States\n    //------------------------------------------------------------------------------\n    // index 0 is for main render pass, 1 for RTT render pass\n\n    _this._viewportsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    _this._scissorsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    _this._scissorCached = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 0\n    };\n    _this._stencilRefsCurrent = [-1, -1];\n    _this._blendColorsCurrent = [[null, null, null, null], [null, null, null, null]];\n    _this._name = \"WebGPU\";\n    _this.isNDCHalfZRange = true;\n    _this.hasOriginBottomLeft = false;\n    options.deviceDescriptor = options.deviceDescriptor || {};\n    options.swapChainFormat = options.swapChainFormat || WebGPUConstants.TextureFormat.BGRA8Unorm;\n    options.antialiasing = options.antialiasing === undefined ? true : options.antialiasing;\n    options.stencil = (_a = options.stencil) !== null && _a !== void 0 ? _a : true;\n    options.enableGPUDebugMarkers = (_b = options.enableGPUDebugMarkers) !== null && _b !== void 0 ? _b : false;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n    Logger.Log(\"Babylon.js v\".concat(Engine.Version, \" - \").concat(_this.description, \" engine\"));\n\n    if (!navigator.gpu) {\n      Logger.Error(\"WebGPU is not supported by your browser.\");\n      return _this;\n    }\n\n    _this._isWebGPU = true;\n    _this._shaderPlatformName = \"WEBGPU\";\n\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n\n    if (options.audioEngine === undefined) {\n      options.audioEngine = true;\n    }\n\n    _this._deterministicLockstep = options.deterministicLockstep;\n    _this._lockstepMaxSteps = options.lockstepMaxSteps;\n    _this._timeStep = options.timeStep || 1 / 60;\n    _this._doNotHandleContextLost = !!options.doNotHandleContextLost;\n    _this._canvas = canvas;\n    _this._options = options;\n    _this.premultipliedAlpha = (_c = options.premultipliedAlpha) !== null && _c !== void 0 ? _c : true;\n    var devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\n    var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\n    var adaptToDeviceRatio = (_d = options.adaptToDeviceRatio) !== null && _d !== void 0 ? _d : false;\n    _this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\n    _this._mainPassSampleCount = options.antialiasing ? _this._defaultSampleCount : 1;\n    _this._isStencilEnable = options.stencil;\n\n    _this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);\n\n    _this._shaderProcessor = new WebGPUShaderProcessorGLSL();\n    _this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\n    return _this;\n  }\n\n  Object.defineProperty(WebGPUEngine.prototype, \"snapshotRenderingMode\", {\n    /**\n     * Gets or sets the snapshot rendering mode\n     */\n    get: function get() {\n      return this._snapshotRendering.mode;\n    },\n    set: function set(mode) {\n      this._snapshotRendering.mode = mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new snapshot at the next frame using the current snapshotRenderingMode\n   */\n\n  WebGPUEngine.prototype.snapshotRenderingReset = function () {\n    this._snapshotRendering.reset();\n  };\n\n  Object.defineProperty(WebGPUEngine.prototype, \"snapshotRendering\", {\n    /**\n     * Enables or disables the snapshot rendering mode\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\n     */\n    get: function get() {\n      return this._snapshotRendering.enabled;\n    },\n    set: function set(activate) {\n      this._snapshotRendering.enabled = activate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"disableCacheSamplers\", {\n    /**\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\n     */\n    get: function get() {\n      return this._cacheSampler ? this._cacheSampler.disabled : false;\n    },\n    set: function set(disable) {\n      if (this._cacheSampler) {\n        this._cacheSampler.disabled = disable;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"disableCacheRenderPipelines\", {\n    /**\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\n     */\n    get: function get() {\n      return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\n    },\n    set: function set(disable) {\n      if (this._cacheRenderPipeline) {\n        this._cacheRenderPipeline.disabled = disable;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"disableCacheBindGroups\", {\n    /**\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\n     */\n    get: function get() {\n      return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\n    },\n    set: function set(disable) {\n      if (this._cacheBindGroups) {\n        this._cacheBindGroups.disabled = disable;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine, \"IsSupportedAsync\", {\n    /**\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\n     */\n    get: function get() {\n      return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then(function (adapter) {\n        return !!adapter;\n      }, function () {\n        return false;\n      })[\"catch\"](function () {\n        return false;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine, \"IsSupported\", {\n    /**\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\n     */\n    get: function get() {\n      Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"supportsUniformBuffers\", {\n    /**\n     * Gets a boolean indicating that the engine supports uniform buffers\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"supportedExtensions\", {\n    /** Gets the supported extensions by the WebGPU adapter */\n    get: function get() {\n      return this._adapterSupportedExtensions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"enabledExtensions\", {\n    /** Gets the currently enabled extensions on the WebGPU device */\n    get: function get() {\n      return this._deviceEnabledExtensions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"description\", {\n    /**\n     * Returns a string describing the current engine\n     */\n    get: function get() {\n      var description = this.name + this.version;\n      return description;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"version\", {\n    /**\n     * Returns the version of the engine\n     */\n    get: function get() {\n      return 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets an object containing information about the current engine context\n   * @returns an object containing the vendor, the renderer and the version of the current engine context\n   */\n\n  WebGPUEngine.prototype.getInfo = function () {\n    return {\n      vendor: \"unknown vendor\",\n      renderer: \"unknown renderer\",\n      version: \"unknown version\"\n    };\n  };\n\n  Object.defineProperty(WebGPUEngine.prototype, \"compatibilityMode\", {\n    /**\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\n     * See https://doc.babylonjs.com/advanced_topics/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\n     */\n    get: function get() {\n      return this._compatibilityMode;\n    },\n    set: function set(mode) {\n      this._compatibilityMode = mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUEngine.prototype, \"currentSampleCount\", {\n    /** @hidden */\n    get: function get() {\n      return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Create a new instance of the gpu engine asynchronously\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   * @returns a promise that resolves with the created engine\n   */\n\n  WebGPUEngine.CreateAsync = function (canvas, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var engine = new WebGPUEngine(canvas, options);\n    return new Promise(function (resolve) {\n      engine.initAsync(options.glslangOptions, options.twgslOptions).then(function () {\n        return resolve(engine);\n      });\n    });\n  }; //------------------------------------------------------------------------------\n  //                              Initialization\n  //------------------------------------------------------------------------------\n\n  /**\n   * Initializes the WebGPU context and dependencies.\n   * @param glslangOptions Defines the GLSLang compiler options if necessary\n   * @param twgslOptions Defines the Twgsl compiler options if necessary\n   * @returns a promise notifying the readiness of the engine.\n   */\n\n\n  WebGPUEngine.prototype.initAsync = function (glslangOptions, twgslOptions) {\n    var _this = this;\n\n    var _a;\n\n    return this._initGlslang(glslangOptions !== null && glslangOptions !== void 0 ? glslangOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.glslangOptions).then(function (glslang) {\n      var _a;\n\n      _this._glslang = glslang;\n      _this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\n      return _this._tintWASM ? _this._tintWASM.initTwgsl(twgslOptions !== null && twgslOptions !== void 0 ? twgslOptions : (_a = _this._options) === null || _a === void 0 ? void 0 : _a.twgslOptions).then(function () {\n        return navigator.gpu.requestAdapter(_this._options);\n      }, function (msg) {\n        Logger.Error(\"Can not initialize twgsl!\");\n        Logger.Error(msg);\n        throw Error(\"WebGPU initializations stopped.\");\n      }) : navigator.gpu.requestAdapter(_this._options);\n    }, function (msg) {\n      Logger.Error(\"Can not initialize glslang!\");\n      Logger.Error(msg);\n      throw Error(\"WebGPU initializations stopped.\");\n    }).then(function (adapter) {\n      var _a;\n\n      if (!adapter) {\n        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\n      } else {\n        _this._adapter = adapter;\n        _this._adapterSupportedExtensions = [];\n        (_a = _this._adapter.features) === null || _a === void 0 ? void 0 : _a.forEach(function (feature) {\n          return _this._adapterSupportedExtensions.push(feature);\n        });\n        var deviceDescriptor = _this._options.deviceDescriptor;\n\n        if (deviceDescriptor === null || deviceDescriptor === void 0 ? void 0 : deviceDescriptor.requiredFeatures) {\n          var requestedExtensions = deviceDescriptor.requiredFeatures;\n          var validExtensions = [];\n\n          for (var _i = 0, requestedExtensions_1 = requestedExtensions; _i < requestedExtensions_1.length; _i++) {\n            var extension = requestedExtensions_1[_i];\n\n            if (_this._adapterSupportedExtensions.indexOf(extension) !== -1) {\n              validExtensions.push(extension);\n            }\n          }\n\n          deviceDescriptor.requiredFeatures = validExtensions;\n        }\n\n        return _this._adapter.requestDevice(_this._options.deviceDescriptor);\n      }\n    }).then(function (device) {\n      var _a, _b;\n\n      _this._device = device;\n      _this._deviceEnabledExtensions = [];\n      (_a = _this._device.features) === null || _a === void 0 ? void 0 : _a.forEach(function (feature) {\n        return _this._deviceEnabledExtensions.push(feature);\n      });\n      var numUncapturedErrors = -1;\n\n      _this._device.addEventListener(\"uncapturederror\", function (event) {\n        if (++numUncapturedErrors < _this.numMaxUncapturedErrors) {\n          Logger.Warn(\"WebGPU uncaptured error (\".concat(numUncapturedErrors + 1, \"): \").concat(event.error, \" - \").concat(event.error.message));\n        } else if (numUncapturedErrors++ === _this.numMaxUncapturedErrors) {\n          Logger.Warn(\"WebGPU uncaptured error: too many warnings (\".concat(_this.numMaxUncapturedErrors, \"), no more warnings will be reported to the console for this engine.\"));\n        }\n      });\n\n      if (!_this._doNotHandleContextLost) {\n        (_b = _this._device.lost) === null || _b === void 0 ? void 0 : _b.then(function (info) {\n          _this._contextWasLost = true;\n          Logger.Warn(\"WebGPU context lost. \" + info);\n\n          _this.onContextLostObservable.notifyObservers(_this);\n\n          _this._restoreEngineAfterContextLost(_this.initAsync.bind(_this));\n        });\n      }\n    }, function (e) {\n      Logger.Error(\"Could not retrieve a WebGPU device.\");\n      Logger.Error(e);\n    }).then(function () {\n      _this._bufferManager = new WebGPUBufferManager(_this._device);\n      _this._textureHelper = new WebGPUTextureHelper(_this._device, _this._glslang, _this._tintWASM, _this._bufferManager);\n      _this._cacheSampler = new WebGPUCacheSampler(_this._device);\n      _this._cacheBindGroups = new WebGPUCacheBindGroups(_this._device, _this._cacheSampler, _this);\n      _this._timestampQuery = new WebGPUTimestampQuery(_this._device, _this._bufferManager);\n      _this._occlusionQuery = _this._device.createQuerySet ? new WebGPUOcclusionQuery(_this, _this._device, _this._bufferManager) : undefined;\n      _this._bundleList = new WebGPUBundleList(_this._device);\n      _this._bundleListRenderTarget = new WebGPUBundleList(_this._device);\n      _this._snapshotRendering = new WebGPUSnapshotRendering(_this, _this._snapshotRenderingMode, _this._bundleList, _this._bundleListRenderTarget);\n      _this._ubInvertY = _this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\n      _this._ubDontInvertY = _this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\n\n      if (_this.dbgVerboseLogsForFirstFrames) {\n        if (_this._count === undefined) {\n          _this._count = 0;\n          console.log(\"%c frame #\" + _this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n\n      _this._uploadEncoder = _this._device.createCommandEncoder(_this._uploadEncoderDescriptor);\n      _this._renderEncoder = _this._device.createCommandEncoder(_this._renderEncoderDescriptor);\n      _this._renderTargetEncoder = _this._device.createCommandEncoder(_this._renderTargetEncoderDescriptor);\n      _this._emptyVertexBuffer = new VertexBuffer(_this, [0], \"\", false, false, 1, false, 0, 1);\n\n      _this._initializeLimits();\n\n      _this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(_this._device, _this._emptyVertexBuffer, !_this._caps.textureFloatLinearFiltering);\n      _this._depthCullingState = new WebGPUDepthCullingState(_this._cacheRenderPipeline);\n      _this._stencilStateComposer = new WebGPUStencilStateComposer(_this._cacheRenderPipeline);\n      _this._stencilStateComposer.stencilGlobal = _this._stencilState;\n      _this._depthCullingState.depthTest = true;\n      _this._depthCullingState.depthFunc = 515;\n      _this._depthCullingState.depthMask = true;\n\n      _this._textureHelper.setCommandEncoder(_this._uploadEncoder);\n\n      _this._clearQuad = new WebGPUClearQuad(_this._device, _this, _this._emptyVertexBuffer);\n      _this._defaultDrawContext = _this.createDrawContext();\n      _this._currentDrawContext = _this._defaultDrawContext;\n      _this._defaultMaterialContext = _this.createMaterialContext();\n      _this._currentMaterialContext = _this._defaultMaterialContext;\n\n      _this._initializeContextAndSwapChain();\n\n      _this._initializeMainAttachments();\n\n      _this.resize();\n    })[\"catch\"](function (e) {\n      Logger.Error(\"Can not create WebGPU Device and/or context.\");\n      Logger.Error(e);\n\n      if (console.trace) {\n        console.trace();\n      }\n    });\n  };\n\n  WebGPUEngine.prototype._initGlslang = function (glslangOptions) {\n    glslangOptions = glslangOptions || {};\n    glslangOptions = __assign(__assign({}, WebGPUEngine._GLSLslangDefaultOptions), glslangOptions);\n\n    if (glslangOptions.glslang) {\n      return Promise.resolve(glslangOptions.glslang);\n    }\n\n    if (self.glslang) {\n      return self.glslang(glslangOptions.wasmPath);\n    }\n\n    if (glslangOptions.jsPath && glslangOptions.wasmPath) {\n      if (IsWindowObjectExist()) {\n        return Tools.LoadScriptAsync(glslangOptions.jsPath).then(function () {\n          return self.glslang(glslangOptions.wasmPath);\n        });\n      } else {\n        importScripts(glslangOptions.jsPath);\n        return self.glslang(glslangOptions.wasmPath);\n      }\n    }\n\n    return Promise.reject(\"gslang is not available.\");\n  };\n\n  WebGPUEngine.prototype._initializeLimits = function () {\n    // Init caps\n    // TODO WEBGPU Real Capability check once limits will be working.\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 8192,\n      maxCubemapTextureSize: 2048,\n      maxRenderTextureSize: 8192,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 15,\n      maxFragmentUniformVectors: 1024,\n      maxVertexUniformVectors: 1024,\n      standardDerivatives: true,\n      astc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined,\n      s3tc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      pvrtc: null,\n      etc1: null,\n      etc2: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined,\n      bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      maxAnisotropy: 4,\n      uintIndices: true,\n      fragmentDepthSupported: true,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: true,\n      textureFloat: true,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: true,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      drawBuffersExtension: true,\n      depthTextureExtension: true,\n      vertexArrayObject: false,\n      instancedArrays: true,\n      timerQuery: typeof BigUint64Array !== \"undefined\" && this.enabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? true : undefined,\n      supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\n      canUseTimestampForTimerQuery: true,\n      multiview: false,\n      oculusMultiview: false,\n      parallelShaderCompile: undefined,\n      blendMinMax: true,\n      maxMSAASamples: 4,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: true,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: true\n    };\n    this._caps.parallelShaderCompile = null;\n    this._features = {\n      forceBitmapOverHTMLImageElement: true,\n      supportRenderAndCopyToLodForFloatTextures: true,\n      supportDepthStencilTexture: true,\n      supportShadowSamplers: true,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: true,\n      trackUbosInFrame: true,\n      checkUbosContentBeforeUpload: true,\n      supportCSM: true,\n      basisNeedsPOT: false,\n      support3DTextures: true,\n      needTypeSuffixInShaderConstants: true,\n      supportMSAA: true,\n      supportSSAO2: true,\n      supportExtendedTextureFormats: true,\n      supportSwitchCaseInShader: true,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: true,\n      supportRenderPasses: true,\n      _collectUbosUpdatedInFrame: false\n    };\n  };\n\n  WebGPUEngine.prototype._initializeContextAndSwapChain = function () {\n    this._context = this._canvas.getContext(\"webgpu\");\n\n    this._configureContext(this._canvas.width, this._canvas.height);\n\n    this._colorFormat = this._options.swapChainFormat;\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;\n  }; // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\n\n\n  WebGPUEngine.prototype._initializeMainAttachments = function () {\n    var _a;\n\n    this._mainTextureExtends = {\n      width: this.getRenderWidth(),\n      height: this.getRenderHeight(),\n      depthOrArrayLayers: 1\n    };\n    var bufferDataUpdate = new Float32Array([this.getRenderHeight()]);\n\n    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\n\n    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\n\n    var mainColorAttachments;\n\n    if (this._options.antialiasing) {\n      var mainTextureDescriptor = {\n        size: this._mainTextureExtends,\n        mipLevelCount: 1,\n        sampleCount: this._mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.RenderAttachment\n      };\n      (_a = this._mainTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n      this._mainTexture = this._device.createTexture(mainTextureDescriptor);\n      mainColorAttachments = [{\n        view: this._mainTexture.createView(),\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\n\n      }];\n    } else {\n      mainColorAttachments = [{\n        view: undefined,\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }];\n    }\n\n    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\n\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n\n    var depthTextureDescriptor = {\n      size: this._mainTextureExtends,\n      mipLevelCount: 1,\n      sampleCount: this._mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: this._mainRenderPassWrapper.depthTextureFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment\n    };\n\n    if (this._depthTexture) {\n      this._depthTexture.destroy();\n    }\n\n    this._depthTexture = this._device.createTexture(depthTextureDescriptor);\n    var mainDepthAttachment = {\n      view: this._depthTexture.createView(),\n      depthClearValue: this._clearDepthValue,\n      depthLoadOp: WebGPUConstants.LoadOp.Clear,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilClearValue: this._clearStencilValue,\n      stencilLoadOp: WebGPUConstants.LoadOp.Clear,\n      stencilStoreOp: WebGPUConstants.StoreOp.Store\n    };\n    this._mainRenderPassWrapper.renderPassDescriptor = {\n      colorAttachments: mainColorAttachments,\n      depthStencilAttachment: mainDepthAttachment\n    };\n\n    if (this._mainRenderPassWrapper.renderPass !== null) {\n      this._endMainRenderPass();\n    }\n  };\n\n  WebGPUEngine.prototype._configureContext = function (width, height) {\n    this._context.configure({\n      device: this._device,\n      format: this._options.swapChainFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\n      compositingAlphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasCompositingAlphaMode.Premultiplied : WebGPUConstants.CanvasCompositingAlphaMode.Opaque,\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      }\n    });\n  };\n  /**\n   * Force a specific size of the canvas\n   * @param width defines the new canvas' width\n   * @param height defines the new canvas' height\n   * @param forceSetSize true to force setting the sizes of the underlying canvas\n   * @returns true if the size was changed\n   */\n\n\n  WebGPUEngine.prototype.setSize = function (width, height, forceSetSize) {\n    if (forceSetSize === void 0) {\n      forceSetSize = false;\n    }\n\n    if (!_super.prototype.setSize.call(this, width, height, forceSetSize)) {\n      return false;\n    }\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - setSize called -\", width, height);\n      }\n    }\n\n    this._configureContext(width, height);\n\n    this._initializeMainAttachments();\n\n    if (this.snapshotRendering) {\n      // reset snapshot rendering so that the next frame will record a new list of bundles\n      this.snapshotRenderingReset();\n    }\n\n    return true;\n  };\n  /**\n   * @param shaderLanguage\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._getShaderProcessor = function (shaderLanguage) {\n    if (shaderLanguage === ShaderLanguage.WGSL) {\n      return this._shaderProcessorWGSL;\n    }\n\n    return this._shaderProcessor;\n  };\n  /**\n   * @param shaderLanguage\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._getShaderProcessingContext = function (shaderLanguage) {\n    return new WebGPUShaderProcessingContext(shaderLanguage);\n  }; //------------------------------------------------------------------------------\n  //                          Static Pipeline WebGPU States\n  //------------------------------------------------------------------------------\n\n  /** @hidden */\n\n\n  WebGPUEngine.prototype.applyStates = function () {\n    this._stencilStateComposer.apply();\n\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\n  };\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n\n\n  WebGPUEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames && !bruteForce) {\n      return;\n    } //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\n    // _forceEnableEffect = true assumes the role of _currentEffect = null\n\n\n    this._forceEnableEffect = true;\n    this._currentIndexBuffer = null;\n    this._currentOverrideVertexBuffers = null;\n\n    this._cacheRenderPipeline.setBuffers(null, null, null);\n\n    if (bruteForce) {\n      this._stencilStateComposer.reset();\n\n      this._depthCullingState.reset();\n\n      this._depthCullingState.depthFunc = 515;\n\n      this._alphaState.reset();\n\n      this._alphaMode = 1;\n      this._alphaEquation = 0;\n\n      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\n\n      this._cacheRenderPipeline.setAlphaBlendEnabled(false);\n\n      this.setColorWrite(true);\n    }\n\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  };\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n\n\n  WebGPUEngine.prototype.setColorWrite = function (enable) {\n    this._colorWriteLocal = enable;\n\n    this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\n  };\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n\n\n  WebGPUEngine.prototype.getColorWrite = function () {\n    return this._colorWriteLocal;\n  };\n\n  WebGPUEngine.prototype._resetCurrentViewport = function (index) {\n    this._viewportsCurrent[index].x = 0;\n    this._viewportsCurrent[index].y = 0;\n    this._viewportsCurrent[index].w = 0;\n    this._viewportsCurrent[index].h = 0;\n\n    if (index === 1) {\n      this._viewportCached.x = 0;\n      this._viewportCached.y = 0;\n      this._viewportCached.z = 0;\n      this._viewportCached.w = 0;\n    }\n  };\n\n  WebGPUEngine.prototype._mustUpdateViewport = function (renderPass) {\n    var index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    var x = this._viewportCached.x,\n        y = this._viewportCached.y,\n        w = this._viewportCached.z,\n        h = this._viewportCached.w;\n    var update = this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\n\n    if (update) {\n      this._viewportsCurrent[index].x = this._viewportCached.x;\n      this._viewportsCurrent[index].y = this._viewportCached.y;\n      this._viewportsCurrent[index].w = this._viewportCached.z;\n      this._viewportsCurrent[index].h = this._viewportCached.w;\n    }\n\n    return update;\n  };\n\n  WebGPUEngine.prototype._applyViewport = function (renderPass) {\n    var y = Math.floor(this._viewportCached.y);\n    var h = Math.floor(this._viewportCached.w);\n\n    if (!this._currentRenderTarget) {\n      y = this.getRenderHeight() - y - h;\n    }\n\n    renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - viewport applied - (\", this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  };\n  /**\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._viewport = function (x, y, width, height) {\n    this._viewportCached.x = x;\n    this._viewportCached.y = y;\n    this._viewportCached.z = width;\n    this._viewportCached.w = height;\n  };\n\n  WebGPUEngine.prototype._resetCurrentScissor = function (index) {\n    this._scissorsCurrent[index].x = 0;\n    this._scissorsCurrent[index].y = 0;\n    this._scissorsCurrent[index].w = 0;\n    this._scissorsCurrent[index].h = 0;\n  };\n\n  WebGPUEngine.prototype._mustUpdateScissor = function (renderPass) {\n    var index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    var x = this._scissorCached.x,\n        y = this._scissorCached.y,\n        w = this._scissorCached.z,\n        h = this._scissorCached.w;\n    var update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\n\n    if (update) {\n      this._scissorsCurrent[index].x = this._scissorCached.x;\n      this._scissorsCurrent[index].y = this._scissorCached.y;\n      this._scissorsCurrent[index].w = this._scissorCached.z;\n      this._scissorsCurrent[index].h = this._scissorCached.w;\n    }\n\n    return update;\n  };\n\n  WebGPUEngine.prototype._applyScissor = function (renderPass) {\n    renderPass.setScissorRect(this._scissorCached.x, this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y, this._scissorCached.z, this._scissorCached.w);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - scissor applied - (\", this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  };\n\n  WebGPUEngine.prototype._scissorIsActive = function () {\n    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\n  };\n\n  WebGPUEngine.prototype.enableScissor = function (x, y, width, height) {\n    this._scissorCached.x = x;\n    this._scissorCached.y = y;\n    this._scissorCached.z = width;\n    this._scissorCached.w = height;\n  };\n\n  WebGPUEngine.prototype.disableScissor = function () {\n    this._scissorCached.x = 0;\n    this._scissorCached.y = 0;\n    this._scissorCached.z = 0;\n    this._scissorCached.w = 0;\n\n    this._resetCurrentScissor(0);\n\n    this._resetCurrentScissor(1);\n  };\n\n  WebGPUEngine.prototype._resetCurrentStencilRef = function (index) {\n    this._stencilRefsCurrent[index] = -1;\n  };\n\n  WebGPUEngine.prototype._mustUpdateStencilRef = function (renderPass) {\n    var index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    var update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\n\n    if (update) {\n      this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\n    }\n\n    return update;\n  };\n  /**\n   * @param renderPass\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._applyStencilRef = function (renderPass) {\n    var _a;\n\n    renderPass.setStencilReference((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0);\n  };\n\n  WebGPUEngine.prototype._resetCurrentColorBlend = function (index) {\n    this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\n  };\n\n  WebGPUEngine.prototype._mustUpdateBlendColor = function (renderPass) {\n    var index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    var colorBlend = this._alphaState._blendConstants;\n    var update = colorBlend[0] !== this._blendColorsCurrent[index][0] || colorBlend[1] !== this._blendColorsCurrent[index][1] || colorBlend[2] !== this._blendColorsCurrent[index][2] || colorBlend[3] !== this._blendColorsCurrent[index][3];\n\n    if (update) {\n      this._blendColorsCurrent[index][0] = colorBlend[0];\n      this._blendColorsCurrent[index][1] = colorBlend[1];\n      this._blendColorsCurrent[index][2] = colorBlend[2];\n      this._blendColorsCurrent[index][3] = colorBlend[3];\n    }\n\n    return update;\n  };\n\n  WebGPUEngine.prototype._applyBlendColor = function (renderPass) {\n    renderPass.setBlendConstant(this._alphaState._blendConstants);\n  };\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n\n\n  WebGPUEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    } // Some PGs are using color3...\n\n\n    if (color && color.a === undefined) {\n      color.a = 1;\n    }\n\n    var hasScissor = this._scissorIsActive();\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - clear called - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor);\n      }\n    } // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n\n\n    if (this._currentRenderTarget) {\n      if (hasScissor) {\n        if (!this._rttRenderPassWrapper.renderPass) {\n          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\n        }\n\n        if (!this.compatibilityMode) {\n          this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      } else {\n        if (this._currentRenderPass) {\n          this._endRenderTargetRenderPass();\n        }\n\n        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\n      }\n    } else {\n      if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\n        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\n      }\n\n      if (hasScissor) {\n        if (!this.compatibilityMode) {\n          this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      }\n    }\n  };\n\n  WebGPUEngine.prototype._clearFullQuad = function (clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n\n    var renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\n\n    var renderPassIndex = this._getCurrentRenderPassIndex();\n\n    var bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n\n    this._clearQuad.setColorFormat(this._colorFormat);\n\n    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\n\n    this._clearQuad.setMRTAttachments((_a = this._cacheRenderPipeline.mrtAttachments) !== null && _a !== void 0 ? _a : [], (_b = this._cacheRenderPipeline.mrtTextureArray) !== null && _b !== void 0 ? _b : [], this._cacheRenderPipeline.mrtTextureCount);\n\n    if (!this.compatibilityMode) {\n      bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\n    } else {\n      renderPass.setStencilReference(this._clearStencilValue);\n    }\n\n    var bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\n\n    if (!this.compatibilityMode) {\n      bundleList.addBundle(bundle);\n      bundleList.addItem(new WebGPURenderItemStencilRef((_c = this._stencilStateComposer.funcRef) !== null && _c !== void 0 ? _c : 0));\n\n      this._reportDrawCall();\n    } else {\n      this._applyStencilRef(renderPass);\n    }\n  }; //------------------------------------------------------------------------------\n  //                              Vertex/Index/Storage Buffers\n  //------------------------------------------------------------------------------\n\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the vertex buffer\n   * @returns the new buffer\n   */\n\n\n  WebGPUEngine.prototype.createVertexBuffer = function (data) {\n    var view;\n\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n\n    var dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\n\n    return dataBuffer;\n  };\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the dynamic vertex buffer\n   * @returns the new buffer\n   */\n\n\n  WebGPUEngine.prototype.createDynamicVertexBuffer = function (data) {\n    return this.createVertexBuffer(data);\n  };\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @returns a new buffer\n   */\n\n\n  WebGPUEngine.prototype.createIndexBuffer = function (indices) {\n    var is32Bits = true;\n    var view;\n\n    if (indices instanceof Uint32Array || indices instanceof Int32Array) {\n      view = indices;\n    } else if (indices instanceof Uint16Array) {\n      view = indices;\n      is32Bits = false;\n    } else {\n      if (indices.length > 65535) {\n        view = new Uint32Array(indices);\n      } else {\n        view = new Uint16Array(indices);\n        is32Bits = false;\n      }\n    }\n\n    var dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst);\n\n    dataBuffer.is32Bits = is32Bits;\n    return dataBuffer;\n  };\n  /**\n   * @param data\n   * @param creationFlags\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._createBuffer = function (data, creationFlags) {\n    var view;\n\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n\n    var flags = 0;\n\n    if (creationFlags & 1) {\n      flags |= WebGPUConstants.BufferUsage.CopySrc;\n    }\n\n    if (creationFlags & 2) {\n      flags |= WebGPUConstants.BufferUsage.CopyDst;\n    }\n\n    if (creationFlags & 4) {\n      flags |= WebGPUConstants.BufferUsage.Uniform;\n    }\n\n    if (creationFlags & 8) {\n      flags |= WebGPUConstants.BufferUsage.Vertex;\n    }\n\n    if (creationFlags & 16) {\n      flags |= WebGPUConstants.BufferUsage.Index;\n    }\n\n    if (creationFlags & 32) {\n      flags |= WebGPUConstants.BufferUsage.Storage;\n    }\n\n    return this._bufferManager.createBuffer(view, flags);\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.bindBuffersDirectly = function () {\n    throw \"Not implemented on WebGPU\";\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.updateAndBindInstancesBuffer = function () {\n    throw \"Not implemented on WebGPU\";\n  };\n  /**\n   * Bind a list of vertex buffers with the engine\n   * @param vertexBuffers defines the list of vertex buffers to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffers\n   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\n   */\n\n\n  WebGPUEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    this._currentIndexBuffer = indexBuffer;\n    this._currentOverrideVertexBuffers = overrideVertexBuffers !== null && overrideVertexBuffers !== void 0 ? overrideVertexBuffers : null;\n\n    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\n  };\n  /**\n   * @param buffer\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._releaseBuffer = function (buffer) {\n    return this._bufferManager.releaseBuffer(buffer);\n  }; //------------------------------------------------------------------------------\n  //                              Effects\n  //------------------------------------------------------------------------------\n\n  /**\n   * Create a new effect (used to store vertex/fragment shaders)\n   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\n   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\n   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\n   * @param samplers defines an array of string used to represent textures\n   * @param defines defines the string containing the defines to use to compile the shaders\n   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   * @returns the new Effect\n   */\n\n\n  WebGPUEngine.prototype.createEffect = function (baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage) {\n    var _a;\n\n    if (shaderLanguage === void 0) {\n      shaderLanguage = ShaderLanguage.GLSL;\n    }\n\n    var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\n    var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\n\n    var globalDefines = this._getGlobalDefines();\n\n    var fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : \"\";\n\n    if (globalDefines) {\n      fullDefines += \"\\n\" + globalDefines;\n    }\n\n    var name = vertex + \"+\" + fragment + \"@\" + fullDefines;\n\n    if (this._compiledEffects[name]) {\n      var compiledEffect = this._compiledEffects[name];\n\n      if (onCompiled && compiledEffect.isReady()) {\n        onCompiled(compiledEffect);\n      }\n\n      return compiledEffect;\n    }\n\n    var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);\n    this._compiledEffects[name] = effect;\n    return effect;\n  };\n\n  WebGPUEngine.prototype._compileRawShaderToSpirV = function (source, type) {\n    return this._glslang.compileGLSL(source, type);\n  };\n\n  WebGPUEngine.prototype._compileShaderToSpirV = function (source, type, defines, shaderVersion) {\n    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\n  };\n\n  WebGPUEngine.prototype._getWGSLShader = function (source, type, defines) {\n    if (defines) {\n      defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n    } else {\n      defines = \"\";\n    }\n\n    return defines + source;\n  };\n\n  WebGPUEngine.prototype._createPipelineStageDescriptor = function (vertexShader, fragmentShader, shaderLanguage) {\n    if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\n      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader);\n      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader);\n    }\n\n    return {\n      vertexStage: {\n        module: this._device.createShaderModule({\n          code: vertexShader\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: this._device.createShaderModule({\n          code: fragmentShader\n        }),\n        entryPoint: \"main\"\n      }\n    };\n  };\n\n  WebGPUEngine.prototype._compileRawPipelineStageDescriptor = function (vertexCode, fragmentCode, shaderLanguage) {\n    var vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\n    var fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\n    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\n  };\n\n  WebGPUEngine.prototype._compilePipelineStageDescriptor = function (vertexCode, fragmentCode, defines, shaderLanguage) {\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    var shaderVersion = \"#version 450\\n\";\n    var vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\n    var fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion) : this._getWGSLShader(fragmentCode, \"fragment\", defines);\n\n    var program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\n\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.createRawShaderProgram = function () {\n    throw \"Not available on WebGPU\";\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.createShaderProgram = function () {\n    throw \"Not available on WebGPU\";\n  };\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n\n\n  WebGPUEngine.prototype.inlineShaderCode = function (code) {\n    var sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  };\n  /**\n   * Creates a new pipeline context\n   * @param shaderProcessingContext defines the shader processing context used during the processing if available\n   * @returns the new pipeline\n   */\n\n\n  WebGPUEngine.prototype.createPipelineContext = function (shaderProcessingContext) {\n    return new WebGPUPipelineContext(shaderProcessingContext, this);\n  };\n  /**\n   * Creates a new material context\n   * @returns the new context\n   */\n\n\n  WebGPUEngine.prototype.createMaterialContext = function () {\n    return new WebGPUMaterialContext();\n  };\n  /**\n   * Creates a new draw context\n   * @returns the new context\n   */\n\n\n  WebGPUEngine.prototype.createDrawContext = function () {\n    return new WebGPUDrawContext(this._bufferManager);\n  };\n  /**\n   * @param pipelineContext\n   * @param vertexSourceCode\n   * @param fragmentSourceCode\n   * @param createAsRaw\n   * @param rawVertexSourceCode\n   * @param rawFragmentSourceCode\n   * @param rebuildRebind\n   * @param defines\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._preparePipelineContext = function (pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines) {\n    var webGpuContext = pipelineContext;\n    var shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\n\n    if (this.dbgShowShaderCode) {\n      console.log(defines);\n      console.log(vertexSourceCode);\n      console.log(fragmentSourceCode);\n    }\n\n    webGpuContext.sources = {\n      fragment: fragmentSourceCode,\n      vertex: vertexSourceCode,\n      rawVertex: rawVertexSourceCode,\n      rawFragment: rawFragmentSourceCode\n    };\n\n    if (createAsRaw) {\n      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\n    } else {\n      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\n    }\n  };\n  /**\n   * Gets the list of active attributes for a given WebGPU program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n\n\n  WebGPUEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    var results = new Array(attributesNames.length);\n    var gpuPipelineContext = pipelineContext;\n\n    for (var i = 0; i < attributesNames.length; i++) {\n      var attributeName = attributesNames[i];\n      var attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\n\n      if (attributeLocation === undefined) {\n        continue;\n      }\n\n      results[i] = attributeLocation;\n    }\n\n    return results;\n  };\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n\n\n  WebGPUEngine.prototype.enableEffect = function (effect) {\n    if (!effect) {\n      return;\n    }\n\n    var isNewEffect = true;\n\n    if (!DrawWrapper.IsWrapper(effect)) {\n      isNewEffect = effect !== this._currentEffect;\n      this._currentEffect = effect;\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._currentDrawContext = this._defaultDrawContext;\n      this._counters.numEnableEffects++;\n\n      if (this.dbgLogIfNotDrawWrapper) {\n        Logger.Warn(\"enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=\".concat(effect.uniqueId, \", effect.name=\").concat(effect.name, \", effect.name.vertex=\").concat(effect.name.vertex, \", effect.name.fragment=\").concat(effect.name.fragment), 10);\n      }\n    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {\n      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\n        console.error(\"drawWrapper=\", effect);\n        throw \"Invalid call to enableEffect: the effect property is empty!\";\n      }\n\n      return;\n    } else {\n      isNewEffect = effect.effect !== this._currentEffect;\n      this._currentEffect = effect.effect;\n      this._currentMaterialContext = effect.materialContext;\n      this._currentDrawContext = effect.drawContext;\n      this._counters.numEnableDrawWrapper++;\n\n      if (!this._currentMaterialContext) {\n        console.error(\"drawWrapper=\", effect);\n        throw \"Invalid call to enableEffect: the materialContext property is empty!\";\n      }\n    }\n\n    this._stencilStateComposer.stencilMaterial = undefined;\n    this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\n\n    if (isNewEffect) {\n      if (this._currentEffect.onBind) {\n        this._currentEffect.onBind(this._currentEffect);\n      }\n\n      if (this._currentEffect._onBindObservable) {\n        this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\n      }\n    }\n  };\n  /**\n   * @param effect\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._releaseEffect = function (effect) {\n    if (this._compiledEffects[effect._key]) {\n      delete this._compiledEffects[effect._key];\n\n      this._deletePipelineContext(effect.getPipelineContext());\n    }\n  };\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n\n\n  WebGPUEngine.prototype.releaseEffects = function () {\n    for (var name_1 in this._compiledEffects) {\n      var webGPUPipelineContext = this._compiledEffects[name_1].getPipelineContext();\n\n      this._deletePipelineContext(webGPUPipelineContext);\n    }\n\n    this._compiledEffects = {};\n  };\n\n  WebGPUEngine.prototype._deletePipelineContext = function (pipelineContext) {\n    var webgpuPipelineContext = pipelineContext;\n\n    if (webgpuPipelineContext) {\n      pipelineContext.dispose();\n    }\n  };\n\n  Object.defineProperty(WebGPUEngine.prototype, \"needPOTTextures\", {\n    //------------------------------------------------------------------------------\n    //                              Textures\n    //------------------------------------------------------------------------------\n\n    /**\n     * Gets a boolean indicating that only power of 2 textures are supported\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  WebGPUEngine.prototype._createHardwareTexture = function () {\n    return new WebGPUHardwareTexture();\n  };\n  /**\n   * @param texture\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._releaseTexture = function (texture) {\n    var index = this._internalTexturesCache.indexOf(texture);\n\n    if (index !== -1) {\n      this._internalTexturesCache.splice(index, 1);\n    }\n\n    this._textureHelper.releaseTexture(texture);\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._getRGBABufferInternalSizedFormat = function () {\n    return 5;\n  };\n\n  WebGPUEngine.prototype.updateTextureComparisonFunction = function (texture, comparisonFunction) {\n    texture._comparisonFunction = comparisonFunction;\n  };\n  /**\n   * Creates an internal texture without binding it to a framebuffer\n   * @hidden\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\n   * @param source source type of the texture\n   * @returns a new internal texture\n   */\n\n\n  WebGPUEngine.prototype._createInternalTexture = function (size, options, delayGPUTextureCreation, source) {\n    var _a, _b;\n\n    if (delayGPUTextureCreation === void 0) {\n      delayGPUTextureCreation = true;\n    }\n\n    if (source === void 0) {\n      source = InternalTextureSource.Unknown;\n    }\n\n    var fullOptions = {};\n\n    if (options !== undefined && _typeof(options) === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      fullOptions.format = options.format === undefined ? 5 : options.format;\n      fullOptions.samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;\n      fullOptions.creationFlags = (_b = options.creationFlags) !== null && _b !== void 0 ? _b : 0;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n      fullOptions.format = 5;\n      fullOptions.samples = 1;\n      fullOptions.creationFlags = 0;\n    }\n\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    }\n\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n      fullOptions.type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n\n    var texture = new InternalTexture(this, source);\n    var width = size.width || size;\n    var height = size.height || size;\n    var layers = size.layers || 0;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = fullOptions.samples;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    texture.is2DArray = layers > 0;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n\n    this._internalTexturesCache.push(texture);\n\n    if (!delayGPUTextureCreation) {\n      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\n    }\n\n    return texture;\n  };\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a hardware texture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n\n\n  WebGPUEngine.prototype.createTexture = function (url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {\n    var _this = this;\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, function (texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction) {\n      var _a;\n\n      var imageBitmap = img; // we will never get an HTMLImageElement in WebGPU\n\n      texture.baseWidth = imageBitmap.width;\n      texture.baseHeight = imageBitmap.height;\n      texture.width = imageBitmap.width;\n      texture.height = imageBitmap.height;\n      texture.format = format !== null && format !== void 0 ? format : -1;\n      processFunction(texture.width, texture.height, imageBitmap, extension, texture, function () {});\n\n      if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n        // the texture could have been created before reaching this point so don't recreate it if already existing\n        var gpuTextureWrapper = _this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\n\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n          _this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n\n          if (!noMipmap && !isCompressed) {\n            _this._generateMipmaps(texture, _this._uploadEncoder);\n          }\n        }\n      } else if (!noMipmap && !isCompressed) {\n        _this._generateMipmaps(texture, _this._uploadEncoder);\n      }\n\n      if (scene) {\n        scene._removePendingData(texture);\n      }\n\n      texture.isReady = true;\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n    }, function () {\n      return false;\n    }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);\n  };\n  /**\n   * Wraps an external web gpu texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @returns the babylon internal texture\n   */\n\n\n  WebGPUEngine.prototype.wrapWebGPUTexture = function (texture) {\n    var hardwareTexture = new WebGPUHardwareTexture(texture);\n    var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.isReady = true;\n    return internalTexture;\n  };\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n\n\n  WebGPUEngine.prototype.wrapWebGLTexture = function () {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\n  };\n\n  WebGPUEngine.prototype.generateMipMapsForCubemap = function (texture) {\n    var _a;\n\n    if (texture.generateMipMaps) {\n      var gpuTexture = (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource;\n\n      if (!gpuTexture) {\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\n      }\n\n      this._generateMipmaps(texture, texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined);\n    }\n  };\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   * @param generateMipMaps defines whether to generate mipmaps for the texture\n   */\n\n\n  WebGPUEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture, generateMipMaps) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (generateMipMaps) {\n      texture.generateMipMaps = true;\n\n      this._generateMipmaps(texture);\n    }\n\n    texture.samplingMode = samplingMode;\n  };\n  /**\n   * Update the sampling mode of a given texture\n   * @param texture defines the texture to update\n   * @param wrapU defines the texture wrap mode of the u coordinates\n   * @param wrapV defines the texture wrap mode of the v coordinates\n   * @param wrapR defines the texture wrap mode of the r coordinates\n   */\n\n\n  WebGPUEngine.prototype.updateTextureWrappingMode = function (texture, wrapU, wrapV, wrapR) {\n    if (wrapV === void 0) {\n      wrapV = null;\n    }\n\n    if (wrapR === void 0) {\n      wrapR = null;\n    }\n\n    if (wrapU !== null) {\n      texture._cachedWrapU = wrapU;\n    }\n\n    if (wrapV !== null) {\n      texture._cachedWrapV = wrapV;\n    }\n\n    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\n      texture._cachedWrapR = wrapR;\n    }\n  };\n  /**\n   * Update the dimensions of a texture\n   * @param texture texture to update\n   * @param width new width of the texture\n   * @param height new height of the texture\n   * @param depth new depth of the texture\n   */\n\n\n  WebGPUEngine.prototype.updateTextureDimensions = function (texture, width, height, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    if (!texture._hardwareTexture) {\n      // the gpu texture is not created yet, so when it is it will be created with the right dimensions\n      return;\n    }\n\n    if (texture.width === width && texture.height === height && texture.depth === depth) {\n      return;\n    }\n\n    var additionalUsages = texture._hardwareTexture.textureAdditionalUsages;\n\n    texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\n\n\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\n  };\n  /**\n   * @param name\n   * @param texture\n   * @param baseName\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._setInternalTexture = function (name, texture, baseName) {\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n\n    if (this._currentEffect) {\n      var webgpuPipelineContext = this._currentEffect._pipelineContext;\n      var availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\n\n      this._currentMaterialContext.setTexture(name, texture);\n\n      if (availableTexture && availableTexture.autoBindSampler) {\n        var samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\n\n        this._currentMaterialContext.setSampler(samplerName, texture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\n\n      }\n    }\n  };\n  /**\n   * Sets a texture to the according uniform.\n   * @param channel The texture channel\n   * @param unused unused parameter\n   * @param texture The texture to apply\n   * @param name The name of the uniform in the effect\n   */\n\n\n  WebGPUEngine.prototype.setTexture = function (channel, unused, texture, name) {\n    this._setTexture(channel, texture, false, false, name, name);\n  };\n  /**\n   * Sets an array of texture to the WebGPU context\n   * @param channel defines the channel where the texture array must be set\n   * @param unused unused parameter\n   * @param textures defines the array of textures to bind\n   * @param name name of the channel\n   */\n\n\n  WebGPUEngine.prototype.setTextureArray = function (channel, unused, textures, name) {\n    for (var index = 0; index < textures.length; index++) {\n      this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\n    }\n  };\n\n  WebGPUEngine.prototype._setTexture = function (channel, texture, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPartOfTextureArray, depthStencilTexture, name, baseName) {\n    if (isPartOfTextureArray === void 0) {\n      isPartOfTextureArray = false;\n    }\n\n    if (depthStencilTexture === void 0) {\n      depthStencilTexture = false;\n    }\n\n    if (name === void 0) {\n      name = \"\";\n    } // name == baseName for a texture that is not part of a texture array\n    // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\n    // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\n    // name is used to look up the texture in the _currentMaterialContext.textures map\n\n\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n\n    if (this._currentEffect) {\n      if (!texture) {\n        this._currentMaterialContext.setTexture(name, null);\n\n        return false;\n      } // Video\n\n\n      if (texture.video) {\n        texture.update();\n      } else if (texture.delayLoadState === 4) {\n        // Delay loading\n        texture.delayLoad();\n        return false;\n      }\n\n      var internalTexture = null;\n\n      if (depthStencilTexture) {\n        internalTexture = texture.depthStencilTexture;\n      } else if (texture.isReady()) {\n        internalTexture = texture.getInternalTexture();\n      } else if (texture.isCube) {\n        internalTexture = this.emptyCubeTexture;\n      } else if (texture.is3D) {\n        internalTexture = this.emptyTexture3D;\n      } else if (texture.is2DArray) {\n        internalTexture = this.emptyTexture2DArray;\n      } else {\n        internalTexture = this.emptyTexture;\n      }\n\n      if (internalTexture && !internalTexture.isMultiview) {\n        // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n          var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;\n          texture.wrapU = textureWrapMode;\n          texture.wrapV = textureWrapMode;\n        }\n\n        internalTexture._cachedWrapU = texture.wrapU;\n        internalTexture._cachedWrapV = texture.wrapV;\n\n        if (internalTexture.is3D) {\n          internalTexture._cachedWrapR = texture.wrapR;\n        }\n\n        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\n      }\n\n      this._setInternalTexture(name, internalTexture, baseName);\n    } else {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * @param target\n   * @param internalTexture\n   * @param anisotropicFilteringLevel\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._setAnisotropicLevel = function (target, internalTexture, anisotropicFilteringLevel) {\n    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\n      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\n    }\n  };\n  /**\n   * @param channel\n   * @param texture\n   * @param name\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._bindTexture = function (channel, texture, name) {\n    if (channel === undefined) {\n      return;\n    }\n\n    this._setInternalTexture(name, texture);\n  };\n  /**\n   * Generates the mipmaps for a texture\n   * @param texture texture to generate the mipmaps for\n   */\n\n\n  WebGPUEngine.prototype.generateMipmaps = function (texture) {\n    this._generateMipmaps(texture, this._renderTargetEncoder);\n  };\n  /**\n   * @param texture\n   * @param commandEncoder\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._generateMipmaps = function (texture, commandEncoder) {\n    var gpuHardwareTexture = texture._hardwareTexture;\n\n    if (!gpuHardwareTexture) {\n      return;\n    } // try as much as possible to use the command encoder corresponding to the current pass.\n    // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\n\n\n    commandEncoder = commandEncoder !== null && commandEncoder !== void 0 ? commandEncoder : this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder;\n    var format = texture._hardwareTexture.format;\n    var mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\n      }\n    }\n\n    if (texture.isCube) {\n      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\n    } else {\n      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\n    }\n  };\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n\n\n  WebGPUEngine.prototype.updateTextureData = function (texture, imageData, xOffset, yOffset, width, height, faceIndex, lod, generateMipMaps) {\n    var _a;\n\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    var gpuTextureWrapper = texture._hardwareTexture;\n\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n\n    var data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\n\n    if (generateMipMaps) {\n      this._generateMipmaps(texture, this._renderTargetEncoder);\n    }\n  };\n  /**\n   * @param texture\n   * @param internalFormat\n   * @param width\n   * @param height\n   * @param imageData\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, imageData, faceIndex, lod) {\n    var _a;\n\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gpuTextureWrapper = texture._hardwareTexture;\n\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      texture.format = internalFormat;\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n\n    var data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\n  };\n  /**\n   * @param texture\n   * @param imageData\n   * @param faceIndex\n   * @param lod\n   * @param babylonInternalFormat\n   * @param useTextureWidthAndHeight\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {\n    var _a;\n\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    if (useTextureWidthAndHeight === void 0) {\n      useTextureWidthAndHeight = false;\n    }\n\n    var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\n    var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\n    var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\n    var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\n    var gpuTextureWrapper = texture._hardwareTexture;\n\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n\n    var data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  };\n  /**\n   * @param texture\n   * @param imageData\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\n  };\n  /**\n   * @param texture\n   * @param image\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    var _a;\n\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gpuTextureWrapper = texture._hardwareTexture;\n\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n\n    var bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\n\n    var width = Math.ceil(texture.width / (1 << lod));\n    var height = Math.ceil(texture.height / (1 << lod));\n\n    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  };\n  /**\n   * Reads pixels from the current frame buffer. Please note that this function can be slow\n   * @param x defines the x coordinate of the rectangle where pixels must be read\n   * @param y defines the y coordinate of the rectangle where pixels must be read\n   * @param width defines the width of the rectangle where pixels must be read\n   * @param height defines the height of the rectangle where pixels must be read\n   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  WebGPUEngine.prototype.readPixels = function (x, y, width, height, hasAlpha, flushRenderer) {\n    if (hasAlpha === void 0) {\n      hasAlpha = true;\n    }\n\n    if (flushRenderer === void 0) {\n      flushRenderer = true;\n    }\n\n    var renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\n    var gpuTexture = renderPassWrapper.colorAttachmentGPUTextures[0].underlyingResource;\n    var gpuTextureFormat = renderPassWrapper.colorAttachmentGPUTextures[0].format;\n\n    if (!gpuTexture) {\n      // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\n      return Promise.resolve(new Uint8Array(0));\n    }\n\n    if (flushRenderer) {\n      this.flushFramebuffer();\n    }\n\n    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\n  }; //------------------------------------------------------------------------------\n  //                              Frame management\n  //------------------------------------------------------------------------------\n\n  /**\n   * Begin a new frame\n   */\n\n\n  WebGPUEngine.prototype.beginFrame = function () {\n    _super.prototype.beginFrame.call(this);\n  };\n  /**\n   * End the current frame\n   */\n\n\n  WebGPUEngine.prototype.endFrame = function () {\n    this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\n\n    this._endMainRenderPass();\n\n    this._timestampQuery.endFrame(this._renderEncoder);\n\n    this.flushFramebuffer(false);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - counters\");\n      }\n    }\n\n    this._textureHelper.destroyDeferredTextures();\n\n    this._bufferManager.destroyDeferredBuffers();\n\n    if (this._features._collectUbosUpdatedInFrame) {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          var list = [];\n\n          for (var name_2 in UniformBuffer._UpdatedUbosInFrame) {\n            list.push(name_2 + \":\" + UniformBuffer._UpdatedUbosInFrame[name_2]);\n          }\n\n          console.log(\"frame #\" + this._count + \" - updated ubos -\", list.join(\", \"));\n        }\n      }\n\n      UniformBuffer._UpdatedUbosInFrame = {};\n    }\n\n    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\n    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\n    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\n    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\n    this._counters.numEnableEffects = 0;\n    this._counters.numEnableDrawWrapper = 0;\n    this._counters.numBundleCreationNonCompatMode = 0;\n    this._counters.numBundleReuseNonCompatMode = 0;\n\n    this._cacheRenderPipeline.endFrame();\n\n    this._cacheBindGroups.endFrame();\n\n    this._pendingDebugCommands.length = 0;\n\n    _super.prototype.endFrame.call(this);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"%c frame #\" + this._count + \" - end\", \"background: #ffff00\");\n      }\n\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        this._count++;\n\n        if (this._count !== this.dbgVerboseLogsNumFrames) {\n          console.log(\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n    }\n  };\n  /**\n   * Force a WebGPU flush (ie. a flush of all waiting commands)\n   * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\n   */\n\n\n  WebGPUEngine.prototype.flushFramebuffer = function (reopenPass) {\n    if (reopenPass === void 0) {\n      reopenPass = true;\n    } // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\n\n\n    var currentRenderPassIsNULL = !this._currentRenderPass;\n    var currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\n\n    if (this._currentRenderPass && this._currentRenderTarget) {\n      currentPasses |= 1;\n\n      this._endRenderTargetRenderPass();\n    }\n\n    if (this._mainRenderPassWrapper.renderPass) {\n      currentPasses |= 2;\n\n      this._endMainRenderPass();\n    }\n\n    this._commandBuffers[0] = this._uploadEncoder.finish();\n    this._commandBuffers[1] = this._renderTargetEncoder.finish();\n    this._commandBuffers[2] = this._renderEncoder.finish();\n\n    this._device.queue.submit(this._commandBuffers);\n\n    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n    this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\n\n    this._timestampQuery.startFrame(this._uploadEncoder);\n\n    this._textureHelper.setCommandEncoder(this._uploadEncoder);\n\n    this._bundleList.reset();\n\n    this._bundleListRenderTarget.reset(); // restart the render pass\n\n\n    if (reopenPass) {\n      if (currentPasses & 2) {\n        this._startMainRenderPass(false);\n      }\n\n      if (currentPasses & 1) {\n        this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n      }\n\n      if (currentRenderPassIsNULL && this._currentRenderTarget) {\n        this._currentRenderPass = null;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  WebGPUEngine.prototype._currentFrameBufferIsDefaultFrameBuffer = function () {\n    return this._currentRenderTarget === null;\n  }; //------------------------------------------------------------------------------\n  //                              Render Pass\n  //------------------------------------------------------------------------------\n\n\n  WebGPUEngine.prototype._startRenderTargetRenderPass = function (renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n\n    var rtWrapper = renderTargetWrapper;\n    var depthStencilTexture = rtWrapper._depthStencilTexture;\n    var gpuDepthStencilWrapper = depthStencilTexture === null || depthStencilTexture === void 0 ? void 0 : depthStencilTexture._hardwareTexture;\n    var gpuDepthStencilTexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.underlyingResource;\n    var gpuDepthStencilMSAATexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.msaaTexture;\n    var depthTextureView = gpuDepthStencilTexture === null || gpuDepthStencilTexture === void 0 ? void 0 : gpuDepthStencilTexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    var depthMSAATextureView = gpuDepthStencilMSAATexture === null || gpuDepthStencilMSAATexture === void 0 ? void 0 : gpuDepthStencilMSAATexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    var colorAttachments = [];\n\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n\n    var mustClearColor = setClearStates && clearColor;\n    var mustClearDepth = setClearStates && clearDepth;\n    var mustClearStencil = setClearStates && clearStencil;\n\n    if (rtWrapper._attachments && rtWrapper.isMulti) {\n      // multi render targets\n      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\n        this._mrtAttachments = rtWrapper._defaultAttachments;\n      }\n\n      for (var i = 0; i < this._mrtAttachments.length; ++i) {\n        var index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\n\n        var mrtTexture = rtWrapper.textures[i];\n        var gpuMRTWrapper = mrtTexture === null || mrtTexture === void 0 ? void 0 : mrtTexture._hardwareTexture;\n        var gpuMRTTexture = gpuMRTWrapper === null || gpuMRTWrapper === void 0 ? void 0 : gpuMRTWrapper.underlyingResource;\n\n        if (gpuMRTWrapper && gpuMRTTexture) {\n          var viewDescriptor = __assign(__assign({}, this._rttRenderPassWrapper.colorAttachmentViewDescriptor), {\n            format: gpuMRTWrapper.format\n          });\n\n          var gpuMSAATexture = gpuMRTWrapper.msaaTexture;\n          var colorTextureView = gpuMRTTexture.createView(viewDescriptor);\n          var colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(viewDescriptor);\n          colorAttachments.push({\n            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n            resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n            clearValue: index !== 0 && mustClearColor ? clearColor : undefined,\n            loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n            storeOp: WebGPUConstants.StoreOp.Store\n          });\n        }\n      }\n\n      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);\n\n      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    } else {\n      // single render target\n      var internalTexture = rtWrapper.texture;\n      var gpuWrapper = internalTexture._hardwareTexture;\n      var gpuTexture = gpuWrapper.underlyingResource;\n      var gpuMSAATexture = gpuWrapper.msaaTexture;\n      var colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n      var colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n      colorAttachments.push({\n        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n        resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n        clearValue: mustClearColor ? clearColor : undefined,\n        loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        storeOp: WebGPUConstants.StoreOp.Store\n      });\n    }\n\n    (_a = this._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(this, \"render target pass\", 1);\n    this._rttRenderPassWrapper.renderPassDescriptor = {\n      colorAttachments: colorAttachments,\n      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {\n        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,\n        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined,\n        depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\n        stencilLoadOp: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        stencilStoreOp: WebGPUConstants.StoreOp.Store\n      } : undefined,\n      occlusionQuerySet: ((_b = this._occlusionQuery) === null || _b === void 0 ? void 0 : _b.hasQueries) ? this._occlusionQuery.querySet : undefined\n    };\n    this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        var internalTexture = rtWrapper.texture;\n        console.log(\"frame #\" + this._count + \" - render target begin pass - internalTexture.uniqueId=\", internalTexture.uniqueId, \"width=\", internalTexture.width, \"height=\", internalTexture.height, this._rttRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n\n    this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\n    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);\n\n    this._resetCurrentViewport(1);\n\n    this._resetCurrentScissor(1);\n\n    this._resetCurrentStencilRef(1);\n\n    this._resetCurrentColorBlend(1);\n\n    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\n      this._stencilStateComposer.enabled = false;\n    }\n  };\n  /** @hidden */\n\n\n  WebGPUEngine.prototype._endRenderTargetRenderPass = function () {\n    var _a, _b, _c;\n\n    if (this._currentRenderPass) {\n      var gpuWrapper = this._currentRenderTarget.texture._hardwareTexture;\n\n      if (!this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\n        this._bundleListRenderTarget.run(this._currentRenderPass);\n\n        this._bundleListRenderTarget.reset();\n      }\n\n      this._currentRenderPass.end();\n\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - render target end pass - internalTexture.uniqueId=\", (_b = (_a = this._currentRenderTarget) === null || _a === void 0 ? void 0 : _a.texture) === null || _b === void 0 ? void 0 : _b.uniqueId);\n        }\n      }\n\n      (_c = this._debugPopGroup) === null || _c === void 0 ? void 0 : _c.call(this, 1);\n\n      this._resetCurrentViewport(1);\n\n      this._resetCurrentScissor(1);\n\n      this._resetCurrentStencilRef(1);\n\n      this._resetCurrentColorBlend(1);\n\n      this._currentRenderPass = null;\n\n      this._rttRenderPassWrapper.reset();\n    }\n  };\n\n  WebGPUEngine.prototype._getCurrentRenderPass = function () {\n    if (this._currentRenderTarget && !this._currentRenderPass) {\n      // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\n      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n    } else if (!this._currentRenderPass) {\n      this._startMainRenderPass(false);\n    }\n\n    return this._currentRenderPass;\n  };\n  /** @hidden */\n\n\n  WebGPUEngine.prototype._getCurrentRenderPassIndex = function () {\n    return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n  };\n\n  WebGPUEngine.prototype._startMainRenderPass = function (setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n\n    if (this._mainRenderPassWrapper.renderPass) {\n      this._endMainRenderPass();\n    }\n\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n\n    var mustClearColor = setClearStates && clearColor;\n    var mustClearDepth = setClearStates && clearDepth;\n    var mustClearStencil = setClearStates && clearStencil;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = ((_a = this._occlusionQuery) === null || _a === void 0 ? void 0 : _a.hasQueries) ? this._occlusionQuery.querySet : undefined;\n    this._swapChainTexture = this._context.getCurrentTexture();\n\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(this._swapChainTexture); // Resolve in case of MSAA\n\n\n    if (this._options.antialiasing) {\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = this._swapChainTexture.createView();\n    } else {\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = this._swapChainTexture.createView();\n    }\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - main begin pass - texture width=\" + this._mainTextureExtends.width, \" height=\" + this._mainTextureExtends.height, this._mainRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n\n    (_b = this._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(this, \"main pass\", 0);\n    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);\n    this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\n    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);\n\n    this._resetCurrentViewport(0);\n\n    this._resetCurrentScissor(0);\n\n    this._resetCurrentStencilRef(0);\n\n    this._resetCurrentColorBlend(0);\n\n    if (!this._isStencilEnable) {\n      this._stencilStateComposer.enabled = false;\n    }\n  };\n\n  WebGPUEngine.prototype._endMainRenderPass = function () {\n    var _a;\n\n    if (this._mainRenderPassWrapper.renderPass !== null) {\n      this._snapshotRendering.endMainRenderPass();\n\n      if (!this.compatibilityMode && !this._snapshotRendering.play) {\n        this._bundleList.run(this._mainRenderPassWrapper.renderPass);\n\n        this._bundleList.reset();\n      }\n\n      this._mainRenderPassWrapper.renderPass.end();\n\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - main end pass\");\n        }\n      }\n\n      (_a = this._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(this, 0);\n\n      this._resetCurrentViewport(0);\n\n      this._resetCurrentScissor(0);\n\n      this._resetCurrentStencilRef(0);\n\n      this._resetCurrentColorBlend(0);\n\n      if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\n        this._currentRenderPass = null;\n      }\n\n      this._mainRenderPassWrapper.reset(false);\n    }\n  };\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param texture The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   * @param layer defines the 2d array index to bind to frame buffer to\n   */\n\n\n  WebGPUEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {\n    var _a, _b;\n\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lodLevel === void 0) {\n      lodLevel = 0;\n    }\n\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    var hardwareTexture = (_a = texture.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;\n\n    if (!hardwareTexture) {\n      if (this.dbgSanityChecks) {\n        console.error(\"bindFramebuffer: Trying to bind a texture that does not have a hardware texture!\", texture, hardwareTexture);\n      }\n\n      return;\n    }\n\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n\n    this._currentRenderTarget = texture;\n    hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\n    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\n    this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format) : undefined;\n\n    this._setDepthTextureFormat(this._rttRenderPassWrapper);\n\n    this._setColorFormat(this._rttRenderPassWrapper);\n\n    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\n      format: this._colorFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\n      format: this._depthTextureFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: 0,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - bindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId, \"face=\", faceIndex, \"lodLevel=\", lodLevel, \"layer=\", layer, this._rttRenderPassWrapper.colorAttachmentViewDescriptor, this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n      }\n    }\n\n    this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\n\n    if (this.snapshotRendering && this.snapshotRenderingMode === 1) {\n      // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\n      this._getCurrentRenderPass();\n    }\n\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    } else {\n      if (!requiredWidth) {\n        requiredWidth = texture.width;\n\n        if (lodLevel) {\n          requiredWidth = requiredWidth / Math.pow(2, lodLevel);\n        }\n      }\n\n      if (!requiredHeight) {\n        requiredHeight = texture.height;\n\n        if (lodLevel) {\n          requiredHeight = requiredHeight / Math.pow(2, lodLevel);\n        }\n      }\n\n      this._viewport(0, 0, requiredWidth, requiredHeight);\n    }\n\n    this.wipeCaches();\n  };\n  /**\n   * Unbind the current render target texture from the WebGPU context\n   * @param texture defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n\n\n  WebGPUEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n    var _a, _b;\n\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    var saveCRT = this._currentRenderTarget;\n    this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\n\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n\n    this._currentRenderTarget = saveCRT;\n\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n      this._endRenderTargetRenderPass();\n    }\n\n    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture.texture);\n    }\n\n    this._currentRenderTarget = null;\n\n    this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\n\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId);\n      }\n    }\n\n    this._mrtAttachments = [];\n\n    this._cacheRenderPipeline.setMRT([]);\n\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n\n    this._setColorFormat(this._mainRenderPassWrapper);\n  };\n  /**\n   * Unbind the current render target and bind the default framebuffer\n   */\n\n\n  WebGPUEngine.prototype.restoreDefaultFramebuffer = function () {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else {\n      this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n\n      this._setDepthTextureFormat(this._mainRenderPassWrapper);\n\n      this._setColorFormat(this._mainRenderPassWrapper);\n    }\n\n    if (this._currentRenderPass) {\n      if (this._cachedViewport) {\n        this.setViewport(this._cachedViewport);\n      }\n    }\n\n    this.wipeCaches();\n  }; //------------------------------------------------------------------------------\n  //                              Render\n  //------------------------------------------------------------------------------\n\n  /**\n   * @param wrapper\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._setColorFormat = function (wrapper) {\n    var format = wrapper.colorAttachmentGPUTextures[0].format;\n\n    this._cacheRenderPipeline.setColorFormat(format);\n\n    if (this._colorFormat === format) {\n      return;\n    }\n\n    this._colorFormat = format;\n  };\n  /**\n   * @param wrapper\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._setDepthTextureFormat = function (wrapper) {\n    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\n\n    if (this._depthTextureFormat === wrapper.depthTextureFormat) {\n      return;\n    }\n\n    this._depthTextureFormat = wrapper.depthTextureFormat;\n  };\n\n  WebGPUEngine.prototype.setDitheringState = function () {// Does not exist in WebGPU\n  };\n\n  WebGPUEngine.prototype.setRasterizerState = function () {// Does not exist in WebGPU\n  };\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n\n\n  WebGPUEngine.prototype.setState = function (culling, zOffset, force, reverseSide, cullBackFaces, stencil, zOffsetUnits) {\n    var _a, _b;\n\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    }\n\n    if (zOffsetUnits === void 0) {\n      zOffsetUnits = 0;\n    } // Culling\n\n\n    if (this._depthCullingState.cull !== culling || force) {\n      this._depthCullingState.cull = culling;\n    } // Cull face\n\n\n    var cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 2;\n\n    if (this._depthCullingState.cullFace !== cullFace || force) {\n      this._depthCullingState.cullFace = cullFace;\n    } // Z offset\n\n\n    this.setZOffset(zOffset);\n    this.setZOffsetUnits(zOffsetUnits); // Front face\n\n    var frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;\n\n    if (this._depthCullingState.frontFace !== frontFace || force) {\n      this._depthCullingState.frontFace = frontFace;\n    }\n\n    this._stencilStateComposer.stencilMaterial = stencil;\n  };\n\n  WebGPUEngine.prototype._applyRenderPassChanges = function (renderPass, bundleList) {\n    var _a;\n\n    var mustUpdateViewport = this._mustUpdateViewport(renderPass);\n\n    var mustUpdateScissor = this._mustUpdateScissor(renderPass);\n\n    var mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\n    var mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\n\n    if (bundleList) {\n      if (mustUpdateViewport) {\n        bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\n      }\n\n      if (mustUpdateScissor) {\n        bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n      }\n\n      if (mustUpdateStencilRef) {\n        bundleList.addItem(new WebGPURenderItemStencilRef((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0));\n      }\n\n      if (mustUpdateBlendColor) {\n        bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\n      }\n    } else {\n      if (mustUpdateViewport) {\n        this._applyViewport(renderPass);\n      }\n\n      if (mustUpdateScissor) {\n        this._applyScissor(renderPass);\n      }\n\n      if (mustUpdateStencilRef) {\n        this._applyStencilRef(renderPass);\n      }\n\n      if (mustUpdateBlendColor) {\n        this._applyBlendColor(renderPass);\n      }\n    }\n  };\n\n  WebGPUEngine.prototype._draw = function (drawType, fillMode, start, count, instancesCount) {\n    var _a;\n\n    var renderPass = this._getCurrentRenderPass();\n\n    var renderPassIndex = this._getCurrentRenderPassIndex();\n\n    var bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n    this.applyStates();\n    var webgpuPipelineContext = this._currentEffect._pipelineContext;\n    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\n\n    if (webgpuPipelineContext.uniformBuffer) {\n      webgpuPipelineContext.uniformBuffer.update();\n      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);\n    }\n\n    if (this._snapshotRendering.play) {\n      this._reportDrawCall();\n\n      return;\n    }\n\n    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {\n      this._currentDrawContext.fastBundle = undefined;\n    }\n\n    var useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\n    var renderPass2 = renderPass;\n\n    if (useFastPath || this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, bundleList);\n\n      if (!this._snapshotRendering.record) {\n        this._counters.numBundleReuseNonCompatMode++;\n\n        if (this._currentDrawContext.indirectDrawBuffer) {\n          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n        }\n\n        bundleList.addBundle(this._currentDrawContext.fastBundle);\n\n        this._reportDrawCall();\n\n        return;\n      }\n\n      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\n\n      bundleList.numDrawCalls++;\n    }\n\n    var textureState = 0;\n\n    if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\n      var bitVal = 1;\n\n      for (var i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\n        var textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\n        var texture = (_a = this._currentMaterialContext.textures[textureName]) === null || _a === void 0 ? void 0 : _a.texture;\n\n        if ((texture === null || texture === void 0 ? void 0 : texture.type) === 1) {\n          textureState |= bitVal;\n        }\n\n        bitVal = bitVal << 1;\n      }\n    }\n\n    var pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);\n\n    var bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\n\n    if (!this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\n\n      if (!this.compatibilityMode) {\n        this._counters.numBundleCreationNonCompatMode++;\n        renderPass2 = this._device.createRenderBundleEncoder({\n          colorFormats: this._cacheRenderPipeline.colorFormats,\n          depthStencilFormat: this._depthTextureFormat,\n          sampleCount: this.currentSampleCount\n        });\n      }\n    } // bind pipeline\n\n\n    renderPass2.setPipeline(pipeline); // bind index/vertex buffers\n\n    if (this._currentIndexBuffer) {\n      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16, 0);\n    }\n\n    var vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\n\n    for (var index = 0; index < vertexBuffers.length; index++) {\n      var vertexBuffer = vertexBuffers[index];\n      var buffer = vertexBuffer.getBuffer();\n\n      if (buffer) {\n        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\n      }\n    } // bind bind groups\n\n\n    for (var i = 0; i < bindGroups.length; i++) {\n      renderPass2.setBindGroup(i, bindGroups[i]);\n    } // draw\n\n\n    var nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\n\n    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\n      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n\n      if (drawType === 0) {\n        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      } else {\n        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      }\n    } else if (drawType === 0) {\n      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\n    } else {\n      renderPass2.draw(count, instancesCount || 1, start, 0);\n    }\n\n    if (nonCompatMode) {\n      this._currentDrawContext.fastBundle = renderPass2.finish();\n      bundleList.addBundle(this._currentDrawContext.fastBundle);\n    }\n\n    this._reportDrawCall();\n  };\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n\n\n  WebGPUEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {\n    if (instancesCount === void 0) {\n      instancesCount = 1;\n    }\n\n    this._draw(0, fillMode, indexStart, indexCount, instancesCount);\n  };\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n\n\n  WebGPUEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {\n    if (instancesCount === void 0) {\n      instancesCount = 1;\n    }\n\n    this._currentIndexBuffer = null;\n\n    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\n  }; //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n\n  /**\n   * Dispose and release all associated resources\n   */\n\n\n  WebGPUEngine.prototype.dispose = function () {\n    var _a, _b, _c;\n\n    (_a = this._mainTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this._mainTextureLastCopy) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this._depthTexture) === null || _c === void 0 ? void 0 : _c.destroy();\n\n    _super.prototype.dispose.call(this);\n  }; //------------------------------------------------------------------------------\n  //                              Misc\n  //------------------------------------------------------------------------------\n\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n\n\n  WebGPUEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._canvas.width;\n  };\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n\n\n  WebGPUEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._canvas.height;\n  };\n  /**\n   * Gets the HTML canvas attached with the current WebGPU context\n   * @returns a HTML canvas\n   */\n\n\n  WebGPUEngine.prototype.getRenderingCanvas = function () {\n    return this._canvas;\n  }; //------------------------------------------------------------------------------\n  //                              Errors\n  //------------------------------------------------------------------------------\n\n  /**\n   * Get the current error code of the WebGPU context\n   * @returns the error code\n   */\n\n\n  WebGPUEngine.prototype.getError = function () {\n    // TODO WEBGPU. from the webgpu errors.\n    return 0;\n  }; //------------------------------------------------------------------------------\n  //                              Unused WebGPU\n  //------------------------------------------------------------------------------\n\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.bindSamplers = function () {};\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._bindTextureDirectly = function () {\n    return false;\n  };\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns always true - No parallel shader compilation\n   */\n\n\n  WebGPUEngine.prototype.areAllEffectsReady = function () {\n    return true;\n  };\n  /**\n   * @param pipelineContext\n   * @param action\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._executeWhenRenderingStateIsCompiled = function (pipelineContext, action) {\n    // No parallel shader compilation.\n    // No Async, so direct launch\n    action();\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._isRenderingStateCompiled = function () {\n    // No parallel shader compilation.\n    return true;\n  };\n  /** @hidden */\n\n\n  WebGPUEngine.prototype._getUnpackAlignement = function () {\n    return 1;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._unpackFlipY = function () {};\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._bindUnboundFramebuffer = function () {\n    throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\n  }; // TODO WEBGPU. All of the below should go once engine split with baseEngine.\n\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype._getSamplingParameters = function () {\n    throw \"_getSamplingParameters is not available in WebGPU\";\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.getUniforms = function () {\n    return [];\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setIntArray = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setIntArray2 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setIntArray3 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setIntArray4 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setArray = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setArray2 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setArray3 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setArray4 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setMatrices = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setMatrix3x3 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setMatrix2x2 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setFloat = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setFloat2 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setFloat3 = function () {\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  WebGPUEngine.prototype.setFloat4 = function () {\n    return false;\n  }; // Default glslang options.\n\n\n  WebGPUEngine._GLSLslangDefaultOptions = {\n    jsPath: \"https://preview.babylonjs.com/glslang/glslang.js\",\n    wasmPath: \"https://preview.babylonjs.com/glslang/glslang.wasm\"\n  };\n  /** true to enable using TintWASM to convert Spir-V to WGSL */\n\n  WebGPUEngine.UseTWGSL = true;\n  return WebGPUEngine;\n}(Engine);\n\nexport { WebGPUEngine };","map":{"version":3,"mappings":"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","names":["Logger","IsWindowObjectExist","Color4","Engine","InternalTexture","InternalTextureSource","Effect","WebGPUConstants","VertexBuffer","WebGPUPipelineContext","WebGPUShaderProcessorGLSL","WebGPUShaderProcessorWGSL","WebGPUShaderProcessingContext","Tools","WebGPUTextureHelper","WebGPUBufferManager","WebGPUHardwareTexture","UniformBuffer","WebGPURenderPassWrapper","WebGPUCacheSampler","WebGPUCacheRenderPipelineTree","WebGPUStencilStateComposer","WebGPUDepthCullingState","DrawWrapper","WebGPUMaterialContext","WebGPUDrawContext","WebGPUCacheBindGroups","WebGPUClearQuad","WebGPURenderItemBlendColor","WebGPURenderItemScissor","WebGPURenderItemStencilRef","WebGPURenderItemViewport","WebGPUBundleList","WebGPUTimestampQuery","WebGPUOcclusionQuery","Observable","ShaderCodeInliner","WebGPUTintWASM","WebGPUShaderProcessor","ShaderLanguage","WebGPUSnapshotRendering","PerformanceConfigurator","__extends","canvas","options","_super","_this","label","numEnableEffects","numEnableDrawWrapper","numBundleCreationNonCompatMode","numBundleReuseNonCompatMode","x","y","w","h","z","_name","isNDCHalfZRange","hasOriginBottomLeft","deviceDescriptor","swapChainFormat","TextureFormat","BGRA8Unorm","antialiasing","undefined","stencil","_a","enableGPUDebugMarkers","_b","SetMatrixPrecision","useHighPrecisionMatrix","Log","Version","concat","description","navigator","gpu","Error","_isWebGPU","_shaderPlatformName","deterministicLockstep","lockstepMaxSteps","audioEngine","_deterministicLockstep","_lockstepMaxSteps","_timeStep","timeStep","_doNotHandleContextLost","doNotHandleContextLost","_canvas","_options","premultipliedAlpha","_c","devicePixelRatio","window","limitDeviceRatio","adaptToDeviceRatio","_d","_hardwareScalingLevel","Math","min","_mainPassSampleCount","_defaultSampleCount","_isStencilEnable","_sharedInit","doNotHandleTouchAction","_shaderProcessor","_shaderProcessorWGSL","Object","WebGPUEngine","_snapshotRendering","mode","reset","enabled","activate","_cacheSampler","disabled","disable","_cacheRenderPipeline","_cacheBindGroups","Promise","resolve","requestAdapter","then","adapter","Warn","_adapterSupportedExtensions","_deviceEnabledExtensions","name","version","vendor","renderer","_compatibilityMode","_currentRenderTarget","samples","engine","initAsync","glslangOptions","twgslOptions","_initGlslang","glslang","_glslang","_tintWASM","UseTWGSL","initTwgsl","msg","_adapter","features","forEach","feature","push","requiredFeatures","requestedExtensions","validExtensions","_i","extension","indexOf","requestDevice","device","_device","numUncapturedErrors","addEventListener","event","numMaxUncapturedErrors","error","message","lost","info","_contextWasLost","onContextLostObservable","notifyObservers","_restoreEngineAfterContextLost","bind","e","_bufferManager","_textureHelper","_timestampQuery","_occlusionQuery","createQuerySet","_bundleList","_bundleListRenderTarget","_snapshotRenderingMode","_ubInvertY","createBuffer","Float32Array","BufferUsage","Uniform","CopyDst","_ubDontInvertY","dbgVerboseLogsForFirstFrames","_count","console","log","_uploadEncoder","createCommandEncoder","_uploadEncoderDescriptor","_renderEncoder","_renderEncoderDescriptor","_renderTargetEncoder","_renderTargetEncoderDescriptor","_emptyVertexBuffer","_initializeLimits","_caps","textureFloatLinearFiltering","_depthCullingState","_stencilStateComposer","stencilGlobal","_stencilState","depthTest","depthFunc","depthMask","setCommandEncoder","_clearQuad","_defaultDrawContext","createDrawContext","_currentDrawContext","_defaultMaterialContext","createMaterialContext","_currentMaterialContext","_initializeContextAndSwapChain","_initializeMainAttachments","resize","trace","_GLSLslangDefaultOptions","self","wasmPath","jsPath","LoadScriptAsync","importScripts","reject","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","FeatureName","TextureCompressionASTC","s3tc","TextureCompressionBC","pvrtc","etc1","etc2","TextureCompressionETC2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","timerQuery","BigUint64Array","enabledExtensions","TimestampQuery","supportOcclusionQuery","canUseTimestampForTimerQuery","multiview","oculusMultiview","parallelShaderCompile","blendMinMax","maxMSAASamples","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","_collectUbosUpdatedInFrame","_context","getContext","_configureContext","width","height","_colorFormat","_mainRenderPassWrapper","colorAttachmentGPUTextures","format","_mainTextureExtends","getRenderWidth","getRenderHeight","depthOrArrayLayers","bufferDataUpdate","setSubData","mainColorAttachments","mainTextureDescriptor","size","mipLevelCount","sampleCount","dimension","TextureDimension","E2d","usage","TextureUsage","RenderAttachment","_mainTexture","destroy","createTexture","view","createView","clearValue","loadOp","LoadOp","Clear","storeOp","StoreOp","Store","depthTextureFormat","isStencilEnable","Depth24PlusStencil8","Depth32Float","_setDepthTextureFormat","depthTextureDescriptor","_depthTexture","mainDepthAttachment","depthClearValue","_clearDepthValue","depthLoadOp","depthStoreOp","stencilClearValue","_clearStencilValue","stencilLoadOp","stencilStoreOp","renderPassDescriptor","colorAttachments","depthStencilAttachment","renderPass","_endMainRenderPass","configure","CopySrc","compositingAlphaMode","CanvasCompositingAlphaMode","Premultiplied","Opaque","forceSetSize","setSize","call","dbgVerboseLogsNumFrames","snapshotRendering","snapshotRenderingReset","shaderLanguage","WGSL","apply","setAlphaBlendEnabled","_alphaState","alphaBlend","bruteForce","preventCacheWipeBetweenFrames","_forceEnableEffect","_currentIndexBuffer","_currentOverrideVertexBuffers","setBuffers","_alphaMode","_alphaEquation","setAlphaBlendFactors","_blendFunctionParameters","_blendEquationParameters","setColorWrite","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","enable","_colorWriteLocal","setWriteMask","index","_viewportsCurrent","_viewportCached","update","floor","setViewport","_scissorsCurrent","_scissorCached","setScissorRect","_resetCurrentScissor","_stencilRefsCurrent","funcRef","setStencilReference","_blendColorsCurrent","colorBlend","_blendConstants","setBlendConstant","color","backBuffer","depth","a","hasScissor","_scissorIsActive","_rttRenderPassWrapper","_startRenderTargetRenderPass","compatibilityMode","addItem","_applyScissor","_currentRenderPass","_clearFullQuad","_endRenderTargetRenderPass","_startMainRenderPass","clearColor","clearDepth","clearStencil","_getCurrentRenderPass","renderPassIndex","_getCurrentRenderPassIndex","bundleList","setColorFormat","setDepthStencilFormat","_depthTextureFormat","setMRTAttachments","mrtAttachments","mrtTextureArray","mrtTextureCount","bundle","clear","currentSampleCount","addBundle","_reportDrawCall","_applyStencilRef","data","Array","ArrayBuffer","Uint8Array","dataBuffer","Vertex","createVertexBuffer","indices","is32Bits","Uint32Array","Int32Array","Uint16Array","length","Index","creationFlags","flags","Storage","vertexBuffers","indexBuffer","effect","overrideVertexBuffers","buffer","releaseBuffer","baseName","attributesNamesOrOptions","uniformsNamesOrEngine","samplers","defines","fallbacks","onCompiled","onError","indexParameters","GLSL","vertex","vertexElement","vertexToken","vertexSource","fragment","fragmentElement","fragmentToken","fragmentSource","globalDefines","_getGlobalDefines","fullDefines","_compiledEffects","compiledEffect","isReady","source","type","compileGLSL","shaderVersion","_compileRawShaderToSpirV","split","join","vertexShader","fragmentShader","convertSpirV2WGSL","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","vertexCode","fragmentCode","_createPipelineStageDescriptor","onBeforeShaderCompilationObservable","_compileShaderToSpirV","_getWGSLShader","program","onAfterShaderCompilationObservable","sci","debug","processCode","shaderProcessingContext","pipelineContext","vertexSourceCode","fragmentSourceCode","createAsRaw","rawVertexSourceCode","rawFragmentSourceCode","rebuildRebind","webGpuContext","dbgShowShaderCode","sources","rawVertex","rawFragment","stages","_compileRawPipelineStageDescriptor","_compilePipelineStageDescriptor","attributesNames","results","gpuPipelineContext","i","attributeName","attributeLocation","availableAttributes","isNewEffect","IsWrapper","_currentEffect","_counters","dbgLogIfNotDrawWrapper","uniqueId","materialContext","drawContext","dbgShowEmptyEnableEffectCalls","stencilMaterial","onBind","_onBindObservable","_key","_deletePipelineContext","getPipelineContext","name_1","webGPUPipelineContext","webgpuPipelineContext","dispose","texture","_internalTexturesCache","splice","releaseTexture","comparisonFunction","_comparisonFunction","delayGPUTextureCreation","Unknown","fullOptions","generateMipMaps","samplingMode","layers","baseWidth","baseHeight","is2DArray","_cachedWrapU","_cachedWrapV","createGPUTextureForInternalTexture","url","noMipmap","invertY","scene","onLoad","fallback","forcedExtension","mimeType","loaderOptions","useSRGBBuffer","_createTextureBase","img","isCompressed","processFunction","imageBitmap","_hardwareTexture","underlyingResource","gpuTextureWrapper","IsImageBitmap","updateTexture","_generateMipmaps","_removePendingData","onLoadedObservable","hardwareTexture","internalTexture","gpuTexture","RenderTarget","MultiRenderTarget","wrapU","wrapV","wrapR","is3D","_cachedWrapR","additionalUsages","textureAdditionalUsages","release","_pipelineContext","availableTexture","availableTextures","setTexture","autoBindSampler","samplerName","AutoSamplerSuffix","setSampler","channel","unused","_setTexture","textures","toString","isPartOfTextureArray","depthStencilTexture","video","delayLoadState","delayLoad","getInternalTexture","isCube","emptyCubeTexture","emptyTexture3D","emptyTexture2DArray","emptyTexture","isMultiview","_cachedCoordinatesMode","coordinatesMode","textureWrapMode","_setAnisotropicLevel","anisotropicFilteringLevel","_setInternalTexture","target","_cachedAnisotropicFilteringLevel","commandEncoder","gpuHardwareTexture","mipmapCount","ComputeNumMipmapLevels","generateCubeMipmaps","generateMipmaps","imageData","xOffset","yOffset","faceIndex","lod","byteOffset","byteLength","internalFormat","babylonInternalFormat","useTextureWidthAndHeight","lodMaxWidth","round","LOG2E","lodMaxHeight","pow","max","_uploadDataToTextureDirectly","image","bitmap","ceil","hasAlpha","flushRenderer","renderPassWrapper","gpuTextureFormat","flushFramebuffer","readPixels","beginFrame","endFrame","destroyDeferredTextures","destroyDeferredBuffers","list","name_2","_UpdatedUbosInFrame","countersLastFrame","_pendingDebugCommands","reopenPass","currentRenderPassIsNULL","currentPasses","_commandBuffers","finish","queue","submit","startFrame","renderTargetWrapper","setClearStates","rtWrapper","_depthStencilTexture","gpuDepthStencilWrapper","gpuDepthStencilTexture","gpuDepthStencilMSAATexture","msaaTexture","depthTextureView","depthAttachmentViewDescriptor","depthMSAATextureView","useReverseDepthBuffer","setDepthFunctionToGreaterOrEqual","mustClearColor","mustClearDepth","mustClearStencil","_attachments","isMulti","_mrtAttachments","_defaultAttachments","mrtTexture","gpuMRTWrapper","gpuMRTTexture","viewDescriptor","colorAttachmentViewDescriptor","gpuMSAATexture","colorTextureView","colorMSAATextureView","resolveTarget","Load","setMRT","gpuWrapper","_debugPushGroup","_clearReverseDepthValue","_depthStencilTextureWithStencil","occlusionQuerySet","hasQueries","querySet","beginRenderPass","_debugFlushPendingCommands","_resetCurrentViewport","_resetCurrentStencilRef","_resetCurrentColorBlend","HasStencilAspect","endRenderTargetPass","run","end","_debugPopGroup","_swapChainTexture","getCurrentTexture","set","endMainRenderPass","play","requiredWidth","requiredHeight","forceFullscreenViewport","lodLevel","layer","dbgSanityChecks","unBindFramebuffer","_currentLayer","GetWebGPUTextureFormat","_setColorFormat","TextureViewDimension","baseArrayLayer","baseMipLevel","arrayLayerCount","aspect","TextureAspect","All","snapshotRenderingMode","_cachedViewport","_viewport","wipeCaches","disableGenerateMipMaps","onBeforeUnbind","saveCRT","_onAfterUnbindFrameBufferObservable","wrapper","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","cull","cullFace","setZOffset","setZOffsetUnits","frontFace","mustUpdateViewport","_mustUpdateViewport","mustUpdateScissor","_mustUpdateScissor","mustUpdateStencilRef","_mustUpdateStencilRef","mustUpdateBlendColor","_mustUpdateBlendColor","slice","_applyViewport","_applyBlendColor","drawType","fillMode","start","count","instancesCount","applyStates","bindUniformBufferBase","InternalsUBOName","uniformBuffer","getBuffer","LeftOvertUBOName","isDirty","updateId","forceBindGroupCreation","fastBundle","useFastPath","renderPass2","record","_applyRenderPassChanges","indirectDrawBuffer","setIndirectData","getBundleEncoder","colorFormats","numDrawCalls","textureState","hasFloatTextures","bitVal","textureNames","textureName","pipeline","getRenderPipeline","bindGroups","getBindGroups","createRenderBundleEncoder","depthStencilFormat","setPipeline","setIndexBuffer","IndexFormat","Uint32","Uint16","vertexBuffer","setVertexBuffer","_validOffsetRange","setBindGroup","nonCompatMode","drawIndexedIndirect","drawIndirect","drawIndexed","draw","indexStart","indexCount","_draw","verticesStart","verticesCount","_mainTextureLastCopy","useScreen","action"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/webgpuEngine.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable, DataArray, IndicesArray, Immutable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IEffectCreationOptions } from \"../Materials/effect\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { Constants } from \"./constants\";\r\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IWebGPURenderPipelineStageDescriptor } from \"./WebGPU/webgpuPipelineContext\";\r\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL\";\r\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper\";\r\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree\";\r\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer\";\r\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext\";\r\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext\";\r\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups\";\r\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { ComputeEffect } from \"../Compute/computeEffect\";\r\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport type { TwgslOptions } from \"./WebGPU/webgpuTintWASM\";\r\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport type { WebGPUDataBuffer } from \"../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\ndeclare type VideoTexture = import(\"../Materials/Textures/videoTexture\").VideoTexture;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type RenderTargetWrapper = import(\"./renderTargetWrapper\").RenderTargetWrapper;\r\n\r\n/**\r\n * Options to load the associated Glslang library\r\n */\r\nexport interface GlslangOptions {\r\n    /**\r\n     * Defines an existing instance of Glslang (useful in modules who do not access the global instance).\r\n     */\r\n    glslang?: any;\r\n    /**\r\n     * Defines the URL of the glslang JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the glslang WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/**\r\n * Options to create the WebGPU engine\r\n */\r\nexport interface WebGPUEngineOptions extends GPURequestAdapterOptions {\r\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    deterministicLockstep?: boolean;\r\n\r\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    lockstepMaxSteps?: number;\r\n\r\n    /**\r\n     * Defines the seconds between each deterministic lock step\r\n     */\r\n    timeStep?: number;\r\n\r\n    /**\r\n     * Defines that engine should ignore context lost events\r\n     * If this event happens when this parameter is true, you will have to reload the page to restore rendering\r\n     */\r\n    doNotHandleContextLost?: boolean;\r\n\r\n    /**\r\n     * Defines that engine should ignore modifying touch action attribute and style\r\n     * If not handle, you might need to set it up on your side for expected touch devices behavior.\r\n     */\r\n    doNotHandleTouchAction?: boolean;\r\n\r\n    /**\r\n     * Defines if webaudio should be initialized as well\r\n     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n     */\r\n    audioEngine?: boolean;\r\n\r\n    /**\r\n     * Defines the category of adapter to use.\r\n     * Is it the discrete or integrated device.\r\n     */\r\n    powerPreference?: GPUPowerPreference;\r\n\r\n    /**\r\n     * Defines the device descriptor used to create a device.\r\n     */\r\n    deviceDescriptor?: GPUDeviceDescriptor;\r\n\r\n    /**\r\n     * Defines the requested Swap Chain Format.\r\n     */\r\n    swapChainFormat?: GPUTextureFormat;\r\n\r\n    /**\r\n     * Defines whether MSAA is enabled on the canvas.\r\n     */\r\n    antialiasing?: boolean;\r\n\r\n    /**\r\n     * Defines whether the stencil buffer should be enabled.\r\n     */\r\n    stencil?: boolean;\r\n\r\n    /**\r\n     * Defines whether we should generate debug markers in the gpu command lists (can be seen with PIX for eg)\r\n     */\r\n    enableGPUDebugMarkers?: boolean;\r\n\r\n    /**\r\n     * Options to load the associated Glslang library\r\n     */\r\n    glslangOptions?: GlslangOptions;\r\n\r\n    /**\r\n     * Options to load the associated Twgsl library\r\n     */\r\n    twgslOptions?: TwgslOptions;\r\n\r\n    /**\r\n     * Defines if the engine should no exceed a specified device ratio\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\r\n     */\r\n    limitDeviceRatio?: number;\r\n\r\n    /**\r\n     * Defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n\r\n    /**\r\n     * Defines whether the canvas should be created in \"premultiplied\" mode (if false, the canvas is created in the \"opaque\" mode) (true by default)\r\n     */\r\n    premultipliedAlpha?: boolean;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n}\r\n\r\n/**\r\n * The web GPU engine class provides support for WebGPU version of babylon.js.\r\n * @since 5.0.0\r\n */\r\nexport class WebGPUEngine extends Engine {\r\n    // Default glslang options.\r\n    private static readonly _GLSLslangDefaultOptions: GlslangOptions = {\r\n        jsPath: \"https://preview.babylonjs.com/glslang/glslang.js\",\r\n        wasmPath: \"https://preview.babylonjs.com/glslang/glslang.wasm\",\r\n    };\r\n\r\n    /** true to enable using TintWASM to convert Spir-V to WGSL */\r\n    public static UseTWGSL = true;\r\n\r\n    // Page Life cycle and constants\r\n    private readonly _uploadEncoderDescriptor = { label: \"upload\" };\r\n    private readonly _renderEncoderDescriptor = { label: \"render\" };\r\n    private readonly _renderTargetEncoderDescriptor = { label: \"renderTarget\" };\r\n    /** @hidden */\r\n    public readonly _clearDepthValue = 1;\r\n    /** @hidden */\r\n    public readonly _clearReverseDepthValue = 0;\r\n    /** @hidden */\r\n    public readonly _clearStencilValue = 0;\r\n    private readonly _defaultSampleCount = 4; // Only supported value for now.\r\n\r\n    // Engine Life Cycle\r\n    private _canvas: HTMLCanvasElement;\r\n    /** @hidden */\r\n    public _options: WebGPUEngineOptions;\r\n    private _glslang: any = null;\r\n    private _tintWASM: Nullable<WebGPUTintWASM> = null;\r\n    private _adapter: GPUAdapter;\r\n    private _adapterSupportedExtensions: GPUFeatureName[];\r\n    /** @hidden */\r\n    public _device: GPUDevice;\r\n    private _deviceEnabledExtensions: GPUFeatureName[];\r\n    private _context: GPUCanvasContext;\r\n    private _swapChainTexture: GPUTexture;\r\n    private _mainPassSampleCount: number;\r\n    /** @hidden */\r\n    public _textureHelper: WebGPUTextureHelper;\r\n    /** @hidden */\r\n    public _bufferManager: WebGPUBufferManager;\r\n    private _clearQuad: WebGPUClearQuad;\r\n    /** @hidden */\r\n    public _cacheSampler: WebGPUCacheSampler;\r\n    /** @hidden */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _cacheBindGroups: WebGPUCacheBindGroups;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    /** @hidden */\r\n    public _mrtAttachments: number[];\r\n    /** @hidden */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @hidden */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n    /** @hidden */\r\n    public _compiledComputeEffects: { [key: string]: ComputeEffect } = {};\r\n    /** @hidden */\r\n    public _counters: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Counters from last frame\r\n     */\r\n    public readonly countersLastFrame: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Max number of uncaptured error messages to log\r\n     */\r\n    public numMaxUncapturedErrors = 20;\r\n\r\n    // Some of the internal state might change during the render pass.\r\n    // This happens mainly during clear for the state\r\n    // And when the frame starts to swap the target texture from the swap chain\r\n    private _mainTexture: GPUTexture;\r\n    private _mainTextureLastCopy: GPUTexture;\r\n    private _depthTexture: GPUTexture;\r\n    private _mainTextureExtends: GPUExtent3D;\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _colorFormat: GPUTextureFormat;\r\n    /** @hidden */\r\n    public _ubInvertY: WebGPUDataBuffer;\r\n    /** @hidden */\r\n    public _ubDontInvertY: WebGPUDataBuffer;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @hidden */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n    /** @hidden */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @hidden */\r\n    public _renderTargetEncoder: GPUCommandEncoder;\r\n\r\n    private _commandBuffers: GPUCommandBuffer[] = [null as any, null as any, null as any];\r\n\r\n    // Frame Buffer Life Cycle (recreated for each render target pass)\r\n    /** @hidden */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n    /** @hidden */\r\n    public _mainRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @hidden */\r\n    public _rttRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @hidden */\r\n    public _pendingDebugCommands: Array<[string, Nullable<string>]> = [];\r\n    /** @hidden */\r\n    public _bundleList: WebGPUBundleList;\r\n    /** @hidden */\r\n    public _bundleListRenderTarget: WebGPUBundleList;\r\n    /** @hidden */\r\n    public _onAfterUnbindFrameBufferObservable = new Observable<WebGPUEngine>();\r\n\r\n    // DrawCall Life Cycle\r\n    // Effect is on the parent class\r\n    // protected _currentEffect: Nullable<Effect> = null;\r\n    private _defaultDrawContext: WebGPUDrawContext;\r\n    private _defaultMaterialContext: WebGPUMaterialContext;\r\n    /** @hidden */\r\n    public _currentDrawContext: WebGPUDrawContext;\r\n    /** @hidden */\r\n    public _currentMaterialContext: WebGPUMaterialContext;\r\n    private _currentOverrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }> = null;\r\n    private _currentIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _colorWriteLocal = true;\r\n    private _forceEnableEffect = false;\r\n\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @hidden */\r\n    public dbgShowShaderCode = false;\r\n    /** @hidden */\r\n    public dbgSanityChecks = true;\r\n    /** @hidden */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n    /** @hidden */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @hidden */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @hidden */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n\r\n    private _snapshotRendering: WebGPUSnapshotRendering;\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return this._snapshotRendering.mode;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {\r\n        this._snapshotRendering.mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this._snapshotRendering.reset();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return this._snapshotRendering.enabled;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        this._snapshotRendering.enabled = activate;\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheSamplers(): boolean {\r\n        return this._cacheSampler ? this._cacheSampler.disabled : false;\r\n    }\r\n\r\n    public set disableCacheSamplers(disable: boolean) {\r\n        if (this._cacheSampler) {\r\n            this._cacheSampler.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheRenderPipelines(): boolean {\r\n        return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\r\n    }\r\n\r\n    public set disableCacheRenderPipelines(disable: boolean) {\r\n        if (this._cacheRenderPipeline) {\r\n            this._cacheRenderPipeline.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheBindGroups(): boolean {\r\n        return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\r\n    }\r\n\r\n    public set disableCacheBindGroups(disable: boolean) {\r\n        if (this._cacheBindGroups) {\r\n            this._cacheBindGroups.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\r\n     */\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return !navigator.gpu\r\n            ? Promise.resolve(false)\r\n            : navigator.gpu\r\n                  .requestAdapter()\r\n                  .then(\r\n                      (adapter: GPUAdapter | null) => !!adapter,\r\n                      () => false\r\n                  )\r\n                  .catch(() => false);\r\n    }\r\n\r\n    /**\r\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** Gets the supported extensions by the WebGPU adapter */\r\n    public get supportedExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._adapterSupportedExtensions;\r\n    }\r\n\r\n    /** Gets the currently enabled extensions on the WebGPU device */\r\n    public get enabledExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._deviceEnabledExtensions;\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        const description = this.name + this.version;\r\n\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return {\r\n            vendor: \"unknown vendor\",\r\n            renderer: \"unknown renderer\",\r\n            version: \"unknown version\",\r\n        };\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/advanced_topics/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        this._compatibilityMode = mode;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get currentSampleCount(): number {\r\n        return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine asynchronously\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     * @returns a promise that resolves with the created engine\r\n     */\r\n    public static CreateAsync(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}): Promise<WebGPUEngine> {\r\n        const engine = new WebGPUEngine(canvas, options);\r\n\r\n        return new Promise((resolve) => {\r\n            engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine.\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     */\r\n    public constructor(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}) {\r\n        super(null);\r\n        this._name = \"WebGPU\";\r\n\r\n        (this.isNDCHalfZRange as any) = true;\r\n        (this.hasOriginBottomLeft as any) = false;\r\n\r\n        options.deviceDescriptor = options.deviceDescriptor || {};\r\n        options.swapChainFormat = options.swapChainFormat || WebGPUConstants.TextureFormat.BGRA8Unorm;\r\n        options.antialiasing = options.antialiasing === undefined ? true : options.antialiasing;\r\n        options.stencil = options.stencil ?? true;\r\n        options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\r\n        if (!navigator.gpu) {\r\n            Logger.Error(\"WebGPU is not supported by your browser.\");\r\n            return;\r\n        }\r\n\r\n        this._isWebGPU = true;\r\n        this._shaderPlatformName = \"WEBGPU\";\r\n\r\n        if (options.deterministicLockstep === undefined) {\r\n            options.deterministicLockstep = false;\r\n        }\r\n\r\n        if (options.lockstepMaxSteps === undefined) {\r\n            options.lockstepMaxSteps = 4;\r\n        }\r\n\r\n        if (options.audioEngine === undefined) {\r\n            options.audioEngine = true;\r\n        }\r\n\r\n        this._deterministicLockstep = options.deterministicLockstep;\r\n        this._lockstepMaxSteps = options.lockstepMaxSteps;\r\n        this._timeStep = options.timeStep || 1 / 60;\r\n\r\n        this._doNotHandleContextLost = !!options.doNotHandleContextLost;\r\n\r\n        this._canvas = canvas;\r\n        this._options = options;\r\n        this.premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n\r\n        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\r\n        const adaptToDeviceRatio = options.adaptToDeviceRatio ?? false;\r\n\r\n        this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\r\n        this._mainPassSampleCount = options.antialiasing ? this._defaultSampleCount : 1;\r\n        this._isStencilEnable = options.stencil;\r\n\r\n        this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);\r\n\r\n        this._shaderProcessor = new WebGPUShaderProcessorGLSL();\r\n        this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Initialization\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Initializes the WebGPU context and dependencies.\r\n     * @param glslangOptions Defines the GLSLang compiler options if necessary\r\n     * @param twgslOptions Defines the Twgsl compiler options if necessary\r\n     * @returns a promise notifying the readiness of the engine.\r\n     */\r\n    public initAsync(glslangOptions?: GlslangOptions, twgslOptions?: TwgslOptions): Promise<void> {\r\n        return this._initGlslang(glslangOptions ?? this._options?.glslangOptions)\r\n            .then(\r\n                (glslang: any) => {\r\n                    this._glslang = glslang;\r\n                    this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\r\n                    return this._tintWASM\r\n                        ? this._tintWASM.initTwgsl(twgslOptions ?? this._options?.twgslOptions).then(\r\n                              () => {\r\n                                  return navigator.gpu!.requestAdapter(this._options);\r\n                              },\r\n                              (msg: string) => {\r\n                                  Logger.Error(\"Can not initialize twgsl!\");\r\n                                  Logger.Error(msg);\r\n                                  throw Error(\"WebGPU initializations stopped.\");\r\n                              }\r\n                          )\r\n                        : navigator.gpu!.requestAdapter(this._options);\r\n                },\r\n                (msg: string) => {\r\n                    Logger.Error(\"Can not initialize glslang!\");\r\n                    Logger.Error(msg);\r\n                    throw Error(\"WebGPU initializations stopped.\");\r\n                }\r\n            )\r\n            .then((adapter: GPUAdapter | null) => {\r\n                if (!adapter) {\r\n                    throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\r\n                } else {\r\n                    this._adapter = adapter!;\r\n                    this._adapterSupportedExtensions = [];\r\n                    this._adapter.features?.forEach((feature) => this._adapterSupportedExtensions.push(feature as WebGPUConstants.FeatureName));\r\n\r\n                    const deviceDescriptor = this._options.deviceDescriptor;\r\n\r\n                    if (deviceDescriptor?.requiredFeatures) {\r\n                        const requestedExtensions = deviceDescriptor.requiredFeatures;\r\n                        const validExtensions: GPUFeatureName[] = [];\r\n\r\n                        for (const extension of requestedExtensions) {\r\n                            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\r\n                                validExtensions.push(extension);\r\n                            }\r\n                        }\r\n\r\n                        deviceDescriptor.requiredFeatures = validExtensions;\r\n                    }\r\n\r\n                    return this._adapter.requestDevice(this._options.deviceDescriptor);\r\n                }\r\n            })\r\n            .then(\r\n                (device: GPUDevice) => {\r\n                    this._device = device;\r\n                    this._deviceEnabledExtensions = [];\r\n                    this._device.features?.forEach((feature) => this._deviceEnabledExtensions.push(feature as WebGPUConstants.FeatureName));\r\n\r\n                    let numUncapturedErrors = -1;\r\n                    this._device.addEventListener(\"uncapturederror\", (event) => {\r\n                        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${(<GPUUncapturedErrorEvent>event).error} - ${(<any>event).error.message}`);\r\n                        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(\r\n                                `WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    if (!this._doNotHandleContextLost) {\r\n                        this._device.lost?.then((info) => {\r\n                            this._contextWasLost = true;\r\n                            Logger.Warn(\"WebGPU context lost. \" + info);\r\n                            this.onContextLostObservable.notifyObservers(this);\r\n                            this._restoreEngineAfterContextLost(this.initAsync.bind(this));\r\n                        });\r\n                    }\r\n                },\r\n                (e: any) => {\r\n                    Logger.Error(\"Could not retrieve a WebGPU device.\");\r\n                    Logger.Error(e);\r\n                }\r\n            )\r\n            .then(() => {\r\n                this._bufferManager = new WebGPUBufferManager(this._device);\r\n                this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager);\r\n                this._cacheSampler = new WebGPUCacheSampler(this._device);\r\n                this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\r\n                this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);\r\n                this._occlusionQuery = (this._device as any).createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : (undefined as any);\r\n                this._bundleList = new WebGPUBundleList(this._device);\r\n                this._bundleListRenderTarget = new WebGPUBundleList(this._device);\r\n                this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);\r\n\r\n                this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\r\n                this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n                if (this.dbgVerboseLogsForFirstFrames) {\r\n                    if ((this as any)._count === undefined) {\r\n                        (this as any)._count = 0;\r\n                        console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                    }\r\n                }\r\n\r\n                this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n                this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n                this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n                this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", false, false, 1, false, 0, 1);\r\n\r\n                this._initializeLimits();\r\n\r\n                this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);\r\n\r\n                this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\r\n                this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\r\n                this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n                this._depthCullingState.depthTest = true;\r\n                this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n                this._depthCullingState.depthMask = true;\r\n\r\n                this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n                this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\r\n                this._defaultDrawContext = this.createDrawContext()!;\r\n                this._currentDrawContext = this._defaultDrawContext;\r\n                this._defaultMaterialContext = this.createMaterialContext()!;\r\n                this._currentMaterialContext = this._defaultMaterialContext;\r\n\r\n                this._initializeContextAndSwapChain();\r\n                this._initializeMainAttachments();\r\n                this.resize();\r\n            })\r\n            .catch((e: any) => {\r\n                Logger.Error(\"Can not create WebGPU Device and/or context.\");\r\n                Logger.Error(e);\r\n                if (console.trace) {\r\n                    console.trace();\r\n                }\r\n            });\r\n    }\r\n\r\n    private _initGlslang(glslangOptions?: GlslangOptions): Promise<any> {\r\n        glslangOptions = glslangOptions || {};\r\n        glslangOptions = {\r\n            ...WebGPUEngine._GLSLslangDefaultOptions,\r\n            ...glslangOptions,\r\n        };\r\n\r\n        if (glslangOptions.glslang) {\r\n            return Promise.resolve(glslangOptions.glslang);\r\n        }\r\n\r\n        if ((self as any).glslang) {\r\n            return (self as any).glslang(glslangOptions!.wasmPath);\r\n        }\r\n\r\n        if (glslangOptions.jsPath && glslangOptions.wasmPath) {\r\n            if (IsWindowObjectExist()) {\r\n                return Tools.LoadScriptAsync(glslangOptions.jsPath).then(() => {\r\n                    return (self as any).glslang(glslangOptions!.wasmPath);\r\n                });\r\n            } else {\r\n                importScripts(glslangOptions.jsPath);\r\n                return (self as any).glslang(glslangOptions!.wasmPath);\r\n            }\r\n        }\r\n\r\n        return Promise.reject(\"gslang is not available.\");\r\n    }\r\n\r\n    private _initializeLimits(): void {\r\n        // Init caps\r\n        // TODO WEBGPU Real Capability check once limits will be working.\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: 8192,\r\n            maxCubemapTextureSize: 2048,\r\n            maxRenderTextureSize: 8192,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 15,\r\n            maxFragmentUniformVectors: 1024,\r\n            maxVertexUniformVectors: 1024,\r\n            standardDerivatives: true,\r\n            astc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined) as any,\r\n            s3tc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined) as any,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined) as any,\r\n            bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\r\n            maxAnisotropy: 4, // the spec only supports values of 1 and 4\r\n            uintIndices: true,\r\n            fragmentDepthSupported: true,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: true,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: false, // WebGPU does not allow filtering 32 bits float textures\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: true,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            drawBuffersExtension: true,\r\n            depthTextureExtension: true,\r\n            vertexArrayObject: false,\r\n            instancedArrays: true,\r\n            timerQuery: typeof BigUint64Array !== \"undefined\" && this.enabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? (true as any) : undefined,\r\n            supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\r\n            canUseTimestampForTimerQuery: true,\r\n            multiview: false,\r\n            oculusMultiview: false,\r\n            parallelShaderCompile: undefined,\r\n            blendMinMax: true,\r\n            maxMSAASamples: 4,\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: true,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: true,\r\n        };\r\n\r\n        this._caps.parallelShaderCompile = null as any;\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: true,\r\n            supportDepthStencilTexture: true,\r\n            supportShadowSamplers: true,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: true,\r\n            trackUbosInFrame: true,\r\n            checkUbosContentBeforeUpload: true,\r\n            supportCSM: true,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: true,\r\n            needTypeSuffixInShaderConstants: true,\r\n            supportMSAA: true,\r\n            supportSSAO2: true,\r\n            supportExtendedTextureFormats: true,\r\n            supportSwitchCaseInShader: true,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: true,\r\n            supportRenderPasses: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n    }\r\n\r\n    private _initializeContextAndSwapChain(): void {\r\n        this._context = this._canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n        this._configureContext(this._canvas.width, this._canvas.height);\r\n        this._colorFormat = this._options.swapChainFormat!;\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;\r\n    }\r\n\r\n    // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\r\n    private _initializeMainAttachments(): void {\r\n        this._mainTextureExtends = {\r\n            width: this.getRenderWidth(),\r\n            height: this.getRenderHeight(),\r\n            depthOrArrayLayers: 1,\r\n        };\r\n\r\n        const bufferDataUpdate = new Float32Array([this.getRenderHeight()]);\r\n\r\n        this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\r\n        this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\r\n\r\n        let mainColorAttachments: GPURenderPassColorAttachment[];\r\n\r\n        if (this._options.antialiasing) {\r\n            const mainTextureDescriptor: GPUTextureDescriptor = {\r\n                size: this._mainTextureExtends,\r\n                mipLevelCount: 1,\r\n                sampleCount: this._mainPassSampleCount,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._options.swapChainFormat!,\r\n                usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n            };\r\n\r\n            this._mainTexture?.destroy();\r\n            this._mainTexture = this._device.createTexture(mainTextureDescriptor);\r\n            mainColorAttachments = [\r\n                {\r\n                    view: this._mainTexture.createView(),\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store, // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\r\n                },\r\n            ];\r\n        } else {\r\n            mainColorAttachments = [\r\n                {\r\n                    view: undefined as any,\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ];\r\n        }\r\n\r\n        this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n\r\n        const depthTextureDescriptor: GPUTextureDescriptor = {\r\n            size: this._mainTextureExtends,\r\n            mipLevelCount: 1,\r\n            sampleCount: this._mainPassSampleCount,\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format: this._mainRenderPassWrapper.depthTextureFormat,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n        };\r\n\r\n        if (this._depthTexture) {\r\n            this._depthTexture.destroy();\r\n        }\r\n        this._depthTexture = this._device.createTexture(depthTextureDescriptor);\r\n        const mainDepthAttachment: GPURenderPassDepthStencilAttachment = {\r\n            view: this._depthTexture.createView(),\r\n\r\n            depthClearValue: this._clearDepthValue,\r\n            depthLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n            stencilClearValue: this._clearStencilValue,\r\n            stencilLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            stencilStoreOp: WebGPUConstants.StoreOp.Store,\r\n        };\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor = {\r\n            colorAttachments: mainColorAttachments,\r\n            depthStencilAttachment: mainDepthAttachment,\r\n        };\r\n\r\n        if (this._mainRenderPassWrapper.renderPass !== null) {\r\n            this._endMainRenderPass();\r\n        }\r\n    }\r\n\r\n    private _configureContext(width: number, height: number): void {\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._options.swapChainFormat!,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\r\n            compositingAlphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasCompositingAlphaMode.Premultiplied : WebGPUConstants.CanvasCompositingAlphaMode.Opaque,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!super.setSize(width, height, forceSetSize)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - setSize called -\", width, height);\r\n            }\r\n        }\r\n\r\n        this._configureContext(width, height);\r\n        this._initializeMainAttachments();\r\n\r\n        if (this.snapshotRendering) {\r\n            // reset snapshot rendering so that the next frame will record a new list of bundles\r\n            this.snapshotRenderingReset();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _shaderProcessorWGSL: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @param shaderLanguage\r\n     * @hidden\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._shaderProcessorWGSL;\r\n        }\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * @param shaderLanguage\r\n     * @hidden\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext> {\r\n        return new WebGPUShaderProcessingContext(shaderLanguage);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                          Static Pipeline WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @hidden */\r\n    public applyStates() {\r\n        this._stencilStateComposer.apply();\r\n        this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n\r\n        //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\r\n        // _forceEnableEffect = true assumes the role of _currentEffect = null\r\n        this._forceEnableEffect = true;\r\n        this._currentIndexBuffer = null;\r\n        this._currentOverrideVertexBuffers = null;\r\n        this._cacheRenderPipeline.setBuffers(null, null, null);\r\n\r\n        if (bruteForce) {\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._alphaMode = Constants.ALPHA_ADD;\r\n            this._alphaEquation = Constants.ALPHA_DISABLE;\r\n            this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n            this._cacheRenderPipeline.setAlphaBlendEnabled(false);\r\n\r\n            this.setColorWrite(true);\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWriteLocal = enable;\r\n        this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWriteLocal;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dynamic WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    // index 0 is for main render pass, 1 for RTT render pass\r\n    private _viewportsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n\r\n    private _resetCurrentViewport(index: number) {\r\n        this._viewportsCurrent[index].x = 0;\r\n        this._viewportsCurrent[index].y = 0;\r\n        this._viewportsCurrent[index].w = 0;\r\n        this._viewportsCurrent[index].h = 0;\r\n\r\n        if (index === 1) {\r\n            this._viewportCached.x = 0;\r\n            this._viewportCached.y = 0;\r\n            this._viewportCached.z = 0;\r\n            this._viewportCached.w = 0;\r\n        }\r\n    }\r\n\r\n    private _mustUpdateViewport(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._viewportCached.x,\r\n            y = this._viewportCached.y,\r\n            w = this._viewportCached.z,\r\n            h = this._viewportCached.w;\r\n\r\n        const update =\r\n            this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._viewportsCurrent[index].x = this._viewportCached.x;\r\n            this._viewportsCurrent[index].y = this._viewportCached.y;\r\n            this._viewportsCurrent[index].w = this._viewportCached.z;\r\n            this._viewportsCurrent[index].h = this._viewportCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyViewport(renderPass: GPURenderPassEncoder): void {\r\n        let y = Math.floor(this._viewportCached.y);\r\n        const h = Math.floor(this._viewportCached.w);\r\n\r\n        if (!this._currentRenderTarget) {\r\n            y = this.getRenderHeight() - y - h;\r\n        }\r\n\r\n        renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - viewport applied - (\",\r\n                    this._viewportCached.x,\r\n                    this._viewportCached.y,\r\n                    this._viewportCached.z,\r\n                    this._viewportCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param x\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     * @hidden\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        this._viewportCached.x = x;\r\n        this._viewportCached.y = y;\r\n        this._viewportCached.z = width;\r\n        this._viewportCached.w = height;\r\n    }\r\n\r\n    private _scissorsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n    protected _scissorCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    private _resetCurrentScissor(index: number) {\r\n        this._scissorsCurrent[index].x = 0;\r\n        this._scissorsCurrent[index].y = 0;\r\n        this._scissorsCurrent[index].w = 0;\r\n        this._scissorsCurrent[index].h = 0;\r\n    }\r\n\r\n    private _mustUpdateScissor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._scissorCached.x,\r\n            y = this._scissorCached.y,\r\n            w = this._scissorCached.z,\r\n            h = this._scissorCached.w;\r\n\r\n        const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._scissorsCurrent[index].x = this._scissorCached.x;\r\n            this._scissorsCurrent[index].y = this._scissorCached.y;\r\n            this._scissorsCurrent[index].w = this._scissorCached.z;\r\n            this._scissorsCurrent[index].h = this._scissorCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyScissor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setScissorRect(\r\n            this._scissorCached.x,\r\n            this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y,\r\n            this._scissorCached.z,\r\n            this._scissorCached.w\r\n        );\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - scissor applied - (\",\r\n                    this._scissorCached.x,\r\n                    this._scissorCached.y,\r\n                    this._scissorCached.z,\r\n                    this._scissorCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scissorIsActive() {\r\n        return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._scissorCached.x = x;\r\n        this._scissorCached.y = y;\r\n        this._scissorCached.z = width;\r\n        this._scissorCached.w = height;\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._scissorCached.x = 0;\r\n        this._scissorCached.y = 0;\r\n        this._scissorCached.z = 0;\r\n        this._scissorCached.w = 0;\r\n\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentScissor(1);\r\n    }\r\n\r\n    private _stencilRefsCurrent: Array<number> = [-1, -1];\r\n\r\n    private _resetCurrentStencilRef(index: number): void {\r\n        this._stencilRefsCurrent[index] = -1;\r\n    }\r\n\r\n    private _mustUpdateStencilRef(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\r\n        if (update) {\r\n            this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\r\n        }\r\n        return update;\r\n    }\r\n\r\n    /**\r\n     * @param renderPass\r\n     * @hidden\r\n     */\r\n    public _applyStencilRef(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setStencilReference(this._stencilStateComposer.funcRef ?? 0);\r\n    }\r\n\r\n    private _blendColorsCurrent: Array<Array<Nullable<number>>> = [\r\n        [null, null, null, null],\r\n        [null, null, null, null],\r\n    ];\r\n\r\n    private _resetCurrentColorBlend(index: number): void {\r\n        this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\r\n    }\r\n\r\n    private _mustUpdateBlendColor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const colorBlend = this._alphaState._blendConstants;\r\n\r\n        const update =\r\n            colorBlend[0] !== this._blendColorsCurrent[index][0] ||\r\n            colorBlend[1] !== this._blendColorsCurrent[index][1] ||\r\n            colorBlend[2] !== this._blendColorsCurrent[index][2] ||\r\n            colorBlend[3] !== this._blendColorsCurrent[index][3];\r\n\r\n        if (update) {\r\n            this._blendColorsCurrent[index][0] = colorBlend[0];\r\n            this._blendColorsCurrent[index][1] = colorBlend[1];\r\n            this._blendColorsCurrent[index][2] = colorBlend[2];\r\n            this._blendColorsCurrent[index][3] = colorBlend[3];\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyBlendColor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setBlendConstant(this._alphaState._blendConstants as GPUColor);\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        // Some PGs are using color3...\r\n        if (color && color.a === undefined) {\r\n            color.a = 1;\r\n        }\r\n\r\n        const hasScissor = this._scissorIsActive();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - clear called - backBuffer=\",\r\n                    backBuffer,\r\n                    \" depth=\",\r\n                    depth,\r\n                    \" stencil=\",\r\n                    stencil,\r\n                    \" scissor is active=\",\r\n                    hasScissor\r\n                );\r\n            }\r\n        }\r\n\r\n        // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\r\n        if (this._currentRenderTarget) {\r\n            if (hasScissor) {\r\n                if (!this._rttRenderPassWrapper.renderPass) {\r\n                    this._startRenderTargetRenderPass(this._currentRenderTarget!, false, backBuffer ? color : null, depth, stencil);\r\n                }\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            } else {\r\n                if (this._currentRenderPass) {\r\n                    this._endRenderTargetRenderPass();\r\n                }\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, true, backBuffer ? color : null, depth, stencil);\r\n            }\r\n        } else {\r\n            if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\r\n                this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\r\n            }\r\n            if (hasScissor) {\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clearFullQuad(clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this._clearQuad.setColorFormat(this._colorFormat);\r\n        this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\r\n        this._clearQuad.setMRTAttachments(\r\n            this._cacheRenderPipeline.mrtAttachments ?? [],\r\n            this._cacheRenderPipeline.mrtTextureArray ?? [],\r\n            this._cacheRenderPipeline.mrtTextureCount\r\n        );\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\r\n        } else {\r\n            renderPass!.setStencilReference(this._clearStencilValue);\r\n        }\r\n\r\n        const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addBundle(bundle!);\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            this._reportDrawCall();\r\n        } else {\r\n            this._applyStencilRef(renderPass!);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Vertex/Index/Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the vertex buffer\r\n     * @returns the new buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray): DataBuffer {\r\n        let view: ArrayBufferView;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @returns the new buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray): DataBuffer {\r\n        return this.createVertexBuffer(data);\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @returns a new buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray): DataBuffer {\r\n        let is32Bits = true;\r\n        let view: ArrayBufferView;\r\n\r\n        if (indices instanceof Uint32Array || indices instanceof Int32Array) {\r\n            view = indices;\r\n        } else if (indices instanceof Uint16Array) {\r\n            view = indices;\r\n            is32Bits = false;\r\n        } else {\r\n            if (indices.length > 65535) {\r\n                view = new Uint32Array(indices);\r\n            } else {\r\n                view = new Uint16Array(indices);\r\n                is32Bits = false;\r\n            }\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst);\r\n        dataBuffer.is32Bits = is32Bits;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * @param data\r\n     * @param creationFlags\r\n     * @hidden\r\n     */\r\n    public _createBuffer(data: DataArray | number, creationFlags: number): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        let flags = 0;\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_READ) {\r\n            flags |= WebGPUConstants.BufferUsage.CopySrc;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_WRITE) {\r\n            flags |= WebGPUConstants.BufferUsage.CopyDst;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_UNIFORM) {\r\n            flags |= WebGPUConstants.BufferUsage.Uniform;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_VERTEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Vertex;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Index;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_STORAGE) {\r\n            flags |= WebGPUConstants.BufferUsage.Storage;\r\n        }\r\n\r\n        return this._bufferManager.createBuffer(view, flags);\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public bindBuffersDirectly(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public updateAndBindInstancesBuffer(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers with the engine\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        this._currentIndexBuffer = indexBuffer;\r\n        this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\r\n        this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\r\n    }\r\n\r\n    /**\r\n     * @param buffer\r\n     * @hidden\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        return this._bufferManager.releaseBuffer(buffer);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Effects\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | Engine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ): Effect {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += \"\\n\" + globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = <Effect>this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n\r\n            return compiledEffect;\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            shaderLanguage\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _compileRawShaderToSpirV(source: string, type: string): Uint32Array {\r\n        return this._glslang.compileGLSL(source, type);\r\n    }\r\n\r\n    private _compileShaderToSpirV(source: string, type: string, defines: Nullable<string>, shaderVersion: string): Uint32Array {\r\n        return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\r\n    }\r\n\r\n    private _getWGSLShader(source: string, type: string, defines: Nullable<string>): string {\r\n        if (defines) {\r\n            defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n        } else {\r\n            defines = \"\";\r\n        }\r\n        return defines + source;\r\n    }\r\n\r\n    private _createPipelineStageDescriptor(\r\n        vertexShader: Uint32Array | string,\r\n        fragmentShader: Uint32Array | string,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\r\n            vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader as Uint32Array) as any;\r\n            fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader as Uint32Array) as any;\r\n        }\r\n\r\n        return {\r\n            vertexStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: vertexShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n            fragmentStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: fragmentShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        };\r\n    }\r\n\r\n    private _compileRawPipelineStageDescriptor(vertexCode: string, fragmentCode: string, shaderLanguage: ShaderLanguage): IWebGPURenderPipelineStageDescriptor {\r\n        const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\r\n        const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\r\n\r\n        return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\r\n    }\r\n\r\n    private _compilePipelineStageDescriptor(\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const shaderVersion = \"#version 450\\n\";\r\n        const vertexShader =\r\n            shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\r\n        const fragmentShader =\r\n            shaderLanguage === ShaderLanguage.GLSL\r\n                ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion)\r\n                : this._getWGSLShader(fragmentCode, \"fragment\", defines);\r\n\r\n        const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\r\n\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public createShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n        return new WebGPUPipelineContext(shaderProcessingContext! as WebGPUShaderProcessingContext, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): WebGPUMaterialContext | undefined {\r\n        return new WebGPUMaterialContext();\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): WebGPUDrawContext | undefined {\r\n        return new WebGPUDrawContext(this._bufferManager);\r\n    }\r\n\r\n    /**\r\n     * @param pipelineContext\r\n     * @param vertexSourceCode\r\n     * @param fragmentSourceCode\r\n     * @param createAsRaw\r\n     * @param rawVertexSourceCode\r\n     * @param rawFragmentSourceCode\r\n     * @param rebuildRebind\r\n     * @param defines\r\n     * @hidden\r\n     */\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        const webGpuContext = pipelineContext as WebGPUPipelineContext;\r\n        const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\r\n\r\n        if (this.dbgShowShaderCode) {\r\n            console.log(defines);\r\n            console.log(vertexSourceCode);\r\n            console.log(fragmentSourceCode);\r\n        }\r\n\r\n        webGpuContext.sources = {\r\n            fragment: fragmentSourceCode,\r\n            vertex: vertexSourceCode,\r\n            rawVertex: rawVertexSourceCode,\r\n            rawFragment: rawFragmentSourceCode,\r\n        };\r\n\r\n        if (createAsRaw) {\r\n            webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\r\n        } else {\r\n            webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given WebGPU program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = new Array(attributesNames.length);\r\n        const gpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n\r\n        for (let i = 0; i < attributesNames.length; i++) {\r\n            const attributeName = attributesNames[i];\r\n            const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\r\n            if (attributeLocation === undefined) {\r\n                continue;\r\n            }\r\n\r\n            results[i] = attributeLocation;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        let isNewEffect = true;\r\n\r\n        if (!DrawWrapper.IsWrapper(effect)) {\r\n            isNewEffect = effect !== this._currentEffect;\r\n            this._currentEffect = effect;\r\n            this._currentMaterialContext = this._defaultMaterialContext;\r\n            this._currentDrawContext = this._defaultDrawContext;\r\n            this._counters.numEnableEffects++;\r\n            if (this.dbgLogIfNotDrawWrapper) {\r\n                Logger.Warn(\r\n                    `enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`,\r\n                    10\r\n                );\r\n            }\r\n        } else if (\r\n            !effect.effect ||\r\n            (effect.effect === this._currentEffect &&\r\n                effect.materialContext === this._currentMaterialContext &&\r\n                effect.drawContext === this._currentDrawContext &&\r\n                !this._forceEnableEffect)\r\n        ) {\r\n            if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw \"Invalid call to enableEffect: the effect property is empty!\";\r\n            }\r\n            return;\r\n        } else {\r\n            isNewEffect = effect.effect !== this._currentEffect;\r\n            this._currentEffect = effect.effect;\r\n            this._currentMaterialContext = effect.materialContext as WebGPUMaterialContext;\r\n            this._currentDrawContext = effect.drawContext as WebGPUDrawContext;\r\n            this._counters.numEnableDrawWrapper++;\r\n            if (!this._currentMaterialContext) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw `Invalid call to enableEffect: the materialContext property is empty!`;\r\n            }\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\r\n\r\n        if (isNewEffect) {\r\n            if (this._currentEffect!.onBind) {\r\n                this._currentEffect!.onBind(this._currentEffect!);\r\n            }\r\n            if (this._currentEffect!._onBindObservable) {\r\n                this._currentEffect!._onBindObservable.notifyObservers(this._currentEffect!);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @hidden\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n\r\n            this._deletePipelineContext(effect.getPipelineContext() as WebGPUPipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGPUPipelineContext;\r\n            this._deletePipelineContext(webGPUPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webgpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n        if (webgpuPipelineContext) {\r\n            pipelineContext.dispose();\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new WebGPUHardwareTexture();\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @hidden\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        this._textureHelper.releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(): number {\r\n        return Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @hidden\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        const fullOptions: InternalTextureCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            fullOptions.format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            fullOptions.samples = options.samples ?? 1;\r\n            fullOptions.creationFlags = options.creationFlags ?? 0;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n            fullOptions.format = Constants.TEXTUREFORMAT_RGBA;\r\n            fullOptions.samples = 1;\r\n            fullOptions.creationFlags = 0;\r\n        }\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = fullOptions.samples;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture.format = fullOptions.format;\r\n        texture.is2DArray = layers > 0;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (!delayGPUTextureCreation) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a hardware texture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (\r\n                texture: InternalTexture,\r\n                extension: string,\r\n                scene: Nullable<ISceneLike>,\r\n                img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                invertY: boolean,\r\n                noMipmap: boolean,\r\n                isCompressed: boolean,\r\n                processFunction: (\r\n                    width: number,\r\n                    height: number,\r\n                    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                    extension: string,\r\n                    texture: InternalTexture,\r\n                    continuationCallback: () => void\r\n                ) => boolean\r\n            ) => {\r\n                const imageBitmap = img as ImageBitmap | { width: number; height: number }; // we will never get an HTMLImageElement in WebGPU\r\n\r\n                texture.baseWidth = imageBitmap.width;\r\n                texture.baseHeight = imageBitmap.height;\r\n                texture.width = imageBitmap.width;\r\n                texture.height = imageBitmap.height;\r\n                texture.format = format ?? -1;\r\n\r\n                processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\r\n\r\n                if (!texture._hardwareTexture?.underlyingResource) {\r\n                    // the texture could have been created before reaching this point so don't recreate it if already existing\r\n                    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\r\n\r\n                    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n                        this._textureHelper.updateTexture(\r\n                            imageBitmap,\r\n                            texture,\r\n                            imageBitmap.width,\r\n                            imageBitmap.height,\r\n                            texture.depth,\r\n                            gpuTextureWrapper.format,\r\n                            0,\r\n                            0,\r\n                            invertY,\r\n                            false,\r\n                            0,\r\n                            0\r\n                        );\r\n                        if (!noMipmap && !isCompressed) {\r\n                            this._generateMipmaps(texture, this._uploadEncoder);\r\n                        }\r\n                    }\r\n                } else if (!noMipmap && !isCompressed) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                if (scene) {\r\n                    scene._removePendingData(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n            },\r\n            () => false,\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gpu texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    wrapWebGPUTexture(texture: GPUTexture): InternalTexture {\r\n        const hardwareTexture = new WebGPUHardwareTexture(texture);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\r\n    }\r\n\r\n    public generateMipMapsForCubemap(texture: InternalTexture) {\r\n        if (texture.generateMipMaps) {\r\n            const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n            if (!gpuTexture) {\r\n                this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n            }\r\n\r\n            this._generateMipmaps(\r\n                texture,\r\n                texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._generateMipmaps(texture);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        if (wrapU !== null) {\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {\r\n        if (!texture._hardwareTexture) {\r\n            // the gpu texture is not created yet, so when it is it will be created with the right dimensions\r\n            return;\r\n        }\r\n\r\n        if (texture.width === width && texture.height === height && texture.depth === depth) {\r\n            return;\r\n        }\r\n\r\n        const additionalUsages = (texture._hardwareTexture as WebGPUHardwareTexture).textureAdditionalUsages;\r\n\r\n        texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\r\n    }\r\n\r\n    /**\r\n     * @param name\r\n     * @param texture\r\n     * @param baseName\r\n     * @hidden\r\n     */\r\n    public _setInternalTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>, baseName?: string): void {\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            const webgpuPipelineContext = this._currentEffect._pipelineContext as WebGPUPipelineContext;\r\n            const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\r\n\r\n            this._currentMaterialContext.setTexture(name, texture);\r\n\r\n            if (availableTexture && availableTexture.autoBindSampler) {\r\n                const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n                this._currentMaterialContext.setSampler(samplerName, texture as InternalTexture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>, name: string): void {\r\n        this._setTexture(channel, texture, false, false, name, name);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the WebGPU context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param unused unused parameter\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, unused: Nullable<WebGLUniformLocation>, textures: BaseTexture[], name: string): void {\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\r\n        }\r\n    }\r\n\r\n    protected _setTexture(\r\n        channel: number,\r\n        texture: Nullable<BaseTexture>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        isPartOfTextureArray = false,\r\n        depthStencilTexture = false,\r\n        name = \"\",\r\n        baseName?: string\r\n    ): boolean {\r\n        // name == baseName for a texture that is not part of a texture array\r\n        // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\r\n        // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\r\n        // name is used to look up the texture in the _currentMaterialContext.textures map\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            if (!texture) {\r\n                this._currentMaterialContext.setTexture(name, null);\r\n                return false;\r\n            }\r\n\r\n            // Video\r\n            if ((<VideoTexture>texture).video) {\r\n                (<VideoTexture>texture).update();\r\n            } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                // Delay loading\r\n                texture.delayLoad();\r\n                return false;\r\n            }\r\n\r\n            let internalTexture: Nullable<InternalTexture> = null;\r\n            if (depthStencilTexture) {\r\n                internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n            } else if (texture.isReady()) {\r\n                internalTexture = <InternalTexture>texture.getInternalTexture();\r\n            } else if (texture.isCube) {\r\n                internalTexture = this.emptyCubeTexture;\r\n            } else if (texture.is3D) {\r\n                internalTexture = this.emptyTexture3D;\r\n            } else if (texture.is2DArray) {\r\n                internalTexture = this.emptyTexture2DArray;\r\n            } else {\r\n                internalTexture = this.emptyTexture;\r\n            }\r\n\r\n            if (internalTexture && !internalTexture.isMultiview) {\r\n                // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n                if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                    const textureWrapMode =\r\n                        texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                            ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                            : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    texture.wrapU = textureWrapMode;\r\n                    texture.wrapV = textureWrapMode;\r\n                }\r\n\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                if (internalTexture.is3D) {\r\n                    internalTexture._cachedWrapR = texture.wrapR;\r\n                }\r\n\r\n                this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\r\n            }\r\n\r\n            this._setInternalTexture(name, internalTexture, baseName);\r\n        } else {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param target\r\n     * @param internalTexture\r\n     * @param anisotropicFilteringLevel\r\n     * @hidden\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param channel\r\n     * @param texture\r\n     * @param name\r\n     * @hidden\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        this._generateMipmaps(texture, this._renderTargetEncoder);\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @param commandEncoder\r\n     * @hidden\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        // try as much as possible to use the command encoder corresponding to the current pass.\r\n        // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\r\n        commandEncoder =\r\n            commandEncoder ??\r\n            (this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder);\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\r\n\r\n        if (generateMipMaps) {\r\n            this._generateMipmaps(texture, this._renderTargetEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @param internalFormat\r\n     * @param width\r\n     * @param height\r\n     * @param imageData\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            texture.format = internalFormat;\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @param imageData\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @param babylonInternalFormat\r\n     * @param useTextureWidthAndHeight\r\n     * @hidden\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @param imageData\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @param image\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const bitmap = image as ImageBitmap; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\r\n\r\n        const width = Math.ceil(texture.width / (1 << lod));\r\n        const height = Math.ceil(texture.height / (1 << lod));\r\n\r\n        this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public readPixels(x: number, y: number, width: number, height: number, hasAlpha = true, flushRenderer = true): Promise<ArrayBufferView> {\r\n        const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\r\n        const gpuTexture = renderPassWrapper.colorAttachmentGPUTextures![0].underlyingResource;\r\n        const gpuTextureFormat = renderPassWrapper.colorAttachmentGPUTextures![0].format;\r\n        if (!gpuTexture) {\r\n            // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Frame management\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        super.beginFrame();\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame() {\r\n        this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\r\n\r\n        this._endMainRenderPass();\r\n\r\n        this._timestampQuery.endFrame(this._renderEncoder);\r\n\r\n        this.flushFramebuffer(false);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - counters\");\r\n            }\r\n        }\r\n\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n\r\n        if (this._features._collectUbosUpdatedInFrame) {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    const list: Array<string> = [];\r\n                    for (const name in UniformBuffer._UpdatedUbosInFrame) {\r\n                        list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\r\n                    }\r\n                    console.log(\"frame #\" + (this as any)._count + \" - updated ubos -\", list.join(\", \"));\r\n                }\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame = {};\r\n        }\r\n\r\n        this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\r\n        this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\r\n        this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\r\n        this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\r\n        this._counters.numEnableEffects = 0;\r\n        this._counters.numEnableDrawWrapper = 0;\r\n        this._counters.numBundleCreationNonCompatMode = 0;\r\n        this._counters.numBundleReuseNonCompatMode = 0;\r\n\r\n        this._cacheRenderPipeline.endFrame();\r\n        this._cacheBindGroups.endFrame();\r\n\r\n        this._pendingDebugCommands.length = 0;\r\n\r\n        super.endFrame();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"%c frame #\" + (this as any)._count + \" - end\", \"background: #ffff00\");\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                (this as any)._count++;\r\n                if ((this as any)._count !== this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\r\n     */\r\n    public flushFramebuffer(reopenPass = true): void {\r\n        // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\r\n        const currentRenderPassIsNULL = !this._currentRenderPass;\r\n        let currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\r\n        if (this._currentRenderPass && this._currentRenderTarget) {\r\n            currentPasses |= 1;\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            currentPasses |= 2;\r\n            this._endMainRenderPass();\r\n        }\r\n\r\n        this._commandBuffers[0] = this._uploadEncoder.finish();\r\n        this._commandBuffers[1] = this._renderTargetEncoder.finish();\r\n        this._commandBuffers[2] = this._renderEncoder.finish();\r\n\r\n        this._device.queue.submit(this._commandBuffers);\r\n\r\n        this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n        this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n        this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n        this._timestampQuery.startFrame(this._uploadEncoder);\r\n\r\n        this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n        this._bundleList.reset();\r\n        this._bundleListRenderTarget.reset();\r\n\r\n        // restart the render pass\r\n        if (reopenPass) {\r\n            if (currentPasses & 2) {\r\n                this._startMainRenderPass(false);\r\n            }\r\n            if (currentPasses & 1) {\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, false, null, false, false);\r\n            }\r\n            if (currentRenderPassIsNULL && this._currentRenderTarget) {\r\n                this._currentRenderPass = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render Pass\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _startRenderTargetRenderPass(\r\n        renderTargetWrapper: RenderTargetWrapper,\r\n        setClearStates: boolean,\r\n        clearColor: Nullable<IColor4Like>,\r\n        clearDepth: boolean,\r\n        clearStencil: boolean\r\n    ) {\r\n        const rtWrapper = renderTargetWrapper as WebGPURenderTargetWrapper;\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n        const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource as Nullable<GPUTexture>;\r\n        const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.msaaTexture;\r\n\r\n        const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n\r\n        const colorAttachments: GPURenderPassColorAttachment[] = [];\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        if (rtWrapper._attachments && rtWrapper.isMulti) {\r\n            // multi render targets\r\n            if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\r\n                this._mrtAttachments = rtWrapper._defaultAttachments;\r\n            }\r\n            for (let i = 0; i < this._mrtAttachments.length; ++i) {\r\n                const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\r\n                const mrtTexture = rtWrapper.textures![i];\r\n                const gpuMRTWrapper = mrtTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n                const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\r\n                if (gpuMRTWrapper && gpuMRTTexture) {\r\n                    const viewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        format: gpuMRTWrapper.format,\r\n                    };\r\n                    const gpuMSAATexture = gpuMRTWrapper.msaaTexture;\r\n                    const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\r\n                    const colorMSAATextureView = gpuMSAATexture?.createView(viewDescriptor);\r\n\r\n                    colorAttachments.push({\r\n                        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                        resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                        clearValue: index !== 0 && mustClearColor ? clearColor : undefined,\r\n                        loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    });\r\n                }\r\n            }\r\n            this._cacheRenderPipeline.setMRT(rtWrapper.textures!, this._mrtAttachments.length);\r\n            this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        } else {\r\n            // single render target\r\n            const internalTexture = rtWrapper.texture!;\r\n            const gpuWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n            const gpuTexture = gpuWrapper.underlyingResource!;\r\n\r\n            const gpuMSAATexture = gpuWrapper.msaaTexture;\r\n            const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n            const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n\r\n            colorAttachments.push({\r\n                view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                clearValue: mustClearColor ? clearColor : undefined,\r\n                loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                storeOp: WebGPUConstants.StoreOp.Store,\r\n            });\r\n        }\r\n\r\n        this._debugPushGroup?.(\"render target pass\", 1);\r\n\r\n        this._rttRenderPassWrapper.renderPassDescriptor = {\r\n            colorAttachments,\r\n            depthStencilAttachment:\r\n                depthStencilTexture && gpuDepthStencilTexture\r\n                    ? {\r\n                          view: depthMSAATextureView ? depthMSAATextureView : depthTextureView!,\r\n                          depthClearValue: mustClearDepth ? (this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue) : undefined,\r\n                          depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n                          stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\r\n                          stencilLoadOp: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          stencilStoreOp: WebGPUConstants.StoreOp.Store,\r\n                      }\r\n                    : undefined,\r\n            occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined,\r\n        };\r\n        this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                const internalTexture = rtWrapper.texture!;\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - render target begin pass - internalTexture.uniqueId=\",\r\n                    internalTexture.uniqueId,\r\n                    \"width=\",\r\n                    internalTexture.width,\r\n                    \"height=\",\r\n                    internalTexture.height,\r\n                    this._rttRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(1);\r\n        this._resetCurrentScissor(1);\r\n        this._resetCurrentStencilRef(1);\r\n        this._resetCurrentColorBlend(1);\r\n\r\n        if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _endRenderTargetRenderPass() {\r\n        if (this._currentRenderPass) {\r\n            const gpuWrapper = this._currentRenderTarget!.texture!._hardwareTexture as WebGPUHardwareTexture;\r\n            if (!this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\r\n                this._bundleListRenderTarget.run(this._currentRenderPass);\r\n                this._bundleListRenderTarget.reset();\r\n            }\r\n            this._currentRenderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - render target end pass - internalTexture.uniqueId=\", this._currentRenderTarget?.texture?.uniqueId);\r\n                }\r\n            }\r\n            this._debugPopGroup?.(1);\r\n            this._resetCurrentViewport(1);\r\n            this._resetCurrentScissor(1);\r\n            this._resetCurrentStencilRef(1);\r\n            this._resetCurrentColorBlend(1);\r\n            this._currentRenderPass = null;\r\n            this._rttRenderPassWrapper.reset();\r\n        }\r\n    }\r\n\r\n    private _getCurrentRenderPass(): GPURenderPassEncoder {\r\n        if (this._currentRenderTarget && !this._currentRenderPass) {\r\n            // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        return this._currentRenderPass!;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getCurrentRenderPassIndex(): number {\r\n        return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n    }\r\n\r\n    private _startMainRenderPass(setClearStates: boolean, clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            this._endMainRenderPass();\r\n        }\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.clearValue = mustClearColor ? clearColor : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthClearValue = mustClearDepth\r\n            ? this.useReverseDepthBuffer\r\n                ? this._clearReverseDepthValue\r\n                : this._clearDepthValue\r\n            : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilLoadOp = mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\r\n\r\n        this._swapChainTexture = this._context.getCurrentTexture();\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures![0].set(this._swapChainTexture);\r\n\r\n        // Resolve in case of MSAA\r\n        if (this._options.antialiasing) {\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.resolveTarget = this._swapChainTexture.createView();\r\n        } else {\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.view = this._swapChainTexture.createView();\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - main begin pass - texture width=\" + (this._mainTextureExtends as any).width,\r\n                    \" height=\" + (this._mainTextureExtends as any).height,\r\n                    this._mainRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"main pass\", 0);\r\n\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor!);\r\n\r\n        this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(0);\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentStencilRef(0);\r\n        this._resetCurrentColorBlend(0);\r\n\r\n        if (!this._isStencilEnable) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    private _endMainRenderPass(): void {\r\n        if (this._mainRenderPassWrapper.renderPass !== null) {\r\n            this._snapshotRendering.endMainRenderPass();\r\n            if (!this.compatibilityMode && !this._snapshotRendering.play) {\r\n                this._bundleList.run(this._mainRenderPassWrapper.renderPass);\r\n                this._bundleList.reset();\r\n            }\r\n            this._mainRenderPassWrapper.renderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - main end pass\");\r\n                }\r\n            }\r\n            this._debugPopGroup?.(0);\r\n            this._resetCurrentViewport(0);\r\n            this._resetCurrentScissor(0);\r\n            this._resetCurrentStencilRef(0);\r\n            this._resetCurrentColorBlend(0);\r\n            if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\r\n                this._currentRenderPass = null;\r\n            }\r\n            this._mainRenderPassWrapper.reset(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const hardwareTexture = texture.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!hardwareTexture) {\r\n            if (this.dbgSanityChecks) {\r\n                console.error(\"bindFramebuffer: Trying to bind a texture that does not have a hardware texture!\", texture, hardwareTexture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = texture;\r\n        hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\r\n        this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture\r\n            ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format)\r\n            : undefined;\r\n\r\n        this._setDepthTextureFormat(this._rttRenderPassWrapper);\r\n        this._setColorFormat(this._rttRenderPassWrapper);\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\r\n            format: this._colorFormat,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: lodLevel,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\r\n            format: this._depthTextureFormat!,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - bindFramebuffer called - internalTexture.uniqueId=\",\r\n                    texture.texture?.uniqueId,\r\n                    \"face=\",\r\n                    faceIndex,\r\n                    \"lodLevel=\",\r\n                    lodLevel,\r\n                    \"layer=\",\r\n                    layer,\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\r\n                    this._rttRenderPassWrapper.depthAttachmentViewDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\r\n\r\n        if (this.snapshotRendering && this.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\r\n            this._getCurrentRenderPass();\r\n        }\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = texture.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = texture.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the WebGPU context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const saveCRT = this._currentRenderTarget;\r\n\r\n        this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._currentRenderTarget = saveCRT;\r\n\r\n        if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n\r\n        if (texture.texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture.texture);\r\n        }\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", texture.texture?.uniqueId);\r\n            }\r\n        }\r\n\r\n        this._mrtAttachments = [];\r\n        this._cacheRenderPipeline.setMRT([]);\r\n        this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n            this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n            this._setColorFormat(this._mainRenderPassWrapper);\r\n        }\r\n        if (this._currentRenderPass) {\r\n            if (this._cachedViewport) {\r\n                this.setViewport(this._cachedViewport);\r\n            }\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @param wrapper\r\n     * @hidden\r\n     */\r\n    public _setColorFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        const format = wrapper.colorAttachmentGPUTextures[0].format;\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n        if (this._colorFormat === format) {\r\n            return;\r\n        }\r\n        this._colorFormat = format;\r\n    }\r\n\r\n    /**\r\n     * @param wrapper\r\n     * @hidden\r\n     */\r\n    public _setDepthTextureFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\r\n        if (this._depthTextureFormat === wrapper.depthTextureFormat) {\r\n            return;\r\n        }\r\n        this._depthTextureFormat = wrapper.depthTextureFormat;\r\n    }\r\n\r\n    public setDitheringState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    public setRasterizerState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 2;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? (this._currentRenderTarget ? 1 : 2) : this._currentRenderTarget ? 2 : 1;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    private _applyRenderPassChanges(renderPass: GPURenderPassEncoder, bundleList: Nullable<WebGPUBundleList>): void {\r\n        const mustUpdateViewport = this._mustUpdateViewport(renderPass);\r\n        const mustUpdateScissor = this._mustUpdateScissor(renderPass);\r\n        const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\r\n        const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\r\n\r\n        if (bundleList) {\r\n            if (mustUpdateViewport) {\r\n                bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\r\n            }\r\n            if (mustUpdateScissor) {\r\n                bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\r\n            }\r\n        } else {\r\n            if (mustUpdateViewport) {\r\n                this._applyViewport(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateScissor) {\r\n                this._applyScissor(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                this._applyStencilRef(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                this._applyBlendColor(renderPass as GPURenderPassEncoder);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _draw(drawType: number, fillMode: number, start: number, count: number, instancesCount: number): void {\r\n        const renderPass = this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this.applyStates();\r\n\r\n        const webgpuPipelineContext = this._currentEffect!._pipelineContext as WebGPUPipelineContext;\r\n\r\n        this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\r\n\r\n        if (webgpuPipelineContext.uniformBuffer) {\r\n            webgpuPipelineContext.uniformBuffer.update();\r\n            this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer()!, 0, WebGPUShaderProcessor.LeftOvertUBOName);\r\n        }\r\n\r\n        if (this._snapshotRendering.play) {\r\n            this._reportDrawCall();\r\n            return;\r\n        }\r\n\r\n        if (\r\n            !this.compatibilityMode &&\r\n            (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)\r\n        ) {\r\n            this._currentDrawContext.fastBundle = undefined;\r\n        }\r\n\r\n        const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder = renderPass;\r\n\r\n        if (useFastPath || this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, bundleList);\r\n            if (!this._snapshotRendering.record) {\r\n                this._counters.numBundleReuseNonCompatMode++;\r\n                if (this._currentDrawContext.indirectDrawBuffer) {\r\n                    this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n                }\r\n                bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n                this._reportDrawCall();\r\n                return;\r\n            }\r\n\r\n            renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\r\n            bundleList.numDrawCalls++;\r\n        }\r\n\r\n        let textureState = 0;\r\n        if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\r\n            let bitVal = 1;\r\n            for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\r\n                const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\r\n                const texture = this._currentMaterialContext.textures[textureName]?.texture;\r\n                if (texture?.type === Constants.TEXTURETYPE_FLOAT) {\r\n                    textureState |= bitVal;\r\n                }\r\n                bitVal = bitVal << 1;\r\n            }\r\n        }\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect!, this.currentSampleCount, textureState);\r\n        const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\r\n\r\n        if (!this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\r\n            if (!this.compatibilityMode) {\r\n                this._counters.numBundleCreationNonCompatMode++;\r\n                renderPass2 = this._device.createRenderBundleEncoder({\r\n                    colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                    depthStencilFormat: this._depthTextureFormat,\r\n                    sampleCount: this.currentSampleCount,\r\n                });\r\n            }\r\n        }\r\n\r\n        // bind pipeline\r\n        renderPass2.setPipeline(pipeline);\r\n\r\n        // bind index/vertex buffers\r\n        if (this._currentIndexBuffer) {\r\n            renderPass2.setIndexBuffer(\r\n                this._currentIndexBuffer.underlyingResource,\r\n                this._currentIndexBuffer!.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16,\r\n                0\r\n            );\r\n        }\r\n\r\n        const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\r\n        for (let index = 0; index < vertexBuffers.length; index++) {\r\n            const vertexBuffer = vertexBuffers[index];\r\n\r\n            const buffer = vertexBuffer.getBuffer();\r\n            if (buffer) {\r\n                renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\r\n            }\r\n        }\r\n\r\n        // bind bind groups\r\n        for (let i = 0; i < bindGroups.length; i++) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n\r\n        // draw\r\n        const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\r\n\r\n        if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\r\n            this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n            if (drawType === 0) {\r\n                renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            } else {\r\n                renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            }\r\n        } else if (drawType === 0) {\r\n            renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\r\n        } else {\r\n            renderPass2.draw(count, instancesCount || 1, start, 0);\r\n        }\r\n\r\n        if (nonCompatMode) {\r\n            this._currentDrawContext.fastBundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n        }\r\n\r\n        this._reportDrawCall();\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount: number = 1): void {\r\n        this._draw(0, fillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount: number = 1): void {\r\n        this._currentIndexBuffer = null;\r\n        this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._mainTexture?.destroy();\r\n        this._mainTextureLastCopy?.destroy();\r\n        this._depthTexture?.destroy();\r\n        super.dispose();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Misc\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._canvas.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._canvas.height;\r\n    }\r\n\r\n    /**\r\n     * Gets the HTML canvas attached with the current WebGPU context\r\n     * @returns a HTML canvas\r\n     */\r\n    public getRenderingCanvas(): Nullable<HTMLCanvasElement> {\r\n        return this._canvas;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Errors\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get the current error code of the WebGPU context\r\n     * @returns the error code\r\n     */\r\n    public getError(): number {\r\n        // TODO WEBGPU. from the webgpu errors.\r\n        return 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Unused WebGPU\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public bindSamplers(): void {}\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _bindTextureDirectly(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns always true - No parallel shader compilation\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param pipelineContext\r\n     * @param action\r\n     * @hidden\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // No parallel shader compilation.\r\n        // No Async, so direct launch\r\n        action();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _isRenderingStateCompiled(): boolean {\r\n        // No parallel shader compilation.\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _unpackFlipY() {}\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _bindUnboundFramebuffer() {\r\n        throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\r\n    }\r\n\r\n    // TODO WEBGPU. All of the below should go once engine split with baseEngine.\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getSamplingParameters(): { min: number; mag: number } {\r\n        throw \"_getSamplingParameters is not available in WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public getUniforms(): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setIntArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setIntArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setIntArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setIntArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setMatrices(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setMatrix3x3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setMatrix2x2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setFloat(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setFloat2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setFloat3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public setFloat4(): boolean {\r\n        return false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}