{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\n/**\n * Class used to help managing file picking and drag-n-drop\n */\n\nvar FilesInput =\n/** @class */\nfunction () {\n  /**\n   * Creates a new FilesInput\n   * @param engine defines the rendering engine\n   * @param scene defines the hosting scene\n   * @param sceneLoadedCallback callback called when scene is loaded\n   * @param progressCallback callback called to track progress\n   * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\n   * @param textureLoadingCallback callback called when a texture is loading\n   * @param startingProcessingFilesCallback callback called when the system is about to process all files\n   * @param onReloadCallback callback called when a reload is requested\n   * @param errorCallback callback call if an error occurs\n   */\n  function FilesInput(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {\n    var _this = this;\n    /**\n     * Callback called when a file is processed\n     */\n\n\n    this.onProcessFileCallback = function () {\n      return true;\n    };\n    /**\n     * Function used when loading the scene file\n     * @param sceneFile\n     * @param onProgress\n     */\n\n\n    this.loadAsync = function (sceneFile, onProgress) {\n      return SceneLoader.LoadAsync(\"file:\", sceneFile, _this._engine, onProgress);\n    };\n\n    this._engine = engine;\n    this._currentScene = scene;\n    this._sceneLoadedCallback = sceneLoadedCallback;\n    this._progressCallback = progressCallback;\n    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n    this._textureLoadingCallback = textureLoadingCallback;\n    this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n    this._onReloadCallback = onReloadCallback;\n    this._errorCallback = errorCallback;\n  }\n\n  Object.defineProperty(FilesInput, \"FilesToLoad\", {\n    /**\n     * List of files ready to be loaded\n     */\n    get: function get() {\n      return FilesInputStore.FilesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Calls this function to listen to drag'n'drop events on a specific DOM element\n   * @param elementToMonitor defines the DOM element to track\n   */\n\n  FilesInput.prototype.monitorElementForDragNDrop = function (elementToMonitor) {\n    var _this = this;\n\n    if (elementToMonitor) {\n      this._elementToMonitor = elementToMonitor;\n\n      this._dragEnterHandler = function (e) {\n        _this._drag(e);\n      };\n\n      this._dragOverHandler = function (e) {\n        _this._drag(e);\n      };\n\n      this._dropHandler = function (e) {\n        _this._drop(e);\n      };\n\n      this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n\n      this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n\n      this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n    }\n  };\n\n  Object.defineProperty(FilesInput.prototype, \"filesToLoad\", {\n    /** Gets the current list of files to load */\n    get: function get() {\n      return this._filesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Release all associated resources\n   */\n\n  FilesInput.prototype.dispose = function () {\n    if (!this._elementToMonitor) {\n      return;\n    }\n\n    this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n\n    this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n\n    this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n  };\n\n  FilesInput.prototype._renderFunction = function () {\n    if (this._additionalRenderLoopLogicCallback) {\n      this._additionalRenderLoopLogicCallback();\n    }\n\n    if (this._currentScene) {\n      if (this._textureLoadingCallback) {\n        var remaining = this._currentScene.getWaitingItemsCount();\n\n        if (remaining > 0) {\n          this._textureLoadingCallback(remaining);\n        }\n      }\n\n      this._currentScene.render();\n    }\n  };\n\n  FilesInput.prototype._drag = function (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  FilesInput.prototype._drop = function (eventDrop) {\n    eventDrop.stopPropagation();\n    eventDrop.preventDefault();\n    this.loadFiles(eventDrop);\n  };\n\n  FilesInput.prototype._traverseFolder = function (folder, files, remaining, callback) {\n    var _this = this;\n\n    var reader = folder.createReader();\n    var relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n    reader.readEntries(function (entries) {\n      remaining.count += entries.length;\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n\n        if (entry.isFile) {\n          entry.file(function (file) {\n            file.correctName = relativePath + file.name;\n            files.push(file);\n\n            if (--remaining.count === 0) {\n              callback();\n            }\n          });\n        } else if (entry.isDirectory) {\n          _this._traverseFolder(entry, files, remaining, callback);\n        }\n      }\n\n      if (--remaining.count === 0) {\n        callback();\n      }\n    });\n  };\n\n  FilesInput.prototype._processFiles = function (files) {\n    var _this = this;\n\n    for (var i = 0; i < files.length; i++) {\n      var name_1 = files[i].correctName.toLowerCase();\n      var extension = name_1.split(\".\").pop();\n\n      if (!this.onProcessFileCallback(files[i], name_1, extension, function (sceneFile) {\n        return _this._sceneFileToLoad = sceneFile;\n      })) {\n        continue;\n      }\n\n      if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n        this._sceneFileToLoad = files[i];\n      }\n\n      FilesInput.FilesToLoad[name_1] = files[i];\n    }\n  };\n  /**\n   * Load files from a drop event\n   * @param event defines the drop event to use as source\n   */\n\n\n  FilesInput.prototype.loadFiles = function (event) {\n    var _this = this; // Handling data transfer via drag'n'drop\n\n\n    if (event && event.dataTransfer && event.dataTransfer.files) {\n      this._filesToLoad = event.dataTransfer.files;\n    } // Handling files from input files\n\n\n    if (event && event.target && event.target.files) {\n      this._filesToLoad = event.target.files;\n    }\n\n    if (!this._filesToLoad || this._filesToLoad.length === 0) {\n      return;\n    }\n\n    if (this._startingProcessingFilesCallback) {\n      this._startingProcessingFilesCallback(this._filesToLoad);\n    }\n\n    if (this._filesToLoad && this._filesToLoad.length > 0) {\n      var files_1 = new Array();\n      var folders = [];\n      var items = event.dataTransfer ? event.dataTransfer.items : null;\n\n      for (var i = 0; i < this._filesToLoad.length; i++) {\n        var fileToLoad = this._filesToLoad[i];\n        var name_2 = fileToLoad.name.toLowerCase();\n        var entry = void 0;\n        fileToLoad.correctName = name_2;\n\n        if (items) {\n          var item = items[i];\n\n          if (item.getAsEntry) {\n            entry = item.getAsEntry();\n          } else if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n          }\n        }\n\n        if (!entry) {\n          files_1.push(fileToLoad);\n        } else {\n          if (entry.isDirectory) {\n            folders.push(entry);\n          } else {\n            files_1.push(fileToLoad);\n          }\n        }\n      }\n\n      if (folders.length === 0) {\n        this._processFiles(files_1);\n\n        this._processReload();\n      } else {\n        var remaining_1 = {\n          count: folders.length\n        };\n\n        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {\n          var folder = folders_1[_i];\n\n          this._traverseFolder(folder, files_1, remaining_1, function () {\n            _this._processFiles(files_1);\n\n            if (remaining_1.count === 0) {\n              _this._processReload();\n            }\n          });\n        }\n      }\n    }\n  };\n\n  FilesInput.prototype._processReload = function () {\n    if (this._onReloadCallback) {\n      this._onReloadCallback(this._sceneFileToLoad);\n    } else {\n      this.reload();\n    }\n  };\n  /**\n   * Reload the current scene from the loaded files\n   */\n\n\n  FilesInput.prototype.reload = function () {\n    var _this = this; // If a scene file has been provided\n\n\n    if (this._sceneFileToLoad) {\n      if (this._currentScene) {\n        if (Logger.errorsCount > 0) {\n          Logger.ClearLogCache();\n        }\n\n        this._engine.stopRenderLoop();\n      }\n\n      SceneLoader.ShowLoadingScreen = false;\n\n      this._engine.displayLoadingUI();\n\n      this.loadAsync(this._sceneFileToLoad, this._progressCallback).then(function (scene) {\n        if (_this._currentScene) {\n          _this._currentScene.dispose();\n        }\n\n        _this._currentScene = scene;\n\n        if (_this._sceneLoadedCallback) {\n          _this._sceneLoadedCallback(_this._sceneFileToLoad, _this._currentScene);\n        } // Wait for textures and shaders to be ready\n\n\n        _this._currentScene.executeWhenReady(function () {\n          _this._engine.hideLoadingUI();\n\n          _this._engine.runRenderLoop(function () {\n            _this._renderFunction();\n          });\n        });\n      })[\"catch\"](function (error) {\n        _this._engine.hideLoadingUI();\n\n        if (_this._errorCallback) {\n          _this._errorCallback(_this._sceneFileToLoad, _this._currentScene, error.message);\n        }\n      });\n    } else {\n      Logger.Error(\"Please provide a valid .babylon file.\");\n    }\n  };\n\n  return FilesInput;\n}();\n\nexport { FilesInput };","map":{"version":3,"mappings":"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","names":["SceneLoader","Logger","FilesInputStore","engine","scene","sceneLoadedCallback","progressCallback","additionalRenderLoopLogicCallback","textureLoadingCallback","startingProcessingFilesCallback","onReloadCallback","errorCallback","sceneFile","onProgress","LoadAsync","_this","_engine","_currentScene","_sceneLoadedCallback","_progressCallback","_additionalRenderLoopLogicCallback","_textureLoadingCallback","_startingProcessingFilesCallback","_onReloadCallback","_errorCallback","Object","FilesInput","FilesToLoad","elementToMonitor","_elementToMonitor","_dragEnterHandler","e","_drag","_dragOverHandler","_dropHandler","_drop","addEventListener","_filesToLoad","removeEventListener","remaining","getWaitingItemsCount","render","stopPropagation","preventDefault","eventDrop","loadFiles","folder","files","callback","reader","createReader","relativePath","fullPath","replace","readEntries","entries","count","length","_i","entry","isFile","file","correctName","name","push","isDirectory","_traverseFolder","i","name_1","toLowerCase","extension","split","pop","onProcessFileCallback","_sceneFileToLoad","IsPluginForExtensionAvailable","event","dataTransfer","target","files_1","Array","folders","items","fileToLoad","name_2","item","getAsEntry","webkitGetAsEntry","_processFiles","_processReload","remaining_1","reload","errorsCount","ClearLogCache","stopRenderLoop","ShowLoadingScreen","displayLoadingUI","loadAsync","then","dispose","executeWhenReady","hideLoadingUI","runRenderLoop","_renderFunction","error","message","Error"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/filesInput.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISceneLoaderProgressEvent } from \"../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../Loading/sceneLoader\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Class used to help managing file picking and drag-n-drop\r\n */\r\nexport class FilesInput {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static get FilesToLoad() {\r\n        return FilesInputStore.FilesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Callback called when a file is processed\r\n     */\r\n    public onProcessFileCallback: (file: File, name: string, extension: string, setSceneFileToLoad: (sceneFile: File) => void) => boolean = () => {\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Function used when loading the scene file\r\n     * @param sceneFile\r\n     * @param onProgress\r\n     */\r\n    public loadAsync: (sceneFile: File, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void>) => Promise<Scene> = (sceneFile, onProgress) =>\r\n        SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\r\n\r\n    private _engine: Engine;\r\n    private _currentScene: Nullable<Scene>;\r\n    private _sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>;\r\n    private _progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>;\r\n    private _additionalRenderLoopLogicCallback: Nullable<() => void>;\r\n    private _textureLoadingCallback: Nullable<(remaining: number) => void>;\r\n    private _startingProcessingFilesCallback: Nullable<(files?: File[]) => void>;\r\n    private _onReloadCallback: Nullable<(sceneFile: File) => void>;\r\n    private _errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>;\r\n    private _elementToMonitor: HTMLElement;\r\n\r\n    private _sceneFileToLoad: File;\r\n    private _filesToLoad: File[];\r\n\r\n    /**\r\n     * Creates a new FilesInput\r\n     * @param engine defines the rendering engine\r\n     * @param scene defines the hosting scene\r\n     * @param sceneLoadedCallback callback called when scene is loaded\r\n     * @param progressCallback callback called to track progress\r\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n     * @param textureLoadingCallback callback called when a texture is loading\r\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n     * @param onReloadCallback callback called when a reload is requested\r\n     * @param errorCallback callback call if an error occurs\r\n     */\r\n    constructor(\r\n        engine: Engine,\r\n        scene: Nullable<Scene>,\r\n        sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>,\r\n        progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>,\r\n        additionalRenderLoopLogicCallback: Nullable<() => void>,\r\n        textureLoadingCallback: Nullable<(remaining: number) => void>,\r\n        startingProcessingFilesCallback: Nullable<(files?: File[]) => void>,\r\n        onReloadCallback: Nullable<(sceneFile: File) => void>,\r\n        errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>\r\n    ) {\r\n        this._engine = engine;\r\n        this._currentScene = scene;\r\n\r\n        this._sceneLoadedCallback = sceneLoadedCallback;\r\n        this._progressCallback = progressCallback;\r\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\r\n        this._textureLoadingCallback = textureLoadingCallback;\r\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\r\n        this._onReloadCallback = onReloadCallback;\r\n        this._errorCallback = errorCallback;\r\n    }\r\n\r\n    private _dragEnterHandler: (e: any) => void;\r\n    private _dragOverHandler: (e: any) => void;\r\n    private _dropHandler: (e: any) => void;\r\n\r\n    /**\r\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n     * @param elementToMonitor defines the DOM element to track\r\n     */\r\n    public monitorElementForDragNDrop(elementToMonitor: HTMLElement): void {\r\n        if (elementToMonitor) {\r\n            this._elementToMonitor = elementToMonitor;\r\n\r\n            this._dragEnterHandler = (e) => {\r\n                this._drag(e);\r\n            };\r\n            this._dragOverHandler = (e) => {\r\n                this._drag(e);\r\n            };\r\n            this._dropHandler = (e) => {\r\n                this._drop(e);\r\n            };\r\n\r\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\r\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\r\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\r\n        }\r\n    }\r\n\r\n    /** Gets the current list of files to load */\r\n    public get filesToLoad() {\r\n        return this._filesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose() {\r\n        if (!this._elementToMonitor) {\r\n            return;\r\n        }\r\n\r\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\r\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\r\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\r\n    }\r\n\r\n    private _renderFunction(): void {\r\n        if (this._additionalRenderLoopLogicCallback) {\r\n            this._additionalRenderLoopLogicCallback();\r\n        }\r\n\r\n        if (this._currentScene) {\r\n            if (this._textureLoadingCallback) {\r\n                const remaining = this._currentScene.getWaitingItemsCount();\r\n\r\n                if (remaining > 0) {\r\n                    this._textureLoadingCallback(remaining);\r\n                }\r\n            }\r\n            this._currentScene.render();\r\n        }\r\n    }\r\n\r\n    private _drag(e: DragEvent): void {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private _drop(eventDrop: DragEvent): void {\r\n        eventDrop.stopPropagation();\r\n        eventDrop.preventDefault();\r\n\r\n        this.loadFiles(eventDrop);\r\n    }\r\n\r\n    private _traverseFolder(folder: any, files: Array<any>, remaining: { count: number }, callback: () => void) {\r\n        const reader = folder.createReader();\r\n        const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\r\n        reader.readEntries((entries: any) => {\r\n            remaining.count += entries.length;\r\n            for (const entry of entries) {\r\n                if (entry.isFile) {\r\n                    entry.file((file: any) => {\r\n                        file.correctName = relativePath + file.name;\r\n                        files.push(file);\r\n\r\n                        if (--remaining.count === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else if (entry.isDirectory) {\r\n                    this._traverseFolder(entry, files, remaining, callback);\r\n                }\r\n            }\r\n\r\n            if (--remaining.count === 0) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    private _processFiles(files: Array<any>): void {\r\n        for (let i = 0; i < files.length; i++) {\r\n            const name = files[i].correctName.toLowerCase();\r\n            const extension = name.split(\".\").pop();\r\n\r\n            if (!this.onProcessFileCallback(files[i], name, extension, (sceneFile) => (this._sceneFileToLoad = sceneFile))) {\r\n                continue;\r\n            }\r\n\r\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\r\n                this._sceneFileToLoad = files[i];\r\n            }\r\n\r\n            FilesInput.FilesToLoad[name] = files[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load files from a drop event\r\n     * @param event defines the drop event to use as source\r\n     */\r\n    public loadFiles(event: any): void {\r\n        // Handling data transfer via drag'n'drop\r\n        if (event && event.dataTransfer && event.dataTransfer.files) {\r\n            this._filesToLoad = event.dataTransfer.files;\r\n        }\r\n\r\n        // Handling files from input files\r\n        if (event && event.target && event.target.files) {\r\n            this._filesToLoad = event.target.files;\r\n        }\r\n\r\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._startingProcessingFilesCallback) {\r\n            this._startingProcessingFilesCallback(this._filesToLoad);\r\n        }\r\n\r\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\r\n            const files = new Array<File>();\r\n            const folders = [];\r\n            const items = event.dataTransfer ? event.dataTransfer.items : null;\r\n\r\n            for (let i = 0; i < this._filesToLoad.length; i++) {\r\n                const fileToLoad: any = this._filesToLoad[i];\r\n                const name = fileToLoad.name.toLowerCase();\r\n                let entry;\r\n\r\n                fileToLoad.correctName = name;\r\n\r\n                if (items) {\r\n                    const item = items[i];\r\n                    if (item.getAsEntry) {\r\n                        entry = item.getAsEntry();\r\n                    } else if (item.webkitGetAsEntry) {\r\n                        entry = item.webkitGetAsEntry();\r\n                    }\r\n                }\r\n\r\n                if (!entry) {\r\n                    files.push(fileToLoad);\r\n                } else {\r\n                    if (entry.isDirectory) {\r\n                        folders.push(entry);\r\n                    } else {\r\n                        files.push(fileToLoad);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (folders.length === 0) {\r\n                this._processFiles(files);\r\n                this._processReload();\r\n            } else {\r\n                const remaining = { count: folders.length };\r\n                for (const folder of folders) {\r\n                    this._traverseFolder(folder, files, remaining, () => {\r\n                        this._processFiles(files);\r\n\r\n                        if (remaining.count === 0) {\r\n                            this._processReload();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _processReload() {\r\n        if (this._onReloadCallback) {\r\n            this._onReloadCallback(this._sceneFileToLoad);\r\n        } else {\r\n            this.reload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reload the current scene from the loaded files\r\n     */\r\n    public reload() {\r\n        // If a scene file has been provided\r\n        if (this._sceneFileToLoad) {\r\n            if (this._currentScene) {\r\n                if (Logger.errorsCount > 0) {\r\n                    Logger.ClearLogCache();\r\n                }\r\n                this._engine.stopRenderLoop();\r\n            }\r\n\r\n            SceneLoader.ShowLoadingScreen = false;\r\n            this._engine.displayLoadingUI();\r\n\r\n            this.loadAsync(this._sceneFileToLoad, this._progressCallback)\r\n                .then((scene) => {\r\n                    if (this._currentScene) {\r\n                        this._currentScene.dispose();\r\n                    }\r\n\r\n                    this._currentScene = scene;\r\n\r\n                    if (this._sceneLoadedCallback) {\r\n                        this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\r\n                    }\r\n\r\n                    // Wait for textures and shaders to be ready\r\n                    this._currentScene.executeWhenReady(() => {\r\n                        this._engine.hideLoadingUI();\r\n                        this._engine.runRenderLoop(() => {\r\n                            this._renderFunction();\r\n                        });\r\n                    });\r\n                })\r\n                .catch((error) => {\r\n                    this._engine.hideLoadingUI();\r\n                    if (this._errorCallback) {\r\n                        this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\r\n                    }\r\n                });\r\n        } else {\r\n            Logger.Error(\"Please provide a valid .babylon file.\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}