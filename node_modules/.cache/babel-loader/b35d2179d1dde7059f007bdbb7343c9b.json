{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { InstancedMesh } from \"../Meshes/instancedMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport \"../Shaders/color.fragment.js\";\nimport \"../Shaders/color.vertex.js\";\n\nMesh._LinesMeshParser = function (parsedMesh, scene) {\n  return LinesMesh.Parse(parsedMesh, scene);\n};\n/**\n * Line mesh\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\n */\n\n\nvar LinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(LinesMesh, _super);\n  /**\n   * Creates a new LinesMesh\n   * @param name defines the name\n   * @param scene defines the hosting scene\n   * @param parent defines the parent mesh if any\n   * @param source defines the optional source LinesMesh used to clone data from\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   * When false, achieved by calling a clone(), also passing False.\n   * This will make creation of children, recursive.\n   * @param useVertexColor defines if this LinesMesh supports vertex color\n   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\n   * @param material material to use to draw the line. If not provided, will create a new one\n   */\n\n\n  function LinesMesh(name, scene, parent, source, doNotCloneChildren,\n  /**\n   * If vertex color should be applied to the mesh\n   */\n  useVertexColor,\n  /**\n   * If vertex alpha should be applied to the mesh\n   */\n  useVertexAlpha, material) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (source === void 0) {\n      source = null;\n    }\n\n    var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\n\n    _this.useVertexColor = useVertexColor;\n    _this.useVertexAlpha = useVertexAlpha;\n    /**\n     * Color of the line (Default: White)\n     */\n\n    _this.color = new Color3(1, 1, 1);\n    /**\n     * Alpha of the line (Default: 1)\n     */\n\n    _this.alpha = 1;\n\n    if (source) {\n      _this.color = source.color.clone();\n      _this.alpha = source.alpha;\n      _this.useVertexColor = source.useVertexColor;\n      _this.useVertexAlpha = source.useVertexAlpha;\n    }\n\n    _this.intersectionThreshold = 0.1;\n    var defines = [];\n    var options = {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\n      needAlphaBlending: true,\n      defines: defines,\n      useClipPlane: null\n    };\n\n    if (useVertexAlpha === false) {\n      options.needAlphaBlending = false;\n    }\n\n    if (!useVertexColor) {\n      options.uniforms.push(\"color\");\n      _this._color4 = new Color4();\n    } else {\n      options.defines.push(\"#define VERTEXCOLOR\");\n      options.attributes.push(VertexBuffer.ColorKind);\n    }\n\n    if (material) {\n      _this.material = material;\n    } else {\n      _this.material = new ShaderMaterial(\"colorShader\", _this.getScene(), \"color\", options, false);\n    }\n\n    return _this;\n  }\n\n  LinesMesh.prototype._isShaderMaterial = function (shader) {\n    return shader.getClassName() === \"ShaderMaterial\";\n  };\n\n  LinesMesh.prototype.isReady = function () {\n    if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\n      return false;\n    }\n\n    return _super.prototype.isReady.call(this);\n  };\n  /**\n   * Returns the string \"LineMesh\"\n   */\n\n\n  LinesMesh.prototype.getClassName = function () {\n    return \"LinesMesh\";\n  };\n\n  Object.defineProperty(LinesMesh.prototype, \"material\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._lineMaterial;\n    },\n\n    /**\n     * @hidden\n     */\n    set: function set(value) {\n      this._lineMaterial = value;\n      this._lineMaterial.fillMode = Material.LineListDrawMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return false;\n    },\n    set: function set(value) {// Just ignore it\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  LinesMesh.prototype._bind = function () {\n    if (!this._geometry) {\n      return this;\n    }\n\n    var colorEffect = this._lineMaterial.getEffect(); // VBOs\n\n\n    var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\n\n    if (!this._userInstancedBuffersStorage) {\n      this._geometry._bind(colorEffect, indexToBind);\n    } else {\n      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n    } // Color\n\n\n    if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\n      var _a = this.color,\n          r = _a.r,\n          g = _a.g,\n          b = _a.b;\n\n      this._color4.set(r, g, b, this.alpha);\n\n      this._lineMaterial.setColor4(\"color\", this._color4);\n    }\n\n    return this;\n  };\n  /**\n   * @param subMesh\n   * @param fillMode\n   * @param instancesCount\n   * @hidden\n   */\n\n\n  LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n\n    var engine = this.getScene().getEngine(); // Draw order\n\n    if (this._unIndexed) {\n      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n    } else {\n      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\n    }\n\n    return this;\n  };\n  /**\n   * Disposes of the line mesh\n   * @param doNotRecurse If children should be disposed\n   */\n\n\n  LinesMesh.prototype.dispose = function (doNotRecurse) {\n    this._lineMaterial.dispose(false, false, true);\n\n    _super.prototype.dispose.call(this, doNotRecurse);\n  };\n  /**\n   * Returns a new LineMesh object cloned from the current one.\n   * @param name\n   * @param newParent\n   * @param doNotCloneChildren\n   */\n\n\n  LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n  };\n  /**\n   * Creates a new InstancedLinesMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/divingDeeper/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedLinesMesh\n   */\n\n\n  LinesMesh.prototype.createInstance = function (name) {\n    var instance = new InstancedLinesMesh(name, this);\n\n    if (this.instancedBuffers) {\n      instance.instancedBuffers = {};\n\n      for (var key in this.instancedBuffers) {\n        instance.instancedBuffers[key] = this.instancedBuffers[key];\n      }\n    }\n\n    return instance;\n  };\n  /**\n   * Serializes this ground mesh\n   * @param serializationObject object to write serialization to\n   */\n\n\n  LinesMesh.prototype.serialize = function (serializationObject) {\n    _super.prototype.serialize.call(this, serializationObject);\n\n    serializationObject.color = this.color.asArray();\n    serializationObject.alpha = this.alpha;\n  };\n  /**\n   * Parses a serialized ground mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the ground mesh in\n   * @returns the created ground mesh\n   */\n\n\n  LinesMesh.Parse = function (parsedMesh, scene) {\n    var result = new LinesMesh(parsedMesh.name, scene);\n    result.color = Color3.FromArray(parsedMesh.color);\n    result.alpha = parsedMesh.alpha;\n    return result;\n  };\n\n  return LinesMesh;\n}(Mesh);\n\nexport { LinesMesh };\n/**\n * Creates an instance based on a source LinesMesh\n */\n\nvar InstancedLinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedLinesMesh, _super);\n\n  function InstancedLinesMesh(name, source) {\n    var _this = _super.call(this, name, source) || this;\n\n    _this.intersectionThreshold = source.intersectionThreshold;\n    return _this;\n  }\n  /**\n   * Returns the string \"InstancedLinesMesh\".\n   */\n\n\n  InstancedLinesMesh.prototype.getClassName = function () {\n    return \"InstancedLinesMesh\";\n  };\n\n  return InstancedLinesMesh;\n}(InstancedMesh);\n\nexport { InstancedLinesMesh };","map":{"version":3,"mappings":"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","names":["Color3","Color4","VertexBuffer","Mesh","InstancedMesh","Material","ShaderMaterial","_LinesMeshParser","parsedMesh","scene","LinesMesh","Parse","__extends","name","parent","source","doNotCloneChildren","useVertexColor","useVertexAlpha","material","_super","_this","color","clone","alpha","intersectionThreshold","defines","options","attributes","PositionKind","uniforms","needAlphaBlending","useClipPlane","push","_color4","ColorKind","getScene","shader","getClassName","_lineMaterial","isReady","_userInstancedBuffersStorage","call","Object","value","fillMode","LineListDrawMode","_geometry","colorEffect","getEffect","indexToBind","isUnIndexed","getIndexBuffer","_bind","vertexBuffers","vertexArrayObjects","_isShaderMaterial","r","g","b","set","setColor4","subMesh","instancesCount","getVertexBuffers","_unIndexed","engine","getEngine","drawArraysType","verticesStart","verticesCount","drawElementsType","indexStart","indexCount","doNotRecurse","dispose","newParent","instance","InstancedLinesMesh","instancedBuffers","key","serializationObject","serialize","asArray","result","FromArray"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/linesMesh.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _bind(): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._lineMaterial.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param fillMode\r\n     * @param instancesCount\r\n     * @hidden\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._lineMaterial.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}