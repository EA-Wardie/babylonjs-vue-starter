{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/backgroundVertexDeclaration.js\";\nimport \"./ShadersInclude/backgroundUboDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nvar name = \"backgroundVertexShader\";\nvar shader = \"precision highp float;\\n#include<__decl__backgroundVertex>\\n#include<helperFunctions>\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<instancesDeclaration>\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=position;\\n#endif\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n} else {\\ngl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\\n}\\n#else\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#endif\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normal);\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\\nvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\\nif (fFovMultiplier<=1.0) {\\nvDirectionW=normalize(segment);\\n} else {\\nvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\\n}\\n#endif\\n#endif\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\\nif (vDiffuseInfos.x==0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\nvColor=color;\\n#endif\\n#if defined(POINTSIZE) && !defined(WEBGPU)\\ngl_PointSize=pointSize;\\n#endif\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\"; // Sideeffect\n\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\n\nexport var backgroundVertexShader = {\n  name: name,\n  shader: shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAT,QAA4B,2BAA5B;AACA,OAAO,iDAAP;AACA,OAAO,8CAAP;AACA,OAAO,qCAAP;AACA,OAAO,sCAAP;AACA,OAAO,qDAAP;AACA,OAAO,0CAAP;AACA,OAAO,gDAAP;AACA,OAAO,0CAAP;AACA,OAAO,gDAAP;AACA,OAAO,2CAAP;AACA,OAAO,qCAAP;AACA,OAAO,iCAAP;AACA,OAAO,0CAAP;AACA,OAAO,qCAAP;AACA,OAAO,+BAAP;AACA,OAAO,mCAAP;AAEA,IAAMC,IAAI,GAAG,wBAAb;AACA,IAAMC,MAAM,GAAG,6uFAAf,C,CA+GA;;AACAF,WAAW,CAACG,YAAZ,CAAyBF,IAAzB,IAAiCC,MAAjC;AACA;;AACA,OAAO,IAAME,sBAAsB,GAAG;AAAEH,MAAI,MAAN;AAAQC,QAAM;AAAd,CAA/B","names":["ShaderStore","name","shader","ShadersStore","backgroundVertexShader"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/background.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundVertexDeclaration\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\n\nconst name = \"backgroundVertexShader\";\nconst shader = `precision highp float;\r#include<__decl__backgroundVertex>\n#include<helperFunctions>\nattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\r#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\r#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nvarying vec2 vDiffuseUV;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\r#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*finalWorld*vec4(position,1.0);\r} else {\rgl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\r}\r#else\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\r#endif\nvec4 worldPos=finalWorld*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\r#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\r#endif\nvNormalW=normalize(normalWorld*normal);\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\r#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\rvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\rif (fFovMultiplier<=1.0) {\rvDirectionW=normalize(segment);\r} else {\rvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\r}\r#endif\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef MAINUV1\nvMainUV1=uv;\r#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\r#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nif (vDiffuseInfos.x==0.)\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\r#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const backgroundVertexShader = { name, shader };\n"]},"metadata":{},"sourceType":"module"}