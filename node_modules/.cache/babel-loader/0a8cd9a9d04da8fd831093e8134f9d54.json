{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { GlowLayer } from \"../../../Layers/glowLayer.js\";\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess.js\";\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess.js\";\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess.js\";\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect.js\";\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\n/**\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\n * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline\n */\n\nvar DefaultRenderingPipeline =\n/** @class */\nfunction (_super) {\n  __extends(DefaultRenderingPipeline, _super);\n  /**\n   * @constructor\n   * @param name - The rendering pipeline name (default: \"\")\n   * @param hdr - If high dynamic range textures should be used (default: true)\n   * @param scene - The scene linked to this pipeline (default: the last created scene)\n   * @param cameras - The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\n   * @param automaticBuild - if false, you will have to manually call prepare() to update the pipeline (default: true)\n   */\n\n\n  function DefaultRenderingPipeline(name, hdr, scene, cameras, automaticBuild) {\n    if (name === void 0) {\n      name = \"\";\n    }\n\n    if (hdr === void 0) {\n      hdr = true;\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (automaticBuild === void 0) {\n      automaticBuild = true;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), name) || this;\n\n    _this._camerasToBeAttached = [];\n    /**\n     * ID of the sharpen post process,\n     */\n\n    _this.SharpenPostProcessId = \"SharpenPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the image processing post process;\n     */\n\n    _this.ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the Fast Approximate Anti-Aliasing post process;\n     */\n\n    _this.FxaaPostProcessId = \"FxaaPostProcessEffect\";\n    /**\n     * ID of the chromatic aberration post process,\n     */\n\n    _this.ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\n    /**\n     * ID of the grain post process\n     */\n\n    _this.GrainPostProcessId = \"GrainPostProcessEffect\";\n    /**\n     * Glow post process which adds a glow to emissive areas of the image\n     */\n\n    _this._glowLayer = null;\n    /**\n     * Animations which can be used to tweak settings over a period of time\n     */\n\n    _this.animations = [];\n    _this._imageProcessingConfigurationObserver = null; // Values\n\n    _this._sharpenEnabled = false;\n    _this._bloomEnabled = false;\n    _this._depthOfFieldEnabled = false;\n    _this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\n    _this._fxaaEnabled = false;\n    _this._imageProcessingEnabled = true;\n    _this._bloomScale = 0.5;\n    _this._chromaticAberrationEnabled = false;\n    _this._grainEnabled = false;\n    _this._buildAllowed = true;\n    /**\n     * This is triggered each time the pipeline has been built.\n     */\n\n    _this.onBuildObservable = new Observable();\n    _this._resizeObserver = null;\n    _this._hardwareScaleLevel = 1.0;\n    _this._bloomKernel = 64;\n    /**\n     * Specifies the weight of the bloom in the final rendering\n     */\n\n    _this._bloomWeight = 0.15;\n    /**\n     * Specifies the luma threshold for the area that will be blurred by the bloom\n     */\n\n    _this._bloomThreshold = 0.9;\n    _this._samples = 1;\n    _this._hasCleared = false;\n    _this._prevPostProcess = null;\n    _this._prevPrevPostProcess = null;\n    _this._depthOfFieldSceneObserver = null;\n    _this._cameras = cameras || scene.cameras;\n    _this._cameras = _this._cameras.slice();\n    _this._camerasToBeAttached = _this._cameras.slice();\n    _this._buildAllowed = automaticBuild; // Initialize\n\n    _this._scene = scene;\n\n    var caps = _this._scene.getEngine().getCaps();\n\n    _this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender); // Misc\n\n    if (_this._hdr) {\n      if (caps.textureHalfFloatRender) {\n        _this._defaultPipelineTextureType = 2;\n      } else if (caps.textureFloatRender) {\n        _this._defaultPipelineTextureType = 1;\n      }\n    } else {\n      _this._defaultPipelineTextureType = 0;\n    } // Attach\n\n\n    scene.postProcessRenderPipelineManager.addPipeline(_this);\n\n    var engine = _this._scene.getEngine(); // Create post processes before hand so they can be modified before enabled.\n    // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\n\n\n    _this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);\n    _this._sharpenEffect = new PostProcessRenderEffect(engine, _this.SharpenPostProcessId, function () {\n      return _this.sharpen;\n    }, true);\n    _this.depthOfField = new DepthOfFieldEffect(_this._scene, null, _this._depthOfFieldBlurLevel, _this._defaultPipelineTextureType, true);\n    _this.bloom = new BloomEffect(_this._scene, _this._bloomScale, _this._bloomWeight, _this.bloomKernel, _this._defaultPipelineTextureType, true);\n    _this.chromaticAberration = new ChromaticAberrationPostProcess(\"ChromaticAberration\", engine.getRenderWidth(), engine.getRenderHeight(), 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);\n    _this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, _this.ChromaticAberrationPostProcessId, function () {\n      return _this.chromaticAberration;\n    }, true);\n    _this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);\n    _this._grainEffect = new PostProcessRenderEffect(engine, _this.GrainPostProcessId, function () {\n      return _this.grain;\n    }, true);\n    _this._resizeObserver = engine.onResizeObservable.add(function () {\n      _this._hardwareScaleLevel = engine.getHardwareScalingLevel();\n      _this.bloomKernel = _this._bloomKernel;\n    });\n    _this._imageProcessingConfigurationObserver = _this._scene.imageProcessingConfiguration.onUpdateParameters.add(function () {\n      _this.bloom._downscale._exposure = _this._scene.imageProcessingConfiguration.exposure;\n\n      if (_this.imageProcessingEnabled !== _this._scene.imageProcessingConfiguration.isEnabled) {\n        _this._imageProcessingEnabled = _this._scene.imageProcessingConfiguration.isEnabled;\n\n        _this._buildPipeline();\n      }\n    });\n\n    _this._buildPipeline();\n\n    return _this;\n  }\n\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"scene\", {\n    /**\n     * Gets active scene\n     */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"sharpenEnabled\", {\n    get: function get() {\n      return this._sharpenEnabled;\n    },\n\n    /**\n     * Enable or disable the sharpen process from the pipeline\n     */\n    set: function set(enabled) {\n      if (this._sharpenEnabled === enabled) {\n        return;\n      }\n\n      this._sharpenEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomKernel\", {\n    /**\n     * Specifies the size of the bloom blur kernel, relative to the final output size\n     */\n    get: function get() {\n      return this._bloomKernel;\n    },\n    set: function set(value) {\n      this._bloomKernel = value;\n      this.bloom.kernel = value / this._hardwareScaleLevel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomWeight\", {\n    get: function get() {\n      return this._bloomWeight;\n    },\n\n    /**\n     * The strength of the bloom.\n     */\n    set: function set(value) {\n      if (this._bloomWeight === value) {\n        return;\n      }\n\n      this.bloom.weight = value;\n      this._bloomWeight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomThreshold\", {\n    get: function get() {\n      return this._bloomThreshold;\n    },\n\n    /**\n     * The strength of the bloom.\n     */\n    set: function set(value) {\n      if (this._bloomThreshold === value) {\n        return;\n      }\n\n      this.bloom.threshold = value;\n      this._bloomThreshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomScale\", {\n    get: function get() {\n      return this._bloomScale;\n    },\n\n    /**\n     * The scale of the bloom, lower value will provide better performance.\n     */\n    set: function set(value) {\n      if (this._bloomScale === value) {\n        return;\n      }\n\n      this._bloomScale = value; // recreate bloom and dispose old as this setting is not dynamic\n\n      this._rebuildBloom();\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomEnabled\", {\n    get: function get() {\n      return this._bloomEnabled;\n    },\n\n    /**\n     * Enable or disable the bloom from the pipeline\n     */\n    set: function set(enabled) {\n      if (this._bloomEnabled === enabled) {\n        return;\n      }\n\n      this._bloomEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DefaultRenderingPipeline.prototype._rebuildBloom = function () {\n    // recreate bloom and dispose old as this setting is not dynamic\n    var oldBloom = this.bloom;\n    this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, false);\n    this.bloom.threshold = oldBloom.threshold;\n\n    for (var i = 0; i < this._cameras.length; i++) {\n      oldBloom.disposeEffects(this._cameras[i]);\n    }\n  };\n\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"depthOfFieldEnabled\", {\n    /**\n     * If the depth of field is enabled.\n     */\n    get: function get() {\n      return this._depthOfFieldEnabled;\n    },\n    set: function set(enabled) {\n      if (this._depthOfFieldEnabled === enabled) {\n        return;\n      }\n\n      this._depthOfFieldEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"depthOfFieldBlurLevel\", {\n    /**\n     * Blur level of the depth of field effect. (Higher blur will effect performance)\n     */\n    get: function get() {\n      return this._depthOfFieldBlurLevel;\n    },\n    set: function set(value) {\n      if (this._depthOfFieldBlurLevel === value) {\n        return;\n      }\n\n      this._depthOfFieldBlurLevel = value; // recreate dof and dispose old as this setting is not dynamic\n\n      var oldDof = this.depthOfField;\n      this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\n      this.depthOfField.focalLength = oldDof.focalLength;\n      this.depthOfField.focusDistance = oldDof.focusDistance;\n      this.depthOfField.fStop = oldDof.fStop;\n      this.depthOfField.lensSize = oldDof.lensSize;\n\n      for (var i = 0; i < this._cameras.length; i++) {\n        oldDof.disposeEffects(this._cameras[i]);\n      }\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"fxaaEnabled\", {\n    get: function get() {\n      return this._fxaaEnabled;\n    },\n\n    /**\n     * If the anti aliasing is enabled.\n     */\n    set: function set(enabled) {\n      if (this._fxaaEnabled === enabled) {\n        return;\n      }\n\n      this._fxaaEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"samples\", {\n    get: function get() {\n      return this._samples;\n    },\n\n    /**\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n     */\n    set: function set(sampleCount) {\n      if (this._samples === sampleCount) {\n        return;\n      }\n\n      this._samples = sampleCount;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", {\n    get: function get() {\n      return this._imageProcessingEnabled;\n    },\n\n    /**\n     * If image processing is enabled.\n     */\n    set: function set(enabled) {\n      if (this._imageProcessingEnabled === enabled) {\n        return;\n      }\n\n      this._scene.imageProcessingConfiguration.isEnabled = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"glowLayerEnabled\", {\n    get: function get() {\n      return this._glowLayer != null;\n    },\n\n    /**\n     * If glow layer is enabled. (Adds a glow effect to emmissive materials)\n     */\n    set: function set(enabled) {\n      if (enabled && !this._glowLayer) {\n        this._glowLayer = new GlowLayer(\"\", this._scene);\n      } else if (!enabled && this._glowLayer) {\n        this._glowLayer.dispose();\n\n        this._glowLayer = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"glowLayer\", {\n    /**\n     * Gets the glow layer (or null if not defined)\n     */\n    get: function get() {\n      return this._glowLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"chromaticAberrationEnabled\", {\n    get: function get() {\n      return this._chromaticAberrationEnabled;\n    },\n\n    /**\n     * Enable or disable the chromaticAberration process from the pipeline\n     */\n    set: function set(enabled) {\n      if (this._chromaticAberrationEnabled === enabled) {\n        return;\n      }\n\n      this._chromaticAberrationEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DefaultRenderingPipeline.prototype, \"grainEnabled\", {\n    get: function get() {\n      return this._grainEnabled;\n    },\n\n    /**\n     * Enable or disable the grain process from the pipeline\n     */\n    set: function set(enabled) {\n      if (this._grainEnabled === enabled) {\n        return;\n      }\n\n      this._grainEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the class name\n   * @returns \"DefaultRenderingPipeline\"\n   */\n\n  DefaultRenderingPipeline.prototype.getClassName = function () {\n    return \"DefaultRenderingPipeline\";\n  };\n  /**\n   * Force the compilation of the entire pipeline.\n   */\n\n\n  DefaultRenderingPipeline.prototype.prepare = function () {\n    var previousState = this._buildAllowed;\n    this._buildAllowed = true;\n\n    this._buildPipeline();\n\n    this._buildAllowed = previousState;\n  };\n\n  DefaultRenderingPipeline.prototype._setAutoClearAndTextureSharing = function (postProcess, skipTextureSharing) {\n    if (skipTextureSharing === void 0) {\n      skipTextureSharing = false;\n    }\n\n    if (this._hasCleared) {\n      postProcess.autoClear = false;\n    } else {\n      postProcess.autoClear = true;\n      this._scene.autoClear = false;\n      this._hasCleared = true;\n    }\n\n    if (!skipTextureSharing) {\n      if (this._prevPrevPostProcess) {\n        postProcess.shareOutputWith(this._prevPrevPostProcess);\n      } else {\n        postProcess.useOwnOutput();\n      }\n\n      if (this._prevPostProcess) {\n        this._prevPrevPostProcess = this._prevPostProcess;\n      }\n\n      this._prevPostProcess = postProcess;\n    }\n  };\n\n  DefaultRenderingPipeline.prototype._buildPipeline = function () {\n    var _this = this;\n\n    if (!this._buildAllowed) {\n      return;\n    }\n\n    this._scene.autoClear = true;\n\n    var engine = this._scene.getEngine();\n\n    this._disposePostProcesses();\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras); // get back cameras to be used to reattach pipeline\n\n\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n\n    this._reset();\n\n    this._prevPostProcess = null;\n    this._prevPrevPostProcess = null;\n    this._hasCleared = false;\n\n    if (this.depthOfFieldEnabled) {\n      // Multi camera suport\n      if (this._cameras.length > 1) {\n        for (var _i = 0, _a = this._cameras; _i < _a.length; _i++) {\n          var camera = _a[_i];\n\n          var depthRenderer = this._scene.enableDepthRenderer(camera);\n\n          depthRenderer.useOnlyInActiveCamera = true;\n        }\n\n        this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(function (scene) {\n          if (_this._cameras.indexOf(scene.activeCamera) > -1) {\n            _this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\n          }\n        });\n      } else {\n        this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n\n        var depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\n\n        this.depthOfField.depthTexture = depthRenderer.getDepthMap();\n      }\n\n      if (!this.depthOfField._isReady()) {\n        this.depthOfField._updateEffects();\n      }\n\n      this.addEffect(this.depthOfField);\n\n      this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\n    } else {\n      this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n    }\n\n    if (this.bloomEnabled) {\n      if (!this.bloom._isReady()) {\n        this.bloom._updateEffects();\n      }\n\n      this.addEffect(this.bloom);\n\n      this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\n    }\n\n    if (this._imageProcessingEnabled) {\n      this.imageProcessing = new ImageProcessingPostProcess(\"imageProcessing\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, this.scene.imageProcessingConfiguration);\n\n      if (this._hdr) {\n        this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, function () {\n          return _this.imageProcessing;\n        }, true));\n\n        this._setAutoClearAndTextureSharing(this.imageProcessing);\n      } else {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n\n      if (!this.cameras || this.cameras.length === 0) {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n\n      if (!this.imageProcessing.getEffect()) {\n        this.imageProcessing._updateParameters();\n      }\n    }\n\n    if (this.sharpenEnabled) {\n      if (!this.sharpen.isReady()) {\n        this.sharpen.updateEffect();\n      }\n\n      this.addEffect(this._sharpenEffect);\n\n      this._setAutoClearAndTextureSharing(this.sharpen);\n    }\n\n    if (this.grainEnabled) {\n      if (!this.grain.isReady()) {\n        this.grain.updateEffect();\n      }\n\n      this.addEffect(this._grainEffect);\n\n      this._setAutoClearAndTextureSharing(this.grain);\n    }\n\n    if (this.chromaticAberrationEnabled) {\n      if (!this.chromaticAberration.isReady()) {\n        this.chromaticAberration.updateEffect();\n      }\n\n      this.addEffect(this._chromaticAberrationEffect);\n\n      this._setAutoClearAndTextureSharing(this.chromaticAberration);\n    }\n\n    if (this.fxaaEnabled) {\n      this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n      this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, function () {\n        return _this.fxaa;\n      }, true));\n\n      this._setAutoClearAndTextureSharing(this.fxaa, true);\n    }\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    } // In multicamera mode, the scene needs to autoclear in between cameras.\n\n\n    if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\n      this._scene.autoClear = true;\n    }\n\n    if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n\n    this.onBuildObservable.notifyObservers(this);\n  };\n\n  DefaultRenderingPipeline.prototype._disposePostProcesses = function (disposeNonRecreated) {\n    if (disposeNonRecreated === void 0) {\n      disposeNonRecreated = false;\n    }\n\n    for (var i = 0; i < this._cameras.length; i++) {\n      var camera = this._cameras[i];\n\n      if (this.imageProcessing) {\n        this.imageProcessing.dispose(camera);\n      }\n\n      if (this.fxaa) {\n        this.fxaa.dispose(camera);\n      } // These are created in the constructor and should not be disposed on every pipeline change\n\n\n      if (disposeNonRecreated) {\n        if (this.sharpen) {\n          this.sharpen.dispose(camera);\n        }\n\n        if (this.depthOfField) {\n          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n\n          this.depthOfField.disposeEffects(camera);\n        }\n\n        if (this.bloom) {\n          this.bloom.disposeEffects(camera);\n        }\n\n        if (this.chromaticAberration) {\n          this.chromaticAberration.dispose(camera);\n        }\n\n        if (this.grain) {\n          this.grain.dispose(camera);\n        }\n\n        if (this._glowLayer) {\n          this._glowLayer.dispose();\n        }\n      }\n    }\n\n    this.imageProcessing = null;\n    this.fxaa = null;\n\n    if (disposeNonRecreated) {\n      this.sharpen = null;\n      this._sharpenEffect = null;\n      this.depthOfField = null;\n      this.bloom = null;\n      this.chromaticAberration = null;\n      this._chromaticAberrationEffect = null;\n      this.grain = null;\n      this._grainEffect = null;\n      this._glowLayer = null;\n    }\n  };\n  /**\n   * Adds a camera to the pipeline\n   * @param camera the camera to be added\n   */\n\n\n  DefaultRenderingPipeline.prototype.addCamera = function (camera) {\n    this._camerasToBeAttached.push(camera);\n\n    this._buildPipeline();\n  };\n  /**\n   * Removes a camera from the pipeline\n   * @param camera the camera to remove\n   */\n\n\n  DefaultRenderingPipeline.prototype.removeCamera = function (camera) {\n    var index = this._camerasToBeAttached.indexOf(camera);\n\n    this._camerasToBeAttached.splice(index, 1);\n\n    this._buildPipeline();\n  };\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n\n\n  DefaultRenderingPipeline.prototype.dispose = function () {\n    this.onBuildObservable.clear();\n\n    this._disposePostProcesses(true);\n\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n\n    this._scene.autoClear = true;\n\n    if (this._resizeObserver) {\n      this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\n\n      this._resizeObserver = null;\n    }\n\n    this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n\n\n  DefaultRenderingPipeline.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"DefaultRenderingPipeline\";\n    return serializationObject;\n  };\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n\n\n  DefaultRenderingPipeline.Parse = function (source, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new DefaultRenderingPipeline(source._name, source._name._hdr, scene);\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"sharpenEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomKernel\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomWeight\", void 0);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomThreshold\", void 0);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"_hdr\", void 0);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomWeight\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomThreshold\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomScale\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldBlurLevel\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"fxaaEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"samples\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"glowLayerEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"chromaticAberrationEnabled\", null);\n\n  __decorate([serialize()], DefaultRenderingPipeline.prototype, \"grainEnabled\", null);\n\n  return DefaultRenderingPipeline;\n}(PostProcessRenderPipeline);\n\nexport { DefaultRenderingPipeline };\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);","map":{"version":3,"mappings":";;;;;AAEA,SAASA,SAAT,EAAoBC,mBAApB,QAA+C,6BAA/C;AAEA,SAASC,UAAT,QAA2B,6BAA3B;AAEA,SAASC,MAAT,QAAuB,yBAAvB;AAGA,SAASC,OAAT,QAAwB,wCAAxB;AAIA,SAASC,SAAT,QAA0B,8BAA1B;AAGA,SAASC,kBAAT,QAAmC,8CAAnC;AACA,SAASC,0BAAT,QAA2C,sDAA3C;AACA,SAASC,8BAAT,QAA+C,0DAA/C;AACA,SAASC,gBAAT,QAAiC,4CAAjC;AACA,SAASC,eAAT,QAAgC,2CAAhC;AACA,SAASC,yBAAT,QAA0C,oEAA1C;AACA,SAASC,uBAAT,QAAwC,kEAAxC;AACA,SAASC,kBAAT,EAA6BC,2BAA7B,QAAgE,8CAAhE;AACA,SAASC,WAAT,QAA4B,uCAA5B;AACA,SAASC,aAAT,QAA8B,4BAA9B;AACA,SAASC,WAAT,QAA4B,iCAA5B;AAEA,OAAO,yFAAP;AAIA;;;;;AAIA;AAAA;AAAA;AAA8CC;AAqX1C;;;;;;;;;;AAQA,oCAAYC,IAAZ,EAA+BC,GAA/B,EAAoDC,KAApD,EAAkGC,OAAlG,EAAsHC,cAAtH,EAA2I;AAA/H;AAAAJ;AAAiB;;AAAE;AAAAC;AAAmB;;AAAE;AAAAC,cAAeJ,WAAW,CAACO,gBAA3B;AAA4C;;AAAsB;AAAAD;AAAqB;;AAA3I,gBACIE,kBAAMJ,KAAK,CAACK,SAAN,EAAN,EAAyBP,IAAzB,KAA8B,IADlC;;AA3XQQ,iCAAsC,EAAtC;AACR;;;;AAGiBA,iCAA+B,0BAA/B;AACjB;;;;;AAISA,yCAAuC,kCAAvC;AACT;;;;;AAISA,8BAA4B,uBAA5B;AACT;;;;AAGiBA,6CAA2C,sCAA3C;AACjB;;;;AAGiBA,+BAA6B,wBAA7B;AA+BjB;;;;AAGQA,uBAAkC,IAAlC;AAER;;;;AAGOA,uBAA0B,EAA1B;AAECA,kDAA0F,IAA1F,CA4TmI,CA3T3I;;AACQA,4BAA2B,KAA3B;AACAA,0BAAyB,KAAzB;AACAA,iCAAgC,KAAhC;AACAA,mCAAyBb,2BAA2B,CAACc,GAArD;AACAD,yBAAwB,KAAxB;AACAA,oCAAmC,IAAnC;AAEAA,wBAAsB,GAAtB;AACAA,wCAAuC,KAAvC;AACAA,0BAAyB,KAAzB;AAEAA,0BAAgB,IAAhB;AAER;;;;AAGOA,8BAAoB,IAAIzB,UAAJ,EAApB;AA0BCyB,4BAA8C,IAA9C;AACAA,gCAAsB,GAAtB;AACAA,yBAAuB,EAAvB;AAaR;;;;AAIQA,yBAAuB,IAAvB;AACR;;;;AAIQA,4BAA0B,GAA1B;AAqJAA,qBAAW,CAAX;AAiNAA,wBAAc,KAAd;AACAA,6BAA0C,IAA1C;AACAA,iCAA8C,IAA9C;AAyBAA,uCAAwD,IAAxD;AAvIJA,SAAI,CAACE,QAAL,GAAgBP,OAAO,IAAID,KAAK,CAACC,OAAjC;AACAK,SAAI,CAACE,QAAL,GAAgBF,KAAI,CAACE,QAAL,CAAcC,KAAd,EAAhB;AACAH,SAAI,CAACI,oBAAL,GAA4BJ,KAAI,CAACE,QAAL,CAAcC,KAAd,EAA5B;AAEAH,SAAI,CAACK,aAAL,GAAqBT,cAArB,CANuI,CAQvI;;AACAI,SAAI,CAACM,MAAL,GAAcZ,KAAd;;AACA,QAAMa,IAAI,GAAGP,KAAI,CAACM,MAAL,CAAYP,SAAZ,GAAwBS,OAAxB,EAAb;;AACAR,SAAI,CAACS,IAAL,GAAYhB,GAAG,KAAKc,IAAI,CAACG,sBAAL,IAA+BH,IAAI,CAACI,kBAAzC,CAAf,CAXuI,CAavI;;AACA,QAAIX,KAAI,CAACS,IAAT,EAAe;AACX,UAAIF,IAAI,CAACG,sBAAT,EAAiC;AAC7BV,aAAI,CAACY,2BAAL,GAAmC,CAAnC;AACH,OAFD,MAEO,IAAIL,IAAI,CAACI,kBAAT,EAA6B;AAChCX,aAAI,CAACY,2BAAL,GAAmC,CAAnC;AACH;AACJ,KAND,MAMO;AACHZ,WAAI,CAACY,2BAAL,GAAmC,CAAnC;AACH,KAtBsI,CAwBvI;;;AACAlB,SAAK,CAACmB,gCAAN,CAAuCC,WAAvC,CAAmDd,KAAnD;;AAEA,QAAMe,MAAM,GAAGf,KAAI,CAACM,MAAL,CAAYP,SAAZ,EAAf,CA3BuI,CA4BvI;AACA;;;AACAC,SAAI,CAACgB,OAAL,GAAe,IAAIrC,kBAAJ,CAAuB,SAAvB,EAAkC,GAAlC,EAAuC,IAAvC,EAA6CF,OAAO,CAACwC,qBAArD,EAA4EF,MAA5E,EAAoF,KAApF,EAA2Ff,KAAI,CAACY,2BAAhG,EAA6H,IAA7H,CAAf;AACAZ,SAAI,CAACkB,cAAL,GAAsB,IAAIjC,uBAAJ,CAClB8B,MADkB,EAElBf,KAAI,CAACmB,oBAFa,EAGlB;AACI,aAAOnB,KAAI,CAACgB,OAAZ;AACH,KALiB,EAMlB,IANkB,CAAtB;AASAhB,SAAI,CAACoB,YAAL,GAAoB,IAAIlC,kBAAJ,CAAuBc,KAAI,CAACM,MAA5B,EAAoC,IAApC,EAA0CN,KAAI,CAACqB,sBAA/C,EAAuErB,KAAI,CAACY,2BAA5E,EAAyG,IAAzG,CAApB;AAEAZ,SAAI,CAACsB,KAAL,GAAa,IAAIlC,WAAJ,CAAgBY,KAAI,CAACM,MAArB,EAA6BN,KAAI,CAACuB,WAAlC,EAA+CvB,KAAI,CAACwB,YAApD,EAAkExB,KAAI,CAACyB,WAAvE,EAAoFzB,KAAI,CAACY,2BAAzF,EAAsH,IAAtH,CAAb;AAEAZ,SAAI,CAAC0B,mBAAL,GAA2B,IAAI7C,8BAAJ,CACvB,qBADuB,EAEvBkC,MAAM,CAACY,cAAP,EAFuB,EAGvBZ,MAAM,CAACa,eAAP,EAHuB,EAIvB,GAJuB,EAKvB,IALuB,EAMvBnD,OAAO,CAACwC,qBANe,EAOvBF,MAPuB,EAQvB,KARuB,EASvBf,KAAI,CAACY,2BATkB,EAUvB,IAVuB,CAA3B;AAYAZ,SAAI,CAAC6B,0BAAL,GAAkC,IAAI5C,uBAAJ,CAC9B8B,MAD8B,EAE9Bf,KAAI,CAAC8B,gCAFyB,EAG9B;AACI,aAAO9B,KAAI,CAAC0B,mBAAZ;AACH,KAL6B,EAM9B,IAN8B,CAAlC;AASA1B,SAAI,CAAC+B,KAAL,GAAa,IAAIjD,gBAAJ,CAAqB,OAArB,EAA8B,GAA9B,EAAmC,IAAnC,EAAyCL,OAAO,CAACwC,qBAAjD,EAAwEF,MAAxE,EAAgF,KAAhF,EAAuFf,KAAI,CAACY,2BAA5F,EAAyH,IAAzH,CAAb;AACAZ,SAAI,CAACgC,YAAL,GAAoB,IAAI/C,uBAAJ,CAChB8B,MADgB,EAEhBf,KAAI,CAACiC,kBAFW,EAGhB;AACI,aAAOjC,KAAI,CAAC+B,KAAZ;AACH,KALe,EAMhB,IANgB,CAApB;AASA/B,SAAI,CAACkC,eAAL,GAAuBnB,MAAM,CAACoB,kBAAP,CAA0BC,GAA1B,CAA8B;AACjDpC,WAAI,CAACqC,mBAAL,GAA2BtB,MAAM,CAACuB,uBAAP,EAA3B;AACAtC,WAAI,CAACyB,WAAL,GAAmBzB,KAAI,CAACuC,YAAxB;AACH,KAHsB,CAAvB;AAKAvC,SAAI,CAACwC,qCAAL,GAA6CxC,KAAI,CAACM,MAAL,CAAYmC,4BAAZ,CAAyCC,kBAAzC,CAA4DN,GAA5D,CAAgE;AACzGpC,WAAI,CAACsB,KAAL,CAAWqB,UAAX,CAAsBC,SAAtB,GAAkC5C,KAAI,CAACM,MAAL,CAAYmC,4BAAZ,CAAyCI,QAA3E;;AAEA,UAAI7C,KAAI,CAAC8C,sBAAL,KAAgC9C,KAAI,CAACM,MAAL,CAAYmC,4BAAZ,CAAyCM,SAA7E,EAAwF;AACpF/C,aAAI,CAACgD,uBAAL,GAA+BhD,KAAI,CAACM,MAAL,CAAYmC,4BAAZ,CAAyCM,SAAxE;;AACA/C,aAAI,CAACiD,cAAL;AACH;AACJ,KAP4C,CAA7C;;AASAjD,SAAI,CAACiD,cAAL;;;AACH;;AA/XDC,wBAAWC,kCAAX,EAAW,OAAX,EAAgB;AAHhB;;;SAGA;AACI,aAAO,KAAK7C,MAAZ;AACH,KAFe;qBAAA;;AAAA,GAAhB;AAOA4C,wBAAWC,kCAAX,EAAW,gBAAX,EAAyB;SAUzB;AACI,aAAO,KAAKC,eAAZ;AACH,KAZwB;;AAHzB;;;SAGA,aAA0BC,OAA1B,EAA0C;AACtC,UAAI,KAAKD,eAAL,KAAyBC,OAA7B,EAAsC;AAClC;AACH;;AACD,WAAKD,eAAL,GAAuBC,OAAvB;;AAEA,WAAKJ,cAAL;AACH,KAPwB;qBAAA;;AAAA,GAAzB;AAqBAC,wBAAWC,kCAAX,EAAW,aAAX,EAAsB;AAJtB;;;SAIA;AACI,aAAO,KAAKZ,YAAZ;AACH,KAFqB;SAGtB,aAAuBe,KAAvB,EAAoC;AAChC,WAAKf,YAAL,GAAoBe,KAApB;AACA,WAAKhC,KAAL,CAAWiC,MAAX,GAAoBD,KAAK,GAAG,KAAKjB,mBAAjC;AACH,KANqB;qBAAA;;AAAA,GAAtB;AAyBAa,wBAAWC,kCAAX,EAAW,aAAX,EAAsB;SAUtB;AACI,aAAO,KAAK3B,YAAZ;AACH,KAZqB;;AAHtB;;;SAGA,aAAuB8B,KAAvB,EAAoC;AAChC,UAAI,KAAK9B,YAAL,KAAsB8B,KAA1B,EAAiC;AAC7B;AACH;;AACD,WAAKhC,KAAL,CAAWkC,MAAX,GAAoBF,KAApB;AAEA,WAAK9B,YAAL,GAAoB8B,KAApB;AACH,KAPqB;qBAAA;;AAAA,GAAtB;AAiBAJ,wBAAWC,kCAAX,EAAW,gBAAX,EAAyB;SASzB;AACI,aAAO,KAAKM,eAAZ;AACH,KAXwB;;AAHzB;;;SAGA,aAA0BH,KAA1B,EAAuC;AACnC,UAAI,KAAKG,eAAL,KAAyBH,KAA7B,EAAoC;AAChC;AACH;;AACD,WAAKhC,KAAL,CAAWoC,SAAX,GAAuBJ,KAAvB;AACA,WAAKG,eAAL,GAAuBH,KAAvB;AACH,KANwB;qBAAA;;AAAA,GAAzB;AAgBAJ,wBAAWC,kCAAX,EAAW,YAAX,EAAqB;SAarB;AACI,aAAO,KAAK5B,WAAZ;AACH,KAfoB;;AAHrB;;;SAGA,aAAsB+B,KAAtB,EAAmC;AAC/B,UAAI,KAAK/B,WAAL,KAAqB+B,KAAzB,EAAgC;AAC5B;AACH;;AACD,WAAK/B,WAAL,GAAmB+B,KAAnB,CAJ+B,CAM/B;;AACA,WAAKK,aAAL;;AAEA,WAAKV,cAAL;AACH,KAVoB;qBAAA;;AAAA,GAArB;AAoBAC,wBAAWC,kCAAX,EAAW,cAAX,EAAuB;SAUvB;AACI,aAAO,KAAKS,aAAZ;AACH,KAZsB;;AAHvB;;;SAGA,aAAwBP,OAAxB,EAAwC;AACpC,UAAI,KAAKO,aAAL,KAAuBP,OAA3B,EAAoC;AAChC;AACH;;AACD,WAAKO,aAAL,GAAqBP,OAArB;;AAEA,WAAKJ,cAAL;AACH,KAPsB;qBAAA;;AAAA,GAAvB;;AAcQE,qDAAR;AACI;AACA,QAAMU,QAAQ,GAAG,KAAKvC,KAAtB;AACA,SAAKA,KAAL,GAAa,IAAIlC,WAAJ,CAAgB,KAAKkB,MAArB,EAA6B,KAAKwD,UAAlC,EAA8C,KAAKtC,YAAnD,EAAiE,KAAKC,WAAtE,EAAmF,KAAKb,2BAAxF,EAAqH,KAArH,CAAb;AACA,SAAKU,KAAL,CAAWoC,SAAX,GAAuBG,QAAQ,CAACH,SAAhC;;AACA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK7D,QAAL,CAAc8D,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3CF,cAAQ,CAACI,cAAT,CAAwB,KAAK/D,QAAL,CAAc6D,CAAd,CAAxB;AACH;AACJ,GARO;;AAcRb,wBAAWC,kCAAX,EAAW,qBAAX,EAA8B;AAJ9B;;;SAIA;AACI,aAAO,KAAKe,oBAAZ;AACH,KAF6B;SAI9B,aAA+Bb,OAA/B,EAA+C;AAC3C,UAAI,KAAKa,oBAAL,KAA8Bb,OAAlC,EAA2C;AACvC;AACH;;AACD,WAAKa,oBAAL,GAA4Bb,OAA5B;;AAEA,WAAKJ,cAAL;AACH,KAX6B;qBAAA;;AAAA,GAA9B;AAiBAC,wBAAWC,kCAAX,EAAW,uBAAX,EAAgC;AAJhC;;;SAIA;AACI,aAAO,KAAK9B,sBAAZ;AACH,KAF+B;SAIhC,aAAiCiC,KAAjC,EAAmE;AAC/D,UAAI,KAAKjC,sBAAL,KAAgCiC,KAApC,EAA2C;AACvC;AACH;;AACD,WAAKjC,sBAAL,GAA8BiC,KAA9B,CAJ+D,CAM/D;;AACA,UAAMa,MAAM,GAAG,KAAK/C,YAApB;AAEA,WAAKA,YAAL,GAAoB,IAAIlC,kBAAJ,CAAuB,KAAKoB,MAA5B,EAAoC,IAApC,EAA0C,KAAKe,sBAA/C,EAAuE,KAAKT,2BAA5E,EAAyG,KAAzG,CAApB;AACA,WAAKQ,YAAL,CAAkBgD,WAAlB,GAAgCD,MAAM,CAACC,WAAvC;AACA,WAAKhD,YAAL,CAAkBiD,aAAlB,GAAkCF,MAAM,CAACE,aAAzC;AACA,WAAKjD,YAAL,CAAkBkD,KAAlB,GAA0BH,MAAM,CAACG,KAAjC;AACA,WAAKlD,YAAL,CAAkBmD,QAAlB,GAA6BJ,MAAM,CAACI,QAApC;;AAEA,WAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK7D,QAAL,CAAc8D,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3CI,cAAM,CAACF,cAAP,CAAsB,KAAK/D,QAAL,CAAc6D,CAAd,CAAtB;AACH;;AAED,WAAKd,cAAL;AACH,KAxB+B;qBAAA;;AAAA,GAAhC;AA6BAC,wBAAWC,kCAAX,EAAW,aAAX,EAAsB;SAUtB;AACI,aAAO,KAAKqB,YAAZ;AACH,KAZqB;;AAHtB;;;SAGA,aAAuBnB,OAAvB,EAAuC;AACnC,UAAI,KAAKmB,YAAL,KAAsBnB,OAA1B,EAAmC;AAC/B;AACH;;AACD,WAAKmB,YAAL,GAAoBnB,OAApB;;AAEA,WAAKJ,cAAL;AACH,KAPqB;qBAAA;;AAAA,GAAtB;AAkBAC,wBAAWC,kCAAX,EAAW,SAAX,EAAkB;SAUlB;AACI,aAAO,KAAKsB,QAAZ;AACH,KAZiB;;AAHlB;;;SAGA,aAAmBC,WAAnB,EAAsC;AAClC,UAAI,KAAKD,QAAL,KAAkBC,WAAtB,EAAmC;AAC/B;AACH;;AACD,WAAKD,QAAL,GAAgBC,WAAhB;;AAEA,WAAKzB,cAAL;AACH,KAPiB;qBAAA;;AAAA,GAAlB;AAiBAC,wBAAWC,kCAAX,EAAW,wBAAX,EAAiC;SASjC;AACI,aAAO,KAAKH,uBAAZ;AACH,KAXgC;;AAHjC;;;SAGA,aAAkCK,OAAlC,EAAkD;AAC9C,UAAI,KAAKL,uBAAL,KAAiCK,OAArC,EAA8C;AAC1C;AACH;;AAED,WAAK/C,MAAL,CAAYmC,4BAAZ,CAAyCM,SAAzC,GAAqDM,OAArD;AACH,KANgC;qBAAA;;AAAA,GAAjC;AAgBAH,wBAAWC,kCAAX,EAAW,kBAAX,EAA2B;SAU3B;AACI,aAAO,KAAKwB,UAAL,IAAmB,IAA1B;AACH,KAZ0B;;AAH3B;;;SAGA,aAA4BtB,OAA5B,EAA4C;AACxC,UAAIA,OAAO,IAAI,CAAC,KAAKsB,UAArB,EAAiC;AAC7B,aAAKA,UAAL,GAAkB,IAAIjG,SAAJ,CAAc,EAAd,EAAkB,KAAK4B,MAAvB,CAAlB;AACH,OAFD,MAEO,IAAI,CAAC+C,OAAD,IAAY,KAAKsB,UAArB,EAAiC;AACpC,aAAKA,UAAL,CAAgBC,OAAhB;;AACA,aAAKD,UAAL,GAAkB,IAAlB;AACH;AACJ,KAP0B;qBAAA;;AAAA,GAA3B;AAiBAzB,wBAAWC,kCAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA;AACI,aAAO,KAAKwB,UAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAOAzB,wBAAWC,kCAAX,EAAW,4BAAX,EAAqC;SAUrC;AACI,aAAO,KAAK0B,2BAAZ;AACH,KAZoC;;AAHrC;;;SAGA,aAAsCxB,OAAtC,EAAsD;AAClD,UAAI,KAAKwB,2BAAL,KAAqCxB,OAAzC,EAAkD;AAC9C;AACH;;AACD,WAAKwB,2BAAL,GAAmCxB,OAAnC;;AAEA,WAAKJ,cAAL;AACH,KAPoC;qBAAA;;AAAA,GAArC;AAgBAC,wBAAWC,kCAAX,EAAW,cAAX,EAAuB;SAUvB;AACI,aAAO,KAAK2B,aAAZ;AACH,KAZsB;;AAHvB;;;SAGA,aAAwBzB,OAAxB,EAAwC;AACpC,UAAI,KAAKyB,aAAL,KAAuBzB,OAA3B,EAAoC;AAChC;AACH;;AACD,WAAKyB,aAAL,GAAqBzB,OAArB;;AAEA,WAAKJ,cAAL;AACH,KAPsB;qBAAA;;AAAA,GAAvB;AAkHA;;;;;AAIOE,oDAAP;AACI,WAAO,0BAAP;AACH,GAFM;AAIP;;;;;AAGOA,+CAAP;AACI,QAAM4B,aAAa,GAAG,KAAK1E,aAA3B;AACA,SAAKA,aAAL,GAAqB,IAArB;;AACA,SAAK4C,cAAL;;AACA,SAAK5C,aAAL,GAAqB0E,aAArB;AACH,GALM;;AAWC5B,sEAAR,UAAuC6B,WAAvC,EAAiEC,kBAAjE,EAA2F;AAA1B;AAAAA;AAA0B;;AACvF,QAAI,KAAKC,WAAT,EAAsB;AAClBF,iBAAW,CAACG,SAAZ,GAAwB,KAAxB;AACH,KAFD,MAEO;AACHH,iBAAW,CAACG,SAAZ,GAAwB,IAAxB;AACA,WAAK7E,MAAL,CAAY6E,SAAZ,GAAwB,KAAxB;AACA,WAAKD,WAAL,GAAmB,IAAnB;AACH;;AAED,QAAI,CAACD,kBAAL,EAAyB;AACrB,UAAI,KAAKG,oBAAT,EAA+B;AAC3BJ,mBAAW,CAACK,eAAZ,CAA4B,KAAKD,oBAAjC;AACH,OAFD,MAEO;AACHJ,mBAAW,CAACM,YAAZ;AACH;;AAED,UAAI,KAAKC,gBAAT,EAA2B;AACvB,aAAKH,oBAAL,GAA4B,KAAKG,gBAAjC;AACH;;AACD,WAAKA,gBAAL,GAAwBP,WAAxB;AACH;AACJ,GArBO;;AAyBA7B,sDAAR;AAAA;;AACI,QAAI,CAAC,KAAK9C,aAAV,EAAyB;AACrB;AACH;;AACD,SAAKC,MAAL,CAAY6E,SAAZ,GAAwB,IAAxB;;AAEA,QAAMpE,MAAM,GAAG,KAAKT,MAAL,CAAYP,SAAZ,EAAf;;AAEA,SAAKyF,qBAAL;;AACA,QAAI,KAAKtF,QAAL,KAAkB,IAAtB,EAA4B;AACxB,WAAKI,MAAL,CAAYO,gCAAZ,CAA6C4E,+BAA7C,CAA6E,KAAKC,KAAlF,EAAyF,KAAKxF,QAA9F,EADwB,CAExB;;;AACA,WAAKA,QAAL,GAAgB,KAAKE,oBAAL,CAA0BD,KAA1B,EAAhB;AACH;;AACD,SAAKwF,MAAL;;AACA,SAAKJ,gBAAL,GAAwB,IAAxB;AACA,SAAKH,oBAAL,GAA4B,IAA5B;AACA,SAAKF,WAAL,GAAmB,KAAnB;;AAEA,QAAI,KAAKU,mBAAT,EAA8B;AAC1B;AACA,UAAI,KAAK1F,QAAL,CAAc8D,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,aAAqB,sBAAK9D,QAA1B,EAAqB2F,cAArB,EAAqBA,IAArB,EAAoC;AAA/B,cAAMC,MAAM,SAAZ;;AACD,cAAMC,aAAa,GAAG,KAAKzF,MAAL,CAAY0F,mBAAZ,CAAgCF,MAAhC,CAAtB;;AACAC,uBAAa,CAACE,qBAAd,GAAsC,IAAtC;AACH;;AAED,aAAKC,0BAAL,GAAkC,KAAK5F,MAAL,CAAY6F,oCAAZ,CAAiD/D,GAAjD,CAAqD,UAAC1C,KAAD,EAAM;AACzF,cAAIM,KAAI,CAACE,QAAL,CAAckG,OAAd,CAAsB1G,KAAK,CAAC2G,YAA5B,IAA6C,CAAC,CAAlD,EAAqD;AACjDrG,iBAAI,CAACoB,YAAL,CAAkBkF,YAAlB,GAAiC5G,KAAK,CAACsG,mBAAN,CAA0BtG,KAAK,CAAC2G,YAAhC,EAA8CE,WAA9C,EAAjC;AACH;AACJ,SAJiC,CAAlC;AAKH,OAXD,MAWO;AACH,aAAKjG,MAAL,CAAY6F,oCAAZ,CAAiDK,MAAjD,CAAwD,KAAKN,0BAA7D;;AACA,YAAMH,aAAa,GAAG,KAAKzF,MAAL,CAAY0F,mBAAZ,CAAgC,KAAK9F,QAAL,CAAc,CAAd,CAAhC,CAAtB;;AACA,aAAKkB,YAAL,CAAkBkF,YAAlB,GAAiCP,aAAa,CAACQ,WAAd,EAAjC;AACH;;AAED,UAAI,CAAC,KAAKnF,YAAL,CAAkBqF,QAAlB,EAAL,EAAmC;AAC/B,aAAKrF,YAAL,CAAkBsF,cAAlB;AACH;;AACD,WAAKC,SAAL,CAAe,KAAKvF,YAApB;;AACA,WAAKwF,8BAAL,CAAoC,KAAKxF,YAAL,CAAkByF,QAAlB,CAA2B,CAA3B,CAApC,EAAmE,IAAnE;AACH,KAxBD,MAwBO;AACH,WAAKvG,MAAL,CAAY6F,oCAAZ,CAAiDK,MAAjD,CAAwD,KAAKN,0BAA7D;AACH;;AAED,QAAI,KAAKY,YAAT,EAAuB;AACnB,UAAI,CAAC,KAAKxF,KAAL,CAAWmF,QAAX,EAAL,EAA4B;AACxB,aAAKnF,KAAL,CAAWoF,cAAX;AACH;;AACD,WAAKC,SAAL,CAAe,KAAKrF,KAApB;;AACA,WAAKsF,8BAAL,CAAoC,KAAKtF,KAAL,CAAWuF,QAAX,CAAoB,CAApB,CAApC,EAA4D,IAA5D;AACH;;AAED,QAAI,KAAK7D,uBAAT,EAAkC;AAC9B,WAAK+D,eAAL,GAAuB,IAAInI,0BAAJ,CACnB,iBADmB,EAEnB,GAFmB,EAGnB,IAHmB,EAInBH,OAAO,CAACwC,qBAJW,EAKnBF,MALmB,EAMnB,KANmB,EAOnB,KAAKH,2BAPc,EAQnB,KAAKlB,KAAL,CAAW+C,4BARQ,CAAvB;;AAUA,UAAI,KAAKhC,IAAT,EAAe;AACX,aAAKkG,SAAL,CACI,IAAI1H,uBAAJ,CACI8B,MADJ,EAEI,KAAKiG,4BAFT,EAGI;AACI,iBAAOhH,KAAI,CAAC+G,eAAZ;AACH,SALL,EAMI,IANJ,CADJ;;AAUA,aAAKH,8BAAL,CAAoC,KAAKG,eAAzC;AACH,OAZD,MAYO;AACH,aAAKzG,MAAL,CAAYmC,4BAAZ,CAAyCwE,kBAAzC,GAA8D,KAA9D;AACH;;AAED,UAAI,CAAC,KAAKtH,OAAN,IAAiB,KAAKA,OAAL,CAAaqE,MAAb,KAAwB,CAA7C,EAAgD;AAC5C,aAAK1D,MAAL,CAAYmC,4BAAZ,CAAyCwE,kBAAzC,GAA8D,KAA9D;AACH;;AAED,UAAI,CAAC,KAAKF,eAAL,CAAqBG,SAArB,EAAL,EAAuC;AACnC,aAAKH,eAAL,CAAqBI,iBAArB;AACH;AACJ;;AAED,QAAI,KAAKC,cAAT,EAAyB;AACrB,UAAI,CAAC,KAAKpG,OAAL,CAAaqG,OAAb,EAAL,EAA6B;AACzB,aAAKrG,OAAL,CAAasG,YAAb;AACH;;AACD,WAAKX,SAAL,CAAe,KAAKzF,cAApB;;AACA,WAAK0F,8BAAL,CAAoC,KAAK5F,OAAzC;AACH;;AAED,QAAI,KAAKuG,YAAT,EAAuB;AACnB,UAAI,CAAC,KAAKxF,KAAL,CAAWsF,OAAX,EAAL,EAA2B;AACvB,aAAKtF,KAAL,CAAWuF,YAAX;AACH;;AACD,WAAKX,SAAL,CAAe,KAAK3E,YAApB;;AACA,WAAK4E,8BAAL,CAAoC,KAAK7E,KAAzC;AACH;;AAED,QAAI,KAAKyF,0BAAT,EAAqC;AACjC,UAAI,CAAC,KAAK9F,mBAAL,CAAyB2F,OAAzB,EAAL,EAAyC;AACrC,aAAK3F,mBAAL,CAAyB4F,YAAzB;AACH;;AACD,WAAKX,SAAL,CAAe,KAAK9E,0BAApB;;AACA,WAAK+E,8BAAL,CAAoC,KAAKlF,mBAAzC;AACH;;AAED,QAAI,KAAK+F,WAAT,EAAsB;AAClB,WAAKC,IAAL,GAAY,IAAI3I,eAAJ,CAAoB,MAApB,EAA4B,GAA5B,EAAiC,IAAjC,EAAuCN,OAAO,CAACwC,qBAA/C,EAAsEF,MAAtE,EAA8E,KAA9E,EAAqF,KAAKH,2BAA1F,CAAZ;AACA,WAAK+F,SAAL,CACI,IAAI1H,uBAAJ,CACI8B,MADJ,EAEI,KAAK4G,iBAFT,EAGI;AACI,eAAO3H,KAAI,CAAC0H,IAAZ;AACH,OALL,EAMI,IANJ,CADJ;;AAUA,WAAKd,8BAAL,CAAoC,KAAKc,IAAzC,EAA+C,IAA/C;AACH;;AAED,QAAI,KAAKxH,QAAL,KAAkB,IAAtB,EAA4B;AACxB,WAAKI,MAAL,CAAYO,gCAAZ,CAA6C+G,6BAA7C,CAA2E,KAAKlC,KAAhF,EAAuF,KAAKxF,QAA5F;AACH,KApIL,CAsII;;;AACA,QAAI,KAAKI,MAAL,CAAYuH,aAAZ,IAA6B,KAAKvH,MAAL,CAAYuH,aAAZ,CAA0B7D,MAA1B,GAAmC,CAApE,EAAuE;AACnE,WAAK1D,MAAL,CAAY6E,SAAZ,GAAwB,IAAxB;AACH;;AAED,QAAI,CAAC,KAAK2C,6BAAL,CAAmC,KAAKC,OAAxC,CAAD,IAAqD,KAAKA,OAAL,GAAe,CAAxE,EAA2E;AACvEvJ,YAAM,CAACwJ,IAAP,CAAY,qFAAZ;AACH;;AAED,SAAKC,iBAAL,CAAuBC,eAAvB,CAAuC,IAAvC;AACH,GAhJO;;AAkJA/E,6DAAR,UAA8BgF,mBAA9B,EAAyD;AAA3B;AAAAA;AAA2B;;AACrD,SAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK7D,QAAL,CAAc8D,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3C,UAAM+B,MAAM,GAAG,KAAK5F,QAAL,CAAc6D,CAAd,CAAf;;AAEA,UAAI,KAAKgD,eAAT,EAA0B;AACtB,aAAKA,eAAL,CAAqBnC,OAArB,CAA6BkB,MAA7B;AACH;;AAED,UAAI,KAAK4B,IAAT,EAAe;AACX,aAAKA,IAAL,CAAU9C,OAAV,CAAkBkB,MAAlB;AACH,OAT0C,CAW3C;;;AACA,UAAIqC,mBAAJ,EAAyB;AACrB,YAAI,KAAKnH,OAAT,EAAkB;AACd,eAAKA,OAAL,CAAa4D,OAAb,CAAqBkB,MAArB;AACH;;AAED,YAAI,KAAK1E,YAAT,EAAuB;AACnB,eAAKd,MAAL,CAAY6F,oCAAZ,CAAiDK,MAAjD,CAAwD,KAAKN,0BAA7D;;AACA,eAAK9E,YAAL,CAAkB6C,cAAlB,CAAiC6B,MAAjC;AACH;;AAED,YAAI,KAAKxE,KAAT,EAAgB;AACZ,eAAKA,KAAL,CAAW2C,cAAX,CAA0B6B,MAA1B;AACH;;AAED,YAAI,KAAKpE,mBAAT,EAA8B;AAC1B,eAAKA,mBAAL,CAAyBkD,OAAzB,CAAiCkB,MAAjC;AACH;;AAED,YAAI,KAAK/D,KAAT,EAAgB;AACZ,eAAKA,KAAL,CAAW6C,OAAX,CAAmBkB,MAAnB;AACH;;AACD,YAAI,KAAKnB,UAAT,EAAqB;AACjB,eAAKA,UAAL,CAAgBC,OAAhB;AACH;AACJ;AACJ;;AAEK,SAAKmC,eAAL,GAAwB,IAAxB;AACA,SAAKW,IAAL,GAAa,IAAb;;AAEN,QAAIS,mBAAJ,EAAyB;AACf,WAAKnH,OAAL,GAAgB,IAAhB;AACA,WAAKE,cAAL,GAAuB,IAAvB;AACA,WAAKE,YAAL,GAAqB,IAArB;AACA,WAAKE,KAAL,GAAc,IAAd;AACA,WAAKI,mBAAL,GAA4B,IAA5B;AACA,WAAKG,0BAAL,GAAmC,IAAnC;AACA,WAAKE,KAAL,GAAc,IAAd;AACA,WAAKC,YAAL,GAAqB,IAArB;AACN,WAAK2C,UAAL,GAAkB,IAAlB;AACH;AACJ,GAtDO;AAwDR;;;;;;AAIOxB,iDAAP,UAAiB2C,MAAjB,EAA+B;AAC3B,SAAK1F,oBAAL,CAA0BgI,IAA1B,CAA+BtC,MAA/B;;AACA,SAAK7C,cAAL;AACH,GAHM;AAKP;;;;;;AAIOE,oDAAP,UAAoB2C,MAApB,EAAkC;AAC9B,QAAMuC,KAAK,GAAG,KAAKjI,oBAAL,CAA0BgG,OAA1B,CAAkCN,MAAlC,CAAd;;AACA,SAAK1F,oBAAL,CAA0BkI,MAA1B,CAAiCD,KAAjC,EAAwC,CAAxC;;AACA,SAAKpF,cAAL;AACH,GAJM;AAMP;;;;;AAGOE,+CAAP;AACI,SAAK8E,iBAAL,CAAuBM,KAAvB;;AACA,SAAK/C,qBAAL,CAA2B,IAA3B;;AACA,SAAKlF,MAAL,CAAYO,gCAAZ,CAA6C4E,+BAA7C,CAA6E,KAAKC,KAAlF,EAAyF,KAAKxF,QAA9F;;AACA,SAAKI,MAAL,CAAY6E,SAAZ,GAAwB,IAAxB;;AACA,QAAI,KAAKjD,eAAT,EAA0B;AACtB,WAAK5B,MAAL,CAAYP,SAAZ,GAAwBoC,kBAAxB,CAA2CqE,MAA3C,CAAkD,KAAKtE,eAAvD;;AACA,WAAKA,eAAL,GAAuB,IAAvB;AACH;;AACD,SAAK5B,MAAL,CAAYmC,4BAAZ,CAAyCC,kBAAzC,CAA4D8D,MAA5D,CAAmE,KAAKhE,qCAAxE;;AACA1C,qBAAM8E,OAAN,CAAa4D,IAAb,CAAa,IAAb;AACH,GAXM;AAaP;;;;;;AAIOrF,iDAAP;AACI,QAAMsF,mBAAmB,GAAGnK,mBAAmB,CAACoK,SAApB,CAA8B,IAA9B,CAA5B;AACAD,uBAAmB,CAACE,UAApB,GAAiC,0BAAjC;AAEA,WAAOF,mBAAP;AACH,GALM;AAOP;;;;;;;;;AAOctF,mCAAd,UAAoByF,MAApB,EAAiClJ,KAAjC,EAA+CmJ,OAA/C,EAA8D;AAC1D,WAAOvK,mBAAmB,CAACwK,KAApB,CAA0B;AAAM,iBAAI3F,wBAAJ,CAA6ByF,MAAM,CAAClD,KAApC,EAA2CkD,MAAM,CAAClD,KAAP,CAAajF,IAAxD,EAA8Df,KAA9D;AAAoE,KAApG,EAAsGkJ,MAAtG,EAA8GlJ,KAA9G,EAAqHmJ,OAArH,CAAP;AACH,GAFa;;AA9pBdE,cADC1K,SAAS,EACV;;AAWA0K,cADC1K,SAAS,EACV;;AAYA0K,cADC1K,SAAS,EACV;;AAKA0K,cADC1K,SAAS,EACV;;AAGA0K,cADC1K,SAAS,EACV;;AAeA0K,cADC1K,SAAS,EACV;;AAgBA0K,cADC1K,SAAS,EACV;;AAoBA0K,cADC1K,SAAS,EACV;;AAiBA0K,cADC1K,SAAS,EACV;;AAkBA0K,cADC1K,SAAS,EACV;;AAiBA0K,cADC1K,SAAS,EACV;;AAuCA0K,cADC1K,SAAS,EACV;;AAkBA0K,cADC1K,SAAS,EACV;;AAgBA0K,cADC1K,SAAS,EACV;;AAiBA0K,cADC1K,SAAS,EACV;;AAwBA0K,cADC1K,SAAS,EACV;;AAgBA0K,cADC1K,SAAS,EACV;;AAyZJ;AAAC,CA1wBD,CAA8CW,yBAA9C;;SAAamE;AA4wBb9D,aAAa,CAAC,kCAAD,EAAqC8D,wBAArC,CAAb","names":["serialize","SerializationHelper","Observable","Logger","Texture","GlowLayer","SharpenPostProcess","ImageProcessingPostProcess","ChromaticAberrationPostProcess","GrainPostProcess","FxaaPostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","DepthOfFieldEffect","DepthOfFieldEffectBlurLevel","BloomEffect","RegisterClass","EngineStore","__extends","name","hdr","scene","cameras","automaticBuild","LastCreatedScene","_super","getEngine","_this","Low","_cameras","slice","_camerasToBeAttached","_buildAllowed","_scene","caps","getCaps","_hdr","textureHalfFloatRender","textureFloatRender","_defaultPipelineTextureType","postProcessRenderPipelineManager","addPipeline","engine","sharpen","BILINEAR_SAMPLINGMODE","_sharpenEffect","SharpenPostProcessId","depthOfField","_depthOfFieldBlurLevel","bloom","_bloomScale","_bloomWeight","bloomKernel","chromaticAberration","getRenderWidth","getRenderHeight","_chromaticAberrationEffect","ChromaticAberrationPostProcessId","grain","_grainEffect","GrainPostProcessId","_resizeObserver","onResizeObservable","add","_hardwareScaleLevel","getHardwareScalingLevel","_bloomKernel","_imageProcessingConfigurationObserver","imageProcessingConfiguration","onUpdateParameters","_downscale","_exposure","exposure","imageProcessingEnabled","isEnabled","_imageProcessingEnabled","_buildPipeline","Object","DefaultRenderingPipeline","_sharpenEnabled","enabled","value","kernel","weight","_bloomThreshold","threshold","_rebuildBloom","_bloomEnabled","oldBloom","bloomScale","i","length","disposeEffects","_depthOfFieldEnabled","oldDof","focalLength","focusDistance","fStop","lensSize","_fxaaEnabled","_samples","sampleCount","_glowLayer","dispose","_chromaticAberrationEnabled","_grainEnabled","previousState","postProcess","skipTextureSharing","_hasCleared","autoClear","_prevPrevPostProcess","shareOutputWith","useOwnOutput","_prevPostProcess","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","depthOfFieldEnabled","_i","camera","depthRenderer","enableDepthRenderer","useOnlyInActiveCamera","_depthOfFieldSceneObserver","onAfterRenderTargetsRenderObservable","indexOf","activeCamera","depthTexture","getDepthMap","remove","_isReady","_updateEffects","addEffect","_setAutoClearAndTextureSharing","_effects","bloomEnabled","imageProcessing","ImageProcessingPostProcessId","applyByPostProcess","getEffect","_updateParameters","sharpenEnabled","isReady","updateEffect","grainEnabled","chromaticAberrationEnabled","fxaaEnabled","fxaa","FxaaPostProcessId","attachCamerasToRenderPipeline","activeCameras","_enableMSAAOnFirstPostProcess","samples","Warn","onBuildObservable","notifyObservers","disposeNonRecreated","push","index","splice","clear","call","serializationObject","Serialize","customType","source","rootUrl","Parse","__decorate"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { Observer } from \"../../../Misc/observable\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { ImageProcessingConfiguration } from \"../../../Materials/imageProcessingConfiguration\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport { GlowLayer } from \"../../../Layers/glowLayer\";\r\n\r\nimport type { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess\";\r\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess\";\r\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect\";\r\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\ndeclare type Animation = import(\"../../../Animations/animation\").Animation;\r\n\r\n/**\r\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\r\n * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline\r\n */\r\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    private _scene: Scene;\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n    /**\r\n     * ID of the sharpen post process,\r\n     */\r\n    private readonly SharpenPostProcessId: string = \"SharpenPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the image processing post process;\r\n     */\r\n    readonly ImageProcessingPostProcessId: string = \"ImageProcessingPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the Fast Approximate Anti-Aliasing post process;\r\n     */\r\n    readonly FxaaPostProcessId: string = \"FxaaPostProcessEffect\";\r\n    /**\r\n     * ID of the chromatic aberration post process,\r\n     */\r\n    private readonly ChromaticAberrationPostProcessId: string = \"ChromaticAberrationPostProcessEffect\";\r\n    /**\r\n     * ID of the grain post process\r\n     */\r\n    private readonly GrainPostProcessId: string = \"GrainPostProcessEffect\";\r\n\r\n    // Post-processes\r\n    /**\r\n     * Sharpen post process which will apply a sharpen convolution to enhance edges\r\n     */\r\n    public sharpen: SharpenPostProcess;\r\n    private _sharpenEffect: PostProcessRenderEffect;\r\n    private bloom: BloomEffect;\r\n    /**\r\n     * Depth of field effect, applies a blur based on how far away objects are from the focus distance.\r\n     */\r\n    public depthOfField: DepthOfFieldEffect;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaa: FxaaPostProcess;\r\n    /**\r\n     * Image post processing pass used to perform operations such as tone mapping or color grading.\r\n     */\r\n    public imageProcessing: ImageProcessingPostProcess;\r\n    /**\r\n     * Chromatic aberration post process which will shift rgb colors in the image\r\n     */\r\n    public chromaticAberration: ChromaticAberrationPostProcess;\r\n    private _chromaticAberrationEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Grain post process which add noise to the image\r\n     */\r\n    public grain: GrainPostProcess;\r\n    private _grainEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Glow post process which adds a glow to emissive areas of the image\r\n     */\r\n    private _glowLayer: Nullable<GlowLayer> = null;\r\n\r\n    /**\r\n     * Animations which can be used to tweak settings over a period of time\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _imageProcessingConfigurationObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n    // Values\r\n    private _sharpenEnabled: boolean = false;\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _imageProcessingEnabled: boolean = true;\r\n    private _defaultPipelineTextureType: number;\r\n    private _bloomScale: number = 0.5;\r\n    private _chromaticAberrationEnabled: boolean = false;\r\n    private _grainEnabled: boolean = false;\r\n\r\n    private _buildAllowed = true;\r\n\r\n    /**\r\n     * This is triggered each time the pipeline has been built.\r\n     */\r\n    public onBuildObservable = new Observable<DefaultRenderingPipeline>();\r\n\r\n    /**\r\n     * Gets active scene\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the sharpen process from the pipeline\r\n     */\r\n    public set sharpenEnabled(enabled: boolean) {\r\n        if (this._sharpenEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._sharpenEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get sharpenEnabled(): boolean {\r\n        return this._sharpenEnabled;\r\n    }\r\n\r\n    private _resizeObserver: Nullable<Observer<Engine>> = null;\r\n    private _hardwareScaleLevel = 1.0;\r\n    private _bloomKernel: number = 64;\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    @serialize()\r\n    public get bloomKernel(): number {\r\n        return this._bloomKernel;\r\n    }\r\n    public set bloomKernel(value: number) {\r\n        this._bloomKernel = value;\r\n        this.bloom.kernel = value / this._hardwareScaleLevel;\r\n    }\r\n\r\n    /**\r\n     * Specifies the weight of the bloom in the final rendering\r\n     */\r\n    @serialize()\r\n    private _bloomWeight: number = 0.15;\r\n    /**\r\n     * Specifies the luma threshold for the area that will be blurred by the bloom\r\n     */\r\n    @serialize()\r\n    private _bloomThreshold: number = 0.9;\r\n\r\n    @serialize()\r\n    private _hdr: boolean;\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public set bloomWeight(value: number) {\r\n        if (this._bloomWeight === value) {\r\n            return;\r\n        }\r\n        this.bloom.weight = value;\r\n\r\n        this._bloomWeight = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomWeight(): number {\r\n        return this._bloomWeight;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public set bloomThreshold(value: number) {\r\n        if (this._bloomThreshold === value) {\r\n            return;\r\n        }\r\n        this.bloom.threshold = value;\r\n        this._bloomThreshold = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomThreshold(): number {\r\n        return this._bloomThreshold;\r\n    }\r\n\r\n    /**\r\n     * The scale of the bloom, lower value will provide better performance.\r\n     */\r\n    public set bloomScale(value: number) {\r\n        if (this._bloomScale === value) {\r\n            return;\r\n        }\r\n        this._bloomScale = value;\r\n\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        this._rebuildBloom();\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomScale(): number {\r\n        return this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the bloom from the pipeline\r\n     */\r\n    public set bloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._bloomEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    private _rebuildBloom() {\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        const oldBloom = this.bloom;\r\n        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, false);\r\n        this.bloom.threshold = oldBloom.threshold;\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldBloom.disposeEffects(this._cameras[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the depth of field is enabled.\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set depthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._depthOfFieldEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Blur level of the depth of field effect. (Higher blur will effect performance)\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldBlurLevel(): DepthOfFieldEffectBlurLevel {\r\n        return this._depthOfFieldBlurLevel;\r\n    }\r\n\r\n    public set depthOfFieldBlurLevel(value: DepthOfFieldEffectBlurLevel) {\r\n        if (this._depthOfFieldBlurLevel === value) {\r\n            return;\r\n        }\r\n        this._depthOfFieldBlurLevel = value;\r\n\r\n        // recreate dof and dispose old as this setting is not dynamic\r\n        const oldDof = this.depthOfField;\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\r\n        this.depthOfField.focalLength = oldDof.focalLength;\r\n        this.depthOfField.focusDistance = oldDof.focusDistance;\r\n        this.depthOfField.fStop = oldDof.fStop;\r\n        this.depthOfField.lensSize = oldDof.lensSize;\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldDof.disposeEffects(this._cameras[i]);\r\n        }\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * If the anti aliasing is enabled.\r\n     */\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._fxaaEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    private _samples = 1;\r\n    /**\r\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n        this._samples = sampleCount;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * If image processing is enabled.\r\n     */\r\n    public set imageProcessingEnabled(enabled: boolean) {\r\n        if (this._imageProcessingEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._scene.imageProcessingConfiguration.isEnabled = enabled;\r\n    }\r\n\r\n    @serialize()\r\n    public get imageProcessingEnabled(): boolean {\r\n        return this._imageProcessingEnabled;\r\n    }\r\n\r\n    /**\r\n     * If glow layer is enabled. (Adds a glow effect to emmissive materials)\r\n     */\r\n    public set glowLayerEnabled(enabled: boolean) {\r\n        if (enabled && !this._glowLayer) {\r\n            this._glowLayer = new GlowLayer(\"\", this._scene);\r\n        } else if (!enabled && this._glowLayer) {\r\n            this._glowLayer.dispose();\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get glowLayerEnabled(): boolean {\r\n        return this._glowLayer != null;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow layer (or null if not defined)\r\n     */\r\n    public get glowLayer() {\r\n        return this._glowLayer;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the chromaticAberration process from the pipeline\r\n     */\r\n    public set chromaticAberrationEnabled(enabled: boolean) {\r\n        if (this._chromaticAberrationEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._chromaticAberrationEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get chromaticAberrationEnabled(): boolean {\r\n        return this._chromaticAberrationEnabled;\r\n    }\r\n    /**\r\n     * Enable or disable the grain process from the pipeline\r\n     */\r\n    public set grainEnabled(enabled: boolean) {\r\n        if (this._grainEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._grainEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get grainEnabled(): boolean {\r\n        return this._grainEnabled;\r\n    }\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name - The rendering pipeline name (default: \"\")\r\n     * @param hdr - If high dynamic range textures should be used (default: true)\r\n     * @param scene - The scene linked to this pipeline (default: the last created scene)\r\n     * @param cameras - The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\r\n     * @param automaticBuild - if false, you will have to manually call prepare() to update the pipeline (default: true)\r\n     */\r\n    constructor(name: string = \"\", hdr: boolean = true, scene: Scene = EngineStore.LastCreatedScene!, cameras?: Camera[], automaticBuild = true) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        this._buildAllowed = automaticBuild;\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        const caps = this._scene.getEngine().getCaps();\r\n        this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\r\n\r\n        // Misc\r\n        if (this._hdr) {\r\n            if (caps.textureHalfFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        } else {\r\n            this._defaultPipelineTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        // Attach\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n        // Create post processes before hand so they can be modified before enabled.\r\n        // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\r\n        this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._sharpenEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.SharpenPostProcessId,\r\n            () => {\r\n                return this.sharpen;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\r\n\r\n        this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, true);\r\n\r\n        this.chromaticAberration = new ChromaticAberrationPostProcess(\r\n            \"ChromaticAberration\",\r\n            engine.getRenderWidth(),\r\n            engine.getRenderHeight(),\r\n            1.0,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            this._defaultPipelineTextureType,\r\n            true\r\n        );\r\n        this._chromaticAberrationEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.ChromaticAberrationPostProcessId,\r\n            () => {\r\n                return this.chromaticAberration;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._grainEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.GrainPostProcessId,\r\n            () => {\r\n                return this.grain;\r\n            },\r\n            true\r\n        );\r\n\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n            this.bloomKernel = this._bloomKernel;\r\n        });\r\n\r\n        this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\r\n\r\n            if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\r\n                this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\r\n                this._buildPipeline();\r\n            }\r\n        });\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns \"DefaultRenderingPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DefaultRenderingPipeline\";\r\n    }\r\n\r\n    /**\r\n     * Force the compilation of the entire pipeline.\r\n     */\r\n    public prepare(): void {\r\n        const previousState = this._buildAllowed;\r\n        this._buildAllowed = true;\r\n        this._buildPipeline();\r\n        this._buildAllowed = previousState;\r\n    }\r\n\r\n    private _hasCleared = false;\r\n    private _prevPostProcess: Nullable<PostProcess> = null;\r\n    private _prevPrevPostProcess: Nullable<PostProcess> = null;\r\n\r\n    private _setAutoClearAndTextureSharing(postProcess: PostProcess, skipTextureSharing = false) {\r\n        if (this._hasCleared) {\r\n            postProcess.autoClear = false;\r\n        } else {\r\n            postProcess.autoClear = true;\r\n            this._scene.autoClear = false;\r\n            this._hasCleared = true;\r\n        }\r\n\r\n        if (!skipTextureSharing) {\r\n            if (this._prevPrevPostProcess) {\r\n                postProcess.shareOutputWith(this._prevPrevPostProcess);\r\n            } else {\r\n                postProcess.useOwnOutput();\r\n            }\r\n\r\n            if (this._prevPostProcess) {\r\n                this._prevPrevPostProcess = this._prevPostProcess;\r\n            }\r\n            this._prevPostProcess = postProcess;\r\n        }\r\n    }\r\n\r\n    private _depthOfFieldSceneObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    private _buildPipeline() {\r\n        if (!this._buildAllowed) {\r\n            return;\r\n        }\r\n        this._scene.autoClear = true;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n        this._prevPostProcess = null;\r\n        this._prevPrevPostProcess = null;\r\n        this._hasCleared = false;\r\n\r\n        if (this.depthOfFieldEnabled) {\r\n            // Multi camera suport\r\n            if (this._cameras.length > 1) {\r\n                for (const camera of this._cameras) {\r\n                    const depthRenderer = this._scene.enableDepthRenderer(camera);\r\n                    depthRenderer.useOnlyInActiveCamera = true;\r\n                }\r\n\r\n                this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {\r\n                    if (this._cameras.indexOf(scene.activeCamera!) > -1) {\r\n                        this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\r\n                    }\r\n                });\r\n            } else {\r\n                this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\r\n                this.depthOfField.depthTexture = depthRenderer.getDepthMap();\r\n            }\r\n\r\n            if (!this.depthOfField._isReady()) {\r\n                this.depthOfField._updateEffects();\r\n            }\r\n            this.addEffect(this.depthOfField);\r\n            this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\r\n        } else {\r\n            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n        }\r\n\r\n        if (this.bloomEnabled) {\r\n            if (!this.bloom._isReady()) {\r\n                this.bloom._updateEffects();\r\n            }\r\n            this.addEffect(this.bloom);\r\n            this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\r\n        }\r\n\r\n        if (this._imageProcessingEnabled) {\r\n            this.imageProcessing = new ImageProcessingPostProcess(\r\n                \"imageProcessing\",\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._defaultPipelineTextureType,\r\n                this.scene.imageProcessingConfiguration\r\n            );\r\n            if (this._hdr) {\r\n                this.addEffect(\r\n                    new PostProcessRenderEffect(\r\n                        engine,\r\n                        this.ImageProcessingPostProcessId,\r\n                        () => {\r\n                            return this.imageProcessing;\r\n                        },\r\n                        true\r\n                    )\r\n                );\r\n                this._setAutoClearAndTextureSharing(this.imageProcessing);\r\n            } else {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this.cameras || this.cameras.length === 0) {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this.imageProcessing.getEffect()) {\r\n                this.imageProcessing._updateParameters();\r\n            }\r\n        }\r\n\r\n        if (this.sharpenEnabled) {\r\n            if (!this.sharpen.isReady()) {\r\n                this.sharpen.updateEffect();\r\n            }\r\n            this.addEffect(this._sharpenEffect);\r\n            this._setAutoClearAndTextureSharing(this.sharpen);\r\n        }\r\n\r\n        if (this.grainEnabled) {\r\n            if (!this.grain.isReady()) {\r\n                this.grain.updateEffect();\r\n            }\r\n            this.addEffect(this._grainEffect);\r\n            this._setAutoClearAndTextureSharing(this.grain);\r\n        }\r\n\r\n        if (this.chromaticAberrationEnabled) {\r\n            if (!this.chromaticAberration.isReady()) {\r\n                this.chromaticAberration.updateEffect();\r\n            }\r\n            this.addEffect(this._chromaticAberrationEffect);\r\n            this._setAutoClearAndTextureSharing(this.chromaticAberration);\r\n        }\r\n\r\n        if (this.fxaaEnabled) {\r\n            this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.FxaaPostProcessId,\r\n                    () => {\r\n                        return this.fxaa;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n            this._setAutoClearAndTextureSharing(this.fxaa, true);\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        // In multicamera mode, the scene needs to autoclear in between cameras.\r\n        if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\r\n            this._scene.autoClear = true;\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _disposePostProcesses(disposeNonRecreated = false): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.imageProcessing) {\r\n                this.imageProcessing.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaa) {\r\n                this.fxaa.dispose(camera);\r\n            }\r\n\r\n            // These are created in the constructor and should not be disposed on every pipeline change\r\n            if (disposeNonRecreated) {\r\n                if (this.sharpen) {\r\n                    this.sharpen.dispose(camera);\r\n                }\r\n\r\n                if (this.depthOfField) {\r\n                    this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                    this.depthOfField.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.bloom) {\r\n                    this.bloom.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.chromaticAberration) {\r\n                    this.chromaticAberration.dispose(camera);\r\n                }\r\n\r\n                if (this.grain) {\r\n                    this.grain.dispose(camera);\r\n                }\r\n                if (this._glowLayer) {\r\n                    this._glowLayer.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        (<any>this.imageProcessing) = null;\r\n        (<any>this.fxaa) = null;\r\n\r\n        if (disposeNonRecreated) {\r\n            (<any>this.sharpen) = null;\r\n            (<any>this._sharpenEffect) = null;\r\n            (<any>this.depthOfField) = null;\r\n            (<any>this.bloom) = null;\r\n            (<any>this.chromaticAberration) = null;\r\n            (<any>this._chromaticAberrationEffect) = null;\r\n            (<any>this.grain) = null;\r\n            (<any>this._grainEffect) = null;\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a camera to the pipeline\r\n     * @param camera the camera to be added\r\n     */\r\n    public addCamera(camera: Camera): void {\r\n        this._camerasToBeAttached.push(camera);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes a camera from the pipeline\r\n     * @param camera the camera to remove\r\n     */\r\n    public removeCamera(camera: Camera): void {\r\n        const index = this._camerasToBeAttached.indexOf(camera);\r\n        this._camerasToBeAttached.splice(index, 1);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this.onBuildObservable.clear();\r\n        this._disposePostProcesses(true);\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n        this._scene.autoClear = true;\r\n        if (this._resizeObserver) {\r\n            this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"DefaultRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline {\r\n        return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);\r\n"]},"metadata":{},"sourceType":"module"}