{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * Defines a subdivision inside a mesh\n */\n\nvar SubMesh =\n/** @class */\nfunction () {\n  /**\n   * Creates a new submesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n   */\n  function SubMesh(\n  /** the material index to use */\n  materialIndex,\n  /** vertex index start */\n  verticesStart,\n  /** vertices count */\n  verticesCount,\n  /** index start */\n  indexStart,\n  /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    if (addToMesh === void 0) {\n      addToMesh = true;\n    }\n\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    this._mainDrawWrapperOverride = null;\n    /** @hidden */\n\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @hidden */\n\n    this._lastColliderWorldVertices = null;\n    /** @hidden */\n\n    this._lastColliderTransformMatrix = null;\n    /** @hidden */\n\n    this._renderId = 0;\n    /** @hidden */\n\n    this._alphaIndex = 0;\n    /** @hidden */\n\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n\n    this._engine = this._mesh.getScene().getEngine();\n    this.resetDrawCache();\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(SubMesh.prototype, \"materialDefines\", {\n    /**\n     * Gets material defines used by the effect associated to the sub mesh\n     */\n    get: function get() {\n      var _a;\n\n      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;\n    },\n\n    /**\n     * Sets material defines used by the effect associated to the sub mesh\n     */\n    set: function set(defines) {\n      var _a;\n\n      var drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n      drawWrapper.defines = defines;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param passId\n   * @param createIfNotExisting\n   * @hidden\n   */\n\n  SubMesh.prototype._getDrawWrapper = function (passId, createIfNotExisting) {\n    if (createIfNotExisting === void 0) {\n      createIfNotExisting = false;\n    }\n\n    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;\n    var drawWrapper = this._drawWrappers[passId];\n\n    if (!drawWrapper && createIfNotExisting) {\n      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\n    }\n\n    return drawWrapper;\n  };\n  /**\n   * @param passId\n   * @param disposeWrapper\n   * @hidden\n   */\n\n\n  SubMesh.prototype._removeDrawWrapper = function (passId, disposeWrapper) {\n    var _a;\n\n    if (disposeWrapper === void 0) {\n      disposeWrapper = true;\n    }\n\n    if (disposeWrapper) {\n      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n\n    this._drawWrappers[passId] = undefined;\n  };\n\n  Object.defineProperty(SubMesh.prototype, \"effect\", {\n    /**\n     * Gets associated (main) effect (possibly the effect override if defined)\n     */\n    get: function get() {\n      var _a, _b;\n\n      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SubMesh.prototype, \"_drawWrapper\", {\n    /** @hidden */\n    get: function get() {\n      var _a;\n\n      return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SubMesh.prototype, \"_drawWrapperOverride\", {\n    /** @hidden */\n    get: function get() {\n      return this._mainDrawWrapperOverride;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param wrapper\n   * @hidden\n   */\n\n  SubMesh.prototype._setMainDrawWrapperOverride = function (wrapper) {\n    this._mainDrawWrapperOverride = wrapper;\n  };\n  /**\n   * Sets associated effect (effect used to render this submesh)\n   * @param effect defines the effect to associate with\n   * @param defines defines the set of defines used to compile this effect\n   * @param materialContext material context associated to the effect\n   * @param resetContext true to reset the draw context\n   */\n\n\n  SubMesh.prototype.setEffect = function (effect, defines, materialContext, resetContext) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (resetContext === void 0) {\n      resetContext = true;\n    }\n\n    var drawWrapper = this._drawWrapper;\n    drawWrapper.setEffect(effect, defines, resetContext);\n\n    if (materialContext !== undefined) {\n      drawWrapper.materialContext = materialContext;\n    }\n\n    if (!effect) {\n      drawWrapper.defines = null;\n      drawWrapper.materialContext = undefined;\n    }\n  };\n  /**\n   * Resets the draw wrappers cache\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n\n\n  SubMesh.prototype.resetDrawCache = function (passId) {\n    if (this._drawWrappers) {\n      if (passId !== undefined) {\n        this._removeDrawWrapper(passId);\n\n        return;\n      } else {\n        for (var _i = 0, _a = this._drawWrappers; _i < _a.length; _i++) {\n          var drawWrapper = _a[_i];\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n\n    this._drawWrappers = [];\n  };\n  /**\n   * Add a new submesh to a mesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns the new submesh\n   */\n\n\n  SubMesh.AddToMesh = function (materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  };\n\n  Object.defineProperty(SubMesh.prototype, \"IsGlobal\", {\n    /**\n     * Returns true if this submesh covers the entire parent mesh\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get: function get() {\n      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the submesh BoundingInfo object\n   * @returns current bounding info (or mesh's one if the submesh is global)\n   */\n\n  SubMesh.prototype.getBoundingInfo = function () {\n    if (this.IsGlobal) {\n      return this._mesh.getBoundingInfo();\n    }\n\n    return this._boundingInfo;\n  };\n  /**\n   * Sets the submesh BoundingInfo\n   * @param boundingInfo defines the new bounding info to use\n   * @returns the SubMesh\n   */\n\n\n  SubMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n  /**\n   * Returns the mesh of the current submesh\n   * @return the parent mesh\n   */\n\n\n  SubMesh.prototype.getMesh = function () {\n    return this._mesh;\n  };\n  /**\n   * Returns the rendering mesh of the submesh\n   * @returns the rendering mesh (could be different from parent mesh)\n   */\n\n\n  SubMesh.prototype.getRenderingMesh = function () {\n    return this._renderingMesh;\n  };\n  /**\n   * Returns the replacement mesh of the submesh\n   * @returns the replacement mesh (could be different from parent mesh)\n   */\n\n\n  SubMesh.prototype.getReplacementMesh = function () {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  };\n  /**\n   * Returns the effective mesh of the submesh\n   * @returns the effective mesh (could be different from parent mesh)\n   */\n\n\n  SubMesh.prototype.getEffectiveMesh = function () {\n    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  };\n  /**\n   * Returns the submesh material\n   * @returns null or the current material\n   */\n\n\n  SubMesh.prototype.getMaterial = function () {\n    var _a;\n\n    var rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;\n\n    if (rootMaterial === null || rootMaterial === undefined) {\n      return this._mesh.getScene().defaultMaterial;\n    } else if (this._isMultiMaterial(rootMaterial)) {\n      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this.resetDrawCache();\n      }\n\n      return effectiveMaterial;\n    }\n\n    return rootMaterial;\n  };\n\n  SubMesh.prototype._isMultiMaterial = function (material) {\n    return material.getSubMaterial !== undefined;\n  }; // Methods\n\n  /**\n   * Sets a new updated BoundingInfo object to the submesh\n   * @param data defines an optional position array to use to determine the bounding info\n   * @returns the SubMesh\n   */\n\n\n  SubMesh.prototype.refreshBoundingInfo = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    this._lastColliderWorldVertices = null;\n\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n\n    var indices = this._renderingMesh.getIndices();\n\n    var extend; //is this the only submesh?\n\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      var boundingInfo = this._renderingMesh.getBoundingInfo(); //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n\n\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n\n    return this;\n  };\n  /**\n   * @param collider\n   * @hidden\n   */\n\n\n  SubMesh.prototype._checkCollision = function (collider) {\n    var boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  };\n  /**\n   * Updates the submesh BoundingInfo\n   * @param world defines the world matrix to use to update the bounding info\n   * @returns the submesh\n   */\n\n\n  SubMesh.prototype.updateBoundingInfo = function (world) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n\n    return this;\n  };\n  /**\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is intersecting with the frustum\n   */\n\n\n  SubMesh.prototype.isInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  };\n  /**\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is inside the frustum\n   */\n\n\n  SubMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\n   * Renders the submesh\n   * @param enableAlphaMode defines if alpha needs to be used\n   * @returns the submesh\n   */\n\n\n  SubMesh.prototype.render = function (enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n\n    return this;\n  };\n  /**\n   * @param indices\n   * @param engine\n   * @hidden\n   */\n\n\n  SubMesh.prototype._getLinesIndexBuffer = function (indices, engine) {\n    if (!this._linesIndexBuffer) {\n      var linesIndices = [];\n\n      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n\n    return this._linesIndexBuffer;\n  };\n  /**\n   * Checks if the submesh intersects with a ray\n   * @param ray defines the ray to test\n   * @returns true is the passed ray intersects the submesh bounding box\n   */\n\n\n  SubMesh.prototype.canIntersects = function (ray) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  };\n  /**\n   * Intersects current submesh with a ray\n   * @param ray defines the ray to test\n   * @param positions defines mesh's positions array\n   * @param indices defines mesh's indices array\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns intersection info or null if no intersection\n   */\n\n\n  SubMesh.prototype.intersects = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var material = this.getMaterial();\n\n    if (!material) {\n      return null;\n    }\n\n    var step = 3;\n    var checkStopper = false;\n\n    switch (material.fillMode) {\n      case 3:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n\n      default:\n        break;\n    } // LineMesh first as it's also a Mesh...\n\n\n    if (material.fillMode === 4) {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  };\n  /**\n   * @param ray\n   * @param positions\n   * @param indices\n   * @param intersectionThreshold\n   * @param fastCheck\n   * @hidden\n   */\n\n\n  SubMesh.prototype._intersectLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      var p0 = positions[indices[index]];\n      var p1 = positions[indices[index + 1]];\n      var length_1 = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length_1 < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length_1 < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length_1);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /**\n   * @param ray\n   * @param positions\n   * @param indices\n   * @param intersectionThreshold\n   * @param fastCheck\n   * @hidden\n   */\n\n\n  SubMesh.prototype._intersectUnIndexedLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var length_2 = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length_2 < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length_2 < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length_2);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /**\n   * @param ray\n   * @param positions\n   * @param indices\n   * @param step\n   * @param checkStopper\n   * @param fastCheck\n   * @param trianglePredicate\n   * @hidden\n   */\n\n\n  SubMesh.prototype._intersectTriangles = function (ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    var faceId = -1;\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n      faceId++;\n      var indexA = indices[index];\n      var indexB = indices[index + 1];\n      var indexC = indices[index + 2];\n\n      if (checkStopper && indexC === 0xffffffff) {\n        index += 2;\n        continue;\n      }\n\n      var p0 = positions[indexA];\n      var p1 = positions[indexB];\n      var p2 = positions[indexC]; // stay defensive and don't check against undefined positions.\n\n      if (!p0 || !p1 || !p2) {\n        continue;\n      }\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceId;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /**\n   * @param ray\n   * @param positions\n   * @param indices\n   * @param fastCheck\n   * @param trianglePredicate\n   * @hidden\n   */\n\n\n  SubMesh.prototype._intersectUnIndexedTriangles = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var p2 = positions[index + 2];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._rebuild = function () {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }; // Clone\n\n  /**\n   * Creates a new submesh from the passed mesh\n   * @param newMesh defines the new hosting mesh\n   * @param newRenderingMesh defines an optional rendering mesh\n   * @returns the new submesh\n   */\n\n\n  SubMesh.prototype.clone = function (newMesh, newRenderingMesh) {\n    var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n\n    if (!this.IsGlobal) {\n      var boundingInfo = this.getBoundingInfo();\n\n      if (!boundingInfo) {\n        return result;\n      }\n\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n\n    return result;\n  }; // Dispose\n\n  /**\n   * Release associated resources\n   */\n\n\n  SubMesh.prototype.dispose = function () {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n\n      this._linesIndexBuffer = null;\n    } // Remove from mesh\n\n\n    var index = this._mesh.subMeshes.indexOf(this);\n\n    this._mesh.subMeshes.splice(index, 1);\n\n    this.resetDrawCache();\n  };\n  /**\n   * Gets the class name\n   * @returns the string \"SubMesh\".\n   */\n\n\n  SubMesh.prototype.getClassName = function () {\n    return \"SubMesh\";\n  }; // Statics\n\n  /**\n   * Creates a new submesh from indices data\n   * @param materialIndex the index of the main mesh material\n   * @param startIndex the index where to start the copy in the mesh indices array\n   * @param indexCount the number of indices to copy then from the startIndex\n   * @param mesh the main mesh to create the submesh from\n   * @param renderingMesh the optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns a new submesh\n   */\n\n\n  SubMesh.CreateFromIndices = function (materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    var minVertexIndex = Number.MAX_VALUE;\n    var maxVertexIndex = -Number.MAX_VALUE;\n    var whatWillRender = renderingMesh || mesh;\n    var indices = whatWillRender.getIndices();\n\n    for (var index = startIndex; index < startIndex + indexCount; index++) {\n      var vertexIndex = indices[index];\n\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n  };\n\n  return SubMesh;\n}();\n\nexport { SubMesh };","map":{"version":3,"mappings":"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","names":["VertexBuffer","IntersectionInfo","BoundingInfo","extractMinAndMaxIndexed","DrawWrapper","materialIndex","verticesStart","verticesCount","indexStart","indexCount","mesh","renderingMesh","createBoundingBox","addToMesh","_mesh","_renderingMesh","subMeshes","push","_engine","getScene","getEngine","resetDrawCache","_trianglePlanes","_id","length","refreshBoundingInfo","computeWorldMatrix","Object","SubMesh","_mainDrawWrapperOverride","defines","_getDrawWrapper","_a","drawWrapper","undefined","passId","createIfNotExisting","currentRenderPassId","_drawWrappers","disposeWrapper","dispose","effect","_b","wrapper","materialContext","resetContext","_drawWrapper","setEffect","_removeDrawWrapper","_i","getTotalVertices","IsGlobal","getBoundingInfo","_boundingInfo","boundingInfo","_internalAbstractMeshDataInfo","_actAsRegularMesh","replacementMesh","rootMaterial","getMaterialForRenderPass","material","defaultMaterial","_isMultiMaterial","effectiveMaterial","getSubMaterial","_currentMaterial","data","_lastColliderWorldVertices","geometry","getVerticesData","PositionKind","indices","getIndices","extend","minimum","clone","maximum","boundingBias","reConstruct","collider","_checkCollision","world","update","frustumPlanes","isInFrustum","cullingStrategy","isCompletelyInFrustum","enableAlphaMode","render","engine","_linesIndexBuffer","linesIndices","index","createIndexBuffer","_linesIndexCount","ray","intersectsBox","boundingBox","positions","fastCheck","trianglePredicate","getMaterial","step","checkStopper","fillMode","_intersectUnIndexedLines","intersectionThreshold","_intersectLines","_unIndexed","_intersectUnIndexedTriangles","_intersectTriangles","intersectInfo","p0","p1","length_1","intersectionSegment","distance","faceId","length_2","indexA","indexB","indexC","p2","currentIntersectInfo","intersectsTriangle","newMesh","newRenderingMesh","result","_releaseBuffer","indexOf","splice","startIndex","minVertexIndex","Number","MAX_VALUE","maxVertexIndex","whatWillRender","vertexIndex"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/subMesh.ts"],"sourcesContent":["import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type MaterialDefines = import(\"../Materials/materialDefines\").MaterialDefines;\r\ndeclare type MultiMaterial = import(\"../Materials/multiMaterial\").MultiMaterial;\r\ndeclare type AbstractMesh = import(\"./abstractMesh\").AbstractMesh;\r\ndeclare type Mesh = import(\"./mesh\").Mesh;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: Engine;\r\n    /** @hidden */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @param passId\r\n     * @param createIfNotExisting\r\n     * @hidden\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @param passId\r\n     * @param disposeWrapper\r\n     * @hidden\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true) {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose();\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @param wrapper\r\n     * @hidden\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @hidden */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @hidden */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @hidden */\r\n    public _trianglePlanes: Plane[];\r\n    /** @hidden */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n\r\n    /** @hidden */\r\n    public _renderId = 0;\r\n    /** @hidden */\r\n    public _alphaIndex: number = 0;\r\n    /** @hidden */\r\n    public _distanceToCamera: number = 0;\r\n    /** @hidden */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @return the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (rootMaterial === null || rootMaterial === undefined) {\r\n            return this._mesh.getScene().defaultMaterial;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param collider\r\n     * @hidden\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param indices\r\n     * @param engine\r\n     * @hidden\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const linesIndices = [];\r\n\r\n            for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param ray\r\n     * @param positions\r\n     * @param indices\r\n     * @param intersectionThreshold\r\n     * @param fastCheck\r\n     * @hidden\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @param ray\r\n     * @param positions\r\n     * @param indices\r\n     * @param intersectionThreshold\r\n     * @param fastCheck\r\n     * @hidden\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @param ray\r\n     * @param positions\r\n     * @param indices\r\n     * @param step\r\n     * @param checkStopper\r\n     * @param fastCheck\r\n     * @param trianglePredicate\r\n     * @hidden\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @param ray\r\n     * @param positions\r\n     * @param indices\r\n     * @param fastCheck\r\n     * @param trianglePredicate\r\n     * @hidden\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}