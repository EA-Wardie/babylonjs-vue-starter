{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\n/**\n * Block used to output the final color\n */\n\nvar FragmentOutputBlock =\n/** @class */\nfunction (_super) {\n  __extends(FragmentOutputBlock, _super);\n  /**\n   * Create a new FragmentOutputBlock\n   * @param name defines the block name\n   */\n\n\n  function FragmentOutputBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment, true) || this;\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\n\n\n    _this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\n\n    _this.convertToLinearSpace = false;\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\n\n    _this.useLogarithmicDepth = false;\n\n    _this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\n\n    _this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, true);\n\n    _this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n\n    _this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\n\n    return _this;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  FragmentOutputBlock.prototype.getClassName = function () {\n    return \"FragmentOutputBlock\";\n  };\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n\n  FragmentOutputBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"logarithmicDepthConstant\");\n\n    state._excludeVariableName(\"vFragmentDepth\");\n  };\n\n  Object.defineProperty(FragmentOutputBlock.prototype, \"rgba\", {\n    /**\n     * Gets the rgba input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FragmentOutputBlock.prototype, \"rgb\", {\n    /**\n     * Gets the rgb input component\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FragmentOutputBlock.prototype, \"a\", {\n    /**\n     * Gets the a input component\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  FragmentOutputBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\n  };\n\n  FragmentOutputBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (this.useLogarithmicDepth && mesh) {\n      MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\n    }\n  };\n\n  FragmentOutputBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    var rgba = this.rgba;\n    var rgb = this.rgb;\n    var a = this.a;\n    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\n    state.sharedData.blocksWithDefines.push(this);\n\n    if (this.useLogarithmicDepth) {\n      state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\n\n      state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\n\n      state.sharedData.bindableBlocks.push(this);\n    }\n\n    this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\n    var comments = \"//\".concat(this.name);\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    if (rgba.connectedPoint) {\n      if (a.isConnected) {\n        state.compilationString += \"gl_FragColor = vec4(\".concat(rgba.associatedVariableName, \".rgb, \").concat(a.associatedVariableName, \");\\r\\n\");\n      } else {\n        state.compilationString += \"gl_FragColor = \".concat(rgba.associatedVariableName, \";\\r\\n\");\n      }\n    } else if (rgb.connectedPoint) {\n      var aValue = \"1.0\";\n\n      if (a.connectedPoint) {\n        aValue = a.associatedVariableName;\n      }\n\n      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        state.compilationString += \"gl_FragColor = vec4(\".concat(rgb.associatedVariableName, \", \").concat(rgb.associatedVariableName, \", \").concat(rgb.associatedVariableName, \", \").concat(aValue, \");\\r\\n\");\n      } else {\n        state.compilationString += \"gl_FragColor = vec4(\".concat(rgb.associatedVariableName, \", \").concat(aValue, \");\\r\\n\");\n      }\n    } else {\n      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\n    }\n\n    state.compilationString += \"#ifdef \".concat(this._linearDefineName, \"\\r\\n\");\n    state.compilationString += \"gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef \".concat(this._gammaDefineName, \"\\r\\n\");\n    state.compilationString += \"gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n\n    if (this.useLogarithmicDepth) {\n      state.compilationString += \"gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n\";\n    }\n\n    return this;\n  };\n\n  FragmentOutputBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    codeString += \"\".concat(this._codeVariableName, \".convertToGammaSpace = \").concat(this.convertToGammaSpace, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".convertToLinearSpace = \").concat(this.convertToLinearSpace, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".useLogarithmicDepth = \").concat(this.useLogarithmicDepth, \";\\r\\n\");\n    return codeString;\n  };\n\n  FragmentOutputBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\n    return serializationObject;\n  };\n\n  FragmentOutputBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    var _a;\n\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = serializationObject.convertToLinearSpace;\n    this.useLogarithmicDepth = (_a = serializationObject.useLogarithmicDepth) !== null && _a !== void 0 ? _a : false;\n  };\n\n  __decorate([editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n    notifiers: {\n      update: true\n    }\n  })], FragmentOutputBlock.prototype, \"convertToGammaSpace\", void 0);\n\n  __decorate([editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n    notifiers: {\n      update: true\n    }\n  })], FragmentOutputBlock.prototype, \"convertToLinearSpace\", void 0);\n\n  __decorate([editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")], FragmentOutputBlock.prototype, \"useLogarithmicDepth\", void 0);\n\n  return FragmentOutputBlock;\n}(NodeMaterialBlock);\n\nexport { FragmentOutputBlock };\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","MaterialHelper","__extends","name","_super","Fragment","_this","registerInput","Color4","Color3","Float","rgb","acceptedConnectionPointTypes","push","FragmentOutputBlock","state","_excludeVariableName","Object","_inputs","mesh","nodeMaterial","defines","setValue","_linearDefineName","convertToLinearSpace","_gammaDefineName","convertToGammaSpace","effect","useLogarithmicDepth","BindLogDepth","undefined","getScene","_buildBlock","call","rgba","a","sharedData","hints","needAlphaBlending","isConnected","blocksWithDefines","_emitUniformFromString","_emitVaryingFromString","bindableBlocks","_getFreeDefineName","comments","_emitFunctionFromInclude","connectedPoint","compilationString","associatedVariableName","concat","aValue","type","checks","notConnectedNonOptionalInputs","codeString","_dumpPropertiesCode","_codeVariableName","serializationObject","serialize","scene","rootUrl","_deserialize","_a","__decorate","Boolean","notifiers","update"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\ndeclare type Effect = import(\"../../../effect\").Effect;\r\ndeclare type Mesh = import(\"../../../../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    @editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    @editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (this.useLogarithmicDepth && mesh) {\r\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        if (this.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\r\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n"]},"metadata":{},"sourceType":"module"}