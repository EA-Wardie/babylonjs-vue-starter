{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __assign, __decorate, __extends } from \"tslib\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\n\nAbstractScene.prototype.getGlowLayerByName = function (name) {\n  for (var index = 0; index < this.effectLayers.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\n *\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\n *\n * Documentation: https://doc.babylonjs.com/how_to/glow_layer\n */\n\n\nvar GlowLayer =\n/** @class */\nfunction (_super) {\n  __extends(GlowLayer, _super);\n  /**\n   * Instantiates a new glow Layer and references it to the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\n   */\n\n\n  function GlowLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._intensity = 1.0;\n    _this._includedOnlyMeshes = [];\n    _this._excludedMeshes = [];\n    _this._meshesUsingTheirOwnMaterials = [];\n    _this.neutralColor = new Color4(0, 0, 0, 1); // Adapt options\n\n    _this._options = __assign({\n      mainTextureRatio: GlowLayer.DefaultTextureRatio,\n      blurKernelSize: 32,\n      mainTextureFixedSize: undefined,\n      camera: null,\n      mainTextureSamples: 1,\n      renderingGroupId: -1,\n      ldrMerge: false,\n      alphaBlendingMode: 1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: _this._options.alphaBlendingMode,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(GlowLayer.prototype, \"blurKernelSize\", {\n    /**\n     * Gets the kernel size of the blur.\n     */\n    get: function get() {\n      return this._horizontalBlurPostprocess1.kernel;\n    },\n\n    /**\n     * Sets the kernel size of the blur.\n     */\n    set: function set(value) {\n      this._horizontalBlurPostprocess1.kernel = value;\n      this._verticalBlurPostprocess1.kernel = value;\n      this._horizontalBlurPostprocess2.kernel = value;\n      this._verticalBlurPostprocess2.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlowLayer.prototype, \"intensity\", {\n    /**\n     * Gets the glow intensity.\n     */\n    get: function get() {\n      return this._intensity;\n    },\n\n    /**\n     * Sets the glow intensity.\n     */\n    set: function set(value) {\n      this._intensity = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the effect name of the layer.\n   * @return The effect name\n   */\n\n  GlowLayer.prototype.getEffectName = function () {\n    return GlowLayer.EffectName;\n  };\n  /**\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   */\n\n\n  GlowLayer.prototype._createMergeEffect = function () {\n    var defines = \"#define EMISSIVE \\n\";\n\n    if (this._options.ldrMerge) {\n      defines += \"#define LDR \\n\";\n    } // Effect\n\n\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\n  };\n  /**\n   * Creates the render target textures and post processes used in the glow layer.\n   */\n\n\n  GlowLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width;\n    var blurTextureHeight = this._mainTextureDesiredSize.height;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture1.renderParticles = false;\n    this._blurTexture1.ignoreCameraViewport = true;\n    var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\n    var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\n    this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, this._scene, false, true, textureType);\n    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture2.renderParticles = false;\n    this._blurTexture2.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture1, this._blurTexture2];\n    this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess1.width = blurTextureWidth;\n    this._horizontalBlurPostprocess1.height = blurTextureHeight;\n    this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\n\n    this._horizontalBlurPostprocess1.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._mainTexture);\n    });\n\n    this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2.width = blurTextureWidth2;\n    this._horizontalBlurPostprocess2.height = blurTextureHeight2;\n    this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\n\n    this._horizontalBlurPostprocess2.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._blurTexture1);\n    });\n\n    this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\n    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._mainTexture.samples = this._options.mainTextureSamples;\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      var internalTexture = _this._blurTexture1.renderTarget;\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses1, internalTexture, true);\n\n        var internalTexture2 = _this._blurTexture2.renderTarget;\n\n        if (internalTexture2) {\n          _this._scene.postProcessManager.directRender(_this._postProcesses2, internalTexture2, true);\n        }\n\n        _this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);\n      }\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @return true if ready otherwise, false\n   */\n\n\n  GlowLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh) {\n      return false;\n    }\n\n    var emissiveTexture = material.emissiveTexture;\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\n   * Returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n\n\n  GlowLayer.prototype.needStencil = function () {\n    return false;\n  };\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n\n\n  GlowLayer.prototype._canRenderMesh = function (mesh, material) {\n    return true;\n  };\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   */\n\n\n  GlowLayer.prototype._internalRender = function (effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture1);\n    effect.setTexture(\"textureSampler2\", this._blurTexture2);\n    effect.setFloat(\"offset\", this._intensity); // Cache\n\n    var engine = this._engine;\n    var previousStencilBuffer = engine.getStencilBuffer(); // Draw order\n\n    engine.setStencilBuffer(false);\n    engine.drawElementsType(Material.TriangleFillMode, 0, 6); // Draw order\n\n    engine.setStencilBuffer(previousStencilBuffer);\n  };\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n\n\n  GlowLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var _a;\n\n    var textureLevel = 1.0;\n\n    if (this.customEmissiveTextureSelector) {\n      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\n    } else {\n      if (material) {\n        this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n        if (this._emissiveTextureAndColor.texture) {\n          textureLevel = this._emissiveTextureAndColor.texture.level;\n        }\n      } else {\n        this._emissiveTextureAndColor.texture = null;\n      }\n    }\n\n    if (this.customEmissiveColorSelector) {\n      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\n    } else {\n      if (material.emissiveColor) {\n        var emissiveIntensity = (_a = material.emissiveIntensity) !== null && _a !== void 0 ? _a : 1;\n        textureLevel *= emissiveIntensity;\n\n        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);\n      } else {\n        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }\n    }\n  };\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n\n\n  GlowLayer.prototype._shouldRenderMesh = function (mesh) {\n    return this.hasMesh(mesh);\n  };\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n\n\n  GlowLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define GLOW\");\n  };\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to exclude from the glow layer\n   */\n\n\n  GlowLayer.prototype.addExcludedMesh = function (mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n\n\n  GlowLayer.prototype.removeExcludedMesh = function (mesh) {\n    var index = this._excludedMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  };\n  /**\n   * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\n   * @param mesh The mesh to include in the glow layer\n   */\n\n\n  GlowLayer.prototype.addIncludedOnlyMesh = function (mesh) {\n    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._includedOnlyMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\n   * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n\n\n  GlowLayer.prototype.removeIncludedOnlyMesh = function (mesh) {\n    var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._includedOnlyMeshes.splice(index, 1);\n    }\n  };\n  /**\n   * Determine if a given mesh will be used in the glow layer\n   * @param mesh The mesh to test\n   * @returns true if the mesh will be highlighted by the current glow layer\n   */\n\n\n  GlowLayer.prototype.hasMesh = function (mesh) {\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    } // Included Mesh\n\n\n    if (this._includedOnlyMeshes.length) {\n      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\n    } // Excluded Mesh\n\n\n    if (this._excludedMeshes.length) {\n      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\n    }\n\n    return true;\n  };\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   */\n\n\n  GlowLayer.prototype._useMeshMaterial = function (mesh) {\n    if (this._meshesUsingTheirOwnMaterials.length == 0) {\n      return false;\n    }\n\n    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\n  };\n  /**\n   * Add a mesh to be rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to use its material\n   */\n\n\n  GlowLayer.prototype.referenceMeshToUseItsOwnMaterial = function (mesh) {\n    var _this = this;\n\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n\n    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\n\n    mesh.onDisposeObservable.add(function () {\n      _this._disposeMesh(mesh);\n    });\n  };\n  /**\n   * Remove a mesh from being rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to not use its material\n   */\n\n\n  GlowLayer.prototype.unReferenceMeshFromUsingItsOwnMaterial = function (mesh) {\n    var index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n\n    while (index >= 0) {\n      this._meshesUsingTheirOwnMaterials.splice(index, 1);\n\n      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    }\n\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n  };\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @hidden\n   */\n\n\n  GlowLayer.prototype._disposeMesh = function (mesh) {\n    this.removeIncludedOnlyMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n\n\n  GlowLayer.prototype.getClassName = function () {\n    return \"GlowLayer\";\n  };\n  /**\n   * Serializes this glow layer\n   * @returns a serialized glow layer object\n   */\n\n\n  GlowLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.GlowLayer\";\n    var index; // Included meshes\n\n    serializationObject.includedMeshes = [];\n\n    if (this._includedOnlyMeshes.length) {\n      for (index = 0; index < this._includedOnlyMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\n\n        if (mesh) {\n          serializationObject.includedMeshes.push(mesh.id);\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes.length) {\n      for (index = 0; index < this._excludedMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\n\n        if (mesh) {\n          serializationObject.excludedMeshes.push(mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Creates a Glow Layer from parsed glow layer data\n   * @param parsedGlowLayer defines glow layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the glow layer information\n   * @returns a parsed Glow Layer\n   */\n\n\n  GlowLayer.Parse = function (parsedGlowLayer, scene, rootUrl) {\n    var gl = SerializationHelper.Parse(function () {\n      return new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options);\n    }, parsedGlowLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        gl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\n      var mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\n\n      if (mesh) {\n        gl.addIncludedOnlyMesh(mesh);\n      }\n    }\n\n    return gl;\n  };\n  /**\n   * Effect Name of the layer.\n   */\n\n\n  GlowLayer.EffectName = \"GlowLayer\";\n  /**\n   * The default blur kernel size used for the glow.\n   */\n\n  GlowLayer.DefaultBlurKernelSize = 32;\n  /**\n   * The default texture size ratio used for the glow.\n   */\n\n  GlowLayer.DefaultTextureRatio = 0.5;\n\n  __decorate([serialize()], GlowLayer.prototype, \"blurKernelSize\", null);\n\n  __decorate([serialize()], GlowLayer.prototype, \"intensity\", null);\n\n  __decorate([serialize(\"options\")], GlowLayer.prototype, \"_options\", void 0);\n\n  return GlowLayer;\n}(EffectLayer);\n\nexport { GlowLayer };\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Vector2","VertexBuffer","Texture","RenderTargetTexture","Material","BlurPostProcess","EffectLayer","AbstractScene","RegisterClass","Engine","Color4","prototype","getGlowLayerByName","name","index","effectLayers","length","getEffectName","GlowLayer","EffectName","__extends","scene","options","_super","_this","neutralColor","_options","__assign","mainTextureRatio","DefaultTextureRatio","blurKernelSize","mainTextureFixedSize","undefined","camera","mainTextureSamples","renderingGroupId","ldrMerge","alphaBlendingMode","_init","Object","_horizontalBlurPostprocess1","kernel","value","_verticalBlurPostprocess1","_horizontalBlurPostprocess2","_verticalBlurPostprocess2","_intensity","defines","_engine","createEffect","PositionKind","blurTextureWidth","_mainTextureDesiredSize","width","blurTextureHeight","height","needPOTTextures","GetExponentOfTwo","_maxSize","textureType","getCaps","textureHalfFloatRender","_blurTexture1","_scene","wrapU","CLAMP_ADDRESSMODE","wrapV","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","ignoreCameraViewport","blurTextureWidth2","Math","floor","blurTextureHeight2","_blurTexture2","_textures","getEngine","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_mainTexture","_postProcesses","_postProcesses1","_postProcesses2","samples","onAfterUnbindObservable","internalTexture","renderTarget","postProcessManager","directRender","internalTexture2","unBindFramebuffer","map","pp","autoClear","subMesh","useInstances","material","getMaterial","mesh","getRenderingMesh","emissiveTexture","_isReady","call","setFloat","engine","previousStencilBuffer","getStencilBuffer","setStencilBuffer","drawElementsType","TriangleFillMode","textureLevel","customEmissiveTextureSelector","_emissiveTextureAndColor","texture","level","customEmissiveColorSelector","color","emissiveColor","emissiveIntensity","_a","set","r","g","b","alpha","a","hasMesh","push","_excludedMeshes","indexOf","uniqueId","splice","_includedOnlyMeshes","_meshesUsingTheirOwnMaterials","resetDrawCache","renderPassId","onDisposeObservable","_disposeMesh","removeIncludedOnlyMesh","removeExcludedMesh","serializationObject","Serialize","customType","includedMeshes","getMeshByUniqueId","id","excludedMeshes","parsedGlowLayer","rootUrl","gl","Parse","getMeshById","addExcludedMesh","addIncludedOnlyMesh","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/glowLayer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { PBRMaterial } from \"../Materials/PBR/pbrMaterial\";\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @return The highlight layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getGlowLayerByName = function (name: string): Nullable<GlowLayer> {\r\n    for (let index = 0; index < this.effectLayers.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * How big is the kernel of the blur texture.\r\n     */\r\n    blurKernelSize: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Enable MSAA by choosing the number of samples.\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Forces the merge step to be done in ldr (clamp values > 1)\r\n     */\r\n    ldrMerge?: boolean;\r\n\r\n    /**\r\n     * Defines the blend mode used by the merge\r\n     */\r\n    alphaBlendingMode?: number;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/how_to/glow_layer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        this._horizontalBlurPostprocess1.kernel = value;\r\n        this._verticalBlurPostprocess1.kernel = value;\r\n        this._horizontalBlurPostprocess2.kernel = value;\r\n        this._verticalBlurPostprocess2.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._horizontalBlurPostprocess1.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    private _options: IGlowLayerOptions;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n\r\n    private _includedOnlyMeshes: number[] = [];\r\n    private _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        let defines = \"#define EMISSIVE \\n\";\r\n        if (this._options.ldrMerge) {\r\n            defines += \"#define LDR \\n\";\r\n        }\r\n\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerHBP1\",\r\n            new Vector2(1.0, 0),\r\n            this._options.blurKernelSize / 2,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerVBP1\",\r\n            new Vector2(0, 1.0),\r\n            this._options.blurKernelSize / 2,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerHBP2\",\r\n            new Vector2(1.0, 0),\r\n            this._options.blurKernelSize / 2,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerVBP2\",\r\n            new Vector2(0, 1.0),\r\n            this._options.blurKernelSize / 2,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            const internalTexture = this._blurTexture1.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\r\n\r\n                const internalTexture2 = this._blurTexture2.renderTarget;\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        const emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        const previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        let textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            } else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                const emissiveIntensity = (<PBRMaterial>material).emissiveIntensity ?? 1;\r\n                textureLevel *= emissiveIntensity;\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha\r\n                );\r\n            } else {\r\n                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n\r\n        mesh.onDisposeObservable.add(() => {\r\n            this._disposeMesh(mesh as Mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @hidden\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        let index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        if (this._includedOnlyMeshes.length) {\r\n            for (index = 0; index < this._includedOnlyMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes.length) {\r\n            for (index = 0; index < this._excludedMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\r\n"]},"metadata":{},"sourceType":"module"}