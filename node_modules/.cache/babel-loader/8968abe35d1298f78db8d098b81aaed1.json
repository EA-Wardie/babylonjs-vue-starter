{"ast":null,"code":"import \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tags } from \"../Misc/tags.js\";\nimport { Quaternion, Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"./devTools.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nvar __decoratorInitialStore = {};\nvar __mergedStore = {};\n\nvar _copySource = function _copySource(creationFunction, source, instanciate) {\n  var destination = creationFunction(); // Tags\n\n  if (Tags) {\n    Tags.AddTagsTo(destination, source.tags);\n  }\n\n  var classStore = getMergedStore(destination); // Properties\n\n  for (var property in classStore) {\n    var propertyDescriptor = classStore[property];\n    var sourceProperty = source[property];\n    var propertyType = propertyDescriptor.type;\n\n    if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n      switch (propertyType) {\n        case 0: // Value\n\n        case 6: // Mesh reference\n\n        case 11:\n          // Camera reference\n          destination[property] = sourceProperty;\n          break;\n\n        case 1:\n          // Texture\n          destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\n          break;\n\n        case 2: // Color3\n\n        case 3: // FresnelParameters\n\n        case 4: // Vector2\n\n        case 5: // Vector3\n\n        case 7: // Color Curves\n\n        case 10: // Quaternion\n\n        case 12:\n          // Matrix\n          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();\n          break;\n      }\n    }\n  }\n\n  return destination;\n};\n\nfunction getDirectStore(target) {\n  var classKey = target.getClassName();\n\n  if (!__decoratorInitialStore[classKey]) {\n    __decoratorInitialStore[classKey] = {};\n  }\n\n  return __decoratorInitialStore[classKey];\n}\n/**\n * Return the list of properties flagged as serializable\n * @param target host object\n */\n\n\nfunction getMergedStore(target) {\n  var classKey = target.getClassName();\n\n  if (__mergedStore[classKey]) {\n    return __mergedStore[classKey];\n  }\n\n  __mergedStore[classKey] = {};\n  var store = __mergedStore[classKey];\n  var currentTarget = target;\n  var currentKey = classKey;\n\n  while (currentKey) {\n    var initialStore = __decoratorInitialStore[currentKey];\n\n    for (var property in initialStore) {\n      store[property] = initialStore[property];\n    }\n\n    var parent_1 = void 0;\n    var done = false;\n\n    do {\n      parent_1 = Object.getPrototypeOf(currentTarget);\n\n      if (!parent_1.getClassName) {\n        done = true;\n        break;\n      }\n\n      if (parent_1.getClassName() !== currentKey) {\n        break;\n      }\n\n      currentTarget = parent_1;\n    } while (parent_1);\n\n    if (done) {\n      break;\n    }\n\n    currentKey = parent_1.getClassName();\n    currentTarget = parent_1;\n  }\n\n  return store;\n}\n\nfunction generateSerializableMember(type, sourceName) {\n  return function (target, propertyKey) {\n    var classStore = getDirectStore(target);\n\n    if (!classStore[propertyKey]) {\n      classStore[propertyKey] = {\n        type: type,\n        sourceName: sourceName\n      };\n    }\n  };\n}\n\nfunction generateExpandMember(setCallback, targetKey) {\n  if (targetKey === void 0) {\n    targetKey = null;\n  }\n\n  return function (target, propertyKey) {\n    var key = targetKey || \"_\" + propertyKey;\n    Object.defineProperty(target, propertyKey, {\n      get: function get() {\n        return this[key];\n      },\n      set: function set(value) {\n        // does this object (i.e. vector3) has an equals function? use it!\n        // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\n        if (typeof this.equals === \"function\") {\n          if (this.equals(value)) {\n            return;\n          }\n        }\n\n        if (this[key] === value) {\n          return;\n        }\n\n        this[key] = value;\n        target[setCallback].apply(this);\n      },\n      enumerable: true,\n      configurable: true\n    });\n  };\n}\n\nexport function expandToProperty(callback, targetKey) {\n  if (targetKey === void 0) {\n    targetKey = null;\n  }\n\n  return generateExpandMember(callback, targetKey);\n}\nexport function serialize(sourceName) {\n  return generateSerializableMember(0, sourceName); // value member\n}\nexport function serializeAsTexture(sourceName) {\n  return generateSerializableMember(1, sourceName); // texture member\n}\nexport function serializeAsColor3(sourceName) {\n  return generateSerializableMember(2, sourceName); // color3 member\n}\nexport function serializeAsFresnelParameters(sourceName) {\n  return generateSerializableMember(3, sourceName); // fresnel parameters member\n}\nexport function serializeAsVector2(sourceName) {\n  return generateSerializableMember(4, sourceName); // vector2 member\n}\nexport function serializeAsVector3(sourceName) {\n  return generateSerializableMember(5, sourceName); // vector3 member\n}\nexport function serializeAsMeshReference(sourceName) {\n  return generateSerializableMember(6, sourceName); // mesh reference member\n}\nexport function serializeAsColorCurves(sourceName) {\n  return generateSerializableMember(7, sourceName); // color curves\n}\nexport function serializeAsColor4(sourceName) {\n  return generateSerializableMember(8, sourceName); // color 4\n}\nexport function serializeAsImageProcessingConfiguration(sourceName) {\n  return generateSerializableMember(9, sourceName); // image processing\n}\nexport function serializeAsQuaternion(sourceName) {\n  return generateSerializableMember(10, sourceName); // quaternion member\n}\nexport function serializeAsMatrix(sourceName) {\n  return generateSerializableMember(12, sourceName); // matrix member\n}\n/**\n * Decorator used to define property that can be serialized as reference to a camera\n * @param sourceName defines the name of the property to decorate\n */\n\nexport function serializeAsCameraReference(sourceName) {\n  return generateSerializableMember(11, sourceName); // camera reference member\n}\n/**\n * Class used to help serialization objects\n */\n\nvar SerializationHelper =\n/** @class */\nfunction () {\n  function SerializationHelper() {}\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n\n\n  SerializationHelper.AppendSerializedAnimations = function (source, destination) {\n    if (source.animations) {\n      destination.animations = [];\n\n      for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\n        var animation = source.animations[animationIndex];\n        destination.animations.push(animation.serialize());\n      }\n    }\n  };\n  /**\n   * Static function used to serialized a specific entity\n   * @param entity defines the entity to serialize\n   * @param serializationObject defines the optional target object where serialization data will be stored\n   * @returns a JSON compatible object representing the serialization of the entity\n   */\n\n\n  SerializationHelper.Serialize = function (entity, serializationObject) {\n    if (!serializationObject) {\n      serializationObject = {};\n    } // Tags\n\n\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(entity);\n    }\n\n    var serializedProperties = getMergedStore(entity); // Properties\n\n    for (var property in serializedProperties) {\n      var propertyDescriptor = serializedProperties[property];\n      var targetPropertyName = propertyDescriptor.sourceName || property;\n      var propertyType = propertyDescriptor.type;\n      var sourceProperty = entity[property];\n\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        switch (propertyType) {\n          case 0:\n            // Value\n            serializationObject[targetPropertyName] = sourceProperty;\n            break;\n\n          case 1:\n            // Texture\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n\n          case 2:\n            // Color3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n\n          case 3:\n            // FresnelParameters\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n\n          case 4:\n            // Vector2\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n\n          case 5:\n            // Vector3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n\n          case 6:\n            // Mesh reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n\n          case 7:\n            // Color Curves\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n\n          case 8:\n            // Color 4\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n\n          case 9:\n            // Image Processing\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n\n          case 10:\n            // Quaternion\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n\n          case 11:\n            // Camera reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n\n          case 12:\n            // Matrix\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Creates a new entity from a serialization data object\n   * @param creationFunction defines a function used to instanciated the new entity\n   * @param source defines the source serialization data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url for resources\n   * @returns a new entity\n   */\n\n\n  SerializationHelper.Parse = function (creationFunction, source, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = null;\n    }\n\n    var destination = creationFunction();\n\n    if (!rootUrl) {\n      rootUrl = \"\";\n    } // Tags\n\n\n    if (Tags) {\n      Tags.AddTagsTo(destination, source.tags);\n    }\n\n    var classStore = getMergedStore(destination); // Properties\n\n    for (var property in classStore) {\n      var propertyDescriptor = classStore[property];\n      var sourceProperty = source[propertyDescriptor.sourceName || property];\n      var propertyType = propertyDescriptor.type;\n\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        var dest = destination;\n\n        switch (propertyType) {\n          case 0:\n            // Value\n            dest[property] = sourceProperty;\n            break;\n\n          case 1:\n            // Texture\n            if (scene) {\n              dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\n            }\n\n            break;\n\n          case 2:\n            // Color3\n            dest[property] = Color3.FromArray(sourceProperty);\n            break;\n\n          case 3:\n            // FresnelParameters\n            dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\n            break;\n\n          case 4:\n            // Vector2\n            dest[property] = Vector2.FromArray(sourceProperty);\n            break;\n\n          case 5:\n            // Vector3\n            dest[property] = Vector3.FromArray(sourceProperty);\n            break;\n\n          case 6:\n            // Mesh reference\n            if (scene) {\n              dest[property] = scene.getLastMeshById(sourceProperty);\n            }\n\n            break;\n\n          case 7:\n            // Color Curves\n            dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\n            break;\n\n          case 8:\n            // Color 4\n            dest[property] = Color4.FromArray(sourceProperty);\n            break;\n\n          case 9:\n            // Image Processing\n            dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\n            break;\n\n          case 10:\n            // Quaternion\n            dest[property] = Quaternion.FromArray(sourceProperty);\n            break;\n\n          case 11:\n            // Camera reference\n            if (scene) {\n              dest[property] = scene.getCameraById(sourceProperty);\n            }\n\n            break;\n\n          case 12:\n            // Matrix\n            dest[property] = Matrix.FromArray(sourceProperty);\n            break;\n        }\n      }\n    }\n\n    return destination;\n  };\n  /**\n   * Clones an object\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @returns the cloned object\n   */\n\n\n  SerializationHelper.Clone = function (creationFunction, source) {\n    return _copySource(creationFunction, source, false);\n  };\n  /**\n   * Instanciates a new object based on a source one (some data will be shared between both object)\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @returns the new object\n   */\n\n\n  SerializationHelper.Instanciate = function (creationFunction, source) {\n    return _copySource(creationFunction, source, true);\n  };\n  /**\n   * Gets or sets a boolean to indicate if the UniqueId property should be serialized\n   */\n\n\n  SerializationHelper.AllowLoadingUniqueId = false;\n  /**\n   * @param sourceProperty\n   * @hidden\n   */\n\n  SerializationHelper._ImageProcessingConfigurationParser = function (sourceProperty) {\n    throw _WarnImport(\"ImageProcessingConfiguration\");\n  };\n  /**\n   * @param sourceProperty\n   * @hidden\n   */\n\n\n  SerializationHelper._FresnelParametersParser = function (sourceProperty) {\n    throw _WarnImport(\"FresnelParameters\");\n  };\n  /**\n   * @param sourceProperty\n   * @hidden\n   */\n\n\n  SerializationHelper._ColorCurvesParser = function (sourceProperty) {\n    throw _WarnImport(\"ColorCurves\");\n  };\n  /**\n   * @param sourceProperty\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  SerializationHelper._TextureParser = function (sourceProperty, scene, rootUrl) {\n    throw _WarnImport(\"Texture\");\n  };\n\n  return SerializationHelper;\n}();\n\nexport { SerializationHelper };\n/**\n * Decorator used to redirect a function to a native implementation if available.\n * @param target\n * @param propertyKey\n * @param descriptor\n * @param predicate\n * @hidden\n */\n\nexport function nativeOverride(target, propertyKey, descriptor, predicate) {\n  // Cache the original JS function for later.\n  var jsFunc = descriptor.value; // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\n\n  descriptor.value = function () {\n    var params = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    } // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\n\n\n    var func = jsFunc; // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\n\n    if (typeof _native !== \"undefined\" && _native[propertyKey]) {\n      var nativeFunc_1 = _native[propertyKey]; // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\n\n      if (predicate) {\n        // The resolved function will execute the predicate and then either execute the native function or the JS function.\n        func = function func() {\n          var params = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n          }\n\n          return predicate.apply(void 0, params) ? nativeFunc_1.apply(void 0, params) : jsFunc.apply(void 0, params);\n        };\n      } else {\n        // The resolved function will directly execute the native function.\n        func = nativeFunc_1;\n      }\n    } // Override the JS function again with the final resolved target function.\n\n\n    target[propertyKey] = func; // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\n    // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\n\n    return func.apply(void 0, params);\n  };\n}\n/**\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\n * @param predicate\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\n *          public someMethod(arg1: string, arg2: number): string {\n * @hidden\n */\n\nnativeOverride.filter = function (predicate) {\n  return function (target, propertyKey, descriptor) {\n    return nativeOverride(target, propertyKey, descriptor, predicate);\n  };\n};","map":{"version":3,"mappings":"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","names":["Tags","Quaternion","Vector2","Vector3","Matrix","_WarnImport","Color4","Color3","__decoratorInitialStore","__mergedStore","_copySource","creationFunction","source","instanciate","destination","AddTagsTo","tags","classStore","getMergedStore","property","propertyDescriptor","sourceProperty","propertyType","type","undefined","SerializationHelper","AllowLoadingUniqueId","isRenderTarget","clone","getDirectStore","target","classKey","getClassName","store","currentTarget","currentKey","initialStore","parent_1","done","Object","getPrototypeOf","generateSerializableMember","sourceName","propertyKey","generateExpandMember","setCallback","targetKey","key","defineProperty","get","set","value","equals","apply","enumerable","configurable","expandToProperty","callback","serialize","serializeAsTexture","serializeAsColor3","serializeAsFresnelParameters","serializeAsVector2","serializeAsVector3","serializeAsMeshReference","serializeAsColorCurves","serializeAsColor4","serializeAsImageProcessingConfiguration","serializeAsQuaternion","serializeAsMatrix","serializeAsCameraReference","animations","animationIndex","length","animation","push","entity","serializationObject","GetTags","serializedProperties","targetPropertyName","asArray","id","scene","rootUrl","dest","_TextureParser","FromArray","_FresnelParametersParser","getLastMeshById","_ColorCurvesParser","_ImageProcessingConfigurationParser","getCameraById","nativeOverride","descriptor","predicate","jsFunc","params","func","_native","nativeFunc_1","filter"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/decorators.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Quaternion, Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\n\r\ndeclare type ImageProcessingConfiguration = import(\"../Materials/imageProcessingConfiguration\").ImageProcessingConfiguration;\r\ndeclare type FresnelParameters = import(\"../Materials/fresnelParameters\").FresnelParameters;\r\ndeclare type ColorCurves = import(\"../Materials/colorCurves\").ColorCurves;\r\ndeclare type BaseTexture = import(\"../Materials/Textures/baseTexture\").BaseTexture;\r\n\r\nconst __decoratorInitialStore = {};\r\nconst __mergedStore = {};\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags) {\r\n        Tags.AddTagsTo(destination, (<any>source).tags);\r\n    }\r\n\r\n    const classStore = getMergedStore(destination);\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\nfunction getDirectStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if (!(<any>__decoratorInitialStore)[classKey]) {\r\n        (<any>__decoratorInitialStore)[classKey] = {};\r\n    }\r\n\r\n    return (<any>__decoratorInitialStore)[classKey];\r\n}\r\n\r\n/**\r\n * Return the list of properties flagged as serializable\r\n * @param target host object\r\n */\r\nfunction getMergedStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if ((<any>__mergedStore)[classKey]) {\r\n        return (<any>__mergedStore)[classKey];\r\n    }\r\n\r\n    (<any>__mergedStore)[classKey] = {};\r\n\r\n    const store = (<any>__mergedStore)[classKey];\r\n    let currentTarget = target;\r\n    let currentKey = classKey;\r\n    while (currentKey) {\r\n        const initialStore = (<any>__decoratorInitialStore)[currentKey];\r\n        for (const property in initialStore) {\r\n            store[property] = initialStore[property];\r\n        }\r\n\r\n        let parent: any;\r\n        let done = false;\r\n\r\n        do {\r\n            parent = Object.getPrototypeOf(currentTarget);\r\n            if (!parent.getClassName) {\r\n                done = true;\r\n                break;\r\n            }\r\n\r\n            if (parent.getClassName() !== currentKey) {\r\n                break;\r\n            }\r\n\r\n            currentTarget = parent;\r\n        } while (parent);\r\n\r\n        if (done) {\r\n            break;\r\n        }\r\n\r\n        currentKey = parent.getClassName();\r\n        currentTarget = parent;\r\n    }\r\n\r\n    return store;\r\n}\r\n\r\nfunction generateSerializableMember(type: number, sourceName?: string) {\r\n    return (target: any, propertyKey: string | symbol) => {\r\n        const classStore = getDirectStore(target);\r\n\r\n        if (!classStore[propertyKey]) {\r\n            classStore[propertyKey] = { type: type, sourceName: sourceName };\r\n        }\r\n    };\r\n}\r\n\r\nfunction generateExpandMember(setCallback: string, targetKey: Nullable<string> = null) {\r\n    return (target: any, propertyKey: string) => {\r\n        const key = targetKey || \"_\" + propertyKey;\r\n        Object.defineProperty(target, propertyKey, {\r\n            get: function (this: any) {\r\n                return this[key];\r\n            },\r\n            set: function (this: any, value) {\r\n                // does this object (i.e. vector3) has an equals function? use it!\r\n                // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\r\n                if (typeof this.equals === \"function\") {\r\n                    if (this.equals(value)) {\r\n                        return;\r\n                    }\r\n                }\r\n                if (this[key] === value) {\r\n                    return;\r\n                }\r\n                this[key] = value;\r\n\r\n                target[setCallback].apply(this);\r\n            },\r\n            enumerable: true,\r\n            configurable: true,\r\n        });\r\n    };\r\n}\r\n\r\nexport function expandToProperty(callback: string, targetKey: Nullable<string> = null) {\r\n    return generateExpandMember(callback, targetKey);\r\n}\r\n\r\nexport function serialize(sourceName?: string) {\r\n    return generateSerializableMember(0, sourceName); // value member\r\n}\r\n\r\nexport function serializeAsTexture(sourceName?: string) {\r\n    return generateSerializableMember(1, sourceName); // texture member\r\n}\r\n\r\nexport function serializeAsColor3(sourceName?: string) {\r\n    return generateSerializableMember(2, sourceName); // color3 member\r\n}\r\n\r\nexport function serializeAsFresnelParameters(sourceName?: string) {\r\n    return generateSerializableMember(3, sourceName); // fresnel parameters member\r\n}\r\n\r\nexport function serializeAsVector2(sourceName?: string) {\r\n    return generateSerializableMember(4, sourceName); // vector2 member\r\n}\r\n\r\nexport function serializeAsVector3(sourceName?: string) {\r\n    return generateSerializableMember(5, sourceName); // vector3 member\r\n}\r\n\r\nexport function serializeAsMeshReference(sourceName?: string) {\r\n    return generateSerializableMember(6, sourceName); // mesh reference member\r\n}\r\n\r\nexport function serializeAsColorCurves(sourceName?: string) {\r\n    return generateSerializableMember(7, sourceName); // color curves\r\n}\r\n\r\nexport function serializeAsColor4(sourceName?: string) {\r\n    return generateSerializableMember(8, sourceName); // color 4\r\n}\r\n\r\nexport function serializeAsImageProcessingConfiguration(sourceName?: string) {\r\n    return generateSerializableMember(9, sourceName); // image processing\r\n}\r\n\r\nexport function serializeAsQuaternion(sourceName?: string) {\r\n    return generateSerializableMember(10, sourceName); // quaternion member\r\n}\r\n\r\nexport function serializeAsMatrix(sourceName?: string) {\r\n    return generateSerializableMember(12, sourceName); // matrix member\r\n}\r\n\r\n/**\r\n * Decorator used to define property that can be serialized as reference to a camera\r\n * @param sourceName defines the name of the property to decorate\r\n */\r\nexport function serializeAsCameraReference(sourceName?: string) {\r\n    return generateSerializableMember(11, sourceName); // camera reference member\r\n}\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @param sourceProperty\r\n     * @hidden\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @param sourceProperty\r\n     * @hidden\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @param sourceProperty\r\n     * @hidden\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @param sourceProperty\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = getMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        const classStore = getMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, false);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n\r\n/** @hidden */\r\ndeclare const _native: any;\r\n\r\n/**\r\n * Decorator used to redirect a function to a native implementation if available.\r\n * @param target\r\n * @param propertyKey\r\n * @param descriptor\r\n * @param predicate\r\n * @hidden\r\n */\r\nexport function nativeOverride<T extends (...params: any[]) => boolean>(\r\n    target: any,\r\n    propertyKey: string,\r\n    descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>,\r\n    predicate?: T\r\n) {\r\n    // Cache the original JS function for later.\r\n    const jsFunc = descriptor.value!;\r\n\r\n    // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\r\n    descriptor.value = (...params: Parameters<T>): unknown => {\r\n        // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\r\n        let func = jsFunc;\r\n\r\n        // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\r\n        if (typeof _native !== \"undefined\" && _native[propertyKey]) {\r\n            const nativeFunc = _native[propertyKey] as (...params: Parameters<T>) => unknown;\r\n            // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\r\n            if (predicate) {\r\n                // The resolved function will execute the predicate and then either execute the native function or the JS function.\r\n                func = (...params: Parameters<T>) => (predicate(...params) ? nativeFunc(...params) : jsFunc(...params));\r\n            } else {\r\n                // The resolved function will directly execute the native function.\r\n                func = nativeFunc;\r\n            }\r\n        }\r\n\r\n        // Override the JS function again with the final resolved target function.\r\n        target[propertyKey] = func;\r\n\r\n        // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\r\n        // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\r\n        return func(...params);\r\n    };\r\n}\r\n\r\n/**\r\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\r\n * @param predicate\r\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\r\n *          public someMethod(arg1: string, arg2: number): string {\r\n * @hidden\r\n */\r\nnativeOverride.filter = function <T extends (...params: any) => boolean>(predicate: T) {\r\n    return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>) =>\r\n        nativeOverride(target, propertyKey, descriptor, predicate);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}