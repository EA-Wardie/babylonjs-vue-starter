{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PivotTools } from \"../Misc/pivotTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Bounding box gizmo\n */\n\nvar BoundingBoxGizmo =\n/** @class */\nfunction (_super) {\n  __extends(BoundingBoxGizmo, _super);\n  /**\n   * Creates an BoundingBoxGizmo\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n\n\n  function BoundingBoxGizmo(color, gizmoLayer) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._boundingDimensions = new Vector3(1, 1, 1);\n    _this._renderObserver = null;\n    _this._pointerObserver = null;\n    _this._scaleDragSpeed = 0.2;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3(0, 0, 0);\n    _this._tmpRotationMatrix = new Matrix();\n    /**\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\n     */\n\n    _this.ignoreChildren = false;\n    /**\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\n     */\n\n    _this.includeChildPredicate = null;\n    /**\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\n     */\n\n    _this.rotationSphereSize = 0.1;\n    /**\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\n     */\n\n    _this.scaleBoxSize = 0.1;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n\n    _this.fixedDragMeshScreenSize = false;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n\n    _this.fixedDragMeshBoundsSize = false;\n    /**\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\n     */\n\n    _this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\n     * Fired when a rotation sphere or scale box is dragged\n     */\n\n    _this.onDragStartObservable = new Observable();\n    /**\n     * Fired when a scale box is dragged\n     */\n\n    _this.onScaleBoxDragObservable = new Observable();\n    /**\n     * Fired when a scale box drag is ended\n     */\n\n    _this.onScaleBoxDragEndObservable = new Observable();\n    /**\n     * Fired when a rotation sphere is dragged\n     */\n\n    _this.onRotationSphereDragObservable = new Observable();\n    /**\n     * Fired when a rotation sphere drag is ended\n     */\n\n    _this.onRotationSphereDragEndObservable = new Observable();\n    /**\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\n     */\n\n    _this.scalePivot = null;\n    /**\n     * Scale factor used for masking some axis\n     */\n\n    _this._axisFactor = new Vector3(1, 1, 1);\n    _this._existingMeshScale = new Vector3(); // Dragging\n\n    _this._dragMesh = null;\n    _this._pointerDragBehavior = new PointerDragBehavior(); // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n\n    _this.updateScale = false;\n    _this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene); // Create Materials\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.disableLighting = true;\n    _this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverColoredMaterial.disableLighting = true; // Build bounding box out of lines\n\n    _this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    var lines = [];\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(_this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(function (l) {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-_this._boundingDimensions.x / 2, -_this._boundingDimensions.y / 2, -_this._boundingDimensions.z / 2));\n      l.isPickable = false;\n\n      _this._lineBoundingBox.addChild(l);\n    });\n\n    _this._rootMesh.addChild(_this._lineBoundingBox);\n\n    _this.setColor(color); // Create rotation spheres\n\n\n    _this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n\n    var _loop_1 = function _loop_1(i) {\n      var sphere = CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this_1._coloredMaterial;\n      sphere.isNearGrabbable = true; // Drag behavior\n\n      var _dragBehavior = new PointerDragBehavior({});\n\n      _dragBehavior.moveAttached = false;\n      _dragBehavior.updateDragPlane = false;\n      sphere.addBehavior(_dragBehavior);\n      var startingTurnDirection = new Vector3(1, 0, 0);\n      var totalTurnAmountOfDrag = 0;\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n      });\n\n      _dragBehavior.onDragObservable.add(function (event) {\n        _this.onRotationSphereDragObservable.notifyObservers({});\n\n        if (_this.attachedMesh) {\n          var originalParent = _this.attachedMesh.parent;\n\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n\n          PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n          var worldDragDirection = startingTurnDirection; // Project the world right on to the drag plane\n\n          var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew(); // project drag delta on to the resulting drag axis and rotate based on that\n\n          var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length()); // Make rotation relative to size of mesh.\n\n          projectDist = projectDist / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length(); // Rotate based on axis\n\n          if (!_this.attachedMesh.rotationQuaternion) {\n            _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);\n          }\n\n          if (!_this._anchorMesh.rotationQuaternion) {\n            _this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._anchorMesh.rotation.y, _this._anchorMesh.rotation.x, _this._anchorMesh.rotation.z);\n          } // Do not allow the object to turn more than a full circle\n\n\n          totalTurnAmountOfDrag += projectDist;\n\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (i >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, _this._tmpQuaternion);\n            } else if (i >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, _this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, _this._tmpQuaternion);\n            } // Rotate around center of bounding box\n\n\n            _this._anchorMesh.addChild(_this.attachedMesh, Gizmo.PreserveScaling);\n\n            _this._anchorMesh.rotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._anchorMesh.rotationQuaternion);\n\n            _this._anchorMesh.removeChild(_this.attachedMesh, Gizmo.PreserveScaling);\n\n            _this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n          }\n\n          _this.updateBoundingBox();\n\n          PivotTools._RestorePivotPoint(_this.attachedMesh);\n        }\n\n        _this._updateDummy();\n      }); // Selection/deselection\n\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n\n        _this._selectNode(sphere);\n      });\n\n      _dragBehavior.onDragEndObservable.add(function () {\n        _this.onRotationSphereDragEndObservable.notifyObservers({});\n\n        _this._selectNode(null);\n\n        _this._updateDummy();\n      });\n\n      this_1._rotateSpheresParent.addChild(sphere);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < 12; i++) {\n      _loop_1(i);\n    }\n\n    _this._rootMesh.addChild(_this._rotateSpheresParent); // Create scale cubes\n\n\n    _this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        var _loop_2 = function _loop_2(k) {\n          // create box for relevant axis\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            return \"continue\";\n          }\n\n          var box = CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this_2._coloredMaterial;\n          box.metadata = zeroAxisCount === 2; // None homogenous scale handle\n\n          box.isNearGrabbable = true; // Dragging logic\n\n          var dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n\n          var _dragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n\n          _dragBehavior.updateDragPlane = false;\n          _dragBehavior.moveAttached = false;\n          box.addBehavior(_dragBehavior);\n\n          _dragBehavior.onDragObservable.add(function (event) {\n            _this.onScaleBoxDragObservable.notifyObservers({});\n\n            if (_this.attachedMesh) {\n              var originalParent = _this.attachedMesh.parent;\n\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n\n              PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n              var relativeDragDistance = event.dragDistance / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length();\n\n              var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n\n              deltaScale.scaleInPlace(_this._scaleDragSpeed);\n              deltaScale.multiplyInPlace(_this._axisFactor);\n\n              _this.updateBoundingBox();\n\n              if (_this.scalePivot) {\n                _this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(_this._tmpRotationMatrix); // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n\n\n                _this._boundingDimensions.scaleToRef(0.5, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n\n                _this._boundingDimensions.multiplyToRef(_this.scalePivot, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.addInPlace(_this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(_this._anchorMesh.position, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n              }\n\n              _this._anchorMesh.addChild(_this.attachedMesh, Gizmo.PreserveScaling);\n\n              _this._anchorMesh.scaling.addInPlace(deltaScale);\n\n              if (_this._anchorMesh.scaling.x < 0 || _this._anchorMesh.scaling.y < 0 || _this._anchorMesh.scaling.z < 0) {\n                _this._anchorMesh.scaling.subtractInPlace(deltaScale);\n              }\n\n              _this._anchorMesh.removeChild(_this.attachedMesh, Gizmo.PreserveScaling);\n\n              _this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n\n              PivotTools._RestorePivotPoint(_this.attachedMesh);\n            }\n\n            _this._updateDummy();\n          }); // Selection/deselection\n\n\n          _dragBehavior.onDragStartObservable.add(function () {\n            _this.onDragStartObservable.notifyObservers({});\n\n            _this._selectNode(box);\n          });\n\n          _dragBehavior.onDragEndObservable.add(function () {\n            _this.onScaleBoxDragEndObservable.notifyObservers({});\n\n            _this._selectNode(null);\n\n            _this._updateDummy();\n          });\n\n          this_2._scaleBoxesParent.addChild(box);\n        };\n\n        var this_2 = this;\n\n        for (var k = 0; k < 3; k++) {\n          _loop_2(k);\n        }\n      }\n    }\n\n    _this._rootMesh.addChild(_this._scaleBoxesParent); // Hover color change\n\n\n    var pointerIds = new Array();\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        _this._rotateSpheresParent.getChildMeshes().concat(_this._scaleBoxesParent.getChildMeshes()).forEach(function (mesh) {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = _this._hoverColoredMaterial;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = _this._coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n        }\n      }\n    }); // Update bounding box positions\n\n    _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {\n      // Only update the bounding box if scaling has changed\n      if (_this.attachedMesh && !_this._existingMeshScale.equals(_this.attachedMesh.scaling)) {\n        _this.updateBoundingBox();\n      } else if (_this.fixedDragMeshScreenSize || _this.fixedDragMeshBoundsSize) {\n        _this._updateRotationSpheres();\n\n        _this._updateScaleBoxes();\n      } // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n\n\n      if (_this._dragMesh && _this.attachedMesh && _this._pointerDragBehavior.dragging) {\n        _this._lineBoundingBox.position.rotateByQuaternionToRef(_this._rootMesh.rotationQuaternion, _this._tmpVector);\n\n        _this.attachedMesh.setAbsolutePosition(_this._dragMesh.position.add(_this._tmpVector.scale(-1)));\n      }\n    });\n\n    _this.updateBoundingBox();\n\n    return _this;\n  }\n\n  Object.defineProperty(BoundingBoxGizmo.prototype, \"axisFactor\", {\n    /**\n     * Gets the axis factor\n     * @returns the Vector3 factor value\n     */\n    get: function get() {\n      return this._axisFactor;\n    },\n\n    /**\n     * Sets the axis factor\n     * @param factor the Vector3 value\n     */\n    set: function set(factor) {\n      this._axisFactor = factor; // update scale cube visibility\n\n      var scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n\n      var index = 0;\n\n      for (var i = 0; i < 3; i++) {\n        for (var j = 0; j < 3; j++) {\n          for (var k = 0; k < 3; k++) {\n            var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n            if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n              continue;\n            }\n\n            if (scaleBoxes[index]) {\n              var dragAxis = new Vector3(i - 1, j - 1, k - 1);\n              dragAxis.multiplyInPlace(this._axisFactor);\n              scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\n            }\n\n            index++;\n          }\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoundingBoxGizmo.prototype, \"scaleDragSpeed\", {\n    /**\n     * Gets scale drag speed\n     * @returns the scale speed number\n     */\n    get: function get() {\n      return this._scaleDragSpeed;\n    },\n\n    /**\n     * Sets scale drag speed value\n     * @param value the new speed value\n     */\n    set: function set(value) {\n      this._scaleDragSpeed = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the color of the bounding box gizmo\n   * @param color the color to set\n   */\n\n  BoundingBoxGizmo.prototype.setColor = function (color) {\n    this._coloredMaterial.emissiveColor = color;\n    this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n\n    this._lineBoundingBox.getChildren().forEach(function (l) {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  };\n\n  BoundingBoxGizmo.prototype._attachedNodeChanged = function (value) {\n    var _this = this;\n\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      this._anchorMesh.scaling.setAll(1);\n\n      PivotTools._RemoveAndStorePivotPoint(value);\n\n      var originalParent = value.parent;\n\n      this._anchorMesh.addChild(value, Gizmo.PreserveScaling);\n\n      this._anchorMesh.removeChild(value, Gizmo.PreserveScaling);\n\n      value.setParent(originalParent, Gizmo.PreserveScaling);\n\n      PivotTools._RestorePivotPoint(value);\n\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(function (m) {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(function () {\n        _this._updateDummy();\n      });\n    }\n  };\n\n  BoundingBoxGizmo.prototype._selectNode = function (selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(function (m) {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  };\n  /**\n   * Updates the bounding box information for the Gizmo\n   */\n\n\n  BoundingBoxGizmo.prototype.updateBoundingBox = function () {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh); // Store original parent\n\n\n      var originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null, Gizmo.PreserveScaling);\n\n      this._update(); // Rotate based on axis\n\n\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion); // Store original position and reset mesh to origin before computing the bounding box\n\n\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n      var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions); // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._lineBoundingBox.computeWorldMatrix();\n\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition); // Restore position/rotation values\n\n\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector); // Restore original parent\n\n      this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n    }\n\n    this._updateRotationSpheres();\n\n    this._updateScaleBoxes();\n\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateRotationSpheres = function () {\n    var rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 2; j++) {\n        for (var k = 0; k < 2; k++) {\n          var index = i * 4 + j * 2 + k;\n\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateScaleBoxes = function () {\n    var scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n\n    var index = 0;\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        for (var k = 0; k < 3; k++) {\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n              var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n\n          index++;\n        }\n      }\n    }\n  };\n  /**\n   * Enables rotation on the specified axis and disables rotation on the others\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledRotationAxis = function (axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach(function (m, i) {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  };\n  /**\n   * Enables/disables scaling\n   * @param enable if scaling should be enabled\n   * @param homogeneousScaling defines if scaling should only be homogeneous\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledScaling = function (enable, homogeneousScaling) {\n    if (homogeneousScaling === void 0) {\n      homogeneousScaling = false;\n    }\n\n    this._scaleBoxesParent.getChildMeshes().forEach(function (m) {\n      var enableMesh = enable; // Disable heterogeneous scale handles if requested.\n\n      if (homogeneousScaling && m.metadata === true) {\n        enableMesh = false;\n      }\n\n      m.setEnabled(enableMesh);\n    });\n  };\n\n  BoundingBoxGizmo.prototype._updateDummy = function () {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  };\n  /**\n   * Enables a pointer drag behavior on the bounding box of the gizmo\n   */\n\n\n  BoundingBoxGizmo.prototype.enableDragBehavior = function () {\n    this._dragMesh = CreateBox(\"dummy\", {\n      size: 1\n    }, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this._pointerDragBehavior.useObjectOrientationForDragging = false;\n\n    this._dragMesh.addBehavior(this._pointerDragBehavior);\n  };\n  /**\n   * Disposes of the gizmo\n   */\n\n\n  BoundingBoxGizmo.prototype.dispose = function () {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n\n    this._lineBoundingBox.dispose();\n\n    this._rotateSpheresParent.dispose();\n\n    this._scaleBoxesParent.dispose();\n\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\n   * @returns the bounding box mesh with the passed in mesh as a child\n   */\n\n\n  BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox = function (mesh) {\n    var makeNotPickable = function makeNotPickable(root) {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(function (c) {\n        makeNotPickable(c);\n      });\n    };\n\n    makeNotPickable(mesh); // Reset position to get bounding box from origin with no rotation\n\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n\n    var oldPos = mesh.position.clone();\n    var oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n    var box = CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    var boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling); // Adjust scale to avoid undefined behavior when adding child\n\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2); // Restore original positions\n\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos); // Reverse parenting\n\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  };\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n\n\n  BoundingBoxGizmo.prototype.setCustomMesh = function () {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  };\n\n  return BoundingBoxGizmo;\n}(Gizmo);\n\nexport { BoundingBoxGizmo };","map":{"version":3,"mappings":"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","names":["Observable","Logger","Quaternion","Matrix","Vector3","AbstractMesh","CreateSphere","CreateBox","CreateLines","PointerDragBehavior","Gizmo","UtilityLayerRenderer","StandardMaterial","PivotTools","Color3","Epsilon","__extends","color","gizmoLayer","Gray","DefaultKeepDepthUtilityLayer","_super","_this","updateScale","_anchorMesh","utilityLayerScene","_coloredMaterial","disableLighting","_hoverColoredMaterial","_lineBoundingBox","rotationQuaternion","lines","push","points","_boundingDimensions","x","y","z","forEach","l","position","addInPlace","isPickable","addChild","_rootMesh","setColor","_rotateSpheresParent","i","sphere","diameter","material","this_1","isNearGrabbable","_dragBehavior","moveAttached","updateDragPlane","addBehavior","startingTurnDirection","totalTurnAmountOfDrag","onDragStartObservable","add","copyFrom","forward","onDragObservable","event","onRotationSphereDragObservable","notifyObservers","attachedMesh","originalParent","parent","scaling","isNonUniformWithinEpsilon","Warn","_RemoveAndStorePivotPoint","worldDragDirection","toSub","dragPlaneNormal","scale","Dot","dragAxis","subtract","normalizeToNew","projectDist","delta","Math","abs","length","RotationYawPitchRoll","rotation","PI","RotationYawPitchRollToRef","_tmpQuaternion","PreserveScaling","multiplyToRef","removeChild","setParent","updateBoundingBox","_RestorePivotPoint","_updateDummy","_selectNode","onDragEndObservable","onRotationSphereDragEndObservable","_scaleBoxesParent","j","k","zeroAxisCount","box","size","this_2","metadata","normalize","onScaleBoxDragObservable","relativeDragDistance","dragDistance","deltaScale","scaleInPlace","_scaleDragSpeed","multiplyInPlace","_axisFactor","scalePivot","getWorldMatrix","getRotationMatrixToRef","_tmpRotationMatrix","scaleToRef","_tmpVector","TransformCoordinatesToRef","subtractInPlace","absolutePosition","subtractToRef","onScaleBoxDragEndObservable","pointerIds","Array","_pointerObserver","onPointerObservable","pointerInfo","pointerId","getChildMeshes","concat","mesh","pickInfo","pickedMesh","_renderObserver","originalScene","onBeforeRenderObservable","_existingMeshScale","equals","fixedDragMeshScreenSize","fixedDragMeshBoundsSize","_updateRotationSpheres","_updateScaleBoxes","_dragMesh","_pointerDragBehavior","dragging","rotateByQuaternionToRef","setAbsolutePosition","Object","BoundingBoxGizmo","factor","scaleBoxes","index","setEnabled","lengthSquared","value","emissiveColor","clone","getChildren","setAll","m","markAsDirty","onAfterRenderObservable","addOnce","selectedMesh","isVisible","_update","set","boundingMinMax","getHierarchyBoundingVectors","ignoreChildren","includeChildPredicate","max","min","computeWorldMatrix","rotateSpheres","lookAt","Cross","Right","Up","Forward","activeCamera","distanceFromCamera","rotationSphereSize","fixedDragMeshScreenSizeDistanceFactor","scaleBoxSize","axis","indexOf","enable","homogeneousScaling","enableMesh","getAbsolutePosition","visibility","useObjectOrientationForDragging","remove","dispose","call","makeNotPickable","root","c","oldPos","oldRot","getScene","Error"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/boundingBoxGizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { PivotTools } from \"../Misc/pivotTools\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\n\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Bounding box gizmo\r\n */\r\nexport class BoundingBoxGizmo extends Gizmo {\r\n    private _lineBoundingBox: AbstractMesh;\r\n    private _rotateSpheresParent: AbstractMesh;\r\n    private _scaleBoxesParent: AbstractMesh;\r\n    private _boundingDimensions = new Vector3(1, 1, 1);\r\n    private _renderObserver: Nullable<Observer<Scene>> = null;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n    private _scaleDragSpeed = 0.2;\r\n\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _tmpRotationMatrix = new Matrix();\r\n    /**\r\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\r\n    public ignoreChildren = false;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\r\n    public includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean> = null;\r\n\r\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\r\n    public rotationSphereSize = 0.1;\r\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\r\n    public scaleBoxSize = 0.1;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshScreenSize = false;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshBoundsSize = false;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\r\n    public fixedDragMeshScreenSizeDistanceFactor = 10;\r\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\r\n    public onDragStartObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\r\n    public onScaleBoxDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box drag is ended\r\n     */\r\n    public onScaleBoxDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\r\n    public onRotationSphereDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\r\n    public onRotationSphereDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\r\n    public scalePivot: Nullable<Vector3> = null;\r\n    /**\r\n     * Scale factor used for masking some axis\r\n     */\r\n    private _axisFactor = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Sets the axis factor\r\n     * @param factor the Vector3 value\r\n     */\r\n    public set axisFactor(factor: Vector3) {\r\n        this._axisFactor = factor;\r\n        // update scale cube visibility\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        const dragAxis = new Vector3(i - 1, j - 1, k - 1);\r\n                        dragAxis.multiplyInPlace(this._axisFactor);\r\n                        scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the axis factor\r\n     * @returns the Vector3 factor value\r\n     */\r\n    public get axisFactor(): Vector3 {\r\n        return this._axisFactor;\r\n    }\r\n\r\n    /**\r\n     * Sets scale drag speed value\r\n     * @param value the new speed value\r\n     */\r\n    public set scaleDragSpeed(value: number) {\r\n        this._scaleDragSpeed = value;\r\n    }\r\n\r\n    /**\r\n     * Gets scale drag speed\r\n     * @returns the scale speed number\r\n     */\r\n    public get scaleDragSpeed(): number {\r\n        return this._scaleDragSpeed;\r\n    }\r\n\r\n    /**\r\n     * Mesh used as a pivot to rotate the attached node\r\n     */\r\n    private _anchorMesh: AbstractMesh;\r\n\r\n    private _existingMeshScale = new Vector3();\r\n\r\n    // Dragging\r\n    private _dragMesh: Nullable<Mesh> = null;\r\n    private _pointerDragBehavior = new PointerDragBehavior();\r\n\r\n    private _coloredMaterial: StandardMaterial;\r\n    private _hoverColoredMaterial: StandardMaterial;\r\n\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    public setColor(color: Color3) {\r\n        this._coloredMaterial.emissiveColor = color;\r\n        this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\r\n        this._lineBoundingBox.getChildren().forEach((l) => {\r\n            if ((l as LinesMesh).color) {\r\n                (l as LinesMesh).color = color;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Creates an BoundingBoxGizmo\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\r\n        super(gizmoLayer);\r\n\r\n        // Do not update the gizmo's scale so it has a fixed size to the object its attached to\r\n        this.updateScale = false;\r\n\r\n        this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\r\n        // Create Materials\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.disableLighting = true;\r\n        this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverColoredMaterial.disableLighting = true;\r\n\r\n        // Build bounding box out of lines\r\n        this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._lineBoundingBox.rotationQuaternion = new Quaternion();\r\n        const lines = [];\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.forEach((l) => {\r\n            l.color = color;\r\n            l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n            l.isPickable = false;\r\n            this._lineBoundingBox.addChild(l);\r\n        });\r\n        this._rootMesh.addChild(this._lineBoundingBox);\r\n\r\n        this.setColor(color);\r\n\r\n        // Create rotation spheres\r\n        this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._rotateSpheresParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 12; i++) {\r\n            const sphere = CreateSphere(\"\", { diameter: 1 }, gizmoLayer.utilityLayerScene);\r\n            sphere.rotationQuaternion = new Quaternion();\r\n            sphere.material = this._coloredMaterial;\r\n            sphere.isNearGrabbable = true;\r\n\r\n            // Drag behavior\r\n            const _dragBehavior = new PointerDragBehavior({});\r\n            _dragBehavior.moveAttached = false;\r\n            _dragBehavior.updateDragPlane = false;\r\n            sphere.addBehavior(_dragBehavior);\r\n            const startingTurnDirection = new Vector3(1, 0, 0);\r\n            let totalTurnAmountOfDrag = 0;\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                startingTurnDirection.copyFrom(sphere.forward);\r\n                totalTurnAmountOfDrag = 0;\r\n            });\r\n            _dragBehavior.onDragObservable.add((event) => {\r\n                this.onRotationSphereDragObservable.notifyObservers({});\r\n                if (this.attachedMesh) {\r\n                    const originalParent = this.attachedMesh.parent;\r\n                    if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                        Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                        return;\r\n                    }\r\n                    PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n                    const worldDragDirection = startingTurnDirection;\r\n\r\n                    // Project the world right on to the drag plane\r\n                    const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\r\n                    const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\r\n\r\n                    // project drag delta on to the resulting drag axis and rotate based on that\r\n                    let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\r\n\r\n                    // Make rotation relative to size of mesh.\r\n                    projectDist = (projectDist / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n\r\n                    // Rotate based on axis\r\n                    if (!this.attachedMesh.rotationQuaternion) {\r\n                        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this.attachedMesh.rotation.y,\r\n                            this.attachedMesh.rotation.x,\r\n                            this.attachedMesh.rotation.z\r\n                        );\r\n                    }\r\n                    if (!this._anchorMesh.rotationQuaternion) {\r\n                        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this._anchorMesh.rotation.y,\r\n                            this._anchorMesh.rotation.x,\r\n                            this._anchorMesh.rotation.z\r\n                        );\r\n                    }\r\n\r\n                    // Do not allow the object to turn more than a full circle\r\n                    totalTurnAmountOfDrag += projectDist;\r\n                    if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\r\n                        if (i >= 8) {\r\n                            Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\r\n                        } else if (i >= 4) {\r\n                            Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\r\n                        } else {\r\n                            Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\r\n                        }\r\n\r\n                        // Rotate around center of bounding box\r\n                        this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                        this._anchorMesh.rotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion!);\r\n                        this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                        this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n                    }\r\n                    this.updateBoundingBox();\r\n\r\n                    PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                }\r\n                this._updateDummy();\r\n            });\r\n\r\n            // Selection/deselection\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n                this._selectNode(sphere);\r\n            });\r\n            _dragBehavior.onDragEndObservable.add(() => {\r\n                this.onRotationSphereDragEndObservable.notifyObservers({});\r\n                this._selectNode(null);\r\n                this._updateDummy();\r\n            });\r\n\r\n            this._rotateSpheresParent.addChild(sphere);\r\n        }\r\n        this._rootMesh.addChild(this._rotateSpheresParent);\r\n\r\n        // Create scale cubes\r\n        this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._scaleBoxesParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    // create box for relevant axis\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n\r\n                    const box = CreateBox(\"\", { size: 1 }, gizmoLayer.utilityLayerScene);\r\n                    box.material = this._coloredMaterial;\r\n                    box.metadata = zeroAxisCount === 2; // None homogenous scale handle\r\n                    box.isNearGrabbable = true;\r\n\r\n                    // Dragging logic\r\n                    const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\r\n                    const _dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\r\n                    _dragBehavior.updateDragPlane = false;\r\n                    _dragBehavior.moveAttached = false;\r\n                    box.addBehavior(_dragBehavior);\r\n                    _dragBehavior.onDragObservable.add((event) => {\r\n                        this.onScaleBoxDragObservable.notifyObservers({});\r\n                        if (this.attachedMesh) {\r\n                            const originalParent = this.attachedMesh.parent;\r\n                            if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                                return;\r\n                            }\r\n                            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n                            const relativeDragDistance = (event.dragDistance / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n                            const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\r\n                            if (zeroAxisCount === 2) {\r\n                                // scale on 1 axis when using the anchor box in the face middle\r\n                                deltaScale.x *= Math.abs(dragAxis.x);\r\n                                deltaScale.y *= Math.abs(dragAxis.y);\r\n                                deltaScale.z *= Math.abs(dragAxis.z);\r\n                            }\r\n                            deltaScale.scaleInPlace(this._scaleDragSpeed);\r\n                            deltaScale.multiplyInPlace(this._axisFactor);\r\n                            this.updateBoundingBox();\r\n                            if (this.scalePivot) {\r\n                                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\r\n                                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\r\n                                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.addInPlace(this._tmpVector);\r\n                            } else {\r\n                                // Scale from the position of the opposite corner\r\n                                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                            }\r\n\r\n                            this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                            this._anchorMesh.scaling.addInPlace(deltaScale);\r\n                            if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\r\n                                this._anchorMesh.scaling.subtractInPlace(deltaScale);\r\n                            }\r\n                            this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n                            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                        }\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    // Selection/deselection\r\n                    _dragBehavior.onDragStartObservable.add(() => {\r\n                        this.onDragStartObservable.notifyObservers({});\r\n                        this._selectNode(box);\r\n                    });\r\n                    _dragBehavior.onDragEndObservable.add(() => {\r\n                        this.onScaleBoxDragEndObservable.notifyObservers({});\r\n                        this._selectNode(null);\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    this._scaleBoxesParent.addChild(box);\r\n                }\r\n            }\r\n        }\r\n        this._rootMesh.addChild(this._scaleBoxesParent);\r\n\r\n        // Hover color change\r\n        const pointerIds = new Array<AbstractMesh>();\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                this._rotateSpheresParent\r\n                    .getChildMeshes()\r\n                    .concat(this._scaleBoxesParent.getChildMeshes())\r\n                    .forEach((mesh) => {\r\n                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\r\n                            pointerIds[(<IPointerEvent>pointerInfo.event).pointerId] = mesh;\r\n                            mesh.material = this._hoverColoredMaterial;\r\n                        }\r\n                    });\r\n            } else {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                    pointerIds[(<IPointerEvent>pointerInfo.event).pointerId].material = this._coloredMaterial;\r\n                    delete pointerIds[(<IPointerEvent>pointerInfo.event).pointerId];\r\n                }\r\n            }\r\n        });\r\n\r\n        // Update bounding box positions\r\n        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\r\n            // Only update the bounding box if scaling has changed\r\n            if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\r\n                this.updateBoundingBox();\r\n            } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\r\n                this._updateRotationSpheres();\r\n                this._updateScaleBoxes();\r\n            }\r\n\r\n            // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\r\n            if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\r\n                this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion!, this._tmpVector);\r\n                this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\r\n            }\r\n        });\r\n        this.updateBoundingBox();\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            // Reset anchor mesh to match attached mesh's scale\r\n            // This is needed to avoid invalid box/sphere position on first drag\r\n            this._anchorMesh.scaling.setAll(1);\r\n            PivotTools._RemoveAndStorePivotPoint(value);\r\n            const originalParent = value.parent;\r\n            this._anchorMesh.addChild(value, Gizmo.PreserveScaling);\r\n            this._anchorMesh.removeChild(value, Gizmo.PreserveScaling);\r\n            value.setParent(originalParent, Gizmo.PreserveScaling);\r\n            PivotTools._RestorePivotPoint(value);\r\n            this.updateBoundingBox();\r\n            value.getChildMeshes(false).forEach((m) => {\r\n                m.markAsDirty(\"scaling\");\r\n            });\r\n\r\n            this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\r\n                this._updateDummy();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _selectNode(selectedMesh: Nullable<Mesh>) {\r\n        this._rotateSpheresParent\r\n            .getChildMeshes()\r\n            .concat(this._scaleBoxesParent.getChildMeshes())\r\n            .forEach((m) => {\r\n                m.isVisible = !selectedMesh || m == selectedMesh;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the bounding box information for the Gizmo\r\n     */\r\n    public updateBoundingBox() {\r\n        if (this.attachedMesh) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n            // Store original parent\r\n            const originalParent = this.attachedMesh.parent;\r\n            this.attachedMesh.setParent(null, Gizmo.PreserveScaling);\r\n\r\n            this._update();\r\n\r\n            // Rotate based on axis\r\n            if (!this.attachedMesh.rotationQuaternion) {\r\n                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n            }\r\n            if (!this._anchorMesh.rotationQuaternion) {\r\n                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\r\n            }\r\n            this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n\r\n            // Store original position and reset mesh to origin before computing the bounding box\r\n            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n            this._tmpVector.copyFrom(this.attachedMesh.position);\r\n            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\r\n            this.attachedMesh.position.set(0, 0, 0);\r\n\r\n            // Update bounding dimensions/positions\r\n            const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\r\n            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\r\n\r\n            // Update gizmo to match bounding box scaling and rotation\r\n            // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\r\n            // The position of the gizmo is then set to the attachedMesh in gizmo._update\r\n            this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\r\n            this._lineBoundingBox.position.set(\r\n                (boundingMinMax.max.x + boundingMinMax.min.x) / 2,\r\n                (boundingMinMax.max.y + boundingMinMax.min.y) / 2,\r\n                (boundingMinMax.max.z + boundingMinMax.min.z) / 2\r\n            );\r\n            this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._lineBoundingBox.computeWorldMatrix();\r\n            this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\r\n\r\n            // Restore position/rotation values\r\n            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\r\n            this.attachedMesh.position.copyFrom(this._tmpVector);\r\n\r\n            // Restore original parent\r\n            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n        }\r\n\r\n        this._updateRotationSpheres();\r\n        this._updateScaleBoxes();\r\n\r\n        if (this.attachedMesh) {\r\n            this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\r\n            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n        }\r\n    }\r\n\r\n    private _updateRotationSpheres() {\r\n        const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                for (let k = 0; k < 2; k++) {\r\n                    const index = i * 4 + j * 2 + k;\r\n                    if (i == 0) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 1) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 2) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                        rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                        const distanceFromCamera = (this.rotationSphereSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                        rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                    } else if (this.fixedDragMeshBoundsSize) {\r\n                        rotateSpheres[index].scaling.set(\r\n                            this.rotationSphereSize * this._boundingDimensions.x,\r\n                            this.rotationSphereSize * this._boundingDimensions.y,\r\n                            this.rotationSphereSize * this._boundingDimensions.z\r\n                        );\r\n                    } else {\r\n                        rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateScaleBoxes() {\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\r\n                        scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                            scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                            const distanceFromCamera = (this.scaleBoxSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                            scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                        } else if (this.fixedDragMeshBoundsSize) {\r\n                            scaleBoxes[index].scaling.set(\r\n                                this.scaleBoxSize * this._boundingDimensions.x,\r\n                                this.scaleBoxSize * this._boundingDimensions.y,\r\n                                this.scaleBoxSize * this._boundingDimensions.z\r\n                            );\r\n                        } else {\r\n                            scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\r\n                        }\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    public setEnabledRotationAxis(axis: string) {\r\n        this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\r\n            if (i < 4) {\r\n                m.setEnabled(axis.indexOf(\"x\") != -1);\r\n            } else if (i < 8) {\r\n                m.setEnabled(axis.indexOf(\"y\") != -1);\r\n            } else {\r\n                m.setEnabled(axis.indexOf(\"z\") != -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    public setEnabledScaling(enable: boolean, homogeneousScaling = false) {\r\n        this._scaleBoxesParent.getChildMeshes().forEach((m) => {\r\n            let enableMesh = enable;\r\n            // Disable heterogeneous scale handles if requested.\r\n            if (homogeneousScaling && m.metadata === true) {\r\n                enableMesh = false;\r\n            }\r\n            m.setEnabled(enableMesh);\r\n        });\r\n    }\r\n\r\n    private _updateDummy() {\r\n        if (this._dragMesh) {\r\n            this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\r\n            this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\r\n            this._dragMesh.rotationQuaternion!.copyFrom(this._rootMesh.rotationQuaternion!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a pointer drag behavior on the bounding box of the gizmo\r\n     */\r\n    public enableDragBehavior() {\r\n        this._dragMesh = CreateBox(\"dummy\", { size: 1 }, this.gizmoLayer.utilityLayerScene);\r\n        this._dragMesh.visibility = 0;\r\n        this._dragMesh.rotationQuaternion = new Quaternion();\r\n        this._pointerDragBehavior.useObjectOrientationForDragging = false;\r\n        this._dragMesh.addBehavior(this._pointerDragBehavior);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\r\n        this._lineBoundingBox.dispose();\r\n        this._rotateSpheresParent.dispose();\r\n        this._scaleBoxesParent.dispose();\r\n        if (this._dragMesh) {\r\n            this._dragMesh.dispose();\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n     * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n     * @returns the bounding box mesh with the passed in mesh as a child\r\n     */\r\n    public static MakeNotPickableAndWrapInBoundingBox(mesh: Mesh): Mesh {\r\n        const makeNotPickable = (root: AbstractMesh) => {\r\n            root.isPickable = false;\r\n            root.getChildMeshes().forEach((c) => {\r\n                makeNotPickable(c);\r\n            });\r\n        };\r\n        makeNotPickable(mesh);\r\n\r\n        // Reset position to get bounding box from origin with no rotation\r\n        if (!mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\r\n        }\r\n        const oldPos = mesh.position.clone();\r\n        const oldRot = mesh.rotationQuaternion.clone();\r\n        mesh.rotationQuaternion.set(0, 0, 0, 1);\r\n        mesh.position.set(0, 0, 0);\r\n\r\n        // Update bounding dimensions/positions\r\n        const box = CreateBox(\"box\", { size: 1 }, mesh.getScene());\r\n        const boundingMinMax = mesh.getHierarchyBoundingVectors();\r\n        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\r\n\r\n        // Adjust scale to avoid undefined behavior when adding child\r\n        if (box.scaling.y === 0) {\r\n            box.scaling.y = Epsilon;\r\n        }\r\n        if (box.scaling.x === 0) {\r\n            box.scaling.x = Epsilon;\r\n        }\r\n        if (box.scaling.z === 0) {\r\n            box.scaling.z = Epsilon;\r\n        }\r\n\r\n        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\r\n\r\n        // Restore original positions\r\n        mesh.addChild(box);\r\n        mesh.rotationQuaternion.copyFrom(oldRot);\r\n        mesh.position.copyFrom(oldPos);\r\n\r\n        // Reverse parenting\r\n        mesh.removeChild(box);\r\n\r\n        box.addChild(mesh);\r\n        box.visibility = 0;\r\n        return box;\r\n    }\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\"Custom meshes are not supported on this gizmo\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}