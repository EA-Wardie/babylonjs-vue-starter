{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { MorphTarget } from \"./morphTarget.js\";\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray.js\";\n/**\n * This class is used to deform meshes using morphing between different targets\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\n */\n\nvar MorphTargetManager =\n/** @class */\nfunction () {\n  /**\n   * Creates a new MorphTargetManager\n   * @param scene defines the current scene\n   */\n  function MorphTargetManager(scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this._targets = new Array();\n    this._targetInfluenceChangedObservers = new Array();\n    this._targetDataLayoutChangedObservers = new Array();\n    this._activeTargets = new SmartArray(16);\n    this._supportsNormals = false;\n    this._supportsTangents = false;\n    this._supportsUVs = false;\n    this._vertexCount = 0;\n    this._textureVertexStride = 0;\n    this._textureWidth = 0;\n    this._textureHeight = 1;\n    this._uniqueId = 0;\n    this._tempInfluences = new Array();\n    this._canUseTextureForTargets = false;\n    this._blockCounter = 0;\n    /** @hidden */\n\n    this._parentContainer = null;\n    /**\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\n     */\n\n    this.optimizeInfluencers = true;\n    /**\n     * Gets or sets a boolean indicating if normals must be morphed\n     */\n\n    this.enableNormalMorphing = true;\n    /**\n     * Gets or sets a boolean indicating if tangents must be morphed\n     */\n\n    this.enableTangentMorphing = true;\n    /**\n     * Gets or sets a boolean indicating if UV must be morphed\n     */\n\n    this.enableUVMorphing = true;\n    this._useTextureToStoreTargets = true;\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    this._scene = scene;\n\n    if (this._scene) {\n      this._scene.morphTargetManagers.push(this);\n\n      this._uniqueId = this._scene.getUniqueId();\n\n      var engineCaps = this._scene.getEngine().getCaps();\n\n      this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n  }\n\n  Object.defineProperty(MorphTargetManager.prototype, \"areUpdatesFrozen\", {\n    get: function get() {\n      return this._blockCounter > 0;\n    },\n\n    /**\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\n     */\n    set: function set(block) {\n      if (block) {\n        this._blockCounter++;\n      } else {\n        this._blockCounter--;\n\n        if (this._blockCounter <= 0) {\n          this._blockCounter = 0;\n\n          this._syncActiveTargets(true);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"uniqueId\", {\n    /**\n     * Gets the unique ID of this manager\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"vertexCount\", {\n    /**\n     * Gets the number of vertices handled by this manager\n     */\n    get: function get() {\n      return this._vertexCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsNormals\", {\n    /**\n     * Gets a boolean indicating if this manager supports morphing of normals\n     */\n    get: function get() {\n      return this._supportsNormals && this.enableNormalMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsTangents\", {\n    /**\n     * Gets a boolean indicating if this manager supports morphing of tangents\n     */\n    get: function get() {\n      return this._supportsTangents && this.enableTangentMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsUVs\", {\n    /**\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\n     */\n    get: function get() {\n      return this._supportsUVs && this.enableUVMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numTargets\", {\n    /**\n     * Gets the number of targets stored in this manager\n     */\n    get: function get() {\n      return this._targets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numInfluencers\", {\n    /**\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\n     */\n    get: function get() {\n      return this._activeTargets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"influences\", {\n    /**\n     * Gets the list of influences (one per target)\n     */\n    get: function get() {\n      return this._influences;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"useTextureToStoreTargets\", {\n    /**\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get: function get() {\n      return this._useTextureToStoreTargets;\n    },\n    set: function set(value) {\n      this._useTextureToStoreTargets = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"isUsingTextureForTargets\", {\n    /**\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\n     */\n    get: function get() {\n      return MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the active target at specified index. An active target is a target with an influence > 0\n   * @param index defines the index to check\n   * @returns the requested target\n   */\n\n  MorphTargetManager.prototype.getActiveTarget = function (index) {\n    return this._activeTargets.data[index];\n  };\n  /**\n   * Gets the target at specified index\n   * @param index defines the index to check\n   * @returns the requested target\n   */\n\n\n  MorphTargetManager.prototype.getTarget = function (index) {\n    return this._targets[index];\n  };\n  /**\n   * Add a new target to this manager\n   * @param target defines the target to add\n   */\n\n\n  MorphTargetManager.prototype.addTarget = function (target) {\n    var _this = this;\n\n    this._targets.push(target);\n\n    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(function (needUpdate) {\n      _this._syncActiveTargets(needUpdate);\n    }));\n\n    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(function () {\n      _this._syncActiveTargets(true);\n    }));\n\n    this._syncActiveTargets(true);\n  };\n  /**\n   * Removes a target from the manager\n   * @param target defines the target to remove\n   */\n\n\n  MorphTargetManager.prototype.removeTarget = function (target) {\n    var index = this._targets.indexOf(target);\n\n    if (index >= 0) {\n      this._targets.splice(index, 1);\n\n      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\n\n      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\n\n      this._syncActiveTargets(true);\n    }\n  };\n  /**\n   * @param effect\n   * @hidden\n   */\n\n\n  MorphTargetManager.prototype._bind = function (effect) {\n    effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\n    effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\n    effect.setTexture(\"morphTargets\", this._targetStoreTexture);\n  };\n  /**\n   * Clone the current manager\n   * @returns a new MorphTargetManager\n   */\n\n\n  MorphTargetManager.prototype.clone = function () {\n    var copy = new MorphTargetManager(this._scene);\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      copy.addTarget(target.clone());\n    }\n\n    copy.enableNormalMorphing = this.enableNormalMorphing;\n    copy.enableTangentMorphing = this.enableTangentMorphing;\n    copy.enableUVMorphing = this.enableUVMorphing;\n    return copy;\n  };\n  /**\n   * Serializes the current manager into a Serialization object\n   * @returns the serialized object\n   */\n\n\n  MorphTargetManager.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.uniqueId;\n    serializationObject.targets = [];\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      serializationObject.targets.push(target.serialize());\n    }\n\n    return serializationObject;\n  };\n\n  MorphTargetManager.prototype._syncActiveTargets = function (needUpdate) {\n    if (this.areUpdatesFrozen) {\n      return;\n    }\n\n    var influenceCount = 0;\n\n    this._activeTargets.reset();\n\n    this._supportsNormals = true;\n    this._supportsTangents = true;\n    this._supportsUVs = true;\n    this._vertexCount = 0;\n\n    if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\n      this._morphTargetTextureIndices = new Float32Array(this._targets.length);\n    }\n\n    var targetIndex = -1;\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      targetIndex++;\n\n      if (target.influence === 0 && this.optimizeInfluencers) {\n        continue;\n      }\n\n      this._activeTargets.push(target);\n\n      this._morphTargetTextureIndices[influenceCount] = targetIndex;\n      this._tempInfluences[influenceCount++] = target.influence;\n      this._supportsNormals = this._supportsNormals && target.hasNormals;\n      this._supportsTangents = this._supportsTangents && target.hasTangents;\n      this._supportsUVs = this._supportsUVs && target.hasUVs;\n      var positions = target.getPositions();\n\n      if (positions) {\n        var vertexCount = positions.length / 3;\n\n        if (this._vertexCount === 0) {\n          this._vertexCount = vertexCount;\n        } else if (this._vertexCount !== vertexCount) {\n          Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n          return;\n        }\n      }\n    }\n\n    if (!this._influences || this._influences.length !== influenceCount) {\n      this._influences = new Float32Array(influenceCount);\n    }\n\n    for (var index = 0; index < influenceCount; index++) {\n      this._influences[index] = this._tempInfluences[index];\n    }\n\n    if (needUpdate) {\n      this.synchronize();\n    }\n  };\n  /**\n   * Synchronize the targets with all the meshes using this morph target manager\n   */\n\n\n  MorphTargetManager.prototype.synchronize = function () {\n    if (!this._scene || this.areUpdatesFrozen) {\n      return;\n    }\n\n    if (this.isUsingTextureForTargets && this._vertexCount) {\n      this._textureVertexStride = 1;\n\n      if (this._supportsNormals) {\n        this._textureVertexStride++;\n      }\n\n      if (this._supportsTangents) {\n        this._textureVertexStride++;\n      }\n\n      if (this._supportsUVs) {\n        this._textureVertexStride++;\n      }\n\n      this._textureWidth = this._vertexCount * this._textureVertexStride;\n      this._textureHeight = 1;\n\n      var maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;\n\n      if (this._textureWidth > maxTextureSize) {\n        this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\n        this._textureWidth = maxTextureSize;\n      }\n\n      var mustUpdateTexture = true;\n\n      if (this._targetStoreTexture) {\n        var textureSize = this._targetStoreTexture.getSize();\n\n        if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {\n          mustUpdateTexture = false;\n        }\n      }\n\n      if (mustUpdateTexture) {\n        if (this._targetStoreTexture) {\n          this._targetStoreTexture.dispose();\n        }\n\n        var targetCount = this._targets.length;\n        var data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\n        var offset = 0;\n\n        for (var index = 0; index < targetCount; index++) {\n          var target = this._targets[index];\n          var positions = target.getPositions();\n          var normals = target.getNormals();\n          var uvs = target.getUVs();\n          var tangents = target.getTangents();\n\n          if (!positions) {\n            if (index === 0) {\n              Logger.Error(\"Invalid morph target. Target must have positions.\");\n            }\n\n            return;\n          }\n\n          offset = index * this._textureWidth * this._textureHeight * 4;\n\n          for (var vertex = 0; vertex < this._vertexCount; vertex++) {\n            data[offset] = positions[vertex * 3];\n            data[offset + 1] = positions[vertex * 3 + 1];\n            data[offset + 2] = positions[vertex * 3 + 2];\n            offset += 4;\n\n            if (normals) {\n              data[offset] = normals[vertex * 3];\n              data[offset + 1] = normals[vertex * 3 + 1];\n              data[offset + 2] = normals[vertex * 3 + 2];\n              offset += 4;\n            }\n\n            if (uvs) {\n              data[offset] = uvs[vertex * 2];\n              data[offset + 1] = uvs[vertex * 2 + 1];\n              offset += 4;\n            }\n\n            if (tangents) {\n              data[offset] = tangents[vertex * 3];\n              data[offset + 1] = tangents[vertex * 3 + 1];\n              data[offset + 2] = tangents[vertex * 3 + 2];\n              offset += 4;\n            }\n          }\n        }\n\n        this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);\n      }\n    } // Flag meshes as dirty to resync with the active targets\n\n\n    for (var _i = 0, _a = this._scene.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.morphTargetManager === this) {\n        mesh._syncGeometryWithMorphTargetManager();\n      }\n    }\n  };\n  /**\n   * Release all resources\n   */\n\n\n  MorphTargetManager.prototype.dispose = function () {\n    if (this._targetStoreTexture) {\n      this._targetStoreTexture.dispose();\n    }\n\n    this._targetStoreTexture = null; // Remove from scene\n\n    if (this._scene) {\n      this._scene.removeMorphTargetManager(this);\n\n      if (this._parentContainer) {\n        var index = this._parentContainer.morphTargetManagers.indexOf(this);\n\n        if (index > -1) {\n          this._parentContainer.morphTargetManagers.splice(index, 1);\n        }\n\n        this._parentContainer = null;\n      }\n    }\n  }; // Statics\n\n  /**\n   * Creates a new MorphTargetManager from serialized data\n   * @param serializationObject defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns the new MorphTargetManager\n   */\n\n\n  MorphTargetManager.Parse = function (serializationObject, scene) {\n    var result = new MorphTargetManager(scene);\n    result._uniqueId = serializationObject.id;\n\n    for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {\n      var targetData = _a[_i];\n      result.addTarget(MorphTarget.Parse(targetData, scene));\n    }\n\n    return result;\n  };\n  /** Enable storing morph target data into textures when set to true (true by default) */\n\n\n  MorphTargetManager.EnableTextureStorage = true;\n  return MorphTargetManager;\n}();\n\nexport { MorphTargetManager };","map":{"version":3,"mappings":"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","names":["SmartArray","Logger","EngineStore","MorphTarget","RawTexture2DArray","scene","Array","LastCreatedScene","_scene","morphTargetManagers","push","_uniqueId","getUniqueId","engineCaps","getEngine","getCaps","_canUseTextureForTargets","canUseGLVertexID","textureFloat","maxVertexTextureImageUnits","Object","MorphTargetManager","_blockCounter","block","_syncActiveTargets","_vertexCount","_supportsNormals","enableNormalMorphing","_supportsTangents","enableTangentMorphing","_supportsUVs","enableUVMorphing","_targets","length","_activeTargets","_influences","_useTextureToStoreTargets","value","EnableTextureStorage","useTextureToStoreTargets","index","data","target","_targetInfluenceChangedObservers","onInfluenceChanged","add","needUpdate","_this","_targetDataLayoutChangedObservers","_onDataLayoutChanged","indexOf","splice","remove","effect","setFloat3","_textureVertexStride","_textureWidth","_textureHeight","setFloatArray","_morphTargetTextureIndices","setTexture","_targetStoreTexture","copy","_i","addTarget","clone","serializationObject","id","uniqueId","targets","serialize","areUpdatesFrozen","influenceCount","reset","Float32Array","targetIndex","influence","optimizeInfluencers","_tempInfluences","hasNormals","hasTangents","hasUVs","positions","getPositions","vertexCount","Error","synchronize","isUsingTextureForTargets","maxTextureSize","Math","ceil","mustUpdateTexture","textureSize","getSize","width","height","depth","dispose","targetCount","offset","normals","getNormals","uvs","getUVs","tangents","getTangents","vertex","CreateRGBATexture","meshes","mesh","morphTargetManager","_syncGeometryWithMorphTargetManager","removeMorphTargetManager","_parentContainer","result","targetData","Parse"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Morph/morphTargetManager.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\r\nexport class MorphTargetManager implements IDisposable {\r\n    /** Enable storing morph target data into textures when set to true (true by default) */\r\n    public static EnableTextureStorage = true;\r\n\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _morphTargetTextureIndices: Float32Array;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _vertexCount = 0;\r\n    private _textureVertexStride = 0;\r\n    private _textureWidth = 0;\r\n    private _textureHeight = 1;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n    private _canUseTextureForTargets = false;\r\n    private _blockCounter = 0;\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /** @hidden */\r\n    public _targetStoreTexture: Nullable<RawTexture2DArray>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\r\n     */\r\n    public optimizeInfluencers = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\r\n     */\r\n    public set areUpdatesFrozen(block: boolean) {\r\n        if (block) {\r\n            this._blockCounter++;\r\n        } else {\r\n            this._blockCounter--;\r\n            if (this._blockCounter <= 0) {\r\n                this._blockCounter = 0;\r\n\r\n                this._syncActiveTargets(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public get areUpdatesFrozen() {\r\n        return this._blockCounter > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.morphTargetManagers.push(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n\r\n            const engineCaps = this._scene.getEngine().getCaps();\r\n            this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        return this._influences;\r\n    }\r\n\r\n    private _useTextureToStoreTargets = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreTargets(): boolean {\r\n        return this._useTextureToStoreTargets;\r\n    }\r\n\r\n    public set useTextureToStoreTargets(value: boolean) {\r\n        this._useTextureToStoreTargets = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\r\n     */\r\n    public get isUsingTextureForTargets() {\r\n        return MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets;\r\n    }\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(\r\n            target.onInfluenceChanged.add((needUpdate) => {\r\n                this._syncActiveTargets(needUpdate);\r\n            })\r\n        );\r\n        this._targetDataLayoutChangedObservers.push(\r\n            target._onDataLayoutChanged.add(() => {\r\n                this._syncActiveTargets(true);\r\n            })\r\n        );\r\n        this._syncActiveTargets(true);\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        const index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._syncActiveTargets(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @hidden\r\n     */\r\n    public _bind(effect: Effect) {\r\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\r\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\r\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        const copy = new MorphTargetManager(this._scene);\r\n\r\n        for (const target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (const target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate: boolean): void {\r\n        if (this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._vertexCount = 0;\r\n\r\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\r\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\r\n        }\r\n\r\n        let targetIndex = -1;\r\n        for (const target of this._targets) {\r\n            targetIndex++;\r\n            if (target.influence === 0 && this.optimizeInfluencers) {\r\n                continue;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n\r\n            const positions = target.getPositions();\r\n            if (positions) {\r\n                const vertexCount = positions.length / 3;\r\n                if (this._vertexCount === 0) {\r\n                    this._vertexCount = vertexCount;\r\n                } else if (this._vertexCount !== vertexCount) {\r\n                    Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (let index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this.synchronize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene || this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        if (this.isUsingTextureForTargets && this._vertexCount) {\r\n            this._textureVertexStride = 1;\r\n\r\n            if (this._supportsNormals) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            if (this._supportsTangents) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            if (this._supportsUVs) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            this._textureWidth = this._vertexCount * this._textureVertexStride;\r\n            this._textureHeight = 1;\r\n\r\n            const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;\r\n            if (this._textureWidth > maxTextureSize) {\r\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\r\n                this._textureWidth = maxTextureSize;\r\n            }\r\n\r\n            let mustUpdateTexture = true;\r\n            if (this._targetStoreTexture) {\r\n                const textureSize = this._targetStoreTexture.getSize();\r\n                if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {\r\n                    mustUpdateTexture = false;\r\n                }\r\n            }\r\n\r\n            if (mustUpdateTexture) {\r\n                if (this._targetStoreTexture) {\r\n                    this._targetStoreTexture.dispose();\r\n                }\r\n\r\n                const targetCount = this._targets.length;\r\n                const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\r\n\r\n                let offset = 0;\r\n                for (let index = 0; index < targetCount; index++) {\r\n                    const target = this._targets[index];\r\n\r\n                    const positions = target.getPositions();\r\n                    const normals = target.getNormals();\r\n                    const uvs = target.getUVs();\r\n                    const tangents = target.getTangents();\r\n\r\n                    if (!positions) {\r\n                        if (index === 0) {\r\n                            Logger.Error(\"Invalid morph target. Target must have positions.\");\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    offset = index * this._textureWidth * this._textureHeight * 4;\r\n                    for (let vertex = 0; vertex < this._vertexCount; vertex++) {\r\n                        data[offset] = positions[vertex * 3];\r\n                        data[offset + 1] = positions[vertex * 3 + 1];\r\n                        data[offset + 2] = positions[vertex * 3 + 2];\r\n\r\n                        offset += 4;\r\n\r\n                        if (normals) {\r\n                            data[offset] = normals[vertex * 3];\r\n                            data[offset + 1] = normals[vertex * 3 + 1];\r\n                            data[offset + 2] = normals[vertex * 3 + 2];\r\n                            offset += 4;\r\n                        }\r\n\r\n                        if (uvs) {\r\n                            data[offset] = uvs[vertex * 2];\r\n                            data[offset + 1] = uvs[vertex * 2 + 1];\r\n                            offset += 4;\r\n                        }\r\n\r\n                        if (tangents) {\r\n                            data[offset] = tangents[vertex * 3];\r\n                            data[offset + 1] = tangents[vertex * 3 + 1];\r\n                            data[offset + 2] = tangents[vertex * 3 + 2];\r\n                            offset += 4;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(\r\n                    data,\r\n                    this._textureWidth,\r\n                    this._textureHeight,\r\n                    targetCount,\r\n                    this._scene,\r\n                    false,\r\n                    false,\r\n                    Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                    Constants.TEXTURETYPE_FLOAT\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (const mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose() {\r\n        if (this._targetStoreTexture) {\r\n            this._targetStoreTexture.dispose();\r\n        }\r\n\r\n        this._targetStoreTexture = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            this._scene.removeMorphTargetManager(this);\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        const result = new MorphTargetManager(scene);\r\n\r\n        result._uniqueId = serializationObject.id;\r\n\r\n        for (const targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData, scene));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}