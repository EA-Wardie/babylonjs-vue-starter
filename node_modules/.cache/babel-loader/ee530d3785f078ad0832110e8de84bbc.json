{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\n/**\n * Provides render target textures and other important rendering information for a given XRLayer.\n * @hidden\n */\n\nvar WebXRLayerRenderTargetTextureProvider =\n/** @class */\nfunction () {\n  function WebXRLayerRenderTargetTextureProvider(_scene, layerWrapper) {\n    this._scene = _scene;\n    this.layerWrapper = layerWrapper;\n    this._renderTargetTextures = new Array();\n    this._engine = _scene.getEngine();\n  }\n\n  WebXRLayerRenderTargetTextureProvider.prototype._createInternalTexture = function (textureSize, texture) {\n    var internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\n    internalTexture.width = textureSize.width;\n    internalTexture.height = textureSize.height;\n    internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\n    internalTexture.isReady = true;\n    return internalTexture;\n  };\n\n  WebXRLayerRenderTargetTextureProvider.prototype._createRenderTargetTexture = function (width, height, framebuffer, colorTexture, depthStencilTexture, multiview) {\n    if (!this._engine) {\n      throw new Error(\"Engine is disposed\");\n    }\n\n    var textureSize = {\n      width: width,\n      height: height\n    }; // Create render target texture from the internal texture\n\n    var renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\n    var renderTargetWrapper = renderTargetTexture.renderTarget; // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\n\n    if (framebuffer || !colorTexture) {\n      renderTargetWrapper._framebuffer = framebuffer;\n    } // Create internal texture\n\n\n    if (colorTexture) {\n      if (multiview) {\n        renderTargetWrapper._colorTextureArray = colorTexture;\n      } else {\n        var internalTexture = this._createInternalTexture(textureSize, colorTexture);\n\n        renderTargetWrapper.setTexture(internalTexture, 0);\n        renderTargetTexture._texture = internalTexture;\n      }\n    }\n\n    if (depthStencilTexture) {\n      if (multiview) {\n        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\n      } else {\n        renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\n      }\n    }\n\n    renderTargetTexture.disableRescaling(); // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\n\n    if (typeof XRWebGLBinding !== \"undefined\") {\n      // WebXR pre-clears textures\n      renderTargetTexture.skipInitialClear = true;\n    }\n\n    this._renderTargetTextures.push(renderTargetTexture);\n\n    return renderTargetTexture;\n  };\n\n  WebXRLayerRenderTargetTextureProvider.prototype._destroyRenderTargetTexture = function (renderTargetTexture) {\n    this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\n\n    renderTargetTexture.dispose();\n  };\n\n  WebXRLayerRenderTargetTextureProvider.prototype.getFramebufferDimensions = function () {\n    return this._framebufferDimensions;\n  };\n\n  WebXRLayerRenderTargetTextureProvider.prototype.dispose = function () {\n    this._renderTargetTextures.forEach(function (rtt) {\n      return rtt.dispose();\n    });\n\n    this._renderTargetTextures.length = 0;\n  };\n\n  return WebXRLayerRenderTargetTextureProvider;\n}();\n\nexport { WebXRLayerRenderTargetTextureProvider };","map":{"version":3,"mappings":"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","names":["WebGLHardwareTexture","InternalTexture","InternalTextureSource","MultiviewRenderTarget","RenderTargetTexture","_scene","layerWrapper","Array","_engine","getEngine","WebXRLayerRenderTargetTextureProvider","textureSize","texture","internalTexture","Unknown","width","height","_hardwareTexture","_gl","isReady","framebuffer","colorTexture","depthStencilTexture","multiview","Error","renderTargetTexture","renderTargetWrapper","renderTarget","_framebuffer","_colorTextureArray","_createInternalTexture","setTexture","_texture","_depthStencilTextureArray","_depthStencilTexture","disableRescaling","XRWebGLBinding","skipInitialClear","_renderTargetTextures","push","splice","indexOf","dispose","_framebufferDimensions","forEach","rtt","length"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRRenderTargetTextureProvider.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @hidden\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(private readonly _scene: Scene, public readonly layerWrapper: WebXRLayerWrapper) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\r\n        if (typeof XRWebGLBinding !== \"undefined\") {\r\n            // WebXR pre-clears textures\r\n            renderTargetTexture.skipInitialClear = true;\r\n        }\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}