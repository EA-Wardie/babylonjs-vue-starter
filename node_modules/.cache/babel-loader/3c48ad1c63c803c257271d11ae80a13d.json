{"ast":null,"code":"import \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\n\nMesh.prototype.thinInstanceAdd = function (matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n\n  var index = this._thinInstanceDataStorage.instancesCount;\n\n  if (Array.isArray(matrix)) {\n    for (var i = 0; i < matrix.length; ++i) {\n      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n    }\n  } else {\n    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n  }\n\n  return index;\n};\n\nMesh.prototype.thinInstanceAddSelf = function (refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\n\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n  this.removeVerticesData(kind);\n\n  this._thinInstanceInitializeUserStorage();\n\n  this._userThinInstanceBuffersStorage.strides[kind] = stride;\n  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n\n  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\n\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n  matrix.copyToArray(matrixData, index * 16);\n\n  if (this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n  }\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(\"matrix\");\n\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n\n  return true;\n};\n\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n\n\n  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(kind);\n  }\n\n  return true;\n};\n\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n  get: function get() {\n    return this._thinInstanceDataStorage.instancesCount;\n  },\n  set: function set(value) {\n    var _a, _b;\n\n    var numMaxInstances = ((_b = (_a = this._thinInstanceDataStorage.matrixData) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) / 16;\n\n    if (value <= numMaxInstances) {\n      this._thinInstanceDataStorage.instancesCount = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind, buffer, staticBuffer) {\n  if (staticBuffer === void 0) {\n    staticBuffer = false;\n  }\n\n  var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\n\n  for (var i = 0; i < 4; i++) {\n    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\n  }\n\n  return matrixBuffer;\n};\n\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride, staticBuffer) {\n  var _a, _b, _c;\n\n  if (stride === void 0) {\n    stride = 0;\n  }\n\n  if (staticBuffer === void 0) {\n    staticBuffer = false;\n  }\n\n  stride = stride || 16;\n\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n    this._thinInstanceDataStorage.matrixData = buffer;\n    this._thinInstanceDataStorage.worldMatrices = null;\n\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\n\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    } else {\n      this._thinInstanceDataStorage.instancesCount = 0;\n\n      if (!this.doNotSyncBoundingInfo) {\n        // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n        this.refreshBoundingInfo();\n      }\n    }\n  } else if (kind === \"previousMatrix\") {\n    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._thinInstanceDataStorage.previousMatrixBuffer = null;\n    this._thinInstanceDataStorage.previousMatrixData = buffer;\n\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\n    }\n  } else {\n    // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\n    // hot switching kind here to preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n\n    if (buffer === null) {\n      if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {\n        this.removeVerticesData(kind);\n        delete this._userThinInstanceBuffersStorage.data[kind];\n        delete this._userThinInstanceBuffersStorage.strides[kind];\n        delete this._userThinInstanceBuffersStorage.sizes[kind];\n        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n      }\n    } else {\n      this._thinInstanceInitializeUserStorage();\n\n      this._userThinInstanceBuffersStorage.data[kind] = buffer;\n      this._userThinInstanceBuffersStorage.strides[kind] = stride;\n      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n  var _a, _b, _c;\n\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else if (kind === \"previousMatrix\") {\n    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n  }\n};\n\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n  var _a;\n\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n    }\n  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n  }\n};\n\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return [];\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (!this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices = new Array();\n\n    for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n    }\n  }\n\n  return this._thinInstanceDataStorage.worldMatrices;\n};\n\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo, applySkeleton, applyMorph) {\n  if (forceRefreshParentInfo === void 0) {\n    forceRefreshParentInfo = false;\n  }\n\n  if (applySkeleton === void 0) {\n    applySkeleton = false;\n  }\n\n  if (applyMorph === void 0) {\n    applyMorph = false;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return;\n  }\n\n  var vectors = this._thinInstanceDataStorage.boundingVectors;\n\n  if (forceRefreshParentInfo) {\n    vectors.length = 0;\n    this.refreshBoundingInfo(applySkeleton, applyMorph);\n  }\n\n  var boundingInfo = this.getBoundingInfo();\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (vectors.length === 0) {\n    for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n      vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n    }\n  }\n\n  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n\n  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n\n  for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n\n    for (var v = 0; v < vectors.length; ++v) {\n      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n    }\n  }\n\n  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n\n  this._updateBoundingInfo();\n};\n\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances) {\n  var _a, _b, _c;\n\n  if (numInstances === void 0) {\n    numInstances = 1;\n  }\n\n  var kindIsMatrix = kind === \"matrix\";\n\n  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n    return;\n  }\n\n  var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n  var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n  var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n  var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n  var newSize = currentSize;\n\n  while (newSize < bufferSize) {\n    newSize *= 2;\n  }\n\n  if (!data || currentSize != newSize) {\n    if (!data) {\n      data = new Float32Array(newSize);\n    } else {\n      var newData = new Float32Array(newSize);\n      newData.set(data, 0);\n      data = newData;\n    }\n\n    if (kindIsMatrix) {\n      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\n      this._thinInstanceDataStorage.matrixData = data;\n      this._thinInstanceDataStorage.matrixBufferSize = newSize;\n\n      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\n        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\n      }\n    } else {\n      (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();\n      this._userThinInstanceBuffersStorage.data[kind] = data;\n      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n  if (!this._userThinInstanceBuffersStorage) {\n    this._userThinInstanceBuffersStorage = {\n      data: {},\n      sizes: {},\n      vertexBuffers: {},\n      strides: {}\n    };\n  }\n};\n\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n  var _a;\n\n  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {\n    this._thinInstanceDataStorage.matrixBuffer.dispose();\n\n    this._thinInstanceDataStorage.matrixBuffer = null;\n  }\n};","map":{"version":3,"mappings":"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","names":["Mesh","VertexBuffer","Buffer","Matrix","Vector3","TmpVectors","prototype","thinInstanceAdd","matrix","refresh","_thinInstanceUpdateBufferSize","Array","isArray","length","index","_thinInstanceDataStorage","instancesCount","i","thinInstanceSetMatrixAt","thinInstanceAddSelf","IdentityReadOnly","thinInstanceRegisterAttribute","kind","stride","removeVerticesData","_thinInstanceInitializeUserStorage","_userThinInstanceBuffersStorage","strides","sizes","Math","max","data","Float32Array","vertexBuffers","getEngine","setVerticesBuffer","matrixData","copyToArray","worldMatrices","thinInstanceBufferUpdated","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetAttributeAt","value","set","Object","defineProperty","get","numMaxInstances","_a","_b","enumerable","configurable","_thinInstanceCreateMatrixBuffer","buffer","staticBuffer","matrixBuffer","createVertexBuffer","thinInstanceSetBuffer","dispose","matrixBufferSize","refreshBoundingInfo","previousMatrixBuffer","previousMatrixData","ColorKind","ColorInstanceKind","_c","updateDirectly","thinInstancePartialBufferUpdate","offset","thinInstanceGetWorldMatrices","FromArray","forceRefreshParentInfo","applySkeleton","applyMorph","vectors","boundingVectors","boundingInfo","getBoundingInfo","v","boundingBox","push","clone","setAll","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","FromArrayToRef","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","reConstruct","_updateBoundingInfo","numInstances","kindIsMatrix","currentSize","bufferSize","newSize","newData","_scene","needsPreviousWorldMatrices","_disposeThinInstanceSpecificData"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/thinInstanceMesh.ts"],"sourcesContent":["import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @return an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @hidden */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @hidden */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @hidden */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @hidden */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const numMaxInstances = (this._thinInstanceDataStorage.matrixData?.length ?? 0) / 16;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = false): Buffer {\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = false): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = new Array<Matrix>();\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}