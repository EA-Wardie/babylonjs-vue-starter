{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { Vector2 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { MTLFileLoader } from \"./mtlFileLoader.js\";\nimport { SolidParser } from \"./solidParser.js\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\n\nvar OBJFileLoader =\n/** @class */\nfunction () {\n  /**\n   * Creates loader for .OBJ files\n   *\n   * @param loadingOptions options for loading and parsing OBJ/MTL files.\n   */\n  function OBJFileLoader(loadingOptions) {\n    /**\n     * Defines the name of the plugin.\n     */\n    this.name = \"obj\";\n    /**\n     * Defines the extension the plugin is able to load.\n     */\n\n    this.extensions = \".obj\";\n    this._assetContainer = null;\n    this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\n  }\n\n  Object.defineProperty(OBJFileLoader, \"INVERT_TEXTURE_Y\", {\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    get: function get() {\n      return MTLFileLoader.INVERT_TEXTURE_Y;\n    },\n    set: function set(value) {\n      MTLFileLoader.INVERT_TEXTURE_Y = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OBJFileLoader, \"_DefaultLoadingOptions\", {\n    get: function get() {\n      return {\n        computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n        optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n        importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n        invertY: OBJFileLoader.INVERT_Y,\n        invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        UVScaling: OBJFileLoader.UV_SCALING,\n        materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n        optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n        skipMaterials: OBJFileLoader.SKIP_MATERIALS\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Calls synchronously the MTL file attached to this obj.\n   * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n   * Without this function materials are not displayed in the first frame (but displayed after).\n   * In consequence it is impossible to get material information in your HTML file\n   *\n   * @param url The URL of the MTL file\n   * @param rootUrl defines where to load data from\n   * @param onSuccess Callback function to be called when the MTL file is loaded\n   * @param onFailure\n   */\n\n  OBJFileLoader.prototype._loadMTL = function (url, rootUrl, onSuccess, onFailure) {\n    //The complete path to the mtl file\n    var pathOfFile = rootUrl + url; // Loads through the babylon tools to allow fileInput search.\n\n    Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, function (request, exception) {\n      onFailure(pathOfFile, exception);\n    });\n  };\n  /**\n   * Instantiates a OBJ file loader plugin.\n   * @returns the created plugin\n   */\n\n\n  OBJFileLoader.prototype.createPlugin = function () {\n    return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\n  };\n  /**\n   * If the data string can be loaded directly.\n   * @returns if the data can be loaded directly\n   */\n\n\n  OBJFileLoader.prototype.canDirectLoad = function () {\n    return false;\n  };\n  /**\n   * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene the scene the meshes should be added to\n   * @param data the OBJ data to load\n   * @param rootUrl root url to load from\n   * @returns a promise containing the loaded meshes, particles, skeletons and animations\n   */\n\n\n  OBJFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl) {\n    //get the meshes from OBJ file\n    return this._parseSolid(meshesNames, scene, data, rootUrl).then(function (meshes) {\n      return {\n        meshes: meshes,\n        particleSystems: [],\n        skeletons: [],\n        animationGroups: [],\n        transformNodes: [],\n        geometries: [],\n        lights: []\n      };\n    });\n  };\n  /**\n   * Imports all objects from the loaded OBJ data and adds them to the scene\n   * @param scene the scene the objects should be added to\n   * @param data the OBJ data to load\n   * @param rootUrl root url to load from\n   * @returns a promise which completes when objects have been loaded to the scene\n   */\n\n\n  OBJFileLoader.prototype.loadAsync = function (scene, data, rootUrl) {\n    //Get the 3D model\n    return this.importMeshAsync(null, scene, data, rootUrl).then(function () {// return void\n    });\n  };\n  /**\n   * Load into an asset container.\n   * @param scene The scene to load into\n   * @param data The data to import\n   * @param rootUrl The root url for scene and resources\n   * @returns The loaded asset container\n   */\n\n\n  OBJFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl) {\n    var _this = this;\n\n    var container = new AssetContainer(scene);\n    this._assetContainer = container;\n    return this.importMeshAsync(null, scene, data, rootUrl).then(function (result) {\n      result.meshes.forEach(function (mesh) {\n        return container.meshes.push(mesh);\n      });\n      result.meshes.forEach(function (mesh) {\n        var material = mesh.material;\n\n        if (material) {\n          // Materials\n          if (container.materials.indexOf(material) == -1) {\n            container.materials.push(material); // Textures\n\n            var textures = material.getActiveTextures();\n            textures.forEach(function (t) {\n              if (container.textures.indexOf(t) == -1) {\n                container.textures.push(t);\n              }\n            });\n          }\n        }\n      });\n      _this._assetContainer = null;\n      return container;\n    })[\"catch\"](function (ex) {\n      _this._assetContainer = null;\n      throw ex;\n    });\n  };\n  /**\n   * Read the OBJ file and create an Array of meshes.\n   * Each mesh contains all information given by the OBJ and the MTL file.\n   * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n   * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene defines the scene where are displayed the data\n   * @param data defines the content of the obj file\n   * @param rootUrl defines the path to the folder\n   * @returns the list of loaded meshes\n   */\n\n\n  OBJFileLoader.prototype._parseSolid = function (meshesNames, scene, data, rootUrl) {\n    var _this = this;\n\n    var fileToLoad = \"\"; //The name of the mtlFile to load\n\n    var materialsFromMTLFile = new MTLFileLoader();\n    var materialToUse = new Array();\n    var babylonMeshesArray = []; //The mesh for babylon\n    // Main function\n\n    var solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n    solidParser.parse(meshesNames, data, scene, this._assetContainer, function (fileName) {\n      fileToLoad = fileName;\n    }); // load the materials\n\n    var mtlPromises = []; // Check if we have a file to load\n\n    if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n      //Load the file synchronously\n      mtlPromises.push(new Promise(function (resolve, reject) {\n        _this._loadMTL(fileToLoad, rootUrl, function (dataLoaded) {\n          try {\n            //Create materials thanks MTLLoader function\n            materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._assetContainer); //Look at each material loaded in the mtl file\n\n            for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n              //Three variables to get all meshes with the same material\n              var startIndex = 0;\n              var _indices = [];\n\n              var _index = void 0; //The material from MTL file is used in the meshes loaded\n              //Push the indice in an array\n              //Check if the material is not used for another mesh\n\n\n              while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                _indices.push(_index);\n\n                startIndex = _index + 1;\n              } //If the material is not used dispose it\n\n\n              if (_index === -1 && _indices.length === 0) {\n                //If the material is not needed, remove it\n                materialsFromMTLFile.materials[n].dispose();\n              } else {\n                for (var o = 0; o < _indices.length; o++) {\n                  //Apply the material to the Mesh for each mesh with the material\n                  var mesh = babylonMeshesArray[_indices[o]];\n                  var material = materialsFromMTLFile.materials[n];\n                  mesh.material = material;\n\n                  if (!mesh.getTotalIndices()) {\n                    // No indices, we need to turn on point cloud\n                    material.pointsCloud = true;\n                  }\n                }\n              }\n            }\n\n            resolve();\n          } catch (e) {\n            Tools.Warn(\"Error processing MTL file: '\".concat(fileToLoad, \"'\"));\n\n            if (_this._loadingOptions.materialLoadingFailsSilently) {\n              resolve();\n            } else {\n              reject(e);\n            }\n          }\n        }, function (pathOfFile, exception) {\n          Tools.Warn(\"Error downloading MTL file: '\".concat(fileToLoad, \"'\"));\n\n          if (_this._loadingOptions.materialLoadingFailsSilently) {\n            resolve();\n          } else {\n            reject(exception);\n          }\n        });\n      }));\n    } //Return an array with all Mesh\n\n\n    return Promise.all(mtlPromises).then(function () {\n      return babylonMeshesArray;\n    });\n  };\n  /**\n   * Defines if UVs are optimized by default during load.\n   */\n\n\n  OBJFileLoader.OPTIMIZE_WITH_UV = true;\n  /**\n   * Invert model on y-axis (does a model scaling inversion)\n   */\n\n  OBJFileLoader.INVERT_Y = false;\n  /**\n   * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n   */\n\n  OBJFileLoader.IMPORT_VERTEX_COLORS = false;\n  /**\n   * Compute the normals for the model, even if normals are present in the file.\n   */\n\n  OBJFileLoader.COMPUTE_NORMALS = false;\n  /**\n   * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n   * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n   */\n\n  OBJFileLoader.OPTIMIZE_NORMALS = false;\n  /**\n   * Defines custom scaling of UV coordinates of loaded meshes.\n   */\n\n  OBJFileLoader.UV_SCALING = new Vector2(1, 1);\n  /**\n   * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n   */\n\n  OBJFileLoader.SKIP_MATERIALS = false;\n  /**\n   * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n   *\n   * Defaults to true for backwards compatibility.\n   */\n\n  OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\n  return OBJFileLoader;\n}();\n\nexport { OBJFileLoader };\n\nif (SceneLoader) {\n  //Add this loader into the register plugin\n  SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","map":{"version":3,"mappings":"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","names":["Vector2","Tools","SceneLoader","AssetContainer","MTLFileLoader","SolidParser","loadingOptions","_loadingOptions","OBJFileLoader","_DefaultLoadingOptions","Object","INVERT_TEXTURE_Y","value","computeNormals","COMPUTE_NORMALS","optimizeNormals","OPTIMIZE_NORMALS","importVertexColors","IMPORT_VERTEX_COLORS","invertY","INVERT_Y","invertTextureY","UVScaling","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","optimizeWithUV","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","url","rootUrl","onSuccess","onFailure","pathOfFile","LoadFile","undefined","request","exception","meshesNames","scene","data","_parseSolid","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","importMeshAsync","container","_assetContainer","result","forEach","mesh","push","material","materials","indexOf","textures","getActiveTextures","t","_this","ex","fileToLoad","materialsFromMTLFile","materialToUse","Array","babylonMeshesArray","solidParser","parse","fileName","mtlPromises","Promise","resolve","reject","_loadMTL","dataLoaded","parseMTL","n","length","startIndex","_indices","_index","name","dispose","o","getTotalIndices","pointsCloud","e","Warn","all","RegisterPlugin"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/OBJ/objFileLoader.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"core/Loading/sceneLoader\";\r\nimport { SceneLoader } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public name = \"obj\";\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public extensions = \".obj\";\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: OBJLoadingOptions) {\r\n        this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest | undefined, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiates a OBJ file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return this.importMeshAsync(null, scene, data, rootUrl)\r\n            .then((result) => {\r\n                result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                result.meshes.forEach((mesh) => {\r\n                    const material = mesh.material;\r\n                    if (material) {\r\n                        // Materials\r\n                        if (container.materials.indexOf(material) == -1) {\r\n                            container.materials.push(material);\r\n\r\n                            // Textures\r\n                            const textures = material.getActiveTextures();\r\n                            textures.forEach((t) => {\r\n                                if (container.textures.indexOf(t) == -1) {\r\n                                    container.textures.push(t);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                this._assetContainer = null;\r\n                return container;\r\n            })\r\n            .catch((ex) => {\r\n                this._assetContainer = null;\r\n                throw ex;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse = new Array<string>();\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        return Promise.all(mtlPromises).then(() => {\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    //Add this loader into the register plugin\r\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\r\n}\r\n"]},"metadata":{},"sourceType":"module"}