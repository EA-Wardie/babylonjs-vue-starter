{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.string.substr.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/** @hidden */\nvar ShaderDefineExpression =\n/** @class */\nfunction () {\n  function ShaderDefineExpression() {} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ShaderDefineExpression.prototype.isTrue = function (preprocessors) {\n    return true;\n  };\n\n  ShaderDefineExpression.postfixToInfix = function (postfix) {\n    var stack = [];\n\n    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {\n      var c = postfix_1[_i];\n\n      if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\n        stack.push(c);\n      } else {\n        var v1 = stack[stack.length - 1],\n            v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        stack.push(\"(\".concat(v2).concat(c).concat(v1, \")\"));\n      }\n    }\n\n    return stack[stack.length - 1];\n  };\n\n  ShaderDefineExpression.infixToPostfix = function (infix) {\n    var result = [];\n    var stackIdx = -1;\n\n    var pushOperand = function pushOperand() {\n      operand = operand.trim();\n\n      if (operand !== \"\") {\n        result.push(operand);\n        operand = \"\";\n      }\n    };\n\n    var push = function push(s) {\n      if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\n        ShaderDefineExpression._Stack[++stackIdx] = s;\n      }\n    };\n\n    var peek = function peek() {\n      return ShaderDefineExpression._Stack[stackIdx];\n    };\n\n    var pop = function pop() {\n      return stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--];\n    };\n\n    var idx = 0,\n        operand = \"\";\n\n    while (idx < infix.length) {\n      var c = infix.charAt(idx),\n          token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\n\n      if (c === \"(\") {\n        operand = \"\";\n        push(c);\n      } else if (c === \")\") {\n        pushOperand();\n\n        while (stackIdx !== -1 && peek() !== \"(\") {\n          result.push(pop());\n        }\n\n        pop();\n      } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\n        pushOperand();\n\n        while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\n          result.push(pop());\n        }\n\n        push(token);\n        idx++;\n      } else {\n        operand += c;\n      }\n\n      idx++;\n    }\n\n    pushOperand();\n\n    while (stackIdx !== -1) {\n      if (peek() === \"(\") {\n        pop();\n      } else {\n        result.push(pop());\n      }\n    }\n\n    return result;\n  };\n\n  ShaderDefineExpression._OperatorPriority = {\n    \")\": 0,\n    \"(\": 1,\n    \"||\": 2,\n    \"&&\": 3\n  };\n  ShaderDefineExpression._Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n  return ShaderDefineExpression;\n}();\n\nexport { ShaderDefineExpression };","map":{"version":3,"mappings":";;;;AAAA;;AACA;AACA;AAAA;AAAA;AAAA,qCAiGC,CAjGD,CACI;;;AACOA,4CAAP,UAAcC,aAAd,EAAsD;AAClD,WAAO,IAAP;AACH,GAFM;;AAaOD,0CAAd,UAA6BE,OAA7B,EAA8C;AAC1C,QAAMC,KAAK,GAAa,EAAxB;;AAEA,SAAgB,+BAAhB,EAAgBC,qBAAhB,EAAgBA,IAAhB,EAAyB;AAApB,UAAMC,CAAC,gBAAP;;AACD,UAAIL,sBAAsB,CAACM,iBAAvB,CAAyCD,CAAzC,MAAgDE,SAApD,EAA+D;AAC3DJ,aAAK,CAACK,IAAN,CAAWH,CAAX;AACH,OAFD,MAEO;AACH,YAAMI,EAAE,GAAGN,KAAK,CAACA,KAAK,CAACO,MAAN,GAAe,CAAhB,CAAhB;AAAA,YACIC,EAAE,GAAGR,KAAK,CAACA,KAAK,CAACO,MAAN,GAAe,CAAhB,CADd;AAGAP,aAAK,CAACO,MAAN,IAAgB,CAAhB;AACAP,aAAK,CAACK,IAAN,CAAW,WAAIG,EAAJ,EAAMC,MAAN,CAASP,CAAT,EAAUO,MAAV,CAAaH,EAAb,EAAe,GAAf,CAAX;AACH;AACJ;;AAED,WAAON,KAAK,CAACA,KAAK,CAACO,MAAN,GAAe,CAAhB,CAAZ;AACH,GAhBa;;AAkBAV,0CAAd,UAA6Ba,KAA7B,EAA0C;AACtC,QAAMC,MAAM,GAAa,EAAzB;AAEA,QAAIC,QAAQ,GAAG,CAAC,CAAhB;;AAEA,QAAMC,WAAW,GAAG,SAAdA,WAAc;AAChBC,aAAO,GAAGA,OAAO,CAACC,IAAR,EAAV;;AACA,UAAID,OAAO,KAAK,EAAhB,EAAoB;AAChBH,cAAM,CAACN,IAAP,CAAYS,OAAZ;AACAA,eAAO,GAAG,EAAV;AACH;AACJ,KAND;;AAQA,QAAMT,IAAI,GAAG,SAAPA,IAAO,CAACW,CAAD,EAAU;AACnB,UAAIJ,QAAQ,GAAGf,sBAAsB,CAACoB,MAAvB,CAA8BV,MAA9B,GAAuC,CAAtD,EAAyD;AACrDV,8BAAsB,CAACoB,MAAvB,CAA8B,EAAEL,QAAhC,IAA4CI,CAA5C;AACH;AACJ,KAJD;;AAMA,QAAME,IAAI,GAAG,SAAPA,IAAO;AAAM,mCAAsB,CAACD,MAAvB,CAA8BL,QAA9B;AAAuC,KAA1D;;AAEA,QAAMO,GAAG,GAAG,SAANA,GAAM;AAAM,aAACP,QAAQ,KAAK,CAAC,CAAd,GAAkB,wBAAlB,GAA6Cf,sBAAsB,CAACoB,MAAvB,CAA8BL,QAAQ,EAAtC,CAA9C;AAAwF,KAA1G;;AAEA,QAAIQ,GAAG,GAAG,CAAV;AAAA,QACIN,OAAO,GAAG,EADd;;AAGA,WAAOM,GAAG,GAAGV,KAAK,CAACH,MAAnB,EAA2B;AACvB,UAAML,CAAC,GAAGQ,KAAK,CAACW,MAAN,CAAaD,GAAb,CAAV;AAAA,UACIE,KAAK,GAAGF,GAAG,GAAGV,KAAK,CAACH,MAAN,GAAe,CAArB,GAAyBG,KAAK,CAACa,MAAN,CAAaH,GAAb,EAAkB,CAAlB,CAAzB,GAAgD,EAD5D;;AAGA,UAAIlB,CAAC,KAAK,GAAV,EAAe;AACXY,eAAO,GAAG,EAAV;AACAT,YAAI,CAACH,CAAD,CAAJ;AACH,OAHD,MAGO,IAAIA,CAAC,KAAK,GAAV,EAAe;AAClBW,mBAAW;;AACX,eAAOD,QAAQ,KAAK,CAAC,CAAd,IAAmBM,IAAI,OAAO,GAArC,EAA0C;AACtCP,gBAAM,CAACN,IAAP,CAAYc,GAAG,EAAf;AACH;;AACDA,WAAG;AACN,OANM,MAMA,IAAItB,sBAAsB,CAACM,iBAAvB,CAAyCmB,KAAzC,IAAkD,CAAtD,EAAyD;AAC5DT,mBAAW;;AACX,eAAOD,QAAQ,KAAK,CAAC,CAAd,IAAmBf,sBAAsB,CAACM,iBAAvB,CAAyCe,IAAI,EAA7C,KAAoDrB,sBAAsB,CAACM,iBAAvB,CAAyCmB,KAAzC,CAA9E,EAA+H;AAC3HX,gBAAM,CAACN,IAAP,CAAYc,GAAG,EAAf;AACH;;AACDd,YAAI,CAACiB,KAAD,CAAJ;AACAF,WAAG;AACN,OAPM,MAOA;AACHN,eAAO,IAAIZ,CAAX;AACH;;AACDkB,SAAG;AACN;;AAEDP,eAAW;;AAEX,WAAOD,QAAQ,KAAK,CAAC,CAArB,EAAwB;AACpB,UAAIM,IAAI,OAAO,GAAf,EAAoB;AAChBC,WAAG;AACN,OAFD,MAEO;AACHR,cAAM,CAACN,IAAP,CAAYc,GAAG,EAAf;AACH;AACJ;;AAED,WAAOR,MAAP;AACH,GA/Da;;AA3BCd,6CAAgD;AAC3D,SAAK,CADsD;AAE3D,SAAK,CAFsD;AAG3D,UAAM,CAHqD;AAI3D,UAAM;AAJqD,GAAhD;AAOAA,kCAAS,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,EAArC,EAAyC,EAAzC,EAA6C,EAA7C,EAAiD,EAAjD,EAAqD,EAArD,EAAyD,EAAzD,EAA6D,EAA7D,EAAiE,EAAjE,EAAqE,EAArE,EAAyE,EAAzE,EAA6E,EAA7E,CAAT;AAoFnB;AAAC,CAjGD;;SAAaA","names":["ShaderDefineExpression","preprocessors","postfix","stack","_i","c","_OperatorPriority","undefined","push","v1","length","v2","concat","infix","result","stackIdx","pushOperand","operand","trim","s","_Stack","peek","pop","idx","charAt","token","substr"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/Processors/Expressions/shaderDefineExpression.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @hidden */\r\nexport class ShaderDefineExpression {\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    private static _OperatorPriority: { [name: string]: number } = {\r\n        \")\": 0,\r\n        \"(\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n    };\r\n\r\n    private static _Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\r\n\r\n    public static postfixToInfix(postfix: string[]): string {\r\n        const stack: string[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\r\n                stack.push(c);\r\n            } else {\r\n                const v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n                stack.push(`(${v2}${c}${v1})`);\r\n            }\r\n        }\r\n\r\n        return stack[stack.length - 1];\r\n    }\r\n\r\n    public static infixToPostfix(infix: string): string[] {\r\n        const result: string[] = [];\r\n\r\n        let stackIdx = -1;\r\n\r\n        const pushOperand = () => {\r\n            operand = operand.trim();\r\n            if (operand !== \"\") {\r\n                result.push(operand);\r\n                operand = \"\";\r\n            }\r\n        };\r\n\r\n        const push = (s: string) => {\r\n            if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\r\n                ShaderDefineExpression._Stack[++stackIdx] = s;\r\n            }\r\n        };\r\n\r\n        const peek = () => ShaderDefineExpression._Stack[stackIdx];\r\n\r\n        const pop = () => (stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--]);\r\n\r\n        let idx = 0,\r\n            operand = \"\";\r\n\r\n        while (idx < infix.length) {\r\n            const c = infix.charAt(idx),\r\n                token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\r\n\r\n            if (c === \"(\") {\r\n                operand = \"\";\r\n                push(c);\r\n            } else if (c === \")\") {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && peek() !== \"(\") {\r\n                    result.push(pop());\r\n                }\r\n                pop();\r\n            } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\r\n                    result.push(pop());\r\n                }\r\n                push(token);\r\n                idx++;\r\n            } else {\r\n                operand += c;\r\n            }\r\n            idx++;\r\n        }\r\n\r\n        pushOperand();\r\n\r\n        while (stackIdx !== -1) {\r\n            if (peek() === \"(\") {\r\n                pop();\r\n            } else {\r\n                result.push(pop());\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}