{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { Scene } from \"../scene.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Class representing a ray with position and direction\n */\n\nvar Ray =\n/** @class */\nfunction () {\n  /**\n   * Creates a new ray\n   * @param origin origin point\n   * @param direction direction\n   * @param length length of the ray\n   */\n  function Ray(\n  /** origin point */\n  origin,\n  /** direction */\n  direction,\n  /** length of the ray */\n  length) {\n    if (length === void 0) {\n      length = Number.MAX_VALUE;\n    }\n\n    this.origin = origin;\n    this.direction = direction;\n    this.length = length;\n  } // Methods\n\n  /**\n   * Clone the current ray\n   * @returns a new ray\n   */\n\n\n  Ray.prototype.clone = function () {\n    return new Ray(this.origin.clone(), this.direction.clone(), this.length);\n  };\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray length by design to improve perfs.\n   * @param minimum bound of the box\n   * @param maximum bound of the box\n   * @param intersectionTreshold extra extend to be added to the box in all direction\n   * @returns if the box was hit\n   */\n\n\n  Ray.prototype.intersectsBoxMinMax = function (minimum, maximum, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n\n    var newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n\n    var d = 0.0;\n    var maxValue = Number.MAX_VALUE;\n    var inv;\n    var min;\n    var max;\n    var temp;\n\n    if (Math.abs(this.direction.x) < 0.0000001) {\n      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.x;\n      min = (newMinimum.x - this.origin.x) * inv;\n      max = (newMaximum.x - this.origin.x) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.y) < 0.0000001) {\n      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.y;\n      min = (newMinimum.y - this.origin.y) * inv;\n      max = (newMaximum.y - this.origin.y) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.z) < 0.0000001) {\n      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.z;\n      min = (newMinimum.z - this.origin.z) * inv;\n      max = (newMaximum.z - this.origin.z) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray lenght by design to improve perfs.\n   * @param box the bounding box to check\n   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\n   * @returns if the box was hit\n   */\n\n\n  Ray.prototype.intersectsBox = function (box, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n  };\n  /**\n   * If the ray hits a sphere\n   * @param sphere the bounding sphere to check\n   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\n   * @returns true if it hits the sphere\n   */\n\n\n  Ray.prototype.intersectsSphere = function (sphere, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var x = sphere.center.x - this.origin.x;\n    var y = sphere.center.y - this.origin.y;\n    var z = sphere.center.z - this.origin.z;\n    var pyth = x * x + y * y + z * z;\n    var radius = sphere.radius + intersectionTreshold;\n    var rr = radius * radius;\n\n    if (pyth <= rr) {\n      return true;\n    }\n\n    var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n\n    if (dot < 0.0) {\n      return false;\n    }\n\n    var temp = pyth - dot * dot;\n    return temp <= rr;\n  };\n  /**\n   * If the ray hits a triange\n   * @param vertex0 triangle vertex\n   * @param vertex1 triangle vertex\n   * @param vertex2 triangle vertex\n   * @returns intersection information if hit\n   */\n\n\n  Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {\n    var edge1 = Ray._TmpVector3[0];\n    var edge2 = Ray._TmpVector3[1];\n    var pvec = Ray._TmpVector3[2];\n    var tvec = Ray._TmpVector3[3];\n    var qvec = Ray._TmpVector3[4];\n    vertex1.subtractToRef(vertex0, edge1);\n    vertex2.subtractToRef(vertex0, edge2);\n    Vector3.CrossToRef(this.direction, edge2, pvec);\n    var det = Vector3.Dot(edge1, pvec);\n\n    if (det === 0) {\n      return null;\n    }\n\n    var invdet = 1 / det;\n    this.origin.subtractToRef(vertex0, tvec);\n    var bv = Vector3.Dot(tvec, pvec) * invdet;\n\n    if (bv < 0 || bv > 1.0) {\n      return null;\n    }\n\n    Vector3.CrossToRef(tvec, edge1, qvec);\n    var bw = Vector3.Dot(this.direction, qvec) * invdet;\n\n    if (bw < 0 || bv + bw > 1.0) {\n      return null;\n    } //check if the distance is longer than the predefined length.\n\n\n    var distance = Vector3.Dot(edge2, qvec) * invdet;\n\n    if (distance > this.length) {\n      return null;\n    }\n\n    return new IntersectionInfo(1 - bv - bw, bv, distance);\n  };\n  /**\n   * Checks if ray intersects a plane\n   * @param plane the plane to check\n   * @returns the distance away it was hit\n   */\n\n\n  Ray.prototype.intersectsPlane = function (plane) {\n    var distance;\n    var result1 = Vector3.Dot(plane.normal, this.direction);\n\n    if (Math.abs(result1) < 9.99999997475243e-7) {\n      return null;\n    } else {\n      var result2 = Vector3.Dot(plane.normal, this.origin);\n      distance = (-plane.d - result2) / result1;\n\n      if (distance < 0.0) {\n        if (distance < -9.99999997475243e-7) {\n          return null;\n        } else {\n          return 0;\n        }\n      }\n\n      return distance;\n    }\n  };\n  /**\n   * Calculate the intercept of a ray on a given axis\n   * @param axis to check 'x' | 'y' | 'z'\n   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\n   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\n   */\n\n\n  Ray.prototype.intersectsAxis = function (axis, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    switch (axis) {\n      case \"y\":\n        {\n          var t = (this.origin.y - offset) / this.direction.y;\n\n          if (t > 0) {\n            return null;\n          }\n\n          return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n        }\n\n      case \"x\":\n        {\n          var t = (this.origin.x - offset) / this.direction.x;\n\n          if (t > 0) {\n            return null;\n          }\n\n          return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n        }\n\n      case \"z\":\n        {\n          var t = (this.origin.z - offset) / this.direction.z;\n\n          if (t > 0) {\n            return null;\n          }\n\n          return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n        }\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Checks if ray intersects a mesh\n   * @param mesh the mesh to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @returns picking info of the intersection\n   */\n\n\n  Ray.prototype.intersectsMesh = function (mesh, fastCheck) {\n    var tm = TmpVectors.Matrix[0];\n    mesh.getWorldMatrix().invertToRef(tm);\n\n    if (this._tmpRay) {\n      Ray.TransformToRef(this, tm, this._tmpRay);\n    } else {\n      this._tmpRay = Ray.Transform(this, tm);\n    }\n\n    return mesh.intersects(this._tmpRay, fastCheck);\n  };\n  /**\n   * Checks if ray intersects a mesh\n   * @param meshes the meshes to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param results array to store result in\n   * @returns Array of picking infos\n   */\n\n\n  Ray.prototype.intersectsMeshes = function (meshes, fastCheck, results) {\n    if (results) {\n      results.length = 0;\n    } else {\n      results = [];\n    }\n\n    for (var i = 0; i < meshes.length; i++) {\n      var pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n\n      if (pickInfo.hit) {\n        results.push(pickInfo);\n      }\n    }\n\n    results.sort(this._comparePickingInfo);\n    return results;\n  };\n\n  Ray.prototype._comparePickingInfo = function (pickingInfoA, pickingInfoB) {\n    if (pickingInfoA.distance < pickingInfoB.distance) {\n      return -1;\n    } else if (pickingInfoA.distance > pickingInfoB.distance) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Intersection test between the ray and a given segment within a given tolerance (threshold)\n   * @param sega the first point of the segment to test the intersection against\n   * @param segb the second point of the segment to test the intersection against\n   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n   * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n   */\n\n\n  Ray.prototype.intersectionSegment = function (sega, segb, threshold) {\n    var o = this.origin;\n    var u = TmpVectors.Vector3[0];\n    var rsegb = TmpVectors.Vector3[1];\n    var v = TmpVectors.Vector3[2];\n    var w = TmpVectors.Vector3[3];\n    segb.subtractToRef(sega, u);\n    this.direction.scaleToRef(Ray._Rayl, v);\n    o.addToRef(v, rsegb);\n    sega.subtractToRef(o, w);\n    var a = Vector3.Dot(u, u); // always >= 0\n\n    var b = Vector3.Dot(u, v);\n    var c = Vector3.Dot(v, v); // always >= 0\n\n    var d = Vector3.Dot(u, w);\n    var e = Vector3.Dot(v, w);\n    var D = a * c - b * b; // always >= 0\n\n    var sN,\n        sD = D; // sc = sN / sD, default sD = D >= 0\n\n    var tN,\n        tD = D; // tc = tN / tD, default tD = D >= 0\n    // compute the line parameters of the two closest points\n\n    if (D < Ray._Smallnum) {\n      // the lines are almost parallel\n      sN = 0.0; // force using point P0 on segment S1\n\n      sD = 1.0; // to prevent possible division by 0.0 later\n\n      tN = e;\n      tD = c;\n    } else {\n      // get the closest points on the infinite lines\n      sN = b * e - c * d;\n      tN = a * e - b * d;\n\n      if (sN < 0.0) {\n        // sc < 0 => the s=0 edge is visible\n        sN = 0.0;\n        tN = e;\n        tD = c;\n      } else if (sN > sD) {\n        // sc > 1 => the s=1 edge is visible\n        sN = sD;\n        tN = e + b;\n        tD = c;\n      }\n    }\n\n    if (tN < 0.0) {\n      // tc < 0 => the t=0 edge is visible\n      tN = 0.0; // recompute sc for this edge\n\n      if (-d < 0.0) {\n        sN = 0.0;\n      } else if (-d > a) {\n        sN = sD;\n      } else {\n        sN = -d;\n        sD = a;\n      }\n    } else if (tN > tD) {\n      // tc > 1 => the t=1 edge is visible\n      tN = tD; // recompute sc for this edge\n\n      if (-d + b < 0.0) {\n        sN = 0;\n      } else if (-d + b > a) {\n        sN = sD;\n      } else {\n        sN = -d + b;\n        sD = a;\n      }\n    } // finally do the division to get sc and tc\n\n\n    var sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\n    var tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD; // get the difference of the two closest points\n\n    var qtc = TmpVectors.Vector3[4];\n    v.scaleToRef(tc, qtc);\n    var qsc = TmpVectors.Vector3[5];\n    u.scaleToRef(sc, qsc);\n    qsc.addInPlace(w);\n    var dP = TmpVectors.Vector3[6];\n    qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n\n    var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n\n    if (isIntersected) {\n      return qsc.length();\n    }\n\n    return -1;\n  };\n  /**\n   * Update the ray from viewport position\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns this ray updated\n   */\n\n\n  Ray.prototype.update = function (x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking) {\n    if (enableDistantPicking === void 0) {\n      enableDistantPicking = false;\n    }\n\n    if (enableDistantPicking) {\n      // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\n      // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\n      // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\n      // This is slower (2 matrix inverts instead of 1) but precision is preserved.\n      // This is hidden behind `EnableDistantPicking` flag (default is false)\n      if (!Ray._RayDistant) {\n        Ray._RayDistant = Ray.Zero();\n      }\n\n      Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\n\n      var tm = TmpVectors.Matrix[0];\n      world.invertToRef(tm);\n      Ray.TransformToRef(Ray._RayDistant, tm, this);\n    } else {\n      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n    }\n\n    return this;\n  }; // Statics\n\n  /**\n   * Creates a ray with origin and direction of 0,0,0\n   * @returns the new ray\n   */\n\n\n  Ray.Zero = function () {\n    return new Ray(Vector3.Zero(), Vector3.Zero());\n  };\n  /**\n   * Creates a new ray from screen space and viewport\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @returns new ray\n   */\n\n\n  Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n    var result = Ray.Zero();\n    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n  };\n  /**\n   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n   * transformed to the given world matrix.\n   * @param origin The origin point\n   * @param end The end point\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\n   * @returns the new ray\n   */\n\n\n  Ray.CreateNewFromTo = function (origin, end, world) {\n    if (world === void 0) {\n      world = Matrix.IdentityReadOnly;\n    }\n\n    var direction = end.subtract(origin);\n    var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    direction.normalize();\n    return Ray.Transform(new Ray(origin, direction, length), world);\n  };\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @returns the resulting new ray\n   */\n\n\n  Ray.Transform = function (ray, matrix) {\n    var result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    Ray.TransformToRef(ray, matrix, result);\n    return result;\n  };\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @param result ray to store result in\n   */\n\n\n  Ray.TransformToRef = function (ray, matrix, result) {\n    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n    result.length = ray.length;\n    var dir = result.direction;\n    var len = dir.length();\n\n    if (!(len === 0 || len === 1)) {\n      var num = 1.0 / len;\n      dir.x *= num;\n      dir.y *= num;\n      dir.z *= num;\n      result.length *= len;\n    }\n  };\n  /**\n   * Unproject a ray from screen space to object space\n   * @param sourceX defines the screen space x coordinate to use\n   * @param sourceY defines the screen space y coordinate to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   */\n\n\n  Ray.prototype.unprojectRayToRef = function (sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n    var _a;\n\n    var matrix = TmpVectors.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    var nearScreenSource = TmpVectors.Vector3[0];\n    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;\n    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    nearScreenSource.z = ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) ? 0 : -1; // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\n\n    var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\n    var nearVec3 = TmpVectors.Vector3[2];\n    var farVec3 = TmpVectors.Vector3[3];\n\n    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n\n    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n\n    this.origin.copyFrom(nearVec3);\n    farVec3.subtractToRef(nearVec3, this.direction);\n    this.direction.normalize();\n  };\n\n  Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\n  Ray._RayDistant = Ray.Zero();\n  Ray._Smallnum = 0.00000001;\n  Ray._Rayl = 10e8;\n  return Ray;\n}();\n\nexport { Ray };\n\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  var result = Ray.Zero();\n  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n  return result;\n};\n\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  if (enableDistantPicking === void 0) {\n    enableDistantPicking = false;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return this;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);\n  return this;\n};\n\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n  var result = Ray.Zero();\n  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n  return result;\n};\n\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n  if (!PickingInfo) {\n    return this;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n  var identity = Matrix.Identity(); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n  return this;\n};\n\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n  var ray = rayFunction(world, mesh.enableDistantPicking);\n  var result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n\n  if (!result || !result.hit) {\n    return null;\n  }\n\n  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n    return null;\n  }\n\n  return result;\n};\n\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      // first check if the ray intersects the whole bounding box/sphere of the mesh\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        if (onlyBoundingInfo) {\n          // the user only asked for a bounding info check so we can return\n          return result;\n        }\n\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_1 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n\n          if (result_1) {\n            pickingInfo = result_1;\n            pickingInfo.thinInstanceIndex = index;\n\n            if (fastCheck) {\n              return pickingInfo;\n            }\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n\n      if (result) {\n        pickingInfo = result;\n\n        if (fastCheck) {\n          return pickingInfo;\n        }\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n\n          if (result_2) {\n            result_2.thinInstanceIndex = index;\n            pickingInfos.push(result_2);\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n\n      if (result) {\n        pickingInfos.push(result);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n  var _this = this;\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, true);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking) {\n  var _this = this;\n\n  if (_enableDistantPicking === void 0) {\n    _enableDistantPicking = false;\n  }\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world, enableDistantPicking) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null, false, enableDistantPicking);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n  var _this = this;\n\n  var result = this._internalPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = ray;\n  }\n\n  return result;\n};\n\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    return _this.createPickingRay(x, y, world, camera || null);\n  }, predicate, trianglePredicate);\n};\n\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, trianglePredicate);\n};\n\nCamera.prototype.getForwardRay = function (length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\n\nCamera.prototype.getForwardRayToRef = function (refRay, length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  if (!transform) {\n    transform = this.getWorldMatrix();\n  }\n\n  refRay.length = length;\n\n  if (!origin) {\n    refRay.origin.copyFrom(this.position);\n  } else {\n    refRay.origin.copyFrom(origin);\n  }\n\n  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\n  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\n  return refRay;\n};","map":{"version":3,"mappings":"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","names":["ArrayTools","Matrix","Vector3","TmpVectors","PickingInfo","IntersectionInfo","Scene","Camera","EngineStore","origin","direction","length","Number","MAX_VALUE","Ray","clone","minimum","maximum","intersectionTreshold","newMinimum","_TmpVector3","copyFromFloats","x","y","z","newMaximum","d","maxValue","inv","min","max","temp","Math","abs","Infinity","box","intersectsBoxMinMax","sphere","center","pyth","radius","rr","dot","vertex0","vertex1","vertex2","edge1","edge2","pvec","tvec","qvec","subtractToRef","CrossToRef","det","Dot","invdet","bv","bw","distance","plane","result1","normal","result2","axis","offset","t","mesh","fastCheck","tm","getWorldMatrix","invertToRef","_tmpRay","TransformToRef","Transform","intersects","meshes","results","i","pickInfo","intersectsMesh","hit","push","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","sega","segb","threshold","o","u","rsegb","v","w","scaleToRef","_Rayl","addToRef","a","b","c","e","D","sN","sD","tN","tD","_Smallnum","sc","tc","qtc","qsc","addInPlace","dP","isIntersected","lengthSquared","viewportWidth","viewportHeight","world","view","projection","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","IdentityReadOnly","result","update","end","subtract","sqrt","normalize","ray","matrix","TransformCoordinatesToRef","TransformNormalToRef","dir","len","num","sourceX","sourceY","multiplyToRef","invert","nearScreenSource","LastCreatedEngine","_a","isNDCHalfZRange","farScreenSource","nearVec3","farVec3","_UnprojectFromInvertedMatrixToRef","copyFrom","BuildArray","prototype","createPickingRay","camera","cameraViewSpace","createPickingRayToRef","engine","getEngine","activeCamera","cameraViewport","viewport","toGlobal","getRenderWidth","getRenderHeight","getHardwareScalingLevel","height","width","getViewMatrix","getProjectionMatrix","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","Error","identity","Identity","_internalPickForMesh","pickingInfo","rayFunction","onlyBoundingInfo","trianglePredicate","skipBoundingInfo","_internalPick","predicate","meshIndex","isEnabled","isVisible","isPickable","hasThinInstances","thinInstanceEnablePicking","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","index","thinMatrix","result_1","thinInstanceIndex","_internalMultiPick","pickingInfos","Array","result_2","pickWithBoundingInfo","_this","_tempPickingRay","pick","_enableDistantPicking","pickWithRay","_pickWithRayInverseMatrix","_cachedRayForTransform","multiPick","multiPickWithRay","getForwardRay","transform","getForwardRayToRef","refRay","position","set","_scene","useRightHandedSystem","NormalizeToRef"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Culling/ray.ts"],"sourcesContent":["import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const direction = end.subtract(origin);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = EngineStore.LastCreatedEngine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @hidden */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @hidden */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @hidden */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo>;\r\n\r\n        /** @hidden */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @hidden */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        viewport.width,\r\n        viewport.height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos = new Array<PickingInfo>();\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}