{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder.js\";\n/**\n * Class used to render a debug view of a given skeleton\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\n */\n\nvar SkeletonViewer =\n/** @class */\nfunction () {\n  /**\n   * Creates a new SkeletonViewer\n   * @param skeleton defines the skeleton to render\n   * @param mesh defines the mesh attached to the skeleton\n   * @param scene defines the hosting scene\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\n   * @param renderingGroupId defines the rendering group id to use with the viewer\n   * @param options All of the extra constructor options for the SkeletonViewer\n   */\n  function SkeletonViewer(\n  /** defines the skeleton to render */\n  skeleton,\n  /** defines the mesh attached to the skeleton */\n  mesh,\n  /** The Scene scope*/\n  scene,\n  /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices,\n  /** defines the rendering group id to use with the viewer */\n  renderingGroupId,\n  /** is the options for the viewer */\n  options) {\n    if (autoUpdateBonesMatrices === void 0) {\n      autoUpdateBonesMatrices = true;\n    }\n\n    if (renderingGroupId === void 0) {\n      renderingGroupId = 3;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n\n    this._isEnabled = true;\n    /** SkeletonViewer render observable. */\n\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false; //Defaults\n\n    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;\n    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;\n    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};\n    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;\n    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;\n    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;\n    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;\n    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;\n    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;\n    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;\n    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;\n    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;\n    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;\n    var initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    this._boneIndices = new Set();\n\n    if (!options.useAllBones) {\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (var i = 0; i < initialMeshBoneIndices.length; ++i) {\n          var index = initialMeshBoneIndices[i],\n              weight = initialMeshBoneWeights[i];\n\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n\n\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    var displayMode = this.options.displayMode || 0;\n\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n\n    this.displayMode = displayMode; //Prep the Systems\n\n    this.update();\n\n    this._bindObs();\n  }\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\n   */\n\n\n  SkeletonViewer.CreateBoneWeightShader = function (options, scene) {\n    var _a, _c, _d, _e, _f, _g;\n\n    var skeleton = options.skeleton;\n    var colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();\n    var colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();\n    var colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();\n    var colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();\n    var colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();\n    var targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = \"precision highp float;\\n\\n        attribute vec3 position;\\n        attribute vec2 uv;\\n\\n        uniform mat4 view;\\n        uniform mat4 projection;\\n        uniform mat4 worldViewProjection;\\n\\n        #include<bonesDeclaration>\\n        #if NUM_BONE_INFLUENCERS == 0\\n            attribute vec4 matricesIndices;\\n            attribute vec4 matricesWeights;\\n        #endif\\n        #include<bakedVertexAnimationDeclaration>\\n\\n        #include<instancesDeclaration>\\n\\n        varying vec3 vColor;\\n\\n        uniform vec3 colorBase;\\n        uniform vec3 colorZero;\\n        uniform vec3 colorQuarter;\\n        uniform vec3 colorHalf;\\n        uniform vec3 colorFull;\\n\\n        uniform float targetBoneIndex;\\n\\n        void main() {\\n            vec3 positionUpdated = position;\\n\\n            #include<instancesVertex>\\n            #include<bonesVertex>\\n            #include<bakedVertexAnimation>\\n\\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n            vec3 color = colorBase;\\n            float totalWeight = 0.;\\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\\n                totalWeight += matricesWeights[0];\\n            }\\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\\n                totalWeight += matricesWeights[1];\\n            }\\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\\n                totalWeight += matricesWeights[2];\\n            }\\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\\n                totalWeight += matricesWeights[3];\\n            }\\n\\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\\n            vColor = color;\\n\\n        gl_Position = projection * view * worldPos;\\n        }\";\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = \"\\n            precision highp float;\\n            varying vec3 vPosition;\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4(vColor, 1.0);\\n                gl_FragColor = color;\\n            }\\n        \";\n    var shader = new ShaderMaterial(\"boneWeight:\" + skeleton.name, scene, {\n      vertex: \"boneWeights:\" + skeleton.name,\n      fragment: \"boneWeights:\" + skeleton.name\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorBase\", \"colorZero\", \"colorQuarter\", \"colorHalf\", \"colorFull\", \"targetBoneIndex\"]\n    });\n    shader.setColor3(\"colorBase\", colorBase);\n    shader.setColor3(\"colorZero\", colorZero);\n    shader.setColor3(\"colorQuarter\", colorQuarter);\n    shader.setColor3(\"colorHalf\", colorHalf);\n    shader.setColor3(\"colorFull\", colorFull);\n    shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\n\n    shader.getClassName = function () {\n      return \"BoneWeightShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   */\n\n\n  SkeletonViewer.CreateSkeletonMapShader = function (options, scene) {\n    var _a;\n\n    var skeleton = options.skeleton;\n    var colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(0.59, 0.18, 1.0),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    var bufferWidth = skeleton.bones.length + 1;\n\n    var colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n\n    var shader = new ShaderMaterial(\"boneWeights:\" + skeleton.name, scene, {\n      vertexSource: \"precision highp float;\\n\\n            attribute vec3 position;\\n            attribute vec2 uv;\\n\\n            uniform mat4 view;\\n            uniform mat4 projection;\\n            uniform mat4 worldViewProjection;\\n            uniform float colorMap[\" + skeleton.bones.length * 4 + \"];\\n\\n            #include<bonesDeclaration>\\n            #if NUM_BONE_INFLUENCERS == 0\\n                attribute vec4 matricesIndices;\\n                attribute vec4 matricesWeights;\\n            #endif\\n            #include<bakedVertexAnimationDeclaration>\\n            #include<instancesDeclaration>\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec3 positionUpdated = position;\\n\\n                #include<instancesVertex>\\n                #include<bonesVertex>\\n                #include<bakedVertexAnimation>\\n\\n                vec3 color = vec3(0.);\\n                bool first = true;\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int boneIdx = int(matricesIndices[i]);\\n                    float boneWgt = matricesWeights[i];\\n\\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\\n\\n                    if (boneWgt > 0.) {\\n                        if (first) {\\n                            first = false;\\n                            color = c;\\n                        } else {\\n                            color = mix(color, c, boneWgt);\\n                        }\\n                    }\\n                }\\n\\n                vColor = color;\\n\\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n                gl_Position = projection * view * worldPos;\\n            }\",\n      fragmentSource: \"\\n            precision highp float;\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4( vColor, 1.0 );\\n                gl_FragColor = color;\\n            }\\n            \"\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"]\n    });\n    shader.setFloats(\"colorMap\", colorMapBuffer);\n\n    shader.getClassName = function () {\n      return \"SkeletonMapShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** private static method to create a BoneWeight Shader\n   * @param size The size of the buffer to create (usually the bone count)\n   * @param colorMap The gradient data to generate\n   * @param scene The scene that the shader is scoped to\n   * @returns an Array of floats from the color gradient values\n   */\n\n\n  SkeletonViewer._CreateBoneMapColorBuffer = function (size, colorMap, scene) {\n    var tempGrad = new DynamicTexture(\"temp\", {\n      width: size,\n      height: 1\n    }, scene, false);\n    var ctx = tempGrad.getContext();\n    var grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(function (stop) {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    var buffer = [];\n    var data = ctx.getImageData(0, 0, size, 1).data;\n    var rUnit = 1 / 255;\n\n    for (var i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n\n    tempGrad.dispose();\n    return buffer;\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"scene\", {\n    /** Gets the Scene. */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"utilityLayer\", {\n    /** Gets the utilityLayer. */\n    get: function get() {\n      return this._utilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"isReady\", {\n    /** Checks Ready Status. */\n    get: function get() {\n      return this._ready;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"ready\", {\n    /** Sets Ready Status. */\n    set: function set(value) {\n      this._ready = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"debugMesh\", {\n    /** Gets the debugMesh */\n    get: function get() {\n      return this._debugMesh;\n    },\n\n    /** Sets the debugMesh */\n    set: function set(value) {\n      this._debugMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"displayMode\", {\n    /** Gets the displayMode */\n    get: function get() {\n      return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n    },\n\n    /** Sets the displayMode */\n    set: function set(value) {\n      if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n        value = SkeletonViewer.DISPLAY_LINES;\n      }\n\n      this.options.displayMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** The Dynamic bindings for the update functions */\n\n  SkeletonViewer.prototype._bindObs = function () {\n    var _this = this;\n\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(function () {\n            _this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  };\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n\n\n  SkeletonViewer.prototype.update = function () {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n\n          break;\n        }\n    }\n\n    this._buildLocalAxes();\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /** Gets or sets a boolean indicating if the viewer is enabled */\n    set: function set(value) {\n      if (this.isEnabled === value) {\n        return;\n      }\n\n      this._isEnabled = value;\n\n      if (this.debugMesh) {\n        this.debugMesh.setEnabled(value);\n      }\n\n      if (value && !this._obs) {\n        this._bindObs();\n      } else if (!value && this._obs) {\n        this.scene.onBeforeRenderObservable.remove(this._obs);\n        this._obs = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (z === void 0) {\n      z = 0;\n    }\n\n    var tmat = TmpVectors.Matrix[0];\n    var parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n\n    if (x !== 0 || y !== 0 || z !== 0) {\n      var tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\n    }\n\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {\n    var len = bones.length;\n    var mesh = this.mesh;\n    var meshPos = mesh.position;\n    var idx = 0;\n\n    for (var i = 0; i < len; i++) {\n      var bone = bones[i];\n      var points = this._debugLines[idx];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n\n      this._getBonePosition(points[0], bone, meshMat);\n\n      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones) {\n    var len = bones.length;\n    var boneNum = 0;\n    var mesh = this.mesh;\n    var meshPos = mesh.position;\n\n    for (var i = len - 1; i >= 0; i--) {\n      var childBone = bones[i];\n      var parentBone = childBone.getParent();\n\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var points = this._debugLines[boneNum];\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n\n      childBone.getAbsolutePositionToRef(mesh, points[0]);\n      parentBone.getAbsolutePositionToRef(mesh, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n  };\n  /**\n   * function to revert the mesh and scene back to the initial state.\n   * @param animationState\n   */\n\n\n  SkeletonViewer.prototype._revert = function (animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  };\n  /**\n   * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\n   * @param bone\n   * @param matrix\n   */\n\n\n  SkeletonViewer.prototype._getAbsoluteBindPoseToRef = function (bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n\n    bone.getBaseMatrix().multiplyToRef(matrix, matrix);\n    return;\n  };\n  /**\n   * function to build and bind sphere joint points and spur bone representations.\n   * @param spheresOnly\n   */\n\n\n  SkeletonViewer.prototype._buildSpheresAndSpurs = function (spheresOnly) {\n    var _a, _c;\n\n    if (spheresOnly === void 0) {\n      spheresOnly = true;\n    }\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this._ready = false;\n    var utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;\n    var bones = this.skeleton.bones;\n    var spheres = [];\n    var spurs = [];\n    var animationState = this.scene.animationsEnabled;\n\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteTransforms();\n      }\n\n      var longestBoneLength_1 = Number.NEGATIVE_INFINITY;\n      var displayOptions_1 = this.options.displayOptions || {};\n\n      var _loop_1 = function _loop_1(i) {\n        var bone = bones[i];\n\n        if (bone._index === -1 || !this_1._boneIndices.has(bone.getIndex()) && !this_1.options.useAllBones) {\n          return \"continue\";\n        }\n\n        var boneAbsoluteBindPoseTransform = new Matrix();\n\n        this_1._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n        var anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        bone.children.forEach(function (bc) {\n          var childAbsoluteBindPoseTransform = new Matrix();\n          bc.getBaseMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n          var childPoint = new Vector3();\n          childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n          var distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n\n          if (distanceFromParent > longestBoneLength_1) {\n            longestBoneLength_1 = distanceFromParent;\n          }\n\n          if (spheresOnly) {\n            return;\n          }\n\n          var dir = childPoint.clone().subtract(anchorPoint.clone());\n          var h = dir.length();\n          var up = dir.normalize().scale(h);\n          var midStep = displayOptions_1.midStep || 0.165;\n          var midStepFactor = displayOptions_1.midStepFactor || 0.215;\n          var up0 = up.scale(midStep);\n          var spur = ExtrudeShapeCustom(\"skeletonViewer\", {\n            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n            path: [Vector3.Zero(), up0, up],\n            scaleFunction: function scaleFunction(i) {\n              switch (i) {\n                case 0:\n                case 2:\n                  return 0;\n\n                case 1:\n                  return h * midStepFactor;\n              }\n\n              return 0;\n            },\n            sideOrientation: Mesh.DEFAULTSIDE,\n            updatable: false\n          }, utilityLayerScene);\n          var numVertices = spur.getTotalVertices();\n          var mwk = [],\n              mik = [];\n\n          for (var i_1 = 0; i_1 < numVertices; i_1++) {\n            mwk.push(1, 0, 0, 0); // Select verts at end of spur (ie vert 10 to 14) and bind to child\n            // bone if spurFollowsChild is enabled.\n\n            if (displayOptions_1.spurFollowsChild && i_1 > 9) {\n              mik.push(bc.getIndex(), 0, 0, 0);\n            } else {\n              mik.push(bone.getIndex(), 0, 0, 0);\n            }\n          }\n\n          spur.position = anchorPoint.clone();\n          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n          spur.convertToFlatShadedMesh();\n          spurs.push(spur);\n        });\n        var sphereBaseSize = displayOptions_1.sphereBaseSize || 0.2;\n        var sphere = CreateSphere(\"skeletonViewer\", {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        var numVertices = sphere.getTotalVertices();\n        var mwk = [],\n            mik = [];\n\n        for (var i_2 = 0; i_2 < numVertices; i_2++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < bones.length; i++) {\n        _loop_1(i);\n      }\n\n      var sphereScaleUnit = displayOptions_1.sphereScaleUnit || 2;\n      var sphereFactor = displayOptions_1.sphereFactor || 0.85;\n      var meshes = [];\n\n      for (var i = 0; i < spheres.length; i++) {\n        var _d = spheres[i],\n            sphere = _d[0],\n            bone = _d[1];\n        var scale = 1 / (sphereScaleUnit / longestBoneLength_1);\n        var _stepsOut = 0;\n        var _b = bone;\n\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n\n      var light = this.utilityLayer._getSharedGizmoLight();\n\n      light.intensity = 0.7;\n\n      this._revert(animationState);\n\n      this.ready = true;\n    } catch (err) {\n      console.error(err);\n\n      this._revert(animationState);\n\n      this.dispose();\n    }\n  };\n\n  SkeletonViewer.prototype._buildLocalAxes = function () {\n    var _a;\n\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n\n    this._localAxes = null;\n    var displayOptions = this.options.displayOptions || {};\n\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n    var size = displayOptions.localAxesSize || 0.075;\n    var lines = [];\n    var colors = [];\n    var red = new Color4(1, 0, 0, 1);\n    var green = new Color4(0, 1, 0, 1);\n    var blue = new Color4(0, 0, 1, 1);\n    var mwk = [];\n    var mik = [];\n    var vertsPerBone = 6;\n\n    for (var i in this.skeleton.bones) {\n      var bone = this.skeleton.bones[i];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var boneAbsoluteBindPoseTransform = new Matrix();\n      var boneOrigin = new Vector3();\n\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n      boneAbsoluteBindPoseTransform.decompose(undefined, undefined, boneOrigin);\n      var m = bone.getBaseMatrix().getRotationMatrix();\n      var boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      var boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      var boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      var axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      var axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      var axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      var linePoints = [axisX, axisY, axisZ];\n      var lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push.apply(lines, linePoints);\n      colors.push.apply(colors, lineColors);\n\n      for (var j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n\n    this._localAxes = CreateLineSystem(\"localAxes\", {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;\n  };\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n\n\n  SkeletonViewer.prototype._displayLinesUpdate = function () {\n    if (!this._utilityLayer) {\n      return;\n    }\n\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteTransforms();\n    }\n\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n\n      this._debugMesh.position.copyFrom(this.mesh.position);\n\n      this._debugMesh.color = this.color;\n    }\n  };\n  /** Changes the displayMode of the skeleton viewer\n   * @param mode The displayMode numerical value\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayMode = function (mode) {\n    var wasEnabled = this.isEnabled ? true : false;\n\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n\n        this._debugMesh = null;\n        this.ready = false;\n      }\n\n      this.displayMode = mode;\n      this.update();\n\n      this._bindObs();\n\n      this.isEnabled = wasEnabled;\n    }\n  };\n  /** Sets a display option of the skeleton viewer\n   *\n   * | Option           | Type    | Default | Description |\n   * | ---------------- | ------- | ------- | ----------- |\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\n   *\n   * @param option String of the option name\n   * @param value The numerical option value\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayOptions = function (option, value) {\n    var wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this.update();\n\n    this._bindObs();\n\n    this.isEnabled = wasEnabled;\n  };\n  /** Release associated resources */\n\n\n  SkeletonViewer.prototype.dispose = function () {\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n    }\n\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n\n      this._utilityLayer = null;\n    }\n\n    this.ready = false;\n  };\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\n\n\n  SkeletonViewer.DISPLAY_LINES = 0;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\n\n  SkeletonViewer.DISPLAY_SPHERES = 1;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\n\n  SkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;\n  return SkeletonViewer;\n}();\n\nexport { SkeletonViewer };","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","TmpVectors","Color3","Color4","Mesh","CreateLineSystem","UtilityLayerRenderer","Material","ShaderMaterial","DynamicTexture","VertexBuffer","Effect","CreateSphere","ExtrudeShapeCustom","skeleton","mesh","scene","autoUpdateBonesMatrices","renderingGroupId","options","White","Array","_scene","_ready","pauseAnimations","_a","returnToRest","_c","displayMode","_d","SkeletonViewer","DISPLAY_LINES","displayOptions","_e","midStep","_f","midStepFactor","_g","sphereBaseSize","_h","sphereScaleUnit","_j","sphereFactor","_k","spurFollowsChild","_l","showLocalAxes","_m","localAxesSize","_o","computeBonesUsingShaders","_p","useAllBones","_q","initialMeshBoneIndices","getVerticesData","MatricesIndicesKind","initialMeshBoneWeights","MatricesWeightsKind","_boneIndices","Set","i","length","index","weight","add","_utilityLayer","pickUtilitySceneFirst","utilityLayerScene","autoClearDepthAndStencil","DISPLAY_SPHERE_AND_SPURS","update","_bindObs","colorBase","Black","colorZero","Blue","colorQuarter","Green","colorHalf","Yellow","colorFull","Red","targetBoneIndex","ShadersStore","name","shader","vertex","fragment","attributes","uniforms","setColor3","setFloat","getClassName","transparencyMode","MATERIAL_OPAQUE","colorMap","color","location","bufferWidth","bones","colorMapBuffer","_CreateBoneMapColorBuffer","vertexSource","fragmentSource","setFloats","size","tempGrad","width","height","ctx","getContext","grad","createLinearGradient","forEach","stop","addColorStop","toHexString","fillStyle","fillRect","buffer","data","getImageData","rUnit","push","dispose","Object","value","_debugMesh","_obs","onBeforeRenderObservable","_this","_displayLinesUpdate","DISPLAY_SPHERES","_buildSpheresAndSpurs","_buildLocalAxes","_isEnabled","isEnabled","debugMesh","setEnabled","remove","position","bone","meshMat","x","y","z","tmat","parentBone","getParent","copyFrom","getLocalMatrix","tmat2","IdentityToRef","setTranslationFromFloats","multiplyToRef","getAbsoluteTransform","m","len","meshPos","idx","points","_debugLines","_index","has","getIndex","Zero","_getBonePosition","subtractInPlace","boneNum","childBone","getAbsolutePositionToRef","animationState","animationsEnabled","utilityLayer","matrix","Identity","_getAbsoluteBindPoseToRef","getBaseMatrix","spheresOnly","ready","spheres","spurs","computeAbsoluteTransforms","longestBoneLength_1","Number","NEGATIVE_INFINITY","displayOptions_1","this_1","boneAbsoluteBindPoseTransform","anchorPoint","decompose","undefined","children","bc","childAbsoluteBindPoseTransform","childPoint","distanceFromParent","Distance","dir","clone","subtract","h","up","normalize","scale","up0","spur","shape","path","scaleFunction","sideOrientation","DEFAULTSIDE","updatable","numVertices","getTotalVertices","mwk","mik","i_1","setVerticesData","convertToFlatShadedMesh","sphere","segments","diameter","i_2","meshes","_stepsOut","_b","scaling","scaleInPlace","Math","pow","MergeMeshes","concat","parent","alwaysSelectAsActiveMesh","light","_getSharedGizmoLight","intensity","_revert","err","console","error","_localAxes","targetScene","lines","colors","red","green","blue","vertsPerBone","boneOrigin","getRotationMatrix","boneAxisX","TransformCoordinates","boneAxisY","boneAxisZ","axisX","axisY","axisZ","linePoints","lineColors","apply","j","_getLinesForBonesNoLength","_getLinesForBonesWithLength","getWorldMatrix","instance","mode","wasEnabled","option"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Debug/skeletonViewer.ts"],"sourcesContent":["import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport type { ISkeletonViewerOptions, IBoneWeightShaderOptions, ISkeletonMapShaderOptions, ISkeletonMapShaderColorMapKnot } from \"./ISkeletonViewer\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder\";\r\n\r\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\r\nexport class SkeletonViewer {\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\r\n    public static readonly DISPLAY_LINES = 0;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\r\n    public static readonly DISPLAY_SPHERES = 1;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\r\n    public static readonly DISPLAY_SPHERE_AND_SPURS = 2;\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n     */\r\n    static CreateBoneWeightShader(options: IBoneWeightShaderOptions, scene: Scene): ShaderMaterial {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorBase: Color3 = options.colorBase ?? Color3.Black();\r\n        const colorZero: Color3 = options.colorZero ?? Color3.Blue();\r\n        const colorQuarter: Color3 = options.colorQuarter ?? Color3.Green();\r\n        const colorHalf: Color3 = options.colorHalf ?? Color3.Yellow();\r\n        const colorFull: Color3 = options.colorFull ?? Color3.Red();\r\n        const targetBoneIndex: number = options.targetBoneIndex ?? 0;\r\n\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\r\n\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n\r\n        uniform mat4 view;\r\n        uniform mat4 projection;\r\n        uniform mat4 worldViewProjection;\r\n\r\n        #include<bonesDeclaration>\r\n        #if NUM_BONE_INFLUENCERS == 0\r\n            attribute vec4 matricesIndices;\r\n            attribute vec4 matricesWeights;\r\n        #endif\r\n        #include<bakedVertexAnimationDeclaration>\r\n\r\n        #include<instancesDeclaration>\r\n\r\n        varying vec3 vColor;\r\n\r\n        uniform vec3 colorBase;\r\n        uniform vec3 colorZero;\r\n        uniform vec3 colorQuarter;\r\n        uniform vec3 colorHalf;\r\n        uniform vec3 colorFull;\r\n\r\n        uniform float targetBoneIndex;\r\n\r\n        void main() {\r\n            vec3 positionUpdated = position;\r\n\r\n            #include<instancesVertex>\r\n            #include<bonesVertex>\r\n            #include<bakedVertexAnimation>\r\n\r\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n            vec3 color = colorBase;\r\n            float totalWeight = 0.;\r\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\r\n                totalWeight += matricesWeights[0];\r\n            }\r\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\r\n                totalWeight += matricesWeights[1];\r\n            }\r\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\r\n                totalWeight += matricesWeights[2];\r\n            }\r\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\r\n                totalWeight += matricesWeights[3];\r\n            }\r\n\r\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\r\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\r\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\r\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\r\n            vColor = color;\r\n\r\n        gl_Position = projection * view * worldPos;\r\n        }`;\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\r\n            precision highp float;\r\n            varying vec3 vPosition;\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4(vColor, 1.0);\r\n                gl_FragColor = color;\r\n            }\r\n        `;\r\n        const shader: ShaderMaterial = new ShaderMaterial(\r\n            \"boneWeight:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertex: \"boneWeights:\" + skeleton.name,\r\n                fragment: \"boneWeights:\" + skeleton.name,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\r\n                    \"world\",\r\n                    \"worldView\",\r\n                    \"worldViewProjection\",\r\n                    \"view\",\r\n                    \"projection\",\r\n                    \"viewProjection\",\r\n                    \"colorBase\",\r\n                    \"colorZero\",\r\n                    \"colorQuarter\",\r\n                    \"colorHalf\",\r\n                    \"colorFull\",\r\n                    \"targetBoneIndex\",\r\n                ],\r\n            }\r\n        );\r\n\r\n        shader.setColor3(\"colorBase\", colorBase);\r\n        shader.setColor3(\"colorZero\", colorZero);\r\n        shader.setColor3(\"colorQuarter\", colorQuarter);\r\n        shader.setColor3(\"colorHalf\", colorHalf);\r\n        shader.setColor3(\"colorFull\", colorFull);\r\n        shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"BoneWeightShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     */\r\n    static CreateSkeletonMapShader(options: ISkeletonMapShaderOptions, scene: Scene) {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorMap: ISkeletonMapShaderColorMapKnot[] = options.colorMap ?? [\r\n            {\r\n                color: new Color3(1, 0.38, 0.18),\r\n                location: 0,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 0.18, 1.0),\r\n                location: 0.2,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 1, 0.18),\r\n                location: 0.4,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.87, 0.17),\r\n                location: 0.6,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.17, 0.42),\r\n                location: 0.8,\r\n            },\r\n            {\r\n                color: new Color3(0.17, 0.68, 1.0),\r\n                location: 1.0,\r\n            },\r\n        ];\r\n\r\n        const bufferWidth: number = skeleton.bones.length + 1;\r\n        const colorMapBuffer: number[] = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\r\n        const shader = new ShaderMaterial(\r\n            \"boneWeights:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertexSource:\r\n                    `precision highp float;\r\n\r\n            attribute vec3 position;\r\n            attribute vec2 uv;\r\n\r\n            uniform mat4 view;\r\n            uniform mat4 projection;\r\n            uniform mat4 worldViewProjection;\r\n            uniform float colorMap[` +\r\n                    skeleton.bones.length * 4 +\r\n                    `];\r\n\r\n            #include<bonesDeclaration>\r\n            #if NUM_BONE_INFLUENCERS == 0\r\n                attribute vec4 matricesIndices;\r\n                attribute vec4 matricesWeights;\r\n            #endif\r\n            #include<bakedVertexAnimationDeclaration>\r\n            #include<instancesDeclaration>\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec3 positionUpdated = position;\r\n\r\n                #include<instancesVertex>\r\n                #include<bonesVertex>\r\n                #include<bakedVertexAnimation>\r\n\r\n                vec3 color = vec3(0.);\r\n                bool first = true;\r\n\r\n                for (int i = 0; i < 4; i++) {\r\n                    int boneIdx = int(matricesIndices[i]);\r\n                    float boneWgt = matricesWeights[i];\r\n\r\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\r\n\r\n                    if (boneWgt > 0.) {\r\n                        if (first) {\r\n                            first = false;\r\n                            color = c;\r\n                        } else {\r\n                            color = mix(color, c, boneWgt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vColor = color;\r\n\r\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n                gl_Position = projection * view * worldPos;\r\n            }`,\r\n                fragmentSource: `\r\n            precision highp float;\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4( vColor, 1.0 );\r\n                gl_FragColor = color;\r\n            }\r\n            `,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"],\r\n            }\r\n        );\r\n\r\n        shader.setFloats(\"colorMap\", colorMapBuffer);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"SkeletonMapShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** private static method to create a BoneWeight Shader\r\n     * @param size The size of the buffer to create (usually the bone count)\r\n     * @param colorMap The gradient data to generate\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns an Array of floats from the color gradient values\r\n     */\r\n    private static _CreateBoneMapColorBuffer(size: number, colorMap: ISkeletonMapShaderColorMapKnot[], scene: Scene) {\r\n        const tempGrad = new DynamicTexture(\"temp\", { width: size, height: 1 }, scene, false);\r\n        const ctx = tempGrad.getContext();\r\n        const grad = ctx.createLinearGradient(0, 0, size, 0);\r\n\r\n        colorMap.forEach((stop) => {\r\n            grad.addColorStop(stop.location, stop.color.toHexString());\r\n        });\r\n\r\n        ctx.fillStyle = grad;\r\n        ctx.fillRect(0, 0, size, 1);\r\n        tempGrad.update();\r\n        const buffer: number[] = [];\r\n        const data: Uint8ClampedArray = ctx.getImageData(0, 0, size, 1).data;\r\n        const rUnit = 1 / 255;\r\n        for (let i = 0; i < data.length; i++) {\r\n            buffer.push(data[i] * rUnit);\r\n        }\r\n        tempGrad.dispose();\r\n        return buffer;\r\n    }\r\n\r\n    /** If SkeletonViewer scene scope. */\r\n    private _scene: Scene;\r\n\r\n    /** Gets or sets the color used to render the skeleton */\r\n    public color: Color3 = Color3.White();\r\n\r\n    /** Array of the points of the skeleton fo the line view. */\r\n    private _debugLines = new Array<Array<Vector3>>();\r\n\r\n    /** The SkeletonViewers Mesh. */\r\n    private _debugMesh: Nullable<LinesMesh>;\r\n\r\n    /** The local axes Meshes. */\r\n    private _localAxes: Nullable<LinesMesh> = null;\r\n\r\n    /** If SkeletonViewer is enabled. */\r\n    private _isEnabled = true;\r\n\r\n    /** If SkeletonViewer is ready. */\r\n    private _ready: boolean;\r\n\r\n    /** SkeletonViewer render observable. */\r\n    private _obs: Nullable<Observer<Scene>> = null;\r\n\r\n    /** The Utility Layer to render the gizmos in. */\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _boneIndices: Set<number>;\r\n\r\n    /** Gets the Scene. */\r\n    get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n    /** Gets the utilityLayer. */\r\n    get utilityLayer(): Nullable<UtilityLayerRenderer> {\r\n        return this._utilityLayer;\r\n    }\r\n    /** Checks Ready Status. */\r\n    get isReady(): Boolean {\r\n        return this._ready;\r\n    }\r\n    /** Sets Ready Status. */\r\n    set ready(value: boolean) {\r\n        this._ready = value;\r\n    }\r\n    /** Gets the debugMesh */\r\n    get debugMesh(): Nullable<AbstractMesh> | Nullable<LinesMesh> {\r\n        return this._debugMesh;\r\n    }\r\n    /** Sets the debugMesh */\r\n    set debugMesh(value: Nullable<AbstractMesh> | Nullable<LinesMesh>) {\r\n        this._debugMesh = value as any;\r\n    }\r\n    /** Gets the displayMode */\r\n    get displayMode(): number {\r\n        return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\r\n    }\r\n    /** Sets the displayMode */\r\n    set displayMode(value: number) {\r\n        if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            value = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.options.displayMode = value;\r\n    }\r\n    /**\r\n     * Creates a new SkeletonViewer\r\n     * @param skeleton defines the skeleton to render\r\n     * @param mesh defines the mesh attached to the skeleton\r\n     * @param scene defines the hosting scene\r\n     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n     * @param renderingGroupId defines the rendering group id to use with the viewer\r\n     * @param options All of the extra constructor options for the SkeletonViewer\r\n     */\r\n    constructor(\r\n        /** defines the skeleton to render */\r\n        public skeleton: Skeleton,\r\n        /** defines the mesh attached to the skeleton */\r\n        public mesh: AbstractMesh,\r\n        /** The Scene scope*/\r\n        scene: Scene,\r\n        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\r\n        public autoUpdateBonesMatrices: boolean = true,\r\n        /** defines the rendering group id to use with the viewer */\r\n        public renderingGroupId: number = 3,\r\n        /** is the options for the viewer */\r\n        public options: Partial<ISkeletonViewerOptions> = {}\r\n    ) {\r\n        this._scene = scene;\r\n        this._ready = false;\r\n\r\n        //Defaults\r\n        options.pauseAnimations = options.pauseAnimations ?? true;\r\n        options.returnToRest = options.returnToRest ?? false;\r\n        options.displayMode = options.displayMode ?? SkeletonViewer.DISPLAY_LINES;\r\n        options.displayOptions = options.displayOptions ?? {};\r\n        options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;\r\n        options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;\r\n        options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;\r\n        options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;\r\n        options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;\r\n        options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;\r\n        options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;\r\n        options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;\r\n        options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;\r\n        options.useAllBones = options.useAllBones ?? true;\r\n\r\n        const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        this._boneIndices = new Set();\r\n\r\n        if (!options.useAllBones) {\r\n            if (initialMeshBoneIndices && initialMeshBoneWeights) {\r\n                for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\r\n                    const index = initialMeshBoneIndices[i],\r\n                        weight = initialMeshBoneWeights[i];\r\n                    if (weight !== 0) {\r\n                        this._boneIndices.add(index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Create Utility Layer */\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n\r\n        let displayMode = this.options.displayMode || 0;\r\n        if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            displayMode = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.displayMode = displayMode;\r\n        //Prep the Systems\r\n        this.update();\r\n        this._bindObs();\r\n    }\r\n\r\n    /** The Dynamic bindings for the update functions */\r\n    private _bindObs(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._obs = this.scene.onBeforeRenderObservable.add(() => {\r\n                    this._displayLinesUpdate();\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used to manually update. */\r\n    public update(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._displayLinesUpdate();\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERES: {\r\n                this._buildSpheresAndSpurs(true);\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {\r\n                this._buildSpheresAndSpurs(false);\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._buildLocalAxes();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the viewer is enabled */\r\n    public set isEnabled(value: boolean) {\r\n        if (this.isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n\r\n        if (this.debugMesh) {\r\n            this.debugMesh.setEnabled(value);\r\n        }\r\n\r\n        if (value && !this._obs) {\r\n            this._bindObs();\r\n        } else if (!value && this._obs) {\r\n            this.scene.onBeforeRenderObservable.remove(this._obs);\r\n            this._obs = null;\r\n        }\r\n    }\r\n\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    private _getBonePosition(position: Vector3, bone: Bone, meshMat: Matrix, x = 0, y = 0, z = 0): void {\r\n        const tmat = TmpVectors.Matrix[0];\r\n        const parentBone = bone.getParent();\r\n        tmat.copyFrom(bone.getLocalMatrix());\r\n\r\n        if (x !== 0 || y !== 0 || z !== 0) {\r\n            const tmat2 = TmpVectors.Matrix[1];\r\n            Matrix.IdentityToRef(tmat2);\r\n            tmat2.setTranslationFromFloats(x, y, z);\r\n            tmat2.multiplyToRef(tmat, tmat);\r\n        }\r\n\r\n        if (parentBone) {\r\n            tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\r\n        }\r\n\r\n        tmat.multiplyToRef(meshMat, tmat);\r\n\r\n        position.x = tmat.m[12];\r\n        position.y = tmat.m[13];\r\n        position.z = tmat.m[14];\r\n    }\r\n\r\n    private _getLinesForBonesWithLength(bones: Bone[], meshMat: Matrix): void {\r\n        const len = bones.length;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        let idx = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            const bone = bones[i];\r\n            let points = this._debugLines[idx];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[idx] = points;\r\n            }\r\n            this._getBonePosition(points[0], bone, meshMat);\r\n            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    private _getLinesForBonesNoLength(bones: Bone[]): void {\r\n        const len = bones.length;\r\n        let boneNum = 0;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        for (let i = len - 1; i >= 0; i--) {\r\n            const childBone = bones[i];\r\n            const parentBone = childBone.getParent();\r\n            if (!parentBone || (!this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            let points = this._debugLines[boneNum];\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[boneNum] = points;\r\n            }\r\n            childBone.getAbsolutePositionToRef(mesh, points[0]);\r\n            parentBone.getAbsolutePositionToRef(mesh, points[1]);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            boneNum++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to revert the mesh and scene back to the initial state.\r\n     * @param animationState\r\n     */\r\n    private _revert(animationState: boolean): void {\r\n        if (this.options.pauseAnimations) {\r\n            this.scene.animationsEnabled = animationState;\r\n            this.utilityLayer!.utilityLayerScene!.animationsEnabled = animationState;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\r\n     * @param bone\r\n     * @param matrix\r\n     */\r\n    private _getAbsoluteBindPoseToRef(bone: Nullable<Bone>, matrix: Matrix) {\r\n        if (bone === null || bone._index === -1) {\r\n            matrix.copyFrom(Matrix.Identity());\r\n            return;\r\n        }\r\n\r\n        this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\r\n        bone.getBaseMatrix().multiplyToRef(matrix, matrix);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * function to build and bind sphere joint points and spur bone representations.\r\n     * @param spheresOnly\r\n     */\r\n    private _buildSpheresAndSpurs(spheresOnly = true): void {\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n\r\n        this._ready = false;\r\n        const utilityLayerScene = this.utilityLayer?.utilityLayerScene!;\r\n        const bones: Bone[] = this.skeleton.bones;\r\n        const spheres: Array<[Mesh, Bone]> = [];\r\n        const spurs: Mesh[] = [];\r\n\r\n        const animationState = this.scene.animationsEnabled;\r\n\r\n        try {\r\n            if (this.options.pauseAnimations) {\r\n                this.scene.animationsEnabled = false;\r\n                utilityLayerScene.animationsEnabled = false;\r\n            }\r\n\r\n            if (this.options.returnToRest) {\r\n                this.skeleton.returnToRest();\r\n            }\r\n\r\n            if (this.autoUpdateBonesMatrices) {\r\n                this.skeleton.computeAbsoluteTransforms();\r\n            }\r\n\r\n            let longestBoneLength = Number.NEGATIVE_INFINITY;\r\n            const displayOptions = this.options.displayOptions || {};\r\n\r\n            for (let i = 0; i < bones.length; i++) {\r\n                const bone = bones[i];\r\n\r\n                if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                    continue;\r\n                }\r\n\r\n                const boneAbsoluteBindPoseTransform = new Matrix();\r\n                this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n\r\n                const anchorPoint = new Vector3();\r\n\r\n                boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\r\n\r\n                bone.children.forEach((bc) => {\r\n                    const childAbsoluteBindPoseTransform: Matrix = new Matrix();\r\n                    bc.getBaseMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\r\n                    const childPoint = new Vector3();\r\n                    childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\r\n                    const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\r\n                    if (distanceFromParent > longestBoneLength) {\r\n                        longestBoneLength = distanceFromParent;\r\n                    }\r\n                    if (spheresOnly) {\r\n                        return;\r\n                    }\r\n\r\n                    const dir = childPoint.clone().subtract(anchorPoint.clone());\r\n                    const h = dir.length();\r\n                    const up = dir.normalize().scale(h);\r\n\r\n                    const midStep = displayOptions.midStep || 0.165;\r\n                    const midStepFactor = displayOptions.midStepFactor || 0.215;\r\n\r\n                    const up0 = up.scale(midStep);\r\n\r\n                    const spur = ExtrudeShapeCustom(\r\n                        \"skeletonViewer\",\r\n                        {\r\n                            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\r\n                            path: [Vector3.Zero(), up0, up],\r\n                            scaleFunction: (i: number) => {\r\n                                switch (i) {\r\n                                    case 0:\r\n                                    case 2:\r\n                                        return 0;\r\n                                    case 1:\r\n                                        return h * midStepFactor;\r\n                                }\r\n                                return 0;\r\n                            },\r\n                            sideOrientation: Mesh.DEFAULTSIDE,\r\n                            updatable: false,\r\n                        },\r\n                        utilityLayerScene\r\n                    );\r\n\r\n                    const numVertices = spur.getTotalVertices();\r\n                    const mwk: number[] = [],\r\n                        mik: number[] = [];\r\n\r\n                    for (let i = 0; i < numVertices; i++) {\r\n                        mwk.push(1, 0, 0, 0);\r\n\r\n                        // Select verts at end of spur (ie vert 10 to 14) and bind to child\r\n                        // bone if spurFollowsChild is enabled.\r\n                        if (displayOptions.spurFollowsChild && i > 9) {\r\n                            mik.push(bc.getIndex(), 0, 0, 0);\r\n                        } else {\r\n                            mik.push(bone.getIndex(), 0, 0, 0);\r\n                        }\r\n                    }\r\n\r\n                    spur.position = anchorPoint.clone();\r\n\r\n                    spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                    spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n                    spur.convertToFlatShadedMesh();\r\n\r\n                    spurs.push(spur);\r\n                });\r\n\r\n                const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\r\n\r\n                const sphere = CreateSphere(\r\n                    \"skeletonViewer\",\r\n                    {\r\n                        segments: 6,\r\n                        diameter: sphereBaseSize,\r\n                        updatable: true,\r\n                    },\r\n                    utilityLayerScene\r\n                );\r\n\r\n                const numVertices = sphere.getTotalVertices();\r\n\r\n                const mwk: number[] = [],\r\n                    mik: number[] = [];\r\n\r\n                for (let i = 0; i < numVertices; i++) {\r\n                    mwk.push(1, 0, 0, 0);\r\n                    mik.push(bone.getIndex(), 0, 0, 0);\r\n                }\r\n\r\n                sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n\r\n                sphere.position = anchorPoint.clone();\r\n                spheres.push([sphere, bone]);\r\n            }\r\n\r\n            const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\r\n            const sphereFactor = displayOptions.sphereFactor || 0.85;\r\n\r\n            const meshes = [];\r\n            for (let i = 0; i < spheres.length; i++) {\r\n                const [sphere, bone] = spheres[i];\r\n                const scale = 1 / (sphereScaleUnit / longestBoneLength);\r\n\r\n                let _stepsOut = 0;\r\n                let _b = bone;\r\n\r\n                while (_b.getParent() && (_b.getParent() as Bone).getIndex() !== -1) {\r\n                    _stepsOut++;\r\n                    _b = _b.getParent() as Bone;\r\n                }\r\n                sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\r\n                meshes.push(sphere);\r\n            }\r\n\r\n            this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\r\n            if (this.debugMesh) {\r\n                this.debugMesh.renderingGroupId = this.renderingGroupId;\r\n                this.debugMesh.skeleton = this.skeleton;\r\n                this.debugMesh.parent = this.mesh;\r\n                this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n                this.debugMesh.alwaysSelectAsActiveMesh = true;\r\n            }\r\n\r\n            const light = this.utilityLayer!._getSharedGizmoLight();\r\n            light.intensity = 0.7;\r\n\r\n            this._revert(animationState);\r\n            this.ready = true;\r\n        } catch (err) {\r\n            console.error(err);\r\n            this._revert(animationState);\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    private _buildLocalAxes(): void {\r\n        if (this._localAxes) {\r\n            this._localAxes.dispose();\r\n        }\r\n\r\n        this._localAxes = null;\r\n\r\n        const displayOptions = this.options.displayOptions || {};\r\n\r\n        if (!displayOptions.showLocalAxes) {\r\n            return;\r\n        }\r\n\r\n        const targetScene = this._utilityLayer!.utilityLayerScene;\r\n        const size = displayOptions.localAxesSize || 0.075;\r\n        const lines = [];\r\n        const colors = [];\r\n        const red = new Color4(1, 0, 0, 1);\r\n        const green = new Color4(0, 1, 0, 1);\r\n        const blue = new Color4(0, 0, 1, 1);\r\n\r\n        const mwk: number[] = [];\r\n        const mik: number[] = [];\r\n        const vertsPerBone = 6;\r\n\r\n        for (const i in this.skeleton.bones) {\r\n            const bone = this.skeleton.bones[i];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n\r\n            const boneAbsoluteBindPoseTransform = new Matrix();\r\n            const boneOrigin = new Vector3();\r\n\r\n            this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n            boneAbsoluteBindPoseTransform.decompose(undefined, undefined, boneOrigin);\r\n\r\n            const m = bone.getBaseMatrix().getRotationMatrix();\r\n\r\n            const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\r\n            const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\r\n            const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\r\n\r\n            const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\r\n            const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\r\n            const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\r\n\r\n            const linePoints = [axisX, axisY, axisZ];\r\n            const lineColors = [\r\n                [red, red],\r\n                [green, green],\r\n                [blue, blue],\r\n            ];\r\n\r\n            lines.push(...linePoints);\r\n            colors.push(...lineColors);\r\n\r\n            for (let j = 0; j < vertsPerBone; j++) {\r\n                mwk.push(1, 0, 0, 0);\r\n                mik.push(bone.getIndex(), 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        this._localAxes = CreateLineSystem(\"localAxes\", { lines: lines, colors: colors, updatable: true }, targetScene);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n        this._localAxes.skeleton = this.skeleton;\r\n        this._localAxes.renderingGroupId = this.renderingGroupId;\r\n        this._localAxes.parent = this.mesh;\r\n        this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used for the line display. */\r\n    private _displayLinesUpdate(): void {\r\n        if (!this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        if (this.autoUpdateBonesMatrices) {\r\n            this.skeleton.computeAbsoluteTransforms();\r\n        }\r\n\r\n        if (this.skeleton.bones[0].length === undefined) {\r\n            this._getLinesForBonesNoLength(this.skeleton.bones);\r\n        } else {\r\n            this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\r\n        }\r\n\r\n        const targetScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        if (targetScene) {\r\n            if (!this._debugMesh) {\r\n                this._debugMesh = CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: null }, targetScene);\r\n                this._debugMesh.renderingGroupId = this.renderingGroupId;\r\n            } else {\r\n                CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);\r\n            }\r\n            this._debugMesh.position.copyFrom(this.mesh.position);\r\n            this._debugMesh.color = this.color;\r\n        }\r\n    }\r\n    /** Changes the displayMode of the skeleton viewer\r\n     * @param mode The displayMode numerical value\r\n     */\r\n    public changeDisplayMode(mode: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        if (this.displayMode !== mode) {\r\n            this.isEnabled = false;\r\n            if (this._debugMesh) {\r\n                this._debugMesh.dispose();\r\n                this._debugMesh = null;\r\n                this.ready = false;\r\n            }\r\n            this.displayMode = mode;\r\n\r\n            this.update();\r\n            this._bindObs();\r\n            this.isEnabled = wasEnabled;\r\n        }\r\n    }\r\n\r\n    /** Sets a display option of the skeleton viewer\r\n     *\r\n     * | Option           | Type    | Default | Description |\r\n     * | ---------------- | ------- | ------- | ----------- |\r\n     * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n     * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n     * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n     *\r\n     * @param option String of the option name\r\n     * @param value The numerical option value\r\n     */\r\n    public changeDisplayOptions(option: string, value: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        (this.options.displayOptions as any)[option] = value;\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n        this.update();\r\n        this._bindObs();\r\n        this.isEnabled = wasEnabled;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n        }\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n\r\n        this.ready = false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}