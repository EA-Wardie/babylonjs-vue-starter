{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { BackEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\n */\n\nvar BouncingBehavior =\n/** @class */\nfunction () {\n  function BouncingBehavior() {\n    /**\n     * The duration of the animation, in milliseconds\n     */\n    this.transitionDuration = 450;\n    /**\n     * Length of the distance animated by the transition when lower radius is reached\n     */\n\n    this.lowerRadiusTransitionRange = 2;\n    /**\n     * Length of the distance animated by the transition when upper radius is reached\n     */\n\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false; // Animations\n\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n\n  Object.defineProperty(BouncingBehavior.prototype, \"name\", {\n    /**\n     * Gets the name of the behavior.\n     */\n    get: function get() {\n      return \"Bouncing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BouncingBehavior.prototype, \"autoTransitionRange\", {\n    /**\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n     */\n    get: function get() {\n      return this._autoTransitionRange;\n    },\n\n    /**\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._autoTransitionRange === value) {\n        return;\n      }\n\n      this._autoTransitionRange = value;\n      var camera = this._attachedCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      if (value) {\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n          if (!mesh) {\n            return;\n          }\n\n          mesh.computeWorldMatrix(true);\n          var diagonal = mesh.getBoundingInfo().diagonalLength;\n          _this.lowerRadiusTransitionRange = diagonal * 0.05;\n          _this.upperRadiusTransitionRange = diagonal * 0.05;\n        });\n      } else if (this._onMeshTargetChangedObserver) {\n        camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initializes the behavior.\n   */\n\n  BouncingBehavior.prototype.init = function () {// Do nothing\n  };\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n\n\n  BouncingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      if (!_this._attachedCamera) {\n        return;\n      } // Add the bounce animation to the lower radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);\n      } // Add the bounce animation to the upper radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);\n      }\n    });\n  };\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n\n\n  BouncingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\n   * @param radiusLimit The limit to check against.\n   * @return Bool to indicate if at limit.\n   */\n\n\n  BouncingBehavior.prototype._isRadiusAtLimit = function (radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\n   * @param radiusDelta The delta by which to animate to. Can be negative.\n   */\n\n\n  BouncingBehavior.prototype._applyBoundRadiusAnimation = function (radiusDelta) {\n    var _this = this;\n\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    } // Prevent zoom until bounce has completed\n\n\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0; // Animate to the radius limit\n\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () {\n      return _this._clearAnimationLocks();\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\n   */\n\n\n  BouncingBehavior.prototype._clearAnimationLocks = function () {\n    this._radiusIsAnimating = false;\n\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  };\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n\n\n  BouncingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n\n      this._animatables[0].stop();\n\n      this._animatables.shift();\n    }\n  };\n  /**\n   * The easing function used by animations\n   */\n\n\n  BouncingBehavior.EasingFunction = new BackEase(0.3);\n  /**\n   * The easing mode used by animations\n   */\n\n  BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;\n  return BouncingBehavior;\n}();\n\nexport { BouncingBehavior };","map":{"version":3,"mappings":";AAGA,SAASA,QAAT,EAAmBC,cAAnB,QAAyC,4BAAzC;AAKA,SAASC,SAAT,QAA0B,+BAA1B;AAEA;;;;;AAIA;AAAA;AAAA;AAAA;AAkBI;;;AAGO,8BAAqB,GAArB;AAEP;;;;AAGO,sCAA6B,CAA7B;AAEP;;;;AAGO,sCAA6B,CAAC,CAA9B;AAEC,gCAAuB,KAAvB,CAjCZ,CA8HI;;AACQ,8BAA8B,KAA9B;AACA,mCAA+C,IAA/C;AACA,wBAAe,IAAIC,KAAJ,EAAf;AAgFX;;AA7MGC,wBAAWC,0BAAX,EAAW,MAAX,EAAe;AAHf;;;SAGA;AACI,aAAO,UAAP;AACH,KAFc;qBAAA;;AAAA,GAAf;AAkCAD,wBAAWC,0BAAX,EAAW,qBAAX,EAA8B;AAH9B;;;SAGA;AACI,aAAO,KAAKC,oBAAZ;AACH,KAF6B;;AAI9B;;;;SAIA,aAA+BC,KAA/B,EAA6C;AAA7C;;AACI,UAAI,KAAKD,oBAAL,KAA8BC,KAAlC,EAAyC;AACrC;AACH;;AAED,WAAKD,oBAAL,GAA4BC,KAA5B;AAEA,UAAMC,MAAM,GAAG,KAAKC,eAApB;;AACA,UAAI,CAACD,MAAL,EAAa;AACT;AACH;;AAED,UAAID,KAAJ,EAAW;AACP,aAAKG,4BAAL,GAAoCF,MAAM,CAACG,6BAAP,CAAqCC,GAArC,CAAyC,UAACC,IAAD,EAAK;AAC9E,cAAI,CAACA,IAAL,EAAW;AACP;AACH;;AAEDA,cAAI,CAACC,kBAAL,CAAwB,IAAxB;AACA,cAAMC,QAAQ,GAAGF,IAAI,CAACG,eAAL,GAAuBC,cAAxC;AAEAC,eAAI,CAACC,0BAAL,GAAkCJ,QAAQ,GAAG,IAA7C;AACAG,eAAI,CAACE,0BAAL,GAAkCL,QAAQ,GAAG,IAA7C;AACH,SAVmC,CAApC;AAWH,OAZD,MAYO,IAAI,KAAKL,4BAAT,EAAuC;AAC1CF,cAAM,CAACG,6BAAP,CAAqCU,MAArC,CAA4C,KAAKX,4BAAjD;AACH;AACJ,KAnC6B;qBAAA;;AAAA,GAA9B;AA0CA;;;;AAGOL,oCAAP,aACI;AACH,GAFM;AAIP;;;;;;AAIOA,sCAAP,UAAcG,MAAd,EAAqC;AAArC;;AACI,SAAKC,eAAL,GAAuBD,MAAvB;AACA,SAAKc,2BAAL,GAAmCd,MAAM,CAACe,4BAAP,CAAoCX,GAApC,CAAwC;AACvE,UAAI,CAACM,KAAI,CAACT,eAAV,EAA2B;AACvB;AACH,OAHsE,CAKvE;;;AACA,UAAIS,KAAI,CAACM,gBAAL,CAAsBN,KAAI,CAACT,eAAL,CAAqBgB,gBAA3C,CAAJ,EAAkE;AAC9DP,aAAI,CAACQ,0BAAL,CAAgCR,KAAI,CAACC,0BAArC;AACH,OARsE,CAUvE;;;AACA,UAAID,KAAI,CAACM,gBAAL,CAAsBN,KAAI,CAACT,eAAL,CAAqBkB,gBAA3C,CAAJ,EAAkE;AAC9DT,aAAI,CAACQ,0BAAL,CAAgCR,KAAI,CAACE,0BAArC;AACH;AACJ,KAdkC,CAAnC;AAeH,GAjBM;AAmBP;;;;;AAGOf,sCAAP;AACI,QAAI,CAAC,KAAKI,eAAV,EAA2B;AACvB;AACH;;AACD,QAAI,KAAKa,2BAAT,EAAsC;AAClC,WAAKb,eAAL,CAAqBc,4BAArB,CAAkDF,MAAlD,CAAyD,KAAKC,2BAA9D;AACH;;AACD,QAAI,KAAKZ,4BAAT,EAAuC;AACnC,WAAKD,eAAL,CAAqBE,6BAArB,CAAmDU,MAAnD,CAA0D,KAAKX,4BAA/D;AACH;;AACD,SAAKD,eAAL,GAAuB,IAAvB;AACH,GAXM;AAmBP;;;;;;;AAKQJ,gDAAR,UAAyBuB,WAAzB,EAAsD;AAClD,QAAI,CAAC,KAAKnB,eAAV,EAA2B;AACvB,aAAO,KAAP;AACH;;AAED,QAAI,KAAKA,eAAL,CAAqBoB,MAArB,KAAgCD,WAAhC,IAA+C,CAAC,KAAKE,kBAAzD,EAA6E;AACzE,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH,GATO;AAWR;;;;;;AAIQzB,0DAAR,UAAmC0B,WAAnC,EAAsD;AAAtD;;AACI,QAAI,CAAC,KAAKtB,eAAV,EAA2B;AACvB;AACH;;AAED,QAAI,CAAC,KAAKuB,uBAAV,EAAmC;AAC/B3B,sBAAgB,CAACJ,cAAjB,CAAgCgC,aAAhC,CAA8C5B,gBAAgB,CAAC6B,UAA/D;AACA,WAAKF,uBAAL,GAA+B9B,SAAS,CAACiC,eAAV,CAA0B,QAA1B,EAAoCjC,SAAS,CAACkC,mBAA9C,EAAmE,EAAnE,EAAuE/B,gBAAgB,CAACJ,cAAxF,CAA/B;AACH,KARiD,CASlD;;;AACA,SAAKoC,qBAAL,GAA6B,KAAK5B,eAAL,CAAqB6B,cAAlD;AACA,SAAK7B,eAAL,CAAqB6B,cAArB,GAAsCC,QAAtC;AACA,SAAK9B,eAAL,CAAqB+B,oBAArB,GAA4C,CAA5C,CAZkD,CAclD;;AACA,SAAKC,iBAAL;AACA,SAAKX,kBAAL,GAA0B,IAA1B;AACA,QAAMY,UAAU,GAAGxC,SAAS,CAACyC,YAAV,CACf,QADe,EAEf,KAAKlC,eAAL,CAAqBoB,MAArB,GAA8BE,WAFf,EAGf,KAAKtB,eAHU,EAIf,KAAKA,eAAL,CAAqBmC,QAArB,EAJe,EAKf,EALe,EAMf,KAAKZ,uBANU,EAOf,KAAKa,kBAPU,EAQf;AAAM,kBAAI,CAACC,oBAAL;AAA2B,KARlB,CAAnB;;AAWA,QAAIJ,UAAJ,EAAgB;AACZ,WAAKK,YAAL,CAAkBC,IAAlB,CAAuBN,UAAvB;AACH;AACJ,GA/BO;AAiCR;;;;;AAGUrC,oDAAV;AACI,SAAKyB,kBAAL,GAA0B,KAA1B;;AAEA,QAAI,KAAKrB,eAAT,EAA0B;AACtB,WAAKA,eAAL,CAAqB6B,cAArB,GAAsC,KAAKD,qBAA3C;AACH;AACJ,GANS;AAQV;;;;;AAGOhC,iDAAP;AACI,QAAI,KAAKI,eAAT,EAA0B;AACtB,WAAKA,eAAL,CAAqBwC,UAArB,GAAkC,EAAlC;AACH;;AACD,WAAO,KAAKF,YAAL,CAAkBG,MAAzB,EAAiC;AAC7B,WAAKH,YAAL,CAAkB,CAAlB,EAAqBI,cAArB,GAAsC,IAAtC;;AACA,WAAKJ,YAAL,CAAkB,CAAlB,EAAqBK,IAArB;;AACA,WAAKL,YAAL,CAAkBM,KAAlB;AACH;AACJ,GATM;AA/LP;;;;;AAGchD,oCAAiB,IAAIL,QAAJ,CAAa,GAAb,CAAjB;AAEd;;;;AAGcK,gCAAaJ,cAAc,CAACqD,kBAA5B;AAiMlB;AAAC,CAjND;;SAAajD","names":["BackEase","EasingFunction","Animation","Array","Object","BouncingBehavior","_autoTransitionRange","value","camera","_attachedCamera","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","add","mesh","computeWorldMatrix","diagonal","getBoundingInfo","diagonalLength","_this","lowerRadiusTransitionRange","upperRadiusTransitionRange","remove","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_isRadiusAtLimit","lowerRadiusLimit","_applyBoundRadiusAnimation","upperRadiusLimit","radiusLimit","radius","_radiusIsAnimating","radiusDelta","_radiusBounceTransition","setEasingMode","EasingMode","CreateAnimation","ANIMATIONTYPE_FLOAT","_cachedWheelPrecision","wheelPrecision","Infinity","inertialRadiusOffset","stopAllAnimations","animatable","TransitionTo","getScene","transitionDuration","_clearAnimationLocks","_animatables","push","animations","length","onAnimationEnd","stop","shift","EASINGMODE_EASEOUT"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Cameras/bouncingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                const diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @return Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}