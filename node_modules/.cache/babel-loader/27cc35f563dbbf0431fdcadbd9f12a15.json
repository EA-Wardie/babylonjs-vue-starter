{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { LensFlare } from \"./lensFlare.js\";\nimport \"../Shaders/lensFlare.fragment.js\";\nimport \"../Shaders/lensFlare.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n * It is usually composed of several `lensFlare`.\n * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\n */\n\nvar LensFlareSystem =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a lens flare system.\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n   * It is usually composed of several `lensFlare`.\n   * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\n   * @param name Define the name of the lens flare system in the scene\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\n   * @param scene Define the scene the lens flare system belongs to\n   */\n  function LensFlareSystem(\n  /**\n   * Define the name of the lens flare system\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\n     * List of lens flares used in this system.\n     */\n\n    this.lensFlares = new Array();\n    /**\n     * Define a limit from the border the lens flare can be visible.\n     */\n\n    this.borderLimit = 300;\n    /**\n     * Define a viewport border we do not want to see the lens flare in.\n     */\n\n    this.viewportBorder = 0;\n    /**\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\n     */\n\n    this.layerMask = 0x0fffffff;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n\n    this.meshesSelectionPredicate = function (m) {\n      return scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    };\n\n    var engine = scene.getEngine(); // VBO\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2); // Indices\n\n    this._createIndexBuffer();\n  }\n\n  Object.defineProperty(LensFlareSystem.prototype, \"scene\", {\n    /** Gets the scene */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LensFlareSystem.prototype._createIndexBuffer = function () {\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n  };\n\n  Object.defineProperty(LensFlareSystem.prototype, \"isEnabled\", {\n    /**\n     * Define if the lens flare system is enabled.\n     */\n    get: function get() {\n      return this._isEnabled;\n    },\n    set: function set(value) {\n      this._isEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the scene the effects belongs to.\n   * @returns the scene holding the lens flare system\n   */\n\n  LensFlareSystem.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\n   * Get the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the emitter of the lens flare system\n   */\n\n\n  LensFlareSystem.prototype.getEmitter = function () {\n    return this._emitter;\n  };\n  /**\n   * Set the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @param newEmitter Define the new emitter of the system\n   */\n\n\n  LensFlareSystem.prototype.setEmitter = function (newEmitter) {\n    this._emitter = newEmitter;\n  };\n  /**\n   * Get the lens flare system emitter position.\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the position\n   */\n\n\n  LensFlareSystem.prototype.getEmitterPosition = function () {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  };\n  /**\n   * @param globalViewport\n   * @hidden\n   */\n\n\n  LensFlareSystem.prototype.computeEffectivePosition = function (globalViewport) {\n    var position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n\n    var rhs = this._scene.useRightHandedSystem;\n    var okZ = position.z > 0 && !rhs || position.z < 0 && rhs;\n\n    if (okZ) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  LensFlareSystem.prototype._isVisible = function () {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n\n    var emitterPosition = this.getEmitterPosition();\n    var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    var distance = direction.length();\n    direction.normalize();\n    var ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n\n    var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  };\n  /**\n   * @hidden\n   */\n\n\n  LensFlareSystem.prototype.render = function () {\n    if (!this._scene.activeCamera) {\n      return false;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var viewport = this._scene.activeCamera.viewport;\n    var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true)); // Position\n\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    } // Visibility\n\n\n    if (!this._isVisible()) {\n      return false;\n    } // Intensity\n\n\n    var awayX;\n    var awayY;\n\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n\n    var away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n\n    var intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n\n    if (intensity < 0) {\n      return false;\n    }\n\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    } // Position\n\n\n    var centerX = globalViewport.x + globalViewport.width / 2;\n    var centerY = globalViewport.y + globalViewport.height / 2;\n    var distX = centerX - this._positionX;\n    var distY = centerY - this._positionY; // Effects\n\n    engine.setState(false);\n    engine.setDepthBuffer(false); // Flares\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n\n      if (!flare._drawWrapper.effect.isReady() || flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n\n      engine.enableEffect(flare._drawWrapper);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);\n      engine.setAlphaMode(flare.alphaMode);\n      var x = centerX - distX * flare.position;\n      var y = centerY - distY * flare.position;\n      var cw = flare.size;\n      var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      var viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n\n      flare._drawWrapper.effect.setMatrix(\"viewportMatrix\", viewportMatrix); // Texture\n\n\n      flare._drawWrapper.effect.setTexture(\"textureSampler\", flare.texture); // Color\n\n\n      flare._drawWrapper.effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0); // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  };\n  /**\n   * Rebuilds the lens flare system\n   */\n\n\n  LensFlareSystem.prototype.rebuild = function () {\n    var _a;\n\n    this._createIndexBuffer();\n\n    for (var key in this._vertexBuffers) {\n      (_a = this._vertexBuffers[key]) === null || _a === void 0 ? void 0 : _a._rebuild();\n    }\n  };\n  /**\n   * Dispose and release the lens flare with its associated resources.\n   */\n\n\n  LensFlareSystem.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    } // Remove from scene\n\n\n    var index = this._scene.lensFlareSystems.indexOf(this);\n\n    this._scene.lensFlareSystems.splice(index, 1);\n  };\n  /**\n   * Parse a lens flare system from a JSON representation\n   * @param parsedLensFlareSystem Define the JSON to parse\n   * @param scene Define the scene the parsed system should be instantiated in\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\n   * @returns the parsed system\n   */\n\n\n  LensFlareSystem.Parse = function (parsedLensFlareSystem, scene, rootUrl) {\n    var emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\n    var name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    var lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n\n    for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      var parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n\n    return lensFlareSystem;\n  };\n  /**\n   * Serialize the current Lens Flare System into a JSON representation.\n   * @returns the serialized JSON\n   */\n\n\n  LensFlareSystem.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n\n    return serializationObject;\n  };\n  /**\n   * @param _\n   * @hidden\n   */\n\n\n  LensFlareSystem._SceneComponentInitialization = function (_) {\n    throw _WarnImport(\"LensFlareSystemSceneComponent\");\n  };\n\n  return LensFlareSystem;\n}();\n\nexport { LensFlareSystem };","map":{"version":3,"mappings":"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","names":["Tools","Matrix","Vector3","Scalar","EngineStore","VertexBuffer","Ray","Material","LensFlare","_WarnImport","Color3","name","emitter","scene","Array","_scene","LastCreatedScene","LensFlareSystem","_SceneComponentInitialization","_emitter","id","lensFlareSystems","push","meshesSelectionPredicate","m","activeCamera","material","isVisible","isEnabled","isBlocker","layerMask","engine","getEngine","vertices","_vertexBuffers","PositionKind","_createIndexBuffer","Object","indices","_indexBuffer","createIndexBuffer","_isEnabled","value","newEmitter","getAbsolutePosition","position","globalViewport","getEmitterPosition","Project","Identity","getTransformMatrix","_positionX","x","_positionY","y","TransformCoordinates","getViewMatrix","viewportBorder","width","height","rhs","useRightHandedSystem","okZ","z","emitterPosition","direction","subtract","globalPosition","distance","length","normalize","ray","pickInfo","pickWithRay","hit","viewport","toGlobal","getRenderWidth","getRenderHeight","computeEffectivePosition","_isVisible","awayX","awayY","borderLimit","away","intensity","Clamp","centerX","centerY","distX","distY","setState","setDepthBuffer","index","lensFlares","flare","_drawWrapper","effect","isReady","texture","enableEffect","bindBuffers","setAlphaMode","alphaMode","cw","size","ch","getAspectRatio","cx","cy","viewportMatrix","FromValues","setMatrix","setTexture","setFloat4","color","r","g","b","drawElementsType","TriangleFillMode","key","_a","_rebuild","vertexBuffer","dispose","_releaseBuffer","indexOf","splice","parsedLensFlareSystem","rootUrl","getLastEntryById","emitterId","lensFlareSystem","flares","parsedFlare","AddFlare","FromArray","textureName","serializationObject","getEmitter","asArray","GetFilename","_"],"sourceRoot":"","sources":["../../../../../lts/core/generated/LensFlares/lensFlareSystem.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { LensFlare } from \"./lensFlare\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/lensFlare.fragment\";\r\nimport \"../Shaders/lensFlare.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\n\r\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n */\r\nexport class LensFlareSystem {\r\n    /**\r\n     * List of lens flares used in this system.\r\n     */\r\n    public lensFlares = new Array<LensFlare>();\r\n\r\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\r\n    public borderLimit = 300;\r\n\r\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\r\n    public viewportBorder = 0;\r\n\r\n    /**\r\n     * Define a predicate which could limit the list of meshes able to occlude the effect.\r\n     */\r\n    public meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /** Gets the scene */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Define the id of the lens flare system in the scene.\r\n     * (equal to name by default)\r\n     */\r\n    public id: string;\r\n\r\n    private _scene: Scene;\r\n    private _emitter: any;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _positionX: number;\r\n    private _positionY: number;\r\n    private _isEnabled = true;\r\n\r\n    /**\r\n     * @param _\r\n     * @hidden\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"LensFlareSystemSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Instantiates a lens flare system.\r\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n     * It is usually composed of several `lensFlare`.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     * @param name Define the name of the lens flare system in the scene\r\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param scene Define the scene the lens flare system belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the lens flare system\r\n         */\r\n        public name: string,\r\n        emitter: any,\r\n        scene: Scene\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        LensFlareSystem._SceneComponentInitialization(this._scene);\r\n\r\n        this._emitter = emitter;\r\n        this.id = name;\r\n        scene.lensFlareSystems.push(this);\r\n\r\n        this.meshesSelectionPredicate = (m) =>\r\n            <boolean>(scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        // Indices\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the effects belongs to.\r\n     * @returns the scene holding the lens flare system\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the emitter of the lens flare system\r\n     */\r\n    public getEmitter(): any {\r\n        return this._emitter;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param newEmitter Define the new emitter of the system\r\n     */\r\n    public setEmitter(newEmitter: any): void {\r\n        this._emitter = newEmitter;\r\n    }\r\n\r\n    /**\r\n     * Get the lens flare system emitter position.\r\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the position\r\n     */\r\n    public getEmitterPosition(): Vector3 {\r\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\r\n    }\r\n\r\n    /**\r\n     * @param globalViewport\r\n     * @hidden\r\n     */\r\n    public computeEffectivePosition(globalViewport: Viewport): boolean {\r\n        let position = this.getEmitterPosition();\r\n\r\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._positionX = position.x;\r\n        this._positionY = position.y;\r\n\r\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x -= this.viewportBorder;\r\n            globalViewport.y -= this.viewportBorder;\r\n            globalViewport.width += this.viewportBorder * 2;\r\n            globalViewport.height += this.viewportBorder * 2;\r\n            position.x += this.viewportBorder;\r\n            position.y += this.viewportBorder;\r\n            this._positionX += this.viewportBorder;\r\n            this._positionY += this.viewportBorder;\r\n        }\r\n\r\n        const rhs = this._scene.useRightHandedSystem;\r\n        const okZ = (position.z > 0 && !rhs) || (position.z < 0 && rhs);\r\n\r\n        if (okZ) {\r\n            if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\r\n                if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\r\n                    return true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _isVisible(): boolean {\r\n        if (!this._isEnabled || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const emitterPosition = this.getEmitterPosition();\r\n        const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\r\n        const distance = direction.length();\r\n        direction.normalize();\r\n\r\n        const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\r\n        const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\r\n\r\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public render(): boolean {\r\n        if (!this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const viewport = this._scene.activeCamera.viewport;\r\n        const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\r\n\r\n        // Position\r\n        if (!this.computeEffectivePosition(globalViewport)) {\r\n            return false;\r\n        }\r\n\r\n        // Visibility\r\n        if (!this._isVisible()) {\r\n            return false;\r\n        }\r\n\r\n        // Intensity\r\n        let awayX;\r\n        let awayY;\r\n\r\n        if (this._positionX < this.borderLimit + globalViewport.x) {\r\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\r\n        } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\r\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\r\n        } else {\r\n            awayX = 0;\r\n        }\r\n\r\n        if (this._positionY < this.borderLimit + globalViewport.y) {\r\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\r\n        } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\r\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\r\n        } else {\r\n            awayY = 0;\r\n        }\r\n\r\n        let away = awayX > awayY ? awayX : awayY;\r\n\r\n        away -= this.viewportBorder;\r\n\r\n        if (away > this.borderLimit) {\r\n            away = this.borderLimit;\r\n        }\r\n\r\n        let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\r\n        if (intensity < 0) {\r\n            return false;\r\n        }\r\n\r\n        if (intensity > 1.0) {\r\n            intensity = 1.0;\r\n        }\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x += this.viewportBorder;\r\n            globalViewport.y += this.viewportBorder;\r\n            globalViewport.width -= this.viewportBorder * 2;\r\n            globalViewport.height -= this.viewportBorder * 2;\r\n            this._positionX -= this.viewportBorder;\r\n            this._positionY -= this.viewportBorder;\r\n        }\r\n\r\n        // Position\r\n        const centerX = globalViewport.x + globalViewport.width / 2;\r\n        const centerY = globalViewport.y + globalViewport.height / 2;\r\n        const distX = centerX - this._positionX;\r\n        const distY = centerY - this._positionY;\r\n\r\n        // Effects\r\n        engine.setState(false);\r\n        engine.setDepthBuffer(false);\r\n\r\n        // Flares\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            if (!flare._drawWrapper.effect!.isReady() || (flare.texture && !flare.texture.isReady())) {\r\n                continue;\r\n            }\r\n\r\n            engine.enableEffect(flare._drawWrapper);\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect!);\r\n\r\n            engine.setAlphaMode(flare.alphaMode);\r\n\r\n            const x = centerX - distX * flare.position;\r\n            const y = centerY - distY * flare.position;\r\n\r\n            const cw = flare.size;\r\n            const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\r\n            const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\r\n            const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\r\n\r\n            const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\r\n\r\n            flare._drawWrapper.effect!.setMatrix(\"viewportMatrix\", viewportMatrix);\r\n\r\n            // Texture\r\n            flare._drawWrapper.effect!.setTexture(\"textureSampler\", flare.texture);\r\n\r\n            // Color\r\n            flare._drawWrapper.effect!.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        engine.setDepthBuffer(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the lens flare system\r\n     */\r\n    public rebuild(): void {\r\n        this._createIndexBuffer();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]?._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        while (this.lensFlares.length) {\r\n            this.lensFlares[0].dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        const index = this._scene.lensFlareSystems.indexOf(this);\r\n        this._scene.lensFlareSystems.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Parse a lens flare system from a JSON representation\r\n     * @param parsedLensFlareSystem Define the JSON to parse\r\n     * @param scene Define the scene the parsed system should be instantiated in\r\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n     * @returns the parsed system\r\n     */\r\n    public static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem {\r\n        const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\r\n\r\n        const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\r\n\r\n        const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\r\n\r\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\r\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\r\n\r\n        for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\r\n            const parsedFlare = parsedLensFlareSystem.flares[index];\r\n            LensFlare.AddFlare(\r\n                parsedFlare.size,\r\n                parsedFlare.position,\r\n                Color3.FromArray(parsedFlare.color),\r\n                parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\",\r\n                lensFlareSystem\r\n            );\r\n        }\r\n\r\n        return lensFlareSystem;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current Lens Flare System into a JSON representation.\r\n     * @returns the serialized JSON\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.emitterId = this.getEmitter().id;\r\n        serializationObject.borderLimit = this.borderLimit;\r\n\r\n        serializationObject.flares = [];\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            serializationObject.flares.push({\r\n                size: flare.size,\r\n                position: flare.position,\r\n                color: flare.color.asArray(),\r\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\"),\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}