{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space, Axis } from \"../Maths/math.axis.js\";\n/**\n * Class used to make a bone look toward a point in space\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller\n */\n\nvar BoneLookController =\n/** @class */\nfunction () {\n  /**\n   * Create a BoneLookController\n   * @param mesh the TransformNode that the bone belongs to\n   * @param bone the bone that will be looking to the target\n   * @param target the target Vector3 to look at\n   * @param options optional settings:\n   * * maxYaw: the maximum angle the bone will yaw to\n   * * minYaw: the minimum angle the bone will yaw to\n   * * maxPitch: the maximum angle the bone will pitch to\n   * * minPitch: the minimum angle the bone will yaw to\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n   * * upAxis: the up axis of the coordinate system\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\n   * * adjustRoll: used to make an adjustment to the roll of the bone\n   * @param options.maxYaw\n   * @param options.minYaw\n   * @param options.maxPitch\n   * @param options.minPitch\n   * @param options.slerpAmount\n   * @param options.upAxis\n   * @param options.upAxisSpace\n   * @param options.yawAxis\n   * @param options.pitchAxis\n   * @param options.adjustYaw\n   * @param options.adjustPitch\n   * @param options.adjustRoll\n   **/\n  function BoneLookController(mesh, bone, target, options) {\n    /**\n     * The up axis of the coordinate system that is used when the bone is rotated\n     */\n    this.upAxis = Vector3.Up();\n    /**\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\n     */\n\n    this.upAxisSpace = Space.LOCAL;\n    /**\n     * Used to make an adjustment to the yaw of the bone\n     */\n\n    this.adjustYaw = 0;\n    /**\n     * Used to make an adjustment to the pitch of the bone\n     */\n\n    this.adjustPitch = 0;\n    /**\n     * Used to make an adjustment to the roll of the bone\n     */\n\n    this.adjustRoll = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        var newYawAxis = Axis.Y;\n        var newPitchAxis = Axis.X;\n\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n\n        var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n\n        this._transformYawPitch.invert();\n      }\n    }\n\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n\n  Object.defineProperty(BoneLookController.prototype, \"minYaw\", {\n    /**\n     * Gets or sets the minimum yaw angle that the bone can look to\n     */\n    get: function get() {\n      return this._minYaw;\n    },\n    set: function set(value) {\n      this._minYaw = value;\n      this._minYawSin = Math.sin(value);\n      this._minYawCos = Math.cos(value);\n\n      if (this._maxYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxYaw\", {\n    /**\n     * Gets or sets the maximum yaw angle that the bone can look to\n     */\n    get: function get() {\n      return this._maxYaw;\n    },\n    set: function set(value) {\n      this._maxYaw = value;\n      this._maxYawSin = Math.sin(value);\n      this._maxYawCos = Math.cos(value);\n\n      if (this._minYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"minPitch\", {\n    /**\n     * Gets or sets the minimum pitch angle that the bone can look to\n     */\n    get: function get() {\n      return this._minPitch;\n    },\n    set: function set(value) {\n      this._minPitch = value;\n      this._minPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxPitch\", {\n    /**\n     * Gets or sets the maximum pitch angle that the bone can look to\n     */\n    get: function get() {\n      return this._maxPitch;\n    },\n    set: function set(value) {\n      this._maxPitch = value;\n      this._maxPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\n   */\n\n  BoneLookController.prototype.update = function () {\n    //skip the first frame when slerping so that the TransformNode rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n\n    var bone = this.bone;\n    var bonePos = BoneLookController._TmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    var target = this.target;\n    var _tmpMat1 = BoneLookController._TmpMats[0];\n    var _tmpMat2 = BoneLookController._TmpMats[1];\n    var mesh = this.mesh;\n    var parentBone = bone.getParent();\n    var upAxis = BoneLookController._TmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n\n    var checkYaw = false;\n    var checkPitch = false;\n\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n\n    if (checkYaw || checkPitch) {\n      var spaceMat = BoneLookController._TmpMats[2];\n      var spaceMatInv = BoneLookController._TmpMats[3];\n\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        var forwardAxis = BoneLookController._TmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n\n        var rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n\n      spaceMat.invertToRef(spaceMatInv);\n      var xzlen = null;\n\n      if (checkPitch) {\n        var localTarget = BoneLookController._TmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        var pitch = Math.atan2(localTarget.y, xzlen);\n        var newPitch = pitch;\n\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n\n      if (checkYaw) {\n        var localTarget = BoneLookController._TmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        var yaw = Math.atan2(localTarget.x, localTarget.z);\n        var newYaw = yaw;\n\n        if (yaw > this._maxYaw || yaw < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yaw > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (yaw < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          }\n        }\n\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          var boneFwd = BoneLookController._TmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n\n          var boneRotMat = BoneLookController._TmpMats[4];\n\n          this._boneQuat.toRotationMatrix(boneRotMat);\n\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n\n          var angBtwTar = this._getAngleBetween(boneYaw, yaw);\n\n          var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n\n            var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n\n            var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n\n    var zaxis = BoneLookController._TmpVecs[5];\n    var xaxis = BoneLookController._TmpVecs[6];\n    var yaxis = BoneLookController._TmpVecs[7];\n    var tmpQuat = BoneLookController._TmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n\n    this._updateLinkedTransformRotation();\n  };\n\n  BoneLookController.prototype._getAngleDiff = function (ang1, ang2) {\n    var angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n\n    return angDiff;\n  };\n\n  BoneLookController.prototype._getAngleBetween = function (ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    var ab = 0;\n\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n\n    return ab;\n  };\n\n  BoneLookController.prototype._isAngleBetween = function (ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  BoneLookController.prototype._updateLinkedTransformRotation = function () {\n    var bone = this.bone;\n\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  };\n\n  BoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\n  BoneLookController._TmpQuat = Quaternion.Identity();\n  BoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return BoneLookController;\n}();\n\nexport { BoneLookController };","map":{"version":3,"mappings":"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","names":["ArrayTools","Vector3","Quaternion","Matrix","Space","Axis","mesh","bone","target","options","Up","LOCAL","Identity","Forward","adjustYaw","adjustPitch","adjustRoll","maxYaw","Math","PI","minYaw","maxPitch","minPitch","slerpAmount","upAxis","upAxisSpace","yawAxis","pitchAxis","newYawAxis","Y","newPitchAxis","X","clone","normalize","newRollAxis","Cross","_transformYawPitch","FromXYZAxesToRef","_transformYawPitchInv","invert","getParent","BONE","Object","BoneLookController","_minYaw","value","_minYawSin","sin","_minYawCos","cos","_maxYaw","_midYawConstraint","_getAngleDiff","_yawRange","_maxYawSin","_maxYawCos","_minPitch","_minPitchTan","tan","_maxPitch","_maxPitchTan","_firstFrameSkipped","bonePos","_TmpVecs","getAbsolutePositionToRef","_tmpMat1","_TmpMats","_tmpMat2","parentBone","copyFrom","TransformCoordinatesToRef","getDirectionToRef","scaling","x","y","z","checkYaw","checkPitch","spaceMat","spaceMatInv","getRotationMatrixToRef","WORLD","getWorldMatrix","forwardAxis","_fowardAxis","rightAxis","invertToRef","xzlen","localTarget","subtractToRef","sqrt","pitch","atan2","newPitch","addInPlace","yaw","newYaw","_isAngleBetween","_slerping","boneFwd","Z","boneRotMat","_boneQuat","toRotationMatrix","multiplyToRef","boneYaw","angBtwTar","_getAngleBetween","angBtwMidYaw","angBtwMax","angBtwMin","zaxis","xaxis","yaxis","tmpQuat","_TmpQuat","CrossToRef","RotationYawPitchRollToRef","getRotationQuaternionToRef","FromRotationMatrixToRef","SlerpToRef","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","ang1","ang2","angDiff","ab","ang","_linkedTransformNode","rotationQuaternion","BuildArray","Zero"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Bones/boneLookController.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Bone } from \"./bone\";\r\nimport { Space, Axis } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller\r\n */\r\nexport class BoneLookController {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(10, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * The target Vector3 that the bone will look at\r\n     */\r\n    public target: Vector3;\r\n\r\n    /**\r\n     * The TransformNode that the bone is attached to\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The bone that will be looking to the target\r\n     */\r\n    public bone: Bone;\r\n\r\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\r\n    public upAxis: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\r\n    public upAxisSpace: Space = Space.LOCAL;\r\n\r\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\r\n    public adjustYaw = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\r\n    public adjustPitch = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\r\n    public adjustRoll = 0;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _minYaw: number;\r\n    private _maxYaw: number;\r\n    private _minPitch: number;\r\n    private _maxPitch: number;\r\n    private _minYawSin: number;\r\n    private _minYawCos: number;\r\n    private _maxYawSin: number;\r\n    private _maxYawCos: number;\r\n    private _midYawConstraint: number;\r\n    private _minPitchTan: number;\r\n    private _maxPitchTan: number;\r\n\r\n    private _boneQuat: Quaternion = Quaternion.Identity();\r\n    private _slerping = false;\r\n    private _transformYawPitch: Matrix;\r\n    private _transformYawPitchInv: Matrix;\r\n    private _firstFrameSkipped = false;\r\n    private _yawRange: number;\r\n    private _fowardAxis: Vector3 = Vector3.Forward();\r\n\r\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\r\n    get minYaw(): number {\r\n        return this._minYaw;\r\n    }\r\n\r\n    set minYaw(value: number) {\r\n        this._minYaw = value;\r\n        this._minYawSin = Math.sin(value);\r\n        this._minYawCos = Math.cos(value);\r\n        if (this._maxYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\r\n    get maxYaw(): number {\r\n        return this._maxYaw;\r\n    }\r\n\r\n    set maxYaw(value: number) {\r\n        this._maxYaw = value;\r\n        this._maxYawSin = Math.sin(value);\r\n        this._maxYawCos = Math.cos(value);\r\n        if (this._minYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\r\n    get minPitch(): number {\r\n        return this._minPitch;\r\n    }\r\n\r\n    set minPitch(value: number) {\r\n        this._minPitch = value;\r\n        this._minPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\r\n    get maxPitch(): number {\r\n        return this._maxPitch;\r\n    }\r\n\r\n    set maxPitch(value: number) {\r\n        this._maxPitch = value;\r\n        this._maxPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Create a BoneLookController\r\n     * @param mesh the TransformNode that the bone belongs to\r\n     * @param bone the bone that will be looking to the target\r\n     * @param target the target Vector3 to look at\r\n     * @param options optional settings:\r\n     * * maxYaw: the maximum angle the bone will yaw to\r\n     * * minYaw: the minimum angle the bone will yaw to\r\n     * * maxPitch: the maximum angle the bone will pitch to\r\n     * * minPitch: the minimum angle the bone will yaw to\r\n     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n     * * upAxis: the up axis of the coordinate system\r\n     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n     * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n     * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n     * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n     * * adjustRoll: used to make an adjustment to the roll of the bone\r\n     * @param options.maxYaw\r\n     * @param options.minYaw\r\n     * @param options.maxPitch\r\n     * @param options.minPitch\r\n     * @param options.slerpAmount\r\n     * @param options.upAxis\r\n     * @param options.upAxisSpace\r\n     * @param options.yawAxis\r\n     * @param options.pitchAxis\r\n     * @param options.adjustYaw\r\n     * @param options.adjustPitch\r\n     * @param options.adjustRoll\r\n     **/\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        target: Vector3,\r\n        options?: {\r\n            maxYaw?: number;\r\n            minYaw?: number;\r\n            maxPitch?: number;\r\n            minPitch?: number;\r\n            slerpAmount?: number;\r\n            upAxis?: Vector3;\r\n            upAxisSpace?: Space;\r\n            yawAxis?: Vector3;\r\n            pitchAxis?: Vector3;\r\n            adjustYaw?: number;\r\n            adjustPitch?: number;\r\n            adjustRoll?: number;\r\n        }\r\n    ) {\r\n        this.mesh = mesh;\r\n        this.bone = bone;\r\n        this.target = target;\r\n\r\n        if (options) {\r\n            if (options.adjustYaw) {\r\n                this.adjustYaw = options.adjustYaw;\r\n            }\r\n\r\n            if (options.adjustPitch) {\r\n                this.adjustPitch = options.adjustPitch;\r\n            }\r\n\r\n            if (options.adjustRoll) {\r\n                this.adjustRoll = options.adjustRoll;\r\n            }\r\n\r\n            if (options.maxYaw != null) {\r\n                this.maxYaw = options.maxYaw;\r\n            } else {\r\n                this.maxYaw = Math.PI;\r\n            }\r\n\r\n            if (options.minYaw != null) {\r\n                this.minYaw = options.minYaw;\r\n            } else {\r\n                this.minYaw = -Math.PI;\r\n            }\r\n\r\n            if (options.maxPitch != null) {\r\n                this.maxPitch = options.maxPitch;\r\n            } else {\r\n                this.maxPitch = Math.PI;\r\n            }\r\n\r\n            if (options.minPitch != null) {\r\n                this.minPitch = options.minPitch;\r\n            } else {\r\n                this.minPitch = -Math.PI;\r\n            }\r\n\r\n            if (options.slerpAmount != null) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n\r\n            if (options.upAxis != null) {\r\n                this.upAxis = options.upAxis;\r\n            }\r\n\r\n            if (options.upAxisSpace != null) {\r\n                this.upAxisSpace = options.upAxisSpace;\r\n            }\r\n\r\n            if (options.yawAxis != null || options.pitchAxis != null) {\r\n                let newYawAxis = Axis.Y;\r\n                let newPitchAxis = Axis.X;\r\n\r\n                if (options.yawAxis != null) {\r\n                    newYawAxis = options.yawAxis.clone();\r\n                    newYawAxis.normalize();\r\n                }\r\n\r\n                if (options.pitchAxis != null) {\r\n                    newPitchAxis = options.pitchAxis.clone();\r\n                    newPitchAxis.normalize();\r\n                }\r\n\r\n                const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\r\n\r\n                this._transformYawPitch = Matrix.Identity();\r\n                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\r\n\r\n                this._transformYawPitchInv = this._transformYawPitch.clone();\r\n                this._transformYawPitch.invert();\r\n            }\r\n        }\r\n\r\n        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\r\n            this.upAxisSpace = Space.LOCAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n     */\r\n    public update(): void {\r\n        //skip the first frame when slerping so that the TransformNode rotation is correct\r\n        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\r\n            this._firstFrameSkipped = true;\r\n            return;\r\n        }\r\n\r\n        const bone = this.bone;\r\n        const bonePos = BoneLookController._TmpVecs[0];\r\n        bone.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        let target = this.target;\r\n        const _tmpMat1 = BoneLookController._TmpMats[0];\r\n        const _tmpMat2 = BoneLookController._TmpMats[1];\r\n\r\n        const mesh = this.mesh;\r\n        const parentBone = bone.getParent();\r\n\r\n        const upAxis = BoneLookController._TmpVecs[1];\r\n        upAxis.copyFrom(this.upAxis);\r\n\r\n        if (this.upAxisSpace == Space.BONE && parentBone) {\r\n            if (this._transformYawPitch) {\r\n                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\r\n            }\r\n            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\r\n        } else if (this.upAxisSpace == Space.LOCAL) {\r\n            mesh.getDirectionToRef(upAxis, upAxis);\r\n            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\r\n                upAxis.normalize();\r\n            }\r\n        }\r\n\r\n        let checkYaw = false;\r\n        let checkPitch = false;\r\n\r\n        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\r\n            checkYaw = true;\r\n        }\r\n        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\r\n            checkPitch = true;\r\n        }\r\n\r\n        if (checkYaw || checkPitch) {\r\n            const spaceMat = BoneLookController._TmpMats[2];\r\n            const spaceMatInv = BoneLookController._TmpMats[3];\r\n\r\n            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\r\n                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\r\n            } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\r\n                spaceMat.copyFrom(mesh.getWorldMatrix());\r\n            } else {\r\n                let forwardAxis = BoneLookController._TmpVecs[2];\r\n                forwardAxis.copyFrom(this._fowardAxis);\r\n\r\n                if (this._transformYawPitch) {\r\n                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\r\n                }\r\n\r\n                if (parentBone) {\r\n                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\r\n                } else {\r\n                    mesh.getDirectionToRef(forwardAxis, forwardAxis);\r\n                }\r\n\r\n                const rightAxis = Vector3.Cross(upAxis, forwardAxis);\r\n                rightAxis.normalize();\r\n                forwardAxis = Vector3.Cross(rightAxis, upAxis);\r\n\r\n                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\r\n            }\r\n\r\n            spaceMat.invertToRef(spaceMatInv);\r\n\r\n            let xzlen: Nullable<number> = null;\r\n\r\n            if (checkPitch) {\r\n                const localTarget = BoneLookController._TmpVecs[3];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                const pitch = Math.atan2(localTarget.y, xzlen);\r\n                let newPitch = pitch;\r\n\r\n                if (pitch > this._maxPitch) {\r\n                    localTarget.y = this._maxPitchTan * xzlen;\r\n                    newPitch = this._maxPitch;\r\n                } else if (pitch < this._minPitch) {\r\n                    localTarget.y = this._minPitchTan * xzlen;\r\n                    newPitch = this._minPitch;\r\n                }\r\n\r\n                if (pitch != newPitch) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n\r\n            if (checkYaw) {\r\n                const localTarget = BoneLookController._TmpVecs[4];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                const yaw = Math.atan2(localTarget.x, localTarget.z);\r\n                let newYaw = yaw;\r\n\r\n                if (yaw > this._maxYaw || yaw < this._minYaw) {\r\n                    if (xzlen == null) {\r\n                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                    }\r\n\r\n                    if (this._yawRange > Math.PI) {\r\n                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    } else {\r\n                        if (yaw > this._maxYaw) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (yaw < this._minYaw) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._slerping && this._yawRange > Math.PI) {\r\n                    //are we going to be crossing into the min/max region?\r\n                    const boneFwd = BoneLookController._TmpVecs[8];\r\n                    boneFwd.copyFrom(Axis.Z);\r\n                    if (this._transformYawPitch) {\r\n                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\r\n                    }\r\n\r\n                    const boneRotMat = BoneLookController._TmpMats[4];\r\n                    this._boneQuat.toRotationMatrix(boneRotMat);\r\n                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\r\n\r\n                    const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\r\n                    const angBtwTar = this._getAngleBetween(boneYaw, yaw);\r\n                    const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\r\n\r\n                    if (angBtwTar > angBtwMidYaw) {\r\n                        if (xzlen == null) {\r\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                        }\r\n\r\n                        const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\r\n                        const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\r\n\r\n                        if (angBtwMin < angBtwMax) {\r\n                            newYaw = boneYaw + Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        } else {\r\n                            newYaw = boneYaw - Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (yaw != newYaw) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n        }\r\n\r\n        const zaxis = BoneLookController._TmpVecs[5];\r\n        const xaxis = BoneLookController._TmpVecs[6];\r\n        const yaxis = BoneLookController._TmpVecs[7];\r\n        const tmpQuat = BoneLookController._TmpQuat;\r\n\r\n        target.subtractToRef(bonePos, zaxis);\r\n        zaxis.normalize();\r\n        Vector3.CrossToRef(upAxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n        Vector3.CrossToRef(zaxis, xaxis, yaxis);\r\n        yaxis.normalize();\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\r\n\r\n        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\r\n            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\r\n            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\r\n        }\r\n\r\n        if (this.slerpAmount < 1) {\r\n            if (!this._slerping) {\r\n                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\r\n            }\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\r\n            Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\r\n\r\n            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\r\n            this._slerping = true;\r\n        } else {\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\r\n            this._slerping = false;\r\n        }\r\n\r\n        this._updateLinkedTransformRotation();\r\n    }\r\n\r\n    private _getAngleDiff(ang1: number, ang2: number): number {\r\n        let angDiff = ang2 - ang1;\r\n        angDiff %= Math.PI * 2;\r\n\r\n        if (angDiff > Math.PI) {\r\n            angDiff -= Math.PI * 2;\r\n        } else if (angDiff < -Math.PI) {\r\n            angDiff += Math.PI * 2;\r\n        }\r\n\r\n        return angDiff;\r\n    }\r\n\r\n    private _getAngleBetween(ang1: number, ang2: number): number {\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        let ab = 0;\r\n\r\n        if (ang1 < ang2) {\r\n            ab = ang2 - ang1;\r\n        } else {\r\n            ab = ang1 - ang2;\r\n        }\r\n\r\n        if (ab > Math.PI) {\r\n            ab = Math.PI * 2 - ab;\r\n        }\r\n\r\n        return ab;\r\n    }\r\n\r\n    private _isAngleBetween(ang: number, ang1: number, ang2: number): boolean {\r\n        ang %= 2 * Math.PI;\r\n        ang = ang < 0 ? ang + 2 * Math.PI : ang;\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        if (ang1 < ang2) {\r\n            if (ang > ang1 && ang < ang2) {\r\n                return true;\r\n            }\r\n        } else {\r\n            if (ang > ang2 && ang < ang1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(): void {\r\n        const bone = this.bone;\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}