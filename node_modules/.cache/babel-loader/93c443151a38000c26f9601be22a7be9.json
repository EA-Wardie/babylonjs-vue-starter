{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { __assign, __decorate, __extends } from \"tslib\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Shaders/glowBlurPostProcess.fragment.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\n\nAbstractScene.prototype.getHighlightLayerByName = function (name) {\n  var _a;\n\n  for (var index = 0; index < ((_a = this.effectLayers) === null || _a === void 0 ? void 0 : _a.length); index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\n * Special Glow Blur post process only blurring the alpha channel\n * It enforces keeping the most luminous color in the color channel.\n */\n\n\nvar GlowBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(GlowBlurPostProcess, _super);\n\n  function GlowBlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable) || this;\n\n    _this.direction = direction;\n    _this.kernel = kernel;\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setFloat2(\"screenSize\", _this.width, _this.height);\n      effect.setVector2(\"direction\", _this.direction);\n      effect.setFloat(\"blurWidth\", _this.kernel);\n    });\n\n    return _this;\n  }\n\n  return GlowBlurPostProcess;\n}(PostProcess);\n/**\n * The highlight layer Helps adding a glow effect around a mesh.\n *\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\n * glowy meshes to your scene.\n *\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\n */\n\n\nvar HighlightLayer =\n/** @class */\nfunction (_super) {\n  __extends(HighlightLayer, _super);\n  /**\n   * Instantiates a new highlight Layer and references it to the scene..\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\n   */\n\n\n  function HighlightLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.name = name;\n    /**\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\n     */\n\n    _this.innerGlow = true;\n    /**\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\n     */\n\n    _this.outerGlow = true;\n    /**\n     * An event triggered when the highlight layer is being blurred.\n     */\n\n    _this.onBeforeBlurObservable = new Observable();\n    /**\n     * An event triggered when the highlight layer has been blurred.\n     */\n\n    _this.onAfterBlurObservable = new Observable();\n    _this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\n    _this._meshes = {};\n    _this._excludedMeshes = {};\n    _this.neutralColor = HighlightLayer.NeutralColor; // Warn on stencil\n\n    if (!_this._engine.isStencilEnable) {\n      Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\n    } // Adapt options\n\n\n    _this._options = __assign({\n      mainTextureRatio: 0.5,\n      blurTextureSizeRatio: 0.5,\n      blurHorizontalSize: 1.0,\n      blurVerticalSize: 1.0,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: _this._options.alphaBlendingMode,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    }); // Do not render as long as no meshes have been added\n\n\n    _this._shouldRender = false;\n    return _this;\n  }\n\n  Object.defineProperty(HighlightLayer.prototype, \"blurHorizontalSize\", {\n    /**\n     * Gets the horizontal size of the blur.\n     */\n    get: function get() {\n      return this._horizontalBlurPostprocess.kernel;\n    },\n\n    /**\n     * Specifies the horizontal size of the blur.\n     */\n    set: function set(value) {\n      this._horizontalBlurPostprocess.kernel = value;\n      this._options.blurHorizontalSize = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HighlightLayer.prototype, \"blurVerticalSize\", {\n    /**\n     * Gets the vertical size of the blur.\n     */\n    get: function get() {\n      return this._verticalBlurPostprocess.kernel;\n    },\n\n    /**\n     * Specifies the vertical size of the blur.\n     */\n    set: function set(value) {\n      this._verticalBlurPostprocess.kernel = value;\n      this._options.blurVerticalSize = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the effect name of the layer.\n   * @return The effect name\n   */\n\n  HighlightLayer.prototype.getEffectName = function () {\n    return HighlightLayer.EffectName;\n  };\n\n  HighlightLayer.prototype._numInternalDraws = function () {\n    return 2; // we need two rendering, one for the inner glow and the other for the outer glow\n  };\n  /**\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   */\n\n\n  HighlightLayer.prototype._createMergeEffect = function () {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\n  };\n  /**\n   * Creates the render target textures and post processes used in the highlight layer.\n   */\n\n\n  HighlightLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n    var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.anisotropicFilteringLevel = 16;\n\n    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\n\n    this._blurTexture.renderParticles = false;\n    this._blurTexture.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture];\n\n    if (this._options.alphaBlendingMode === 2) {\n      this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._downSamplePostprocess.externalTextureSamplerBinding = true;\n\n      this._downSamplePostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    } else {\n      this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._horizontalBlurPostprocess.width = blurTextureWidth;\n      this._horizontalBlurPostprocess.height = blurTextureHeight;\n      this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    }\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      _this.onBeforeBlurObservable.notifyObservers(_this);\n\n      var internalTexture = _this._blurTexture.renderTarget;\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses, internalTexture, true);\n\n        _this._engine.unBindFramebuffer(internalTexture, true);\n      }\n\n      _this.onAfterBlurObservable.notifyObservers(_this);\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\n   * Returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n\n\n  HighlightLayer.prototype.needStencil = function () {\n    return true;\n  };\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @return true if ready otherwise, false\n   */\n\n\n  HighlightLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh || !this._meshes) {\n      return false;\n    }\n\n    var emissiveTexture = null;\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      emissiveTexture = material.emissiveTexture;\n    }\n\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   * @param renderIndex\n   */\n\n\n  HighlightLayer.prototype._internalRender = function (effect, renderIndex) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture); // Cache\n\n    var engine = this._engine;\n    engine.cacheStencilState(); // Stencil operations\n\n    engine.setStencilOperationPass(7681);\n    engine.setStencilOperationFail(7680);\n    engine.setStencilOperationDepthFail(7680); // Draw order\n\n    engine.setStencilMask(0x00);\n    engine.setStencilBuffer(true);\n    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference); // 2 passes inner outer\n\n    if (this.outerGlow && renderIndex === 0) {\n      // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\n      effect.setFloat(\"offset\", 0);\n      engine.setStencilFunction(517);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    if (this.innerGlow && renderIndex === 1) {\n      // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\n      effect.setFloat(\"offset\", 1);\n      engine.setStencilFunction(514);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Restore Cache\n\n\n    engine.restoreStencilState();\n  };\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   */\n\n\n  HighlightLayer.prototype.shouldRender = function () {\n    if (_super.prototype.shouldRender.call(this)) {\n      return this._meshes ? true : false;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n\n\n  HighlightLayer.prototype._shouldRenderMesh = function (mesh) {\n    // Excluded Mesh\n    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n\n\n  HighlightLayer.prototype._canRenderMesh = function (mesh, material) {\n    // all meshes can be rendered in the highlight layer, even transparent ones\n    return true;\n  };\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n\n\n  HighlightLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define HIGHLIGHT\");\n  };\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n\n\n  HighlightLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh) {\n      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n    } else {\n      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n    }\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n      this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._emissiveTextureAndColor.texture = null;\n    }\n  };\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\n   * @param mesh The mesh to exclude from the highlight layer\n   */\n\n\n  HighlightLayer.prototype.addExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (!meshExcluded) {\n      this._excludedMeshes[mesh.uniqueId] = {\n        mesh: mesh,\n        beforeBind: mesh.onBeforeBindObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(false);\n        }),\n        afterRender: mesh.onAfterRenderObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(true);\n        })\n      };\n    }\n  };\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\n   * @param mesh The mesh to highlight\n   */\n\n\n  HighlightLayer.prototype.removeExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (meshExcluded) {\n      if (meshExcluded.beforeBind) {\n        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\n      }\n\n      if (meshExcluded.afterRender) {\n        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n      }\n    }\n\n    this._excludedMeshes[mesh.uniqueId] = null;\n  };\n  /**\n   * Determine if a given mesh will be highlighted by the current HighlightLayer\n   * @param mesh mesh to test\n   * @returns true if the mesh will be highlighted by the current HighlightLayer\n   */\n\n\n  HighlightLayer.prototype.hasMesh = function (mesh) {\n    if (!this._meshes) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\n  };\n  /**\n   * Add a mesh in the highlight layer in order to make it glow with the chosen color.\n   * @param mesh The mesh to highlight\n   * @param color The color of the highlight\n   * @param glowEmissiveOnly Extract the glow from the emissive texture\n   */\n\n\n  HighlightLayer.prototype.addMesh = function (mesh, color, glowEmissiveOnly) {\n    var _this = this;\n\n    if (glowEmissiveOnly === void 0) {\n      glowEmissiveOnly = false;\n    }\n\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      meshHighlight.color = color;\n    } else {\n      this._meshes[mesh.uniqueId] = {\n        mesh: mesh,\n        color: color,\n        // Lambda required for capture due to Observable this context\n        observerHighlight: mesh.onBeforeBindObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            if (_this._excludedMeshes && _this._excludedMeshes[mesh.uniqueId]) {\n              _this._defaultStencilReference(mesh);\n            } else {\n              mesh.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);\n            }\n          }\n        }),\n        observerDefault: mesh.onAfterRenderObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            _this._defaultStencilReference(mesh);\n          }\n        }),\n        glowEmissiveOnly: glowEmissiveOnly\n      };\n      mesh.onDisposeObservable.add(function () {\n        _this._disposeMesh(mesh);\n      });\n    }\n\n    this._shouldRender = true;\n  };\n  /**\n   * Remove a mesh from the highlight layer in order to make it stop glowing.\n   * @param mesh The mesh to highlight\n   */\n\n\n  HighlightLayer.prototype.removeMesh = function (mesh) {\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      if (meshHighlight.observerHighlight) {\n        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n      }\n\n      if (meshHighlight.observerDefault) {\n        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n      }\n\n      delete this._meshes[mesh.uniqueId];\n    }\n\n    this._shouldRender = false;\n\n    for (var meshHighlightToCheck in this._meshes) {\n      if (this._meshes[meshHighlightToCheck]) {\n        this._shouldRender = true;\n        break;\n      }\n    }\n  };\n  /**\n   * Remove all the meshes currently referenced in the highlight layer\n   */\n\n\n  HighlightLayer.prototype.removeAllMeshes = function () {\n    if (!this._meshes) {\n      return;\n    }\n\n    for (var uniqueId in this._meshes) {\n      if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\n        var mesh = this._meshes[uniqueId];\n\n        if (mesh) {\n          this.removeMesh(mesh.mesh);\n        }\n      }\n    }\n  };\n  /**\n   * Force the stencil to the normal expected value for none glowing parts\n   * @param mesh\n   */\n\n\n  HighlightLayer.prototype._defaultStencilReference = function (mesh) {\n    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\n  };\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @hidden\n   */\n\n\n  HighlightLayer.prototype._disposeMesh = function (mesh) {\n    this.removeMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n\n\n  HighlightLayer.prototype.dispose = function () {\n    if (this._meshes) {\n      // Clean mesh references\n      for (var id in this._meshes) {\n        var meshHighlight = this._meshes[id];\n\n        if (meshHighlight && meshHighlight.mesh) {\n          if (meshHighlight.observerHighlight) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n          }\n\n          if (meshHighlight.observerDefault) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n          }\n        }\n      }\n\n      this._meshes = null;\n    }\n\n    if (this._excludedMeshes) {\n      for (var id in this._excludedMeshes) {\n        var meshHighlight = this._excludedMeshes[id];\n\n        if (meshHighlight) {\n          if (meshHighlight.beforeBind) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\n          }\n\n          if (meshHighlight.afterRender) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n          }\n        }\n      }\n\n      this._excludedMeshes = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n\n\n  HighlightLayer.prototype.getClassName = function () {\n    return \"HighlightLayer\";\n  };\n  /**\n   * Serializes this Highlight layer\n   * @returns a serialized Highlight layer object\n   */\n\n\n  HighlightLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.HighlightLayer\"; // Highlighted meshes\n\n    serializationObject.meshes = [];\n\n    if (this._meshes) {\n      for (var m in this._meshes) {\n        var mesh = this._meshes[m];\n\n        if (mesh) {\n          serializationObject.meshes.push({\n            glowEmissiveOnly: mesh.glowEmissiveOnly,\n            color: mesh.color.asArray(),\n            meshId: mesh.mesh.id\n          });\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes) {\n      for (var e in this._excludedMeshes) {\n        var excludedMesh = this._excludedMeshes[e];\n\n        if (excludedMesh) {\n          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Creates a Highlight layer from parsed Highlight layer data\n   * @param parsedHightlightLayer defines the Highlight layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the Highlight layer information\n   * @returns a parsed Highlight layer\n   */\n\n\n  HighlightLayer.Parse = function (parsedHightlightLayer, scene, rootUrl) {\n    var hl = SerializationHelper.Parse(function () {\n      return new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options);\n    }, parsedHightlightLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        hl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\n      var highlightedMesh = parsedHightlightLayer.meshes[index];\n      var mesh = scene.getMeshById(highlightedMesh.meshId);\n\n      if (mesh) {\n        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\n      }\n    }\n\n    return hl;\n  };\n  /**\n   * Effect Name of the highlight layer.\n   */\n\n\n  HighlightLayer.EffectName = \"HighlightLayer\";\n  /**\n   * The neutral color used during the preparation of the glow effect.\n   * This is black by default as the blend operation is a blend operation.\n   */\n\n  HighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);\n  /**\n   * Stencil value used for glowing meshes.\n   */\n\n  HighlightLayer.GlowingMeshStencilReference = 0x02;\n  /**\n   * Stencil value used for the other meshes in the scene.\n   */\n\n  HighlightLayer.NormalMeshStencilReference = 0x01;\n\n  __decorate([serialize()], HighlightLayer.prototype, \"innerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"outerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurHorizontalSize\", null);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurVerticalSize\", null);\n\n  __decorate([serialize(\"options\")], HighlightLayer.prototype, \"_options\", void 0);\n\n  return HighlightLayer;\n}(EffectLayer);\n\nexport { HighlightLayer };\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Observable","Vector2","Engine","VertexBuffer","Material","Texture","RenderTargetTexture","PostProcess","PassPostProcess","BlurPostProcess","EffectLayer","AbstractScene","Logger","RegisterClass","Color4","Color3","prototype","getHighlightLayerByName","name","index","effectLayers","_a","length","getEffectName","HighlightLayer","EffectName","__extends","direction","kernel","options","camera","samplingMode","engine","reusable","BILINEAR_SAMPLINGMODE","_super","_this","onApplyObservable","add","effect","setFloat2","width","height","setVector2","setFloat","scene","GlowingMeshStencilReference","neutralColor","NeutralColor","_engine","isStencilEnable","Warn","_options","__assign","mainTextureRatio","blurTextureSizeRatio","blurHorizontalSize","blurVerticalSize","alphaBlendingMode","renderingGroupId","_init","mainTextureFixedSize","_shouldRender","Object","_horizontalBlurPostprocess","value","_verticalBlurPostprocess","createEffect","PositionKind","isStroke","undefined","blurTextureWidth","_mainTextureDesiredSize","blurTextureHeight","needPOTTextures","GetExponentOfTwo","_maxSize","textureType","getCaps","textureHalfFloatRender","_blurTexture","_scene","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","updateSamplingMode","TRILINEAR_SAMPLINGMODE","renderParticles","ignoreCameraViewport","_textures","_downSamplePostprocess","getEngine","externalTextureSamplerBinding","setTexture","_mainTexture","GlowBlurPostProcess","_postProcesses","onAfterUnbindObservable","onBeforeBlurObservable","notifyObservers","internalTexture","renderTarget","postProcessManager","directRender","unBindFramebuffer","onAfterBlurObservable","map","pp","autoClear","subMesh","useInstances","material","getMaterial","mesh","getRenderingMesh","_meshes","emissiveTexture","highlightLayerMesh","uniqueId","glowEmissiveOnly","_isReady","call","renderIndex","cacheStencilState","setStencilOperationPass","setStencilOperationFail","setStencilOperationDepthFail","setStencilMask","setStencilBuffer","setStencilFunctionReference","_instanceGlowingMeshStencilReference","outerGlow","setStencilFunction","drawElementsType","TriangleFillMode","innerGlow","restoreStencilState","shouldRender","_excludedMeshes","hasMesh","defines","push","_emissiveTextureAndColor","color","set","r","g","b","a","texture","meshExcluded","beforeBind","onBeforeBindObservable","afterRender","onAfterRenderObservable","remove","meshHighlight","observerHighlight","isEnabled","_defaultStencilReference","getScene","observerDefault","onDisposeObservable","_disposeMesh","meshHighlightToCheck","hasOwnProperty","removeMesh","NormalMeshStencilReference","removeExcludedMesh","id","dispose","serializationObject","Serialize","customType","meshes","m","asArray","meshId","excludedMeshes","e","excludedMesh","parsedHightlightLayer","rootUrl","hl","Parse","getMeshById","addExcludedMesh","highlightedMesh","addMesh","FromArray","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/highlightLayer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcessOptions } from \"../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Shaders/glowBlurPostProcess.fragment\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @return The highlight layer if found otherwise null.\r\n         */\r\n        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getHighlightLayerByName = function (name: string): Nullable<HighlightLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as HighlightLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\r\nclass GlowBlurPostProcess extends PostProcess {\r\n    constructor(\r\n        name: string,\r\n        public direction: Vector2,\r\n        public kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean\r\n    ) {\r\n        super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"screenSize\", this.width, this.height);\r\n            effect.setVector2(\"direction\", this.direction);\r\n            effect.setFloat(\"blurWidth\", this.kernel);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IHighlightLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster).\r\n     */\r\n    blurTextureSizeRatio: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur.\r\n     */\r\n    blurVerticalSize: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur.\r\n     */\r\n    blurHorizontalSize: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default is combine.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke?\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n}\r\n\r\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\r\nexport class HighlightLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n        this._options.blurHorizontalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n        this._options.blurVerticalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    private _instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    @serialize(\"options\")\r\n    private _options: IHighlightLayerOptions;\r\n    private _downSamplePostprocess: PassPostProcess;\r\n    private _horizontalBlurPostprocess: GlowBlurPostProcess;\r\n    private _verticalBlurPostprocess: GlowBlurPostProcess;\r\n    private _blurTexture: RenderTargetTexture;\r\n\r\n    private _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    private _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     */\r\n    constructor(public name: string, scene?: Scene, options?: Partial<IHighlightLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = HighlightLayer.NeutralColor;\r\n\r\n        // Warn on stencil\r\n        if (!this._engine.isStencilEnable) {\r\n            Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\r\n        }\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId,\r\n        });\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return HighlightLayer.EffectName;\r\n    }\r\n\r\n    protected _numInternalDraws(): number {\r\n        return 2; // we need two rendering, one for the inner glow and the other for the outer glow\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the highlight layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        this._blurTexture = new RenderTargetTexture(\r\n            \"HighlightLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.anisotropicFilteringLevel = 16;\r\n        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._blurTexture.renderParticles = false;\r\n        this._blurTexture.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture];\r\n\r\n        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {\r\n            this._downSamplePostprocess = new PassPostProcess(\r\n                \"HighlightLayerPPP\",\r\n                this._options.blurTextureSizeRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._downSamplePostprocess.externalTextureSamplerBinding = true;\r\n            this._downSamplePostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._horizontalBlurPostprocess = new GlowBlurPostProcess(\r\n                \"HighlightLayerHBP\",\r\n                new Vector2(1.0, 0),\r\n                this._options.blurHorizontalSize,\r\n                1,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new GlowBlurPostProcess(\r\n                \"HighlightLayerVBP\",\r\n                new Vector2(0, 1.0),\r\n                this._options.blurVerticalSize,\r\n                1,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine()\r\n            );\r\n            this._verticalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        } else {\r\n            this._horizontalBlurPostprocess = new BlurPostProcess(\r\n                \"HighlightLayerHBP\",\r\n                new Vector2(1.0, 0),\r\n                this._options.blurHorizontalSize / 2,\r\n                {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine(),\r\n                false,\r\n                textureType\r\n            );\r\n            this._horizontalBlurPostprocess.width = blurTextureWidth;\r\n            this._horizontalBlurPostprocess.height = blurTextureHeight;\r\n            this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new BlurPostProcess(\r\n                \"HighlightLayerVBP\",\r\n                new Vector2(0, 1.0),\r\n                this._options.blurVerticalSize / 2,\r\n                {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                this._scene.getEngine(),\r\n                false,\r\n                textureType\r\n            );\r\n\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this.onBeforeBlurObservable.notifyObservers(this);\r\n\r\n            const internalTexture = this._blurTexture.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);\r\n                this._engine.unBindFramebuffer(internalTexture, true);\r\n            }\r\n\r\n            this.onAfterBlurObservable.notifyObservers(this);\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<Texture> = null;\r\n        const highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderIndex\r\n     */\r\n    protected _internalRender(effect: Effect, renderIndex: number): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(Constants.REPLACE);\r\n        engine.setStencilOperationFail(Constants.KEEP);\r\n        engine.setStencilOperationDepthFail(Constants.KEEP);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow && renderIndex === 0) {\r\n            // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(Constants.NOTEQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow && renderIndex === 1) {\r\n            // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(Constants.EQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (super.shouldRender()) {\r\n            return this._meshes ? true : false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        // all meshes can be rendered in the highlight layer, even transparent ones\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define HIGHLIGHT\");\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        const highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            this._excludedMeshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                beforeBind: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(false);\r\n                }),\r\n                afterRender: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(true);\r\n                }),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        } else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        } else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly,\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (const meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the stencil to the normal expected value for none glowing parts\r\n     * @param mesh\r\n     */\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @hidden\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (const id in this._meshes) {\r\n                const meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const id in this._excludedMeshes) {\r\n                const meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this Highlight layer\r\n     * @returns a serialized Highlight layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.HighlightLayer\";\r\n\r\n        // Highlighted meshes\r\n        serializationObject.meshes = [];\r\n\r\n        if (this._meshes) {\r\n            for (const m in this._meshes) {\r\n                const mesh = this._meshes[m];\r\n\r\n                if (mesh) {\r\n                    serializationObject.meshes.push({\r\n                        glowEmissiveOnly: mesh.glowEmissiveOnly,\r\n                        color: mesh.color.asArray(),\r\n                        meshId: mesh.mesh.id,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const e in this._excludedMeshes) {\r\n                const excludedMesh = this._excludedMeshes[e];\r\n\r\n                if (excludedMesh) {\r\n                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Highlight layer from parsed Highlight layer data\r\n     * @param parsedHightlightLayer defines the Highlight layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the Highlight layer information\r\n     * @returns a parsed Highlight layer\r\n     */\r\n    public static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer {\r\n        const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                hl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\r\n            const highlightedMesh = parsedHightlightLayer.meshes[index];\r\n            const mesh = scene.getMeshById(highlightedMesh.meshId);\r\n\r\n            if (mesh) {\r\n                hl.addMesh(<Mesh>mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\r\n            }\r\n        }\r\n\r\n        return hl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);\r\n"]},"metadata":{},"sourceType":"module"}