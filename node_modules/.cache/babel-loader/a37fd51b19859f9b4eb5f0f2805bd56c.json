{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { ShaderCodeNode } from \"./shaderCodeNode.js\";\nimport { ShaderCodeCursor } from \"./shaderCodeCursor.js\";\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode.js\";\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode.js\";\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator.js\";\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator.js\";\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator.js\";\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression.js\";\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nvar regexSE = /defined\\s*?\\((.+?)\\)/g;\nvar regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\n/** @hidden */\n\nvar ShaderProcessor =\n/** @class */\nfunction () {\n  function ShaderProcessor() {}\n\n  ShaderProcessor.Initialize = function (options) {\n    if (options.processor && options.processor.initializeShaders) {\n      options.processor.initializeShaders(options.processingContext);\n    }\n  };\n\n  ShaderProcessor.Process = function (sourceCode, options, callback, engine) {\n    var _this = this;\n\n    var _a;\n\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n\n    this._ProcessIncludes(sourceCode, options, function (codeWithIncludes) {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n\n      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);\n\n      callback(migratedCode);\n    });\n  };\n\n  ShaderProcessor.PreProcess = function (sourceCode, options, callback, engine) {\n    var _this = this;\n\n    var _a;\n\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n\n    this._ProcessIncludes(sourceCode, options, function (codeWithIncludes) {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n\n      var migratedCode = _this._ApplyPreProcessing(codeWithIncludes, options, engine);\n\n      callback(migratedCode);\n    });\n  };\n\n  ShaderProcessor.Finalize = function (vertexCode, fragmentCode, options) {\n    if (!options.processor || !options.processor.finalizeShaders) {\n      return {\n        vertexCode: vertexCode,\n        fragmentCode: fragmentCode\n      };\n    }\n\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\n  };\n\n  ShaderProcessor._ProcessPrecision = function (source, options) {\n    var _a;\n\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {\n      return source;\n    }\n\n    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n\n    return source;\n  };\n\n  ShaderProcessor._ExtractOperation = function (expression) {\n    var regex = /defined\\((.+)\\)/;\n    var match = regex.exec(expression);\n\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n\n    var operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\n    var operator = \"\";\n    var indexOperator = 0;\n\n    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {\n      operator = operators_1[_i];\n      indexOperator = expression.indexOf(operator);\n\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n\n    var define = expression.substring(0, indexOperator).trim();\n    var value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  };\n\n  ShaderProcessor._BuildSubExpression = function (expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    var postfix = ShaderDefineExpression.infixToPostfix(expression);\n    var stack = [];\n\n    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {\n      var c = postfix_1[_i];\n\n      if (c !== \"||\" && c !== \"&&\") {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        var v1 = stack[stack.length - 1],\n            v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        var operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n\n        if (typeof v1 === \"string\") {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n\n        if (typeof v2 === \"string\") {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n\n        operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n\n    var result = stack[stack.length - 1];\n\n    if (typeof result === \"string\") {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    } // note: stack.length !== 1 if there was an error in the parsing\n\n\n    return typeof result === \"string\" ? this._ExtractOperation(result) : result;\n  };\n\n  ShaderProcessor._BuildExpression = function (line, start) {\n    var node = new ShaderCodeTestNode();\n    var command = line.substring(0, start);\n    var expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n\n    return node;\n  };\n\n  ShaderProcessor._MoveCursorWithinIf = function (cursor, rootNode, ifNode) {\n    var line = cursor.currentLine;\n\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      var first5 = line.substring(0, 5).toLowerCase();\n\n      if (first5 === \"#else\") {\n        var elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n\n        this._MoveCursor(cursor, elseNode);\n\n        return;\n      } else if (first5 === \"#elif\") {\n        var elifNode = this._BuildExpression(line, 5);\n\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  };\n\n  ShaderProcessor._MoveCursor = function (cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      var line = cursor.currentLine;\n      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\n      var matches = keywords.exec(line);\n\n      if (matches && matches.length) {\n        var keyword = matches[0];\n\n        switch (keyword) {\n          case \"#ifdef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 6);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#else\":\n          case \"#elif\":\n            return true;\n\n          case \"#endif\":\n            return false;\n\n          case \"#ifndef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 7);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#if\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n\n              var ifNode = this._BuildExpression(line, 3);\n\n              rootNode.children.push(newRootNode);\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n        }\n      } else {\n        var newNode = new ShaderCodeNode();\n        newNode.line = line;\n        rootNode.children.push(newNode); // Detect additional defines\n\n        if (line[0] === \"#\" && line[1] === \"d\") {\n          var split = line.replace(\";\", \"\").split(\" \");\n          newNode.additionalDefineKey = split[1];\n\n          if (split.length === 3) {\n            newNode.additionalDefineValue = split[2];\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  ShaderProcessor._EvaluatePreProcessors = function (sourceCode, preprocessors, options) {\n    var rootNode = new ShaderCodeNode();\n    var cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\"); // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n\n    this._MoveCursor(cursor, rootNode); // Recompose\n\n\n    return rootNode.process(preprocessors, options);\n  };\n\n  ShaderProcessor._PreparePreProcessors = function (options, engine) {\n    var _a;\n\n    var defines = options.defines;\n    var preprocessors = {};\n\n    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {\n      var define = defines_1[_i];\n      var keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      var split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n\n    if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {\n      preprocessors[\"GL_ES\"] = \"true\";\n    }\n\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n\n    engine._getGlobalDefines(preprocessors);\n\n    return preprocessors;\n  };\n\n  ShaderProcessor._ProcessShaderConversion = function (sourceCode, options, engine) {\n    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n\n    if (!options.processor) {\n      return preparedSourceCode;\n    } // Already converted\n\n\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      return preparedSourceCode.replace(\"#version 300 es\", \"\");\n    }\n\n    var defines = options.defines;\n\n    var preprocessors = this._PreparePreProcessors(options, engine); // General pre processing\n\n\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options); // Post processing\n\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    } // Inline functions tagged with #define inline\n\n\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n\n    return preparedSourceCode;\n  };\n\n  ShaderProcessor._ApplyPreProcessing = function (sourceCode, options, engine) {\n    var _a, _b;\n\n    var preparedSourceCode = sourceCode;\n    var defines = options.defines;\n\n    var preprocessors = this._PreparePreProcessors(options, engine); // General pre processing\n\n\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options); // Post processing\n\n    if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    } // Inline functions tagged with #define inline\n\n\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n\n    return preparedSourceCode;\n  };\n\n  ShaderProcessor._ProcessIncludes = function (sourceCode, options, callback) {\n    var _this = this;\n\n    var regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\n    var match = regexShaderInclude.exec(sourceCode);\n    var returnValue = new String(sourceCode);\n    var keepProcessing = false;\n\n    var _loop_1 = function _loop_1() {\n      var includeFile = match[1]; // Uniform declaration\n\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(/__decl__/, \"\");\n\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(/Vertex/, \"Ubo\");\n          includeFile = includeFile.replace(/Fragment/, \"Ubo\");\n        }\n\n        includeFile = includeFile + \"Declaration\";\n      }\n\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        var includeContent = options.includesShadersStore[includeFile];\n\n        if (match[2]) {\n          var splits = match[3].split(\",\");\n\n          for (var index = 0; index < splits.length; index += 2) {\n            var source = new RegExp(splits[index], \"g\");\n            var dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n\n        if (match[4]) {\n          var indexString = match[5];\n\n          if (indexString.indexOf(\"..\") !== -1) {\n            var indexSplits = indexString.split(\"..\");\n            var minIndex = parseInt(indexSplits[0]);\n            var maxIndex = parseInt(indexSplits[1]);\n            var sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n\n            for (var i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                  return p1 + \"{X}\";\n                });\n              }\n\n              includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                return p1 + \"{X}\";\n              });\n            }\n\n            includeContent = includeContent.replace(/\\{X\\}/g, indexString);\n          }\n        } // Replace\n\n\n        returnValue = returnValue.replace(match[0], includeContent);\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\n      } else {\n        var includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, function (fileContent) {\n          options.includesShadersStore[includeFile] = fileContent;\n\n          _this._ProcessIncludes(returnValue, options, callback);\n        });\n\n        return {\n          value: void 0\n        };\n      }\n\n      match = regexShaderInclude.exec(sourceCode);\n    };\n\n    while (match != null) {\n      var state_1 = _loop_1();\n\n      if (_typeof(state_1) === \"object\") return state_1.value;\n    }\n\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  };\n  /**\n   * Loads a file from a url\n   * @param url url to load\n   * @param onSuccess callback called when the file successfully loads\n   * @param onProgress callback called while file is loading (if the server supports this mode)\n   * @param offlineProvider defines the offline provider for caching\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @param onError callback called when the file fails to load\n   * @returns a file request object\n   * @hidden\n   */\n\n\n  ShaderProcessor._FileToolsLoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _WarnImport(\"FileTools\");\n  };\n\n  return ShaderProcessor;\n}();\n\nexport { ShaderProcessor };","map":{"version":3,"mappings":"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","names":["ShaderCodeNode","ShaderCodeCursor","ShaderCodeConditionNode","ShaderCodeTestNode","ShaderDefineIsDefinedOperator","ShaderDefineOrOperator","ShaderDefineAndOperator","ShaderDefineExpression","ShaderDefineArithmeticOperator","_WarnImport","ShaderLanguage","regexSE","regexSERevert","ShaderProcessor","options","processor","initializeShaders","processingContext","sourceCode","callback","engine","_a","preProcessShaderCode","isFragment","_ProcessIncludes","codeWithIncludes","processCodeAfterIncludes","migratedCode","_this","_ProcessShaderConversion","_ApplyPreProcessing","vertexCode","fragmentCode","finalizeShaders","source","noPrecision","shouldUseHighPrecisionShader","indexOf","replace","expression","regex","match","exec","length","trim","operators","operator","indexOperator","_i","define","substring","value","postfix","infixToPostfix","stack","c","push","v1","v2","leftOperand","_ExtractOperation","rightOperand","result","line","start","node","command","testExpression","_BuildSubExpression","cursor","rootNode","ifNode","currentLine","_MoveCursor","first5","toLowerCase","elseNode","children","elifNode","_BuildExpression","canRead","lineIndex","keywords","matches","keyword","newRootNode","_MoveCursorWithinIf","newNode","split","additionalDefineKey","additionalDefineValue","preprocessors","lines","process","defines","keyValue","shaderLanguage","GLSL","version","platformName","_getGlobalDefines","preparedSourceCode","_ProcessPrecision","_PreparePreProcessors","preProcessor","_EvaluatePreProcessors","postProcessor","_features","needShaderCodeInlining","inlineShaderCode","_b","regexShaderInclude","returnValue","String","keepProcessing","includeFile","supportsUniformBuffers","includesShadersStore","includeContent","splits","index","RegExp","dest","indexString","indexSplits","minIndex","parseInt","maxIndex","sourceIncludeContent","slice","isNaN","indexParameters","i","str","p1","toString","includeShaderUrl","shadersRepository","_FileToolsLoadFile","fileContent","url","onSuccess","onProgress","offlineProvider","useArrayBuffer","onError"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Processors/shaderProcessor.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\ndeclare type WebRequest = import(\"../../Misc/webRequest\").WebRequest;\r\ndeclare type LoadFileError = import(\"../../Misc/fileTools\").LoadFileError;\r\ndeclare type IOfflineProvider = import(\"../../Offline/IOfflineProvider\").IOfflineProvider;\r\ndeclare type IFileRequest = import(\"../../Misc/fileRequest\").IFileRequest;\r\ndeclare type ThinEngine = import(\"../thinEngine\").ThinEngine;\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\n\r\n/** @hidden */\r\nexport class ShaderProcessor {\r\n    public static Initialize(options: ProcessingOptions): void {\r\n        if (options.processor && options.processor.initializeShaders) {\r\n            options.processor.initializeShaders(options.processingContext);\r\n        }\r\n    }\r\n\r\n    public static Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\r\n            callback(migratedCode);\r\n        });\r\n    }\r\n\r\n    public static PreProcess(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\r\n            callback(migratedCode);\r\n        });\r\n    }\r\n\r\n    public static Finalize(vertexCode: string, fragmentCode: string, options: ProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n        if (!options.processor || !options.processor.finalizeShaders) {\r\n            return { vertexCode, fragmentCode };\r\n        }\r\n\r\n        return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n    }\r\n\r\n    private static _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n        if (options.processor?.noPrecision) {\r\n            return source;\r\n        }\r\n\r\n        const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n        if (source.indexOf(\"precision highp float\") === -1) {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                source = \"precision mediump float;\\n\" + source;\r\n            } else {\r\n                source = \"precision highp float;\\n\" + source;\r\n            }\r\n        } else {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                // Moving highp to mediump\r\n                source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n            }\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    private static _ExtractOperation(expression: string) {\r\n        const regex = /defined\\((.+)\\)/;\r\n\r\n        const match = regex.exec(expression);\r\n\r\n        if (match && match.length) {\r\n            return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n        }\r\n\r\n        const operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\r\n        let operator = \"\";\r\n        let indexOperator = 0;\r\n\r\n        for (operator of operators) {\r\n            indexOperator = expression.indexOf(operator);\r\n\r\n            if (indexOperator > -1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (indexOperator === -1) {\r\n            return new ShaderDefineIsDefinedOperator(expression);\r\n        }\r\n\r\n        const define = expression.substring(0, indexOperator).trim();\r\n        const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n        return new ShaderDefineArithmeticOperator(define, operator, value);\r\n    }\r\n\r\n    private static _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n        expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n        const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n        const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (c !== \"||\" && c !== \"&&\") {\r\n                stack.push(c);\r\n            } else if (stack.length >= 2) {\r\n                let v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n\r\n                const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n                if (typeof v1 === \"string\") {\r\n                    v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                if (typeof v2 === \"string\") {\r\n                    v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\r\n                operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\r\n\r\n                stack.push(operator);\r\n            }\r\n        }\r\n\r\n        let result = stack[stack.length - 1];\r\n\r\n        if (typeof result === \"string\") {\r\n            result = result.replace(regexSERevert, \"defined($1)\");\r\n        }\r\n\r\n        // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n        return typeof result === \"string\" ? this._ExtractOperation(result) : result;\r\n    }\r\n\r\n    private static _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n        const node = new ShaderCodeTestNode();\r\n        const command = line.substring(0, start);\r\n        let expression = line.substring(start);\r\n\r\n        expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n        if (command === \"#ifdef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n        } else if (command === \"#ifndef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n        } else {\r\n            node.testExpression = this._BuildSubExpression(expression);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private static _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n        let line = cursor.currentLine;\r\n        while (this._MoveCursor(cursor, ifNode)) {\r\n            line = cursor.currentLine;\r\n            const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n            if (first5 === \"#else\") {\r\n                const elseNode = new ShaderCodeNode();\r\n                rootNode.children.push(elseNode);\r\n                this._MoveCursor(cursor, elseNode);\r\n                return;\r\n            } else if (first5 === \"#elif\") {\r\n                const elifNode = this._BuildExpression(line, 5);\r\n\r\n                rootNode.children.push(elifNode);\r\n                ifNode = elifNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n        while (cursor.canRead) {\r\n            cursor.lineIndex++;\r\n            const line = cursor.currentLine;\r\n            const keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n            const matches = keywords.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                const keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = this._BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = this._BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        const ifNode = this._BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                const newNode = new ShaderCodeNode();\r\n                newNode.line = line;\r\n                rootNode.children.push(newNode);\r\n\r\n                // Detect additional defines\r\n                if (line[0] === \"#\" && line[1] === \"d\") {\r\n                    const split = line.replace(\";\", \"\").split(\" \");\r\n                    newNode.additionalDefineKey = split[1];\r\n\r\n                    if (split.length === 3) {\r\n                        newNode.additionalDefineValue = split[2];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        const rootNode = new ShaderCodeNode();\r\n        const cursor = new ShaderCodeCursor();\r\n\r\n        cursor.lineIndex = -1;\r\n        cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n        // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n        this._MoveCursor(cursor, rootNode);\r\n\r\n        // Recompose\r\n        return rootNode.process(preprocessors, options);\r\n    }\r\n\r\n    private static _PreparePreProcessors(options: ProcessingOptions, engine: ThinEngine): { [key: string]: string } {\r\n        const defines = options.defines;\r\n        const preprocessors: { [key: string]: string } = {};\r\n\r\n        for (const define of defines) {\r\n            const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n            const split = keyValue.split(\" \");\r\n            preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n        }\r\n\r\n        if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n            preprocessors[\"GL_ES\"] = \"true\";\r\n        }\r\n        preprocessors[\"__VERSION__\"] = options.version;\r\n        preprocessors[options.platformName] = \"true\";\r\n\r\n        engine._getGlobalDefines(preprocessors);\r\n\r\n        return preprocessors;\r\n    }\r\n\r\n    private static _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\r\n\r\n        if (!options.processor) {\r\n            return preparedSourceCode;\r\n        }\r\n\r\n        // Already converted\r\n        if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n            return preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n        }\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ApplyPreProcessing(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = sourceCode;\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor?.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor?.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n        const regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\n        let match = regexShaderInclude.exec(sourceCode);\r\n\r\n        let returnValue = new String(sourceCode);\r\n        let keepProcessing = false;\r\n\r\n        while (match != null) {\r\n            let includeFile = match[1];\r\n\r\n            // Uniform declaration\r\n            if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n                includeFile = includeFile.replace(/__decl__/, \"\");\r\n                if (options.supportsUniformBuffers) {\r\n                    includeFile = includeFile.replace(/Vertex/, \"Ubo\");\r\n                    includeFile = includeFile.replace(/Fragment/, \"Ubo\");\r\n                }\r\n                includeFile = includeFile + \"Declaration\";\r\n            }\r\n\r\n            if (options.includesShadersStore[includeFile]) {\r\n                // Substitution\r\n                let includeContent = options.includesShadersStore[includeFile];\r\n                if (match[2]) {\r\n                    const splits = match[3].split(\",\");\r\n\r\n                    for (let index = 0; index < splits.length; index += 2) {\r\n                        const source = new RegExp(splits[index], \"g\");\r\n                        const dest = splits[index + 1];\r\n\r\n                        includeContent = includeContent.replace(source, dest);\r\n                    }\r\n                }\r\n\r\n                if (match[4]) {\r\n                    const indexString = match[5];\r\n\r\n                    if (indexString.indexOf(\"..\") !== -1) {\r\n                        const indexSplits = indexString.split(\"..\");\r\n                        const minIndex = parseInt(indexSplits[0]);\r\n                        let maxIndex = parseInt(indexSplits[1]);\r\n                        let sourceIncludeContent = includeContent.slice(0);\r\n                        includeContent = \"\";\r\n\r\n                        if (isNaN(maxIndex)) {\r\n                            maxIndex = options.indexParameters[indexSplits[1]];\r\n                        }\r\n\r\n                        for (let i = minIndex; i < maxIndex; i++) {\r\n                            if (!options.supportsUniformBuffers) {\r\n                                // Ubo replacement\r\n                                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                    return p1 + \"{X}\";\r\n                                });\r\n                            }\r\n                            includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\r\n                        }\r\n                    } else {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent = includeContent.replace(/\\{X\\}/g, indexString);\r\n                    }\r\n                }\r\n\r\n                // Replace\r\n                returnValue = returnValue.replace(match[0], includeContent);\r\n\r\n                keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n            } else {\r\n                const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n                ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {\r\n                    options.includesShadersStore[includeFile] = fileContent as string;\r\n                    this._ProcessIncludes(<string>returnValue, options, callback);\r\n                });\r\n                return;\r\n            }\r\n\r\n            match = regexShaderInclude.exec(sourceCode);\r\n        }\r\n\r\n        if (keepProcessing) {\r\n            this._ProcessIncludes(returnValue.toString(), options, callback);\r\n        } else {\r\n            callback(returnValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @hidden\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}