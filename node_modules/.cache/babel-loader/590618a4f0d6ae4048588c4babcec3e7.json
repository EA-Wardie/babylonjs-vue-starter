{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateDisc } from \"../Meshes/Builders/discBuilder.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The SPS is also a particle system. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System\n */\n\nvar SolidParticleSystem =\n/** @class */\nfunction () {\n  /**\n   * Creates a SPS (Solid Particle System) object.\n   * @param name (String) is the SPS name, this will be the underlying mesh name.\n   * @param scene (Scene) is the scene in which the SPS is added.\n   * @param options defines the options of the sps e.g.\n   * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\n   * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\n   * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\n   * * useModelMaterial (optional boolean, default false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\n   * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\n   * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\n   * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\n   * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\n   * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the bounding sphere radius by in order to reduce it for instance.\n   * @param options.updatable\n   * @param options.isPickable\n   * @param options.enableDepthSort\n   * @param options.particleIntersection\n   * @param options.boundingSphereOnly\n   * @param options.bSphereRadiusFactor\n   * @param options.expandable\n   * @param options.useModelMaterial\n   * @param options.enableMultiMaterial\n   * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\n   */\n  function SolidParticleSystem(name, scene, options) {\n    /**\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\n     *  Example : var p = SPS.particles[i];\n     */\n    this.particles = new Array();\n    /**\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\n     */\n\n    this.nbParticles = 0;\n    /**\n     * If the particles must ever face the camera (default false). Useful for planar particles.\n     */\n\n    this.billboard = false;\n    /**\n     * Recompute normals when adding a shape\n     */\n\n    this.recomputeNormals = false;\n    /**\n     * This a counter ofr your own usage. It's not set by any SPS functions.\n     */\n\n    this.counter = 0;\n    /**\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns\n     */\n\n    this.vars = {};\n    /**\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\n     * @hidden\n     */\n\n    this._bSphereOnly = false;\n    /**\n     * A number to multiply the bounding sphere radius by in order to reduce it for instance. (Internal use only)\n     * @hidden\n     */\n\n    this._bSphereRadiusFactor = 1.0;\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._index = 0; // indices index\n\n    this._updatable = true;\n    this._pickable = false;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._depthSort = false;\n    this._expandable = false;\n    this._shapeCounter = 0;\n    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\n    this._color = new Color4(0, 0, 0, 0);\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeParticleVertex = false;\n    this._computeBoundingBox = false;\n    this._depthSortParticles = true;\n    this._mustUnrotateFixedNormals = false;\n    this._particlesIntersect = false;\n    this._needs32Bits = false;\n    this._isNotBuilt = true;\n    this._lastParticleId = 0;\n    this._idxOfId = []; // array : key = particle.id / value = particle.idx\n\n    this._multimaterialEnabled = false;\n    this._useModelMaterial = false;\n\n    this._depthSortFunction = function (p1, p2) {\n      return p2.sqDistance - p1.sqDistance;\n    };\n\n    this._materialSortFunction = function (p1, p2) {\n      return p1.materialIndex - p2.materialIndex;\n    };\n\n    this._autoUpdateSubMeshes = false;\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._camera = scene.activeCamera;\n    this._pickable = options ? options.isPickable : false;\n    this._depthSort = options ? options.enableDepthSort : false;\n    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;\n    this._useModelMaterial = options ? options.useModelMaterial : false;\n    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\n    this._expandable = options ? options.expandable : false;\n    this._particlesIntersect = options ? options.particleIntersection : false;\n    this._bSphereOnly = options ? options.boundingSphereOnly : false;\n    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    if (this._multimaterialEnabled) {\n      this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n      this._materials = [];\n      this._materialIndexesById = {};\n    }\n\n    this._tmpVertex = new SolidParticleVertex();\n  }\n  /**\n   * Builds the SPS underlying mesh. Returns a standard Mesh.\n   * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\n   * @returns the created mesh\n   */\n\n\n  SolidParticleSystem.prototype.buildMesh = function () {\n    if (!this._isNotBuilt && this.mesh) {\n      return this.mesh;\n    }\n\n    if (this.nbParticles === 0 && !this.mesh) {\n      var triangle = CreateDisc(\"\", {\n        radius: 1,\n        tessellation: 3\n      }, this._scene);\n      this.addShape(triangle, 1);\n      triangle.dispose();\n    }\n\n    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n\n    if (!this.mesh) {\n      // in case it's already expanded\n      var mesh = new Mesh(this.name, this._scene);\n      this.mesh = mesh;\n    }\n\n    if (!this._updatable && this._multimaterialEnabled) {\n      this._sortParticlesByMaterial(); // this may reorder the indices32\n\n    }\n\n    if (this.recomputeNormals) {\n      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\n    }\n\n    this._normals32 = new Float32Array(this._normals);\n    this._fixedNormal32 = new Float32Array(this._normals);\n\n    if (this._mustUnrotateFixedNormals) {\n      // the particles could be created already rotated in the mesh with a positionFunction\n      this._unrotateFixedNormals();\n    }\n\n    var vertexData = new VertexData();\n    vertexData.indices = this._depthSort ? this._indices : this._indices32;\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    vertexData.set(this._normals32, VertexBuffer.NormalKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    if (this._colors32.length > 0) {\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    vertexData.applyToMesh(this.mesh, this._updatable);\n    this.mesh.isPickable = this._pickable;\n\n    if (this._pickable) {\n      var faceId = 0;\n\n      for (var p = 0; p < this.nbParticles; p++) {\n        var part = this.particles[p];\n        var lind = part._model._indicesLength;\n\n        for (var i = 0; i < lind; i++) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = {\n              idx: part.idx,\n              faceId: faceId\n            };\n            this.pickedParticles[faceId] = pickedData;\n            faceId++;\n          }\n        }\n      }\n    }\n\n    if (this._multimaterialEnabled) {\n      this.setMultiMaterial(this._materials);\n    }\n\n    if (!this._expandable) {\n      // free memory\n      if (!this._depthSort && !this._multimaterialEnabled) {\n        this._indices = null;\n      }\n\n      this._positions = null;\n      this._normals = null;\n      this._uvs = null;\n      this._colors = null;\n\n      if (!this._updatable) {\n        this.particles.length = 0;\n      }\n    }\n\n    this._isNotBuilt = false;\n    this.recomputeNormals = false;\n    return this.mesh;\n  };\n  /**\n   * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\n   * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\n   * Thus the particles generated from `digest()` have their property `position` set yet.\n   * @param mesh ( Mesh ) is the mesh to be digested\n   * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overridden by the parameter `number` if any\n   * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\n   * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n   * @param options.facetNb\n   * @param options.number\n   * @param options.delta\n   * @param options.storage\n   * @returns the current SPS\n   */\n\n\n  SolidParticleSystem.prototype.digest = function (mesh, options) {\n    var size = options && options.facetNb || 1;\n    var number = options && options.number || 0;\n    var delta = options && options.delta || 0;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    var storage = options && options.storage ? options.storage : null;\n    var f = 0; // facet counter\n\n    var totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n    // compute size from number\n\n    if (number) {\n      number = number > totalFacets ? totalFacets : number;\n      size = Math.round(totalFacets / number);\n      delta = 0;\n    } else {\n      size = size > totalFacets ? totalFacets : size;\n    }\n\n    var facetPos = []; // submesh positions\n\n    var facetNor = [];\n    var facetInd = []; // submesh indices\n\n    var facetUV = []; // submesh UV\n\n    var facetCol = []; // submesh colors\n\n    var barycenter = Vector3.Zero();\n    var sizeO = size;\n\n    while (f < totalFacets) {\n      size = sizeO + Math.floor((1 + delta) * Math.random());\n\n      if (f > totalFacets - size) {\n        size = totalFacets - f;\n      } // reset temp arrays\n\n\n      facetPos.length = 0;\n      facetNor.length = 0;\n      facetInd.length = 0;\n      facetUV.length = 0;\n      facetCol.length = 0; // iterate over \"size\" facets\n\n      var fi = 0;\n\n      for (var j = f * 3; j < (f + size) * 3; j++) {\n        facetInd.push(fi);\n        var i = meshInd[j];\n        var i3 = i * 3;\n        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\n        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\n\n        if (meshUV) {\n          var i2 = i * 2;\n          facetUV.push(meshUV[i2], meshUV[i2 + 1]);\n        }\n\n        if (meshCol) {\n          var i4 = i * 4;\n          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\n        }\n\n        fi++;\n      } // create a model shape for each single particle\n\n\n      var idx = this.nbParticles;\n\n      var shape = this._posToShape(facetPos);\n\n      var shapeUV = this._uvsToShapeUV(facetUV);\n\n      var shapeInd = Tools.Slice(facetInd);\n      var shapeCol = Tools.Slice(facetCol);\n      var shapeNor = Tools.Slice(facetNor); // compute the barycenter of the shape\n\n      barycenter.copyFromFloats(0, 0, 0);\n      var v = void 0;\n\n      for (v = 0; v < shape.length; v++) {\n        barycenter.addInPlace(shape[v]);\n      }\n\n      barycenter.scaleInPlace(1 / shape.length); // shift the shape from its barycenter to the origin\n      // and compute the BBox required for intersection.\n\n      var minimum = new Vector3(Infinity, Infinity, Infinity);\n      var maximum = new Vector3(-Infinity, -Infinity, -Infinity);\n\n      for (v = 0; v < shape.length; v++) {\n        shape[v].subtractInPlace(barycenter);\n        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n      }\n\n      var bInfo = void 0;\n\n      if (this._particlesIntersect) {\n        bInfo = new BoundingInfo(minimum, maximum);\n      }\n\n      var material = null;\n\n      if (this._useModelMaterial) {\n        material = mesh.material ? mesh.material : this._setDefaultMaterial();\n      }\n\n      var modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material); // add the particle in the SPS\n\n      var currentPos = this._positions.length;\n      var currentInd = this._indices.length;\n\n      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\n\n      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage); // initialize the particle position\n\n\n      this.particles[this.nbParticles].position.addInPlace(barycenter);\n\n      if (!storage) {\n        this._index += shape.length;\n        idx++;\n        this.nbParticles++;\n        this._lastParticleId++;\n      }\n\n      this._shapeCounter++;\n      f += size;\n    }\n\n    this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\n   * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._unrotateFixedNormals = function () {\n    var index = 0;\n    var idx = 0;\n    var tmpNormal = TmpVectors.Vector3[0];\n    var quaternion = TmpVectors.Quaternion[0];\n    var invertedRotMatrix = TmpVectors.Matrix[0];\n\n    for (var p = 0; p < this.particles.length; p++) {\n      var particle = this.particles[p];\n      var shape = particle._model._shape; // computing the inverse of the rotation matrix from the quaternion\n      // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\n\n      if (particle.rotationQuaternion) {\n        particle.rotationQuaternion.conjugateToRef(quaternion);\n      } else {\n        var rotation = particle.rotation;\n        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        quaternion.conjugateInPlace();\n      }\n\n      quaternion.toRotationMatrix(invertedRotMatrix);\n\n      for (var pt = 0; pt < shape.length; pt++) {\n        idx = index + pt * 3;\n        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\n        tmpNormal.toArray(this._fixedNormal32, idx);\n      }\n\n      index = idx + 3;\n    }\n  };\n  /**\n   * Resets the temporary working copy particle\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._resetCopy = function () {\n    var copy = this._copy;\n    copy.position.setAll(0);\n    copy.rotation.setAll(0);\n    copy.rotationQuaternion = null;\n    copy.scaling.setAll(1);\n    copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\n    copy.color = null;\n    copy.translateFromPivot = false;\n    copy.shapeId = 0;\n    copy.materialIndex = null;\n  };\n  /**\n   * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\n   * @param p the current index in the positions array to be updated\n   * @param ind the current index in the indices array\n   * @param shape a Vector3 array, the shape geometry\n   * @param positions the positions array to be updated\n   * @param meshInd the shape indices array\n   * @param indices the indices array to be updated\n   * @param meshUV the shape uv array\n   * @param uvs the uv array to be updated\n   * @param meshCol the shape color array\n   * @param colors the color array to be updated\n   * @param meshNor the shape normals array\n   * @param normals the normals array to be updated\n   * @param idx the particle index\n   * @param idxInShape the particle index in its shape\n   * @param options the addShape() method  passed options\n   * @param model\n   * @model the particle model\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._meshBuilder = function (p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {\n    var i;\n    var u = 0;\n    var c = 0;\n    var n = 0;\n\n    this._resetCopy();\n\n    var copy = this._copy;\n    var storeApart = options && options.storage ? true : false;\n    copy.idx = idx;\n    copy.idxInShape = idxInShape;\n    copy.shapeId = model.shapeId;\n\n    if (this._useModelMaterial) {\n      var materialId = model._material.uniqueId;\n      var materialIndexesById = this._materialIndexesById;\n\n      if (!Object.prototype.hasOwnProperty.call(materialIndexesById, materialId)) {\n        materialIndexesById[materialId] = this._materials.length;\n\n        this._materials.push(model._material);\n      }\n\n      var matIdx = materialIndexesById[materialId];\n      copy.materialIndex = matIdx;\n    }\n\n    if (options && options.positionFunction) {\n      // call to custom positionFunction\n      options.positionFunction(copy, idx, idxInShape);\n      this._mustUnrotateFixedNormals = true;\n    } // in case the particle geometry must NOT be inserted in the SPS mesh geometry\n\n\n    if (storeApart) {\n      return copy;\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv;\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    Matrix.IdentityToRef(rotMatrix);\n    copy.getRotationMatrix(rotMatrix);\n    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.setAll(0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var someVertexFunction = options && options.vertexFunction;\n\n    for (i = 0; i < shape.length; i++) {\n      tmpVector.copyFrom(shape[i]);\n\n      if (copy.color) {\n        tmpColor.copyFrom(copy.color);\n      }\n\n      if (meshUV) {\n        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\n      }\n\n      if (someVertexFunction) {\n        options.vertexFunction(copy, tmpVertex, i);\n      }\n\n      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\n      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\n\n      if (meshUV) {\n        var copyUvs = copy.uvs;\n        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\n        u += 2;\n      }\n\n      if (copy.color) {\n        this._color.copyFrom(tmpColor);\n      } else {\n        var color = this._color;\n\n        if (meshCol && meshCol[c] !== undefined) {\n          color.r = meshCol[c];\n          color.g = meshCol[c + 1];\n          color.b = meshCol[c + 2];\n          color.a = meshCol[c + 3];\n        } else {\n          color.r = 1.0;\n          color.g = 1.0;\n          color.b = 1.0;\n          color.a = 1.0;\n        }\n      }\n\n      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n      c += 4;\n\n      if (!this.recomputeNormals && meshNor) {\n        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\n        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\n        n += 3;\n      }\n    }\n\n    for (i = 0; i < meshInd.length; i++) {\n      var current_ind = p + meshInd[i];\n      indices.push(current_ind);\n\n      if (current_ind > 65535) {\n        this._needs32Bits = true;\n      }\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      var matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\n      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\n    }\n\n    return copy;\n  };\n  /**\n   * Returns a shape Vector3 array from positions float array\n   * @param positions float array\n   * @returns a vector3 array\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._posToShape = function (positions) {\n    var shape = [];\n\n    for (var i = 0; i < positions.length; i += 3) {\n      shape.push(Vector3.FromArray(positions, i));\n    }\n\n    return shape;\n  };\n  /**\n   * Returns a shapeUV array from a float uvs (array deep copy)\n   * @param uvs as a float array\n   * @returns a shapeUV array\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._uvsToShapeUV = function (uvs) {\n    var shapeUV = [];\n\n    if (uvs) {\n      for (var i = 0; i < uvs.length; i++) {\n        shapeUV.push(uvs[i]);\n      }\n    }\n\n    return shapeUV;\n  };\n  /**\n   * Adds a new particle object in the particles array\n   * @param idx particle index in particles array\n   * @param id particle id\n   * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\n   * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\n   * @param model particle ModelShape object\n   * @param shapeId model shape identifier\n   * @param idxInShape index of the particle in the current model\n   * @param bInfo model bounding info object\n   * @param storage target storage array, if any\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._addParticle = function (idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo, storage) {\n    if (bInfo === void 0) {\n      bInfo = null;\n    }\n\n    if (storage === void 0) {\n      storage = null;\n    }\n\n    var sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\n    var target = storage ? storage : this.particles;\n    target.push(sp);\n    return sp;\n  };\n  /**\n   * Adds some particles to the SPS from the model shape. Returns the shape id.\n   * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps\n   * @param mesh is any Mesh object that will be used as a model for the solid particles.\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\n   * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n   * @param options.positionFunction\n   * @param options.vertexFunction\n   * @param options.storage\n   * @returns the number of shapes in the system\n   */\n\n\n  SolidParticleSystem.prototype.addShape = function (mesh, nb, options) {\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    this.recomputeNormals = meshNor ? false : true;\n    var indices = Tools.SliceToArray(meshInd);\n    var shapeNormals = Tools.SliceToArray(meshNor);\n    var shapeColors = meshCol ? Tools.SliceToArray(meshCol) : [];\n    var storage = options && options.storage ? options.storage : null;\n    var bbInfo = null;\n\n    if (this._particlesIntersect) {\n      bbInfo = mesh.getBoundingInfo();\n    }\n\n    var shape = this._posToShape(meshPos);\n\n    var shapeUV = this._uvsToShapeUV(meshUV);\n\n    var posfunc = options ? options.positionFunction : null;\n    var vtxfunc = options ? options.vertexFunction : null;\n    var material = null;\n\n    if (this._useModelMaterial) {\n      material = mesh.material ? mesh.material : this._setDefaultMaterial();\n    }\n\n    var modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material); // particles\n\n    for (var i = 0; i < nb; i++) {\n      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\n    }\n\n    this._shapeCounter++;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this._shapeCounter - 1;\n  };\n  /**\n   * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\n   * @param particle\n   * @param reset\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._rebuildParticle = function (particle, reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    this._resetCopy();\n\n    var copy = this._copy;\n\n    if (particle._model._positionFunction) {\n      // recall to stored custom positionFunction\n      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = TmpVectors.Vector3[0];\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    copy.getRotationMatrix(rotMatrix);\n    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var shape = particle._model._shape;\n\n    for (var pt = 0; pt < shape.length; pt++) {\n      tmpVertex.copyFrom(shape[pt]);\n\n      if (particle._model._vertexFunction) {\n        particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\n\n      }\n\n      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\n    }\n\n    if (reset) {\n      particle.position.setAll(0.0);\n      particle.rotation.setAll(0.0);\n      particle.rotationQuaternion = null;\n      particle.scaling.setAll(1.0);\n      particle.uvs.setAll(0.0);\n      particle.pivot.setAll(0.0);\n      particle.translateFromPivot = false;\n      particle.parentId = null;\n    }\n  };\n  /**\n   * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\n   * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\n   * @returns the SPS.\n   */\n\n\n  SolidParticleSystem.prototype.rebuildMesh = function (reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    for (var p = 0; p < this.particles.length; p++) {\n      this._rebuildParticle(this.particles[p], reset);\n    }\n\n    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\n    return this;\n  };\n  /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\n   *  Returns an array with the removed particles.\n   *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\n   *  The SPS can't be empty so at least one particle needs to remain in place.\n   *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\n   * @param start index of the first particle to remove\n   * @param end index of the last particle to remove (included)\n   * @returns an array populated with the removed particles\n   */\n\n\n  SolidParticleSystem.prototype.removeParticles = function (start, end) {\n    var nb = end - start + 1;\n\n    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\n      return [];\n    }\n\n    var particles = this.particles;\n    var currentNb = this.nbParticles;\n\n    if (end < currentNb - 1) {\n      // update the particle indexes in the positions array in case they're remaining particles after the last removed\n      var firstRemaining = end + 1;\n      var shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\n      var shifInd = particles[firstRemaining]._ind - particles[start]._ind;\n\n      for (var i = firstRemaining; i < currentNb; i++) {\n        var part = particles[i];\n        part._pos -= shiftPos;\n        part._ind -= shifInd;\n      }\n    }\n\n    var removed = particles.splice(start, nb);\n    this._positions.length = 0;\n    this._indices.length = 0;\n    this._colors.length = 0;\n    this._uvs.length = 0;\n    this._normals.length = 0;\n    this._index = 0;\n    this._idxOfId.length = 0;\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    var ind = 0;\n    var particlesLength = particles.length;\n\n    for (var p = 0; p < particlesLength; p++) {\n      var particle = particles[p];\n      var model = particle._model;\n      var shape = model._shape;\n      var modelIndices = model._indices;\n      var modelNormals = model._normals;\n      var modelColors = model._shapeColors;\n      var modelUVs = model._shapeUV;\n      particle.idx = p;\n      this._idxOfId[particle.id] = p;\n\n      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\n\n      this._index += shape.length;\n      ind += modelIndices.length;\n    }\n\n    this.nbParticles -= nb;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return removed;\n  };\n  /**\n   * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\n   * @param solidParticleArray an array populated with Solid Particles objects\n   * @returns the SPS\n   */\n\n\n  SolidParticleSystem.prototype.insertParticlesFromArray = function (solidParticleArray) {\n    if (!this._expandable) {\n      return this;\n    }\n\n    var idxInShape = 0;\n    var currentShapeId = solidParticleArray[0].shapeId;\n    var nb = solidParticleArray.length;\n\n    for (var i = 0; i < nb; i++) {\n      var sp = solidParticleArray[i];\n      var model = sp._model;\n      var shape = model._shape;\n      var meshInd = model._indices;\n      var meshUV = model._shapeUV;\n      var meshCol = model._shapeColors;\n      var meshNor = model._normals;\n      var noNor = meshNor ? false : true;\n      this.recomputeNormals = noNor || this.recomputeNormals;\n      var bbInfo = sp.getBoundingInfo();\n\n      var newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\n\n      sp.copyToRef(newPart);\n      idxInShape++;\n\n      if (currentShapeId != sp.shapeId) {\n        currentShapeId = sp.shapeId;\n        idxInShape = 0;\n      }\n    }\n\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\n   * Creates a new particle and modifies the SPS mesh geometry :\n   * - calls _meshBuilder() to increase the SPS mesh geometry step by step\n   * - calls _addParticle() to populate the particle array\n   * factorized code from addShape() and insertParticlesFromArray()\n   * @param idx particle index in the particles array\n   * @param i particle index in its shape\n   * @param modelShape particle ModelShape object\n   * @param shape shape vertex array\n   * @param meshInd shape indices array\n   * @param meshUV shape uv array\n   * @param meshCol shape color array\n   * @param meshNor shape normals array\n   * @param bbInfo shape bounding info\n   * @param storage target particle storage\n   * @param options\n   * @options addShape() passed options\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._insertNewParticle = function (idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {\n    var currentPos = this._positions.length;\n    var currentInd = this._indices.length;\n\n    var currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\n\n    var sp = null;\n\n    if (this._updatable) {\n      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\n      sp.position.copyFrom(currentCopy.position);\n      sp.rotation.copyFrom(currentCopy.rotation);\n\n      if (currentCopy.rotationQuaternion) {\n        if (sp.rotationQuaternion) {\n          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n        } else {\n          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\n        }\n      }\n\n      if (currentCopy.color) {\n        if (sp.color) {\n          sp.color.copyFrom(currentCopy.color);\n        } else {\n          sp.color = currentCopy.color.clone();\n        }\n      }\n\n      sp.scaling.copyFrom(currentCopy.scaling);\n      sp.uvs.copyFrom(currentCopy.uvs);\n\n      if (currentCopy.materialIndex !== null) {\n        sp.materialIndex = currentCopy.materialIndex;\n      }\n\n      if (this.expandable) {\n        this._idxOfId[sp.id] = sp.idx;\n      }\n    }\n\n    if (!storage) {\n      this._index += shape.length;\n      this.nbParticles++;\n      this._lastParticleId++;\n    }\n\n    return sp;\n  };\n  /**\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n   *  This method calls `updateParticle()` for each particle of the SPS.\n   *  For an animated SPS, it is usually called within the render loop.\n   * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n   * @returns the SPS.\n   */\n\n\n  SolidParticleSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || this._isNotBuilt) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var invertedMatrix = TmpVectors.Matrix[1];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var normals32 = this._normals32;\n    var uvs32 = this._uvs32;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var fixedNormal32 = this._fixedNormal32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    var camInvertedPosition = tempVectors[10].setAll(0);\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv; // cases when the World Matrix is to be computed first\n\n    if (this.billboard || this._depthSort) {\n      this.mesh.computeWorldMatrix(true);\n\n      this.mesh._worldMatrix.invertToRef(invertedMatrix);\n    } // if the particles will always face the camera\n\n\n    if (this.billboard) {\n      // compute the camera position and un-rotate it by the current mesh rotation\n      var tmpVector0 = tempVectors[0];\n\n      this._camera.getDirectionToRef(Axis.Z, tmpVector0);\n\n      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\n      camAxisZ.normalize(); // same for camera up vector extracted from the cam view matrix\n\n      var view = this._camera.getViewMatrix(true);\n\n      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\n      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\n      camAxisY.normalize();\n      camAxisX.normalize();\n    } // if depthSort, compute the camera global position in the mesh local system\n\n\n    if (this._depthSort) {\n      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\n    }\n\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current position index in the global array positions32\n\n    var index = 0; // position start index in the global array positions32 of the current particle\n\n    var colidx = 0; // current color index in the global array colors32\n\n    var colorIndex = 0; // color start index in the global array colors32 of the current particle\n\n    var uvidx = 0; // current uv index in the global array uvs32\n\n    var uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n\n    var pt = 0; // current index in the particle model shape\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    } // particle loop\n\n\n    index = this.particles[start]._pos;\n    var vpos = index / 3 | 0;\n    colorIndex = vpos * 4;\n    uvIndex = vpos * 2;\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p]; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var shape = particle._model._shape;\n      var shapeUV = particle._model._shapeUV;\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleRotation = particle.rotation;\n      var particleScaling = particle.scaling;\n      var particleGlobalPosition = particle._globalPosition; // camera-particle distance for depth sorting\n\n      if (this._depthSort && this._depthSortParticles) {\n        var dsp = this.depthSortedParticles[p];\n        dsp.idx = particle.idx;\n        dsp.ind = particle._ind;\n        dsp.indicesLength = particle._model._indicesLength;\n        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\n      } // skip the computations for inactive or already invisible particles\n\n\n      if (!particle.alive || particle._stillInvisible && !particle.isVisible) {\n        // increment indexes for the next particle\n        pt = shape.length;\n        index += pt * 3;\n        colorIndex += pt * 4;\n        uvIndex += pt * 2;\n        continue;\n      }\n\n      if (particle.isVisible) {\n        particle._stillInvisible = false; // un-mark permanent invisibility\n\n        var scaledPivot = tempVectors[12];\n        particle.pivot.multiplyToRef(particleScaling, scaledPivot); // particle rotation matrix\n\n        if (this.billboard) {\n          particleRotation.x = 0.0;\n          particleRotation.y = 0.0;\n        }\n\n        if (this._computeParticleRotation || this.billboard) {\n          particle.getRotationMatrix(rotMatrix);\n        }\n\n        var particleHasParent = particle.parentId !== null;\n\n        if (particleHasParent) {\n          var parent_1 = this.getParticleById(particle.parentId);\n\n          if (parent_1) {\n            var parentRotationMatrix = parent_1._rotationMatrix;\n            var parentGlobalPosition = parent_1._globalPosition;\n            var rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n            var rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n            var rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n\n            if (this._computeParticleRotation || this.billboard) {\n              var rotMatrixValues = rotMatrix.m;\n              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n            }\n          } else {\n            // in case the parent were removed at some moment\n            particle.parentId = null;\n          }\n        } else {\n          particleGlobalPosition.x = particlePosition.x;\n          particleGlobalPosition.y = particlePosition.y;\n          particleGlobalPosition.z = particlePosition.z;\n\n          if (this._computeParticleRotation || this.billboard) {\n            var rotMatrixValues = rotMatrix.m;\n            particleRotationMatrix[0] = rotMatrixValues[0];\n            particleRotationMatrix[1] = rotMatrixValues[1];\n            particleRotationMatrix[2] = rotMatrixValues[2];\n            particleRotationMatrix[3] = rotMatrixValues[4];\n            particleRotationMatrix[4] = rotMatrixValues[5];\n            particleRotationMatrix[5] = rotMatrixValues[6];\n            particleRotationMatrix[6] = rotMatrixValues[8];\n            particleRotationMatrix[7] = rotMatrixValues[9];\n            particleRotationMatrix[8] = rotMatrixValues[10];\n          }\n        }\n\n        var pivotBackTranslation = tempVectors[11];\n\n        if (particle.translateFromPivot) {\n          pivotBackTranslation.setAll(0.0);\n        } else {\n          pivotBackTranslation.copyFrom(scaledPivot);\n        } // particle vertex loop\n\n\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          var iu = 2 * pt;\n          var iv = iu + 1;\n          tmpVector.copyFrom(shape[pt]);\n\n          if (this._computeParticleColor && particle.color) {\n            tmpColor.copyFrom(particle.color);\n          }\n\n          if (this._computeParticleTexture) {\n            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\n          }\n\n          if (this._computeParticleVertex) {\n            this.updateParticleVertex(particle, tmpVertex, pt);\n          } // positions\n\n\n          var vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\n          var vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\n          var vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\n          var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n          var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n          var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n          rotatedX += pivotBackTranslation.x;\n          rotatedY += pivotBackTranslation.y;\n          rotatedZ += pivotBackTranslation.z;\n          var px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n          var py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n          var pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n          if (this._computeBoundingBox) {\n            minimum.minimizeInPlaceFromFloats(px, py, pz);\n            maximum.maximizeInPlaceFromFloats(px, py, pz);\n          } // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n\n\n          if (!this._computeParticleVertex) {\n            var normalx = fixedNormal32[idx];\n            var normaly = fixedNormal32[idx + 1];\n            var normalz = fixedNormal32[idx + 2];\n            var rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\n            var rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\n            var rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\n            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\n            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\n            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\n          }\n\n          if (this._computeParticleColor && particle.color) {\n            var colors32_1 = this._colors32;\n            colors32_1[colidx] = tmpColor.r;\n            colors32_1[colidx + 1] = tmpColor.g;\n            colors32_1[colidx + 2] = tmpColor.b;\n            colors32_1[colidx + 3] = tmpColor.a;\n          }\n\n          if (this._computeParticleTexture) {\n            var uvs = particle.uvs;\n            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      } // particle just set invisible : scaled to zero and positioned at the origin\n      else {\n        particle._stillInvisible = true; // mark the particle as invisible\n\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\n          normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\n\n          if (this._computeParticleColor && particle.color) {\n            var color = particle.color;\n            colors32[colidx] = color.r;\n            colors32[colidx + 1] = color.g;\n            colors32[colidx + 2] = color.b;\n            colors32[colidx + 3] = color.a;\n          }\n\n          if (this._computeParticleTexture) {\n            var uvs = particle.uvs;\n            uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      } // if the particle intersections must be computed : update the bbInfo\n\n\n      if (this._particlesIntersect) {\n        var bInfo = particle.getBoundingInfo();\n        var bBox = bInfo.boundingBox;\n        var bSphere = bInfo.boundingSphere;\n        var modelBoundingInfo = particle._modelBoundingInfo;\n\n        if (!this._bSphereOnly) {\n          // place, scale and rotate the particle bbox within the SPS local system, then update it\n          var modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\n          var tempMin = tempVectors[1];\n          var tempMax = tempVectors[2];\n          tempMin.setAll(Number.MAX_VALUE);\n          tempMax.setAll(-Number.MAX_VALUE);\n\n          for (var b = 0; b < 8; b++) {\n            var scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\n            var scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\n            var scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\n            var rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\n            var rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\n            var rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\n            var x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n            var y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n            var z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n            tempMin.minimizeInPlaceFromFloats(x, y, z);\n            tempMax.maximizeInPlaceFromFloats(x, y, z);\n          }\n\n          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\n        } // place and scale the particle bouding sphere in the SPS local system, then update it\n\n\n        var minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\n        var maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\n        var bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\n        var halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\n        var bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\n        var bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\n        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\n      } // increment indexes for the next particle\n\n\n      index = idx + 3;\n      colorIndex = colidx + 4;\n      uvIndex = uvidx + 2;\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        var vb = mesh.getVertexBuffer(VertexBuffer.ColorKind);\n\n        if (vb && !mesh.isPickable) {\n          vb.updateDirectly(colors32, 0);\n        } else {\n          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n        }\n      }\n\n      if (this._computeParticleTexture) {\n        var vb = mesh.getVertexBuffer(VertexBuffer.UVKind);\n\n        if (vb && !mesh.isPickable) {\n          vb.updateDirectly(uvs32, 0);\n        } else {\n          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n        }\n      }\n\n      var vbp = mesh.getVertexBuffer(VertexBuffer.PositionKind);\n\n      if (vbp && !mesh.isPickable) {\n        vbp.updateDirectly(positions32, 0);\n      } else {\n        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n      }\n\n      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\n        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\n          // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n          var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\n          VertexData.ComputeNormals(positions32, indices32, normals32, params);\n\n          for (var i = 0; i < normals32.length; i++) {\n            fixedNormal32[i] = normals32[i];\n          }\n        }\n\n        if (!mesh.areNormalsFrozen) {\n          var vb = mesh.getVertexBuffer(VertexBuffer.NormalKind);\n\n          if (vb && !mesh.isPickable) {\n            vb.updateDirectly(normals32, 0);\n          } else {\n            mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\n          }\n        }\n      }\n\n      if (this._depthSort && this._depthSortParticles) {\n        var depthSortedParticles = this.depthSortedParticles;\n        depthSortedParticles.sort(this._depthSortFunction);\n        var dspl = depthSortedParticles.length;\n        var sid = 0;\n        var faceId = 0;\n\n        for (var sorted = 0; sorted < dspl; sorted++) {\n          var sortedParticle = depthSortedParticles[sorted];\n          var lind = sortedParticle.indicesLength;\n          var sind = sortedParticle.ind;\n\n          for (var i = 0; i < lind; i++) {\n            indices32[sid] = indices[sind + i];\n            sid++;\n\n            if (this._pickable) {\n              var f = i % 3;\n\n              if (f == 0) {\n                var pickedData = this.pickedParticles[faceId];\n                pickedData.idx = sortedParticle.idx;\n                pickedData.faceId = faceId;\n                faceId++;\n              }\n            }\n          }\n        }\n\n        mesh.updateIndices(indices32);\n      }\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh.hasBoundingInfo) {\n        mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    if (this._autoUpdateSubMeshes) {\n      this.computeSubMeshes();\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\n   * Disposes the SPS.\n   */\n\n\n  SolidParticleSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._normals32 = null;\n    this._fixedNormal32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n    this.pickedParticles = null;\n    this.pickedBySubMesh = null;\n    this._materials = null;\n    this._materialIndexes = null;\n    this._indicesByMaterial = null;\n    this._idxOfId = null;\n  };\n  /** Returns an object {idx: number faceId: number} for the picked particle from the passed pickingInfo object.\n   * idx is the particle index in the SPS\n   * faceId is the picked face index counted within this particle.\n   * Returns null if the pickInfo can't identify a picked particle.\n   * @param pickingInfo (PickingInfo object)\n   * @returns {idx: number, faceId: number} or null\n   */\n\n\n  SolidParticleSystem.prototype.pickedParticle = function (pickingInfo) {\n    if (pickingInfo.hit) {\n      var subMesh = pickingInfo.subMeshId;\n      var faceId = pickingInfo.faceId - this.mesh.subMeshes[subMesh].indexStart / 3;\n      var picked = this.pickedBySubMesh;\n\n      if (picked[subMesh] && picked[subMesh][faceId]) {\n        return picked[subMesh][faceId];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Returns a SolidParticle object from its identifier : particle.id\n   * @param id (integer) the particle Id\n   * @returns the searched particle or null if not found in the SPS.\n   */\n\n\n  SolidParticleSystem.prototype.getParticleById = function (id) {\n    var p = this.particles[id];\n\n    if (p && p.id == id) {\n      return p;\n    }\n\n    var particles = this.particles;\n    var idx = this._idxOfId[id];\n\n    if (idx !== undefined) {\n      return particles[idx];\n    }\n\n    var i = 0;\n    var nb = this.nbParticles;\n\n    while (i < nb) {\n      var particle = particles[i];\n\n      if (particle.id == id) {\n        return particle;\n      }\n\n      i++;\n    }\n\n    return null;\n  };\n  /**\n   * Returns a new array populated with the particles having the passed shapeId.\n   * @param shapeId (integer) the shape identifier\n   * @returns a new solid particle array\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeId = function (shapeId) {\n    var ref = [];\n    this.getParticlesByShapeIdToRef(shapeId, ref);\n    return ref;\n  };\n  /**\n   * Populates the passed array \"ref\" with the particles having the passed shapeId.\n   * @param shapeId the shape identifier\n   * @returns the SPS\n   * @param ref\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeIdToRef = function (shapeId, ref) {\n    ref.length = 0;\n\n    for (var i = 0; i < this.nbParticles; i++) {\n      var p = this.particles[i];\n\n      if (p.shapeId == shapeId) {\n        ref.push(p);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Computes the required SubMeshes according the materials assigned to the particles.\n   * @returns the solid particle system.\n   * Does nothing if called before the SPS mesh is built.\n   */\n\n\n  SolidParticleSystem.prototype.computeSubMeshes = function () {\n    if (!this.mesh || !this._multimaterialEnabled) {\n      return this;\n    }\n\n    var depthSortedParticles = this.depthSortedParticles;\n\n    if (this.particles.length > 0) {\n      for (var p = 0; p < this.particles.length; p++) {\n        var part = this.particles[p];\n\n        if (!part.materialIndex) {\n          part.materialIndex = 0;\n        }\n\n        var sortedPart = depthSortedParticles[p];\n        sortedPart.materialIndex = part.materialIndex;\n        sortedPart.ind = part._ind;\n        sortedPart.indicesLength = part._model._indicesLength;\n        sortedPart.idx = part.idx;\n      }\n    }\n\n    this._sortParticlesByMaterial();\n\n    var indicesByMaterial = this._indicesByMaterial;\n    var materialIndexes = this._materialIndexes;\n    var mesh = this.mesh;\n    mesh.subMeshes = [];\n    var vcount = mesh.getTotalVertices();\n\n    for (var m = 0; m < materialIndexes.length; m++) {\n      var start = indicesByMaterial[m];\n      var count = indicesByMaterial[m + 1] - start;\n      var matIndex = materialIndexes[m];\n      new SubMesh(matIndex, 0, vcount, start, count, mesh);\n    }\n\n    return this;\n  };\n  /**\n   * Sorts the solid particles by material when MultiMaterial is enabled.\n   * Updates the indices32 array.\n   * Updates the indicesByMaterial array.\n   * Updates the mesh indices array.\n   * @returns the SPS\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._sortParticlesByMaterial = function () {\n    var indicesByMaterial = [0];\n    this._indicesByMaterial = indicesByMaterial;\n    var materialIndexes = [];\n    this._materialIndexes = materialIndexes;\n    var depthSortedParticles = this.depthSortedParticles;\n    depthSortedParticles.sort(this._materialSortFunction);\n    var length = depthSortedParticles.length;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var subMeshIndex = 0;\n    var subMeshFaceId = 0;\n    var sid = 0;\n    var lastMatIndex = depthSortedParticles[0].materialIndex;\n    materialIndexes.push(lastMatIndex);\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    for (var sorted = 0; sorted < length; sorted++) {\n      var sortedPart = depthSortedParticles[sorted];\n      var lind = sortedPart.indicesLength;\n      var sind = sortedPart.ind;\n\n      if (sortedPart.materialIndex !== lastMatIndex) {\n        lastMatIndex = sortedPart.materialIndex;\n        indicesByMaterial.push(sid);\n        materialIndexes.push(lastMatIndex);\n\n        if (this._pickable) {\n          subMeshIndex++;\n          this.pickedBySubMesh[subMeshIndex] = [];\n          subMeshFaceId = 0;\n        }\n      }\n\n      var faceId = 0;\n\n      for (var i = 0; i < lind; i++) {\n        indices32[sid] = indices[sind + i];\n\n        if (this._pickable) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\n\n            if (pickedData) {\n              pickedData.idx = sortedPart.idx;\n              pickedData.faceId = faceId;\n            } else {\n              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = {\n                idx: sortedPart.idx,\n                faceId: faceId\n              };\n            }\n\n            subMeshFaceId++;\n            faceId++;\n          }\n        }\n\n        sid++;\n      }\n    }\n\n    indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\n\n    if (this._updatable) {\n      this.mesh.updateIndices(indices32);\n    }\n\n    return this;\n  };\n  /**\n   * Sets the material indexes by id materialIndexesById[id] = materialIndex\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._setMaterialIndexesById = function () {\n    this._materialIndexesById = {};\n\n    for (var i = 0; i < this._materials.length; i++) {\n      var id = this._materials[i].uniqueId;\n      this._materialIndexesById[id] = i;\n    }\n  };\n  /**\n   * Returns an array with unique values of Materials from the passed array\n   * @param array the material array to be checked and filtered\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._filterUniqueMaterialId = function (array) {\n    var filtered = array.filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    });\n    return filtered;\n  };\n  /**\n   * Sets a new Standard Material as _defaultMaterial if not already set.\n   * @hidden\n   */\n\n\n  SolidParticleSystem.prototype._setDefaultMaterial = function () {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\n    }\n\n    return this._defaultMaterial;\n  };\n  /**\n   * Visibility helper : Recomputes the visible size according to the mesh bounding box\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n   * @returns the SPS.\n   */\n\n\n  SolidParticleSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n   * @param size the size (float) of the visibility box\n   * note : this doesn't lock the SPS mesh bounding box.\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n   */\n\n\n  SolidParticleSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"isAlwaysVisible\", {\n    /**\n     * Gets whether the SPS as always visible or not\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n     */\n    get: function get() {\n      return this._alwaysVisible;\n    },\n\n    /**\n     * Sets the SPS as always visible or not\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n     */\n    set: function set(val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"isVisibilityBoxLocked\", {\n    /**\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n     */\n    get: function get() {\n      return this._isVisibilityBoxLocked;\n    },\n\n    /**\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\n     */\n    set: function set(val) {\n      this._isVisibilityBoxLocked = val;\n      var boundingInfo = this.mesh.getBoundingInfo();\n      boundingInfo.isLocked = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleRotation\", {\n    /**\n     * Gets if `setParticles()` computes the particle rotations or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n     */\n    get: function get() {\n      return this._computeParticleRotation;\n    },\n\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n     */\n    set: function set(val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleColor\", {\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get: function get() {\n      return this._computeParticleColor;\n    },\n\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set: function set(val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleTexture\", {\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get: function get() {\n      return this._computeParticleTexture;\n    },\n    set: function set(val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleVertex\", {\n    /**\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\n     * Default value : false. The SPS is faster when it's set to false.\n     * Note : the particle custom vertex positions aren't stored values.\n     */\n    get: function get() {\n      return this._computeParticleVertex;\n    },\n\n    /**\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\n     * Default value : false. The SPS is faster when it's set to false.\n     * Note : the particle custom vertex positions aren't stored values.\n     */\n    set: function set(val) {\n      this._computeParticleVertex = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeBoundingBox\", {\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get: function get() {\n      return this._computeBoundingBox;\n    },\n\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set: function set(val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"depthSortParticles\", {\n    /**\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n     * Default : `true`\n     */\n    get: function get() {\n      return this._depthSortParticles;\n    },\n\n    /**\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n     * Default : `true`\n     */\n    set: function set(val) {\n      this._depthSortParticles = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"expandable\", {\n    /**\n     * Gets if the SPS is created as expandable at construction time.\n     * Default : `false`\n     */\n    get: function get() {\n      return this._expandable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterialEnabled\", {\n    /**\n     * Gets if the SPS supports the Multi Materials\n     */\n    get: function get() {\n      return this._multimaterialEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"useModelMaterial\", {\n    /**\n     * Gets if the SPS uses the model materials for its own multimaterial.\n     */\n    get: function get() {\n      return this._useModelMaterial;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"materials\", {\n    /**\n     * The SPS used material array.\n     */\n    get: function get() {\n      return this._materials;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the SPS MultiMaterial from the passed materials.\n   * Note : the passed array is internally copied and not used then by reference.\n   * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\n   */\n\n  SolidParticleSystem.prototype.setMultiMaterial = function (materials) {\n    this._materials = this._filterUniqueMaterialId(materials);\n\n    this._setMaterialIndexesById();\n\n    if (this._multimaterial) {\n      this._multimaterial.dispose();\n    }\n\n    this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n\n    for (var m = 0; m < this._materials.length; m++) {\n      this._multimaterial.subMaterials.push(this._materials[m]);\n    }\n\n    this.computeSubMeshes();\n    this.mesh.material = this._multimaterial;\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterial\", {\n    /**\n     * The SPS computed multimaterial object\n     */\n    get: function get() {\n      return this._multimaterial;\n    },\n    set: function set(mm) {\n      this._multimaterial = mm;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"autoUpdateSubMeshes\", {\n    /**\n     * If the subMeshes must be updated on the next call to setParticles()\n     */\n    get: function get() {\n      return this._autoUpdateSubMeshes;\n    },\n    set: function set(val) {\n      this._autoUpdateSubMeshes = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by the user to fit his needs\n\n  /**\n   * This function does nothing. It may be overwritten to set all the particle first values.\n   * The SPS doesn't call this function, you may have to call it by your own.\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\n   */\n\n  SolidParticleSystem.prototype.initParticles = function () {};\n  /**\n   * This function does nothing. It may be overwritten to recycle a particle.\n   * The SPS doesn't call this function, you may have to call it by your own.\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\n   * @param particle The particle to recycle\n   * @returns the recycled particle\n   */\n\n\n  SolidParticleSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\n   * Updates a particle : this function should  be overwritten by the user.\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\n   * @example : just set a particle position or velocity and recycle conditions\n   * @param particle The particle to update\n   * @returns the updated particle\n   */\n\n\n  SolidParticleSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\n   * Updates a vertex of a particle : it can be overwritten by the user.\n   * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\n   * @param particle the current particle\n   * @param vertex the current vertex of the current particle : a SolidParticleVertex object\n   * @param pt the index of the current vertex in the particle shape\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape\n   * @example : just set a vertex particle position or color\n   * @returns the sps\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  SolidParticleSystem.prototype.updateParticleVertex = function (particle, vertex, pt) {\n    return this;\n  };\n  /**\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  SolidParticleSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n   * This will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  SolidParticleSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return SolidParticleSystem;\n}();\n\nexport { SolidParticleSystem };","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","TmpVectors","Quaternion","Color4","VertexBuffer","VertexData","Mesh","CreateDisc","EngineStore","DepthSortedParticle","SolidParticle","ModelShape","SolidParticleVertex","BoundingInfo","Axis","SubMesh","StandardMaterial","MultiMaterial","Tools","name","scene","options","Array","p1","p2","sqDistance","materialIndex","_scene","LastCreatedScene","_camera","activeCamera","_pickable","isPickable","_depthSort","enableDepthSort","_multimaterialEnabled","enableMultiMaterial","_useModelMaterial","useModelMaterial","_expandable","expandable","_particlesIntersect","particleIntersection","_bSphereOnly","boundingSphereOnly","_bSphereRadiusFactor","bSphereRadiusFactor","updatable","undefined","_updatable","pickedBySubMesh","pickedParticles","depthSortedParticles","_multimaterial","_materials","_materialIndexesById","_tmpVertex","SolidParticleSystem","_isNotBuilt","mesh","nbParticles","triangle","radius","tessellation","addShape","dispose","_indices32","_needs32Bits","Uint32Array","_indices","Uint16Array","_positions32","Float32Array","_positions","_uvs32","_uvs","_colors32","_colors","_sortParticlesByMaterial","recomputeNormals","ComputeNormals","_normals","_normals32","_fixedNormal32","_mustUnrotateFixedNormals","_unrotateFixedNormals","vertexData","indices","set","PositionKind","NormalKind","length","UVKind","ColorKind","applyToMesh","faceId","p","part","particles","lind","_model","_indicesLength","i","f","pickedData","idx","setMultiMaterial","size","facetNb","number","delta","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","meshNor","storage","totalFacets","Math","round","facetPos","facetNor","facetInd","facetUV","facetCol","barycenter","Zero","sizeO","floor","random","fi","j","push","i3","i2","i4","shape","_posToShape","shapeUV","_uvsToShapeUV","shapeInd","Slice","shapeCol","shapeNor","copyFromFloats","v","addInPlace","scaleInPlace","minimum","Infinity","maximum","subtractInPlace","minimizeInPlaceFromFloats","x","y","z","maximizeInPlaceFromFloats","bInfo","material","_setDefaultMaterial","modelShape","_shapeCounter","currentPos","currentInd","_meshBuilder","_index","_addParticle","_lastParticleId","position","index","tmpNormal","quaternion","invertedRotMatrix","particle","_shape","rotationQuaternion","conjugateToRef","rotation","RotationYawPitchRollToRef","conjugateInPlace","toRotationMatrix","pt","TransformNormalFromFloatsToRef","toArray","copy","_copy","setAll","scaling","uvs","color","translateFromPivot","shapeId","ind","positions","colors","normals","idxInShape","model","u","c","n","_resetCopy","storeApart","materialId","_material","uniqueId","materialIndexesById","Object","prototype","hasOwnProperty","call","matIdx","positionFunction","rotMatrix","tmpVertex","tmpVector","tmpColor","tmpUV","uv","tmpRotated","pivotBackTranslation","scaledPivot","IdentityToRef","getRotationMatrix","pivot","multiplyToRef","copyFrom","someVertexFunction","vertexFunction","multiplyInPlace","TransformCoordinatesToRef","copyUvs","w","_color","r","g","b","a","current_ind","matIndex","FromArray","id","idxpos","idxind","sp","target","nb","SliceToArray","shapeNormals","shapeColors","bbInfo","getBoundingInfo","posfunc","vtxfunc","_insertNewParticle","reset","_positionFunction","_vertexFunction","_pos","parentId","_rebuildParticle","updateVerticesData","start","end","currentNb","firstRemaining","shiftPos","shifInd","_ind","removed","splice","_idxOfId","particlesLength","modelIndices","modelNormals","modelColors","_shapeColors","modelUVs","_shapeUV","solidParticleArray","currentShapeId","noNor","newPart","copyToRef","currentCopy","clone","update","beforeUpdateParticles","invertedMatrix","colors32","positions32","normals32","uvs32","indices32","fixedNormal32","tempVectors","camAxisX","camAxisY","camAxisZ","Number","MAX_VALUE","camInvertedPosition","billboard","computeWorldMatrix","_worldMatrix","invertToRef","tmpVector0","getDirectionToRef","Z","TransformNormalToRef","normalize","view","getViewMatrix","m","CrossToRef","globalPosition","colidx","colorIndex","uvidx","uvIndex","isFacetDataEnabled","_computeBoundingBox","boundingInfo","vpos","updateParticle","particleRotationMatrix","_rotationMatrix","particlePosition","particleRotation","particleScaling","particleGlobalPosition","_globalPosition","_depthSortParticles","dsp","indicesLength","DistanceSquared","alive","_stillInvisible","isVisible","_computeParticleRotation","particleHasParent","parent_1","getParticleById","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","iu","iv","_computeParticleColor","_computeParticleTexture","_computeParticleVertex","updateParticleVertex","vertexX","vertexY","vertexZ","px","py","pz","normalx","normaly","normalz","rotatedx","rotatedy","rotatedz","colors32_1","bBox","boundingBox","bSphere","boundingSphere","modelBoundingInfo","_modelBoundingInfo","modelBoundingInfoVectors","vectors","tempMin","tempMax","scaledX","scaledY","scaledZ","reConstruct","minBbox","maxBbox","bSphereCenter","addToRef","halfDiag","subtractToRef","bSphereMinBbox","bSphereMaxBbox","vb","getVertexBuffer","updateDirectly","vbp","areNormalsFrozen","params","getFacetDataParameters","sort","_depthSortFunction","dspl","sid","sorted","sortedParticle","sind","updateIndices","hasBoundingInfo","buildBoundingInfo","_autoUpdateSubMeshes","computeSubMeshes","afterUpdateParticles","vars","_materialIndexes","_indicesByMaterial","pickingInfo","hit","subMesh","subMeshId","subMeshes","indexStart","picked","ref","getParticlesByShapeIdToRef","sortedPart","indicesByMaterial","materialIndexes","vcount","getTotalVertices","count","_materialSortFunction","subMeshIndex","subMeshFaceId","lastMatIndex","array","filtered","filter","value","self","indexOf","_defaultMaterial","_isVisibilityBoxLocked","refreshBoundingInfo","vis","_alwaysVisible","val","alwaysSelectAsActiveMesh","isLocked","materials","_filterUniqueMaterialId","_setMaterialIndexesById","subMaterials","mm","vertex","stop"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/solidParticleSystem.ts"],"sourcesContent":["import type { Nullable, IndicesArray, FloatArray } from \"../types\";\r\nimport { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateDisc } from \"../Meshes/Builders/discBuilder\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\r\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The SPS is also a particle system. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System\r\n */\r\nexport class SolidParticleSystem implements IDisposable {\r\n    /**\r\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: SolidParticle[] = new Array<SolidParticle>();\r\n    /**\r\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * If the particles must ever face the camera (default false). Useful for planar particles.\r\n     */\r\n    public billboard: boolean = false;\r\n    /**\r\n     * Recompute normals when adding a shape\r\n     */\r\n    public recomputeNormals: boolean = false;\r\n    /**\r\n     * This a counter ofr your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The SPS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are available.\r\n     */\r\n    public mesh: Mesh;\r\n    /**\r\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * This array is populated when the SPS is set as 'pickable'.\r\n     * Each key of this array is a `faceId` value that you can get from a pickResult object.\r\n     * Each element of this array is an object `{idx: int, faceId: int}`.\r\n     * `idx` is the picked particle index in the `SPS.particles` array\r\n     * `faceId` is the picked face index counted within this particle.\r\n     * This array is the first element of the pickedBySubMesh array : sps.pickBySubMesh[0].\r\n     * It's not pertinent to use it when using a SPS with the support for MultiMaterial enabled.\r\n     * Use the method SPS.pickedParticle(pickingInfo) instead.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles\r\n     */\r\n    public pickedParticles: { idx: number; faceId: number }[];\r\n    /**\r\n     * This array is populated when the SPS is set as 'pickable'\r\n     * Each key of this array is a submesh index.\r\n     * Each element of this array is a second array defined like this :\r\n     * Each key of this second array is a `faceId` value that you can get from a pickResult object.\r\n     * Each element of this second array is an object `{idx: int, faceId: int}`.\r\n     * `idx` is the picked particle index in the `SPS.particles` array\r\n     * `faceId` is the picked face index counted within this particle.\r\n     * It's better to use the method SPS.pickedParticle(pickingInfo) rather than using directly this array.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles\r\n     */\r\n    public pickedBySubMesh: { idx: number; faceId: number }[][];\r\n    /**\r\n     * This array is populated when `enableDepthSort` is set to true.\r\n     * Each element of this array is an instance of the class DepthSortedParticle.\r\n     */\r\n    public depthSortedParticles: DepthSortedParticle[];\r\n\r\n    /**\r\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereOnly: boolean = false;\r\n    /**\r\n     * A number to multiply the bounding sphere radius by in order to reduce it for instance. (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereRadiusFactor: number = 1.0;\r\n\r\n    private _scene: Scene;\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray; // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array; // updated positions for the VBO\r\n    private _normals32: Float32Array; // updated normals for the VBO\r\n    private _fixedNormal32: Float32Array; // initial normal references\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _index: number = 0; // indices index\r\n    private _updatable: boolean = true;\r\n    private _pickable: boolean = false;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _depthSort: boolean = false;\r\n    private _expandable: boolean = false;\r\n    private _shapeCounter: number = 0;\r\n    private _copy: SolidParticle = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\r\n    private _color: Color4 = new Color4(0, 0, 0, 0);\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeParticleVertex: boolean = false;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _depthSortParticles: boolean = true;\r\n    private _camera: TargetCamera;\r\n    private _mustUnrotateFixedNormals = false;\r\n    private _particlesIntersect: boolean = false;\r\n    private _needs32Bits: boolean = false;\r\n    private _isNotBuilt: boolean = true;\r\n    private _lastParticleId: number = 0;\r\n    private _idxOfId: number[] = []; // array : key = particle.id / value = particle.idx\r\n    private _multimaterialEnabled: boolean = false;\r\n    private _useModelMaterial: boolean = false;\r\n    private _indicesByMaterial: number[];\r\n    private _materialIndexes: number[];\r\n    private _depthSortFunction = (p1: DepthSortedParticle, p2: DepthSortedParticle) => p2.sqDistance - p1.sqDistance;\r\n    private _materialSortFunction = (p1: DepthSortedParticle, p2: DepthSortedParticle) => p1.materialIndex - p2.materialIndex;\r\n    private _materials: Material[];\r\n    private _multimaterial: MultiMaterial;\r\n    private _materialIndexesById: any;\r\n    private _defaultMaterial: Material;\r\n    private _autoUpdateSubMeshes: boolean = false;\r\n    private _tmpVertex: SolidParticleVertex;\r\n\r\n    /**\r\n     * Creates a SPS (Solid Particle System) object.\r\n     * @param name (String) is the SPS name, this will be the underlying mesh name.\r\n     * @param scene (Scene) is the scene in which the SPS is added.\r\n     * @param options defines the options of the sps e.g.\r\n     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\r\n     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\r\n     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\r\n     * * useModelMaterial (optional boolean, default false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\r\n     * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\r\n     * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\r\n     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\r\n     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\r\n     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the bounding sphere radius by in order to reduce it for instance.\r\n     * @param options.updatable\r\n     * @param options.isPickable\r\n     * @param options.enableDepthSort\r\n     * @param options.particleIntersection\r\n     * @param options.boundingSphereOnly\r\n     * @param options.bSphereRadiusFactor\r\n     * @param options.expandable\r\n     * @param options.useModelMaterial\r\n     * @param options.enableMultiMaterial\r\n     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options?: {\r\n            updatable?: boolean;\r\n            isPickable?: boolean;\r\n            enableDepthSort?: boolean;\r\n            particleIntersection?: boolean;\r\n            boundingSphereOnly?: boolean;\r\n            bSphereRadiusFactor?: number;\r\n            expandable?: boolean;\r\n            useModelMaterial?: boolean;\r\n            enableMultiMaterial?: boolean;\r\n        }\r\n    ) {\r\n        this.name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._camera = <TargetCamera>scene.activeCamera;\r\n        this._pickable = options ? <boolean>options.isPickable : false;\r\n        this._depthSort = options ? <boolean>options.enableDepthSort : false;\r\n        this._multimaterialEnabled = options ? <boolean>options.enableMultiMaterial : false;\r\n        this._useModelMaterial = options ? <boolean>options.useModelMaterial : false;\r\n        this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\r\n        this._expandable = options ? <boolean>options.expandable : false;\r\n        this._particlesIntersect = options ? <boolean>options.particleIntersection : false;\r\n        this._bSphereOnly = options ? <boolean>options.boundingSphereOnly : false;\r\n        this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n        if (this._pickable) {\r\n            this.pickedBySubMesh = [[]];\r\n            this.pickedParticles = this.pickedBySubMesh[0];\r\n        }\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            this.depthSortedParticles = [];\r\n        }\r\n        if (this._multimaterialEnabled) {\r\n            this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\r\n            this._materials = [];\r\n            this._materialIndexesById = {};\r\n        }\r\n        this._tmpVertex = new SolidParticleVertex();\r\n    }\r\n\r\n    /**\r\n     * Builds the SPS underlying mesh. Returns a standard Mesh.\r\n     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\r\n     * @returns the created mesh\r\n     */\r\n    public buildMesh(): Mesh {\r\n        if (!this._isNotBuilt && this.mesh) {\r\n            return this.mesh;\r\n        }\r\n        if (this.nbParticles === 0 && !this.mesh) {\r\n            const triangle = CreateDisc(\"\", { radius: 1, tessellation: 3 }, this._scene);\r\n            this.addShape(triangle, 1);\r\n            triangle.dispose();\r\n        }\r\n        this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        if (!this.mesh) {\r\n            // in case it's already expanded\r\n            const mesh = new Mesh(this.name, this._scene);\r\n            this.mesh = mesh;\r\n        }\r\n        if (!this._updatable && this._multimaterialEnabled) {\r\n            this._sortParticlesByMaterial(); // this may reorder the indices32\r\n        }\r\n        if (this.recomputeNormals) {\r\n            VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\r\n        }\r\n\r\n        this._normals32 = new Float32Array(this._normals);\r\n        this._fixedNormal32 = new Float32Array(this._normals);\r\n        if (this._mustUnrotateFixedNormals) {\r\n            // the particles could be created already rotated in the mesh with a positionFunction\r\n            this._unrotateFixedNormals();\r\n        }\r\n        const vertexData = new VertexData();\r\n        vertexData.indices = this._depthSort ? this._indices : this._indices32;\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n        vertexData.set(this._normals32, VertexBuffer.NormalKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        if (this._colors32.length > 0) {\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n\r\n        vertexData.applyToMesh(this.mesh, this._updatable);\r\n        this.mesh.isPickable = this._pickable;\r\n\r\n        if (this._pickable) {\r\n            let faceId = 0;\r\n            for (let p = 0; p < this.nbParticles; p++) {\r\n                const part = this.particles[p];\r\n                const lind = part._model._indicesLength;\r\n                for (let i = 0; i < lind; i++) {\r\n                    const f = i % 3;\r\n                    if (f == 0) {\r\n                        const pickedData = { idx: part.idx, faceId: faceId };\r\n                        this.pickedParticles[faceId] = pickedData;\r\n                        faceId++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._multimaterialEnabled) {\r\n            this.setMultiMaterial(this._materials);\r\n        }\r\n\r\n        if (!this._expandable) {\r\n            // free memory\r\n            if (!this._depthSort && !this._multimaterialEnabled) {\r\n                (<any>this._indices) = null;\r\n            }\r\n            (<any>this._positions) = null;\r\n            (<any>this._normals) = null;\r\n            (<any>this._uvs) = null;\r\n            (<any>this._colors) = null;\r\n\r\n            if (!this._updatable) {\r\n                this.particles.length = 0;\r\n            }\r\n        }\r\n        this._isNotBuilt = false;\r\n        this.recomputeNormals = false;\r\n        return this.mesh;\r\n    }\r\n\r\n    /**\r\n     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\r\n     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\r\n     * Thus the particles generated from `digest()` have their property `position` set yet.\r\n     * @param mesh ( Mesh ) is the mesh to be digested\r\n     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overridden by the parameter `number` if any\r\n     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\r\n     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\r\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n     * @param options.facetNb\r\n     * @param options.number\r\n     * @param options.delta\r\n     * @param options.storage\r\n     * @returns the current SPS\r\n     */\r\n    public digest(mesh: Mesh, options?: { facetNb?: number; number?: number; delta?: number; storage?: [] }): SolidParticleSystem {\r\n        let size: number = (options && options.facetNb) || 1;\r\n        let number: number = (options && options.number) || 0;\r\n        let delta: number = (options && options.delta) || 0;\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        const meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const storage = options && options.storage ? options.storage : null;\r\n\r\n        let f: number = 0; // facet counter\r\n        const totalFacets: number = meshInd.length / 3; // a facet is a triangle, so 3 indices\r\n        // compute size from number\r\n        if (number) {\r\n            number = number > totalFacets ? totalFacets : number;\r\n            size = Math.round(totalFacets / number);\r\n            delta = 0;\r\n        } else {\r\n            size = size > totalFacets ? totalFacets : size;\r\n        }\r\n\r\n        const facetPos: number[] = []; // submesh positions\r\n        const facetNor: number[] = [];\r\n        const facetInd: number[] = []; // submesh indices\r\n        const facetUV: number[] = []; // submesh UV\r\n        const facetCol: number[] = []; // submesh colors\r\n        const barycenter: Vector3 = Vector3.Zero();\r\n        const sizeO: number = size;\r\n\r\n        while (f < totalFacets) {\r\n            size = sizeO + Math.floor((1 + delta) * Math.random());\r\n            if (f > totalFacets - size) {\r\n                size = totalFacets - f;\r\n            }\r\n            // reset temp arrays\r\n            facetPos.length = 0;\r\n            facetNor.length = 0;\r\n            facetInd.length = 0;\r\n            facetUV.length = 0;\r\n            facetCol.length = 0;\r\n\r\n            // iterate over \"size\" facets\r\n            let fi: number = 0;\r\n            for (let j = f * 3; j < (f + size) * 3; j++) {\r\n                facetInd.push(fi);\r\n                const i: number = meshInd[j];\r\n                const i3: number = i * 3;\r\n                facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\r\n                facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\r\n                if (meshUV) {\r\n                    const i2: number = i * 2;\r\n                    facetUV.push(meshUV[i2], meshUV[i2 + 1]);\r\n                }\r\n                if (meshCol) {\r\n                    const i4: number = i * 4;\r\n                    facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\r\n                }\r\n                fi++;\r\n            }\r\n\r\n            // create a model shape for each single particle\r\n            let idx: number = this.nbParticles;\r\n            const shape: Vector3[] = this._posToShape(facetPos);\r\n            const shapeUV: number[] = this._uvsToShapeUV(facetUV);\r\n            const shapeInd = Tools.Slice(facetInd);\r\n            const shapeCol = Tools.Slice(facetCol);\r\n            const shapeNor = Tools.Slice(facetNor);\r\n\r\n            // compute the barycenter of the shape\r\n            barycenter.copyFromFloats(0, 0, 0);\r\n            let v: number;\r\n            for (v = 0; v < shape.length; v++) {\r\n                barycenter.addInPlace(shape[v]);\r\n            }\r\n            barycenter.scaleInPlace(1 / shape.length);\r\n\r\n            // shift the shape from its barycenter to the origin\r\n            // and compute the BBox required for intersection.\r\n            const minimum: Vector3 = new Vector3(Infinity, Infinity, Infinity);\r\n            const maximum: Vector3 = new Vector3(-Infinity, -Infinity, -Infinity);\r\n            for (v = 0; v < shape.length; v++) {\r\n                shape[v].subtractInPlace(barycenter);\r\n                minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\r\n                maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\r\n            }\r\n            let bInfo;\r\n            if (this._particlesIntersect) {\r\n                bInfo = new BoundingInfo(minimum, maximum);\r\n            }\r\n            let material = null;\r\n            if (this._useModelMaterial) {\r\n                material = mesh.material ? mesh.material : this._setDefaultMaterial();\r\n            }\r\n            const modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);\r\n\r\n            // add the particle in the SPS\r\n            const currentPos = this._positions.length;\r\n            const currentInd = this._indices.length;\r\n            this._meshBuilder(\r\n                this._index,\r\n                currentInd,\r\n                shape,\r\n                this._positions,\r\n                shapeInd,\r\n                this._indices,\r\n                facetUV,\r\n                this._uvs,\r\n                shapeCol,\r\n                this._colors,\r\n                shapeNor,\r\n                this._normals,\r\n                idx,\r\n                0,\r\n                null,\r\n                modelShape\r\n            );\r\n            this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);\r\n            // initialize the particle position\r\n            this.particles[this.nbParticles].position.addInPlace(barycenter);\r\n\r\n            if (!storage) {\r\n                this._index += shape.length;\r\n                idx++;\r\n                this.nbParticles++;\r\n                this._lastParticleId++;\r\n            }\r\n            this._shapeCounter++;\r\n            f += size;\r\n        }\r\n        this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\r\n     * @hidden\r\n     */\r\n    private _unrotateFixedNormals() {\r\n        let index = 0;\r\n        let idx = 0;\r\n        const tmpNormal = TmpVectors.Vector3[0];\r\n        const quaternion = TmpVectors.Quaternion[0];\r\n        const invertedRotMatrix = TmpVectors.Matrix[0];\r\n        for (let p = 0; p < this.particles.length; p++) {\r\n            const particle = this.particles[p];\r\n            const shape = particle._model._shape;\r\n\r\n            // computing the inverse of the rotation matrix from the quaternion\r\n            // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\r\n            if (particle.rotationQuaternion) {\r\n                particle.rotationQuaternion.conjugateToRef(quaternion);\r\n            } else {\r\n                const rotation = particle.rotation;\r\n                Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n                quaternion.conjugateInPlace();\r\n            }\r\n            quaternion.toRotationMatrix(invertedRotMatrix);\r\n\r\n            for (let pt = 0; pt < shape.length; pt++) {\r\n                idx = index + pt * 3;\r\n                Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\r\n                tmpNormal.toArray(this._fixedNormal32, idx);\r\n            }\r\n            index = idx + 3;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the temporary working copy particle\r\n     * @hidden\r\n     */\r\n    private _resetCopy() {\r\n        const copy = this._copy;\r\n        copy.position.setAll(0);\r\n        copy.rotation.setAll(0);\r\n        copy.rotationQuaternion = null;\r\n        copy.scaling.setAll(1);\r\n        copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\r\n        copy.color = null;\r\n        copy.translateFromPivot = false;\r\n        copy.shapeId = 0;\r\n        copy.materialIndex = null;\r\n    }\r\n\r\n    /**\r\n     * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\r\n     * @param p the current index in the positions array to be updated\r\n     * @param ind the current index in the indices array\r\n     * @param shape a Vector3 array, the shape geometry\r\n     * @param positions the positions array to be updated\r\n     * @param meshInd the shape indices array\r\n     * @param indices the indices array to be updated\r\n     * @param meshUV the shape uv array\r\n     * @param uvs the uv array to be updated\r\n     * @param meshCol the shape color array\r\n     * @param colors the color array to be updated\r\n     * @param meshNor the shape normals array\r\n     * @param normals the normals array to be updated\r\n     * @param idx the particle index\r\n     * @param idxInShape the particle index in its shape\r\n     * @param options the addShape() method  passed options\r\n     * @param model\r\n     * @model the particle model\r\n     * @hidden\r\n     */\r\n    private _meshBuilder(\r\n        p: number,\r\n        ind: number,\r\n        shape: Vector3[],\r\n        positions: number[],\r\n        meshInd: IndicesArray,\r\n        indices: number[],\r\n        meshUV: number[] | Float32Array,\r\n        uvs: number[],\r\n        meshCol: number[] | Float32Array,\r\n        colors: number[],\r\n        meshNor: number[] | Float32Array,\r\n        normals: number[],\r\n        idx: number,\r\n        idxInShape: number,\r\n        options: any,\r\n        model: ModelShape\r\n    ): SolidParticle {\r\n        let i;\r\n        let u = 0;\r\n        let c = 0;\r\n        let n = 0;\r\n\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        const storeApart = options && options.storage ? true : false;\r\n        copy.idx = idx;\r\n        copy.idxInShape = idxInShape;\r\n        copy.shapeId = model.shapeId;\r\n        if (this._useModelMaterial) {\r\n            const materialId = model._material!.uniqueId;\r\n            const materialIndexesById = this._materialIndexesById;\r\n            if (!Object.prototype.hasOwnProperty.call(materialIndexesById, materialId)) {\r\n                materialIndexesById[materialId] = this._materials.length;\r\n                this._materials.push(model._material!);\r\n            }\r\n            const matIdx = materialIndexesById[materialId];\r\n            copy.materialIndex = matIdx;\r\n        }\r\n\r\n        if (options && options.positionFunction) {\r\n            // call to custom positionFunction\r\n            options.positionFunction(copy, idx, idxInShape);\r\n            this._mustUnrotateFixedNormals = true;\r\n        }\r\n\r\n        // in case the particle geometry must NOT be inserted in the SPS mesh geometry\r\n        if (storeApart) {\r\n            return copy;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const tmpVertex = this._tmpVertex;\r\n        const tmpVector = tmpVertex.position;\r\n        const tmpColor = tmpVertex.color;\r\n        const tmpUV = tmpVertex.uv;\r\n        const tmpRotated = TmpVectors.Vector3[1];\r\n        const pivotBackTranslation = TmpVectors.Vector3[2];\r\n        const scaledPivot = TmpVectors.Vector3[3];\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.setAll(0.0);\r\n        } else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        const someVertexFunction = options && options.vertexFunction;\r\n        for (i = 0; i < shape.length; i++) {\r\n            tmpVector.copyFrom(shape[i]);\r\n            if (copy.color) {\r\n                tmpColor.copyFrom(copy.color);\r\n            }\r\n            if (meshUV) {\r\n                tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\r\n            }\r\n            if (someVertexFunction) {\r\n                options.vertexFunction(copy, tmpVertex, i);\r\n            }\r\n\r\n            tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\r\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\r\n            positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\r\n\r\n            if (meshUV) {\r\n                const copyUvs = copy.uvs;\r\n                uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\r\n                u += 2;\r\n            }\r\n\r\n            if (copy.color) {\r\n                this._color.copyFrom(tmpColor);\r\n            } else {\r\n                const color = this._color;\r\n                if (meshCol && meshCol[c] !== undefined) {\r\n                    color.r = meshCol[c];\r\n                    color.g = meshCol[c + 1];\r\n                    color.b = meshCol[c + 2];\r\n                    color.a = meshCol[c + 3];\r\n                } else {\r\n                    color.r = 1.0;\r\n                    color.g = 1.0;\r\n                    color.b = 1.0;\r\n                    color.a = 1.0;\r\n                }\r\n            }\r\n            colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\r\n            c += 4;\r\n\r\n            if (!this.recomputeNormals && meshNor) {\r\n                Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\r\n                normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\r\n                n += 3;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < meshInd.length; i++) {\r\n            const current_ind = p + meshInd[i];\r\n            indices.push(current_ind);\r\n            if (current_ind > 65535) {\r\n                this._needs32Bits = true;\r\n            }\r\n        }\r\n\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            const matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\r\n            this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Returns a shape Vector3 array from positions float array\r\n     * @param positions float array\r\n     * @returns a vector3 array\r\n     * @hidden\r\n     */\r\n    private _posToShape(positions: number[] | Float32Array): Vector3[] {\r\n        const shape = [];\r\n        for (let i = 0; i < positions.length; i += 3) {\r\n            shape.push(Vector3.FromArray(positions, i));\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    /**\r\n     * Returns a shapeUV array from a float uvs (array deep copy)\r\n     * @param uvs as a float array\r\n     * @returns a shapeUV array\r\n     * @hidden\r\n     */\r\n    private _uvsToShapeUV(uvs: number[] | Float32Array): number[] {\r\n        const shapeUV = [];\r\n        if (uvs) {\r\n            for (let i = 0; i < uvs.length; i++) {\r\n                shapeUV.push(uvs[i]);\r\n            }\r\n        }\r\n        return shapeUV;\r\n    }\r\n\r\n    /**\r\n     * Adds a new particle object in the particles array\r\n     * @param idx particle index in particles array\r\n     * @param id particle id\r\n     * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\r\n     * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\r\n     * @param model particle ModelShape object\r\n     * @param shapeId model shape identifier\r\n     * @param idxInShape index of the particle in the current model\r\n     * @param bInfo model bounding info object\r\n     * @param storage target storage array, if any\r\n     * @hidden\r\n     */\r\n    private _addParticle(\r\n        idx: number,\r\n        id: number,\r\n        idxpos: number,\r\n        idxind: number,\r\n        model: ModelShape,\r\n        shapeId: number,\r\n        idxInShape: number,\r\n        bInfo: Nullable<BoundingInfo> = null,\r\n        storage: Nullable<[]> = null\r\n    ): SolidParticle {\r\n        const sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\r\n        const target = storage ? storage : this.particles;\r\n        target.push(sp);\r\n        return sp;\r\n    }\r\n\r\n    /**\r\n     * Adds some particles to the SPS from the model shape. Returns the shape id.\r\n     * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps\r\n     * @param mesh is any Mesh object that will be used as a model for the solid particles.\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\r\n     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\r\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n     * @param options.positionFunction\r\n     * @param options.vertexFunction\r\n     * @param options.storage\r\n     * @returns the number of shapes in the system\r\n     */\r\n    public addShape(mesh: Mesh, nb: number, options?: { positionFunction?: any; vertexFunction?: any; storage?: [] }): number {\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        const meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        this.recomputeNormals = meshNor ? false : true;\r\n        const indices = Tools.SliceToArray<IndicesArray, number>(meshInd);\r\n        const shapeNormals = Tools.SliceToArray<number[] | Float32Array, number>(meshNor);\r\n        const shapeColors = meshCol ? Tools.SliceToArray<number[] | Float32Array, number>(meshCol) : [];\r\n        const storage = options && options.storage ? options.storage : null;\r\n        let bbInfo: Nullable<BoundingInfo> = null;\r\n        if (this._particlesIntersect) {\r\n            bbInfo = mesh.getBoundingInfo();\r\n        }\r\n\r\n        const shape = this._posToShape(meshPos);\r\n        const shapeUV = this._uvsToShapeUV(meshUV);\r\n\r\n        const posfunc = options ? options.positionFunction : null;\r\n        const vtxfunc = options ? options.vertexFunction : null;\r\n        let material = null;\r\n        if (this._useModelMaterial) {\r\n            material = mesh.material ? mesh.material : this._setDefaultMaterial();\r\n        }\r\n        const modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);\r\n\r\n        // particles\r\n        for (let i = 0; i < nb; i++) {\r\n            this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\r\n        }\r\n        this._shapeCounter++;\r\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\r\n        return this._shapeCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\r\n     * @param particle\r\n     * @param reset\r\n     * @hidden\r\n     */\r\n    private _rebuildParticle(particle: SolidParticle, reset: boolean = false): void {\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        if (particle._model._positionFunction) {\r\n            // recall to stored custom positionFunction\r\n            particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const tmpVertex = TmpVectors.Vector3[0];\r\n        const tmpRotated = TmpVectors.Vector3[1];\r\n        const pivotBackTranslation = TmpVectors.Vector3[2];\r\n        const scaledPivot = TmpVectors.Vector3[3];\r\n\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\r\n        } else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        const shape = particle._model._shape;\r\n\r\n        for (let pt = 0; pt < shape.length; pt++) {\r\n            tmpVertex.copyFrom(shape[pt]);\r\n            if (particle._model._vertexFunction) {\r\n                particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\r\n            }\r\n\r\n            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\r\n            tmpRotated\r\n                .addInPlace(pivotBackTranslation)\r\n                .addInPlace(copy.position)\r\n                .toArray(this._positions32, particle._pos + pt * 3);\r\n        }\r\n        if (reset) {\r\n            particle.position.setAll(0.0);\r\n            particle.rotation.setAll(0.0);\r\n            particle.rotationQuaternion = null;\r\n            particle.scaling.setAll(1.0);\r\n            particle.uvs.setAll(0.0);\r\n            particle.pivot.setAll(0.0);\r\n            particle.translateFromPivot = false;\r\n            particle.parentId = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\r\n     * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\r\n     * @returns the SPS.\r\n     */\r\n    public rebuildMesh(reset: boolean = false): SolidParticleSystem {\r\n        for (let p = 0; p < this.particles.length; p++) {\r\n            this._rebuildParticle(this.particles[p], reset);\r\n        }\r\n        this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\r\n        return this;\r\n    }\r\n\r\n    /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\r\n     *  Returns an array with the removed particles.\r\n     *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\r\n     *  The SPS can't be empty so at least one particle needs to remain in place.\r\n     *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\r\n     * @param start index of the first particle to remove\r\n     * @param end index of the last particle to remove (included)\r\n     * @returns an array populated with the removed particles\r\n     */\r\n    public removeParticles(start: number, end: number): SolidParticle[] {\r\n        const nb = end - start + 1;\r\n        if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\r\n            return [];\r\n        }\r\n        const particles = this.particles;\r\n        const currentNb = this.nbParticles;\r\n        if (end < currentNb - 1) {\r\n            // update the particle indexes in the positions array in case they're remaining particles after the last removed\r\n            const firstRemaining = end + 1;\r\n            const shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\r\n            const shifInd = particles[firstRemaining]._ind - particles[start]._ind;\r\n            for (let i = firstRemaining; i < currentNb; i++) {\r\n                const part = particles[i];\r\n                part._pos -= shiftPos;\r\n                part._ind -= shifInd;\r\n            }\r\n        }\r\n        const removed = particles.splice(start, nb);\r\n        this._positions.length = 0;\r\n        this._indices.length = 0;\r\n        this._colors.length = 0;\r\n        this._uvs.length = 0;\r\n        this._normals.length = 0;\r\n        this._index = 0;\r\n        this._idxOfId.length = 0;\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            this.depthSortedParticles = [];\r\n        }\r\n        let ind = 0;\r\n        const particlesLength = particles.length;\r\n        for (let p = 0; p < particlesLength; p++) {\r\n            const particle = particles[p];\r\n            const model = particle._model;\r\n            const shape = model._shape;\r\n            const modelIndices = model._indices;\r\n            const modelNormals = model._normals;\r\n            const modelColors = model._shapeColors;\r\n            const modelUVs = model._shapeUV;\r\n            particle.idx = p;\r\n            this._idxOfId[particle.id] = p;\r\n            this._meshBuilder(\r\n                this._index,\r\n                ind,\r\n                shape,\r\n                this._positions,\r\n                modelIndices,\r\n                this._indices,\r\n                modelUVs,\r\n                this._uvs,\r\n                modelColors,\r\n                this._colors,\r\n                modelNormals,\r\n                this._normals,\r\n                particle.idx,\r\n                particle.idxInShape,\r\n                null,\r\n                model\r\n            );\r\n            this._index += shape.length;\r\n            ind += modelIndices.length;\r\n        }\r\n        this.nbParticles -= nb;\r\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\r\n     * @param solidParticleArray an array populated with Solid Particles objects\r\n     * @returns the SPS\r\n     */\r\n    public insertParticlesFromArray(solidParticleArray: SolidParticle[]): SolidParticleSystem {\r\n        if (!this._expandable) {\r\n            return this;\r\n        }\r\n        let idxInShape = 0;\r\n        let currentShapeId = solidParticleArray[0].shapeId;\r\n        const nb = solidParticleArray.length;\r\n        for (let i = 0; i < nb; i++) {\r\n            const sp = solidParticleArray[i];\r\n            const model = sp._model;\r\n            const shape = model._shape;\r\n            const meshInd = model._indices;\r\n            const meshUV = model._shapeUV;\r\n            const meshCol = model._shapeColors;\r\n            const meshNor = model._normals;\r\n            const noNor = meshNor ? false : true;\r\n            this.recomputeNormals = noNor || this.recomputeNormals;\r\n            const bbInfo = sp.getBoundingInfo();\r\n            const newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\r\n            sp.copyToRef(newPart!);\r\n            idxInShape++;\r\n            if (currentShapeId != sp.shapeId) {\r\n                currentShapeId = sp.shapeId;\r\n                idxInShape = 0;\r\n            }\r\n        }\r\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new particle and modifies the SPS mesh geometry :\r\n     * - calls _meshBuilder() to increase the SPS mesh geometry step by step\r\n     * - calls _addParticle() to populate the particle array\r\n     * factorized code from addShape() and insertParticlesFromArray()\r\n     * @param idx particle index in the particles array\r\n     * @param i particle index in its shape\r\n     * @param modelShape particle ModelShape object\r\n     * @param shape shape vertex array\r\n     * @param meshInd shape indices array\r\n     * @param meshUV shape uv array\r\n     * @param meshCol shape color array\r\n     * @param meshNor shape normals array\r\n     * @param bbInfo shape bounding info\r\n     * @param storage target particle storage\r\n     * @param options\r\n     * @options addShape() passed options\r\n     * @hidden\r\n     */\r\n    private _insertNewParticle(\r\n        idx: number,\r\n        i: number,\r\n        modelShape: ModelShape,\r\n        shape: Vector3[],\r\n        meshInd: IndicesArray,\r\n        meshUV: number[] | Float32Array,\r\n        meshCol: number[] | Float32Array,\r\n        meshNor: number[] | Float32Array,\r\n        bbInfo: Nullable<BoundingInfo>,\r\n        storage: Nullable<[]>,\r\n        options: any\r\n    ): Nullable<SolidParticle> {\r\n        const currentPos = this._positions.length;\r\n        const currentInd = this._indices.length;\r\n        const currentCopy = this._meshBuilder(\r\n            this._index,\r\n            currentInd,\r\n            shape,\r\n            this._positions,\r\n            meshInd,\r\n            this._indices,\r\n            meshUV,\r\n            this._uvs,\r\n            meshCol,\r\n            this._colors,\r\n            meshNor,\r\n            this._normals,\r\n            idx,\r\n            i,\r\n            options,\r\n            modelShape\r\n        );\r\n        let sp: Nullable<SolidParticle> = null;\r\n        if (this._updatable) {\r\n            sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\r\n            sp.position.copyFrom(currentCopy.position);\r\n            sp.rotation.copyFrom(currentCopy.rotation);\r\n            if (currentCopy.rotationQuaternion) {\r\n                if (sp.rotationQuaternion) {\r\n                    sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\r\n                } else {\r\n                    sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\r\n                }\r\n            }\r\n            if (currentCopy.color) {\r\n                if (sp.color) {\r\n                    sp.color.copyFrom(currentCopy.color);\r\n                } else {\r\n                    sp.color = currentCopy.color.clone();\r\n                }\r\n            }\r\n            sp.scaling.copyFrom(currentCopy.scaling);\r\n            sp.uvs.copyFrom(currentCopy.uvs);\r\n            if (currentCopy.materialIndex !== null) {\r\n                sp.materialIndex = currentCopy.materialIndex;\r\n            }\r\n            if (this.expandable) {\r\n                this._idxOfId[sp.id] = sp.idx;\r\n            }\r\n        }\r\n        if (!storage) {\r\n            this._index += shape.length;\r\n            this.nbParticles++;\r\n            this._lastParticleId++;\r\n        }\r\n        return sp;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the SPS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): SolidParticleSystem {\r\n        if (!this._updatable || this._isNotBuilt) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const invertedMatrix = TmpVectors.Matrix[1];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const normals32 = this._normals32;\r\n        const uvs32 = this._uvs32;\r\n        const indices32 = this._indices32;\r\n        const indices = this._indices;\r\n        const fixedNormal32 = this._fixedNormal32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n        const camInvertedPosition = tempVectors[10].setAll(0);\r\n\r\n        const tmpVertex = this._tmpVertex;\r\n        const tmpVector = tmpVertex.position;\r\n        const tmpColor = tmpVertex.color;\r\n        const tmpUV = tmpVertex.uv;\r\n\r\n        // cases when the World Matrix is to be computed first\r\n        if (this.billboard || this._depthSort) {\r\n            this.mesh.computeWorldMatrix(true);\r\n            this.mesh._worldMatrix.invertToRef(invertedMatrix);\r\n        }\r\n        // if the particles will always face the camera\r\n        if (this.billboard) {\r\n            // compute the camera position and un-rotate it by the current mesh rotation\r\n            const tmpVector0 = tempVectors[0];\r\n            this._camera.getDirectionToRef(Axis.Z, tmpVector0);\r\n            Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\r\n            camAxisZ.normalize();\r\n            // same for camera up vector extracted from the cam view matrix\r\n            const view = this._camera.getViewMatrix(true);\r\n            Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\r\n            Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\r\n            camAxisY.normalize();\r\n            camAxisX.normalize();\r\n        }\r\n\r\n        // if depthSort, compute the camera global position in the mesh local system\r\n        if (this._depthSort) {\r\n            Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\r\n        }\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        let idx = 0; // current position index in the global array positions32\r\n        let index = 0; // position start index in the global array positions32 of the current particle\r\n        let colidx = 0; // current color index in the global array colors32\r\n        let colorIndex = 0; // color start index in the global array colors32 of the current particle\r\n        let uvidx = 0; // current uv index in the global array uvs32\r\n        let uvIndex = 0; // uv start index in the global array uvs32 of the current particle\r\n        let pt = 0; // current index in the particle model shape\r\n\r\n        if (this.mesh.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) {\r\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        // particle loop\r\n        index = this.particles[start]._pos;\r\n        const vpos = (index / 3) | 0;\r\n        colorIndex = vpos * 4;\r\n        uvIndex = vpos * 2;\r\n\r\n        for (let p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const shape = particle._model._shape;\r\n            const shapeUV = particle._model._shapeUV;\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleRotation = particle.rotation;\r\n            const particleScaling = particle.scaling;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            // camera-particle distance for depth sorting\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                const dsp = this.depthSortedParticles[p];\r\n                dsp.idx = particle.idx;\r\n                dsp.ind = particle._ind;\r\n                dsp.indicesLength = particle._model._indicesLength;\r\n                dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\r\n            }\r\n\r\n            // skip the computations for inactive or already invisible particles\r\n            if (!particle.alive || (particle._stillInvisible && !particle.isVisible)) {\r\n                // increment indexes for the next particle\r\n                pt = shape.length;\r\n                index += pt * 3;\r\n                colorIndex += pt * 4;\r\n                uvIndex += pt * 2;\r\n                continue;\r\n            }\r\n\r\n            if (particle.isVisible) {\r\n                particle._stillInvisible = false; // un-mark permanent invisibility\r\n\r\n                const scaledPivot = tempVectors[12];\r\n                particle.pivot.multiplyToRef(particleScaling, scaledPivot);\r\n\r\n                // particle rotation matrix\r\n                if (this.billboard) {\r\n                    particleRotation.x = 0.0;\r\n                    particleRotation.y = 0.0;\r\n                }\r\n                if (this._computeParticleRotation || this.billboard) {\r\n                    particle.getRotationMatrix(rotMatrix);\r\n                }\r\n\r\n                const particleHasParent = particle.parentId !== null;\r\n                if (particleHasParent) {\r\n                    const parent = this.getParticleById(particle.parentId!);\r\n                    if (parent) {\r\n                        const parentRotationMatrix = parent._rotationMatrix;\r\n                        const parentGlobalPosition = parent._globalPosition;\r\n\r\n                        const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                        const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                        const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                        if (this._computeParticleRotation || this.billboard) {\r\n                            const rotMatrixValues = rotMatrix.m;\r\n                            particleRotationMatrix[0] =\r\n                                rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[1] =\r\n                                rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[2] =\r\n                                rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                            particleRotationMatrix[3] =\r\n                                rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[4] =\r\n                                rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[5] =\r\n                                rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                            particleRotationMatrix[6] =\r\n                                rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[7] =\r\n                                rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[8] =\r\n                                rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                        }\r\n                    } else {\r\n                        // in case the parent were removed at some moment\r\n                        particle.parentId = null;\r\n                    }\r\n                } else {\r\n                    particleGlobalPosition.x = particlePosition.x;\r\n                    particleGlobalPosition.y = particlePosition.y;\r\n                    particleGlobalPosition.z = particlePosition.z;\r\n\r\n                    if (this._computeParticleRotation || this.billboard) {\r\n                        const rotMatrixValues = rotMatrix.m;\r\n                        particleRotationMatrix[0] = rotMatrixValues[0];\r\n                        particleRotationMatrix[1] = rotMatrixValues[1];\r\n                        particleRotationMatrix[2] = rotMatrixValues[2];\r\n                        particleRotationMatrix[3] = rotMatrixValues[4];\r\n                        particleRotationMatrix[4] = rotMatrixValues[5];\r\n                        particleRotationMatrix[5] = rotMatrixValues[6];\r\n                        particleRotationMatrix[6] = rotMatrixValues[8];\r\n                        particleRotationMatrix[7] = rotMatrixValues[9];\r\n                        particleRotationMatrix[8] = rotMatrixValues[10];\r\n                    }\r\n                }\r\n\r\n                const pivotBackTranslation = tempVectors[11];\r\n                if (particle.translateFromPivot) {\r\n                    pivotBackTranslation.setAll(0.0);\r\n                } else {\r\n                    pivotBackTranslation.copyFrom(scaledPivot);\r\n                }\r\n\r\n                // particle vertex loop\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n                    const iu = 2 * pt;\r\n                    const iv = iu + 1;\r\n\r\n                    tmpVector.copyFrom(shape[pt]);\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        tmpColor.copyFrom(particle.color);\r\n                    }\r\n                    if (this._computeParticleTexture) {\r\n                        tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\r\n                    }\r\n                    if (this._computeParticleVertex) {\r\n                        this.updateParticleVertex(particle, tmpVertex, pt);\r\n                    }\r\n\r\n                    // positions\r\n                    const vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\r\n                    const vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\r\n                    const vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\r\n\r\n                    let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n                    let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n                    let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n                    rotatedX += pivotBackTranslation.x;\r\n                    rotatedY += pivotBackTranslation.y;\r\n                    rotatedZ += pivotBackTranslation.z;\r\n\r\n                    const px = (positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\r\n                    const py = (positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\r\n                    const pz = (positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\r\n\r\n                    if (this._computeBoundingBox) {\r\n                        minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                        maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n                    }\r\n\r\n                    // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\r\n                    if (!this._computeParticleVertex) {\r\n                        const normalx = fixedNormal32[idx];\r\n                        const normaly = fixedNormal32[idx + 1];\r\n                        const normalz = fixedNormal32[idx + 2];\r\n\r\n                        const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\r\n                        const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\r\n                        const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\r\n\r\n                        normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\r\n                        normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\r\n                        normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\r\n                    }\r\n\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const colors32 = this._colors32;\r\n                        colors32[colidx] = tmpColor.r;\r\n                        colors32[colidx + 1] = tmpColor.g;\r\n                        colors32[colidx + 2] = tmpColor.b;\r\n                        colors32[colidx + 3] = tmpColor.a;\r\n                    }\r\n\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n            // particle just set invisible : scaled to zero and positioned at the origin\r\n            else {\r\n                particle._stillInvisible = true; // mark the particle as invisible\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n\r\n                    positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\r\n                    normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const color = particle.color;\r\n                        colors32[colidx] = color.r;\r\n                        colors32[colidx + 1] = color.g;\r\n                        colors32[colidx + 2] = color.b;\r\n                        colors32[colidx + 3] = color.a;\r\n                    }\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if the particle intersections must be computed : update the bbInfo\r\n            if (this._particlesIntersect) {\r\n                const bInfo = particle.getBoundingInfo();\r\n                const bBox = bInfo.boundingBox;\r\n                const bSphere = bInfo.boundingSphere;\r\n                const modelBoundingInfo = particle._modelBoundingInfo;\r\n                if (!this._bSphereOnly) {\r\n                    // place, scale and rotate the particle bbox within the SPS local system, then update it\r\n                    const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\r\n\r\n                    const tempMin = tempVectors[1];\r\n                    const tempMax = tempVectors[2];\r\n                    tempMin.setAll(Number.MAX_VALUE);\r\n                    tempMax.setAll(-Number.MAX_VALUE);\r\n                    for (let b = 0; b < 8; b++) {\r\n                        const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\r\n                        const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\r\n                        const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\r\n                        const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\r\n                        const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\r\n                        const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\r\n                        const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n                        const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n                        const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n                        tempMin.minimizeInPlaceFromFloats(x, y, z);\r\n                        tempMax.maximizeInPlaceFromFloats(x, y, z);\r\n                    }\r\n\r\n                    bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\r\n                }\r\n\r\n                // place and scale the particle bouding sphere in the SPS local system, then update it\r\n                const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\r\n                const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\r\n\r\n                const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\r\n                const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\r\n                const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\r\n                const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\r\n                bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\r\n            }\r\n\r\n            // increment indexes for the next particle\r\n            index = idx + 3;\r\n            colorIndex = colidx + 4;\r\n            uvIndex = uvidx + 2;\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (update) {\r\n            if (this._computeParticleColor) {\r\n                const vb = mesh.getVertexBuffer(VertexBuffer.ColorKind);\r\n                if (vb && !mesh.isPickable) {\r\n                    vb.updateDirectly(colors32, 0);\r\n                } else {\r\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n                }\r\n            }\r\n            if (this._computeParticleTexture) {\r\n                const vb = mesh.getVertexBuffer(VertexBuffer.UVKind);\r\n                if (vb && !mesh.isPickable) {\r\n                    vb.updateDirectly(uvs32, 0);\r\n                } else {\r\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n                }\r\n            }\r\n            const vbp = mesh.getVertexBuffer(VertexBuffer.PositionKind);\r\n            if (vbp && !mesh.isPickable) {\r\n                vbp.updateDirectly(positions32, 0);\r\n            } else {\r\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            }\r\n            if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\r\n                if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\r\n                    // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\r\n                    const params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\r\n                    VertexData.ComputeNormals(positions32, indices32, normals32, params);\r\n                    for (let i = 0; i < normals32.length; i++) {\r\n                        fixedNormal32[i] = normals32[i];\r\n                    }\r\n                }\r\n                if (!mesh.areNormalsFrozen) {\r\n                    const vb = mesh.getVertexBuffer(VertexBuffer.NormalKind);\r\n                    if (vb && !mesh.isPickable) {\r\n                        vb.updateDirectly(normals32, 0);\r\n                    } else {\r\n                        mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\r\n                    }\r\n                }\r\n            }\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                const depthSortedParticles = this.depthSortedParticles;\r\n                depthSortedParticles.sort(this._depthSortFunction);\r\n                const dspl = depthSortedParticles.length;\r\n                let sid = 0;\r\n                let faceId = 0;\r\n                for (let sorted = 0; sorted < dspl; sorted++) {\r\n                    const sortedParticle = depthSortedParticles[sorted];\r\n                    const lind = sortedParticle.indicesLength;\r\n                    const sind = sortedParticle.ind;\r\n                    for (let i = 0; i < lind; i++) {\r\n                        indices32[sid] = indices[sind + i];\r\n                        sid++;\r\n                        if (this._pickable) {\r\n                            const f = i % 3;\r\n                            if (f == 0) {\r\n                                const pickedData = this.pickedParticles[faceId];\r\n                                pickedData.idx = sortedParticle.idx;\r\n                                pickedData.faceId = faceId;\r\n                                faceId++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                mesh.updateIndices(indices32);\r\n            }\r\n        }\r\n        if (this._computeBoundingBox) {\r\n            if (mesh.hasBoundingInfo) {\r\n                mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\r\n            } else {\r\n                mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n        }\r\n        if (this._autoUpdateSubMeshes) {\r\n            this.computeSubMeshes();\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the SPS.\r\n     */\r\n    public dispose(): void {\r\n        this.mesh.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._normals32) = null;\r\n        (<any>this._fixedNormal32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n        (<any>this.pickedParticles) = null;\r\n        (<any>this.pickedBySubMesh) = null;\r\n        (<any>this._materials) = null;\r\n        (<any>this._materialIndexes) = null;\r\n        (<any>this._indicesByMaterial) = null;\r\n        (<any>this._idxOfId) = null;\r\n    }\r\n    /** Returns an object {idx: number faceId: number} for the picked particle from the passed pickingInfo object.\r\n     * idx is the particle index in the SPS\r\n     * faceId is the picked face index counted within this particle.\r\n     * Returns null if the pickInfo can't identify a picked particle.\r\n     * @param pickingInfo (PickingInfo object)\r\n     * @returns {idx: number, faceId: number} or null\r\n     */\r\n    public pickedParticle(pickingInfo: PickingInfo): Nullable<{ idx: number; faceId: number }> {\r\n        if (pickingInfo.hit) {\r\n            const subMesh = pickingInfo.subMeshId;\r\n            const faceId = pickingInfo.faceId - this.mesh.subMeshes[subMesh].indexStart / 3;\r\n            const picked = this.pickedBySubMesh;\r\n            if (picked[subMesh] && picked[subMesh][faceId]) {\r\n                return picked[subMesh][faceId];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a SolidParticle object from its identifier : particle.id\r\n     * @param id (integer) the particle Id\r\n     * @returns the searched particle or null if not found in the SPS.\r\n     */\r\n    public getParticleById(id: number): Nullable<SolidParticle> {\r\n        const p = this.particles[id];\r\n        if (p && p.id == id) {\r\n            return p;\r\n        }\r\n        const particles = this.particles;\r\n        const idx = this._idxOfId[id];\r\n        if (idx !== undefined) {\r\n            return particles[idx];\r\n        }\r\n        let i = 0;\r\n        const nb = this.nbParticles;\r\n        while (i < nb) {\r\n            const particle = particles[i];\r\n            if (particle.id == id) {\r\n                return particle;\r\n            }\r\n            i++;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a new array populated with the particles having the passed shapeId.\r\n     * @param shapeId (integer) the shape identifier\r\n     * @returns a new solid particle array\r\n     */\r\n    public getParticlesByShapeId(shapeId: number): SolidParticle[] {\r\n        const ref: SolidParticle[] = [];\r\n        this.getParticlesByShapeIdToRef(shapeId, ref);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Populates the passed array \"ref\" with the particles having the passed shapeId.\r\n     * @param shapeId the shape identifier\r\n     * @returns the SPS\r\n     * @param ref\r\n     */\r\n    public getParticlesByShapeIdToRef(shapeId: number, ref: SolidParticle[]): SolidParticleSystem {\r\n        ref.length = 0;\r\n        for (let i = 0; i < this.nbParticles; i++) {\r\n            const p = this.particles[i];\r\n            if (p.shapeId == shapeId) {\r\n                ref.push(p);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Computes the required SubMeshes according the materials assigned to the particles.\r\n     * @returns the solid particle system.\r\n     * Does nothing if called before the SPS mesh is built.\r\n     */\r\n    public computeSubMeshes(): SolidParticleSystem {\r\n        if (!this.mesh || !this._multimaterialEnabled) {\r\n            return this;\r\n        }\r\n        const depthSortedParticles = this.depthSortedParticles;\r\n        if (this.particles.length > 0) {\r\n            for (let p = 0; p < this.particles.length; p++) {\r\n                const part = this.particles[p];\r\n                if (!part.materialIndex) {\r\n                    part.materialIndex = 0;\r\n                }\r\n                const sortedPart = depthSortedParticles[p];\r\n                sortedPart.materialIndex = part.materialIndex;\r\n                sortedPart.ind = part._ind;\r\n                sortedPart.indicesLength = part._model._indicesLength;\r\n                sortedPart.idx = part.idx;\r\n            }\r\n        }\r\n        this._sortParticlesByMaterial();\r\n        const indicesByMaterial = this._indicesByMaterial;\r\n        const materialIndexes = this._materialIndexes;\r\n        const mesh = this.mesh;\r\n        mesh.subMeshes = [];\r\n        const vcount = mesh.getTotalVertices();\r\n        for (let m = 0; m < materialIndexes.length; m++) {\r\n            const start = indicesByMaterial[m];\r\n            const count = indicesByMaterial[m + 1] - start;\r\n            const matIndex = materialIndexes[m];\r\n            new SubMesh(matIndex, 0, vcount, start, count, mesh);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sorts the solid particles by material when MultiMaterial is enabled.\r\n     * Updates the indices32 array.\r\n     * Updates the indicesByMaterial array.\r\n     * Updates the mesh indices array.\r\n     * @returns the SPS\r\n     * @hidden\r\n     */\r\n    private _sortParticlesByMaterial(): SolidParticleSystem {\r\n        const indicesByMaterial = [0];\r\n        this._indicesByMaterial = indicesByMaterial;\r\n        const materialIndexes: number[] = [];\r\n        this._materialIndexes = materialIndexes;\r\n        const depthSortedParticles = this.depthSortedParticles;\r\n        depthSortedParticles.sort(this._materialSortFunction);\r\n        const length = depthSortedParticles.length;\r\n        const indices32 = this._indices32;\r\n        const indices = this._indices;\r\n\r\n        let subMeshIndex = 0;\r\n        let subMeshFaceId = 0;\r\n        let sid = 0;\r\n        let lastMatIndex = depthSortedParticles[0].materialIndex;\r\n        materialIndexes.push(lastMatIndex);\r\n        if (this._pickable) {\r\n            this.pickedBySubMesh = [[]];\r\n            this.pickedParticles = this.pickedBySubMesh[0];\r\n        }\r\n        for (let sorted = 0; sorted < length; sorted++) {\r\n            const sortedPart = depthSortedParticles[sorted];\r\n            const lind = sortedPart.indicesLength;\r\n            const sind = sortedPart.ind;\r\n            if (sortedPart.materialIndex !== lastMatIndex) {\r\n                lastMatIndex = sortedPart.materialIndex;\r\n                indicesByMaterial.push(sid);\r\n                materialIndexes.push(lastMatIndex);\r\n                if (this._pickable) {\r\n                    subMeshIndex++;\r\n                    this.pickedBySubMesh[subMeshIndex] = [];\r\n                    subMeshFaceId = 0;\r\n                }\r\n            }\r\n            let faceId = 0;\r\n            for (let i = 0; i < lind; i++) {\r\n                indices32[sid] = indices[sind + i];\r\n                if (this._pickable) {\r\n                    const f = i % 3;\r\n                    if (f == 0) {\r\n                        const pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\r\n                        if (pickedData) {\r\n                            pickedData.idx = sortedPart.idx;\r\n                            pickedData.faceId = faceId;\r\n                        } else {\r\n                            this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = { idx: sortedPart.idx, faceId: faceId };\r\n                        }\r\n                        subMeshFaceId++;\r\n                        faceId++;\r\n                    }\r\n                }\r\n                sid++;\r\n            }\r\n        }\r\n\r\n        indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\r\n        if (this._updatable) {\r\n            this.mesh.updateIndices(indices32);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the material indexes by id materialIndexesById[id] = materialIndex\r\n     * @hidden\r\n     */\r\n    private _setMaterialIndexesById() {\r\n        this._materialIndexesById = {};\r\n        for (let i = 0; i < this._materials.length; i++) {\r\n            const id = this._materials[i].uniqueId;\r\n            this._materialIndexesById[id] = i;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array with unique values of Materials from the passed array\r\n     * @param array the material array to be checked and filtered\r\n     * @hidden\r\n     */\r\n    private _filterUniqueMaterialId(array: Material[]): Material[] {\r\n        const filtered = array.filter(function (value, index, self) {\r\n            return self.indexOf(value) === index;\r\n        });\r\n        return filtered;\r\n    }\r\n    /**\r\n     * Sets a new Standard Material as _defaultMaterial if not already set.\r\n     * @hidden\r\n     */\r\n    private _setDefaultMaterial(): Material {\r\n        if (!this._defaultMaterial) {\r\n            this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\r\n        }\r\n        return this._defaultMaterial;\r\n    }\r\n    /**\r\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     * @returns the SPS.\r\n     */\r\n    public refreshVisibleSize(): SolidParticleSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the SPS mesh bounding box.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        const vis = size / 2;\r\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isVisibilityBoxLocked(val: boolean) {\r\n        this._isVisibilityBoxLocked = val;\r\n\r\n        const boundingInfo = this.mesh.getBoundingInfo();\r\n\r\n        boundingInfo.isLocked = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isVisibilityBoxLocked(): boolean {\r\n        return this._isVisibilityBoxLocked;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public set computeParticleVertex(val: boolean) {\r\n        this._computeParticleVertex = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public set depthSortParticles(val: boolean) {\r\n        this._depthSortParticles = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public get computeParticleRotation(): boolean {\r\n        return this._computeParticleRotation;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public get computeParticleVertex(): boolean {\r\n        return this._computeParticleVertex;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public get depthSortParticles(): boolean {\r\n        return this._depthSortParticles;\r\n    }\r\n\r\n    /**\r\n     * Gets if the SPS is created as expandable at construction time.\r\n     * Default : `false`\r\n     */\r\n    public get expandable(): boolean {\r\n        return this._expandable;\r\n    }\r\n    /**\r\n     * Gets if the SPS supports the Multi Materials\r\n     */\r\n    public get multimaterialEnabled(): boolean {\r\n        return this._multimaterialEnabled;\r\n    }\r\n    /**\r\n     * Gets if the SPS uses the model materials for its own multimaterial.\r\n     */\r\n    public get useModelMaterial(): boolean {\r\n        return this._useModelMaterial;\r\n    }\r\n    /**\r\n     * The SPS used material array.\r\n     */\r\n    public get materials(): Material[] {\r\n        return this._materials;\r\n    }\r\n    /**\r\n     * Sets the SPS MultiMaterial from the passed materials.\r\n     * Note : the passed array is internally copied and not used then by reference.\r\n     * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\r\n     */\r\n    public setMultiMaterial(materials: Material[]) {\r\n        this._materials = this._filterUniqueMaterialId(materials);\r\n        this._setMaterialIndexesById();\r\n        if (this._multimaterial) {\r\n            this._multimaterial.dispose();\r\n        }\r\n        this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\r\n        for (let m = 0; m < this._materials.length; m++) {\r\n            this._multimaterial.subMaterials.push(this._materials[m]);\r\n        }\r\n        this.computeSubMeshes();\r\n        this.mesh.material = this._multimaterial;\r\n    }\r\n    /**\r\n     * The SPS computed multimaterial object\r\n     */\r\n    public get multimaterial(): MultiMaterial {\r\n        return this._multimaterial;\r\n    }\r\n    public set multimaterial(mm) {\r\n        this._multimaterial = mm;\r\n    }\r\n    /**\r\n     * If the subMeshes must be updated on the next call to setParticles()\r\n     */\r\n    public get autoUpdateSubMeshes(): boolean {\r\n        return this._autoUpdateSubMeshes;\r\n    }\r\n    public set autoUpdateSubMeshes(val: boolean) {\r\n        this._autoUpdateSubMeshes = val;\r\n    }\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by the user to fit his needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     */\r\n    public initParticles(): void {}\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a vertex of a particle : it can be overwritten by the user.\r\n     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\r\n     * @param particle the current particle\r\n     * @param vertex the current vertex of the current particle : a SolidParticleVertex object\r\n     * @param pt the index of the current vertex in the particle shape\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape\r\n     * @example : just set a vertex particle position or color\r\n     * @returns the sps\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateParticleVertex(particle: SolidParticle, vertex: SolidParticleVertex, pt: number): SolidParticleSystem {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}