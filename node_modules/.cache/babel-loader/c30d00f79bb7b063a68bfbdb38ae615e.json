{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Single axis scale gizmo\n */\n\nvar AxisScaleGizmo =\n/** @class */\nfunction (_super) {\n  __extends(AxisScaleGizmo, _super);\n  /**\n   * Creates an AxisScaleGizmo\n   * @param dragAxis The axis which the gizmo will be able to scale on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param parent\n   * @param thickness display gizmo axis thickness\n   */\n\n\n  function AxisScaleGizmo(dragAxis, color, gizmoLayer, parent, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _this = this;\n\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    _this = _super.call(this, gizmoLayer) || this;\n    _this._pointerObserver = null;\n    /**\n     * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n\n    _this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n\n    _this.onSnapObservable = new Observable();\n    /**\n     * If the scaling operation should be done on all axis (default: false)\n     */\n\n    _this.uniformScaling = false;\n    /**\n     * Custom sensitivity value for the drag strength\n     */\n\n    _this.sensitivity = 1;\n    /**\n     * The magnitude of the drag strength (scaling factor)\n     */\n\n    _this.dragScale = 1;\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._tmpVector = new Vector3();\n    _this._tmpMatrix = new Matrix();\n    _this._tmpMatrix2 = new Matrix();\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build mesh + Collider\n\n    _this._gizmoMesh = new Mesh(\"axis\", gizmoLayer.utilityLayerScene);\n\n    var _h = _this._createGizmoMesh(_this._gizmoMesh, thickness),\n        arrowMesh = _h.arrowMesh,\n        arrowTail = _h.arrowTail;\n\n    var collider = _this._createGizmoMesh(_this._gizmoMesh, thickness + 4, true);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragAxis));\n\n    _this._rootMesh.addChild(_this._gizmoMesh, Gizmo.PreserveScaling);\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3); // Closure of initial prop values for resetting\n\n\n    var nodePosition = arrowMesh.position.clone();\n    var linePosition = arrowTail.position.clone();\n    var lineScale = arrowTail.scaling.clone();\n\n    var increaseGizmoMesh = function increaseGizmoMesh(dragDistance) {\n      var dragStrength = dragDistance * (3 / _this._rootMesh.scaling.length()) * 6;\n      arrowMesh.position.z += dragStrength / 3.5;\n      arrowTail.scaling.y += dragStrength;\n      _this.dragScale = arrowTail.scaling.y;\n      arrowTail.position.z = arrowMesh.position.z / 2;\n    };\n\n    var resetGizmoMesh = function resetGizmoMesh() {\n      arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);\n      arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);\n      arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);\n      _this.dragScale = arrowTail.scaling.y;\n      _this._dragging = false;\n    }; // Add drag behavior to handle events when the gizmo is dragged\n\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragAxis: dragAxis\n    });\n    _this.dragBehavior.moveAttached = false;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior);\n\n    var currentSnapDragDistance = 0;\n    var tmpVector = new Vector3();\n    var tmpSnapEvent = {\n      snapDistance: 0\n    };\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        _this._handlePivot(); // Drag strength is modified by the scale of the gizmo (eg. for small objects like boombox the strength will be increased to match the behavior of larger objects)\n\n\n        var dragStrength = _this.sensitivity * event.dragDistance * (_this.scaleRatio * 3 / _this._rootMesh.scaling.length()); // Snapping logic\n\n\n        var snapped = false;\n        var dragSteps = 0;\n\n        if (_this.uniformScaling) {\n          tmpVector.setAll(0.57735); // 1 / sqrt(3)\n        } else {\n          tmpVector.copyFrom(dragAxis);\n        }\n\n        if (_this.snapDistance == 0) {\n          tmpVector.scaleToRef(dragStrength, tmpVector);\n        } else {\n          currentSnapDragDistance += dragStrength;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            tmpVector.scaleToRef(_this.snapDistance * dragSteps, tmpVector);\n            snapped = true;\n          } else {\n            tmpVector.scaleInPlace(0);\n          }\n        }\n\n        Matrix.ScalingToRef(1 + tmpVector.x, 1 + tmpVector.y, 1 + tmpVector.z, _this._tmpMatrix2);\n\n        _this._tmpMatrix2.multiplyToRef(_this.attachedNode.getWorldMatrix(), _this._tmpMatrix);\n\n        var transformNode = _this.attachedNode._isMesh ? _this.attachedNode : undefined;\n\n        _this._tmpMatrix.decompose(_this._tmpVector, undefined, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n\n        var maxScale = 100000;\n\n        if (Math.abs(_this._tmpVector.x) < maxScale && Math.abs(_this._tmpVector.y) < maxScale && Math.abs(_this._tmpVector.z) < maxScale) {\n          _this.attachedNode.getWorldMatrix().copyFrom(_this._tmpMatrix);\n        }\n\n        if (snapped) {\n          tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;\n\n          _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n\n        _this._matrixChanged();\n      }\n    }); // On Drag Listener: to move gizmo mesh with user action\n\n\n    _this.dragBehavior.onDragStartObservable.add(function () {\n      _this._dragging = true;\n    });\n\n    _this.dragBehavior.onDragObservable.add(function (e) {\n      return increaseGizmoMesh(e.dragDistance);\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(resetGizmoMesh); // Listeners for Universal Scalar\n\n\n    (_c = (_b = (_a = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _a === void 0 ? void 0 : _a.dragBehavior) === null || _b === void 0 ? void 0 : _b.onDragObservable) === null || _c === void 0 ? void 0 : _c.add(function (e) {\n      return increaseGizmoMesh(e.delta.y);\n    });\n    (_f = (_e = (_d = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _d === void 0 ? void 0 : _d.dragBehavior) === null || _e === void 0 ? void 0 : _e.onDragEndObservable) === null || _f === void 0 ? void 0 : _f.add(resetGizmoMesh);\n    var cache = {\n      gizmoMeshes: [arrowMesh, arrowTail],\n      colliderMeshes: [collider.arrowMesh, collider.arrowTail],\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false,\n      dragBehavior: _this.dragBehavior\n    };\n    (_g = _this._parent) === null || _g === void 0 ? void 0 : _g.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this.dragBehavior.enabled ? _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial : _this._disableMaterial;\n\n        _this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n\n    _this.dragBehavior.onEnabledObservable.add(function (newState) {\n      _this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? _this._coloredMaterial : _this._disableMaterial);\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes());\n    return _this;\n  }\n  /**\n   * Create Geometry for Gizmo\n   * @param parentMesh\n   * @param thickness\n   * @param isCollider\n   */\n\n\n  AxisScaleGizmo.prototype._createGizmoMesh = function (parentMesh, thickness, isCollider) {\n    if (isCollider === void 0) {\n      isCollider = false;\n    }\n\n    var arrowMesh = CreateBox(\"yPosMesh\", {\n      size: 0.4 * (1 + (thickness - 1) / 4)\n    }, this.gizmoLayer.utilityLayerScene);\n    var arrowTail = CreateCylinder(\"cylinder\", {\n      diameterTop: 0.005 * thickness,\n      height: 0.275,\n      diameterBottom: 0.005 * thickness,\n      tessellation: 96\n    }, this.gizmoLayer.utilityLayerScene); // Position arrow pointing in its drag axis\n\n    arrowMesh.scaling.scaleInPlace(0.1);\n    arrowMesh.material = this._coloredMaterial;\n    arrowMesh.rotation.x = Math.PI / 2;\n    arrowMesh.position.z += 0.3;\n    arrowTail.material = this._coloredMaterial;\n    arrowTail.position.z += 0.275 / 2;\n    arrowTail.rotation.x = Math.PI / 2;\n\n    if (isCollider) {\n      arrowMesh.visibility = 0;\n      arrowTail.visibility = 0;\n    }\n\n    parentMesh.addChild(arrowMesh);\n    parentMesh.addChild(arrowTail);\n    return {\n      arrowMesh: arrowMesh,\n      arrowTail: arrowTail\n    };\n  };\n\n  AxisScaleGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  Object.defineProperty(AxisScaleGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\n     * If the gizmo is enabled\n     */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n        this.attachedNode = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n          this.attachedNode = this._parent.attachedNode;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes of the gizmo\n   */\n\n  AxisScaleGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   * @param useGizmoMaterial If the gizmo's default material should be used (default: false)\n   */\n\n\n  AxisScaleGizmo.prototype.setCustomMesh = function (mesh, useGizmoMaterial) {\n    var _this = this;\n\n    if (useGizmoMaterial === void 0) {\n      useGizmoMaterial = false;\n    }\n\n    _super.prototype.setCustomMesh.call(this, mesh);\n\n    if (useGizmoMaterial) {\n      this._rootMesh.getChildMeshes().forEach(function (m) {\n        m.material = _this._coloredMaterial;\n\n        if (m.color) {\n          m.color = _this._coloredMaterial.diffuseColor;\n        }\n      });\n\n      this._customMeshSet = false;\n    }\n  };\n\n  return AxisScaleGizmo;\n}(Gizmo);\n\nexport { AxisScaleGizmo };","map":{"version":3,"mappings":"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","names":["Observable","Vector3","Matrix","Mesh","CreateBox","CreateCylinder","StandardMaterial","PointerDragBehavior","Gizmo","UtilityLayerRenderer","Color3","__extends","dragAxis","color","gizmoLayer","parent","thickness","Gray","DefaultUtilityLayer","_super","_this","_parent","_coloredMaterial","utilityLayerScene","diffuseColor","specularColor","subtract","_hoverMaterial","Yellow","_disableMaterial","alpha","_gizmoMesh","_createGizmoMesh","arrowMesh","arrowTail","collider","lookAt","_rootMesh","position","add","addChild","PreserveScaling","scaling","scaleInPlace","nodePosition","clone","linePosition","lineScale","increaseGizmoMesh","dragDistance","dragStrength","length","z","y","dragScale","resetGizmoMesh","set","x","_dragging","dragBehavior","moveAttached","addBehavior","currentSnapDragDistance","tmpVector","tmpSnapEvent","snapDistance","onDragObservable","event","attachedNode","_handlePivot","sensitivity","scaleRatio","snapped","dragSteps","uniformScaling","setAll","copyFrom","scaleToRef","Math","abs","floor","ScalingToRef","_tmpMatrix2","multiplyToRef","getWorldMatrix","_tmpMatrix","transformNode","_isMesh","undefined","decompose","_tmpVector","maxScale","onSnapObservable","notifyObservers","_matrixChanged","onDragStartObservable","e","onDragEndObservable","uniformScaleGizmo","_a","_b","_c","delta","_d","_e","_f","cache","gizmoMeshes","colliderMeshes","material","hoverMaterial","disableMaterial","active","_g","addToAxisCache","_pointerObserver","onPointerObservable","pointerInfo","_customMeshSet","_isHovered","indexOf","pickInfo","pickedMesh","enabled","_setGizmoMeshMaterial","onEnabledObservable","newState","light","_getSharedGizmoLight","includedOnlyMeshes","concat","getChildMeshes","AxisScaleGizmo","parentMesh","isCollider","size","diameterTop","height","diameterBottom","tessellation","rotation","PI","visibility","value","Object","_isEnabled","attachedMesh","clear","remove","detach","dispose","forEach","matl","call","mesh","useGizmoMaterial","setCustomMesh","m"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/axisScaleGizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Node } from \"../node\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { GizmoAxisCache } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { ScaleGizmo } from \"./scaleGizmo\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\n\r\n/**\r\n * Single axis scale gizmo\r\n */\r\nexport class AxisScaleGizmo extends Gizmo {\r\n    /**\r\n     * Drag behavior responsible for the gizmos dragging interactions\r\n     */\r\n    public dragBehavior: PointerDragBehavior;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n    /**\r\n     * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public snapDistance = 0;\r\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\r\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\r\n    /**\r\n     * If the scaling operation should be done on all axis (default: false)\r\n     */\r\n    public uniformScaling = false;\r\n    /**\r\n     * Custom sensitivity value for the drag strength\r\n     */\r\n    public sensitivity = 1;\r\n    /**\r\n     * The magnitude of the drag strength (scaling factor)\r\n     */\r\n    public dragScale = 1;\r\n\r\n    private _isEnabled: boolean = true;\r\n    private _parent: Nullable<ScaleGizmo> = null;\r\n\r\n    private _gizmoMesh: Mesh;\r\n    private _coloredMaterial: StandardMaterial;\r\n    private _hoverMaterial: StandardMaterial;\r\n    private _disableMaterial: StandardMaterial;\r\n    private _dragging: boolean = false;\r\n    private _tmpVector = new Vector3();\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpMatrix2 = new Matrix();\r\n\r\n    /**\r\n     * Creates an AxisScaleGizmo\r\n     * @param dragAxis The axis which the gizmo will be able to scale on\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param parent\r\n     * @param thickness display gizmo axis thickness\r\n     */\r\n    constructor(\r\n        dragAxis: Vector3,\r\n        color: Color3 = Color3.Gray(),\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        parent: Nullable<ScaleGizmo> = null,\r\n        thickness: number = 1\r\n    ) {\r\n        super(gizmoLayer);\r\n        this._parent = parent;\r\n        // Create Material\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.diffuseColor = color;\r\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\r\n\r\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\r\n\r\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._disableMaterial.diffuseColor = Color3.Gray();\r\n        this._disableMaterial.alpha = 0.4;\r\n\r\n        // Build mesh + Collider\r\n        this._gizmoMesh = new Mesh(\"axis\", gizmoLayer.utilityLayerScene);\r\n        const { arrowMesh, arrowTail } = this._createGizmoMesh(this._gizmoMesh, thickness);\r\n        const collider = this._createGizmoMesh(this._gizmoMesh, thickness + 4, true);\r\n\r\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));\r\n        this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);\r\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\r\n\r\n        // Closure of initial prop values for resetting\r\n        const nodePosition = arrowMesh.position.clone();\r\n        const linePosition = arrowTail.position.clone();\r\n        const lineScale = arrowTail.scaling.clone();\r\n\r\n        const increaseGizmoMesh = (dragDistance: number) => {\r\n            const dragStrength = dragDistance * (3 / this._rootMesh.scaling.length()) * 6;\r\n\r\n            arrowMesh.position.z += dragStrength / 3.5;\r\n            arrowTail.scaling.y += dragStrength;\r\n            this.dragScale = arrowTail.scaling.y;\r\n            arrowTail.position.z = arrowMesh.position.z / 2;\r\n        };\r\n\r\n        const resetGizmoMesh = () => {\r\n            arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);\r\n            arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);\r\n            arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);\r\n            this.dragScale = arrowTail.scaling.y;\r\n            this._dragging = false;\r\n        };\r\n\r\n        // Add drag behavior to handle events when the gizmo is dragged\r\n        this.dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\r\n        this.dragBehavior.moveAttached = false;\r\n        this._rootMesh.addBehavior(this.dragBehavior);\r\n\r\n        let currentSnapDragDistance = 0;\r\n        const tmpVector = new Vector3();\r\n        const tmpSnapEvent = { snapDistance: 0 };\r\n        this.dragBehavior.onDragObservable.add((event) => {\r\n            if (this.attachedNode) {\r\n                this._handlePivot();\r\n                // Drag strength is modified by the scale of the gizmo (eg. for small objects like boombox the strength will be increased to match the behavior of larger objects)\r\n                const dragStrength = this.sensitivity * event.dragDistance * ((this.scaleRatio * 3) / this._rootMesh.scaling.length());\r\n\r\n                // Snapping logic\r\n                let snapped = false;\r\n                let dragSteps = 0;\r\n                if (this.uniformScaling) {\r\n                    tmpVector.setAll(0.57735); // 1 / sqrt(3)\r\n                } else {\r\n                    tmpVector.copyFrom(dragAxis);\r\n                }\r\n                if (this.snapDistance == 0) {\r\n                    tmpVector.scaleToRef(dragStrength, tmpVector);\r\n                } else {\r\n                    currentSnapDragDistance += dragStrength;\r\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\r\n                        dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\r\n                        if (currentSnapDragDistance < 0) {\r\n                            dragSteps *= -1;\r\n                        }\r\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\r\n                        tmpVector.scaleToRef(this.snapDistance * dragSteps, tmpVector);\r\n                        snapped = true;\r\n                    } else {\r\n                        tmpVector.scaleInPlace(0);\r\n                    }\r\n                }\r\n\r\n                Matrix.ScalingToRef(1 + tmpVector.x, 1 + tmpVector.y, 1 + tmpVector.z, this._tmpMatrix2);\r\n\r\n                this._tmpMatrix2.multiplyToRef(this.attachedNode.getWorldMatrix(), this._tmpMatrix);\r\n                const transformNode = (<Mesh>this.attachedNode)._isMesh ? (this.attachedNode as TransformNode) : undefined;\r\n                this._tmpMatrix.decompose(this._tmpVector, undefined, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n\r\n                const maxScale = 100000;\r\n                if (Math.abs(this._tmpVector.x) < maxScale && Math.abs(this._tmpVector.y) < maxScale && Math.abs(this._tmpVector.z) < maxScale) {\r\n                    this.attachedNode.getWorldMatrix().copyFrom(this._tmpMatrix);\r\n                }\r\n\r\n                if (snapped) {\r\n                    tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;\r\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\r\n                }\r\n                this._matrixChanged();\r\n            }\r\n        });\r\n        // On Drag Listener: to move gizmo mesh with user action\r\n        this.dragBehavior.onDragStartObservable.add(() => {\r\n            this._dragging = true;\r\n        });\r\n        this.dragBehavior.onDragObservable.add((e) => increaseGizmoMesh(e.dragDistance));\r\n        this.dragBehavior.onDragEndObservable.add(resetGizmoMesh);\r\n\r\n        // Listeners for Universal Scalar\r\n        parent?.uniformScaleGizmo?.dragBehavior?.onDragObservable?.add((e) => increaseGizmoMesh(e.delta.y));\r\n        parent?.uniformScaleGizmo?.dragBehavior?.onDragEndObservable?.add(resetGizmoMesh);\r\n\r\n        const cache: GizmoAxisCache = {\r\n            gizmoMeshes: [arrowMesh, arrowTail],\r\n            colliderMeshes: [collider.arrowMesh, collider.arrowTail],\r\n            material: this._coloredMaterial,\r\n            hoverMaterial: this._hoverMaterial,\r\n            disableMaterial: this._disableMaterial,\r\n            active: false,\r\n            dragBehavior: this.dragBehavior,\r\n        };\r\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (this._customMeshSet) {\r\n                return;\r\n            }\r\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\r\n            if (!this._parent) {\r\n                const material = this.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\r\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\r\n            }\r\n        });\r\n\r\n        this.dragBehavior.onEnabledObservable.add((newState) => {\r\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\r\n        });\r\n\r\n        const light = gizmoLayer._getSharedGizmoLight();\r\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes());\r\n    }\r\n\r\n    /**\r\n     * Create Geometry for Gizmo\r\n     * @param parentMesh\r\n     * @param thickness\r\n     * @param isCollider\r\n     */\r\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, isCollider = false) {\r\n        const arrowMesh = CreateBox(\"yPosMesh\", { size: 0.4 * (1 + (thickness - 1) / 4) }, this.gizmoLayer.utilityLayerScene);\r\n        const arrowTail = CreateCylinder(\r\n            \"cylinder\",\r\n            { diameterTop: 0.005 * thickness, height: 0.275, diameterBottom: 0.005 * thickness, tessellation: 96 },\r\n            this.gizmoLayer.utilityLayerScene\r\n        );\r\n\r\n        // Position arrow pointing in its drag axis\r\n        arrowMesh.scaling.scaleInPlace(0.1);\r\n        arrowMesh.material = this._coloredMaterial;\r\n        arrowMesh.rotation.x = Math.PI / 2;\r\n        arrowMesh.position.z += 0.3;\r\n\r\n        arrowTail.material = this._coloredMaterial;\r\n        arrowTail.position.z += 0.275 / 2;\r\n        arrowTail.rotation.x = Math.PI / 2;\r\n\r\n        if (isCollider) {\r\n            arrowMesh.visibility = 0;\r\n            arrowTail.visibility = 0;\r\n        }\r\n\r\n        parentMesh.addChild(arrowMesh);\r\n        parentMesh.addChild(arrowTail);\r\n\r\n        return { arrowMesh, arrowTail };\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {\r\n        if (this.dragBehavior) {\r\n            this.dragBehavior.enabled = value ? true : false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the gizmo is enabled\r\n     */\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (!value) {\r\n            this.attachedMesh = null;\r\n            this.attachedNode = null;\r\n        } else {\r\n            if (this._parent) {\r\n                this.attachedMesh = this._parent.attachedMesh;\r\n                this.attachedNode = this._parent.attachedNode;\r\n            }\r\n        }\r\n    }\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.onSnapObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.dragBehavior.detach();\r\n        if (this._gizmoMesh) {\r\n            this._gizmoMesh.dispose();\r\n        }\r\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\r\n            if (matl) {\r\n                matl.dispose();\r\n            }\r\n        });\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     * @param useGizmoMaterial If the gizmo's default material should be used (default: false)\r\n     */\r\n    public setCustomMesh(mesh: Mesh, useGizmoMaterial: boolean = false) {\r\n        super.setCustomMesh(mesh);\r\n        if (useGizmoMaterial) {\r\n            this._rootMesh.getChildMeshes().forEach((m) => {\r\n                m.material = this._coloredMaterial;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = this._coloredMaterial.diffuseColor;\r\n                }\r\n            });\r\n            this._customMeshSet = false;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}