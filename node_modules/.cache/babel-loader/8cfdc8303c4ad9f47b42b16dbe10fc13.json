{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { Scene } from \"../../scene.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { UniformBuffer } from \"../../Materials/uniformBuffer.js\";\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget.js\";\nimport { Frustum } from \"../../Maths/math.frustum.js\";\n\nEngine.prototype.createMultiviewRenderTargetTexture = function (width, height) {\n  var gl = this._gl;\n\n  if (!this.getCaps().multiview) {\n    throw \"Multiview is not supported\";\n  }\n\n  var rtWrapper = this._createHardwareRenderTargetWrapper(false, false, {\n    width: width,\n    height: height\n  });\n\n  rtWrapper._framebuffer = gl.createFramebuffer();\n  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n  internalTexture.width = width;\n  internalTexture.height = height;\n  internalTexture.isMultiview = true;\n  rtWrapper._colorTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._colorTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\n  rtWrapper._depthStencilTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._depthStencilTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH24_STENCIL8, width, height, 2);\n  internalTexture.isReady = true;\n  rtWrapper.setTextures(internalTexture);\n  rtWrapper._depthStencilTexture = internalTexture;\n  return rtWrapper;\n};\n\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture) {\n  var multiviewTexture = _multiviewTexture;\n  var gl = this._gl;\n  var ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\n  this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\n  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\n\n  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\n    if (this.getCaps().oculusMultiview) {\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);\n    } else {\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\n    }\n  } else {\n    throw \"Invalid multiview frame buffer\";\n  }\n};\n\nCamera.prototype._useMultiviewToSingleView = false;\nCamera.prototype._multiviewTexture = null;\n\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width, height) {\n  if (!this._multiviewTexture) {\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\n    this._multiviewTexture.dispose();\n\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  }\n};\n\nfunction createMultiviewUbo(engine, name) {\n  var ubo = new UniformBuffer(engine, undefined, true, name);\n  ubo.addUniform(\"viewProjection\", 16);\n  ubo.addUniform(\"viewProjectionR\", 16);\n  ubo.addUniform(\"view\", 16);\n  ubo.addUniform(\"projection\", 16);\n  ubo.addUniform(\"vEyePosition\", 4);\n  return ubo;\n}\n\nvar currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\nScene.prototype._transformMatrixR = Matrix.Zero();\nScene.prototype._multiviewSceneUbo = null;\n\nScene.prototype._createMultiviewUbo = function () {\n  this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\n};\n\nScene.prototype.createSceneUniformBuffer = function (name) {\n  if (this._multiviewSceneUbo) {\n    return createMultiviewUbo(this.getEngine(), name);\n  }\n\n  return currentCreateSceneUniformBuffer.bind(this)(name);\n};\n\nScene.prototype._updateMultiviewUbo = function (viewR, projectionR) {\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, this._transformMatrixR);\n  }\n\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\n    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\n  }\n\n  if (this._multiviewSceneUbo) {\n    this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\n\n    this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\n\n    this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n    this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n  }\n};\n\nScene.prototype._renderMultiviewToSingleView = function (camera) {\n  // Multiview is only able to be displayed directly for API's such as webXR\n  // This displays a multiview image by rendering to the multiview image and then\n  // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\n  // Render to a multiview texture\n  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));\n\n  if (!this._multiviewSceneUbo) {\n    this._createMultiviewUbo();\n  }\n\n  camera.outputRenderTarget = camera._multiviewTexture;\n\n  this._renderForCamera(camera);\n\n  camera.outputRenderTarget = null; // Consume the multiview texture through a shader for each eye\n\n  for (var index = 0; index < camera._rigCameras.length; index++) {\n    var engine = this.getEngine();\n    this._activeCamera = camera._rigCameras[index];\n    engine.setViewport(this._activeCamera.viewport);\n\n    if (this.postProcessManager) {\n      this.postProcessManager._prepareFrame();\n\n      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["Camera","Engine","Scene","InternalTexture","InternalTextureSource","Matrix","TmpVectors","UniformBuffer","MultiviewRenderTarget","Frustum","prototype","createMultiviewRenderTargetTexture","width","height","gl","_gl","getCaps","multiview","rtWrapper","_createHardwareRenderTargetWrapper","_framebuffer","createFramebuffer","internalTexture","Unknown","isMultiview","_colorTextureArray","createTexture","bindTexture","TEXTURE_2D_ARRAY","texStorage3D","RGBA8","_depthStencilTextureArray","DEPTH24_STENCIL8","isReady","setTextures","_depthStencilTexture","bindMultiviewFramebuffer","_multiviewTexture","multiviewTexture","ext","oculusMultiview","bindFramebuffer","undefined","DRAW_FRAMEBUFFER","framebufferTextureMultisampleMultiviewOVR","COLOR_ATTACHMENT0","samples","DEPTH_STENCIL_ATTACHMENT","framebufferTextureMultiviewOVR","_useMultiviewToSingleView","_resizeOrCreateMultiviewTexture","getScene","getRenderWidth","getRenderHeight","dispose","createMultiviewUbo","engine","name","ubo","addUniform","currentCreateSceneUniformBuffer","createSceneUniformBuffer","_transformMatrixR","Zero","_multiviewSceneUbo","_createMultiviewUbo","getEngine","bind","_updateMultiviewUbo","viewR","projectionR","multiplyToRef","GetRightPlaneToRef","_frustumPlanes","updateMatrix","getTransformMatrix","_viewMatrix","_projectionMatrix","_renderMultiviewToSingleView","camera","_rigPostProcess","outputRenderTarget","_renderForCamera","index","_rigCameras","length","_activeCamera","setViewport","viewport","postProcessManager","_prepareFrame","_finalizeFrame","isIntermediate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.multiview.ts"],"sourcesContent":["import { Camera } from \"../../Cameras/camera\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Scene } from \"../../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget\";\r\nimport { Frustum } from \"../../Maths/math.frustum\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Creates a new multiview render target\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @returns the created multiview render target wrapper\r\n         */\r\n        createMultiviewRenderTargetTexture(width: number, height: number): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Binds a multiview render target wrapper to be drawn to\r\n         * @param multiviewTexture render target wrapper to bind\r\n         */\r\n        bindMultiviewFramebuffer(multiviewTexture: RenderTargetWrapper): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.createMultiviewRenderTargetTexture = function (width: number, height: number) {\r\n    const gl = this._gl;\r\n\r\n    if (!this.getCaps().multiview) {\r\n        throw \"Multiview is not supported\";\r\n    }\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, { width, height }) as WebGLRenderTargetWrapper;\r\n\r\n    rtWrapper._framebuffer = gl.createFramebuffer();\r\n\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.isMultiview = true;\r\n\r\n    rtWrapper._colorTextureArray = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._colorTextureArray);\r\n    (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\r\n\r\n    rtWrapper._depthStencilTextureArray = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._depthStencilTextureArray);\r\n    (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, (gl as any).DEPTH24_STENCIL8, width, height, 2);\r\n\r\n    internalTexture.isReady = true;\r\n\r\n    rtWrapper.setTextures(internalTexture);\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture: RenderTargetWrapper) {\r\n    const multiviewTexture = _multiviewTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\r\n    if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\r\n        if (this.getCaps().oculusMultiview) {\r\n            ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\r\n            ext.framebufferTextureMultisampleMultiviewOVR(\r\n                gl.DRAW_FRAMEBUFFER,\r\n                gl.DEPTH_STENCIL_ATTACHMENT,\r\n                multiviewTexture._depthStencilTextureArray,\r\n                0,\r\n                multiviewTexture.samples,\r\n                0,\r\n                2\r\n            );\r\n        } else {\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\r\n        }\r\n    } else {\r\n        throw \"Invalid multiview frame buffer\";\r\n    }\r\n};\r\n\r\ndeclare module \"../../Cameras/camera\" {\r\n    export interface Camera {\r\n        /**\r\n         * @hidden\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _useMultiviewToSingleView: boolean;\r\n        /**\r\n         * @hidden\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _multiviewTexture: Nullable<RenderTargetTexture>;\r\n\r\n        /**\r\n         * @hidden\r\n         * For WebXR cameras that are rendering to multiview texture arrays.\r\n         */\r\n        _renderingMultiview: boolean;\r\n\r\n        /**\r\n         * @hidden\r\n         * ensures the multiview texture of the camera exists and has the specified width/height\r\n         * @param width height to set on the multiview texture\r\n         * @param height width to set on the multiview texture\r\n         */\r\n        _resizeOrCreateMultiviewTexture(width: number, height: number): void;\r\n    }\r\n}\r\n\r\nCamera.prototype._useMultiviewToSingleView = false;\r\n\r\nCamera.prototype._multiviewTexture = null;\r\n\r\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width: number, height: number) {\r\n    if (!this._multiviewTexture) {\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\r\n        this._multiviewTexture.dispose();\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    }\r\n};\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _transformMatrixR: Matrix;\r\n        /** @hidden */\r\n        _multiviewSceneUbo: Nullable<UniformBuffer>;\r\n        /** @hidden */\r\n        _createMultiviewUbo(): void;\r\n        /** @hidden */\r\n        _updateMultiviewUbo(viewR?: Matrix, projectionR?: Matrix): void;\r\n        /** @hidden */\r\n        _renderMultiviewToSingleView(camera: Camera): void;\r\n    }\r\n}\r\n\r\nfunction createMultiviewUbo(engine: Engine, name?: string) {\r\n    const ubo = new UniformBuffer(engine, undefined, true, name);\r\n    ubo.addUniform(\"viewProjection\", 16);\r\n    ubo.addUniform(\"viewProjectionR\", 16);\r\n    ubo.addUniform(\"view\", 16);\r\n    ubo.addUniform(\"projection\", 16);\r\n    ubo.addUniform(\"vEyePosition\", 4);\r\n    return ubo;\r\n}\r\n\r\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\r\n\r\nScene.prototype._transformMatrixR = Matrix.Zero();\r\nScene.prototype._multiviewSceneUbo = null;\r\nScene.prototype._createMultiviewUbo = function () {\r\n    this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\r\n};\r\nScene.prototype.createSceneUniformBuffer = function (name?: string): UniformBuffer {\r\n    if (this._multiviewSceneUbo) {\r\n        return createMultiviewUbo(this.getEngine(), name);\r\n    }\r\n    return currentCreateSceneUniformBuffer.bind(this)(name);\r\n};\r\nScene.prototype._updateMultiviewUbo = function (viewR?: Matrix, projectionR?: Matrix) {\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, this._transformMatrixR);\r\n    }\r\n\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\r\n        Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\r\n    }\r\n\r\n    if (this._multiviewSceneUbo) {\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\r\n        this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n        this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\r\n    }\r\n};\r\nScene.prototype._renderMultiviewToSingleView = function (camera: Camera) {\r\n    // Multiview is only able to be displayed directly for API's such as webXR\r\n    // This displays a multiview image by rendering to the multiview image and then\r\n    // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\r\n\r\n    // Render to a multiview texture\r\n    camera._resizeOrCreateMultiviewTexture(\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true),\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true)\r\n    );\r\n    if (!this._multiviewSceneUbo) {\r\n        this._createMultiviewUbo();\r\n    }\r\n    camera.outputRenderTarget = camera._multiviewTexture;\r\n    this._renderForCamera(camera);\r\n    camera.outputRenderTarget = null;\r\n\r\n    // Consume the multiview texture through a shader for each eye\r\n    for (let index = 0; index < camera._rigCameras.length; index++) {\r\n        const engine = this.getEngine();\r\n        this._activeCamera = camera._rigCameras[index];\r\n        engine.setViewport(this._activeCamera.viewport);\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._prepareFrame();\r\n            this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\r\n        }\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}