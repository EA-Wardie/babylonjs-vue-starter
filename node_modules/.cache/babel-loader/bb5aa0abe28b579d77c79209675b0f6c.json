{"ast":null,"code":"import { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n/**\n * Information about the result of picking within a scene\n * @see https://doc.babylonjs.com/divingDeeper/mesh/interactions/picking_collisions\n */\n\nvar PickingInfo =\n/** @class */\nfunction () {\n  function PickingInfo() {\n    /** @hidden */\n    this._pickingUnavailable = false;\n    /**\n     * If the pick collided with an object\n     */\n\n    this.hit = false;\n    /**\n     * Distance away where the pick collided\n     */\n\n    this.distance = 0;\n    /**\n     * The location of pick collision\n     */\n\n    this.pickedPoint = null;\n    /**\n     * The mesh corresponding the the pick collision\n     */\n\n    this.pickedMesh = null;\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\n\n    this.bu = 0;\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\n\n    this.bv = 0;\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n\n    this.faceId = -1;\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n\n    this.subMeshFaceId = -1;\n    /** Id of the the submesh that was picked */\n\n    this.subMeshId = 0;\n    /** If a sprite was picked, this will be the sprite the pick collided with */\n\n    this.pickedSprite = null;\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\n\n    this.thinInstanceIndex = -1;\n    /**\n     * The ray that was used to perform the picking.\n     */\n\n    this.ray = null;\n    /**\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\n     */\n\n    this.originMesh = null;\n    /**\n     * The aim-space transform of the input used for picking, if it is an XR input source.\n     */\n\n    this.aimTransform = null;\n    /**\n     * The grip-space transform of the input used for picking, if it is an XR input source.\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\n     */\n\n    this.gripTransform = null;\n  }\n  /**\n   * Gets the normal corresponding to the face the pick collided with\n   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\n   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map\n   * @returns The normal corresponding to the face the pick collided with\n   */\n\n\n  PickingInfo.prototype.getNormal = function (useWorldCoordinates, useVerticesNormals) {\n    if (useWorldCoordinates === void 0) {\n      useWorldCoordinates = false;\n    }\n\n    if (useVerticesNormals === void 0) {\n      useVerticesNormals = true;\n    }\n\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      return null;\n    }\n\n    var indices = this.pickedMesh.getIndices();\n\n    if (!indices) {\n      return null;\n    }\n\n    var result;\n\n    if (useVerticesNormals) {\n      var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\n      var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);\n      var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);\n      var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);\n      normal0 = normal0.scale(this.bu);\n      normal1 = normal1.scale(this.bv);\n      normal2 = normal2.scale(1.0 - this.bu - this.bv);\n      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n    } else {\n      var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\n      var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);\n      var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);\n      var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);\n      var p1p2 = vertex1.subtract(vertex2);\n      var p3p2 = vertex3.subtract(vertex2);\n      result = Vector3.Cross(p1p2, p3p2);\n    }\n\n    if (useWorldCoordinates) {\n      var wm = this.pickedMesh.getWorldMatrix();\n\n      if (this.pickedMesh.nonUniformScaling) {\n        TmpVectors.Matrix[0].copyFrom(wm);\n        wm = TmpVectors.Matrix[0];\n        wm.setTranslationFromFloats(0, 0, 0);\n        wm.invert();\n        wm.transposeToRef(TmpVectors.Matrix[1]);\n        wm = TmpVectors.Matrix[1];\n      }\n\n      result = Vector3.TransformNormal(result, wm);\n    }\n\n    result.normalize();\n    return result;\n  };\n  /**\n   * Gets the texture coordinates of where the pick occurred\n   * @returns the vector containing the coordinates of the texture\n   */\n\n\n  PickingInfo.prototype.getTextureCoordinates = function () {\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      return null;\n    }\n\n    var indices = this.pickedMesh.getIndices();\n\n    if (!indices) {\n      return null;\n    }\n\n    var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);\n\n    if (!uvs) {\n      return null;\n    }\n\n    var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n    var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n    var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n    uv0 = uv0.scale(this.bu);\n    uv1 = uv1.scale(this.bv);\n    uv2 = uv2.scale(1.0 - this.bu - this.bv);\n    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n  };\n\n  return PickingInfo;\n}();\n\nexport { PickingInfo };","map":{"version":3,"mappings":"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","names":["Vector3","Vector2","TmpVectors","VertexBuffer","PickingInfo","useWorldCoordinates","useVerticesNormals","pickedMesh","isVerticesDataPresent","NormalKind","indices","getIndices","result","normals","getVerticesData","normal0","FromArray","faceId","normal1","normal2","scale","bu","bv","x","y","z","positions","PositionKind","vertex1","vertex2","vertex3","p1p2","subtract","p3p2","Cross","wm","getWorldMatrix","nonUniformScaling","Matrix","copyFrom","setTranslationFromFloats","invert","transposeToRef","TransformNormal","normalize","UVKind","uvs","uv0","uv1","uv2"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Collisions/pickingInfo.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../types\";\r\nimport { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { Sprite } from \"../Sprites/sprite\";\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * Information about the result of picking within a scene\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/interactions/picking_collisions\r\n */\r\nexport class PickingInfo {\r\n    /** @hidden */\r\n    public _pickingUnavailable = false;\r\n\r\n    /**\r\n     * If the pick collided with an object\r\n     */\r\n    public hit = false;\r\n    /**\r\n     * Distance away where the pick collided\r\n     */\r\n    public distance = 0;\r\n    /**\r\n     * The location of pick collision\r\n     */\r\n    public pickedPoint: Nullable<Vector3> = null;\r\n    /**\r\n     * The mesh corresponding the the pick collision\r\n     */\r\n    public pickedMesh: Nullable<AbstractMesh> = null;\r\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bu = 0;\r\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bv = 0;\r\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public faceId = -1;\r\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public subMeshFaceId = -1;\r\n    /** Id of the the submesh that was picked */\r\n    public subMeshId = 0;\r\n    /** If a sprite was picked, this will be the sprite the pick collided with */\r\n    public pickedSprite: Nullable<Sprite> = null;\r\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\r\n    public thinInstanceIndex = -1;\r\n    /**\r\n     * The ray that was used to perform the picking.\r\n     */\r\n    public ray: Nullable<Ray> = null;\r\n    /**\r\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\r\n     */\r\n    public originMesh: Nullable<AbstractMesh> = null;\r\n    /**\r\n     * The aim-space transform of the input used for picking, if it is an XR input source.\r\n     */\r\n    public aimTransform: Nullable<TransformNode> = null;\r\n    /**\r\n     * The grip-space transform of the input used for picking, if it is an XR input source.\r\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\r\n     */\r\n    public gripTransform: Nullable<TransformNode> = null;\r\n\r\n    /**\r\n     * Gets the normal corresponding to the face the pick collided with\r\n     * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\r\n     * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map\r\n     * @returns The normal corresponding to the face the pick collided with\r\n     */\r\n    public getNormal(useWorldCoordinates = false, useVerticesNormals = true): Nullable<Vector3> {\r\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            return null;\r\n        }\r\n\r\n        const indices = this.pickedMesh.getIndices();\r\n\r\n        if (!indices) {\r\n            return null;\r\n        }\r\n\r\n        let result: Vector3;\r\n\r\n        if (useVerticesNormals) {\r\n            const normals = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n            let normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);\r\n            let normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);\r\n            let normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);\r\n\r\n            normal0 = normal0.scale(this.bu);\r\n            normal1 = normal1.scale(this.bv);\r\n            normal2 = normal2.scale(1.0 - this.bu - this.bv);\r\n\r\n            result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\r\n        } else {\r\n            const positions = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n            const vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);\r\n            const vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);\r\n            const vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);\r\n\r\n            const p1p2 = vertex1.subtract(vertex2);\r\n            const p3p2 = vertex3.subtract(vertex2);\r\n\r\n            result = Vector3.Cross(p1p2, p3p2);\r\n        }\r\n\r\n        if (useWorldCoordinates) {\r\n            let wm = this.pickedMesh.getWorldMatrix();\r\n\r\n            if (this.pickedMesh.nonUniformScaling) {\r\n                TmpVectors.Matrix[0].copyFrom(wm);\r\n                wm = TmpVectors.Matrix[0];\r\n                wm.setTranslationFromFloats(0, 0, 0);\r\n                wm.invert();\r\n                wm.transposeToRef(TmpVectors.Matrix[1]);\r\n\r\n                wm = TmpVectors.Matrix[1];\r\n            }\r\n\r\n            result = Vector3.TransformNormal(result, wm);\r\n        }\r\n\r\n        result.normalize();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates of where the pick occurred\r\n     * @returns the vector containing the coordinates of the texture\r\n     */\r\n    public getTextureCoordinates(): Nullable<Vector2> {\r\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            return null;\r\n        }\r\n\r\n        const indices = this.pickedMesh.getIndices();\r\n        if (!indices) {\r\n            return null;\r\n        }\r\n\r\n        const uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);\r\n        if (!uvs) {\r\n            return null;\r\n        }\r\n\r\n        let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\r\n        let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\r\n        let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\r\n\r\n        uv0 = uv0.scale(this.bu);\r\n        uv1 = uv1.scale(this.bv);\r\n        uv2 = uv2.scale(1.0 - this.bu - this.bv);\r\n\r\n        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}