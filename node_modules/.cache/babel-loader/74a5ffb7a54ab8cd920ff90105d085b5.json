{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { VertexBuffer } from \"../../../../Buffers/buffer.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\n/**\n * Block used to add morph targets support to vertex shader\n */\n\nvar MorphTargetsBlock =\n/** @class */\nfunction (_super) {\n  __extends(MorphTargetsBlock, _super);\n  /**\n   * Create a new MorphTargetsBlock\n   * @param name defines the block name\n   */\n\n\n  function MorphTargetsBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;\n\n    _this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    _this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    return _this;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  MorphTargetsBlock.prototype.getClassName = function () {\n    return \"MorphTargetsBlock\";\n  };\n\n  Object.defineProperty(MorphTargetsBlock.prototype, \"position\", {\n    /**\n     * Gets the position input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normal\", {\n    /**\n     * Gets the normal input component\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangent\", {\n    /**\n     * Gets the tangent input component\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uv\", {\n    /**\n     * Gets the tangent input component\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"positionOutput\", {\n    /**\n     * Gets the position output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normalOutput\", {\n    /**\n     * Gets the normal output component\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangentOutput\", {\n    /**\n     * Gets the tangent output component\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uvOutput\", {\n    /**\n     * Gets the tangent output component\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MorphTargetsBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"morphTargetInfluences\");\n  };\n\n  MorphTargetsBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.normal.isConnected) {\n      var normalInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"normal\";\n      });\n\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n\n      normalInput.output.connectTo(this.normal);\n    }\n\n    if (!this.tangent.isConnected) {\n      var tangentInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"tangent\";\n      });\n\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n\n      tangentInput.output.connectTo(this.tangent);\n    }\n\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  MorphTargetsBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (mesh.morphTargetManager) {\n      var morphTargetManager = mesh.morphTargetManager;\n\n      if ((morphTargetManager === null || morphTargetManager === void 0 ? void 0 : morphTargetManager.isUsingTextureForTargets) && morphTargetManager.numInfluencers !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\n        defines.markAsAttributesDirty();\n      }\n    }\n\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n\n    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\n  };\n\n  MorphTargetsBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\n      MaterialHelper.BindMorphTargetParameters(mesh, effect);\n\n      if (mesh.morphTargetManager.isUsingTextureForTargets) {\n        mesh.morphTargetManager._bind(effect);\n      }\n    }\n  };\n\n  MorphTargetsBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var state = vertexShaderState;\n    var repeatCount = defines.NUM_MORPH_INFLUENCERS;\n    var manager = mesh.morphTargetManager;\n    var hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    var hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    var hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\n    var injectionCode = \"\";\n\n    if ((manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) && repeatCount > 0) {\n      injectionCode += \"float vertexID;\\r\\n\";\n    }\n\n    for (var index = 0; index < repeatCount; index++) {\n      injectionCode += \"#ifdef MORPHTARGETS\\r\\n\";\n\n      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n        injectionCode += \"vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\r\\n\";\n        injectionCode += \"\".concat(positionOutput.associatedVariableName, \" += (readVector3FromRawSampler(\").concat(index, \", vertexID) - \").concat(position.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n        injectionCode += \"vertexID += 1.0;\\r\\n\";\n      } else {\n        injectionCode += \"\".concat(positionOutput.associatedVariableName, \" += (position\").concat(index, \" - \").concat(position.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n      }\n\n      if (hasNormals) {\n        injectionCode += \"#ifdef MORPHTARGETS_NORMAL\\r\\n\";\n\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += \"\".concat(normalOutput.associatedVariableName, \" += (readVector3FromRawSampler(\").concat(index, \", vertexID) - \").concat(normal.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n          injectionCode += \"vertexID += 1.0;\\r\\n\";\n        } else {\n          injectionCode += \"\".concat(normalOutput.associatedVariableName, \" += (normal\").concat(index, \" - \").concat(normal.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n        }\n\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasUVs) {\n        injectionCode += \"#ifdef MORPHTARGETS_UV\\r\\n\";\n\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += \"\".concat(uvOutput.associatedVariableName, \" += (readVector3FromRawSampler(\").concat(index, \", vertexID).xy - \").concat(uv.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n          injectionCode += \"vertexID += 1.0;\\r\\n\";\n        } else {\n          injectionCode += \"\".concat(uvOutput.associatedVariableName, \".xy += (uv_\").concat(index, \" - \").concat(uv.associatedVariableName, \".xy) * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n        }\n\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasTangents) {\n        injectionCode += \"#ifdef MORPHTARGETS_TANGENT\\r\\n\";\n\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += \"\".concat(tangentOutput.associatedVariableName, \" += (readVector3FromRawSampler(\").concat(index, \", vertexID) - \").concat(tangent.associatedVariableName, \") * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n        } else {\n          injectionCode += \"\".concat(tangentOutput.associatedVariableName, \".xyz += (tangent\").concat(index, \" - \").concat(tangent.associatedVariableName, \".xyz) * morphTargetInfluences[\").concat(index, \"];\\r\\n\");\n        }\n\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      injectionCode += \"#endif\\r\\n\";\n    }\n\n    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\n\n    if (repeatCount > 0) {\n      for (var index = 0; index < repeatCount; index++) {\n        state.attributes.push(VertexBuffer.PositionKind + index);\n\n        if (hasNormals) {\n          state.attributes.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (hasTangents) {\n          state.attributes.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (hasUVs) {\n          state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n    }\n  };\n\n  MorphTargetsBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for defines\n\n\n    state.sharedData.blocksWithDefines.push(this); // Register for binding\n\n    state.sharedData.bindableBlocks.push(this); // Register for repeatable content generation\n\n    state.sharedData.repeatableContentBlocks.push(this); // Emit code\n\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var comments = \"//\".concat(this.name);\n    state.uniforms.push(\"morphTargetInfluences\");\n    state.uniforms.push(\"morphTargetTextureInfo\");\n    state.uniforms.push(\"morphTargetTextureIndices\");\n    state.samplers.push(\"morphTargets\");\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\n      repeatKey: \"maxSimultaneousMorphTargets\"\n    });\n\n    state.compilationString += \"\".concat(this._declareOutput(positionOutput, state), \" = \").concat(position.associatedVariableName, \";\\r\\n\");\n    state.compilationString += \"#ifdef NORMAL\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(normalOutput, state), \" = \").concat(normal.associatedVariableName, \";\\r\\n\");\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(normalOutput, state), \" = vec3(0., 0., 0.);\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef TANGENT\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(tangentOutput, state), \" = \").concat(tangent.associatedVariableName, \";\\r\\n\");\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(tangentOutput, state), \" = vec3(0., 0., 0.);\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef UV1\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(uvOutput, state), \" = \").concat(uv.associatedVariableName, \";\\r\\n\");\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += \"\".concat(this._declareOutput(uvOutput, state), \" = vec2(0., 0.);\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\"; // Repeatable content\n\n    this._repeatableContentAnchor = state._repeatableContentAnchor;\n    state.compilationString += this._repeatableContentAnchor;\n    return this;\n  };\n\n  return MorphTargetsBlock;\n}(NodeMaterialBlock);\n\nexport { MorphTargetsBlock };\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","MaterialHelper","VertexBuffer","InputBlock","RegisterClass","__extends","name","_super","Vertex","_this","registerInput","Vector3","Vector2","registerOutput","MorphTargetsBlock","Object","_inputs","_outputs","state","_excludeVariableName","material","position","isConnected","positionInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","normal","normalInput","tangent","tangentInput","uv","uvInput","mesh","nodeMaterial","defines","morphTargetManager","isUsingTextureForTargets","numInfluencers","markAsAttributesDirty","_areAttributesDirty","PrepareDefinesForMorphTargets","effect","BindMorphTargetParameters","_bind","vertexShaderState","fragmentShaderState","positionOutput","normalOutput","tangentOutput","uvOutput","repeatCount","NUM_MORPH_INFLUENCERS","manager","hasNormals","supportsNormals","hasTangents","supportsTangents","hasUVs","supportsUVs","injectionCode","index","associatedVariableName","concat","compilationString","replace","_repeatableContentAnchor","attributes","push","PositionKind","NormalKind","TangentKind","UVKind","_buildBlock","call","sharedData","blocksWithDefines","bindableBlocks","repeatableContentBlocks","comments","uniforms","samplers","_emitFunctionFromInclude","repeatKey","_declareOutput"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Vertex/morphTargetsBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport { VertexBuffer } from \"../../../../Buffers/buffer\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\n\r\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\r\nexport class MorphTargetsBlock extends NodeMaterialBlock {\r\n    private _repeatableContentAnchor: string;\r\n\r\n    /**\r\n     * Create a new MorphTargetsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MorphTargetsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the position output component\r\n     */\r\n    public get positionOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal output component\r\n     */\r\n    public get normalOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get tangentOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get uvOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"morphTargetInfluences\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\");\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\");\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if ((<Mesh>mesh).morphTargetManager) {\r\n            const morphTargetManager = (<Mesh>mesh).morphTargetManager;\r\n\r\n            if (morphTargetManager?.isUsingTextureForTargets && morphTargetManager.numInfluencers !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n                defines.markAsAttributesDirty();\r\n            }\r\n        }\r\n\r\n        if (!defines._areAttributesDirty) {\r\n            return;\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\r\n            MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n\r\n            if (mesh.morphTargetManager.isUsingTextureForTargets) {\r\n                mesh.morphTargetManager._bind(effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const state = vertexShaderState;\r\n        const repeatCount = defines.NUM_MORPH_INFLUENCERS as number;\r\n\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        const hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\r\n\r\n        let injectionCode = \"\";\r\n\r\n        if (manager?.isUsingTextureForTargets && repeatCount > 0) {\r\n            injectionCode += `float vertexID;\\r\\n`;\r\n        }\r\n\r\n        for (let index = 0; index < repeatCount; index++) {\r\n            injectionCode += `#ifdef MORPHTARGETS\\r\\n`;\r\n            if (manager?.isUsingTextureForTargets) {\r\n                injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\r\\n`;\r\n                injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                injectionCode += `vertexID += 1.0;\\r\\n`;\r\n            } else {\r\n                injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n            }\r\n\r\n            if (hasNormals) {\r\n                injectionCode += `#ifdef MORPHTARGETS_NORMAL\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasUVs) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasTangents) {\r\n                injectionCode += `#ifdef MORPHTARGETS_TANGENT\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${tangent.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            injectionCode += `#endif\\r\\n`;\r\n        }\r\n\r\n        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\r\n\r\n        if (repeatCount > 0) {\r\n            for (let index = 0; index < repeatCount; index++) {\r\n                state.attributes.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (hasNormals) {\r\n                    state.attributes.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (hasTangents) {\r\n                    state.attributes.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (hasUVs) {\r\n                    state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Register for repeatable content generation\r\n        state.sharedData.repeatableContentBlocks.push(this);\r\n\r\n        // Emit code\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const comments = `//${this.name}`;\r\n\r\n        state.uniforms.push(\"morphTargetInfluences\");\r\n        state.uniforms.push(\"morphTargetTextureInfo\");\r\n        state.uniforms.push(\"morphTargetTextureIndices\");\r\n        state.samplers.push(\"morphTargets\");\r\n\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\r\n            repeatKey: \"maxSimultaneousMorphTargets\",\r\n        });\r\n\r\n        state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#ifdef NORMAL\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef TANGENT\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef UV1\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        // Repeatable content\r\n        this._repeatableContentAnchor = state._repeatableContentAnchor;\r\n        state.compilationString += this._repeatableContentAnchor;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);\r\n"]},"metadata":{},"sourceType":"module"}