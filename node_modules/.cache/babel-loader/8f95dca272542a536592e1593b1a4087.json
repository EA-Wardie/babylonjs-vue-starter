{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * A module that will enable pointer selection for motion controllers of XR Input Sources\n */\n\nvar WebXRControllerPointerSelection =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPointerSelection, _super);\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n\n\n  function WebXRControllerPointerSelection(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      var _a = _this._generateNewMeshPair(xrController.pointer),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh; // get two new meshes\n\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n\n      if (_this._attachedController) {\n        if (!_this._options.enablePointerSelectionOnAllControllers && _this._options.preferredHandedness && xrController.inputSource.handedness === _this._options.preferredHandedness) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!_this._options.enablePointerSelectionOnAllControllers) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      }\n\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return _this._attachTrackedPointerRayMode(xrController);\n\n        case \"gaze\":\n          return _this._attachGazeMode(xrController);\n\n        case \"screen\":\n          return _this._attachScreenRayMode(xrController);\n      }\n    };\n\n    _this._controllers = {};\n    _this._tmpVectorForPickCompare = new Vector3();\n    /**\n     * Disable lighting on the laser pointer (so it will always be visible)\n     */\n\n    _this.disablePointerLighting = true;\n    /**\n     * Disable lighting on the selection mesh (so it will always be visible)\n     */\n\n    _this.disableSelectionMeshLighting = true;\n    /**\n     * Should the laser pointer be displayed\n     */\n\n    _this.displayLaserPointer = true;\n    /**\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\n     */\n\n    _this.displaySelectionMesh = true;\n    /**\n     * This color will be set to the laser pointer when selection is triggered\n     */\n\n    _this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\n     * Default color of the laser pointer\n     */\n\n    _this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\n     * default color of the selection ring\n     */\n\n    _this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n\n    _this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    _this._identityMatrix = Matrix.Identity();\n    _this._screenCoordinatesRef = Vector3.Zero();\n    _this._viewportRef = new Viewport(0, 0, 0, 0);\n    _this._scene = _this._xrSessionManager.scene;\n    return _this;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRControllerPointerSelection.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n\n    if (this._options.gazeCamera) {\n      var webXRCamera = this._options.gazeCamera;\n\n      var _a = this._generateNewMeshPair(webXRCamera),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh;\n\n      this._controllers[\"camera\"] = {\n        webXRCamera: webXRCamera,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n\n      this._attachGazeMode();\n    }\n\n    return true;\n  };\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRControllerPointerSelection.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n    return true;\n  };\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getMeshUnderPointer = function (controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getXRControllerByPointerId = function (id) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @param id\n   * @hidden\n   */\n\n\n  WebXRControllerPointerSelection.prototype._getPointerSelectionDisabledByPointerId = function (id) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].disabledByNearInteraction;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * @param id\n   * @param state\n   * @hidden\n   */\n\n\n  WebXRControllerPointerSelection.prototype._setPointerSelectionDisabledByPointerId = function (id, state) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        this._controllers[keys[i]].disabledByNearInteraction = state;\n        return;\n      }\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    Object.keys(this._controllers).forEach(function (id) {\n      // only do this for the selected pointer\n      var controllerData = _this._controllers[id];\n\n      if (!_this._options.enablePointerSelectionOnAllControllers && id !== _this._attachedController || controllerData.disabledByNearInteraction) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n\n      controllerData.laserPointer.isVisible = _this.displayLaserPointer;\n      var controllerGlobalPosition; // Every frame check collisions/input\n\n      if (controllerData.xrController) {\n        controllerGlobalPosition = controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n\n      if (_this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = _this._options.maxPointerDistance;\n      } // update pointerX and pointerY of the scene. Only if the flag is set to true!\n\n\n      if (!_this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        var scene = _this._xrSessionManager.scene;\n        var camera = _this._options.xrInput.xrCamera;\n\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), _this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, _this._identityMatrix, scene.getTransformMatrix(), _this._viewportRef, _this._screenCoordinatesRef); // stay safe\n\n          if (typeof _this._screenCoordinatesRef.x === \"number\" && typeof _this._screenCoordinatesRef.y === \"number\" && !isNaN(_this._screenCoordinatesRef.x) && !isNaN(_this._screenCoordinatesRef.y)) {\n            scene.pointerX = _this._screenCoordinatesRef.x;\n            scene.pointerY = _this._screenCoordinatesRef.y;\n            controllerData.screenCoordinates = {\n              x: _this._screenCoordinatesRef.x,\n              y: _this._screenCoordinatesRef.y\n            };\n          }\n        }\n      }\n\n      var utilityScenePick = null;\n\n      if (_this._utilityLayerScene) {\n        utilityScenePick = _this._utilityLayerScene.pickWithRay(controllerData.tmpRay, _this._utilityLayerScene.pointerMovePredicate || _this.raySelectionPredicate);\n      }\n\n      var originalScenePick = _this._scene.pickWithRay(controllerData.tmpRay, _this._scene.pointerMovePredicate || _this.raySelectionPredicate);\n\n      if (!utilityScenePick || !utilityScenePick.hit) {\n        // No hit in utility scene\n        controllerData.pick = originalScenePick;\n      } else if (!originalScenePick || !originalScenePick.hit) {\n        // No hit in original scene\n        controllerData.pick = utilityScenePick;\n      } else if (utilityScenePick.distance < originalScenePick.distance) {\n        // Hit is closer in utility scene\n        controllerData.pick = utilityScenePick;\n      } else {\n        // Hit is closer in original scene\n        controllerData.pick = originalScenePick;\n      }\n\n      if (controllerData.pick && controllerData.xrController) {\n        controllerData.pick.aimTransform = controllerData.xrController.pointer;\n        controllerData.pick.gripTransform = controllerData.xrController.grip || null;\n      }\n\n      var pick = controllerData.pick;\n\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        _this._updatePointerDistance(controllerData.laserPointer, pick.distance); // Update cursor state\n\n\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance); // To avoid z-fighting\n\n        var pickNormal = _this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n\n        var deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n\n        if (pickNormal) {\n          var axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          var axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n\n        controllerData.selectionMesh.isVisible = true && _this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n\n        _this._updatePointerDistance(controllerData.laserPointer, 1);\n\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  };\n\n  Object.defineProperty(WebXRControllerPointerSelection.prototype, \"_utilityLayerScene\", {\n    get: function get() {\n      return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRControllerPointerSelection.prototype._attachGazeMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"]; // attached when touched, detaches when raised\n\n    var timeToSelect = this._options.timeToSelect || 3000;\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\n    var oldPick = new PickingInfo();\n    var discMesh = CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    var timer = 0;\n    var downTriggered = false;\n    var pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!controllerData.pick) {\n        return;\n      }\n\n      _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n\n      if (controllerData.pick.hit) {\n        if (!_this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n\n          timer += _this._scene.getEngine().getDeltaTime();\n\n          if (timer >= timeToSelect) {\n            _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit); // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\n\n\n            downTriggered = true; // pointer up right after down, if disable on touch out\n\n            if (_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n\n            discMesh.isVisible = false;\n          } else {\n            var scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n          }\n\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n\n      _this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n\n      oldPick = controllerData.pick;\n    });\n\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(function () {\n        if (controllerData.pick && !_this._options.disablePointerUpOnTouchOut && downTriggered) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n          controllerData.finalPointerUpTriggered = true;\n        }\n\n        discMesh.dispose();\n      });\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._attachScreenRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n    var downTriggered = false;\n    var pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n      if (!controllerData.pick || _this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n\n      if (!downTriggered) {\n        _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n\n        controllerData.pointerDownTriggered = true;\n        downTriggered = true;\n\n        if (_this._options.disablePointerUpOnTouchOut) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n        }\n      } else {\n        _this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    xrController.onDisposeObservable.addOnce(function () {\n      _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n      _this._xrSessionManager.runInXRFrame(function () {\n        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !_this._options.disablePointerUpOnTouchOut) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n          controllerData.finalPointerUpTriggered = true;\n        }\n      });\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._attachTrackedPointerRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n\n    var pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      controllerData.laserPointer.material.disableLighting = _this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = _this.disableSelectionMeshLighting;\n\n      if (controllerData.pick) {\n        _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n        _this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n\n    if (xrController.inputSource.gamepad) {\n      var init = function init(motionController) {\n        if (_this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(_this._options.overrideButtonId);\n        }\n\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(function (component) {\n          if (component.changes.pressed) {\n            var pressed = component.changes.pressed.current;\n\n            if (controllerData.pick) {\n              if (_this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === _this._attachedController) {\n                _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n                if (pressed) {\n                  _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n\n                  controllerData.pointerDownTriggered = true;\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n                } else {\n                  _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n                }\n              }\n            } else {\n              if (pressed && !_this._options.enablePointerSelectionOnAllControllers && !_this._options.disableSwitchOnClick) {\n                _this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      var selectStartListener = function selectStartListener(event) {\n        _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n\n          controllerData.pointerDownTriggered = true;\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n        }\n      };\n\n      var selectEndListener = function selectEndListener(event) {\n        _this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n        }\n      };\n\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._convertNormalToDirectionOfRay = function (normal, ray) {\n    if (normal) {\n      var angle = Math.acos(Vector3.Dot(normal, ray.direction));\n\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n\n    return normal;\n  };\n\n  WebXRControllerPointerSelection.prototype._detachController = function (xrControllerUniqueId) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(function (eventName) {\n        var func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n\n        if (func) {\n          _this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n\n    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\n      // Stay safe and fire a pointerup, in case it wasn't already triggered\n      var pointerEventInit_1 = {\n        pointerId: controllerData.id,\n        pointerType: \"xr\"\n      };\n\n      this._xrSessionManager.runInXRFrame(function () {\n        _this._augmentPointerInit(pointerEventInit_1, controllerData.id, controllerData.screenCoordinates);\n\n        _this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit_1);\n      });\n    }\n\n    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(function () {\n      try {\n        controllerData.selectionMesh.dispose();\n        controllerData.laserPointer.dispose(); // remove from the map\n\n        delete _this._controllers[xrControllerUniqueId];\n\n        if (_this._attachedController === xrControllerUniqueId) {\n          // check for other controllers\n          var keys = Object.keys(_this._controllers);\n\n          if (keys.length) {\n            _this._attachedController = keys[0];\n          } else {\n            _this._attachedController = \"\";\n          }\n        }\n      } catch (e) {\n        Tools.Warn(\"controller already detached.\");\n      }\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._generateNewMeshPair = function (meshParent) {\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    var laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n\n    this._updatePointerDistance(laserPointer, 1);\n\n    laserPointer.isPickable = false;\n    laserPointer.isVisible = false; // Create a gaze tracker for the  XR controller\n\n    var selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    var targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    return {\n      laserPointer: laserPointer,\n      selectionMesh: selectionMesh\n    };\n  };\n\n  WebXRControllerPointerSelection.prototype._pickingMoved = function (oldPick, newPick) {\n    var _a;\n\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n\n    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n\n    var delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n\n    var length = this._tmpVectorForPickCompare.length();\n\n    if (length > delta) {\n      return true;\n    }\n\n    return false;\n  };\n\n  WebXRControllerPointerSelection.prototype._updatePointerDistance = function (_laserPointer, distance) {\n    if (distance === void 0) {\n      distance = 100;\n    }\n\n    _laserPointer.scaling.y = distance; // a bit of distance from the controller\n\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n\n    _laserPointer.position.z = distance / 2 + 0.05;\n  };\n\n  WebXRControllerPointerSelection.prototype._augmentPointerInit = function (pointerEventInit, id, screenCoordinates) {\n    pointerEventInit.pointerId = id;\n    pointerEventInit.pointerType = \"xr\";\n\n    if (screenCoordinates) {\n      pointerEventInit.screenX = screenCoordinates.x;\n      pointerEventInit.screenY = screenCoordinates.y;\n    }\n  };\n\n  Object.defineProperty(WebXRControllerPointerSelection.prototype, \"lasterPointerDefaultColor\", {\n    /** @hidden */\n    get: function get() {\n      // here due to a typo\n      return this.laserPointerDefaultColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WebXRControllerPointerSelection._IdCounter = 200;\n  /**\n   * The module's name\n   */\n\n  WebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRControllerPointerSelection.Version = 1;\n  return WebXRControllerPointerSelection;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPointerSelection }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPointerSelection(xrSessionManager, options);\n  };\n}, WebXRControllerPointerSelection.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Matrix","Vector3","Color3","Axis","StandardMaterial","CreateCylinder","CreateTorus","Ray","PickingInfo","WebXRAbstractFeature","UtilityLayerRenderer","Viewport","Tools","__extends","_xrSessionManager","_options","_super","_this","xrController","_controllers","uniqueId","_generateNewMeshPair","pointer","laserPointer","selectionMesh","meshUnderPointer","pick","tmpRay","disabledByNearInteraction","id","WebXRControllerPointerSelection","_IdCounter","_attachedController","enablePointerSelectionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachTrackedPointerRayMode","_attachGazeMode","_attachScreenRayMode","Identity","Zero","_scene","scene","attach","call","xrInput","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","constantlyUpdateMeshUnderPointer","gazeCamera","webXRCamera","detach","Object","keys","controllerId","i","length","state","_xrFrame","controllerData","isVisible","displayLaserPointer","controllerGlobalPosition","position","getWorldPointerRayToRef","getForwardRayToRef","maxPointerDistance","disableScenePointerVectorUpdate","camera","xrCamera","viewport","toGlobalToRef","getEngine","getRenderWidth","getRenderHeight","_viewportRef","ProjectToRef","_identityMatrix","getTransformMatrix","_screenCoordinatesRef","x","y","isNaN","pointerX","pointerY","screenCoordinates","utilityScenePick","_utilityLayerScene","pickWithRay","pointerMovePredicate","raySelectionPredicate","originalScenePick","hit","distance","aimTransform","gripTransform","grip","pickedPoint","_updatePointerDistance","copyFrom","scaling","Math","sqrt","z","pickNormal","_convertNormalToDirectionOfRay","getNormal","deltaFighting","axis1","Cross","Y","axis2","RotationFromAxisToRef","rotation","addInPlace","scale","displaySelectionMesh","pickedMesh","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","timeToSelect","sceneToRenderTo","useUtilityLayer","oldPick","discMesh","diameter","thickness","tessellation","isPickable","parent","timer","downTriggered","pointerEventInit","pointerId","pointerType","onFrameObserver","onXRFrameObservable","add","_augmentPointerInit","material","alpha","_pickingMoved","getDeltaTime","simulatePointerDown","disablePointerUpOnTouchOut","simulatePointerUp","scaleFactor","set","simulatePointerMove","renderingGroupId","undefined","onDisposeObservable","addOnce","finalPointerUpTriggered","dispose","pointerDownTriggered","runInXRFrame","forceGazeMode","disableLighting","disablePointerLighting","disableSelectionMeshLighting","gamepad","init","motionController","overrideButtonId","selectionComponent","getComponent","getMainComponent","onButtonChangedObserver","onButtonStateChangedObservable","component","changes","pressed","current","emissiveColor","selectionMeshPickedColor","laserPointerPickedColor","selectionMeshDefaultColor","laserPointerDefaultColor","disableSwitchOnClick","onMotionControllerInitObservable","selectStartListener","event","selectEndListener","eventListeners","selectend","selectstart","session","addEventListener","normal","ray","angle","acos","Dot","direction","PI","scaleInPlace","xrControllerUniqueId","remove","eventName","func","removeEventListener","pointerEventInit_1","onBeforeRenderObservable","e","Warn","meshParent","customLasterPointerMeshGenerator","height","diameterTop","diameterBottom","subdivisions","laserPointerMaterial","customSelectionMeshGenerator","bakeCurrentTransformIntoVertices","targetMat","specularColor","Black","backFaceCulling","newPick","_a","subtractToRef","_tmpVectorForPickCompare","abs","delta","gazeModePointerMovedFactor","_laserPointer","useRightHandedSystem","screenX","screenY","POINTER_SELECTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRControllerPointerSelection.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPointerSelectionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     * @hidden\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     * @param state\r\n     * @hidden\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y)\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.pointerDownTriggered = true;\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module"}