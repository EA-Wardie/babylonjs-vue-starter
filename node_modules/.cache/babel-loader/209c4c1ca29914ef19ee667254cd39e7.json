{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This represents a set of one or more post processes in Babylon.\n * A post process can be used to apply a shader to a texture after it is rendered.\n * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\n */\n\nvar PostProcessRenderEffect =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a post process render effect.\n   * A post process can be used to apply a shader to a texture after it is rendered.\n   * @param engine The engine the effect is tied to\n   * @param name The name of the effect\n   * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\n   * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\n   */\n  function PostProcessRenderEffect(engine, name, getPostProcesses, singleInstance) {\n    this._name = name;\n    this._singleInstance = singleInstance || true;\n    this._getPostProcesses = getPostProcesses;\n    this._cameras = {};\n    this._indicesForCamera = {};\n    this._postProcesses = {};\n  }\n\n  Object.defineProperty(PostProcessRenderEffect.prototype, \"isSupported\", {\n    /**\n     * Checks if all the post processes in the effect are supported.\n     */\n    get: function get() {\n      for (var index in this._postProcesses) {\n        if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\n          var pps = this._postProcesses[index];\n\n          for (var ppIndex = 0; ppIndex < pps.length; ppIndex++) {\n            if (!pps[ppIndex].isSupported) {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Updates the current state of the effect\n   * @hidden\n   */\n\n  PostProcessRenderEffect.prototype._update = function () {};\n  /**\n   * Attaches the effect on cameras\n   * @param cameras The camera to attach to.\n   * @hidden\n   */\n\n\n  PostProcessRenderEffect.prototype._attachCameras = function (cameras) {\n    var _this = this;\n\n    var cameraKey;\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      var camera = cams[i];\n\n      if (!camera) {\n        return \"continue\";\n      }\n\n      var cameraName = camera.name;\n\n      if (this_1._singleInstance) {\n        cameraKey = 0;\n      } else {\n        cameraKey = cameraName;\n      }\n\n      if (!this_1._postProcesses[cameraKey]) {\n        var postProcess = this_1._getPostProcesses();\n\n        if (postProcess) {\n          this_1._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\n        }\n      }\n\n      if (!this_1._indicesForCamera[cameraName]) {\n        this_1._indicesForCamera[cameraName] = [];\n      }\n\n      this_1._postProcesses[cameraKey].forEach(function (postProcess) {\n        var index = camera.attachPostProcess(postProcess);\n\n        _this._indicesForCamera[cameraName].push(index);\n      });\n\n      if (!this_1._cameras[cameraName]) {\n        this_1._cameras[cameraName] = camera;\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < cams.length; i++) {\n      _loop_1(i);\n    }\n  };\n  /**\n   * Detaches the effect on cameras\n   * @param cameras The camera to detach from.\n   * @hidden\n   */\n\n\n  PostProcessRenderEffect.prototype._detachCameras = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var _loop_2 = function _loop_2(i) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n      var postProcesses = this_2._postProcesses[this_2._singleInstance ? 0 : cameraName];\n\n      if (postProcesses) {\n        postProcesses.forEach(function (postProcess) {\n          camera.detachPostProcess(postProcess);\n        });\n      }\n\n      if (this_2._cameras[cameraName]) {\n        this_2._cameras[cameraName] = null;\n      }\n    };\n\n    var this_2 = this;\n\n    for (var i = 0; i < cams.length; i++) {\n      _loop_2(i);\n    }\n  };\n  /**\n   * Enables the effect on given cameras\n   * @param cameras The camera to enable.\n   * @hidden\n   */\n\n\n  PostProcessRenderEffect.prototype._enable = function (cameras) {\n    var _this = this;\n\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var _loop_3 = function _loop_3(i) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n\n      var _loop_4 = function _loop_4(j) {\n        if (camera._postProcesses[this_3._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this_3._indicesForCamera[cameraName][j]] === null) {\n          this_3._postProcesses[this_3._singleInstance ? 0 : cameraName].forEach(function (postProcess) {\n            cams[i].attachPostProcess(postProcess, _this._indicesForCamera[cameraName][j]);\n          });\n        }\n      };\n\n      for (var j = 0; j < this_3._indicesForCamera[cameraName].length; j++) {\n        _loop_4(j);\n      }\n    };\n\n    var this_3 = this;\n\n    for (var i = 0; i < cams.length; i++) {\n      _loop_3(i);\n    }\n  };\n  /**\n   * Disables the effect on the given cameras\n   * @param cameras The camera to disable.\n   * @hidden\n   */\n\n\n  PostProcessRenderEffect.prototype._disable = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var _loop_5 = function _loop_5(i) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n\n      this_4._postProcesses[this_4._singleInstance ? 0 : cameraName].forEach(function (postProcess) {\n        camera.detachPostProcess(postProcess);\n      });\n    };\n\n    var this_4 = this;\n\n    for (var i = 0; i < cams.length; i++) {\n      _loop_5(i);\n    }\n  };\n  /**\n   * Gets a list of the post processes contained in the effect.\n   * @param camera The camera to get the post processes on.\n   * @returns The list of the post processes in the effect.\n   */\n\n\n  PostProcessRenderEffect.prototype.getPostProcesses = function (camera) {\n    if (this._singleInstance) {\n      return this._postProcesses[0];\n    } else {\n      if (!camera) {\n        return null;\n      }\n\n      return this._postProcesses[camera.name];\n    }\n  };\n\n  return PostProcessRenderEffect;\n}();\n\nexport { PostProcessRenderEffect };","map":{"version":3,"mappings":"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","names":["Tools","engine","name","getPostProcesses","singleInstance","_name","_singleInstance","_getPostProcesses","_cameras","_indicesForCamera","_postProcesses","Object","PostProcessRenderEffect","index","prototype","hasOwnProperty","call","pps","ppIndex","length","isSupported","cameras","cameraKey","cams","MakeArray","i","camera","cameraName","this_1","postProcess","Array","isArray","forEach","attachPostProcess","_this","push","postProcesses","this_2","detachPostProcess","j","this_3","undefined","this_4"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/PostProcesses/RenderPipeline/postProcessRenderEffect.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\r\nexport class PostProcessRenderEffect {\r\n    private _postProcesses: { [Key: string]: Array<PostProcess> };\r\n    private _getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>;\r\n\r\n    private _singleInstance: boolean;\r\n\r\n    private _cameras: { [key: string]: Nullable<Camera> };\r\n    private _indicesForCamera: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Name of the effect\r\n     * @hidden\r\n     */\r\n    public _name: string;\r\n\r\n    /**\r\n     * Instantiates a post process render effect.\r\n     * A post process can be used to apply a shader to a texture after it is rendered.\r\n     * @param engine The engine the effect is tied to\r\n     * @param name The name of the effect\r\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n     */\r\n    constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean) {\r\n        this._name = name;\r\n        this._singleInstance = singleInstance || true;\r\n\r\n        this._getPostProcesses = getPostProcesses;\r\n\r\n        this._cameras = {};\r\n        this._indicesForCamera = {};\r\n\r\n        this._postProcesses = {};\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const index in this._postProcesses) {\r\n            if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\r\n                const pps = this._postProcesses[index];\r\n                for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\r\n                    if (!pps[ppIndex].isSupported) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Updates the current state of the effect\r\n     * @hidden\r\n     */\r\n    public _update(): void {}\r\n\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: Camera): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: any): void {\r\n        let cameraKey;\r\n\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            const cameraName = camera.name;\r\n\r\n            if (this._singleInstance) {\r\n                cameraKey = 0;\r\n            } else {\r\n                cameraKey = cameraName;\r\n            }\r\n\r\n            if (!this._postProcesses[cameraKey]) {\r\n                const postProcess = this._getPostProcesses();\r\n                if (postProcess) {\r\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\r\n                }\r\n            }\r\n\r\n            if (!this._indicesForCamera[cameraName]) {\r\n                this._indicesForCamera[cameraName] = [];\r\n            }\r\n\r\n            this._postProcesses[cameraKey].forEach((postProcess: PostProcess) => {\r\n                const index = camera.attachPostProcess(postProcess);\r\n\r\n                this._indicesForCamera[cameraName].push(index);\r\n            });\r\n\r\n            if (!this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera: Camera = cams[i];\r\n            const cameraName: string = camera.name;\r\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n\r\n            if (postProcesses) {\r\n                postProcesses.forEach((postProcess: PostProcess) => {\r\n                    camera.detachPostProcess(postProcess);\r\n                });\r\n            }\r\n\r\n            if (this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: Camera): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n\r\n            for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\r\n                if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {\r\n                    this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                        cams![i].attachPostProcess(postProcess, this._indicesForCamera[cameraName][j]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: Camera): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                camera.detachPostProcess(postProcess);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of the post processes contained in the effect.\r\n     * @param camera The camera to get the post processes on.\r\n     * @returns The list of the post processes in the effect.\r\n     */\r\n    public getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>> {\r\n        if (this._singleInstance) {\r\n            return this._postProcesses[0];\r\n        } else {\r\n            if (!camera) {\r\n                return null;\r\n            }\r\n            return this._postProcesses[camera.name];\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}