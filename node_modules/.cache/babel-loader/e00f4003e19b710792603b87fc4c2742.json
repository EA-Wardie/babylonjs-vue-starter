{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/web.atob.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\n/**\n * Effect containing vertex and fragment shader that can be executed on an object.\n */\n\nvar Effect =\n/** @class */\nfunction () {\n  /**\n   * Instantiates an effect.\n   * An effect can be used to create/manage/execute vertex and fragment shaders.\n   * @param baseName Name of the effect.\n   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\n   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\n   * @param samplers List of sampler variables that will be passed to the shader.\n   * @param engine Engine to be used to render the effect\n   * @param defines Define statements to be added to the shader.\n   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\n   * @param onCompiled Callback that will be called when the shader is compiled.\n   * @param onError Callback that will be called if an error occurs during shader compilation.\n   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\n   * @param key Effect Key identifying uniquely compiled shader variants\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n  function Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters, key, shaderLanguage) {\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (fallbacks === void 0) {\n      fallbacks = null;\n    }\n\n    if (onCompiled === void 0) {\n      onCompiled = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (key === void 0) {\n      key = \"\";\n    }\n\n    if (shaderLanguage === void 0) {\n      shaderLanguage = ShaderLanguage.GLSL;\n    }\n\n    var _this = this;\n\n    var _a, _b, _c;\n    /**\n     * Name of the effect.\n     */\n\n\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n\n    this.onError = null;\n    /**\n     * Callback that will be called when effect is bound.\n     */\n\n    this.onBind = null;\n    /**\n     * Unique ID of the effect.\n     */\n\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n\n    this.onErrorObservable = new Observable();\n    /** @hidden */\n\n    this._onBindObservable = null;\n    /**\n     * @hidden\n     * Specifies if the effect was previously ready\n     */\n\n    this._wasPreviouslyReady = false;\n    /** @hidden */\n\n    this._bonesComputationForcedToCPU = false;\n    /** @hidden */\n\n    this._uniformBuffersNames = {};\n    /** @hidden */\n\n    this._multiTarget = false;\n    this._samplers = {};\n    this._isReady = false;\n    this._compilationError = \"\";\n    this._allFallbacksProcessed = false;\n    this._uniforms = {};\n    /**\n     * Key for the effect.\n     * @hidden\n     */\n\n    this._key = \"\";\n    this._fallbacks = null;\n    this._vertexSourceCodeOverride = \"\";\n    this._fragmentSourceCodeOverride = \"\";\n    this._transformFeedbackVaryings = null;\n    /**\n     * Compiled shader to webGL program.\n     * @hidden\n     */\n\n    this._pipelineContext = null;\n    /** @hidden */\n\n    this._vertexSourceCode = \"\";\n    /** @hidden */\n\n    this._fragmentSourceCode = \"\";\n    /** @hidden */\n\n    this._rawVertexSourceCode = \"\";\n    /** @hidden */\n\n    this._rawFragmentSourceCode = \"\";\n    this.name = baseName;\n    this._key = key;\n    var processCodeAfterIncludes = undefined;\n    var processFinalCode = null;\n\n    if (attributesNamesOrOptions.attributes) {\n      var options = attributesNamesOrOptions;\n      this._engine = uniformsNamesOrEngine;\n      this._attributesNames = options.attributes;\n      this._uniformsNames = options.uniformsNames.concat(options.samplers);\n      this._samplerList = options.samplers.slice();\n      this.defines = options.defines;\n      this.onError = options.onError;\n      this.onCompiled = options.onCompiled;\n      this._fallbacks = options.fallbacks;\n      this._indexParameters = options.indexParameters;\n      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\n      this._multiTarget = !!options.multiTarget;\n      this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;\n\n      if (options.uniformBuffersNames) {\n        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\n\n        for (var i = 0; i < options.uniformBuffersNames.length; i++) {\n          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n        }\n      }\n\n      processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;\n      processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : undefined;\n    } else {\n      this._engine = engine;\n      this.defines = defines == null ? \"\" : defines;\n      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n      this._samplerList = samplers ? samplers.slice() : [];\n      this._attributesNames = attributesNamesOrOptions;\n      this._uniformBuffersNamesList = [];\n      this._shaderLanguage = shaderLanguage;\n      this.onError = onError;\n      this.onCompiled = onCompiled;\n      this._indexParameters = indexParameters;\n      this._fallbacks = fallbacks;\n    }\n\n    this._attributeLocationByName = {};\n    this.uniqueId = Effect._UniqueIdSeed++;\n    var vertexSource;\n    var fragmentSource;\n    var hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n\n    if (baseName.vertexSource) {\n      vertexSource = \"source:\" + baseName.vertexSource;\n    } else if (baseName.vertexElement) {\n      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\n\n      if (!vertexSource) {\n        vertexSource = baseName.vertexElement;\n      }\n    } else {\n      vertexSource = baseName.vertex || baseName;\n    }\n\n    if (baseName.fragmentSource) {\n      fragmentSource = \"source:\" + baseName.fragmentSource;\n    } else if (baseName.fragmentElement) {\n      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\n\n      if (!fragmentSource) {\n        fragmentSource = baseName.fragmentElement;\n      }\n    } else {\n      fragmentSource = baseName.fragment || baseName;\n    }\n\n    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\n    var processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: this._indexParameters,\n      isFragment: false,\n      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n      processor: this._engine._getShaderProcessor(this._shaderLanguage),\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\n      includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: this._processingContext,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n      processCodeAfterIncludes: processCodeAfterIncludes\n    };\n    var shaderCodes = [undefined, undefined];\n\n    var shadersLoaded = function shadersLoaded() {\n      if (shaderCodes[0] && shaderCodes[1]) {\n        processorOptions.isFragment = true;\n        var migratedVertexCode_1 = shaderCodes[0],\n            fragmentCode = shaderCodes[1];\n        ShaderProcessor.Process(fragmentCode, processorOptions, function (migratedFragmentCode) {\n          if (processFinalCode) {\n            migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\n          }\n\n          var finalShaders = ShaderProcessor.Finalize(migratedVertexCode_1, migratedFragmentCode, processorOptions);\n\n          _this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);\n        }, _this._engine);\n      }\n    };\n\n    this._loadShader(vertexSource, \"Vertex\", \"\", function (vertexCode) {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.Process(vertexCode, processorOptions, function (migratedVertexCode) {\n        _this._rawVertexSourceCode = vertexCode;\n\n        if (processFinalCode) {\n          migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\n        }\n\n        shaderCodes[0] = migratedVertexCode;\n        shadersLoaded();\n      }, _this._engine);\n    });\n\n    this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", function (fragmentCode) {\n      _this._rawFragmentSourceCode = fragmentCode;\n      shaderCodes[1] = fragmentCode;\n      shadersLoaded();\n    });\n  }\n\n  Object.defineProperty(Effect, \"ShadersRepository\", {\n    /**\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\n     */\n    get: function get() {\n      return EngineShaderStore.ShadersRepository;\n    },\n    set: function set(repo) {\n      EngineShaderStore.ShadersRepository = repo;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"onBindObservable\", {\n    /**\n     * Observable that will be called when effect is bound.\n     */\n    get: function get() {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Effect.prototype._useFinalCode = function (migratedVertexCode, migratedFragmentCode, baseName) {\n    if (baseName) {\n      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\n      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\n      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\n      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\n    } else {\n      this._vertexSourceCode = migratedVertexCode;\n      this._fragmentSourceCode = migratedFragmentCode;\n    }\n\n    this._prepareEffect();\n  };\n\n  Object.defineProperty(Effect.prototype, \"key\", {\n    /**\n     * Unique key for this effect\n     */\n    get: function get() {\n      return this._key;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n\n  Effect.prototype.isReady = function () {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  Effect.prototype._isReadyInternal = function () {\n    if (this._isReady) {\n      return true;\n    }\n\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n\n    return false;\n  };\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n\n\n  Effect.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n\n\n  Effect.prototype.getPipelineContext = function () {\n    return this._pipelineContext;\n  };\n  /**\n   * The set of names of attribute variables for the shader.\n   * @returns An array of attribute names.\n   */\n\n\n  Effect.prototype.getAttributesNames = function () {\n    return this._attributesNames;\n  };\n  /**\n   * Returns the attribute at the given index.\n   * @param index The index of the attribute.\n   * @returns The location of the attribute.\n   */\n\n\n  Effect.prototype.getAttributeLocation = function (index) {\n    return this._attributes[index];\n  };\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param name of the attribute to look up.\n   * @returns the attribute location.\n   */\n\n\n  Effect.prototype.getAttributeLocationByName = function (name) {\n    return this._attributeLocationByName[name];\n  };\n  /**\n   * The number of attributes.\n   * @returns the number of attributes.\n   */\n\n\n  Effect.prototype.getAttributesCount = function () {\n    return this._attributes.length;\n  };\n  /**\n   * Gets the index of a uniform variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the index.\n   */\n\n\n  Effect.prototype.getUniformIndex = function (uniformName) {\n    return this._uniformsNames.indexOf(uniformName);\n  };\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the location of the uniform.\n   */\n\n\n  Effect.prototype.getUniform = function (uniformName) {\n    return this._uniforms[uniformName];\n  };\n  /**\n   * Returns an array of sampler variable names\n   * @returns The array of sampler variable names.\n   */\n\n\n  Effect.prototype.getSamplers = function () {\n    return this._samplerList;\n  };\n  /**\n   * Returns an array of uniform variable names\n   * @returns The array of uniform variable names.\n   */\n\n\n  Effect.prototype.getUniformNames = function () {\n    return this._uniformsNames;\n  };\n  /**\n   * Returns an array of uniform buffer variable names\n   * @returns The array of uniform buffer variable names.\n   */\n\n\n  Effect.prototype.getUniformBuffersNames = function () {\n    return this._uniformBuffersNamesList;\n  };\n  /**\n   * Returns the index parameters used to create the effect\n   * @returns The index parameters object\n   */\n\n\n  Effect.prototype.getIndexParameters = function () {\n    return this._indexParameters;\n  };\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n\n\n  Effect.prototype.getCompilationError = function () {\n    return this._compilationError;\n  };\n  /**\n   * Gets a boolean indicating that all fallbacks were used during compilation\n   * @returns true if all fallbacks were used\n   */\n\n\n  Effect.prototype.allFallbacksProcessed = function () {\n    return this._allFallbacksProcessed;\n  };\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n\n\n  Effect.prototype.executeWhenCompiled = function (func) {\n    var _this = this;\n\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n\n    this.onCompileObservable.add(function (effect) {\n      func(effect);\n    });\n\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(function () {\n        _this._checkIsReady(null);\n      }, 16);\n    }\n  };\n\n  Effect.prototype._checkIsReady = function (previousPipelineContext) {\n    var _this = this;\n\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n\n      return;\n    }\n\n    setTimeout(function () {\n      _this._checkIsReady(previousPipelineContext);\n    }, 16);\n  };\n\n  Effect.prototype._loadShader = function (shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        var shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    } // Direct source ?\n\n\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    } // Base64 encoded ?\n\n\n    if (shader.substr(0, 7) === \"base64:\") {\n      var shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n\n    var shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage); // Is in local store ?\n\n    if (shaderStore[shader + key + \"Shader\"]) {\n      callback(shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n\n    var shaderUrl;\n\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\n    } // Vertex shader\n\n\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  };\n\n  Object.defineProperty(Effect.prototype, \"vertexSourceCode\", {\n    /**\n     * Gets the vertex shader source code of this effect\n     */\n    get: function get() {\n      var _a, _b;\n\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"fragmentSourceCode\", {\n    /**\n     * Gets the fragment shader source code of this effect\n     */\n    get: function get() {\n      var _a, _b;\n\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawVertexSourceCode\", {\n    /**\n     * Gets the vertex shader source code before it has been processed by the preprocessor\n     */\n    get: function get() {\n      return this._rawVertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawFragmentSourceCode\", {\n    /**\n     * Gets the fragment shader source code before it has been processed by the preprocessor\n     */\n    get: function get() {\n      return this._rawFragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Recompiles the webGL program\n   * @param vertexSourceCode The source code for the vertex shader.\n   * @param fragmentSourceCode The source code for the fragment shader.\n   * @param onCompiled Callback called when completed.\n   * @param onError Callback called on error.\n   * @hidden\n   */\n\n  Effect.prototype._rebuildProgram = function (vertexSourceCode, fragmentSourceCode, onCompiled, onError) {\n    var _this = this;\n\n    this._isReady = false;\n    this._vertexSourceCodeOverride = vertexSourceCode;\n    this._fragmentSourceCodeOverride = fragmentSourceCode;\n\n    this.onError = function (effect, error) {\n      if (onError) {\n        onError(error);\n      }\n    };\n\n    this.onCompiled = function () {\n      var scenes = _this.getEngine().scenes;\n\n      if (scenes) {\n        for (var i = 0; i < scenes.length; i++) {\n          scenes[i].markAllMaterialsAsDirty(63);\n        }\n      }\n\n      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);\n    };\n\n    this._fallbacks = null;\n\n    this._prepareEffect();\n  };\n  /**\n   * Prepares the effect\n   * @hidden\n   */\n\n\n  Effect.prototype._prepareEffect = function () {\n    var _this = this;\n\n    var attributesNames = this._attributesNames;\n    var defines = this.defines;\n    var previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n\n    try {\n      var engine_1 = this._engine;\n      this._pipelineContext = engine_1.createPipelineContext(this._processingContext);\n      this._pipelineContext._name = this._key;\n\n      var rebuildRebind = this._rebuildProgram.bind(this);\n\n      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);\n      } else {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);\n      }\n\n      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function () {\n        _this._attributes = [];\n\n        _this._pipelineContext._fillEffectInformation(_this, _this._uniformBuffersNames, _this._uniformsNames, _this._uniforms, _this._samplerList, _this._samplers, attributesNames, _this._attributes); // Caches attribute locations.\n\n\n        if (attributesNames) {\n          for (var i = 0; i < attributesNames.length; i++) {\n            var name_1 = attributesNames[i];\n            _this._attributeLocationByName[name_1] = _this._attributes[i];\n          }\n        }\n\n        engine_1.bindSamplers(_this);\n        _this._compilationError = \"\";\n        _this._isReady = true;\n\n        if (_this.onCompiled) {\n          _this.onCompiled(_this);\n        }\n\n        _this.onCompileObservable.notifyObservers(_this);\n\n        _this.onCompileObservable.clear(); // Unbind mesh reference in fallbacks\n\n\n        if (_this._fallbacks) {\n          _this._fallbacks.unBindMesh();\n        }\n\n        if (previousPipelineContext) {\n          _this.getEngine()._deletePipelineContext(previousPipelineContext);\n        }\n      });\n\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  };\n\n  Effect.prototype._getShaderCodeAndErrorLine = function (code, error, isFragment) {\n    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\n    var errorLine = null;\n\n    if (error && code) {\n      var res = error.match(regexp);\n\n      if (res && res.length === 2) {\n        var lineNumber = parseInt(res[1]);\n        var lines = code.split(\"\\n\", -1);\n\n        if (lines.length >= lineNumber) {\n          errorLine = \"Offending line [\".concat(lineNumber, \"] in \").concat(isFragment ? \"fragment\" : \"vertex\", \" code: \").concat(lines[lineNumber - 1]);\n        }\n      }\n    }\n\n    return [code, errorLine];\n  };\n\n  Effect.prototype._processCompilationErrors = function (e, previousPipelineContext) {\n    var _a, _b;\n\n    var _c, _d, _e;\n\n    if (previousPipelineContext === void 0) {\n      previousPipelineContext = null;\n    }\n\n    this._compilationError = e.message;\n    var attributesNames = this._attributesNames;\n    var fallbacks = this._fallbacks; // Let's go through fallbacks then\n\n    Logger.Error(\"Unable to compile effect:\");\n    Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n      return \" \" + uniform;\n    }));\n    Logger.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n      return \" \" + attribute;\n    }));\n    Logger.Error(\"Defines:\\r\\n\" + this.defines);\n\n    if (Effect.LogShaderCodeOnCompilationError) {\n      var lineErrorVertex = null,\n          lineErrorFragment = null,\n          code = null;\n\n      if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {\n        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];\n\n        if (code) {\n          Logger.Error(\"Vertex code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {\n        _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];\n\n        if (code) {\n          Logger.Error(\"Fragment code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n\n      if (lineErrorFragment) {\n        Logger.Error(lineErrorFragment);\n      }\n    }\n\n    Logger.Error(\"Error: \" + this._compilationError);\n\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n\n      this.onErrorObservable.notifyObservers(this);\n    }\n\n    if (fallbacks) {\n      this._pipelineContext = null;\n\n      if (fallbacks.hasMoreFallbacks) {\n        this._allFallbacksProcessed = false;\n        Logger.Error(\"Trying next fallback.\");\n        this.defines = fallbacks.reduce(this.defines, this);\n\n        this._prepareEffect();\n      } else {\n        // Sorry we did everything we can\n        this._allFallbacksProcessed = true;\n\n        if (this.onError) {\n          this.onError(this, this._compilationError);\n        }\n\n        this.onErrorObservable.notifyObservers(this);\n        this.onErrorObservable.clear(); // Unbind mesh reference in fallbacks\n\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n      }\n    } else {\n      this._allFallbacksProcessed = true;\n    }\n  };\n\n  Object.defineProperty(Effect.prototype, \"isSupported\", {\n    /**\n     * Checks if the effect is supported. (Must be called after compilation)\n     */\n    get: function get() {\n      return this._compilationError === \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Binds a texture to the engine to be used as output of the shader.\n   * @param channel Name of the output variable.\n   * @param texture Texture to bind.\n   * @hidden\n   */\n\n  Effect.prototype._bindTexture = function (channel, texture) {\n    this._engine._bindTexture(this._samplers[channel], texture, channel);\n  };\n  /**\n   * Sets a texture on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n\n\n  Effect.prototype.setTexture = function (channel, texture) {\n    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  };\n  /**\n   * Sets a depth stencil texture from a render target on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n\n\n  Effect.prototype.setDepthStencilTexture = function (channel, texture) {\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  };\n  /**\n   * Sets an array of textures on the engine to be used in the shader.\n   * @param channel Name of the variable.\n   * @param textures Textures to set.\n   */\n\n\n  Effect.prototype.setTextureArray = function (channel, textures) {\n    var exName = channel + \"Ex\";\n\n    if (this._samplerList.indexOf(exName + \"0\") === -1) {\n      var initialPos = this._samplerList.indexOf(channel);\n\n      for (var index = 1; index < textures.length; index++) {\n        var currentExName = exName + (index - 1).toString();\n\n        this._samplerList.splice(initialPos + index, 0, currentExName);\n      } // Reset every channels\n\n\n      var channelIndex = 0;\n\n      for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {\n        var key = _a[_i];\n        this._samplers[key] = channelIndex;\n        channelIndex += 1;\n      }\n    }\n\n    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\n  };\n  /**\n   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the input texture from.\n   */\n\n\n  Effect.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\n  };\n  /**\n   * (Warning! setTextureFromPostProcessOutput may be desired instead)\n   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the output texture from.\n   */\n\n\n  Effect.prototype.setTextureFromPostProcessOutput = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\n  };\n  /**\n   * Binds a buffer to a uniform.\n   * @param buffer Buffer to bind.\n   * @param name Name of the uniform variable to bind to.\n   */\n\n\n  Effect.prototype.bindUniformBuffer = function (buffer, name) {\n    var bufferName = this._uniformBuffersNames[name];\n\n    if (bufferName === undefined || Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {\n      return;\n    }\n\n    Effect._BaseCache[bufferName] = buffer;\n\n    this._engine.bindUniformBufferBase(buffer, bufferName, name);\n  };\n  /**\n   * Binds block to a uniform.\n   * @param blockName Name of the block to bind.\n   * @param index Index to bind.\n   */\n\n\n  Effect.prototype.bindUniformBlock = function (blockName, index) {\n    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);\n  };\n  /**\n   * Sets an integer value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value Value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setInt = function (uniformName, value) {\n    this._pipelineContext.setInt(uniformName, value);\n\n    return this;\n  };\n  /**\n   * Sets an int2 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int2.\n   * @param y Second int in int2.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setInt2 = function (uniformName, x, y) {\n    this._pipelineContext.setInt2(uniformName, x, y);\n\n    return this;\n  };\n  /**\n   * Sets an int3 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int3.\n   * @param y Second int in int3.\n   * @param z Third int in int3.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setInt3 = function (uniformName, x, y, z) {\n    this._pipelineContext.setInt3(uniformName, x, y, z);\n\n    return this;\n  };\n  /**\n   * Sets an int4 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int4.\n   * @param y Second int in int4.\n   * @param z Third int in int4.\n   * @param w Fourth int in int4.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setInt4 = function (uniformName, x, y, z, w) {\n    this._pipelineContext.setInt4(uniformName, x, y, z, w);\n\n    return this;\n  };\n  /**\n   * Sets an int array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setIntArray = function (uniformName, array) {\n    this._pipelineContext.setIntArray(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setIntArray2 = function (uniformName, array) {\n    this._pipelineContext.setIntArray2(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setIntArray3 = function (uniformName, array) {\n    this._pipelineContext.setIntArray3(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setIntArray4 = function (uniformName, array) {\n    this._pipelineContext.setIntArray4(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an float array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloatArray = function (uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloatArray2 = function (uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloatArray3 = function (uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloatArray4 = function (uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setArray = function (uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setArray2 = function (uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setArray3 = function (uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setArray4 = function (uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n\n    return this;\n  };\n  /**\n   * Sets matrices on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrices matrices to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setMatrices = function (uniformName, matrices) {\n    this._pipelineContext.setMatrices(uniformName, matrices);\n\n    return this;\n  };\n  /**\n   * Sets matrix on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setMatrix = function (uniformName, matrix) {\n    this._pipelineContext.setMatrix(uniformName, matrix);\n\n    return this;\n  };\n  /**\n   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setMatrix3x3 = function (uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix3x3(uniformName, matrix);\n\n    return this;\n  };\n  /**\n   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setMatrix2x2 = function (uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix2x2(uniformName, matrix);\n\n    return this;\n  };\n  /**\n   * Sets a float on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloat = function (uniformName, value) {\n    this._pipelineContext.setFloat(uniformName, value);\n\n    return this;\n  };\n  /**\n   * Sets a boolean on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param bool value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setBool = function (uniformName, bool) {\n    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);\n\n    return this;\n  };\n  /**\n   * Sets a Vector2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector2 vector2 to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setVector2 = function (uniformName, vector2) {\n    this._pipelineContext.setVector2(uniformName, vector2);\n\n    return this;\n  };\n  /**\n   * Sets a float2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float2.\n   * @param y Second float in float2.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloat2 = function (uniformName, x, y) {\n    this._pipelineContext.setFloat2(uniformName, x, y);\n\n    return this;\n  };\n  /**\n   * Sets a Vector3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector3 Value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setVector3 = function (uniformName, vector3) {\n    this._pipelineContext.setVector3(uniformName, vector3);\n\n    return this;\n  };\n  /**\n   * Sets a float3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float3.\n   * @param y Second float in float3.\n   * @param z Third float in float3.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloat3 = function (uniformName, x, y, z) {\n    this._pipelineContext.setFloat3(uniformName, x, y, z);\n\n    return this;\n  };\n  /**\n   * Sets a Vector4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector4 Value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setVector4 = function (uniformName, vector4) {\n    this._pipelineContext.setVector4(uniformName, vector4);\n\n    return this;\n  };\n  /**\n   * Sets a float4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float4.\n   * @param y Second float in float4.\n   * @param z Third float in float4.\n   * @param w Fourth float in float4.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setFloat4 = function (uniformName, x, y, z, w) {\n    this._pipelineContext.setFloat4(uniformName, x, y, z, w);\n\n    return this;\n  };\n  /**\n   * Sets a Color3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setColor3 = function (uniformName, color3) {\n    this._pipelineContext.setColor3(uniformName, color3);\n\n    return this;\n  };\n  /**\n   * Sets a Color4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @param alpha Alpha value to be set.\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setColor4 = function (uniformName, color3, alpha) {\n    this._pipelineContext.setColor4(uniformName, color3, alpha);\n\n    return this;\n  };\n  /**\n   * Sets a Color4 on a uniform variable\n   * @param uniformName defines the name of the variable\n   * @param color4 defines the value to be set\n   * @returns this effect.\n   */\n\n\n  Effect.prototype.setDirectColor4 = function (uniformName, color4) {\n    this._pipelineContext.setDirectColor4(uniformName, color4);\n\n    return this;\n  };\n  /**\n   * Release all associated resources.\n   **/\n\n\n  Effect.prototype.dispose = function () {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n\n    this._engine._releaseEffect(this);\n  };\n  /**\n   * This function will add a new shader to the shader store\n   * @param name the name of the shader\n   * @param pixelShader optional pixel shader content\n   * @param vertexShader optional vertex shader content\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n\n\n  Effect.RegisterShader = function (name, pixelShader, vertexShader, shaderLanguage) {\n    if (shaderLanguage === void 0) {\n      shaderLanguage = ShaderLanguage.GLSL;\n    }\n\n    if (pixelShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[\"\".concat(name, \"PixelShader\")] = pixelShader;\n    }\n\n    if (vertexShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[\"\".concat(name, \"VertexShader\")] = vertexShader;\n    }\n  };\n  /**\n   * Resets the cache of effects.\n   */\n\n\n  Effect.ResetCache = function () {\n    Effect._BaseCache = {};\n  };\n  /**\n   * Enable logging of the shader code when a compilation error occurs\n   */\n\n\n  Effect.LogShaderCodeOnCompilationError = true;\n  Effect._UniqueIdSeed = 0;\n  Effect._BaseCache = {};\n  /**\n   * Store of each shader (The can be looked up using effect.key)\n   */\n\n  Effect.ShadersStore = EngineShaderStore.ShadersStore;\n  /**\n   * Store of each included file for a shader (The can be looked up using effect.key)\n   */\n\n  Effect.IncludesShadersStore = EngineShaderStore.IncludesShadersStore;\n  return Effect;\n}();\n\nexport { Effect };","map":{"version":3,"mappings":"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","names":["Observable","GetDOMTextContent","IsWindowObjectExist","Logger","ShaderProcessor","ShaderStore","EngineShaderStore","ShaderLanguage","baseName","attributesNamesOrOptions","uniformsNamesOrEngine","samplers","engine","defines","fallbacks","onCompiled","onError","indexParameters","key","shaderLanguage","GLSL","name","_key","processCodeAfterIncludes","undefined","processFinalCode","attributes","options","_engine","_attributesNames","_uniformsNames","uniformsNames","concat","_samplerList","slice","_fallbacks","_indexParameters","_transformFeedbackVaryings","transformFeedbackVaryings","_multiTarget","multiTarget","_shaderLanguage","_a","uniformBuffersNames","_uniformBuffersNamesList","i","length","_uniformBuffersNames","_b","_c","_attributeLocationByName","uniqueId","Effect","_UniqueIdSeed","vertexSource","fragmentSource","hostDocument","getHostDocument","vertexElement","getElementById","vertex","fragmentElement","fragment","_processingContext","_getShaderProcessingContext","processorOptions","split","isFragment","shouldUseHighPrecisionShader","_shouldUseHighPrecisionShader","processor","_getShaderProcessor","supportsUniformBuffers","shadersRepository","GetShadersRepository","includesShadersStore","GetIncludesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","shaderCodes","shadersLoaded","fragmentCode","Process","migratedFragmentCode","finalShaders","Finalize","migratedVertexCode_1","_this","_useFinalCode","vertexCode","_loadShader","Initialize","migratedVertexCode","_rawVertexSourceCode","_rawFragmentSourceCode","Object","ShadersRepository","repo","_onBindObservable","spectorName","_vertexSourceCode","WGSL","_fragmentSourceCode","_prepareEffect","_isReadyInternal","_isReady","_pipelineContext","isReady","index","_attributes","uniformName","indexOf","_uniforms","_compilationError","_allFallbacksProcessed","func","onCompileObservable","add","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","shaderCode","substr","shaderBinary","window","atob","shaderStore","GetShadersStore","shaderUrl","_loadFile","toLowerCase","_vertexSourceCodeOverride","_fragmentSourceCodeOverride","_getVertexShaderCode","_getFragmentShaderCode","vertexSourceCode","fragmentSourceCode","error","scenes","getEngine","markAllMaterialsAsDirty","_handlesSpectorRebuildCallback","attributesNames","engine_1","createPipelineContext","_name","rebuildRebind","_rebuildProgram","bind","_preparePipelineContext","_executeWhenRenderingStateIsCompiled","_fillEffectInformation","_samplers","name_1","bindSamplers","notifyObservers","clear","unBindMesh","_deletePipelineContext","code","regexp","errorLine","res","match","lineNumber","parseInt","lines","message","Error","map","uniform","attribute","LogShaderCodeOnCompilationError","lineErrorVertex","lineErrorFragment","_getShaderCodeAndErrorLine","_d","_e","onErrorObservable","hasMoreFallbacks","reduce","channel","texture","_bindTexture","setTexture","setDepthStencilTexture","textures","exName","initialPos","currentExName","splice","channelIndex","_i","setTextureArray","postProcess","setTextureFromPostProcess","setTextureFromPostProcessOutput","buffer","bufferName","_BaseCache","_features","useUBOBindingCache","bindUniformBufferBase","blockName","bindUniformBlock","value","setInt","x","y","setInt2","z","setInt3","w","setInt4","array","setIntArray","setIntArray2","setIntArray3","setIntArray4","setArray","setArray2","setArray3","setArray4","matrices","setMatrices","matrix","setMatrix","setMatrix3x3","setMatrix2x2","setFloat","bool","vector2","setVector2","setFloat2","vector3","setVector3","setFloat3","vector4","setVector4","setFloat4","color3","setColor3","alpha","setColor4","color4","setDirectColor4","dispose","_releaseEffect","pixelShader","vertexShader","ShadersStore","IncludesShadersStore"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/effect.ts"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type ThinTexture = import(\"../Materials/Textures/thinTexture\").ThinTexture;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type PostProcess = import(\"../PostProcesses/postProcess\").PostProcess;\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @hidden */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    /**\r\n     * @hidden\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @hidden */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @hidden */\r\n    public _samplerList: string[];\r\n    /** @hidden */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @hidden */\r\n    public _engine: Engine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    private _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @hidden\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @hidden\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @hidden */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @hidden */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @hidden */\r\n    private _rawVertexSourceCode: string = \"\";\r\n    /** @hidden */\r\n    private _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<ShaderProcessingContext>;\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    constructor(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | ThinEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: ThinEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        let processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n        let processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <Engine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            processFinalCode = options.processFinalCode ?? null;\r\n            processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n        } else {\r\n            this._engine = <Engine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n\r\n        let vertexSource: any;\r\n        let fragmentSource: any;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.vertexSource) {\r\n            vertexSource = \"source:\" + baseName.vertexSource;\r\n        } else if (baseName.vertexElement) {\r\n            vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\r\n\r\n            if (!vertexSource) {\r\n                vertexSource = baseName.vertexElement;\r\n            }\r\n        } else {\r\n            vertexSource = baseName.vertex || baseName;\r\n        }\r\n\r\n        if (baseName.fragmentSource) {\r\n            fragmentSource = \"source:\" + baseName.fragmentSource;\r\n        } else if (baseName.fragmentElement) {\r\n            fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\r\n\r\n            if (!fragmentSource) {\r\n                fragmentSource = baseName.fragmentElement;\r\n            }\r\n        } else {\r\n            fragmentSource = baseName.fragment || baseName;\r\n        }\r\n\r\n        this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes,\r\n        };\r\n\r\n        const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n        const shadersLoaded = () => {\r\n            if (shaderCodes[0] && shaderCodes[1]) {\r\n                processorOptions.isFragment = true;\r\n                const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n                ShaderProcessor.Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode) => {\r\n                        if (processFinalCode) {\r\n                            migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                        }\r\n                        const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                        this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);\r\n                    },\r\n                    this._engine\r\n                );\r\n            }\r\n        };\r\n        this._loadShader(vertexSource, \"Vertex\", \"\", (vertexCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode) => {\r\n                    this._rawVertexSourceCode = vertexCode;\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n        this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", (fragmentCode) => {\r\n            this._rawFragmentSourceCode = fragmentCode;\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n            const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n            this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\r\n            this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\r\n        } else {\r\n            this._vertexSourceCode = migratedVertexCode;\r\n            this._fragmentSourceCode = migratedFragmentCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        const shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage);\r\n\r\n        // Is in local store ?\r\n        if (shaderStore[shader + key + \"Shader\"]) {\r\n            callback(shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\r\n        }\r\n\r\n        // Vertex shader\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @hidden\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @hidden\r\n     */\r\n    public _prepareEffect() {\r\n        const attributesNames = this._attributesNames;\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createPipelineContext(this._processingContext);\r\n            this._pipelineContext._name = this._key;\r\n\r\n            const rebuildRebind = this._rebuildProgram.bind(this);\r\n            if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCodeOverride,\r\n                    this._fragmentSourceCodeOverride,\r\n                    true,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    null,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            } else {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCode,\r\n                    this._fragmentSourceCode,\r\n                    false,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    defines,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            }\r\n\r\n            engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\r\n                this._attributes = [];\r\n                this._pipelineContext!._fillEffectInformation(\r\n                    this,\r\n                    this._uniformBuffersNames,\r\n                    this._uniformsNames,\r\n                    this._uniforms,\r\n                    this._samplerList,\r\n                    this._samplers,\r\n                    attributesNames,\r\n                    this._attributes\r\n                );\r\n\r\n                // Caches attribute locations.\r\n                if (attributesNames) {\r\n                    for (let i = 0; i < attributesNames.length; i++) {\r\n                        const name = attributesNames[i];\r\n                        this._attributeLocationByName[name] = this._attributes[i];\r\n                    }\r\n                }\r\n\r\n                engine.bindSamplers(this);\r\n\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deletePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\r\n            \"Uniforms: \" +\r\n                this._uniformsNames.map(function (uniform) {\r\n                    return \" \" + uniform;\r\n                })\r\n        );\r\n        Logger.Error(\r\n            \"Attributes: \" +\r\n                attributesNames.map(function (attribute) {\r\n                    return \" \" + attribute;\r\n                })\r\n        );\r\n        Logger.Error(\"Defines:\\r\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                if (this.onError) {\r\n                    this.onError(this, this._compilationError);\r\n                }\r\n                this.onErrorObservable.notifyObservers(this);\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @hidden\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the input texture from.\r\n     */\r\n    public setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n     * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the output texture from.\r\n     */\r\n    public setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}