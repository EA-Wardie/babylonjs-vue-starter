{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces.js\";\nimport { Vector2, Vector3, Vector4, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\n/**\n * Utils functions for GLTF\n * @hidden\n */\n\nvar GLTFUtils =\n/** @class */\nfunction () {\n  function GLTFUtils() {}\n  /**\n   * Sets the given \"parameter\" matrix\n   * @param scene the Scene object\n   * @param source the source node where to pick the matrix\n   * @param parameter the GLTF technique parameter\n   * @param uniformName the name of the shader's uniform\n   * @param shaderMaterial the shader material\n   */\n\n\n  GLTFUtils.SetMatrix = function (scene, source, parameter, uniformName, shaderMaterial) {\n    var mat = null;\n\n    if (parameter.semantic === \"MODEL\") {\n      mat = source.getWorldMatrix();\n    } else if (parameter.semantic === \"PROJECTION\") {\n      mat = scene.getProjectionMatrix();\n    } else if (parameter.semantic === \"VIEW\") {\n      mat = scene.getViewMatrix();\n    } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\n    } else if (parameter.semantic === \"MODELVIEW\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\n    } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\n    } else if (parameter.semantic === \"MODELINVERSE\") {\n      mat = source.getWorldMatrix().invert();\n    } else if (parameter.semantic === \"VIEWINVERSE\") {\n      mat = scene.getViewMatrix().invert();\n    } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\n      mat = scene.getProjectionMatrix().invert();\n    } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\n    } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\n    } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().invert());\n    }\n\n    if (mat) {\n      switch (parameter.type) {\n        case EParameterType.FLOAT_MAT2:\n          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\n          break;\n\n        case EParameterType.FLOAT_MAT3:\n          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\n          break;\n\n        case EParameterType.FLOAT_MAT4:\n          shaderMaterial.setMatrix(uniformName, mat);\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n  /**\n   * Sets the given \"parameter\" matrix\n   * @param shaderMaterial the shader material\n   * @param uniform the name of the shader's uniform\n   * @param value the value of the uniform\n   * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\n   */\n\n\n  GLTFUtils.SetUniform = function (shaderMaterial, uniform, value, type) {\n    switch (type) {\n      case EParameterType.FLOAT:\n        shaderMaterial.setFloat(uniform, value);\n        return true;\n\n      case EParameterType.FLOAT_VEC2:\n        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\n        return true;\n\n      case EParameterType.FLOAT_VEC3:\n        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\n        return true;\n\n      case EParameterType.FLOAT_VEC4:\n        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\n        return true;\n\n      default:\n        return false;\n    }\n  };\n  /**\n   * Returns the wrap mode of the texture\n   * @param mode the mode value\n   */\n\n\n  GLTFUtils.GetWrapMode = function (mode) {\n    switch (mode) {\n      case ETextureWrapMode.CLAMP_TO_EDGE:\n        return Texture.CLAMP_ADDRESSMODE;\n\n      case ETextureWrapMode.MIRRORED_REPEAT:\n        return Texture.MIRROR_ADDRESSMODE;\n\n      case ETextureWrapMode.REPEAT:\n        return Texture.WRAP_ADDRESSMODE;\n\n      default:\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  };\n  /**\n   * Returns the byte stride giving an accessor\n   * @param accessor the GLTF accessor objet\n   */\n\n\n  GLTFUtils.GetByteStrideFromType = function (accessor) {\n    // Needs this function since \"byteStride\" isn't requiered in glTF format\n    var type = accessor.type;\n\n    switch (type) {\n      case \"VEC2\":\n        return 2;\n\n      case \"VEC3\":\n        return 3;\n\n      case \"VEC4\":\n        return 4;\n\n      case \"MAT2\":\n        return 4;\n\n      case \"MAT3\":\n        return 9;\n\n      case \"MAT4\":\n        return 16;\n\n      default:\n        return 1;\n    }\n  };\n  /**\n   * Returns the texture filter mode giving a mode value\n   * @param mode the filter mode value\n   */\n\n\n  GLTFUtils.GetTextureFilterMode = function (mode) {\n    switch (mode) {\n      case ETextureFilterType.LINEAR:\n      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\n      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\n        return Texture.TRILINEAR_SAMPLINGMODE;\n\n      case ETextureFilterType.NEAREST:\n      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\n        return Texture.NEAREST_SAMPLINGMODE;\n\n      default:\n        return Texture.BILINEAR_SAMPLINGMODE;\n    }\n  };\n\n  GLTFUtils.GetBufferFromBufferView = function (gltfRuntime, bufferView, byteOffset, byteLength, componentType) {\n    byteOffset = bufferView.byteOffset + byteOffset;\n    var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\n\n    if (byteOffset + byteLength > loadedBufferView.byteLength) {\n      throw new Error(\"Buffer access is out of range\");\n    }\n\n    var buffer = loadedBufferView.buffer;\n    byteOffset += loadedBufferView.byteOffset;\n\n    switch (componentType) {\n      case EComponentType.BYTE:\n        return new Int8Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.UNSIGNED_BYTE:\n        return new Uint8Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.SHORT:\n        return new Int16Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.UNSIGNED_SHORT:\n        return new Uint16Array(buffer, byteOffset, byteLength);\n\n      default:\n        return new Float32Array(buffer, byteOffset, byteLength);\n    }\n  };\n  /**\n   * Returns a buffer from its accessor\n   * @param gltfRuntime the GLTF runtime\n   * @param accessor the GLTF accessor\n   */\n\n\n  GLTFUtils.GetBufferFromAccessor = function (gltfRuntime, accessor) {\n    var bufferView = gltfRuntime.bufferViews[accessor.bufferView];\n    var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\n    return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\n  };\n  /**\n   * Decodes a buffer view into a string\n   * @param view the buffer view\n   */\n\n\n  GLTFUtils.DecodeBufferToText = function (view) {\n    var result = \"\";\n    var length = view.byteLength;\n\n    for (var i = 0; i < length; ++i) {\n      result += String.fromCharCode(view[i]);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the default material of gltf. Related to\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\n   * @param scene the Babylon.js scene\n   */\n\n\n  GLTFUtils.GetDefaultMaterial = function (scene) {\n    if (!GLTFUtils._DefaultMaterial) {\n      Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\"precision highp float;\", \"\", \"uniform mat4 worldView;\", \"uniform mat4 projection;\", \"\", \"attribute vec3 position;\", \"\", \"void main(void)\", \"{\", \"    gl_Position = projection * worldView * vec4(position, 1.0);\", \"}\"].join(\"\\n\");\n      Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\"precision highp float;\", \"\", \"uniform vec4 u_emission;\", \"\", \"void main(void)\", \"{\", \"    gl_FragColor = u_emission;\", \"}\"].join(\"\\n\");\n      var shaderPath = {\n        vertex: \"GLTFDefaultMaterial\",\n        fragment: \"GLTFDefaultMaterial\"\n      };\n      var options = {\n        attributes: [\"position\"],\n        uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n        samplers: new Array(),\n        needAlphaBlending: false\n      };\n      GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\n\n      GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\n    }\n\n    return GLTFUtils._DefaultMaterial;\n  }; // The GLTF default material\n\n\n  GLTFUtils._DefaultMaterial = null;\n  return GLTFUtils;\n}();\n\nexport { GLTFUtils };","map":{"version":3,"mappings":"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","names":["EParameterType","ETextureWrapMode","ETextureFilterType","EComponentType","Vector2","Vector3","Vector4","Matrix","Color4","Effect","ShaderMaterial","Texture","GLTFUtils","scene","source","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","multiply","invert","getTransformMatrix","type","FLOAT_MAT2","setMatrix2x2","GetAsMatrix2x2","FLOAT_MAT3","setMatrix3x3","GetAsMatrix3x3","FLOAT_MAT4","setMatrix","uniform","value","FLOAT","setFloat","FLOAT_VEC2","setVector2","FromArray","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","mode","CLAMP_TO_EDGE","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","accessor","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_SAMPLINGMODE","BILINEAR_SAMPLINGMODE","gltfRuntime","bufferView","byteOffset","byteLength","componentType","loadedBufferView","loadedBufferViews","buffer","Error","BYTE","Int8Array","UNSIGNED_BYTE","Uint8Array","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","bufferViews","count","GetByteStrideFromType","GetBufferFromBufferView","view","result","length","i","String","fromCharCode","_DefaultMaterial","ShadersStore","join","shaderPath","vertex","fragment","options","attributes","uniforms","samplers","Array","needAlphaBlending","setColor4"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/1.0/glTFLoaderUtils.ts"],"sourcesContent":["import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @hidden\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}