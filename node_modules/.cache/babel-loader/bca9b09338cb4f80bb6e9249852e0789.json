{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\n\nvar UtilityLayerRenderer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a UtilityLayerRenderer\n   * @param originalScene the original scene that will be rendered on top of\n   * @param handleEvents boolean indicating if the utility layer should handle events\n   */\n  function UtilityLayerRenderer(\n  /** the original scene that will be rendered on top of */\n  originalScene, handleEvents) {\n    if (handleEvents === void 0) {\n      handleEvents = true;\n    }\n\n    var _this = this;\n\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n     */\n\n    this.pickUtilitySceneFirst = true;\n    /**\n     *  If the utility layer should automatically be rendered on top of existing scene\n     */\n\n    this.shouldRender = true;\n    /**\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n     */\n\n    this.onlyCheckPointerDownEvents = true;\n    /**\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n     */\n\n    this.processAllEvents = false;\n    /**\n     * Set to false to disable picking\n     */\n\n    this.pickingEnabled = true;\n    /**\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\n     */\n\n    this.onPointerOutObservable = new Observable(); // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false; // Deactivate post processes\n\n    this.utilityLayerScene.postProcessesEnabled = false; // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n\n    this.utilityLayerScene.detachControl();\n\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(function (prePointerInfo) {\n        if (!_this.utilityLayerScene.activeCamera) {\n          return;\n        }\n\n        if (!_this.pickingEnabled) {\n          return;\n        }\n\n        if (!_this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n\n        _this.utilityLayerScene.pointerX = originalScene.pointerX;\n        _this.utilityLayerScene.pointerY = originalScene.pointerY;\n        var pointerEvent = prePointerInfo.event;\n\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          _this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n\n        var getNearPickDataForScene = function getNearPickDataForScene(scene) {\n          var scenePick = null;\n\n          if (prePointerInfo.nearInteractionPickingInfo) {\n            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n              scenePick = prePointerInfo.nearInteractionPickingInfo;\n            } else {\n              scenePick = new PickingInfo();\n            }\n          } else {\n            var previousActiveCamera = null; // If a camera is set for rendering with this layer\n            // it will also be used for the ray computation\n            // To preserve back compat and because scene.pick always use activeCamera\n            // it's substituted temporarily and a new scenePick is forced.\n            // otherwise, the ray with previously active camera is always used.\n            // It's set back to previous activeCamera after operation.\n\n            if (_this._renderCamera) {\n              previousActiveCamera = scene._activeCamera;\n              scene._activeCamera = _this._renderCamera;\n              prePointerInfo.ray = null;\n            }\n\n            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n\n            if (previousActiveCamera) {\n              scene._activeCamera = previousActiveCamera;\n            }\n          }\n\n          return scenePick;\n        };\n\n        var utilityScenePick = getNearPickDataForScene(_this.utilityLayerScene);\n\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        } // always fire the prepointer observable\n\n\n        _this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo); // allow every non pointer down event to flow to the utility layer\n\n\n        if (_this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent.pointerId]) {\n            _this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n\n          return;\n        }\n\n        if (_this.utilityLayerScene.autoClearDepthAndStencil || _this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          var originalScenePick = getNearPickDataForScene(originalScene);\n          var pointerEvent_1 = prePointerInfo.event; // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                _this._pointerCaptures[pointerEvent_1.pointerId] = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                  // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                  _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                  delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n                }\n\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1); // If a previous utility layer set this, do not unset this\n\n\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && utilityScenePick.distance > originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                  // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                  _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                  delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n                }\n\n                _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1);\n              }\n            }\n\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent_1.pointerId]) {\n              _this._pointerCaptures[pointerEvent_1.pointerId] = false;\n            }\n          }\n        }\n      }); // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    } // Render directly on top of existing scene without clearing\n\n\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add(function (camera) {\n      // Only render when the render camera finishes rendering\n      if (_this.shouldRender && camera == _this.getRenderCamera()) {\n        if (camera.outputRenderTarget && camera.isRigCamera) {\n          // clear depth for the utility layer to render correctly\n          _this.originalScene.getEngine().clear(null, false, true, false);\n        }\n\n        _this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function () {\n      _this.dispose();\n    });\n\n    this._updateCamera();\n  }\n  /**\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n   * @returns the camera that is used when rendering the utility layer\n   */\n\n\n  UtilityLayerRenderer.prototype.getRenderCamera = function (getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      var activeCam = void 0;\n\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n\n      return activeCam;\n    }\n  };\n  /**\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n   * @param cam the camera that should be used when rendering the utility layer\n   */\n\n\n  UtilityLayerRenderer.prototype.setRenderCamera = function (cam) {\n    this._renderCamera = cam;\n  };\n  /**\n   * @hidden\n   * Light which used by gizmos to get light shading\n   */\n\n\n  UtilityLayerRenderer.prototype._getSharedGizmoLight = function () {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n\n    return this._sharedGizmoLight;\n  };\n\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultUtilityLayer\", {\n    /**\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n     */\n    get: function get() {\n      if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n        return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n      }\n\n      return UtilityLayerRenderer._DefaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates an utility layer, and set it as a default utility layer\n   * @param scene associated scene\n   * @hidden\n   */\n\n  UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene = function (scene) {\n    UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n\n    UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n      UtilityLayerRenderer._DefaultUtilityLayer = null;\n    });\n\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  };\n\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultKeepDepthUtilityLayer\", {\n    /**\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n     */\n    get: function get() {\n      if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n        });\n      }\n\n      return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  UtilityLayerRenderer.prototype._notifyObservers = function (prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  };\n  /**\n   * Renders the utility layers scene on top of the original scene\n   */\n\n\n  UtilityLayerRenderer.prototype.render = function () {\n    this._updateCamera();\n\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      var oldScene = this.utilityLayerScene.activeCamera.getScene();\n      var camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n\n      this.utilityLayerScene.render(false); // Reset camera's scene back to original\n\n      camera._scene = oldScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  };\n  /**\n   * Disposes of the renderer\n   */\n\n\n  UtilityLayerRenderer.prototype.dispose = function () {\n    this.onPointerOutObservable.clear();\n\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n\n    this.utilityLayerScene.dispose();\n  };\n\n  UtilityLayerRenderer.prototype._updateCamera = function () {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  };\n  /** @hidden */\n\n\n  UtilityLayerRenderer._DefaultUtilityLayer = null;\n  /** @hidden */\n\n  UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n  return UtilityLayerRenderer;\n}();\n\nexport { UtilityLayerRenderer };","map":{"version":3,"mappings":"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","names":["Scene","Observable","PointerInfo","PointerEventTypes","PickingInfo","EngineStore","HemisphericLight","Vector3","Color3","originalScene","handleEvents","utilityLayerScene","getEngine","virtual","useRightHandedSystem","_allowPostProcessClearColor","postProcessesEnabled","detachControl","_originalPointerObserver","onPrePointerObservable","add","prePointerInfo","_this","activeCamera","pickingEnabled","processAllEvents","type","POINTERMOVE","POINTERUP","POINTERDOWN","POINTERDOUBLETAP","pointerX","pointerY","pointerEvent","event","isPointerCaptured","pointerId","_pointerCaptures","getNearPickDataForScene","scene","scenePick","nearInteractionPickingInfo","pickedMesh","getScene","previousActiveCamera","_renderCamera","_activeCamera","ray","pickWithRay","pick","utilityScenePick","notifyObservers","onlyCheckPointerDownEvents","skipOnPointerObservable","onPointerObservable","autoClearDepthAndStencil","pickUtilitySceneFirst","hit","originalScenePick","pointerEvent_1","distance","mainSceneTrackerPredicate","_notifyObservers","_lastPointerEvents","onPointerOutObservable","makeObserverTopPriority","autoClear","_afterRenderObserver","onAfterCameraRenderObservable","camera","shouldRender","getRenderCamera","outputRenderTarget","isRigCamera","clear","render","_sceneDisposeObserver","onDisposeObservable","dispose","_updateCamera","UtilityLayerRenderer","getRigParentIfPossible","activeCam","activeCameras","length","rigParent","cam","_sharedGizmoLight","intensity","groundColor","Gray","Object","_DefaultUtilityLayer","_CreateDefaultUtilityLayerFromScene","LastCreatedScene","addOnce","_DefaultKeepDepthUtilityLayer","pickInfo","oldScene","_scene","leftCamera","rightCamera","remove","cameraToUseForPointers"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/utilityLayerRenderer.ts"],"sourcesContent":["import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @hidden */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @hidden */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @hidden\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance > originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                if (camera.outputRenderTarget && camera.isRigCamera) {\r\n                    // clear depth for the utility layer to render correctly\r\n                    this.originalScene.getEngine().clear(null, false, true, false);\r\n                }\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}