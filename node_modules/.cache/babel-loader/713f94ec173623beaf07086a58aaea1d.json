{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\n\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.isCube = true;\n\n  var internalOptions = __assign({\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    samples: 1\n  }, options); // TODO WEBGPU allow to choose the format?\n\n\n  internalTexture.format = internalOptions.generateStencil ? 13 : 14;\n\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n\n  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\n\n  this._internalTexturesCache.push(internalTexture);\n\n  return internalTexture;\n};\n\nWebGPUEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, useSRGBBuffer) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = false;\n  }\n\n  if (lodScale === void 0) {\n    lodScale = 0;\n  }\n\n  if (lodOffset === void 0) {\n    lodOffset = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = null;\n  }\n\n  if (useSRGBBuffer === void 0) {\n    useSRGBBuffer = false;\n  }\n\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, null, function (texture, imgs) {\n    var imageBitmaps = imgs; // we will always get an ImageBitmap array in WebGPU\n\n    var width = imageBitmaps[0].width;\n    var height = width;\n\n    _this._setCubeMapTextureParams(texture, !noMipmap);\n\n    texture.format = format !== null && format !== void 0 ? format : -1;\n\n    var gpuTextureWrapper = _this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n\n    _this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource, width, height, gpuTextureWrapper.format, false, false, 0, 0);\n\n    if (!noMipmap) {\n      _this._generateMipmaps(texture, _this._uploadEncoder);\n    }\n\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};\n\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  texture.samplingMode = loadMipmap ? 3 : 2;\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n\n  if (maxLevel) {\n    texture._maxLodLevel = maxLevel;\n  }\n};","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","WebGPUEngine","prototype","_createDepthStencilCubeTexture","size","options","internalTexture","DepthStencil","isCube","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","samples","format","_setupDepthStencilTexture","_textureHelper","createGPUTextureForInternalTexture","_internalTexturesCache","push","createCubeTexture","rootUrl","scene","files","noMipmap","onLoad","onError","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","useSRGBBuffer","createCubeTextureBase","texture","imgs","imageBitmaps","width","height","_this","_setCubeMapTextureParams","gpuTextureWrapper","updateCubeTextures","underlyingResource","_generateMipmaps","_uploadEncoder","isReady","onLoadedObservable","notifyObservers","clear","loadMipmap","maxLevel","samplingMode","_cachedWrapU","_cachedWrapV","_maxLodLevel"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.cubeTexture.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\ndeclare type Scene = import(\"../../../scene\").Scene;\r\n\r\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n    internalTexture.isCube = true;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n\r\n    // TODO WEBGPU allow to choose the format?\r\n    internalTexture.format = internalOptions.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n\r\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}