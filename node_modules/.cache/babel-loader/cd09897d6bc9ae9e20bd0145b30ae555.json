{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Wraps one or more Sound objects and selects one with random weight for playback.\n */\n\nvar WeightedSound =\n/** @class */\nfunction () {\n  /**\n   * Creates a new WeightedSound from the list of sounds given.\n   * @param loop When true a Sound will be selected and played when the current playing Sound completes.\n   * @param sounds Array of Sounds that will be selected from.\n   * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\n   */\n  function WeightedSound(loop, sounds, weights) {\n    var _this = this;\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\n\n\n    this.loop = false;\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._volume = 1;\n    /** A Sound is currently playing. */\n\n    this.isPlaying = false;\n    /** A Sound is currently paused. */\n\n    this.isPaused = false;\n    this._sounds = [];\n    this._weights = [];\n\n    if (sounds.length !== weights.length) {\n      throw new Error(\"Sounds length does not equal weights length\");\n    }\n\n    this.loop = loop;\n    this._weights = weights; // Normalize the weights\n\n    var weightSum = 0;\n\n    for (var _i = 0, weights_1 = weights; _i < weights_1.length; _i++) {\n      var weight = weights_1[_i];\n      weightSum += weight;\n    }\n\n    var invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n\n    for (var i = 0; i < this._weights.length; i++) {\n      this._weights[i] *= invWeightSum;\n    }\n\n    this._sounds = sounds;\n\n    for (var _a = 0, _b = this._sounds; _a < _b.length; _a++) {\n      var sound = _b[_a];\n      sound.onEndedObservable.add(function () {\n        _this._onended();\n      });\n    }\n  }\n\n  Object.defineProperty(WeightedSound.prototype, \"directionalConeInnerAngle\", {\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    get: function get() {\n      return this._coneInnerAngle;\n    },\n\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    set: function set(value) {\n      if (value !== this._coneInnerAngle) {\n        if (this._coneOuterAngle < value) {\n          Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneInnerAngle = value;\n\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.directionalConeInnerAngle = value;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WeightedSound.prototype, \"directionalConeOuterAngle\", {\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    get: function get() {\n      return this._coneOuterAngle;\n    },\n\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    set: function set(value) {\n      if (value !== this._coneOuterAngle) {\n        if (value < this._coneInnerAngle) {\n          Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneOuterAngle = value;\n\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.directionalConeOuterAngle = value;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WeightedSound.prototype, \"volume\", {\n    /**\n     * Playback volume.\n     */\n    get: function get() {\n      return this._volume;\n    },\n\n    /**\n     * Playback volume.\n     */\n    set: function set(value) {\n      if (value !== this._volume) {\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.setVolume(value);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WeightedSound.prototype._onended = function () {\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].autoplay = false;\n    }\n\n    if (this.loop && this.isPlaying) {\n      this.play();\n    } else {\n      this.isPlaying = false;\n    }\n  };\n  /**\n   * Suspend playback\n   */\n\n\n  WeightedSound.prototype.pause = function () {\n    this.isPaused = true;\n\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].pause();\n    }\n  };\n  /**\n   * Stop playback\n   */\n\n\n  WeightedSound.prototype.stop = function () {\n    this.isPlaying = false;\n\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].stop();\n    }\n  };\n  /**\n   * Start playback.\n   * @param startOffset Position the clip head at a specific time in seconds.\n   */\n\n\n  WeightedSound.prototype.play = function (startOffset) {\n    if (!this.isPaused) {\n      this.stop();\n      var randomValue = Math.random();\n      var total = 0;\n\n      for (var i = 0; i < this._weights.length; i++) {\n        total += this._weights[i];\n\n        if (randomValue <= total) {\n          this._currentIndex = i;\n          break;\n        }\n      }\n    }\n\n    var sound = this._sounds[this._currentIndex];\n\n    if (sound.isReady()) {\n      sound.play(0, this.isPaused ? undefined : startOffset);\n    } else {\n      sound.autoplay = true;\n    }\n\n    this.isPlaying = true;\n    this.isPaused = false;\n  };\n\n  return WeightedSound;\n}();\n\nexport { WeightedSound };","map":{"version":3,"mappings":"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","names":["Logger","loop","sounds","weights","length","Error","_weights","weightSum","_i","weight","invWeightSum","i","_sounds","_a","sound","onEndedObservable","add","_this","_onended","Object","WeightedSound","_coneInnerAngle","value","_coneOuterAngle","directionalConeInnerAngle","directionalConeOuterAngle","_volume","setVolume","_currentIndex","undefined","autoplay","isPlaying","play","isPaused","pause","stop","startOffset","randomValue","Math","random","total","isReady"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Audio/weightedsound.ts"],"sourcesContent":["import type { Sound } from \"../Audio/sound\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Wraps one or more Sound objects and selects one with random weight for playback.\r\n */\r\nexport class WeightedSound {\r\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\r\n    public loop: boolean = false;\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _volume: number = 1;\r\n    /** A Sound is currently playing. */\r\n    public isPlaying: boolean = false;\r\n    /** A Sound is currently paused. */\r\n    public isPaused: boolean = false;\r\n\r\n    private _sounds: Sound[] = [];\r\n    private _weights: number[] = [];\r\n    private _currentIndex?: number;\r\n\r\n    /**\r\n     * Creates a new WeightedSound from the list of sounds given.\r\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\r\n     * @param sounds Array of Sounds that will be selected from.\r\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\r\n     */\r\n    constructor(loop: boolean, sounds: Sound[], weights: number[]) {\r\n        if (sounds.length !== weights.length) {\r\n            throw new Error(\"Sounds length does not equal weights length\");\r\n        }\r\n\r\n        this.loop = loop;\r\n        this._weights = weights;\r\n        // Normalize the weights\r\n        let weightSum = 0;\r\n        for (const weight of weights) {\r\n            weightSum += weight;\r\n        }\r\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\r\n        for (let i = 0; i < this._weights.length; i++) {\r\n            this._weights[i] *= invWeightSum;\r\n        }\r\n        this._sounds = sounds;\r\n        for (const sound of this._sounds) {\r\n            sound.onEndedObservable.add(() => {\r\n                this._onended();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value !== this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value !== this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public get volume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public set volume(value: number) {\r\n        if (value !== this._volume) {\r\n            for (const sound of this._sounds) {\r\n                sound.setVolume(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].autoplay = false;\r\n        }\r\n        if (this.loop && this.isPlaying) {\r\n            this.play();\r\n        } else {\r\n            this.isPlaying = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Suspend playback\r\n     */\r\n    public pause() {\r\n        this.isPaused = true;\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].pause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop playback\r\n     */\r\n    public stop() {\r\n        this.isPlaying = false;\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start playback.\r\n     * @param startOffset Position the clip head at a specific time in seconds.\r\n     */\r\n    public play(startOffset?: number) {\r\n        if (!this.isPaused) {\r\n            this.stop();\r\n            const randomValue = Math.random();\r\n            let total = 0;\r\n            for (let i = 0; i < this._weights.length; i++) {\r\n                total += this._weights[i];\r\n                if (randomValue <= total) {\r\n                    this._currentIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const sound = this._sounds[this._currentIndex!];\r\n        if (sound.isReady()) {\r\n            sound.play(0, this.isPaused ? undefined : startOffset);\r\n        } else {\r\n            sound.autoplay = true;\r\n        }\r\n        this.isPlaying = true;\r\n        this.isPaused = false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}