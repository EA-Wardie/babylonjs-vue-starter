{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @hidden\n */\n\nvar RenderingGroup =\n/** @class */\nfunction () {\n  /**\n   * Creates a new rendering group.\n   * @param index The rendering group index\n   * @param scene\n   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n   */\n  function RenderingGroup(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this.index = index;\n    this._opaqueSubMeshes = new SmartArray(256);\n    this._transparentSubMeshes = new SmartArray(256);\n    this._alphaTestSubMeshes = new SmartArray(256);\n    this._depthOnlySubMeshes = new SmartArray(256);\n    this._particleSystems = new SmartArray(256);\n    this._spriteManagers = new SmartArray(256);\n    /** @hidden */\n\n    this._empty = true;\n    /** @hidden */\n\n    this._edgesRenderers = new SmartArrayNoDuplicate(16);\n    this._scene = scene;\n    this.opaqueSortCompareFn = opaqueSortCompareFn;\n    this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n    this.transparentSortCompareFn = transparentSortCompareFn;\n  }\n\n  Object.defineProperty(RenderingGroup.prototype, \"opaqueSortCompareFn\", {\n    /**\n     * Set the opaque sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set: function set(value) {\n      this._opaqueSortCompareFn = value;\n\n      if (value) {\n        this._renderOpaque = this._renderOpaqueSorted;\n      } else {\n        this._renderOpaque = RenderingGroup._RenderUnsorted;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderingGroup.prototype, \"alphaTestSortCompareFn\", {\n    /**\n     * Set the alpha test sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set: function set(value) {\n      this._alphaTestSortCompareFn = value;\n\n      if (value) {\n        this._renderAlphaTest = this._renderAlphaTestSorted;\n      } else {\n        this._renderAlphaTest = RenderingGroup._RenderUnsorted;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderingGroup.prototype, \"transparentSortCompareFn\", {\n    /**\n     * Set the transparent sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set: function set(value) {\n      if (value) {\n        this._transparentSortCompareFn = value;\n      } else {\n        this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n      }\n\n      this._renderTransparent = this._renderTransparentSorted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Render all the sub meshes contained in the group.\n   * @param customRenderFunction Used to override the default render behaviour of the group.\n   * @param renderSprites\n   * @param renderParticles\n   * @param activeMeshes\n   * @returns true if rendered some submeshes.\n   */\n\n  RenderingGroup.prototype.render = function (customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n    if (customRenderFunction) {\n      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n      return;\n    }\n\n    var engine = this._scene.getEngine(); // Depth only\n\n\n    if (this._depthOnlySubMeshes.length !== 0) {\n      engine.setColorWrite(false);\n\n      this._renderAlphaTest(this._depthOnlySubMeshes);\n\n      engine.setColorWrite(true);\n    } // Opaque\n\n\n    if (this._opaqueSubMeshes.length !== 0) {\n      this._renderOpaque(this._opaqueSubMeshes);\n    } // Alpha test\n\n\n    if (this._alphaTestSubMeshes.length !== 0) {\n      this._renderAlphaTest(this._alphaTestSubMeshes);\n    }\n\n    var stencilState = engine.getStencilBuffer();\n    engine.setStencilBuffer(false); // Sprites\n\n    if (renderSprites) {\n      this._renderSprites();\n    } // Particles\n\n\n    if (renderParticles) {\n      this._renderParticles(activeMeshes);\n    }\n\n    if (this.onBeforeTransparentRendering) {\n      this.onBeforeTransparentRendering();\n    } // Transparent\n\n\n    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n      engine.setStencilBuffer(stencilState);\n\n      if (this._scene.useOrderIndependentTransparency) {\n        var excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n\n        if (excludedMeshes.length) {\n          // Render leftover meshes that could not be processed by depth peeling\n          this._renderTransparent(excludedMeshes);\n        }\n      } else {\n        this._renderTransparent(this._transparentSubMeshes);\n      }\n\n      engine.setAlphaMode(0);\n    } // Set back stencil to false in case it changes before the edge renderer.\n\n\n    engine.setStencilBuffer(false); // Edges\n\n    if (this._edgesRenderers.length) {\n      for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n        this._edgesRenderers.data[edgesRendererIndex].render();\n      }\n\n      engine.setAlphaMode(0);\n    } // Restore Stencil state.\n\n\n    engine.setStencilBuffer(stencilState);\n  };\n  /**\n   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n\n\n  RenderingGroup.prototype._renderOpaqueSorted = function (subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n  };\n  /**\n   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n\n\n  RenderingGroup.prototype._renderAlphaTestSorted = function (subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n  };\n  /**\n   * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n\n\n  RenderingGroup.prototype._renderTransparentSorted = function (subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n  };\n  /**\n   * Renders the submeshes in a specified order.\n   * @param subMeshes The submeshes to sort before render\n   * @param sortCompareFn The comparison function use to sort\n   * @param camera The camera position use to preprocess the submeshes to help sorting\n   * @param transparent Specifies to activate blending if true\n   */\n\n\n  RenderingGroup._RenderSorted = function (subMeshes, sortCompareFn, camera, transparent) {\n    var subIndex = 0;\n    var subMesh;\n    var cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n\n    for (; subIndex < subMeshes.length; subIndex++) {\n      subMesh = subMeshes.data[subIndex];\n      subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n      subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n    }\n\n    var sortedArray = subMeshes.data.slice(0, subMeshes.length);\n\n    if (sortCompareFn) {\n      sortedArray.sort(sortCompareFn);\n    }\n\n    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n      subMesh = sortedArray[subIndex];\n\n      if (transparent) {\n        var material = subMesh.getMaterial();\n\n        if (material && material.needDepthPrePass) {\n          var engine = material.getScene().getEngine();\n          engine.setColorWrite(false);\n          engine.setAlphaMode(0);\n          subMesh.render(false);\n          engine.setColorWrite(true);\n        }\n      }\n\n      subMesh.render(transparent);\n    }\n  };\n  /**\n   * Renders the submeshes in the order they were dispatched (no sort applied).\n   * @param subMeshes The submeshes to render\n   */\n\n\n  RenderingGroup._RenderUnsorted = function (subMeshes) {\n    for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {\n      var submesh = subMeshes.data[subIndex];\n      submesh.render(false);\n    }\n  };\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front if in the same alpha index.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  RenderingGroup.defaultTransparentSortCompare = function (a, b) {\n    // Alpha index first\n    if (a._alphaIndex > b._alphaIndex) {\n      return 1;\n    }\n\n    if (a._alphaIndex < b._alphaIndex) {\n      return -1;\n    } // Then distance to camera\n\n\n    return RenderingGroup.backToFrontSortCompare(a, b);\n  };\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  RenderingGroup.backToFrontSortCompare = function (a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return 1;\n    }\n\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return -1;\n    }\n\n    return 0;\n  };\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered front to back (prevent overdraw).\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  RenderingGroup.frontToBackSortCompare = function (a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return -1;\n    }\n\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return 1;\n    }\n\n    return 0;\n  };\n  /**\n   * Resets the different lists of submeshes to prepare a new frame.\n   */\n\n\n  RenderingGroup.prototype.prepare = function () {\n    this._opaqueSubMeshes.reset();\n\n    this._transparentSubMeshes.reset();\n\n    this._alphaTestSubMeshes.reset();\n\n    this._depthOnlySubMeshes.reset();\n\n    this._particleSystems.reset();\n\n    this._spriteManagers.reset();\n\n    this._edgesRenderers.reset();\n\n    this._empty = true;\n  };\n\n  RenderingGroup.prototype.dispose = function () {\n    this._opaqueSubMeshes.dispose();\n\n    this._transparentSubMeshes.dispose();\n\n    this._alphaTestSubMeshes.dispose();\n\n    this._depthOnlySubMeshes.dispose();\n\n    this._particleSystems.dispose();\n\n    this._spriteManagers.dispose();\n\n    this._edgesRenderers.dispose();\n  };\n  /**\n   * Inserts the submesh in its correct queue depending on its material.\n   * @param subMesh The submesh to dispatch\n   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n\n\n  RenderingGroup.prototype.dispatch = function (subMesh, mesh, material) {\n    // Get mesh and materials if not provided\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n\n    if (material === undefined) {\n      material = subMesh.getMaterial();\n    }\n\n    if (material === null || material === undefined) {\n      return;\n    }\n\n    if (material.needAlphaBlendingForMesh(mesh)) {\n      // Transparent\n      this._transparentSubMeshes.push(subMesh);\n    } else if (material.needAlphaTesting()) {\n      // Alpha test\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n\n      this._alphaTestSubMeshes.push(subMesh);\n    } else {\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n\n      this._opaqueSubMeshes.push(subMesh); // Opaque\n\n    }\n\n    mesh._renderingGroup = this;\n\n    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n    }\n\n    this._empty = false;\n  };\n\n  RenderingGroup.prototype.dispatchSprites = function (spriteManager) {\n    this._spriteManagers.push(spriteManager);\n\n    this._empty = false;\n  };\n\n  RenderingGroup.prototype.dispatchParticles = function (particleSystem) {\n    this._particleSystems.push(particleSystem);\n\n    this._empty = false;\n  };\n\n  RenderingGroup.prototype._renderParticles = function (activeMeshes) {\n    if (this._particleSystems.length === 0) {\n      return;\n    } // Particles\n\n\n    var activeCamera = this._scene.activeCamera;\n\n    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n\n    for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n      var particleSystem = this._particleSystems.data[particleIndex];\n\n      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n        continue;\n      }\n\n      var emitter = particleSystem.emitter;\n\n      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n        this._scene._activeParticles.addCount(particleSystem.render(), false);\n      }\n    }\n\n    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n  };\n\n  RenderingGroup.prototype._renderSprites = function () {\n    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n      return;\n    } // Sprites\n\n\n    var activeCamera = this._scene.activeCamera;\n\n    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n\n    for (var id = 0; id < this._spriteManagers.length; id++) {\n      var spriteManager = this._spriteManagers.data[id];\n\n      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n        spriteManager.render();\n      }\n    }\n\n    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n  };\n\n  RenderingGroup._ZeroVector = Vector3.Zero();\n  return RenderingGroup;\n}();\n\nexport { RenderingGroup };","map":{"version":3,"mappings":";;;;AAAA,SAASA,UAAT,EAAqBC,qBAArB,QAAkD,uBAAlD;AAIA,SAASC,OAAT,QAAwB,yBAAxB;AASA;;;;;;;AAMA;AAAA;AAAA;AAiEI;;;;;;;;AAQA,0BACWC,KADX,EAEIC,KAFJ,EAGIC,mBAHJ,EAIIC,sBAJJ,EAKIC,wBALJ,EAKiF;AAF7E;AAAAF;AAAwE;;AACxE;AAAAC;AAA2E;;AAC3E;AAAAC;AAA6E;;AAJtE;AAvEH,4BAAmB,IAAIP,UAAJ,CAAwB,GAAxB,CAAnB;AACA,iCAAwB,IAAIA,UAAJ,CAAwB,GAAxB,CAAxB;AACA,+BAAsB,IAAIA,UAAJ,CAAwB,GAAxB,CAAtB;AACA,+BAAsB,IAAIA,UAAJ,CAAwB,GAAxB,CAAtB;AACA,4BAAmB,IAAIA,UAAJ,CAAgC,GAAhC,CAAnB;AACA,2BAAkB,IAAIA,UAAJ,CAA+B,GAA/B,CAAlB;AAUR;;AACO,kBAAS,IAAT;AAEP;;AACO,2BAAkB,IAAIC,qBAAJ,CAA0C,EAA1C,CAAlB;AA0DH,SAAKO,MAAL,GAAcJ,KAAd;AAEA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,wBAAL,GAAgCA,wBAAhC;AACH;;AAvDDE,wBAAWC,wBAAX,EAAW,qBAAX,EAA8B;AAJ9B;;;;SAIA,aAA+BC,KAA/B,EAAkF;AAC9E,WAAKC,oBAAL,GAA4BD,KAA5B;;AACA,UAAIA,KAAJ,EAAW;AACP,aAAKE,aAAL,GAAqB,KAAKC,mBAA1B;AACH,OAFD,MAEO;AACH,aAAKD,aAAL,GAAqBH,cAAc,CAACK,eAApC;AACH;AACJ,KAP6B;qBAAA;;AAAA,GAA9B;AAaAN,wBAAWC,wBAAX,EAAW,wBAAX,EAAiC;AAJjC;;;;SAIA,aAAkCC,KAAlC,EAAqF;AACjF,WAAKK,uBAAL,GAA+BL,KAA/B;;AACA,UAAIA,KAAJ,EAAW;AACP,aAAKM,gBAAL,GAAwB,KAAKC,sBAA7B;AACH,OAFD,MAEO;AACH,aAAKD,gBAAL,GAAwBP,cAAc,CAACK,eAAvC;AACH;AACJ,KAPgC;qBAAA;;AAAA,GAAjC;AAaAN,wBAAWC,wBAAX,EAAW,0BAAX,EAAmC;AAJnC;;;;SAIA,aAAoCC,KAApC,EAAuF;AACnF,UAAIA,KAAJ,EAAW;AACP,aAAKQ,yBAAL,GAAiCR,KAAjC;AACH,OAFD,MAEO;AACH,aAAKQ,yBAAL,GAAiCT,cAAc,CAACU,6BAAhD;AACH;;AACD,WAAKC,kBAAL,GAA0B,KAAKC,wBAA/B;AACH,KAPkC;qBAAA;;AAAA,GAAnC;AA+BA;;;;;;;;;AAQOZ,oCAAP,UACIa,oBADJ,EASIC,aATJ,EAUIC,eAVJ,EAWIC,YAXJ,EAW0C;AAEtC,QAAIH,oBAAJ,EAA0B;AACtBA,0BAAoB,CAAC,KAAKI,gBAAN,EAAwB,KAAKC,mBAA7B,EAAkD,KAAKC,qBAAvD,EAA8E,KAAKC,mBAAnF,CAApB;AACA;AACH;;AAED,QAAMC,MAAM,GAAG,KAAKvB,MAAL,CAAYwB,SAAZ,EAAf,CAPsC,CAStC;;;AACA,QAAI,KAAKF,mBAAL,CAAyBG,MAAzB,KAAoC,CAAxC,EAA2C;AACvCF,YAAM,CAACG,aAAP,CAAqB,KAArB;;AACA,WAAKjB,gBAAL,CAAsB,KAAKa,mBAA3B;;AACAC,YAAM,CAACG,aAAP,CAAqB,IAArB;AACH,KAdqC,CAgBtC;;;AACA,QAAI,KAAKP,gBAAL,CAAsBM,MAAtB,KAAiC,CAArC,EAAwC;AACpC,WAAKpB,aAAL,CAAmB,KAAKc,gBAAxB;AACH,KAnBqC,CAqBtC;;;AACA,QAAI,KAAKC,mBAAL,CAAyBK,MAAzB,KAAoC,CAAxC,EAA2C;AACvC,WAAKhB,gBAAL,CAAsB,KAAKW,mBAA3B;AACH;;AAED,QAAMO,YAAY,GAAGJ,MAAM,CAACK,gBAAP,EAArB;AACAL,UAAM,CAACM,gBAAP,CAAwB,KAAxB,EA3BsC,CA6BtC;;AACA,QAAIb,aAAJ,EAAmB;AACf,WAAKc,cAAL;AACH,KAhCqC,CAkCtC;;;AACA,QAAIb,eAAJ,EAAqB;AACjB,WAAKc,gBAAL,CAAsBb,YAAtB;AACH;;AAED,QAAI,KAAKc,4BAAT,EAAuC;AACnC,WAAKA,4BAAL;AACH,KAzCqC,CA2CtC;;;AACA,QAAI,KAAKX,qBAAL,CAA2BI,MAA3B,KAAsC,CAAtC,IAA2C,KAAKzB,MAAL,CAAYiC,+BAA3D,EAA4F;AACxFV,YAAM,CAACM,gBAAP,CAAwBF,YAAxB;;AACA,UAAI,KAAK3B,MAAL,CAAYiC,+BAAhB,EAAiD;AAC7C,YAAMC,cAAc,GAAG,KAAKlC,MAAL,CAAYmC,oBAAZ,CAAkCC,MAAlC,CAAyC,KAAKf,qBAA9C,CAAvB;;AACA,YAAIa,cAAc,CAACT,MAAnB,EAA2B;AACvB;AACA,eAAKZ,kBAAL,CAAwBqB,cAAxB;AACH;AACJ,OAND,MAMO;AACH,aAAKrB,kBAAL,CAAwB,KAAKQ,qBAA7B;AACH;;AACDE,YAAM,CAACc,YAAP,CAAoB,CAApB;AACH,KAxDqC,CA0DtC;;;AACAd,UAAM,CAACM,gBAAP,CAAwB,KAAxB,EA3DsC,CA6DtC;;AACA,QAAI,KAAKS,eAAL,CAAqBb,MAAzB,EAAiC;AAC7B,WAAK,IAAIc,kBAAkB,GAAG,CAA9B,EAAiCA,kBAAkB,GAAG,KAAKD,eAAL,CAAqBb,MAA3E,EAAmFc,kBAAkB,EAArG,EAAyG;AACrG,aAAKD,eAAL,CAAqBE,IAArB,CAA0BD,kBAA1B,EAA8CH,MAA9C;AACH;;AAEDb,YAAM,CAACc,YAAP,CAAoB,CAApB;AACH,KApEqC,CAsEtC;;;AACAd,UAAM,CAACM,gBAAP,CAAwBF,YAAxB;AACH,GAnFM;AAqFP;;;;;;AAIQzB,iDAAR,UAA4BuC,SAA5B,EAA0D;AACtD,WAAOvC,cAAc,CAACwC,aAAf,CAA6BD,SAA7B,EAAwC,KAAKrC,oBAA7C,EAAmE,KAAKJ,MAAL,CAAY2C,YAA/E,EAA6F,KAA7F,CAAP;AACH,GAFO;AAIR;;;;;;AAIQzC,oDAAR,UAA+BuC,SAA/B,EAA6D;AACzD,WAAOvC,cAAc,CAACwC,aAAf,CAA6BD,SAA7B,EAAwC,KAAKjC,uBAA7C,EAAsE,KAAKR,MAAL,CAAY2C,YAAlF,EAAgG,KAAhG,CAAP;AACH,GAFO;AAIR;;;;;;AAIQzC,sDAAR,UAAiCuC,SAAjC,EAA+D;AAC3D,WAAOvC,cAAc,CAACwC,aAAf,CAA6BD,SAA7B,EAAwC,KAAK9B,yBAA7C,EAAwE,KAAKX,MAAL,CAAY2C,YAApF,EAAkG,IAAlG,CAAP;AACH,GAFO;AAIR;;;;;;;;;AAOezC,iCAAf,UACIuC,SADJ,EAEIG,aAFJ,EAGIC,MAHJ,EAIIC,WAJJ,EAIwB;AAEpB,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,OAAJ;AACA,QAAMC,cAAc,GAAGJ,MAAM,GAAGA,MAAM,CAACK,cAAV,GAA2BhD,cAAc,CAACiD,WAAvE;;AACA,WAAOJ,QAAQ,GAAGN,SAAS,CAAChB,MAA5B,EAAoCsB,QAAQ,EAA5C,EAAgD;AAC5CC,aAAO,GAAGP,SAAS,CAACD,IAAV,CAAeO,QAAf,CAAV;AACAC,aAAO,CAACI,WAAR,GAAsBJ,OAAO,CAACK,OAAR,GAAkBC,UAAxC;AACAN,aAAO,CAACO,iBAAR,GAA4B7D,OAAO,CAAC8D,QAAR,CAAiBR,OAAO,CAACS,eAAR,GAA0BC,cAA1B,CAAyCC,WAA1D,EAAuEV,cAAvE,CAA5B;AACH;;AAED,QAAMW,WAAW,GAAGnB,SAAS,CAACD,IAAV,CAAeqB,KAAf,CAAqB,CAArB,EAAwBpB,SAAS,CAAChB,MAAlC,CAApB;;AAEA,QAAImB,aAAJ,EAAmB;AACfgB,iBAAW,CAACE,IAAZ,CAAiBlB,aAAjB;AACH;;AAED,SAAKG,QAAQ,GAAG,CAAhB,EAAmBA,QAAQ,GAAGa,WAAW,CAACnC,MAA1C,EAAkDsB,QAAQ,EAA1D,EAA8D;AAC1DC,aAAO,GAAGY,WAAW,CAACb,QAAD,CAArB;;AAEA,UAAID,WAAJ,EAAiB;AACb,YAAMiB,QAAQ,GAAGf,OAAO,CAACgB,WAAR,EAAjB;;AAEA,YAAID,QAAQ,IAAIA,QAAQ,CAACE,gBAAzB,EAA2C;AACvC,cAAM1C,MAAM,GAAGwC,QAAQ,CAACG,QAAT,GAAoB1C,SAApB,EAAf;AACAD,gBAAM,CAACG,aAAP,CAAqB,KAArB;AACAH,gBAAM,CAACc,YAAP,CAAoB,CAApB;AACAW,iBAAO,CAACZ,MAAR,CAAe,KAAf;AACAb,gBAAM,CAACG,aAAP,CAAqB,IAArB;AACH;AACJ;;AAEDsB,aAAO,CAACZ,MAAR,CAAeU,WAAf;AACH;AACJ,GAtCc;AAwCf;;;;;;AAIe5C,mCAAf,UAA+BuC,SAA/B,EAA6D;AACzD,SAAK,IAAIM,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGN,SAAS,CAAChB,MAA5C,EAAoDsB,QAAQ,EAA5D,EAAgE;AAC5D,UAAMoB,OAAO,GAAG1B,SAAS,CAACD,IAAV,CAAeO,QAAf,CAAhB;AACAoB,aAAO,CAAC/B,MAAR,CAAe,KAAf;AACH;AACJ,GALc;AAOf;;;;;;;;AAQA;;;AACclC,iDAAd,UAA4CkE,CAA5C,EAAwDC,CAAxD,EAAkE;AAC9D;AACA,QAAID,CAAC,CAAChB,WAAF,GAAgBiB,CAAC,CAACjB,WAAtB,EAAmC;AAC/B,aAAO,CAAP;AACH;;AACD,QAAIgB,CAAC,CAAChB,WAAF,GAAgBiB,CAAC,CAACjB,WAAtB,EAAmC;AAC/B,aAAO,CAAC,CAAR;AACH,KAP6D,CAS9D;;;AACA,WAAOlD,cAAc,CAACoE,sBAAf,CAAsCF,CAAtC,EAAyCC,CAAzC,CAAP;AACH,GAXa;AAad;;;;;;;;AAQA;;;AACcnE,0CAAd,UAAqCkE,CAArC,EAAiDC,CAAjD,EAA2D;AACvD;AACA,QAAID,CAAC,CAACb,iBAAF,GAAsBc,CAAC,CAACd,iBAA5B,EAA+C;AAC3C,aAAO,CAAP;AACH;;AACD,QAAIa,CAAC,CAACb,iBAAF,GAAsBc,CAAC,CAACd,iBAA5B,EAA+C;AAC3C,aAAO,CAAC,CAAR;AACH;;AAED,WAAO,CAAP;AACH,GAVa;AAYd;;;;;;;;AAQA;;;AACcrD,0CAAd,UAAqCkE,CAArC,EAAiDC,CAAjD,EAA2D;AACvD;AACA,QAAID,CAAC,CAACb,iBAAF,GAAsBc,CAAC,CAACd,iBAA5B,EAA+C;AAC3C,aAAO,CAAC,CAAR;AACH;;AACD,QAAIa,CAAC,CAACb,iBAAF,GAAsBc,CAAC,CAACd,iBAA5B,EAA+C;AAC3C,aAAO,CAAP;AACH;;AAED,WAAO,CAAP;AACH,GAVa;AAYd;;;;;AAGOrD,qCAAP;AACI,SAAKiB,gBAAL,CAAsBoD,KAAtB;;AACA,SAAKlD,qBAAL,CAA2BkD,KAA3B;;AACA,SAAKnD,mBAAL,CAAyBmD,KAAzB;;AACA,SAAKjD,mBAAL,CAAyBiD,KAAzB;;AACA,SAAKC,gBAAL,CAAsBD,KAAtB;;AACA,SAAKE,eAAL,CAAqBF,KAArB;;AACA,SAAKjC,eAAL,CAAqBiC,KAArB;;AACA,SAAKG,MAAL,GAAc,IAAd;AACH,GATM;;AAWAxE,qCAAP;AACI,SAAKiB,gBAAL,CAAsBwD,OAAtB;;AACA,SAAKtD,qBAAL,CAA2BsD,OAA3B;;AACA,SAAKvD,mBAAL,CAAyBuD,OAAzB;;AACA,SAAKrD,mBAAL,CAAyBqD,OAAzB;;AACA,SAAKH,gBAAL,CAAsBG,OAAtB;;AACA,SAAKF,eAAL,CAAqBE,OAArB;;AACA,SAAKrC,eAAL,CAAqBqC,OAArB;AACH,GARM;AAUP;;;;;;;;AAMOzE,sCAAP,UAAgB8C,OAAhB,EAAkC4B,IAAlC,EAAuDb,QAAvD,EAAoF;AAChF;AACA,QAAIa,IAAI,KAAKC,SAAb,EAAwB;AACpBD,UAAI,GAAG5B,OAAO,CAACK,OAAR,EAAP;AACH;;AACD,QAAIU,QAAQ,KAAKc,SAAjB,EAA4B;AACxBd,cAAQ,GAAGf,OAAO,CAACgB,WAAR,EAAX;AACH;;AAED,QAAID,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAKc,SAAtC,EAAiD;AAC7C;AACH;;AAED,QAAId,QAAQ,CAACe,wBAAT,CAAkCF,IAAlC,CAAJ,EAA6C;AACzC;AACA,WAAKvD,qBAAL,CAA2B0D,IAA3B,CAAgC/B,OAAhC;AACH,KAHD,MAGO,IAAIe,QAAQ,CAACiB,gBAAT,EAAJ,EAAiC;AACpC;AACA,UAAIjB,QAAQ,CAACE,gBAAb,EAA+B;AAC3B,aAAK3C,mBAAL,CAAyByD,IAAzB,CAA8B/B,OAA9B;AACH;;AAED,WAAK5B,mBAAL,CAAyB2D,IAAzB,CAA8B/B,OAA9B;AACH,KAPM,MAOA;AACH,UAAIe,QAAQ,CAACE,gBAAb,EAA+B;AAC3B,aAAK3C,mBAAL,CAAyByD,IAAzB,CAA8B/B,OAA9B;AACH;;AAED,WAAK7B,gBAAL,CAAsB4D,IAAtB,CAA2B/B,OAA3B,EALG,CAKkC;;AACxC;;AAED4B,QAAI,CAACK,eAAL,GAAuB,IAAvB;;AAEA,QAAIL,IAAI,CAACM,cAAL,IAAuBN,IAAI,CAACM,cAAL,CAAoBC,SAA/C,EAA0D;AACtD,WAAK7C,eAAL,CAAqB8C,eAArB,CAAqCR,IAAI,CAACM,cAA1C;AACH;;AAED,SAAKR,MAAL,GAAc,KAAd;AACH,GAtCM;;AAwCAxE,6CAAP,UAAuBmF,aAAvB,EAAoD;AAChD,SAAKZ,eAAL,CAAqBM,IAArB,CAA0BM,aAA1B;;AACA,SAAKX,MAAL,GAAc,KAAd;AACH,GAHM;;AAKAxE,+CAAP,UAAyBoF,cAAzB,EAAwD;AACpD,SAAKd,gBAAL,CAAsBO,IAAtB,CAA2BO,cAA3B;;AACA,SAAKZ,MAAL,GAAc,KAAd;AACH,GAHM;;AAKCxE,8CAAR,UAAyBgB,YAAzB,EAA+D;AAC3D,QAAI,KAAKsD,gBAAL,CAAsB/C,MAAtB,KAAiC,CAArC,EAAwC;AACpC;AACH,KAH0D,CAK3D;;;AACA,QAAMkB,YAAY,GAAG,KAAK3C,MAAL,CAAY2C,YAAjC;;AACA,SAAK3C,MAAL,CAAYuF,oCAAZ,CAAiDC,eAAjD,CAAiE,KAAKxF,MAAtE;;AACA,SAAK,IAAIyF,aAAa,GAAG,CAAzB,EAA4BA,aAAa,GAAG,KAAKjB,gBAAL,CAAsB/C,MAAlE,EAA0EgE,aAAa,EAAvF,EAA2F;AACvF,UAAMH,cAAc,GAAG,KAAKd,gBAAL,CAAsBhC,IAAtB,CAA2BiD,aAA3B,CAAvB;;AAEA,UAAI,CAAC9C,YAAY,IAAIA,YAAY,CAAC+C,SAAb,GAAyBJ,cAAc,CAACI,SAAzD,MAAwE,CAA5E,EAA+E;AAC3E;AACH;;AAED,UAAMC,OAAO,GAAQL,cAAc,CAACK,OAApC;;AACA,UAAI,CAACA,OAAO,CAACC,QAAT,IAAqB,CAAC1E,YAAtB,IAAsCA,YAAY,CAAC2E,OAAb,CAAqBF,OAArB,MAAkC,CAAC,CAA7E,EAAgF;AAC5E,aAAK3F,MAAL,CAAY8F,gBAAZ,CAA6BC,QAA7B,CAAsCT,cAAc,CAAClD,MAAf,EAAtC,EAA+D,KAA/D;AACH;AACJ;;AACD,SAAKpC,MAAL,CAAYgG,mCAAZ,CAAgDR,eAAhD,CAAgE,KAAKxF,MAArE;AACH,GArBO;;AAuBAE,4CAAR;AACI,QAAI,CAAC,KAAKF,MAAL,CAAYiG,cAAb,IAA+B,KAAKxB,eAAL,CAAqBhD,MAArB,KAAgC,CAAnE,EAAsE;AAClE;AACH,KAHL,CAKI;;;AACA,QAAMkB,YAAY,GAAG,KAAK3C,MAAL,CAAY2C,YAAjC;;AACA,SAAK3C,MAAL,CAAYkG,kCAAZ,CAA+CV,eAA/C,CAA+D,KAAKxF,MAApE;;AACA,SAAK,IAAImG,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,KAAK1B,eAAL,CAAqBhD,MAA3C,EAAmD0E,EAAE,EAArD,EAAyD;AACrD,UAAMd,aAAa,GAAG,KAAKZ,eAAL,CAAqBjC,IAArB,CAA0B2D,EAA1B,CAAtB;;AAEA,UAAI,CAACxD,YAAY,IAAIA,YAAY,CAAC+C,SAAb,GAAyBL,aAAa,CAACK,SAAxD,MAAuE,CAA3E,EAA8E;AAC1EL,qBAAa,CAACjD,MAAd;AACH;AACJ;;AACD,SAAKpC,MAAL,CAAYoG,iCAAZ,CAA8CZ,eAA9C,CAA8D,KAAKxF,MAAnE;AACH,GAhBO;;AA5aOE,+BAAsCR,OAAO,CAAC2G,IAAR,EAAtC;AA6bnB;AAAC,CA9bD;;SAAanG","names":["SmartArray","SmartArrayNoDuplicate","Vector3","index","scene","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","_scene","Object","RenderingGroup","value","_opaqueSortCompareFn","_renderOpaque","_renderOpaqueSorted","_RenderUnsorted","_alphaTestSortCompareFn","_renderAlphaTest","_renderAlphaTestSorted","_transparentSortCompareFn","defaultTransparentSortCompare","_renderTransparent","_renderTransparentSorted","customRenderFunction","renderSprites","renderParticles","activeMeshes","_opaqueSubMeshes","_alphaTestSubMeshes","_transparentSubMeshes","_depthOnlySubMeshes","engine","getEngine","length","setColorWrite","stencilState","getStencilBuffer","setStencilBuffer","_renderSprites","_renderParticles","onBeforeTransparentRendering","useOrderIndependentTransparency","excludedMeshes","depthPeelingRenderer","render","setAlphaMode","_edgesRenderers","edgesRendererIndex","data","subMeshes","_RenderSorted","activeCamera","sortCompareFn","camera","transparent","subIndex","subMesh","cameraPosition","globalPosition","_ZeroVector","_alphaIndex","getMesh","alphaIndex","_distanceToCamera","Distance","getBoundingInfo","boundingSphere","centerWorld","sortedArray","slice","sort","material","getMaterial","needDepthPrePass","getScene","submesh","a","b","backToFrontSortCompare","reset","_particleSystems","_spriteManagers","_empty","dispose","mesh","undefined","needAlphaBlendingForMesh","push","needAlphaTesting","_renderingGroup","_edgesRenderer","isEnabled","pushNoDuplicate","spriteManager","particleSystem","onBeforeParticlesRenderingObservable","notifyObservers","particleIndex","layerMask","emitter","position","indexOf","_activeParticles","addCount","onAfterParticlesRenderingObservable","spritesEnabled","onBeforeSpritesRenderingObservable","id","onAfterSpritesRenderingObservable","Zero"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/renderingGroup.ts"],"sourcesContent":["import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @hidden\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @hidden */\r\n    public _empty = true;\r\n\r\n    /** @hidden */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        this._opaqueSortCompareFn = value;\r\n        if (value) {\r\n            this._renderOpaque = this._renderOpaqueSorted;\r\n        } else {\r\n            this._renderOpaque = RenderingGroup._RenderUnsorted;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        this._alphaTestSortCompareFn = value;\r\n        if (value) {\r\n            this._renderAlphaTest = this._renderAlphaTestSorted;\r\n        } else {\r\n            this._renderAlphaTest = RenderingGroup._RenderUnsorted;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     * @returns true if rendered some submeshes.\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n        for (; subIndex < subMeshes.length; subIndex++) {\r\n            subMesh = subMeshes.data[subIndex];\r\n            subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n            subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n        }\r\n\r\n        const sortedArray = subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in the order they were dispatched (no sort applied).\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private static _RenderUnsorted(subMeshes: SmartArray<SubMesh>): void {\r\n        for (let subIndex = 0; subIndex < subMeshes.length; subIndex++) {\r\n            const submesh = subMeshes.data[subIndex];\r\n            submesh.render(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this._spriteManagers.reset();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTesting()) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}