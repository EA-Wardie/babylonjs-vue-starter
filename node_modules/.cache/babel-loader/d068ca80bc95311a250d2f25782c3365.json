{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\n */\n\nvar FramingBehavior =\n/** @class */\nfunction () {\n  function FramingBehavior() {\n    /**\n     * An event triggered when the animation to zoom on target mesh has ended\n     */\n    this.onTargetFramingAnimationEndObservable = new Observable();\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\n     * Define if the behavior should automatically change the configured\n     * camera limits and sensibilities.\n     */\n\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity; // Framing control\n\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n\n  Object.defineProperty(FramingBehavior.prototype, \"name\", {\n    /**\n     * Gets the name of the behavior.\n     */\n    get: function get() {\n      return \"Framing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"mode\", {\n    /**\n     * Gets current mode used by the behavior.\n     */\n    get: function get() {\n      return this._mode;\n    },\n\n    /**\n     * Sets the current mode used by the behavior\n     */\n    set: function set(mode) {\n      this._mode = mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"radiusScale\", {\n    /**\n     * Gets the scale applied to the radius\n     */\n    get: function get() {\n      return this._radiusScale;\n    },\n\n    /**\n     * Sets the scale applied to the radius (1 by default)\n     */\n    set: function set(radius) {\n      this._radiusScale = radius;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"positionScale\", {\n    /**\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n     */\n    get: function get() {\n      return this._positionScale;\n    },\n\n    /**\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n     */\n    set: function set(scale) {\n      this._positionScale = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"defaultElevation\", {\n    /**\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\n     * behaviour is triggered, in radians.\n     */\n    get: function get() {\n      return this._defaultElevation;\n    },\n\n    /**\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\n     * behaviour is triggered, in radians.\n     */\n    set: function set(elevation) {\n      this._defaultElevation = elevation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnTime\", {\n    /**\n     * Gets the time (in milliseconds) taken to return to the default beta position.\n     * Negative value indicates camera should not return to default.\n     */\n    get: function get() {\n      return this._elevationReturnTime;\n    },\n\n    /**\n     * Sets the time (in milliseconds) taken to return to the default beta position.\n     * Negative value indicates camera should not return to default.\n     */\n    set: function set(speed) {\n      this._elevationReturnTime = speed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnWaitTime\", {\n    /**\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\n     */\n    get: function get() {\n      return this._elevationReturnWaitTime;\n    },\n\n    /**\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\n     */\n    set: function set(time) {\n      this._elevationReturnWaitTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"zoomStopsAnimation\", {\n    /**\n     * Gets the flag that indicates if user zooming should stop animation.\n     */\n    get: function get() {\n      return this._zoomStopsAnimation;\n    },\n\n    /**\n     * Sets the flag that indicates if user zooming should stop animation.\n     */\n    set: function set(flag) {\n      this._zoomStopsAnimation = flag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"framingTime\", {\n    /**\n     * Gets the transition time when framing the mesh, in milliseconds\n     */\n    get: function get() {\n      return this._framingTime;\n    },\n\n    /**\n     * Sets the transition time when framing the mesh, in milliseconds\n     */\n    set: function set(time) {\n      this._framingTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initializes the behavior.\n   */\n\n  FramingBehavior.prototype.init = function () {// Do nothing\n  };\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n\n\n  FramingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n\n    var scene = this._attachedCamera.getScene();\n\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        _this._isPointerDown = true;\n        return;\n      }\n\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        _this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n      if (mesh) {\n        _this.zoomOnMesh(mesh, undefined, function () {\n          _this.onTargetFramingAnimationEndObservable.notifyObservers();\n        });\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      _this._applyUserInteraction(); // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n\n\n      _this._maintainCameraAboveGround();\n    });\n  };\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n\n\n  FramingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    var scene = this._attachedCamera.getScene();\n\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\n   * Targets the given mesh and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n\n\n  FramingBehavior.prototype.zoomOnMesh = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\n   * Targets the given mesh with its children and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshHierarchy = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\n   * Targets the given meshes with their children and updates zoom level accordingly.\n   * @param meshes  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshesHierarchy = function (meshes, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\n   * @param minimumWorld Determines the smaller position of the bounding box extend\n   * @param maximumWorld Determines the bigger position of the bounding box extend\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n\n\n  FramingBehavior.prototype.zoomOnBoundingInfo = function (minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {\n    var _this = this;\n\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var zoomTarget;\n\n    if (!this._attachedCamera) {\n      return;\n    } // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n\n\n    var bottom = minimumWorld.y;\n    var top = maximumWorld.y;\n    var zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      var centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n\n    this._betaIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    } // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n\n\n    var radius = 0;\n\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    } // Set sensibilities\n\n\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      var extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    } // transition to new radius\n\n\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {\n      _this.stopAllAnimations();\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {\n        _this._attachedCamera.storeState();\n      }\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\n   * @param minimumWorld\n   * @param maximumWorld\n   * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\n   *\t\t to fully enclose the mesh in the viewing frustum.\n   */\n\n\n  FramingBehavior.prototype._calculateLowerRadiusFromModelBoundingSphere = function (minimumWorld, maximumWorld) {\n    var size = maximumWorld.subtract(minimumWorld);\n    var boxVectorGlobalDiagonal = size.length();\n\n    var frustumSlope = this._getFrustumSlope(); // Formula for setting distance\n    // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\n\n\n    var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5; // Horizon distance\n\n    var radius = radiusWithoutFraming * this._radiusScale;\n    var distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\n    var distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\n    var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return 0;\n    }\n\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    } // Don't exceed the upper radius limit\n\n\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n\n    return distance;\n  };\n  /**\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\n   * is automatically returned to its default position (expected to be above ground plane).\n   */\n\n\n  FramingBehavior.prototype._maintainCameraAboveGround = function () {\n    var _this = this;\n\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n\n    var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    var defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    var limitBeta = Math.PI * 0.5; // Bring the camera back up if below the ground plane\n\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true; //Transition to new position\n\n      this.stopAllAnimations();\n\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n\n      var animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {\n        _this._clearAnimationLocks();\n\n        _this.stopAllAnimations();\n      });\n\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  };\n  /**\n   * Returns the frustum slope based on the canvas ratio and camera FOV\n   * @returns The frustum slope represented as a Vector2 with X and Y slopes\n   */\n\n\n  FramingBehavior.prototype._getFrustumSlope = function () {\n    // Calculate the viewport ratio\n    // Aspect Ratio is Height/Width.\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return Vector2.Zero();\n    }\n\n    var engine = camera.getScene().getEngine();\n    var aspectRatio = engine.getAspectRatio(camera); // Camera FOV is the vertical field of view (top-bottom) in radians.\n    // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\n\n    var frustumSlopeY = Math.tan(camera.fov / 2); // Slope of the frustum left/right planes in view space, relative to the forward vector.\n    // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\n    // along the forward vector.\n\n    var frustumSlopeX = frustumSlopeY * aspectRatio;\n    return new Vector2(frustumSlopeX, frustumSlopeY);\n  };\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\n   */\n\n\n  FramingBehavior.prototype._clearAnimationLocks = function () {\n    this._betaIsAnimating = false;\n  };\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n\n\n  FramingBehavior.prototype._applyUserInteraction = function () {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n\n      this._clearAnimationLocks();\n    }\n  };\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n\n\n  FramingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n\n        this._animatables[0].stop();\n      }\n\n      this._animatables.shift();\n    }\n  };\n\n  Object.defineProperty(FramingBehavior.prototype, \"isUserIsMoving\", {\n    /**\n     * Gets a value indicating if the user is moving the camera\n     */\n    get: function get() {\n      if (!this._attachedCamera) {\n        return false;\n      }\n\n      return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * The easing function used by animations\n   */\n\n  FramingBehavior.EasingFunction = new ExponentialEase();\n  /**\n   * The easing mode used by animations\n   */\n\n  FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT; // Statics\n\n  /**\n   * The camera can move all the way towards the mesh.\n   */\n\n  FramingBehavior.IgnoreBoundsSizeMode = 0;\n  /**\n   * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\n   */\n\n  FramingBehavior.FitFrustumSidesMode = 1;\n  return FramingBehavior;\n}();\n\nexport { FramingBehavior };","map":{"version":3,"mappings":"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","names":["ExponentialEase","EasingFunction","Observable","PointerEventTypes","PrecisionDate","Vector3","Vector2","Animation","FramingBehavior","FitFrustumSidesMode","Infinity","Array","Object","_mode","mode","_radiusScale","radius","_positionScale","scale","_defaultElevation","elevation","_elevationReturnTime","speed","_elevationReturnWaitTime","time","_zoomStopsAnimation","flag","_framingTime","camera","_attachedCamera","scene","getScene","setEasingMode","EasingMode","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","_this","_isPointerDown","POINTERUP","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","mesh","zoomOnMesh","undefined","onTargetFramingAnimationEndObservable","notifyObservers","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_applyUserInteraction","_maintainCameraAboveGround","remove","focusOnOriginXZ","onAnimationEnd","computeWorldMatrix","boundingBox","getBoundingInfo","zoomOnBoundingInfo","minimumWorld","maximumWorld","getHierarchyBoundingVectors","min","max","meshes","Number","MAX_VALUE","i","length","boundingInfo","CheckExtends","zoomTarget","bottom","y","top","zoomTargetY","radiusWorld","subtract","centerWorld","x","z","_vectorTransition","CreateAnimation","ANIMATIONTYPE_VECTOR3","_betaIsAnimating","animatable","TransitionTo","_animatables","push","position","_calculateLowerRadiusFromModelBoundingSphere","autoCorrectCameraLimitsAndSensibility","lowerRadiusLimit","minZ","IgnoreBoundsSizeMode","extend","panningSensibility","wheelPrecision","_radiusTransition","ANIMATIONTYPE_FLOAT","stopAllAnimations","useInputToRestoreState","storeState","size","boxVectorGlobalDiagonal","frustumSlope","_getFrustumSlope","radiusWithoutFraming","distanceForHorizontalFrustum","Math","sqrt","distanceForVerticalFrustum","distance","upperRadiusLimit","timeSinceInteraction","Now","_lastInteractionTime","defaultBeta","PI","limitBeta","beta","_betaTransition","animatabe","_clearAnimationLocks","Zero","engine","getEngine","aspectRatio","getAspectRatio","frustumSlopeY","tan","fov","frustumSlopeX","isUserIsMoving","animations","stop","shift","inertialAlphaOffset","inertialBetaOffset","inertialRadiusOffset","inertialPanningX","inertialPanningY","EASINGMODE_EASEINOUT"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Cameras/framingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const size = maximumWorld.subtract(minimumWorld);\r\n        const boxVectorGlobalDiagonal = size.length();\r\n        const frustumSlope: Vector2 = this._getFrustumSlope();\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * this._radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\r\n        let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the frustum slope based on the canvas ratio and camera FOV\r\n     * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n     */\r\n    private _getFrustumSlope(): Vector2 {\r\n        // Calculate the viewport ratio\r\n        // Aspect Ratio is Height/Width.\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const engine = camera.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(camera);\r\n\r\n        // Camera FOV is the vertical field of view (top-bottom) in radians.\r\n        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\r\n        const frustumSlopeY = Math.tan(camera.fov / 2);\r\n\r\n        // Slope of the frustum left/right planes in view space, relative to the forward vector.\r\n        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\r\n        // along the forward vector.\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        return new Vector2(frustumSlopeX, frustumSlopeY);\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}