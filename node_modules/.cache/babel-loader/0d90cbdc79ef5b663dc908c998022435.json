{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport { __extends } from \"tslib\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\"; // Ensures Raw texture are included\n\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\n * It can help converting any input color in a desired output one. This can then be used to create effects\n * from sepia, black and white to sixties or futuristic rendering...\n *\n * The only supported format is currently 3dl.\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\n */\n\nvar ColorGradingTexture =\n/** @class */\nfunction (_super) {\n  __extends(ColorGradingTexture, _super);\n  /**\n   * Instantiates a ColorGradingTexture from the following parameters.\n   *\n   * @param url The location of the color grading data (currently only supporting 3dl)\n   * @param sceneOrEngine The scene or engine the texture will be used in\n   * @param onLoad defines a callback triggered when the texture has been loaded\n   */\n\n\n  function ColorGradingTexture(url, sceneOrEngine, onLoad) {\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    var _this = _super.call(this, sceneOrEngine) || this;\n\n    if (!url) {\n      return _this;\n    }\n\n    _this._textureMatrix = Matrix.Identity();\n    _this.name = url;\n    _this.url = url;\n    _this._onLoad = onLoad;\n    _this._texture = _this._getFromCache(url, true);\n\n    if (!_this._texture) {\n      var scene = _this.getScene();\n\n      if (scene) {\n        if (!scene.useDelayedTextureLoading) {\n          _this._loadTexture();\n        } else {\n          _this.delayLoadState = 4;\n        }\n      } else {\n        _this._loadTexture();\n      }\n    } else {\n      _this._triggerOnLoad();\n    }\n\n    return _this;\n  }\n  /**\n   * Fires the onload event from the constructor if requested.\n   */\n\n\n  ColorGradingTexture.prototype._triggerOnLoad = function () {\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  };\n  /**\n   * Returns the texture matrix used in most of the material.\n   * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\n   */\n\n\n  ColorGradingTexture.prototype.getTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\n   * Occurs when the file being loaded is a .3dl LUT file.\n   */\n\n\n  ColorGradingTexture.prototype._load3dlTexture = function () {\n    var _this = this;\n\n    var engine = this._getEngine();\n\n    var texture;\n\n    if (!engine._features.support3DTextures) {\n      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n    } else {\n      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n    }\n\n    this._texture = texture;\n    this._texture.isReady = false;\n    this.isCube = false;\n    this.is3D = engine._features.support3DTextures;\n    this.wrapU = 0;\n    this.wrapV = 0;\n    this.wrapR = 0;\n    this.anisotropicFilteringLevel = 1;\n\n    var callback = function callback(text) {\n      if (typeof text !== \"string\") {\n        return;\n      }\n\n      var data = null;\n      var tempData = null;\n      var line;\n      var lines = text.split(\"\\n\");\n      var size = 0,\n          pixelIndexW = 0,\n          pixelIndexH = 0,\n          pixelIndexSlice = 0;\n      var maxColor = 0;\n\n      for (var i = 0; i < lines.length; i++) {\n        line = lines[i];\n\n        if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\n          continue;\n        }\n\n        if (line.indexOf(\"#\") === 0) {\n          continue;\n        }\n\n        var words = line.split(\" \");\n\n        if (size === 0) {\n          // Number of space + one\n          size = words.length;\n          data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n\n          tempData = new Float32Array(size * size * size * 4);\n          continue;\n        }\n\n        if (size != 0) {\n          var r = Math.max(parseInt(words[0]), 0);\n          var g = Math.max(parseInt(words[1]), 0);\n          var b = Math.max(parseInt(words[2]), 0);\n          maxColor = Math.max(r, maxColor);\n          maxColor = Math.max(g, maxColor);\n          maxColor = Math.max(b, maxColor);\n          var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n\n          if (tempData) {\n            tempData[pixelStorageIndex + 0] = r;\n            tempData[pixelStorageIndex + 1] = g;\n            tempData[pixelStorageIndex + 2] = b;\n          } // Keep for reference in case of back compat problems.\n          // pixelIndexSlice++;\n          // if (pixelIndexSlice % size == 0) {\n          //     pixelIndexH++;\n          //     pixelIndexSlice = 0;\n          //     if (pixelIndexH % size == 0) {\n          //         pixelIndexW++;\n          //         pixelIndexH = 0;\n          //     }\n          // }\n\n\n          pixelIndexH++;\n\n          if (pixelIndexH % size == 0) {\n            pixelIndexSlice++;\n            pixelIndexH = 0;\n\n            if (pixelIndexSlice % size == 0) {\n              pixelIndexW++;\n              pixelIndexSlice = 0;\n            }\n          }\n        }\n      }\n\n      if (tempData && data) {\n        for (var i = 0; i < tempData.length; i++) {\n          if (i > 0 && (i + 1) % 4 === 0) {\n            data[i] = 255;\n          } else {\n            var value = tempData[i];\n            data[i] = value / maxColor * 255;\n          }\n        }\n      }\n\n      if (texture.is3D) {\n        texture.updateSize(size, size, size);\n        engine.updateRawTexture3D(texture, data, 5, false);\n      } else {\n        texture.updateSize(size * size, size);\n        engine.updateRawTexture(texture, data, 5, false);\n      }\n\n      texture.isReady = true;\n\n      _this._triggerOnLoad();\n    };\n\n    var scene = this.getScene();\n\n    if (scene) {\n      scene._loadFile(this.url, callback);\n    } else {\n      engine._loadFile(this.url, callback);\n    }\n\n    return this._texture;\n  };\n  /**\n   * Starts the loading process of the texture.\n   */\n\n\n  ColorGradingTexture.prototype._loadTexture = function () {\n    if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n      this._load3dlTexture();\n    }\n  };\n  /**\n   * Clones the color grading texture.\n   */\n\n\n  ColorGradingTexture.prototype.clone = function () {\n    var newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()); // Base texture\n\n    newTexture.level = this.level;\n    return newTexture;\n  };\n  /**\n   * Called during delayed load for textures.\n   */\n\n\n  ColorGradingTexture.prototype.delayLoad = function () {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, true);\n\n    if (!this._texture) {\n      this._loadTexture();\n    }\n  };\n  /**\n   * Parses a color grading texture serialized by Babylon.\n   * @param parsedTexture The texture information being parsedTexture\n   * @param scene The scene to load the texture in\n   * @return A color grading texture\n   */\n\n\n  ColorGradingTexture.Parse = function (parsedTexture, scene) {\n    var texture = null;\n\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new ColorGradingTexture(parsedTexture.name, scene);\n      texture.name = parsedTexture.name;\n      texture.level = parsedTexture.level;\n    }\n\n    return texture;\n  };\n  /**\n   * Serializes the LUT texture to json format.\n   */\n\n\n  ColorGradingTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.level = this.level;\n    serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n    return serializationObject;\n  };\n  /**\n   * Empty line regex stored for GC.\n   */\n\n\n  ColorGradingTexture._NoneEmptyLineRegex = /\\S+/;\n  return ColorGradingTexture;\n}(BaseTexture);\n\nexport { ColorGradingTexture };\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);","map":{"version":3,"mappings":"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","names":["Matrix","BaseTexture","RegisterClass","__extends","url","sceneOrEngine","onLoad","_super","_this","_textureMatrix","Identity","name","_onLoad","_texture","_getFromCache","scene","getScene","useDelayedTextureLoading","_loadTexture","delayLoadState","_triggerOnLoad","ColorGradingTexture","engine","_getEngine","texture","_features","support3DTextures","createRawTexture","createRawTexture3D","isReady","isCube","is3D","wrapU","wrapV","wrapR","anisotropicFilteringLevel","callback","text","data","tempData","line","lines","split","size","pixelIndexW","pixelIndexH","pixelIndexSlice","maxColor","i","length","_NoneEmptyLineRegex","test","indexOf","words","Uint8Array","Float32Array","r","Math","max","parseInt","g","b","pixelStorageIndex","value","updateSize","updateRawTexture3D","updateRawTexture","_loadFile","toLocaleLowerCase","_load3dlTexture","newTexture","level","parsedTexture","isRenderTarget","serializationObject","customType"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/colorGradingTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\n// Ensures Raw texture are included\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\r\nexport class ColorGradingTexture extends BaseTexture {\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * Empty line regex stored for GC.\r\n     */\r\n    private static _NoneEmptyLineRegex = /\\S+/;\r\n\r\n    private _textureMatrix: Matrix;\r\n    private _onLoad: Nullable<() => void>;\r\n\r\n    /**\r\n     * Instantiates a ColorGradingTexture from the following parameters.\r\n     *\r\n     * @param url The location of the color grading data (currently only supporting 3dl)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     */\r\n    constructor(url: string, sceneOrEngine: Scene | ThinEngine, onLoad: Nullable<() => void> = null) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.name = url;\r\n        this.url = url;\r\n        this._onLoad = onLoad;\r\n\r\n        this._texture = this._getFromCache(url, true);\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (scene) {\r\n                if (!scene.useDelayedTextureLoading) {\r\n                    this._loadTexture();\r\n                } else {\r\n                    this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n                }\r\n            } else {\r\n                this._loadTexture();\r\n            }\r\n        } else {\r\n            this._triggerOnLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fires the onload event from the constructor if requested.\r\n     */\r\n    private _triggerOnLoad(): void {\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture matrix used in most of the material.\r\n     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file being loaded is a .3dl LUT file.\r\n     */\r\n    private _load3dlTexture() {\r\n        const engine = this._getEngine()!;\r\n        let texture: InternalTexture;\r\n        if (!engine._features.support3DTextures) {\r\n            texture = engine.createRawTexture(\r\n                null,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        } else {\r\n            texture = engine.createRawTexture3D(\r\n                null,\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        }\r\n\r\n        this._texture = texture;\r\n        this._texture.isReady = false;\r\n\r\n        this.isCube = false;\r\n        this.is3D = engine._features.support3DTextures;\r\n        this.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapR = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.anisotropicFilteringLevel = 1;\r\n\r\n        const callback = (text: string | ArrayBuffer) => {\r\n            if (typeof text !== \"string\") {\r\n                return;\r\n            }\r\n\r\n            let data: Nullable<Uint8Array> = null;\r\n            let tempData: Nullable<Float32Array> = null;\r\n\r\n            let line: string;\r\n            const lines = text.split(\"\\n\");\r\n            let size = 0,\r\n                pixelIndexW = 0,\r\n                pixelIndexH = 0,\r\n                pixelIndexSlice = 0;\r\n            let maxColor = 0;\r\n\r\n            for (let i = 0; i < lines.length; i++) {\r\n                line = lines[i];\r\n\r\n                if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\r\n                    continue;\r\n                }\r\n\r\n                if (line.indexOf(\"#\") === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const words = line.split(\" \");\r\n                if (size === 0) {\r\n                    // Number of space + one\r\n                    size = words.length;\r\n                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\r\n                    tempData = new Float32Array(size * size * size * 4);\r\n                    continue;\r\n                }\r\n\r\n                if (size != 0) {\r\n                    const r = Math.max(parseInt(words[0]), 0);\r\n                    const g = Math.max(parseInt(words[1]), 0);\r\n                    const b = Math.max(parseInt(words[2]), 0);\r\n\r\n                    maxColor = Math.max(r, maxColor);\r\n                    maxColor = Math.max(g, maxColor);\r\n                    maxColor = Math.max(b, maxColor);\r\n\r\n                    const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\r\n\r\n                    if (tempData) {\r\n                        tempData[pixelStorageIndex + 0] = r;\r\n                        tempData[pixelStorageIndex + 1] = g;\r\n                        tempData[pixelStorageIndex + 2] = b;\r\n                    }\r\n\r\n                    // Keep for reference in case of back compat problems.\r\n                    // pixelIndexSlice++;\r\n                    // if (pixelIndexSlice % size == 0) {\r\n                    //     pixelIndexH++;\r\n                    //     pixelIndexSlice = 0;\r\n                    //     if (pixelIndexH % size == 0) {\r\n                    //         pixelIndexW++;\r\n                    //         pixelIndexH = 0;\r\n                    //     }\r\n                    // }\r\n\r\n                    pixelIndexH++;\r\n                    if (pixelIndexH % size == 0) {\r\n                        pixelIndexSlice++;\r\n                        pixelIndexH = 0;\r\n                        if (pixelIndexSlice % size == 0) {\r\n                            pixelIndexW++;\r\n                            pixelIndexSlice = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (tempData && data) {\r\n                for (let i = 0; i < tempData.length; i++) {\r\n                    if (i > 0 && (i + 1) % 4 === 0) {\r\n                        data[i] = 255;\r\n                    } else {\r\n                        const value = tempData[i];\r\n                        data[i] = (value / maxColor) * 255;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture.is3D) {\r\n                texture.updateSize(size, size, size);\r\n                engine.updateRawTexture3D(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            } else {\r\n                texture.updateSize(size * size, size);\r\n                engine.updateRawTexture(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            }\r\n\r\n            texture.isReady = true;\r\n            this._triggerOnLoad();\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene._loadFile(this.url, callback);\r\n        } else {\r\n            engine._loadFile(this.url, callback);\r\n        }\r\n\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Starts the loading process of the texture.\r\n     */\r\n    private _loadTexture() {\r\n        if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\r\n            this._load3dlTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the color grading texture.\r\n     */\r\n    public clone(): ColorGradingTexture {\r\n        const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()!);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Called during delayed load for textures.\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, true);\r\n\r\n        if (!this._texture) {\r\n            this._loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a color grading texture serialized by Babylon.\r\n     * @param parsedTexture The texture information being parsedTexture\r\n     * @param scene The scene to load the texture in\r\n     * @return A color grading texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): Nullable<ColorGradingTexture> {\r\n        let texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new ColorGradingTexture(parsedTexture.name, scene);\r\n            texture.name = parsedTexture.name;\r\n            texture.level = parsedTexture.level;\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the LUT texture to json format.\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.level = this.level;\r\n        serializationObject.customType = \"BABYLON.ColorGradingTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);\r\n"]},"metadata":{},"sourceType":"module"}