{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Options for the controller physics feature\n */\n\nvar IWebXRControllerPhysicsOptions =\n/** @class */\nfunction () {\n  function IWebXRControllerPhysicsOptions() {}\n\n  return IWebXRControllerPhysicsOptions;\n}();\n\nexport { IWebXRControllerPhysicsOptions };\n/**\n * Add physics impostor to your webxr controllers,\n * including naive calculation of their linear and angular velocity\n */\n\nvar WebXRControllerPhysics =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPhysics, _super);\n  /**\n   * Construct a new Controller Physics Feature\n   * @param _xrSessionManager the corresponding xr session manager\n   * @param _options options to create this feature with\n   */\n\n\n  function WebXRControllerPhysics(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      if (!_this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      } // if no motion controller available, create impostors!\n\n\n      if (_this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(function (motionController) {\n          if (!motionController._doNotLoadControllerMesh) {\n            motionController.onModelLoadedObservable.addOnce(function () {\n              var impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, __assign({\n                mass: 0\n              }, _this._options.physicsProperties));\n              var controllerMesh = xrController.grip || xrController.pointer;\n              _this._controllers[xrController.uniqueId] = {\n                xrController: xrController,\n                impostor: impostor,\n                oldPos: controllerMesh.position.clone(),\n                oldRotation: controllerMesh.rotationQuaternion.clone()\n              };\n            });\n          } else {\n            // This controller isn't using a model, create impostors instead\n            _this._createPhysicsImpostor(xrController);\n          }\n        });\n      } else {\n        _this._createPhysicsImpostor(xrController);\n      }\n    };\n\n    _this._controllers = {};\n    _this._debugMode = false;\n    _this._delta = 0;\n    _this._lastTimestamp = 0;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3();\n\n    if (!_this._options.physicsProperties) {\n      _this._options.physicsProperties = {};\n    }\n\n    return _this;\n  }\n\n  WebXRControllerPhysics.prototype._createPhysicsImpostor = function (xrController) {\n    var impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n    var impostorSize = this._options.physicsProperties.impostorSize || 0.1;\n    var impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n      diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n      diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n      diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n    });\n    impostorMesh.isVisible = this._debugMode;\n    impostorMesh.isPickable = false;\n    impostorMesh.rotationQuaternion = new Quaternion();\n    var controllerMesh = xrController.grip || xrController.pointer;\n    impostorMesh.position.copyFrom(controllerMesh.position);\n    impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    var impostor = new PhysicsImpostor(impostorMesh, impostorType, __assign({\n      mass: 0\n    }, this._options.physicsProperties));\n    this._controllers[xrController.uniqueId] = {\n      xrController: xrController,\n      impostor: impostor,\n      impostorMesh: impostorMesh\n    };\n  };\n  /**\n   * @hidden\n   * enable debugging - will show console outputs and the impostor mesh\n   */\n\n\n  WebXRControllerPhysics.prototype._enablePhysicsDebug = function () {\n    var _this = this;\n\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var controllerData = _this._controllers[controllerId];\n\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  };\n  /**\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\n   * @param xrController the controller to add\n   */\n\n\n  WebXRControllerPhysics.prototype.addController = function (xrController) {\n    this._attachController(xrController);\n  };\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRControllerPhysics.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.xrInput) {\n      return true;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    if (this._options.enableHeadsetImpostor) {\n      var params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      var impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, __assign({\n        mass: 0\n      }, params));\n    }\n\n    return true;\n  };\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRControllerPhysics.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n\n    return true;\n  };\n  /**\n   * Get the headset impostor, if enabled\n   * @returns the impostor\n   */\n\n\n  WebXRControllerPhysics.prototype.getHeadsetImpostor = function () {\n    return this._headsetImpostor;\n  };\n  /**\n   * Get the physics impostor of a specific controller.\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\n   * @param controller the controller or the controller id of which to get the impostor\n   * @returns the impostor or null\n   */\n\n\n  WebXRControllerPhysics.prototype.getImpostorForController = function (controller) {\n    var id = typeof controller === \"string\" ? controller : controller.uniqueId;\n\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Update the physics properties provided in the constructor\n   * @param newProperties the new properties object\n   * @param newProperties.impostorType\n   * @param newProperties.impostorSize\n   * @param newProperties.friction\n   * @param newProperties.restitution\n   */\n\n\n  WebXRControllerPhysics.prototype.setPhysicsProperties = function (newProperties) {\n    this._options.physicsProperties = __assign(__assign({}, this._options.physicsProperties), newProperties);\n  };\n\n  WebXRControllerPhysics.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    var _a, _b;\n\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n\n    if (this._headsetMesh && this._headsetImpostor) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\n\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\n\n      if ((_a = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        var lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\n\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n\n        this._headsetImpostor.setLinearVelocity(this._tmpVector);\n      }\n\n      if ((_b = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        var av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\n\n        this._tmpVector.set(av.x, av.y, av.z);\n\n        this._headsetImpostor.setAngularVelocity(this._tmpVector);\n      }\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var _a, _b;\n\n      var controllerData = _this._controllers[controllerId];\n      var controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      var comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n\n      if ((_a = controllerData.xrController._lastXRPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        var lv = controllerData.xrController._lastXRPose.linearVelocity;\n\n        _this._tmpVector.set(lv.x, lv.y, lv.z);\n\n        controllerData.impostor.setLinearVelocity(_this._tmpVector);\n      } else {\n        controllerMesh.position.subtractToRef(comparedPosition, _this._tmpVector);\n\n        _this._tmpVector.scaleInPlace(1000 / _this._delta);\n\n        controllerData.impostor.setLinearVelocity(_this._tmpVector);\n      }\n\n      comparedPosition.copyFrom(controllerMesh.position);\n\n      if (_this._debugMode) {\n        console.log(_this._tmpVector, \"linear\");\n      }\n\n      var comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n\n      if ((_b = controllerData.xrController._lastXRPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        var av = controllerData.xrController._lastXRPose.angularVelocity;\n\n        _this._tmpVector.set(av.x, av.y, av.z);\n\n        controllerData.impostor.setAngularVelocity(_this._tmpVector);\n      } else {\n        if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n          // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n          comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, _this._tmpQuaternion);\n          var len = Math.sqrt(_this._tmpQuaternion.x * _this._tmpQuaternion.x + _this._tmpQuaternion.y * _this._tmpQuaternion.y + _this._tmpQuaternion.z * _this._tmpQuaternion.z);\n\n          _this._tmpVector.set(_this._tmpQuaternion.x, _this._tmpQuaternion.y, _this._tmpQuaternion.z); // define a better epsilon\n\n\n          if (len < 0.001) {\n            _this._tmpVector.scaleInPlace(2);\n          } else {\n            var angle = 2 * Math.atan2(len, _this._tmpQuaternion.w);\n\n            _this._tmpVector.scaleInPlace(angle / (len * (_this._delta / 1000)));\n          }\n\n          controllerData.impostor.setAngularVelocity(_this._tmpVector);\n        }\n      }\n\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n\n      if (_this._debugMode) {\n        console.log(_this._tmpVector, _this._tmpQuaternion, \"angular\");\n      }\n    });\n  };\n\n  WebXRControllerPhysics.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the webxr specs version\n   */\n\n  WebXRControllerPhysics.Version = 1;\n  return WebXRControllerPhysics;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPhysics }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPhysics(xrSessionManager, options);\n  };\n}, WebXRControllerPhysics.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRAbstractFeature","Vector3","Quaternion","PhysicsImpostor","CreateSphere","WebXRFeatureName","WebXRFeaturesManager","Logger","__extends","_xrSessionManager","_options","_super","_this","xrController","_controllers","uniqueId","scene","isPhysicsEnabled","Warn","physicsProperties","useControllerMesh","inputSource","gamepad","onMotionControllerInitObservable","addOnce","motionController","_doNotLoadControllerMesh","onModelLoadedObservable","impostor","rootMesh","MeshImpostor","__assign","mass","controllerMesh","grip","pointer","oldPos","position","clone","oldRotation","rotationQuaternion","_createPhysicsImpostor","WebXRControllerPhysics","impostorType","SphereImpostor","impostorSize","impostorMesh","diameterX","width","diameterY","height","diameterZ","depth","isVisible","_debugMode","isPickable","copyFrom","Object","keys","forEach","controllerId","controllerData","_attachController","attach","call","xrInput","controllers","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","enableHeadsetImpostor","params","headsetImpostorParams","restitution","_headsetMesh","_headsetImpostor","detach","dispose","id","newProperties","_xrFrame","_delta","currentTimestamp","_lastTimestamp","xrCamera","globalPosition","absoluteRotation","_lastXRViewerPose","_a","linearVelocity","lv","_tmpVector","set","x","y","z","setLinearVelocity","_b","angularVelocity","av","setAngularVelocity","comparedPosition","_lastXRPose","subtractToRef","scaleInPlace","console","log","comparedQuaternion","equalsWithEpsilon","conjugateInPlace","multiplyToRef","_tmpQuaternion","len","Math","sqrt","angle","atan2","w","xrControllerUniqueId","PHYSICS_CONTROLLERS","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRControllerPhysics.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options for the controller physics feature\r\n */\r\nexport class IWebXRControllerPhysicsOptions {\r\n    /**\r\n     * Should the headset get its own impostor\r\n     */\r\n    enableHeadsetImpostor?: boolean;\r\n    /**\r\n     * Optional parameters for the headset impostor\r\n     */\r\n    headsetImpostorParams?: {\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * The physics properties of the future impostors\r\n     */\r\n    physicsProperties?: {\r\n        /**\r\n         * If set to true, a mesh impostor will be created when the controller mesh was loaded\r\n         * Note that this requires a physics engine that supports mesh impostors!\r\n         */\r\n        useControllerMesh?: boolean;\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType?: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    public xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\r\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\r\n            Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\r\n        }\r\n        // if no motion controller available, create impostors!\r\n        if (this._options.physicsProperties!.useControllerMesh && xrController.inputSource.gamepad) {\r\n            xrController.onMotionControllerInitObservable.addOnce((motionController) => {\r\n                if (!motionController._doNotLoadControllerMesh) {\r\n                    motionController.onModelLoadedObservable.addOnce(() => {\r\n                        const impostor = new PhysicsImpostor(motionController.rootMesh!, PhysicsImpostor.MeshImpostor, {\r\n                            mass: 0,\r\n                            ...this._options.physicsProperties,\r\n                        });\r\n\r\n                        const controllerMesh = xrController.grip || xrController.pointer;\r\n                        this._controllers[xrController.uniqueId] = {\r\n                            xrController,\r\n                            impostor,\r\n                            oldPos: controllerMesh.position.clone(),\r\n                            oldRotation: controllerMesh.rotationQuaternion!.clone(),\r\n                        };\r\n                    });\r\n                } else {\r\n                    // This controller isn't using a model, create impostors instead\r\n                    this._createPhysicsImpostor(xrController);\r\n                }\r\n            });\r\n        } else {\r\n            this._createPhysicsImpostor(xrController);\r\n        }\r\n    };\r\n\r\n    private _createPhysicsImpostor(xrController: WebXRInputSource) {\r\n        const impostorType: number = this._options.physicsProperties!.impostorType || PhysicsImpostor.SphereImpostor;\r\n        const impostorSize: number | { width: number; height: number; depth: number } = this._options.physicsProperties!.impostorSize || 0.1;\r\n        const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\r\n            diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n            diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n            diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n        });\r\n        impostorMesh.isVisible = this._debugMode;\r\n        impostorMesh.isPickable = false;\r\n        impostorMesh.rotationQuaternion = new Quaternion();\r\n        const controllerMesh = xrController.grip || xrController.pointer;\r\n        impostorMesh.position.copyFrom(controllerMesh.position);\r\n        impostorMesh.rotationQuaternion!.copyFrom(controllerMesh.rotationQuaternion!);\r\n        const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\r\n            mass: 0,\r\n            ...this._options.physicsProperties,\r\n        });\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            impostor,\r\n            impostorMesh,\r\n        };\r\n    }\r\n\r\n    private _controllers: {\r\n        [id: string]: {\r\n            xrController: WebXRInputSource;\r\n            impostorMesh?: AbstractMesh;\r\n            impostor: PhysicsImpostor;\r\n            oldPos?: Vector3;\r\n            oldSpeed?: Vector3;\r\n            oldRotation?: Quaternion;\r\n        };\r\n    } = {};\r\n    private _debugMode = false;\r\n    private _delta: number = 0;\r\n    private _headsetImpostor?: PhysicsImpostor;\r\n    private _headsetMesh?: AbstractMesh;\r\n    private _lastTimestamp: number = 0;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVector: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Construct a new Controller Physics Feature\r\n     * @param _xrSessionManager the corresponding xr session manager\r\n     * @param _options options to create this feature with\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPhysicsOptions) {\r\n        super(_xrSessionManager);\r\n        if (!this._options.physicsProperties) {\r\n            this._options.physicsProperties = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * enable debugging - will show console outputs and the impostor mesh\r\n     */\r\n    public _enablePhysicsDebug() {\r\n        this._debugMode = true;\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            if (controllerData.impostorMesh) {\r\n                controllerData.impostorMesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n     * @param xrController the controller to add\r\n     */\r\n    public addController(xrController: WebXRInputSource) {\r\n        this._attachController(xrController);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.xrInput) {\r\n            return true;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        if (this._options.enableHeadsetImpostor) {\r\n            const params = this._options.headsetImpostorParams || {\r\n                impostorType: PhysicsImpostor.SphereImpostor,\r\n                restitution: 0.8,\r\n                impostorSize: 0.3,\r\n            };\r\n            const impostorSize = params.impostorSize || 0.3;\r\n            this._headsetMesh = CreateSphere(\"headset-mesh\", {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            this._headsetMesh.rotationQuaternion = new Quaternion();\r\n            this._headsetMesh.isVisible = false;\r\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.dispose();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the headset impostor, if enabled\r\n     * @returns the impostor\r\n     */\r\n    public getHeadsetImpostor() {\r\n        return this._headsetImpostor;\r\n    }\r\n\r\n    /**\r\n     * Get the physics impostor of a specific controller.\r\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n     * @param controller the controller or the controller id of which to get the impostor\r\n     * @returns the impostor or null\r\n     */\r\n    public getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor> {\r\n        const id = typeof controller === \"string\" ? controller : controller.uniqueId;\r\n        if (this._controllers[id]) {\r\n            return this._controllers[id].impostor;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the physics properties provided in the constructor\r\n     * @param newProperties the new properties object\r\n     * @param newProperties.impostorType\r\n     * @param newProperties.impostorSize\r\n     * @param newProperties.friction\r\n     * @param newProperties.restitution\r\n     */\r\n    public setPhysicsProperties(newProperties: {\r\n        impostorType?: number;\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        friction?: number;\r\n        restitution?: number;\r\n    }) {\r\n        this._options.physicsProperties = {\r\n            ...this._options.physicsProperties,\r\n            ...newProperties,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: any): void {\r\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\r\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\r\n        if (this._headsetMesh && this._headsetImpostor) {\r\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\r\n            this._headsetMesh.rotationQuaternion!.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.linearVelocity) {\r\n                const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                this._headsetImpostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.angularVelocity) {\r\n                const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                this._headsetImpostor.setAngularVelocity(this._tmpVector);\r\n            }\r\n        }\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\r\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh!.position;\r\n            if (controllerData.xrController._lastXRPose?.linearVelocity) {\r\n                const lv = controllerData.xrController._lastXRPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            } else {\r\n                controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(1000 / this._delta);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            comparedPosition.copyFrom(controllerMesh.position);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, \"linear\");\r\n            }\r\n\r\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh!.rotationQuaternion!;\r\n            if (controllerData.xrController._lastXRPose?.angularVelocity) {\r\n                const av = controllerData.xrController._lastXRPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n            } else {\r\n                if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion!)) {\r\n                    // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\r\n                    comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion!, this._tmpQuaternion);\r\n                    const len = Math.sqrt(\r\n                        this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z\r\n                    );\r\n                    this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\r\n                    // define a better epsilon\r\n                    if (len < 0.001) {\r\n                        this._tmpVector.scaleInPlace(2);\r\n                    } else {\r\n                        const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\r\n                        this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\r\n                    }\r\n                    controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n                }\r\n            }\r\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion!);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.impostorMesh) {\r\n            controllerData.impostorMesh.dispose();\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPhysics.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPhysics(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPhysics.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module"}