{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __extends } from \"tslib\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { HDRTools } from \"../../Misc/HighDynamicRange/hdr.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { ToGammaSpace } from \"../../Maths/math.constants.js\";\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering.js\";\nimport { ToHalfFloat } from \"../../Misc/textureTools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport \"../../Materials/Textures/baseTexture.polynomial.js\";\n/**\n * This represents a texture coming from an HDR input.\n *\n * The only supported format is currently panorama picture stored in RGBE format.\n * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris\n */\n\nvar HDRCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(HDRCubeTexture, _super);\n  /**\n   * Instantiates an HDRTexture from the following parameters.\n   *\n   * @param url The location of the HDR raw data (Panorama stored in RGBE format)\n   * @param sceneOrEngine The scene or engine the texture will be used in\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\n   * @param noMipmap Forces to not generate the mipmap if true\n   * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process\n   * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\n   * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.\n   * @param onLoad\n   * @param onError\n   */\n\n\n  function HDRCubeTexture(url, sceneOrEngine, size, noMipmap, generateHarmonics, gammaSpace, prefilterOnLoad, onLoad, onError) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (generateHarmonics === void 0) {\n      generateHarmonics = true;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = false;\n    }\n\n    if (prefilterOnLoad === void 0) {\n      prefilterOnLoad = false;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = this;\n\n    var _a;\n\n    _this = _super.call(this, sceneOrEngine) || this;\n    _this._generateHarmonics = true;\n    _this._onError = null;\n    _this._isBlocking = true;\n    _this._rotationY = 0;\n    /**\n     * Gets or sets the center of the bounding box associated with the cube texture\n     * It must define where the camera used to render the texture was set\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    /**\n     * Observable triggered once the texture has been loaded.\n     */\n\n    _this.onLoadObservable = new Observable();\n\n    if (!url) {\n      return _this;\n    }\n\n    _this._coordinatesMode = Texture.CUBIC_MODE;\n    _this.name = url;\n    _this.url = url;\n    _this.hasAlpha = false;\n    _this.isCube = true;\n    _this._textureMatrix = Matrix.Identity();\n    _this._prefilterOnLoad = prefilterOnLoad;\n\n    _this._onLoad = function () {\n      _this.onLoadObservable.notifyObservers(_this);\n\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    _this._onError = onError;\n    _this.gammaSpace = gammaSpace;\n    _this._noMipmap = noMipmap;\n    _this._size = size;\n    _this._generateHarmonics = generateHarmonics;\n    _this._texture = _this._getFromCache(url, _this._noMipmap);\n\n    if (!_this._texture) {\n      if (!((_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading)) {\n        _this._loadTexture();\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return _this._onLoad();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(_this._onLoad);\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(HDRCubeTexture.prototype, \"isBlocking\", {\n    /**\n     * Gets whether or not the texture is blocking during loading.\n     */\n    get: function get() {\n      return this._isBlocking;\n    },\n\n    /**\n     * Sets whether or not the texture is blocking during loading.\n     */\n    set: function set(value) {\n      this._isBlocking = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HDRCubeTexture.prototype, \"rotationY\", {\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get: function get() {\n      return this._rotationY;\n    },\n\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set: function set(value) {\n      this._rotationY = value;\n      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HDRCubeTexture.prototype, \"boundingBoxSize\", {\n    get: function get() {\n      return this._boundingBoxSize;\n    },\n\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set: function set(value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"HDRCubeTexture\"\n   */\n\n  HDRCubeTexture.prototype.getClassName = function () {\n    return \"HDRCubeTexture\";\n  };\n  /**\n   * Occurs when the file is raw .hdr file.\n   */\n\n\n  HDRCubeTexture.prototype._loadTexture = function () {\n    var _this = this;\n\n    var engine = this._getEngine();\n\n    var caps = engine.getCaps();\n    var textureType = 0;\n\n    if (caps.textureFloat && caps.textureFloatLinearFiltering) {\n      textureType = 1;\n    } else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {\n      textureType = 2;\n    }\n\n    var callback = function callback(buffer) {\n      _this.lodGenerationOffset = 0.0;\n      _this.lodGenerationScale = 0.8; // Extract the raw linear data.\n\n      var data = HDRTools.GetCubeMapTextureData(buffer, _this._size); // Generate harmonics if needed.\n\n      if (_this._generateHarmonics) {\n        var sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\n        _this.sphericalPolynomial = sphericalPolynomial;\n      }\n\n      var results = [];\n      var byteArray = null;\n      var shortArray = null; // Push each faces.\n\n      for (var j = 0; j < 6; j++) {\n        // Create fallback array\n        if (textureType === 2) {\n          shortArray = new Uint16Array(_this._size * _this._size * 3);\n        } else if (textureType === 0) {\n          // 3 channels of 1 bytes per pixel in bytes.\n          byteArray = new Uint8Array(_this._size * _this._size * 3);\n        }\n\n        var dataFace = data[HDRCubeTexture._FacesMapping[j]]; // If special cases.\n\n        if (_this.gammaSpace || shortArray || byteArray) {\n          for (var i = 0; i < _this._size * _this._size; i++) {\n            // Put in gamma space if requested.\n            if (_this.gammaSpace) {\n              dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);\n              dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);\n              dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);\n            } // Convert to half float texture for fallback.\n\n\n            if (shortArray) {\n              shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);\n              shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);\n              shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);\n            } // Convert to int texture for fallback.\n\n\n            if (byteArray) {\n              var r = Math.max(dataFace[i * 3 + 0] * 255, 0);\n              var g = Math.max(dataFace[i * 3 + 1] * 255, 0);\n              var b = Math.max(dataFace[i * 3 + 2] * 255, 0); // May use luminance instead if the result is not accurate.\n\n              var max = Math.max(Math.max(r, g), b);\n\n              if (max > 255) {\n                var scale = 255 / max;\n                r *= scale;\n                g *= scale;\n                b *= scale;\n              }\n\n              byteArray[i * 3 + 0] = r;\n              byteArray[i * 3 + 1] = g;\n              byteArray[i * 3 + 2] = b;\n            }\n          }\n        }\n\n        if (shortArray) {\n          results.push(shortArray);\n        } else if (byteArray) {\n          results.push(byteArray);\n        } else {\n          results.push(dataFace);\n        }\n      }\n\n      return results;\n    };\n\n    if (engine._features.allowTexturePrefiltering && this._prefilterOnLoad) {\n      var previousOnLoad_1 = this._onLoad;\n      var hdrFiltering_1 = new HDRFiltering(engine);\n\n      this._onLoad = function () {\n        hdrFiltering_1.prefilter(_this, previousOnLoad_1);\n      };\n    }\n\n    this._texture = engine.createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, 4, textureType, this._noMipmap, callback, null, this._onLoad, this._onError);\n  };\n\n  HDRCubeTexture.prototype.clone = function () {\n    var newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine(), this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace); // Base texture\n\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }; // Methods\n\n\n  HDRCubeTexture.prototype.delayLoad = function () {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, this._noMipmap);\n\n    if (!this._texture) {\n      this._loadTexture();\n    }\n  };\n  /**\n   * Get the texture reflection matrix used to rotate/transform the reflection.\n   * @returns the reflection matrix\n   */\n\n\n  HDRCubeTexture.prototype.getReflectionTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\n   * Set the texture reflection matrix used to rotate/transform the reflection.\n   * @param value Define the reflection matrix to set\n   */\n\n\n  HDRCubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n    var _this = this;\n\n    var _a;\n\n    this._textureMatrix = value;\n\n    if (value.updateFlag === this._textureMatrix.updateFlag) {\n      return;\n    }\n\n    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function (mat) {\n        return mat.getActiveTextures().indexOf(_this) !== -1;\n      });\n    }\n  };\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n\n  HDRCubeTexture.prototype.dispose = function () {\n    this.onLoadObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Parses a JSON representation of an HDR Texture in order to create the texture\n   * @param parsedTexture Define the JSON representation\n   * @param scene Define the scene the texture should be created in\n   * @param rootUrl Define the root url in case we need to load relative dependencies\n   * @returns the newly created texture after parsing\n   */\n\n\n  HDRCubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n    var texture = null;\n\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new HDRCubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);\n      texture.name = parsedTexture.name;\n      texture.hasAlpha = parsedTexture.hasAlpha;\n      texture.level = parsedTexture.level;\n      texture.coordinatesMode = parsedTexture.coordinatesMode;\n      texture.isBlocking = parsedTexture.isBlocking;\n    }\n\n    if (texture) {\n      if (parsedTexture.boundingBoxPosition) {\n        texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n      }\n\n      if (parsedTexture.boundingBoxSize) {\n        texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n      }\n\n      if (parsedTexture.rotationY) {\n        texture.rotationY = parsedTexture.rotationY;\n      }\n    }\n\n    return texture;\n  };\n\n  HDRCubeTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.hasAlpha = this.hasAlpha;\n    serializationObject.isCube = true;\n    serializationObject.level = this.level;\n    serializationObject.size = this._size;\n    serializationObject.coordinatesMode = this.coordinatesMode;\n    serializationObject.useInGammaSpace = this.gammaSpace;\n    serializationObject.generateHarmonics = this._generateHarmonics;\n    serializationObject.customType = \"BABYLON.HDRCubeTexture\";\n    serializationObject.noMipmap = this._noMipmap;\n    serializationObject.isBlocking = this._isBlocking;\n    serializationObject.rotationY = this._rotationY;\n    return serializationObject;\n  };\n\n  HDRCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\n  return HDRCubeTexture;\n}(BaseTexture);\n\nexport { HDRCubeTexture };\nRegisterClass(\"BABYLON.HDRCubeTexture\", HDRCubeTexture);","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","BaseTexture","Texture","HDRTools","CubeMapToSphericalPolynomialTools","RegisterClass","Observable","Tools","ToGammaSpace","HDRFiltering","ToHalfFloat","__extends","url","sceneOrEngine","size","noMipmap","generateHarmonics","gammaSpace","prefilterOnLoad","onLoad","onError","_super","_this","Zero","_coordinatesMode","CUBIC_MODE","name","hasAlpha","isCube","_textureMatrix","Identity","_prefilterOnLoad","_onLoad","onLoadObservable","notifyObservers","_onError","_noMipmap","_size","_generateHarmonics","_texture","_getFromCache","getScene","_a","useDelayedTextureLoading","_loadTexture","delayLoadState","isReady","SetImmediate","onLoadedObservable","add","Object","HDRCubeTexture","_isBlocking","value","_rotationY","setReflectionTextureMatrix","RotationY","_boundingBoxSize","equals","scene","markAllMaterialsAsDirty","engine","_getEngine","caps","getCaps","textureType","textureFloat","textureFloatLinearFiltering","textureHalfFloat","textureHalfFloatLinearFiltering","callback","buffer","lodGenerationOffset","lodGenerationScale","data","GetCubeMapTextureData","sphericalPolynomial","ConvertCubeMapToSphericalPolynomial","results","byteArray","shortArray","j","Uint16Array","Uint8Array","dataFace","_FacesMapping","i","Math","pow","r","max","g","b","scale","push","_features","allowTexturePrefiltering","previousOnLoad_1","hdrFiltering_1","prefilter","createRawCubeTextureFromUrl","newTexture","level","wrapU","wrapV","coordinatesIndex","coordinatesMode","updateFlag","isIdentity","mat","indexOf","clear","dispose","call","parsedTexture","rootUrl","texture","isRenderTarget","useInGammaSpace","isBlocking","boundingBoxPosition","FromArray","boundingBoxSize","rotationY","serializationObject","customType"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/hdrCubeTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { HDRTools } from \"../../Misc/HighDynamicRange/hdr\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { ToGammaSpace } from \"../../Maths/math.constants\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering\";\r\nimport { ToHalfFloat } from \"../../Misc/textureTools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport \"../../Materials/Textures/baseTexture.polynomial\";\r\n\r\n/**\r\n * This represents a texture coming from an HDR input.\r\n *\r\n * The only supported format is currently panorama picture stored in RGBE format.\r\n * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris\r\n */\r\nexport class HDRCubeTexture extends BaseTexture {\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _generateHarmonics = true;\r\n    private _noMipmap: boolean;\r\n    private _prefilterOnLoad: boolean;\r\n    private _textureMatrix: Matrix;\r\n    private _size: number;\r\n    private _onLoad: () => void;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Sets whether or not the texture is blocking during loading.\r\n     */\r\n    public set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    /**\r\n     * Gets whether or not the texture is blocking during loading.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture\r\n     * It must define where the camera used to render the texture was set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<HDRCubeTexture> = new Observable<HDRCubeTexture>();\r\n\r\n    /**\r\n     * Instantiates an HDRTexture from the following parameters.\r\n     *\r\n     * @param url The location of the HDR raw data (Panorama stored in RGBE format)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process\r\n     * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\r\n     * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.\r\n     * @param onLoad\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        url: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        size: number,\r\n        noMipmap = false,\r\n        generateHarmonics = true,\r\n        gammaSpace = false,\r\n        prefilterOnLoad = false,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._prefilterOnLoad = prefilterOnLoad;\r\n        this._onLoad = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        this._onError = onError;\r\n        this.gammaSpace = gammaSpace;\r\n\r\n        this._noMipmap = noMipmap;\r\n        this._size = size;\r\n        this._generateHarmonics = generateHarmonics;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            if (!this.getScene()?.useDelayedTextureLoading) {\r\n                this._loadTexture();\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => this._onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(this._onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"HDRCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"HDRCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file is raw .hdr file.\r\n     */\r\n    private _loadTexture() {\r\n        const engine = this._getEngine()!;\r\n        const caps = engine.getCaps();\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (caps.textureFloat && caps.textureFloatLinearFiltering) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        } else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n\r\n        const callback = (buffer: ArrayBuffer): Nullable<ArrayBufferView[]> => {\r\n            this.lodGenerationOffset = 0.0;\r\n            this.lodGenerationScale = 0.8;\r\n\r\n            // Extract the raw linear data.\r\n            const data = HDRTools.GetCubeMapTextureData(buffer, this._size);\r\n\r\n            // Generate harmonics if needed.\r\n            if (this._generateHarmonics) {\r\n                const sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\r\n                this.sphericalPolynomial = sphericalPolynomial;\r\n            }\r\n\r\n            const results = [];\r\n\r\n            let byteArray: Nullable<Uint8Array> = null;\r\n            let shortArray: Nullable<Uint16Array> = null;\r\n\r\n            // Push each faces.\r\n            for (let j = 0; j < 6; j++) {\r\n                // Create fallback array\r\n                if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n                    shortArray = new Uint16Array(this._size * this._size * 3);\r\n                } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                    // 3 channels of 1 bytes per pixel in bytes.\r\n                    byteArray = new Uint8Array(this._size * this._size * 3);\r\n                }\r\n\r\n                const dataFace = <Float32Array>(<any>data)[HDRCubeTexture._FacesMapping[j]];\r\n\r\n                // If special cases.\r\n                if (this.gammaSpace || shortArray || byteArray) {\r\n                    for (let i = 0; i < this._size * this._size; i++) {\r\n                        // Put in gamma space if requested.\r\n                        if (this.gammaSpace) {\r\n                            dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);\r\n                            dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);\r\n                            dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);\r\n                        }\r\n\r\n                        // Convert to half float texture for fallback.\r\n                        if (shortArray) {\r\n                            shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);\r\n                            shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);\r\n                            shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);\r\n                        }\r\n\r\n                        // Convert to int texture for fallback.\r\n                        if (byteArray) {\r\n                            let r = Math.max(dataFace[i * 3 + 0] * 255, 0);\r\n                            let g = Math.max(dataFace[i * 3 + 1] * 255, 0);\r\n                            let b = Math.max(dataFace[i * 3 + 2] * 255, 0);\r\n\r\n                            // May use luminance instead if the result is not accurate.\r\n                            const max = Math.max(Math.max(r, g), b);\r\n                            if (max > 255) {\r\n                                const scale = 255 / max;\r\n                                r *= scale;\r\n                                g *= scale;\r\n                                b *= scale;\r\n                            }\r\n\r\n                            byteArray[i * 3 + 0] = r;\r\n                            byteArray[i * 3 + 1] = g;\r\n                            byteArray[i * 3 + 2] = b;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (shortArray) {\r\n                    results.push(shortArray);\r\n                } else if (byteArray) {\r\n                    results.push(byteArray);\r\n                } else {\r\n                    results.push(dataFace);\r\n                }\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (engine._features.allowTexturePrefiltering && this._prefilterOnLoad) {\r\n            const previousOnLoad = this._onLoad;\r\n            const hdrFiltering = new HDRFiltering(engine);\r\n            this._onLoad = () => {\r\n                hdrFiltering.prefilter(this, previousOnLoad);\r\n            };\r\n        }\r\n\r\n        this._texture = engine.createRawCubeTextureFromUrl(\r\n            this.url,\r\n            this.getScene(),\r\n            this._size,\r\n            Constants.TEXTUREFORMAT_RGB,\r\n            textureType,\r\n            this._noMipmap,\r\n            callback,\r\n            null,\r\n            this._onLoad,\r\n            this._onError\r\n        );\r\n    }\r\n\r\n    public clone(): HDRCubeTexture {\r\n        const newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine()!, this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    // Methods\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            this._loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Set the texture reflection matrix used to rotate/transform the reflection.\r\n     * @param value Define the reflection matrix to set\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        this._textureMatrix = value;\r\n\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.onLoadObservable.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON representation of an HDR Texture in order to create the texture\r\n     * @param parsedTexture Define the JSON representation\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param rootUrl Define the root url in case we need to load relative dependencies\r\n     * @returns the newly created texture after parsing\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<HDRCubeTexture> {\r\n        let texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new HDRCubeTexture(\r\n                rootUrl + parsedTexture.name,\r\n                scene,\r\n                parsedTexture.size,\r\n                parsedTexture.noMipmap,\r\n                parsedTexture.generateHarmonics,\r\n                parsedTexture.useInGammaSpace\r\n            );\r\n            texture.name = parsedTexture.name;\r\n            texture.hasAlpha = parsedTexture.hasAlpha;\r\n            texture.level = parsedTexture.level;\r\n            texture.coordinatesMode = parsedTexture.coordinatesMode;\r\n            texture.isBlocking = parsedTexture.isBlocking;\r\n        }\r\n        if (texture) {\r\n            if (parsedTexture.boundingBoxPosition) {\r\n                (<any>texture).boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n            }\r\n            if (parsedTexture.boundingBoxSize) {\r\n                (<any>texture).boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n            }\r\n            if (parsedTexture.rotationY) {\r\n                (<any>texture).rotationY = parsedTexture.rotationY;\r\n            }\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.hasAlpha = this.hasAlpha;\r\n        serializationObject.isCube = true;\r\n        serializationObject.level = this.level;\r\n        serializationObject.size = this._size;\r\n        serializationObject.coordinatesMode = this.coordinatesMode;\r\n        serializationObject.useInGammaSpace = this.gammaSpace;\r\n        serializationObject.generateHarmonics = this._generateHarmonics;\r\n        serializationObject.customType = \"BABYLON.HDRCubeTexture\";\r\n        serializationObject.noMipmap = this._noMipmap;\r\n        serializationObject.isBlocking = this._isBlocking;\r\n        serializationObject.rotationY = this._rotationY;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HDRCubeTexture\", HDRCubeTexture);\r\n"]},"metadata":{},"sourceType":"module"}