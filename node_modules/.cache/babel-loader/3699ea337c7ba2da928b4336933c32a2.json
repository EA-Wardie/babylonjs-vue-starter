{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\n\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps, onBeforeUnbind) {\n  if (disableGenerateMipMaps === void 0) {\n    disableGenerateMipMaps = false;\n  }\n\n  if (onBeforeUnbind) {\n    onBeforeUnbind();\n  }\n\n  var attachments = rtWrapper._attachments;\n  var count = attachments.length;\n\n  if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n    this._endRenderTargetRenderPass();\n  }\n\n  for (var i = 0; i < count; i++) {\n    var texture = rtWrapper.textures[i];\n\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture);\n    }\n  }\n\n  this._currentRenderTarget = null;\n  this._mrtAttachments = [];\n\n  this._cacheRenderPipeline.setMRT([]);\n\n  this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n\n  this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n\n  this._setDepthTextureFormat(this._mainRenderPassWrapper);\n\n  this._setColorFormat(this._mainRenderPassWrapper);\n};\n\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n  var _a;\n\n  var generateMipMaps = false;\n  var generateDepthBuffer = true;\n  var generateStencilBuffer = false;\n  var generateDepthTexture = false;\n  var depthTextureFormat = 15;\n  var textureCount = 1;\n  var defaultType = 0;\n  var defaultSamplingMode = 3;\n  var types = new Array();\n  var samplingModes = new Array();\n\n  var rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    depthTextureFormat = (_a = options.depthTextureFormat) !== null && _a !== void 0 ? _a : 15;\n\n    if (options.types) {\n      types = options.types;\n    }\n\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n  }\n\n  var width = size.width || size;\n  var height = size.height || size;\n  var depthStencilTexture = null;\n\n  if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\n    depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\n  }\n\n  var textures = [];\n  var attachments = [];\n  var defaultAttachments = [];\n  rtWrapper._generateDepthBuffer = generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  rtWrapper._defaultAttachments = defaultAttachments;\n\n  for (var i = 0; i < textureCount; i++) {\n    var samplingMode = samplingModes[i] || defaultSamplingMode;\n    var type = types[i] || defaultType;\n\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures.push(texture);\n    attachments.push(i + 1);\n    defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n\n    this._internalTexturesCache.push(texture);\n\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\n  }\n\n  if (depthStencilTexture) {\n    depthStencilTexture.incrementReferences();\n    textures.push(depthStencilTexture);\n\n    this._internalTexturesCache.push(depthStencilTexture);\n  }\n\n  rtWrapper.setTextures(textures);\n  return rtWrapper;\n};\n\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\n    return samples;\n  }\n\n  var count = rtWrapper.textures.length;\n\n  if (count === 0) {\n    return 1;\n  }\n\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n\n  for (var i = 0; i < count; ++i) {\n    var texture = rtWrapper.textures[i];\n\n    this._textureHelper.createMSAATexture(texture, samples);\n\n    texture.samples = samples;\n  } // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n  // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n  // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n\n\n  if (rtWrapper._depthStencilTexture && rtWrapper._depthStencilTexture !== rtWrapper.textures[rtWrapper.textures.length - 1]) {\n    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n\n    rtWrapper._depthStencilTexture.samples = samples;\n  }\n\n  return samples;\n};\n\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n  if (attachments.length === 0 || !this._currentRenderTarget) {\n    return;\n  }\n\n  this._mrtAttachments = attachments;\n\n  if (this._currentRenderPass) {\n    // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n    this._cacheRenderPipeline.setMRTAttachments(attachments);\n  } else {// the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n  }\n};\n\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus) {\n  var result = [];\n\n  for (var i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(i + 1);\n    } else {\n      result.push(0);\n    }\n  }\n\n  return result;\n};\n\nWebGPUEngine.prototype.restoreSingleAttachment = function () {// not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\n\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {// not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","Logger","WebGPUEngine","prototype","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","attachments","_attachments","count","length","_currentRenderPass","_mainRenderPassWrapper","renderPass","_endRenderTargetRenderPass","i","texture","textures","generateMipMaps","isCube","_generateMipmaps","_currentRenderTarget","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","_setDepthTextureFormat","_setColorFormat","createMultipleRenderTarget","size","options","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","defaultType","defaultSamplingMode","types","Array","samplingModes","_createHardwareRenderTargetWrapper","undefined","_a","width","height","depthStencilTexture","createDepthStencilTexture","defaultAttachments","_generateDepthBuffer","_generateStencilBuffer","_defaultAttachments","samplingMode","type","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","textureFloat","Warn","MultiRenderTarget","push","baseWidth","baseHeight","isReady","samples","_cachedWrapU","_cachedWrapV","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","incrementReferences","setTextures","updateMultipleRenderTargetTextureSampleCount","Math","min","getCaps","maxMSAASamples","createMSAATexture","_depthStencilTexture","bindAttachments","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.multiRender.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n        this._endRenderTargetRenderPass();\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n    this._setColorFormat(this._mainRenderPassWrapper);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    let depthStencilTexture = null;\r\n    if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\r\n    }\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n\r\n        textures.push(texture);\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures.push(depthStencilTexture);\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples);\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && rtWrapper._depthStencilTexture !== rtWrapper.textures[rtWrapper.textures.length - 1]) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n"]},"metadata":{},"sourceType":"module"}