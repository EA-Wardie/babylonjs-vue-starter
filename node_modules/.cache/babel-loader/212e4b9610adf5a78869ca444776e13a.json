{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Type of sub emitter\n */\n\nexport var SubEmitterType;\n\n(function (SubEmitterType) {\n  /**\n   * Attached to the particle over it's lifetime\n   */\n  SubEmitterType[SubEmitterType[\"ATTACHED\"] = 0] = \"ATTACHED\";\n  /**\n   * Created when the particle dies\n   */\n\n  SubEmitterType[SubEmitterType[\"END\"] = 1] = \"END\";\n})(SubEmitterType || (SubEmitterType = {}));\n/**\n * Sub emitter class used to emit particles from an existing particle\n */\n\n\nvar SubEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a sub emitter\n   * @param particleSystem the particle system to be used by the sub emitter\n   */\n  function SubEmitter(\n  /**\n   * the particle system to be used by the sub emitter\n   */\n  particleSystem) {\n    this.particleSystem = particleSystem;\n    /**\n     * Type of the submitter (Default: END)\n     */\n\n    this.type = SubEmitterType.END;\n    /**\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\n     * Note: This only is supported when using an emitter of type Mesh\n     */\n\n    this.inheritDirection = false;\n    /**\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\n     */\n\n    this.inheritedVelocityAmount = 0; // Create mesh as emitter to support rotation\n\n    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {\n      var internalClass = GetClass(\"BABYLON.AbstractMesh\");\n      particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\n      particleSystem._disposeEmitterOnDispose = true;\n    }\n  }\n  /**\n   * Clones the sub emitter\n   * @returns the cloned sub emitter\n   */\n\n\n  SubEmitter.prototype.clone = function () {\n    // Clone particle system\n    var emitter = this.particleSystem.emitter;\n\n    if (!emitter) {\n      emitter = new Vector3();\n    } else if (emitter instanceof Vector3) {\n      emitter = emitter.clone();\n    } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\n      var internalClass = GetClass(\"BABYLON.Mesh\");\n      emitter = new internalClass(\"\", emitter.getScene());\n      emitter.isVisible = false;\n    }\n\n    var clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter)); // Clone properties\n\n    clone.particleSystem.name += \"Clone\";\n    clone.type = this.type;\n    clone.inheritDirection = this.inheritDirection;\n    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    clone.particleSystem._disposeEmitterOnDispose = true;\n    clone.particleSystem.disposeOnStop = true;\n    return clone;\n  };\n  /**\n   * Serialize current object to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the serialized object\n   */\n\n\n  SubEmitter.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n    serializationObject.type = this.type;\n    serializationObject.inheritDirection = this.inheritDirection;\n    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\n    return serializationObject;\n  };\n  /**\n   * @param system\n   * @param sceneOrEngine\n   * @param rootUrl\n   * @param doNotStart\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  SubEmitter._ParseParticleSystem = function (system, sceneOrEngine, rootUrl, doNotStart) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    throw _WarnImport(\"ParseParticle\");\n  };\n  /**\n   * Creates a new SubEmitter from a serialized JSON version\n   * @param serializationObject defines the JSON object to read from\n   * @param sceneOrEngine defines the hosting scene or the hosting engine\n   * @param rootUrl defines the rootUrl for data loading\n   * @returns a new SubEmitter\n   */\n\n\n  SubEmitter.Parse = function (serializationObject, sceneOrEngine, rootUrl) {\n    var system = serializationObject.particleSystem;\n    var subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\n    subEmitter.type = serializationObject.type;\n    subEmitter.inheritDirection = serializationObject.inheritDirection;\n    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\n    subEmitter.particleSystem._isSubEmitter = true;\n    return subEmitter;\n  };\n  /** Release associated resources */\n\n\n  SubEmitter.prototype.dispose = function () {\n    this.particleSystem.dispose();\n  };\n\n  return SubEmitter;\n}();\n\nexport { SubEmitter };","map":{"version":3,"mappings":"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","names":["Vector3","_WarnImport","GetClass","SubEmitterType","particleSystem","END","emitter","dispose","internalClass","getScene","_disposeEmitterOnDispose","SubEmitter","clone","getClassName","indexOf","isVisible","name","type","inheritDirection","inheritedVelocityAmount","disposeOnStop","serializeTexture","serializationObject","serialize","system","sceneOrEngine","rootUrl","doNotStart","subEmitter","_ParseParticleSystem","_isSubEmitter"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/subEmitter.ts"],"sourcesContent":["import { Vector3 } from \"../Maths/math.vector\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type ParticleSystem = import(\"../Particles/particleSystem\").ParticleSystem;\r\n\r\n/**\r\n * Type of sub emitter\r\n */\r\nexport enum SubEmitterType {\r\n    /**\r\n     * Attached to the particle over it's lifetime\r\n     */\r\n    ATTACHED,\r\n    /**\r\n     * Created when the particle dies\r\n     */\r\n    END,\r\n}\r\n\r\n/**\r\n * Sub emitter class used to emit particles from an existing particle\r\n */\r\nexport class SubEmitter {\r\n    /**\r\n     * Type of the submitter (Default: END)\r\n     */\r\n    public type = SubEmitterType.END;\r\n    /**\r\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\r\n     * Note: This only is supported when using an emitter of type Mesh\r\n     */\r\n    public inheritDirection = false;\r\n    /**\r\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\r\n     */\r\n    public inheritedVelocityAmount = 0;\r\n\r\n    /**\r\n     * Creates a sub emitter\r\n     * @param particleSystem the particle system to be used by the sub emitter\r\n     */\r\n    constructor(\r\n        /**\r\n         * the particle system to be used by the sub emitter\r\n         */\r\n        public particleSystem: ParticleSystem\r\n    ) {\r\n        // Create mesh as emitter to support rotation\r\n        if (!particleSystem.emitter || !(<AbstractMesh>particleSystem.emitter).dispose) {\r\n            const internalClass = GetClass(\"BABYLON.AbstractMesh\");\r\n            particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\r\n            particleSystem._disposeEmitterOnDispose = true;\r\n        }\r\n    }\r\n    /**\r\n     * Clones the sub emitter\r\n     * @returns the cloned sub emitter\r\n     */\r\n    public clone(): SubEmitter {\r\n        // Clone particle system\r\n        let emitter = this.particleSystem.emitter;\r\n        if (!emitter) {\r\n            emitter = new Vector3();\r\n        } else if (emitter instanceof Vector3) {\r\n            emitter = emitter.clone();\r\n        } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\r\n            const internalClass = GetClass(\"BABYLON.Mesh\");\r\n            emitter = new internalClass(\"\", emitter.getScene());\r\n            (emitter! as any).isVisible = false;\r\n        }\r\n        const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));\r\n\r\n        // Clone properties\r\n        clone.particleSystem.name += \"Clone\";\r\n        clone.type = this.type;\r\n        clone.inheritDirection = this.inheritDirection;\r\n        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n\r\n        clone.particleSystem._disposeEmitterOnDispose = true;\r\n        clone.particleSystem.disposeOnStop = true;\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serialize current object to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(serializeTexture: boolean = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.inheritDirection = this.inheritDirection;\r\n        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n        serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @param system\r\n     * @param sceneOrEngine\r\n     * @param rootUrl\r\n     * @param doNotStart\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _ParseParticleSystem(system: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false): ParticleSystem {\r\n        throw _WarnImport(\"ParseParticle\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new SubEmitter from a serialized JSON version\r\n     * @param serializationObject defines the JSON object to read from\r\n     * @param sceneOrEngine defines the hosting scene or the hosting engine\r\n     * @param rootUrl defines the rootUrl for data loading\r\n     * @returns a new SubEmitter\r\n     */\r\n    public static Parse(serializationObject: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): SubEmitter {\r\n        const system = serializationObject.particleSystem;\r\n        const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\r\n        subEmitter.type = serializationObject.type;\r\n        subEmitter.inheritDirection = serializationObject.inheritDirection;\r\n        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\r\n        subEmitter.particleSystem._isSubEmitter = true;\r\n\r\n        return subEmitter;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose() {\r\n        this.particleSystem.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}