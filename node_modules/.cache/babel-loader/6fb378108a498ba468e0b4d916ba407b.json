{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/cameras\n */\n\nvar TargetCamera =\n/** @class */\nfunction (_super) {\n  __extends(TargetCamera, _super);\n  /**\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n   * This is the base of the follow, arc rotate cameras and Free camera\n   * @see https://doc.babylonjs.com/features/cameras\n   * @param name Defines the name of the camera in the scene\n   * @param position Defines the start position of the camera in the scene\n   * @param scene Defines the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n\n\n  function TargetCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n\n    _this._tmpUpVector = Vector3.Zero();\n    _this._tmpTargetVector = Vector3.Zero();\n    /**\n     * Define the current direction the camera is moving to\n     */\n\n    _this.cameraDirection = new Vector3(0, 0, 0);\n    /**\n     * Define the current rotation the camera is rotating to\n     */\n\n    _this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n\n    _this.ignoreParentScaling = false;\n    /**\n     * When set, the up vector of the camera will be updated by the rotation of the camera\n     */\n\n    _this.updateUpVectorFromRotation = false;\n    _this._tmpQuaternion = new Quaternion();\n    /**\n     * Define the current rotation of the camera\n     */\n\n    _this.rotation = new Vector3(0, 0, 0);\n    /**\n     * Define the current speed of the camera\n     */\n\n    _this.speed = 2.0;\n    /**\n     * Add constraint to the camera to prevent it to move freely in all directions and\n     * around all axis.\n     */\n\n    _this.noRotationConstraint = false;\n    /**\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n     * panning\n     */\n\n    _this.invertRotation = false;\n    /**\n     * Speed multiplier for inverse camera panning\n     */\n\n    _this.inverseRotationSpeed = 0.2;\n    /**\n     * Define the current target of the camera as an object or a position.\n     * Please note that locking a target will disable panning.\n     */\n\n    _this.lockedTarget = null;\n    /** @hidden */\n\n    _this._currentTarget = Vector3.Zero();\n    /** @hidden */\n\n    _this._initialFocalDistance = 1;\n    /** @hidden */\n\n    _this._viewMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._camMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraTransformMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraRotationMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._referencePoint = new Vector3(0, 0, 1);\n    /** @hidden */\n\n    _this._transformedReferencePoint = Vector3.Zero();\n    _this._defaultUp = Vector3.Up();\n    _this._cachedRotationZ = 0;\n    _this._cachedQuaternionRotationZ = 0;\n    return _this;\n  }\n  /**\n   * Gets the position in front of the camera at a given distance.\n   * @param distance The distance from the camera we want the position to be\n   * @returns the position\n   */\n\n\n  TargetCamera.prototype.getFrontPosition = function (distance) {\n    this.getWorldMatrix();\n    var direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getLockedTargetPosition = function () {\n    if (!this.lockedTarget) {\n      return null;\n    }\n\n    if (this.lockedTarget.absolutePosition) {\n      this.lockedTarget.computeWorldMatrix();\n    }\n\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  };\n  /**\n   * Store current camera state of the camera (fov, position, rotation, etc..)\n   * @returns the camera\n   */\n\n\n  TargetCamera.prototype.storeState = function () {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    return _super.prototype.storeState.call(this);\n  };\n  /**\n   * Restored camera state. You must call storeState() first\n   * @returns whether it was successful or not\n   * @hidden\n   */\n\n\n  TargetCamera.prototype._restoreStateValues = function () {\n    if (!_super.prototype._restoreStateValues.call(this)) {\n      return false;\n    }\n\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  };\n  /**\n   * @param ignoreParentClass\n   * @hidden\n   */\n\n\n  TargetCamera.prototype._updateCache = function (ignoreParentClass) {\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n\n    this._cache.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }; // Synchronized\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._isSynchronizedViewMatrix = function () {\n    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\n      return false;\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }; // Methods\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._computeLocalCameraSpeed = function () {\n    var engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }; // Target\n\n  /**\n   * Defines the target the camera should look at.\n   * @param target Defines the new target as a Vector\n   */\n\n\n  TargetCamera.prototype.setTarget = function (target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n\n    this._camMatrix.invert();\n\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    var vDir = target.subtract(this.position);\n\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n\n    this.rotation.z = 0;\n\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  };\n\n  Object.defineProperty(TargetCamera.prototype, \"target\", {\n    /**\n     * Defines the target point of the camera.\n     * The camera looks towards it form the radius distance.\n     */\n    get: function get() {\n      return this.getTarget();\n    },\n    set: function set(value) {\n      this.setTarget(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Return the current target position of the camera. This value is expressed in local space.\n   * @returns the target position\n   */\n\n  TargetCamera.prototype.getTarget = function () {\n    return this._currentTarget;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._decideIfNeedsToMove = function () {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._updatePosition = function () {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this.position.addInPlace(TmpVectors.Vector3[0]);\n      return;\n    }\n\n    this.position.addInPlace(this.cameraDirection);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._checkInputs = function () {\n    var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n\n    var needToMove = this._decideIfNeedsToMove();\n\n    var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0; // Move\n\n    if (needToMove) {\n      this._updatePosition();\n    } // Rotate\n\n\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n      }\n\n      this.rotation.x += this.cameraRotation.x * directionMultiplier;\n      this.rotation.y += this.cameraRotation.y * directionMultiplier; // Apply constraints\n\n      if (!this.noRotationConstraint) {\n        var limit = 1.570796;\n\n        if (this.rotation.x > limit) {\n          this.rotation.x = limit;\n        }\n\n        if (this.rotation.x < -limit) {\n          this.rotation.x = -limit;\n        }\n      } //rotate, if quaternion is set and rotation was used\n\n\n      if (this.rotationQuaternion) {\n        var len = this.rotation.lengthSquared();\n\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n      }\n    } // Inertia\n\n\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n\n  TargetCamera.prototype._updateCameraRotationMatrix = function () {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  };\n  /**\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n   * @returns the current camera\n   */\n\n\n  TargetCamera.prototype._rotateUpVectorWithCameraRotationMatrix = function () {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getViewMatrix = function () {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    } // Compute\n\n\n    this._updateCameraRotationMatrix(); // Apply the changed rotation to the upVector\n\n\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ !== this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedRotationZ = this.rotation.z;\n    }\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n\n    return this._viewMatrix;\n  };\n\n  TargetCamera.prototype._computeViewMatrix = function (position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        var parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n\n        this._tmpTargetVector.copyFrom(target);\n\n        this._tmpUpVector.copyFrom(up);\n      }\n\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n\n      return;\n    }\n\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n\n    if (this.parent) {\n      var parentWorldMatrix = this.parent.getWorldMatrix();\n\n      this._viewMatrix.invert();\n\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n\n      this._viewMatrix.invert();\n\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  };\n  /**\n   * @param name\n   * @param cameraIndex\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  TargetCamera.prototype.createRigCamera = function (name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n\n      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n\n      return rigCamera;\n    }\n\n    return null;\n  };\n  /**\n   * @hidden\n   */\n\n\n  TargetCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        {\n          //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n          var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n          var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n\n          break;\n        }\n\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n\n    _super.prototype._updateRigCameras.call(this);\n  };\n\n  TargetCamera.prototype._getRigCamPositionAndTarget = function (halfSpace, rigCamera) {\n    var target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    var newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  };\n  /**\n   * Gets the current object class name.\n   * @return the class name\n   */\n\n\n  TargetCamera.prototype.getClassName = function () {\n    return \"TargetCamera\";\n  };\n\n  TargetCamera._RigCamTransformMatrix = new Matrix();\n  TargetCamera._TargetTransformMatrix = new Matrix();\n  TargetCamera._TargetFocalPoint = new Vector3();\n\n  __decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n\n  __decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);\n\n  return TargetCamera;\n}(Camera);\n\nexport { TargetCamera };","map":{"version":3,"mappings":"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","names":["serialize","serializeAsVector3","serializeAsMeshReference","Camera","Quaternion","Matrix","Vector3","Vector2","TmpVectors","Epsilon","Axis","__extends","name","position","scene","setActiveOnSceneIfNoneActive","_super","_this","Zero","Up","TargetCamera","distance","getWorldMatrix","direction","getTarget","subtract","normalize","scaleInPlace","globalPosition","add","lockedTarget","absolutePosition","computeWorldMatrix","_storedPosition","clone","_storedRotation","rotation","rotationQuaternion","_storedRotationQuaternion","storeState","call","_restoreStateValues","cameraDirection","copyFromFloats","cameraRotation","_initCache","_cache","Number","MAX_VALUE","ignoreParentClass","_updateCache","lockedTargetPosition","_getLockedTargetPosition","copyFrom","_isSynchronizedViewMatrix","equals","engine","getEngine","speed","Math","sqrt","getDeltaTime","getFps","target","upVector","_initialFocalDistance","length","z","_referencePoint","LookAtLHToRef","_defaultUp","_camMatrix","invert","x","atan","m","vDir","y","PI","isNaN","RotationYawPitchRollToRef","Object","value","setTarget","_currentTarget","abs","parent","invertToRef","TransformNormalToRef","addInPlace","directionMultiplier","invertRotation","inverseRotationSpeed","needToMove","_decideIfNeedsToMove","needToRotate","_updatePosition","toEulerAnglesToRef","noRotationConstraint","limit","len","lengthSquared","inertia","_checkInputs","toRotationMatrix","_cameraRotationMatrix","_updateCameraRotationMatrix","_cachedQuaternionRotationZ","_rotateUpVectorWithCameraRotationMatrix","_cachedRotationZ","TransformCoordinatesToRef","_transformedReferencePoint","addToRef","updateUpVectorFromRotation","Y","rotateByQuaternionToRef","FromEulerVectorToRef","_tmpQuaternion","_computeViewMatrix","_viewMatrix","up","ignoreParentScaling","parentWorldMatrix","_globalPosition","_tmpTargetVector","_tmpUpVector","_markSyncedWithParent","getScene","useRightHandedSystem","LookAtRHToRef","multiplyToRef","getTranslationToRef","cameraIndex","cameraRigMode","RIG_MODE_NONE","rigCamera","isRigCamera","rigParent","RIG_MODE_VR","RIG_MODE_WEBVR","_cameraRigParams","camLeft","_rigCameras","camRight","RIG_MODE_STEREOSCOPIC_ANAGLYPH","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","leftSign","rightSign","_getRigCamPositionAndTarget","stereoHalfAngle","_updateRigCameras","halfSpace","subtractToRef","_TargetFocalPoint","newFocalTarget","TranslationToRef","_TargetTransformMatrix","RotationAxis","_RigCamTransformMatrix","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/targetCamera.ts"],"sourcesContent":["import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @hidden */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @hidden */\r\n    public _initialFocalDistance = 1;\r\n    /** @hidden */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @hidden */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @hidden */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @hidden\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @param ignoreParentClass\r\n     * @hidden\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @hidden */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @hidden */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @hidden */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param name\r\n     * @param cameraIndex\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}