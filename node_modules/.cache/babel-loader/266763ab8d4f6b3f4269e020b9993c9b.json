{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\n\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n  return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh representing the ground\n */\n\n\nvar GroundMesh =\n/** @class */\nfunction (_super) {\n  __extends(GroundMesh, _super);\n\n  function GroundMesh(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /** If octree should be generated */\n\n\n    _this.generateOctree = false;\n    return _this;\n  }\n  /**\n   * \"GroundMesh\"\n   * @returns \"GroundMesh\"\n   */\n\n\n  GroundMesh.prototype.getClassName = function () {\n    return \"GroundMesh\";\n  };\n\n  Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\n    /**\n     * The minimum of x and y subdivisions\n     */\n    get: function get() {\n      return Math.min(this._subdivisionsX, this._subdivisionsY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\n    /**\n     * X subdivisions\n     */\n    get: function get() {\n      return this._subdivisionsX;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\n    /**\n     * Y subdivisions\n     */\n    get: function get() {\n      return this._subdivisionsY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\n   * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n   * @param chunksCount the number of subdivisions for x and y\n   * @param octreeBlocksSize (Default: 32)\n   */\n\n  GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\n    if (octreeBlocksSize === void 0) {\n      octreeBlocksSize = 32;\n    }\n\n    this._subdivisionsX = chunksCount;\n    this._subdivisionsY = chunksCount;\n    this.subdivide(chunksCount); // Call the octree system optimization if it is defined.\n\n    var thisAsAny = this;\n\n    if (thisAsAny.createOrUpdateSubmeshesOctree) {\n      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n    }\n  };\n  /**\n   * Returns a height (y) value in the World system :\n   * the ground altitude at the coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns the ground y position if (x, z) are outside the ground surface.\n   */\n\n\n  GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this.position.y;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    var y = -(facet.x * x + facet.z * z + facet.w) / facet.y; // return y in the World system\n\n    Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n    return tmpVect.y;\n  };\n  /**\n   * Returns a normalized vector (Vector3) orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\n    var normal = new Vector3(0.0, 1.0, 0.0);\n    this.getNormalAtCoordinatesToRef(x, z, normal);\n    return normal;\n  };\n  /**\n   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @param ref vector to store the result\n   * @returns the GroundMesh.\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\n    var world = this.getWorldMatrix();\n    var tmpMat = TmpVectors.Matrix[5];\n    world.invertToRef(tmpMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n    return this;\n  };\n  /**\n   * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\n   * if the ground has been updated.\n   * This can be used in the render loop.\n   * @returns the GroundMesh.\n   */\n\n\n  GroundMesh.prototype.updateCoordinateHeights = function () {\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n    }\n\n    this._computeHeightQuads();\n\n    return this;\n  }; // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n\n\n  GroundMesh.prototype._getFacetAt = function (x, z) {\n    // retrieve col and row from x, z coordinates in the ground local system\n    var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n    var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n    var quad = this._heightQuads[row * this._subdivisionsX + col];\n    var facet;\n\n    if (z < quad.slope.x * x + quad.slope.y) {\n      facet = quad.facet1;\n    } else {\n      facet = quad.facet2;\n    }\n\n    return facet;\n  }; //  Creates and populates the heightMap array with \"facet\" elements :\n  // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._initHeightQuads = function () {\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n    this._heightQuads = new Array();\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        var quad = {\n          slope: Vector2.Zero(),\n          facet1: new Vector4(0.0, 0.0, 0.0, 0.0),\n          facet2: new Vector4(0.0, 0.0, 0.0, 0.0)\n        };\n        this._heightQuads[row * subdivisionsX + col] = quad;\n      }\n    }\n\n    return this;\n  }; // Compute each quad element values and update the the heightMap array :\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._computeHeightQuads = function () {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!positions) {\n      return this;\n    }\n\n    var v1 = TmpVectors.Vector3[3];\n    var v2 = TmpVectors.Vector3[2];\n    var v3 = TmpVectors.Vector3[1];\n    var v4 = TmpVectors.Vector3[0];\n    var v1v2 = TmpVectors.Vector3[4];\n    var v1v3 = TmpVectors.Vector3[5];\n    var v1v4 = TmpVectors.Vector3[6];\n    var norm1 = TmpVectors.Vector3[7];\n    var norm2 = TmpVectors.Vector3[8];\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var cd = 0; // 2D slope coefficient : z = cd * x + h\n\n    var h = 0;\n    var d1 = 0; // facet plane equation : ax + by + cz + d = 0\n\n    var d2 = 0;\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        i = col * 3;\n        j = row * (subdivisionsX + 1) * 3;\n        k = (row + 1) * (subdivisionsX + 1) * 3;\n        v1.x = positions[j + i];\n        v1.y = positions[j + i + 1];\n        v1.z = positions[j + i + 2];\n        v2.x = positions[j + i + 3];\n        v2.y = positions[j + i + 4];\n        v2.z = positions[j + i + 5];\n        v3.x = positions[k + i];\n        v3.y = positions[k + i + 1];\n        v3.z = positions[k + i + 2];\n        v4.x = positions[k + i + 3];\n        v4.y = positions[k + i + 4];\n        v4.z = positions[k + i + 5]; // 2D slope V1V4\n\n        cd = (v4.z - v1.z) / (v4.x - v1.x);\n        h = v1.z - cd * v1.x; // v1 belongs to the slope\n        // facet equations :\n        // we compute each facet normal vector\n        // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n        // we compute the value d by applying the equation to v1 which belongs to the plane\n        // then we store the facet equation in a Vector4\n\n        v2.subtractToRef(v1, v1v2);\n        v3.subtractToRef(v1, v1v3);\n        v4.subtractToRef(v1, v1v4);\n        Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n\n        Vector3.CrossToRef(v1v2, v1v4, norm2);\n        norm1.normalize();\n        norm2.normalize();\n        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n        var quad = this._heightQuads[row * subdivisionsX + col];\n        quad.slope.copyFromFloats(cd, h);\n        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Serializes this ground mesh\n   * @param serializationObject object to write serialization to\n   */\n\n\n  GroundMesh.prototype.serialize = function (serializationObject) {\n    _super.prototype.serialize.call(this, serializationObject);\n\n    serializationObject.subdivisionsX = this._subdivisionsX;\n    serializationObject.subdivisionsY = this._subdivisionsY;\n    serializationObject.minX = this._minX;\n    serializationObject.maxX = this._maxX;\n    serializationObject.minZ = this._minZ;\n    serializationObject.maxZ = this._maxZ;\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n  };\n  /**\n   * Parses a serialized ground mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the ground mesh in\n   * @returns the created ground mesh\n   */\n\n\n  GroundMesh.Parse = function (parsedMesh, scene) {\n    var result = new GroundMesh(parsedMesh.name, scene);\n    result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n    result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n    result._minX = parsedMesh.minX;\n    result._maxX = parsedMesh.maxX;\n    result._minZ = parsedMesh.minZ;\n    result._maxZ = parsedMesh.maxZ;\n    result._width = parsedMesh.width;\n    result._height = parsedMesh.height;\n    return result;\n  };\n\n  return GroundMesh;\n}(Mesh);\n\nexport { GroundMesh };","map":{"version":3,"mappings":"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","names":["Vector3","Vector2","TmpVectors","Vector4","VertexBuffer","Mesh","_GroundMeshParser","parsedMesh","scene","GroundMesh","Parse","__extends","name","_super","_this","Object","Math","min","_subdivisionsX","_subdivisionsY","chunksCount","octreeBlocksSize","subdivide","thisAsAny","createOrUpdateSubmeshesOctree","x","z","world","getWorldMatrix","invMat","Matrix","invertToRef","tmpVect","TransformCoordinatesFromFloatsToRef","_minX","_maxX","_minZ","_maxZ","position","y","_heightQuads","length","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","w","normal","getNormalAtCoordinatesToRef","ref","tmpMat","TransformNormalFromFloatsToRef","col","floor","_width","row","_height","quad","slope","facet1","facet2","subdivisionsX","subdivisionsY","Array","Zero","positions","getVerticesData","PositionKind","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","i","j","k","cd","h","d1","d2","subtractToRef","CrossToRef","normalize","copyFromFloats","serializationObject","serialize","call","minX","maxX","minZ","maxZ","width","height","result"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/groundMesh.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @hidden */\r\n    public _subdivisionsX: number;\r\n    /** @hidden */\r\n    public _subdivisionsY: number;\r\n    /** @hidden */\r\n    public _width: number;\r\n    /** @hidden */\r\n    public _height: number;\r\n    /** @hidden */\r\n    public _minX: number;\r\n    /** @hidden */\r\n    public _maxX: number;\r\n    /** @hidden */\r\n    public _minZ: number;\r\n    /** @hidden */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}