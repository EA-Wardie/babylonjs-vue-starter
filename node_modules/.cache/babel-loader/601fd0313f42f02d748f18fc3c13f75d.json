{"ast":null,"code":"import \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This is a movement feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\n\nvar WebXRControllerMovement =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerMovement, _super);\n  /**\n   * constructs a new movement controller system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options configuration object for this feature\n   */\n\n\n  function WebXRControllerMovement(_xrSessionManager, options) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e, _f;\n\n    _this = _super.call(this, _xrSessionManager) || this;\n    _this._controllers = {};\n    _this._currentRegistrationConfigurations = []; // forward direction for movement, which may differ from viewer pose.\n\n    _this._movementDirection = null; // unused\n\n    _this._tmpRotationMatrix = Matrix.Identity();\n    _this._tmpTranslationDirection = new Vector3();\n    _this._tmpMovementTranslation = new Vector3();\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        registeredComponents: []\n      };\n      var controllerData = _this._controllers[xrController.uniqueId]; // movement controller only available to gamepad-enabled input sources.\n\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        var initController_1 = function initController_1() {\n          if (xrController.motionController) {\n            var _loop_1 = function _loop_1(registration) {\n              var component = null;\n\n              if (registration.allowedComponentTypes) {\n                for (var _b = 0, _c = registration.allowedComponentTypes; _b < _c.length; _b++) {\n                  var componentType = _c[_b];\n                  var componentOfType = xrController.motionController.getComponentOfType(componentType);\n\n                  if (componentOfType !== null) {\n                    component = componentOfType;\n                    break;\n                  }\n                }\n              }\n\n              if (registration.mainComponentOnly) {\n                var mainComponent = xrController.motionController.getMainComponent();\n\n                if (mainComponent === null) {\n                  return \"continue\";\n                }\n\n                component = mainComponent;\n              }\n\n              if (typeof registration.componentSelectionPredicate === \"function\") {\n                // if does not match we do want to ignore a previously found component\n                component = registration.componentSelectionPredicate(xrController);\n              }\n\n              if (component && registration.forceHandedness) {\n                if (xrController.inputSource.handedness !== registration.forceHandedness) {\n                  return \"continue\";\n                }\n              }\n\n              if (component === null) {\n                return \"continue\";\n              }\n\n              var registeredComponent = {\n                registrationConfiguration: registration,\n                component: component\n              };\n              controllerData.registeredComponents.push(registeredComponent);\n\n              if (\"axisChangedHandler\" in registration) {\n                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add(function (axesData) {\n                  registration.axisChangedHandler(axesData, _this._movementState, _this._featureContext, _this._xrInput);\n                });\n              }\n\n              if (\"buttonChangedhandler\" in registration) {\n                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(function () {\n                  if (component.changes.pressed) {\n                    registration.buttonChangedhandler(component.changes.pressed, _this._movementState, _this._featureContext, _this._xrInput);\n                  }\n                });\n              }\n            };\n\n            for (var _i = 0, _a = _this._currentRegistrationConfigurations; _i < _a.length; _i++) {\n              var registration = _a[_i];\n\n              _loop_1(registration);\n            }\n          }\n        };\n\n        if (xrController.motionController) {\n          initController_1();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(function () {\n            initController_1();\n          });\n        }\n      }\n    };\n\n    if (!options || options.xrInput === undefined) {\n      Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\n      return _this;\n    }\n\n    if (Array.isArray(options.customRegistrationConfigurations)) {\n      _this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\n    } else {\n      _this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS[\"default\"];\n    } // synchronized from feature setter properties\n\n\n    _this._featureContext = {\n      movementEnabled: options.movementEnabled || true,\n      movementOrientationFollowsViewerPose: (_a = options.movementOrientationFollowsViewerPose) !== null && _a !== void 0 ? _a : true,\n      movementSpeed: (_b = options.movementSpeed) !== null && _b !== void 0 ? _b : 1,\n      movementThreshold: (_c = options.movementThreshold) !== null && _c !== void 0 ? _c : 0.25,\n      rotationEnabled: (_d = options.rotationEnabled) !== null && _d !== void 0 ? _d : true,\n      rotationSpeed: (_e = options.rotationSpeed) !== null && _e !== void 0 ? _e : 1.0,\n      rotationThreshold: (_f = options.rotationThreshold) !== null && _f !== void 0 ? _f : 0.25\n    };\n    _this._movementState = {\n      moveX: 0,\n      moveY: 0,\n      rotateX: 0,\n      rotateY: 0\n    };\n    _this._xrInput = options.xrInput;\n    return _this;\n  }\n\n  Object.defineProperty(WebXRControllerMovement.prototype, \"movementDirection\", {\n    /**\n     * Current movement direction.  Will be null before XR Frames have been processed.\n     */\n    get: function get() {\n      return this._movementDirection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"movementEnabled\", {\n    /**\n     * Is movement enabled\n     */\n    get: function get() {\n      return this._featureContext.movementEnabled;\n    },\n\n    /**\n     * Sets whether movement is enabled or not\n     * @param enabled is movement enabled\n     */\n    set: function set(enabled) {\n      this._featureContext.movementEnabled = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"movementOrientationFollowsViewerPose\", {\n    /**\n     * If movement follows viewer pose\n     */\n    get: function get() {\n      return this._featureContext.movementOrientationFollowsViewerPose;\n    },\n\n    /**\n     * Sets whether movement follows viewer pose\n     * @param followsPose is movement should follow viewer pose\n     */\n    set: function set(followsPose) {\n      this._featureContext.movementOrientationFollowsViewerPose = followsPose;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"movementSpeed\", {\n    /**\n     * Gets movement speed\n     */\n    get: function get() {\n      return this._featureContext.movementSpeed;\n    },\n\n    /**\n     * Sets movement speed\n     * @param movementSpeed movement speed\n     */\n    set: function set(movementSpeed) {\n      this._featureContext.movementSpeed = movementSpeed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"movementThreshold\", {\n    /**\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n     */\n    get: function get() {\n      return this._featureContext.movementThreshold;\n    },\n\n    /**\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n     * @param movementThreshold new threshold\n     */\n    set: function set(movementThreshold) {\n      this._featureContext.movementThreshold = movementThreshold;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"rotationEnabled\", {\n    /**\n     * Is rotation enabled\n     */\n    get: function get() {\n      return this._featureContext.rotationEnabled;\n    },\n\n    /**\n     * Sets whether rotation is enabled or not\n     * @param enabled is rotation enabled\n     */\n    set: function set(enabled) {\n      this._featureContext.rotationEnabled = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"rotationSpeed\", {\n    /**\n     * Gets rotation speed factor\n     */\n    get: function get() {\n      return this._featureContext.rotationSpeed;\n    },\n\n    /**\n     * Sets rotation speed factor (1.0 is default)\n     * @param rotationSpeed new rotation speed factor\n     */\n    set: function set(rotationSpeed) {\n      this._featureContext.rotationSpeed = rotationSpeed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRControllerMovement.prototype, \"rotationThreshold\", {\n    /**\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n     */\n    get: function get() {\n      return this._featureContext.rotationThreshold;\n    },\n\n    /**\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n     * @param threshold new threshold\n     */\n    set: function set(threshold) {\n      this._featureContext.rotationThreshold = threshold;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRControllerMovement.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    return true;\n  };\n\n  WebXRControllerMovement.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n    this._controllers = {};\n    return true;\n  };\n  /**\n   * Occurs on every XR frame.\n   * @param _xrFrame\n   */\n\n\n  WebXRControllerMovement.prototype._onXRFrame = function (_xrFrame) {\n    if (!this.attach) {\n      return;\n    }\n\n    if (this._movementDirection === null) {\n      this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();\n    }\n\n    if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\n      // smooth rotation\n      var deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\n\n      var rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n\n      if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n        this._xrInput.xrCamera.cameraRotation.y += rotationY;\n        this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));\n      } else {\n        // movement orientation direction does not affect camera.  We use rotation speed multiplier\n        // otherwise need to implement inertia and constraints for same feel as TargetCamera.\n        this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3.0, 0, 0));\n      }\n    } else if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n      this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\n    }\n\n    if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {\n      Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\n\n      this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0)); // move according to forward direction based on camera speed\n\n\n      Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\n\n      this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\n\n      this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\n    }\n  };\n\n  WebXRControllerMovement.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    for (var _i = 0, _a = controllerData.registeredComponents; _i < _a.length; _i++) {\n      var registeredComponent = _a[_i];\n\n      if (registeredComponent.onAxisChangedObserver) {\n        registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\n      }\n\n      if (registeredComponent.onButtonChangedObserver) {\n        registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\n      }\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;\n  /**\n   * Standard controller configurations.\n   */\n\n  WebXRControllerMovement.REGISTRATIONS = {\n    \"default\": [{\n      allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n      forceHandedness: \"left\",\n      axisChangedHandler: function axisChangedHandler(axes, movementState, featureContext) {\n        movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\n        movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\n      }\n    }, {\n      allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n      forceHandedness: \"right\",\n      axisChangedHandler: function axisChangedHandler(axes, movementState, featureContext) {\n        movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\n        movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\n      }\n    }]\n  };\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the webxr specs version\n   */\n\n  WebXRControllerMovement.Version = 1;\n  return WebXRControllerMovement;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerMovement };\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerMovement(xrSessionManager, options);\n  };\n}, WebXRControllerMovement.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","WebXRControllerComponent","Matrix","Quaternion","Vector3","WebXRAbstractFeature","Tools","__extends","_xrSessionManager","options","_super","_this","Identity","xrController","_controllers","uniqueId","registeredComponents","controllerData","inputSource","targetRayMode","gamepad","initController_1","motionController","registration","component","allowedComponentTypes","_b","componentType","componentOfType","getComponentOfType","mainComponentOnly","mainComponent","getMainComponent","componentSelectionPredicate","forceHandedness","handedness","registeredComponent","registrationConfiguration","push","onAxisChangedObserver","onAxisValueChangedObservable","add","axesData","axisChangedHandler","_movementState","_featureContext","_xrInput","onButtonChangedObserver","onButtonStateChangedObservable","changes","pressed","buttonChangedhandler","_currentRegistrationConfigurations","_i","onMotionControllerInitObservable","addOnce","xrInput","undefined","Error","Array","isArray","customRegistrationConfigurations","WebXRControllerMovement","REGISTRATIONS","movementEnabled","movementOrientationFollowsViewerPose","_a","movementSpeed","movementThreshold","_c","rotationEnabled","_d","rotationSpeed","_e","rotationThreshold","_f","moveX","moveY","rotateX","rotateY","Object","_movementDirection","enabled","followsPose","threshold","attach","call","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","keys","controllerId","_xrFrame","xrCamera","rotationQuaternion","clone","deltaMillis","scene","getEngine","getDeltaTime","rotationY","useRightHandedSystem","cameraRotation","y","multiply","RotationYawPitchRoll","multiplyInPlace","copyFrom","FromQuaternionToRef","_tmpRotationMatrix","_tmpTranslationDirection","set","TransformCoordinatesToRef","_tmpMovementTranslation","scaleInPlace","_computeLocalCameraSpeed","cameraDirection","addInPlace","xrControllerUniqueId","remove","MOVEMENT","THUMBSTICK_TYPE","TOUCHPAD_TYPE","axes","movementState","featureContext","Math","abs","x","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRControllerMovement.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue, IWebXRMotionControllerComponentChangesValues } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { MotionControllerComponentType } from \"../motionController/webXRAbstractMotionController\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * The options container for the controller movement module\r\n */\r\nexport interface IWebXRControllerMovementOptions {\r\n    /**\r\n     * Override default behaviour and provide your own movement controls\r\n     */\r\n    customRegistrationConfigurations?: WebXRControllerMovementRegistrationConfiguration[];\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    movementEnabled?: boolean;\r\n    /**\r\n     * Camera direction follows view pose and movement by default will move independently of the viewer's pose.\r\n     */\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    movementSpeed?: number;\r\n    /**\r\n     * Minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    movementThreshold?: number;\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    rotationEnabled?: boolean;\r\n    /**\r\n     * Minimum threshold the controller's thumstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    rotationThreshold?: number;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    rotationSpeed?: number;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Feature context is used in handlers and on each XR frame to control the camera movement/direction.\r\n */\r\nexport type WebXRControllerMovementFeatureContext = {\r\n    movementEnabled: boolean;\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    movementSpeed: number;\r\n    movementThreshold: number;\r\n    rotationEnabled: boolean;\r\n    rotationSpeed: number;\r\n    rotationThreshold: number;\r\n};\r\n\r\n/**\r\n * Current state of Movements shared across components and handlers.\r\n */\r\nexport type WebXRControllerMovementState = {\r\n    moveX: number;\r\n    moveY: number;\r\n    rotateX: number;\r\n    rotateY: number;\r\n};\r\n\r\n/**\r\n * Button of Axis Handler must be specified.\r\n */\r\nexport type WebXRControllerMovementRegistrationConfiguration = {\r\n    /**\r\n     * handlers are filtered to these types only\r\n     */\r\n    allowedComponentTypes?: MotionControllerComponentType[];\r\n    /**\r\n     * For registering movement to specific hand only.  Useful if your app has a \"main hand\" and \"off hand\" for determining the functionality of a controller.\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n    /**\r\n     * For main component only (useful for buttons and may not trigger axis changes).\r\n     */\r\n    mainComponentOnly?: boolean;\r\n    /**\r\n     * Additional predicate to apply to controllers to restrict a handler being added.\r\n     */\r\n    componentSelectionPredicate?: (xrController: WebXRInputSource) => Nullable<WebXRControllerComponent>;\r\n} & (\r\n    | {\r\n          /**\r\n           * Called when axis changes occur.\r\n           */\r\n          axisChangedHandler: (\r\n              axes: IWebXRMotionControllerAxesValue,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n    | {\r\n          /**\r\n           * Called when the button state changes.\r\n           */\r\n          buttonChangedhandler: (\r\n              pressed: IWebXRMotionControllerComponentChangesValues<boolean>,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n);\r\n\r\ntype RegisteredComponent = {\r\n    registrationConfiguration: WebXRControllerMovementRegistrationConfiguration;\r\n    component: WebXRControllerComponent;\r\n    onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n};\r\n\r\n/**\r\n * This is a movement feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            registeredComponents: RegisteredComponent[];\r\n        };\r\n    } = {};\r\n\r\n    private _currentRegistrationConfigurations: WebXRControllerMovementRegistrationConfiguration[] = [];\r\n    // Feature configuration is syncronized - this is passed to all handlers (reduce GC pressure).\r\n    private _featureContext: WebXRControllerMovementFeatureContext;\r\n    // forward direction for movement, which may differ from viewer pose.\r\n    private _movementDirection: Nullable<Quaternion> = null;\r\n    private _movementState: WebXRControllerMovementState;\r\n    private _xrInput: WebXRInput;\r\n\r\n    // unused\r\n    private _tmpRotationMatrix: Matrix = Matrix.Identity();\r\n    private _tmpTranslationDirection: Vector3 = new Vector3();\r\n    private _tmpMovementTranslation: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MOVEMENT;\r\n\r\n    /**\r\n     * Standard controller configurations.\r\n     */\r\n    public static readonly REGISTRATIONS: { [key: string]: WebXRControllerMovementRegistrationConfiguration[] } = {\r\n        default: [\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"left\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\r\n                    movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"right\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\r\n                    movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n        ],\r\n    };\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Current movement direction.  Will be null before XR Frames have been processed.\r\n     */\r\n    public get movementDirection(): Nullable<Quaternion> {\r\n        return this._movementDirection;\r\n    }\r\n\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    public get movementEnabled(): boolean {\r\n        return this._featureContext.movementEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement is enabled or not\r\n     * @param enabled is movement enabled\r\n     */\r\n    public set movementEnabled(enabled: boolean) {\r\n        this._featureContext.movementEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * If movement follows viewer pose\r\n     */\r\n    public get movementOrientationFollowsViewerPose(): boolean {\r\n        return this._featureContext.movementOrientationFollowsViewerPose;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement follows viewer pose\r\n     * @param followsPose is movement should follow viewer pose\r\n     */\r\n    public set movementOrientationFollowsViewerPose(followsPose: boolean) {\r\n        this._featureContext.movementOrientationFollowsViewerPose = followsPose;\r\n    }\r\n\r\n    /**\r\n     * Gets movement speed\r\n     */\r\n    public get movementSpeed(): number {\r\n        return this._featureContext.movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets movement speed\r\n     * @param movementSpeed movement speed\r\n     */\r\n    public set movementSpeed(movementSpeed: number) {\r\n        this._featureContext.movementSpeed = movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    public get movementThreshold(): number {\r\n        return this._featureContext.movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     * @param movementThreshold new threshold\r\n     */\r\n    public set movementThreshold(movementThreshold: number) {\r\n        this._featureContext.movementThreshold = movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._featureContext.rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._featureContext.rotationEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * Gets rotation speed factor\r\n     */\r\n    public get rotationSpeed(): number {\r\n        return this._featureContext.rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets rotation speed factor (1.0 is default)\r\n     * @param rotationSpeed new rotation speed factor\r\n     */\r\n    public set rotationSpeed(rotationSpeed: number) {\r\n        this._featureContext.rotationSpeed = rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    public get rotationThreshold(): number {\r\n        return this._featureContext.rotationThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     * @param threshold new threshold\r\n     */\r\n    public set rotationThreshold(threshold: number) {\r\n        this._featureContext.rotationThreshold = threshold;\r\n    }\r\n    /**\r\n     * constructs a new movement controller system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, options: IWebXRControllerMovementOptions) {\r\n        super(_xrSessionManager);\r\n\r\n        if (!options || options.xrInput === undefined) {\r\n            Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(options.customRegistrationConfigurations)) {\r\n            this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\r\n        } else {\r\n            this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\r\n        }\r\n\r\n        // synchronized from feature setter properties\r\n        this._featureContext = {\r\n            movementEnabled: options.movementEnabled || true,\r\n            movementOrientationFollowsViewerPose: options.movementOrientationFollowsViewerPose ?? true,\r\n            movementSpeed: options.movementSpeed ?? 1,\r\n            movementThreshold: options.movementThreshold ?? 0.25,\r\n            rotationEnabled: options.rotationEnabled ?? true,\r\n            rotationSpeed: options.rotationSpeed ?? 1.0,\r\n            rotationThreshold: options.rotationThreshold ?? 0.25,\r\n        };\r\n\r\n        this._movementState = {\r\n            moveX: 0,\r\n            moveY: 0,\r\n            rotateX: 0,\r\n            rotateY: 0,\r\n        };\r\n\r\n        this._xrInput = options.xrInput;\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller: WebXRInputSource) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Occurs on every XR frame.\r\n     * @param _xrFrame\r\n     */\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!this.attach) {\r\n            return;\r\n        }\r\n\r\n        if (this._movementDirection === null) {\r\n            this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();\r\n        }\r\n\r\n        if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\r\n            // smooth rotation\r\n            const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\r\n            const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n\r\n            if (this._featureContext.movementOrientationFollowsViewerPose === true) {\r\n                this._xrInput.xrCamera.cameraRotation.y += rotationY;\r\n                this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));\r\n            } else {\r\n                // movement orientation direction does not affect camera.  We use rotation speed multiplier\r\n                // otherwise need to implement inertia and constraints for same feel as TargetCamera.\r\n                this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3.0, 0, 0));\r\n            }\r\n        } else if (this._featureContext.movementOrientationFollowsViewerPose === true) {\r\n            this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\r\n        }\r\n\r\n        if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {\r\n            Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\r\n            this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n            // move according to forward direction based on camera speed\r\n            Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\r\n            this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\r\n\r\n            this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            registeredComponents: [],\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n\r\n        // movement controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initController = () => {\r\n                if (xrController.motionController) {\r\n                    for (const registration of this._currentRegistrationConfigurations) {\r\n                        let component: Nullable<WebXRControllerComponent> = null;\r\n\r\n                        if (registration.allowedComponentTypes) {\r\n                            for (const componentType of registration.allowedComponentTypes) {\r\n                                const componentOfType = xrController.motionController.getComponentOfType(componentType);\r\n                                if (componentOfType !== null) {\r\n                                    component = componentOfType;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (registration.mainComponentOnly) {\r\n                            const mainComponent = xrController.motionController.getMainComponent();\r\n                            if (mainComponent === null) {\r\n                                continue;\r\n                            }\r\n                            component = mainComponent;\r\n                        }\r\n\r\n                        if (typeof registration.componentSelectionPredicate === \"function\") {\r\n                            // if does not match we do want to ignore a previously found component\r\n                            component = registration.componentSelectionPredicate(xrController);\r\n                        }\r\n\r\n                        if (component && registration.forceHandedness) {\r\n                            if (xrController.inputSource.handedness !== registration.forceHandedness) {\r\n                                continue; // do not register\r\n                            }\r\n                        }\r\n\r\n                        if (component === null) {\r\n                            continue; // do not register\r\n                        }\r\n\r\n                        const registeredComponent: RegisteredComponent = {\r\n                            registrationConfiguration: registration,\r\n                            component,\r\n                        };\r\n                        controllerData.registeredComponents.push(registeredComponent);\r\n\r\n                        if (\"axisChangedHandler\" in registration) {\r\n                            registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {\r\n                                registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\r\n                            });\r\n                        }\r\n\r\n                        if (\"buttonChangedhandler\" in registration) {\r\n                            registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\r\n                                if (component!.changes.pressed) {\r\n                                    registration.buttonChangedhandler(component!.changes.pressed, this._movementState, this._featureContext, this._xrInput);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (xrController.motionController) {\r\n                initController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initController();\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n\r\n        for (const registeredComponent of controllerData.registeredComponents) {\r\n            if (registeredComponent.onAxisChangedObserver) {\r\n                registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\r\n            }\r\n            if (registeredComponent.onButtonChangedObserver) {\r\n                registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\r\n            }\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerMovement.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerMovement(xrSessionManager, options);\r\n    },\r\n    WebXRControllerMovement.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module"}