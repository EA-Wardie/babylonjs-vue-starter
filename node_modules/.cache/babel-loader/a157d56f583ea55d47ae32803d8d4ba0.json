{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __extends } from \"tslib\";\nimport { Material } from \"../Materials/material.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * A multi-material is used to apply different materials to different parts of the same object without the need of\n * separate meshes. This can be use to improve performances.\n * @see https://doc.babylonjs.com/how_to/multi_materials\n */\n\nvar MultiMaterial =\n/** @class */\nfunction (_super) {\n  __extends(MultiMaterial, _super);\n  /**\n   * Instantiates a new Multi Material\n   * A multi-material is used to apply different materials to different parts of the same object without the need of\n   * separate meshes. This can be use to improve performances.\n   * @see https://doc.babylonjs.com/how_to/multi_materials\n   * @param name Define the name in the scene\n   * @param scene Define the scene the material belongs to\n   */\n\n\n  function MultiMaterial(name, scene) {\n    var _this = _super.call(this, name, scene, true) || this;\n    /** @hidden */\n\n\n    _this._waitingSubMaterialsUniqueIds = [];\n\n    _this.getScene().multiMaterials.push(_this);\n\n    _this.subMaterials = new Array();\n    _this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiMaterial.prototype, \"subMaterials\", {\n    /**\n     * Gets or Sets the list of Materials used within the multi material.\n     * They need to be ordered according to the submeshes order in the associated mesh\n     */\n    get: function get() {\n      return this._subMaterials;\n    },\n    set: function set(value) {\n      this._subMaterials = value;\n\n      this._hookArray(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Function used to align with Node.getChildren()\n   * @returns the list of Materials used within the multi material\n   */\n\n  MultiMaterial.prototype.getChildren = function () {\n    return this.subMaterials;\n  };\n\n  MultiMaterial.prototype._hookArray = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return deleted;\n    };\n  };\n  /**\n   * Get one of the submaterial by its index in the submaterials array\n   * @param index The index to look the sub material at\n   * @returns The Material if the index has been defined\n   */\n\n\n  MultiMaterial.prototype.getSubMaterial = function (index) {\n    if (index < 0 || index >= this.subMaterials.length) {\n      return this.getScene().defaultMaterial;\n    }\n\n    return this.subMaterials[index];\n  };\n  /**\n   * Get the list of active textures for the whole sub materials list.\n   * @returns All the textures that will be used during the rendering\n   */\n\n\n  MultiMaterial.prototype.getActiveTextures = function () {\n    var _a;\n\n    return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function (subMaterial) {\n      if (subMaterial) {\n        return subMaterial.getActiveTextures();\n      } else {\n        return [];\n      }\n    }));\n  };\n  /**\n   * Specifies if any sub-materials of this multi-material use a given texture.\n   * @param texture Defines the texture to check against this multi-material's sub-materials.\n   * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\n   */\n\n\n  MultiMaterial.prototype.hasTexture = function (texture) {\n    var _a;\n\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    for (var i = 0; i < this.subMaterials.length; i++) {\n      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Gets the current class name of the material e.g. \"MultiMaterial\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n\n\n  MultiMaterial.prototype.getClassName = function () {\n    return \"MultiMaterial\";\n  };\n  /**\n   * Checks if the material is ready to render the requested sub mesh\n   * @param mesh Define the mesh the submesh belongs to\n   * @param subMesh Define the sub mesh to look readiness for\n   * @param useInstances Define whether or not the material is used with instances\n   * @returns true if ready, otherwise false\n   */\n\n\n  MultiMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = this.subMaterials[index];\n\n      if (subMaterial) {\n        if (subMaterial._storeEffectOnSubMeshes) {\n          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\n            return false;\n          }\n\n          continue;\n        }\n\n        if (!subMaterial.isReady(mesh)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Clones the current material and its related sub materials\n   * @param name Define the name of the newly cloned material\n   * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\n   * @returns the cloned material\n   */\n\n\n  MultiMaterial.prototype.clone = function (name, cloneChildren) {\n    var newMultiMaterial = new MultiMaterial(name, this.getScene());\n\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = null;\n      var current = this.subMaterials[index];\n\n      if (cloneChildren && current) {\n        subMaterial = current.clone(name + \"-\" + current.name);\n      } else {\n        subMaterial = this.subMaterials[index];\n      }\n\n      newMultiMaterial.subMaterials.push(subMaterial);\n    }\n\n    return newMultiMaterial;\n  };\n  /**\n   * Serializes the materials into a JSON representation.\n   * @returns the JSON representation\n   */\n\n\n  MultiMaterial.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    serializationObject.materialsUniqueIds = [];\n    serializationObject.materials = [];\n\n    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n      var subMat = this.subMaterials[matIndex];\n\n      if (subMat) {\n        serializationObject.materialsUniqueIds.push(subMat.uniqueId);\n        serializationObject.materials.push(subMat.id);\n      } else {\n        serializationObject.materialsUniqueIds.push(null);\n        serializationObject.materials.push(null);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Dispose the material and release its associated resources\n   * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\n   * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\n   * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\n   */\n\n\n  MultiMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    if (forceDisposeChildren) {\n      for (var index_1 = 0; index_1 < this.subMaterials.length; index_1++) {\n        var subMaterial = this.subMaterials[index_1];\n\n        if (subMaterial) {\n          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\n        }\n      }\n    }\n\n    var index = scene.multiMaterials.indexOf(this);\n\n    if (index >= 0) {\n      scene.multiMaterials.splice(index, 1);\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n  };\n  /**\n   * Creates a MultiMaterial from parsed MultiMaterial data.\n   * @param parsedMultiMaterial defines parsed MultiMaterial data.\n   * @param scene defines the hosting scene\n   * @returns a new MultiMaterial\n   */\n\n\n  MultiMaterial.ParseMultiMaterial = function (parsedMultiMaterial, scene) {\n    var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\n    multiMaterial.id = parsedMultiMaterial.id;\n    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;\n\n    if (Tags) {\n      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n    }\n\n    if (parsedMultiMaterial.materialsUniqueIds) {\n      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;\n    } else {\n      parsedMultiMaterial.materials.forEach(function (subMatId) {\n        return multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId));\n      });\n    }\n\n    return multiMaterial;\n  };\n\n  return MultiMaterial;\n}(Material);\n\nexport { MultiMaterial };\nRegisterClass(\"BABYLON.MultiMaterial\", MultiMaterial);","map":{"version":3,"mappings":"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","names":["Material","Tags","RegisterClass","__extends","name","scene","_super","_this","getScene","multiMaterials","push","subMaterials","Array","_storeEffectOnSubMeshes","Object","MultiMaterial","_subMaterials","value","_hookArray","array","oldPush","items","result","apply","_markAllSubMeshesAsTexturesDirty","oldSplice","splice","index","deleteCount","deleted","length","defaultMaterial","getActiveTextures","call","concat","_a","map","subMaterial","texture","hasTexture","i","mesh","subMesh","useInstances","isReadyForSubMesh","isReady","cloneChildren","newMultiMaterial","current","clone","serializationObject","id","uniqueId","tags","GetTags","materialsUniqueIds","materials","matIndex","subMat","forceDisposeEffect","forceDisposeTextures","forceDisposeChildren","index_1","dispose","indexOf","parsedMultiMaterial","multiMaterial","_loadedUniqueId","AddTagsTo","_waitingSubMaterialsUniqueIds","forEach","subMatId","getLastMaterialById"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/multiMaterial.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\r\nexport class MultiMaterial extends Material {\r\n    private _subMaterials: Nullable<Material>[];\r\n    /** @hidden */\r\n    public _waitingSubMaterialsUniqueIds: string[] = [];\r\n\r\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\r\n    public get subMaterials(): Nullable<Material>[] {\r\n        return this._subMaterials;\r\n    }\r\n\r\n    public set subMaterials(value: Nullable<Material>[]) {\r\n        this._subMaterials = value;\r\n        this._hookArray(value);\r\n    }\r\n\r\n    /**\r\n     * Function used to align with Node.getChildren()\r\n     * @returns the list of Materials used within the multi material\r\n     */\r\n    public getChildren(): Nullable<Material>[] {\r\n        return this.subMaterials;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Multi Material\r\n     * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n     * separate meshes. This can be use to improve performances.\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     * @param name Define the name in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, true);\r\n\r\n        this.getScene().multiMaterials.push(this);\r\n\r\n        this.subMaterials = new Array<Material>();\r\n\r\n        this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\r\n    }\r\n\r\n    private _hookArray(array: Nullable<Material>[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: Nullable<Material>[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get one of the submaterial by its index in the submaterials array\r\n     * @param index The index to look the sub material at\r\n     * @returns The Material if the index has been defined\r\n     */\r\n    public getSubMaterial(index: number): Nullable<Material> {\r\n        if (index < 0 || index >= this.subMaterials.length) {\r\n            return this.getScene().defaultMaterial;\r\n        }\r\n\r\n        return this.subMaterials[index];\r\n    }\r\n\r\n    /**\r\n     * Get the list of active textures for the whole sub materials list.\r\n     * @returns All the textures that will be used during the rendering\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        return super.getActiveTextures().concat(\r\n            ...this.subMaterials.map((subMaterial) => {\r\n                if (subMaterial) {\r\n                    return subMaterial.getActiveTextures();\r\n                } else {\r\n                    return [];\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Specifies if any sub-materials of this multi-material use a given texture.\r\n     * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n     * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < this.subMaterials.length; i++) {\r\n            if (this.subMaterials[i]?.hasTexture(texture)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MultiMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested sub mesh\r\n     * @param mesh Define the mesh the submesh belongs to\r\n     * @param subMesh Define the sub mesh to look readiness for\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        for (let index = 0; index < this.subMaterials.length; index++) {\r\n            const subMaterial = this.subMaterials[index];\r\n            if (subMaterial) {\r\n                if (subMaterial._storeEffectOnSubMeshes) {\r\n                    if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!subMaterial.isReady(mesh)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones the current material and its related sub materials\r\n     * @param name Define the name of the newly cloned material\r\n     * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneChildren?: boolean): MultiMaterial {\r\n        const newMultiMaterial = new MultiMaterial(name, this.getScene());\r\n\r\n        for (let index = 0; index < this.subMaterials.length; index++) {\r\n            let subMaterial: Nullable<Material> = null;\r\n            const current = this.subMaterials[index];\r\n            if (cloneChildren && current) {\r\n                subMaterial = current.clone(name + \"-\" + current.name);\r\n            } else {\r\n                subMaterial = this.subMaterials[index];\r\n            }\r\n            newMultiMaterial.subMaterials.push(subMaterial);\r\n        }\r\n\r\n        return newMultiMaterial;\r\n    }\r\n\r\n    /**\r\n     * Serializes the materials into a JSON representation.\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.materialsUniqueIds = [];\r\n        serializationObject.materials = [];\r\n\r\n        for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\r\n            const subMat = this.subMaterials[matIndex];\r\n\r\n            if (subMat) {\r\n                serializationObject.materialsUniqueIds.push(subMat.uniqueId);\r\n                serializationObject.materials.push(subMat.id);\r\n            } else {\r\n                serializationObject.materialsUniqueIds.push(null);\r\n                serializationObject.materials.push(null);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and release its associated resources\r\n     * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n     * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, forceDisposeChildren?: boolean): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (forceDisposeChildren) {\r\n            for (let index = 0; index < this.subMaterials.length; index++) {\r\n                const subMaterial = this.subMaterials[index];\r\n                if (subMaterial) {\r\n                    subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\r\n                }\r\n            }\r\n        }\r\n\r\n        const index = scene.multiMaterials.indexOf(this);\r\n        if (index >= 0) {\r\n            scene.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Creates a MultiMaterial from parsed MultiMaterial data.\r\n     * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MultiMaterial\r\n     */\r\n    public static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial {\r\n        const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\r\n\r\n        multiMaterial.id = parsedMultiMaterial.id;\r\n        multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\r\n        }\r\n\r\n        if (parsedMultiMaterial.materialsUniqueIds) {\r\n            multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;\r\n        } else {\r\n            parsedMultiMaterial.materials.forEach((subMatId: string) => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));\r\n        }\r\n\r\n        return multiMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiMaterial\", MultiMaterial);\r\n"]},"metadata":{},"sourceType":"module"}