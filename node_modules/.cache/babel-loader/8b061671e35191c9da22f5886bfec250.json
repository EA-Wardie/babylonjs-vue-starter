{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.reflect.own-keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/babylon101/sprites\n */\n\nvar SpriteManager =\n/** @class */\nfunction () {\n  /**\n   * Creates a new sprite manager\n   * @param name defines the manager's name\n   * @param imgUrl defines the sprite sheet url\n   * @param capacity defines the maximum allowed number of sprites\n   * @param cellSize defines the size of a sprite cell\n   * @param scene defines the hosting scene\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param samplingMode defines the sampling mode to use with spritesheet\n   * @param fromPacked set to false; do not alter\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n   */\n  function SpriteManager(\n  /** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode, fromPacked, spriteJSON) {\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (fromPacked === void 0) {\n      fromPacked = false;\n    }\n\n    if (spriteJSON === void 0) {\n      spriteJSON = null;\n    }\n\n    var _this = this;\n\n    this.name = name;\n    /** Gets the list of sprites */\n\n    this.sprites = new Array();\n    /** Gets or sets the rendering group id (0 by default) */\n\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n\n    this.layerMask = 0x0fffffff;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n\n    this.isPickable = false;\n    /**\n     * An event triggered when the manager is disposed.\n     */\n\n    this.onDisposeObservable = new Observable();\n    this._disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n\n    this._packedAndReady = false;\n\n    this._customUpdate = function (sprite, baseSize) {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n\n      var num = sprite.cellIndex;\n\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = _this._spriteMap[sprite.cellIndex];\n      }\n\n      sprite._xOffset = _this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = _this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = _this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = _this._cellData[sprite.cellRef].frame.h;\n    };\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n\n    var engine = this._scene.getEngine();\n\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n\n    this._scene.spriteManagers.push(this);\n\n    this.uniqueId = this.scene.getUniqueId();\n\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n\n  Object.defineProperty(SpriteManager.prototype, \"onDispose\", {\n    /**\n     * Callback called when the manager is disposed\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"children\", {\n    /**\n     * Gets the array of sprites\n     */\n    get: function get() {\n      return this.sprites;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"scene\", {\n    /**\n     * Gets the hosting scene\n     */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"capacity\", {\n    /**\n     * Gets the capacity of the manager\n     */\n    get: function get() {\n      return this._spriteRenderer.capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"texture\", {\n    /**\n     * Gets or sets the spritesheet texture\n     */\n    get: function get() {\n      return this._spriteRenderer.texture;\n    },\n    set: function set(value) {\n      value.wrapU = Texture.CLAMP_ADDRESSMODE;\n      value.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._spriteRenderer.texture = value;\n      this._textureContent = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellWidth\", {\n    /** Defines the default width of a cell in the spritesheet */\n    get: function get() {\n      return this._spriteRenderer.cellWidth;\n    },\n    set: function set(value) {\n      this._spriteRenderer.cellWidth = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellHeight\", {\n    /** Defines the default height of a cell in the spritesheet */\n    get: function get() {\n      return this._spriteRenderer.cellHeight;\n    },\n    set: function set(value) {\n      this._spriteRenderer.cellHeight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"fogEnabled\", {\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n    get: function get() {\n      return this._spriteRenderer.fogEnabled;\n    },\n    set: function set(value) {\n      this._spriteRenderer.fogEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"blendMode\", {\n    /**\n     * Blend mode use to render the particle, it can be any of\n     * the static undefined properties provided in this class.\n     * Default value is 2\n     */\n    get: function get() {\n      return this._spriteRenderer.blendMode;\n    },\n    set: function set(blendMode) {\n      this._spriteRenderer.blendMode = blendMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"disableDepthWrite\", {\n    /** Disables writing to the depth buffer when rendering the sprites.\n     *  It can be handy to disable depth writing when using textures without alpha channel\n     *  and setting some specific blend modes.\n     */\n    get: function get() {\n      return this._disableDepthWrite;\n    },\n    set: function set(value) {\n      this._disableDepthWrite = value;\n      this._spriteRenderer.disableDepthWrite = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the string \"SpriteManager\"\n   * @returns \"SpriteManager\"\n   */\n\n  SpriteManager.prototype.getClassName = function () {\n    return \"SpriteManager\";\n  };\n\n  SpriteManager.prototype._makePacked = function (imgUrl, spriteJSON) {\n    var _this = this;\n\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n        var celldata = void 0;\n\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n\n        if (celldata.frames.length) {\n          var frametemp = {};\n\n          for (var i = 0; i < celldata.frames.length; i++) {\n            var _f = celldata.frames[i];\n\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n\n            var name_1 = _f[Object.keys(_f)[0]];\n\n            frametemp[name_1] = _f;\n          }\n\n          celldata.frames = frametemp;\n        }\n\n        var spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      var re = /\\./g;\n      var li = void 0;\n\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n\n      var jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n\n      var onerror_1 = function onerror_1() {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        _this._fromPacked = false;\n        _this._packedAndReady = false;\n      };\n\n      var onload_1 = function onload_1(data) {\n        try {\n          var celldata = JSON.parse(data);\n          var spritemap = Reflect.ownKeys(celldata.frames);\n          _this._spriteMap = spritemap;\n          _this._packedAndReady = true;\n          _this._cellData = celldata.frames;\n        } catch (e) {\n          _this._fromPacked = false;\n          _this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n\n      Tools.LoadFile(jsonUrl, onload_1, undefined, undefined, false, onerror_1);\n    }\n  };\n\n  SpriteManager.prototype._checkTextureAlpha = function (sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n\n    var textureSize = this.texture.getSize();\n\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n\n    var contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    var contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n    var contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5; // Rotate\n\n    var angle = sprite.angle;\n    var rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n    var rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n    var u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;\n    var v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;\n    var alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  };\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n   * @returns null if no hit or a PickingInfo\n   */\n\n\n  SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance = Number.MAX_VALUE;\n    var currentSprite = null;\n    var pickedPoint = TmpVectors.Vector3[0];\n    var cameraSpacePosition = TmpVectors.Vector3[1];\n    var cameraView = camera.getViewMatrix();\n    var activeRay = ray;\n    var pickedRay = ray;\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n\n      if (sprite.angle) {\n        // Create a rotation matrix to rotate the ray to the sprite's rotation\n        Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n        Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n        Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]); // inv translation x rotation x translation\n\n        TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n        TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n        activeRay = ray.clone();\n        Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n        Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n      } else {\n        activeRay = ray;\n      }\n\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (activeRay.intersectsBoxMinMax(min, max)) {\n        var currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n            continue;\n          }\n\n          pickedRay = activeRay;\n          distance = currentDistance;\n          currentSprite = sprite;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (currentSprite) {\n      var result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance; // Get picked point\n\n      var direction = TmpVectors.Vector3[2];\n      direction.copyFrom(pickedRay.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      pickedRay.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n\n    return null;\n  };\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @returns null if no hit or a PickingInfo array\n   */\n\n\n  SpriteManager.prototype.multiIntersects = function (ray, camera, predicate) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance;\n    var results = [];\n    var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    var cameraView = camera.getViewMatrix();\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n\n        var result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance; // Get picked point\n\n        var direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Render all child sprites\n   */\n\n\n  SpriteManager.prototype.render = function () {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var deltaTime = engine.getDeltaTime();\n\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  };\n  /**\n   * Rebuilds the manager (after a context lost, for eg)\n   */\n\n\n  SpriteManager.prototype.rebuild = function () {\n    var _a;\n\n    (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();\n  };\n  /**\n   * Release associated resources\n   */\n\n\n  SpriteManager.prototype.dispose = function () {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n\n      this._spriteRenderer = null;\n    }\n\n    this._textureContent = null; // Remove from scene\n\n    var index = this._scene.spriteManagers.indexOf(this);\n\n    this._scene.spriteManagers.splice(index, 1); // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\n   * Serializes the sprite manager to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n\n\n  SpriteManager.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n\n    serializationObject.sprites = [];\n\n    for (var _i = 0, _a = this.sprites; _i < _a.length; _i++) {\n      var sprite = _a[_i];\n      serializationObject.sprites.push(sprite.serialize());\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Parses a JSON object to create a new sprite manager.\n   * @param parsedManager The JSON object to parse\n   * @param scene The scene to create the sprite manager\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @returns the new sprite manager\n   */\n\n\n  SpriteManager.Parse = function (parsedManager, scene, rootUrl) {\n    var manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n\n    for (var _i = 0, _a = parsedManager.sprites; _i < _a.length; _i++) {\n      var parsedSprite = _a[_i];\n      Sprite.Parse(parsedSprite, manager);\n    }\n\n    return manager;\n  };\n  /**\n   * Creates a sprite manager from a snippet saved in a remote file\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n\n\n  SpriteManager.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n            var output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\n   * Creates a sprite manager from a snippet saved by the sprite editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n\n\n  SpriteManager.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.spriteManager);\n            var output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /** Define the Url to load snippets */\n\n\n  SpriteManager.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return SpriteManager;\n}();\n\nexport { SpriteManager };","map":{"version":3,"mappings":"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","names":["Observable","Vector3","TmpVectors","Matrix","Sprite","SpriteSceneComponent","PickingInfo","Texture","SceneComponentConstants","Logger","Tools","WebRequest","SpriteRenderer","EngineStore","name","imgUrl","capacity","cellSize","scene","epsilon","samplingMode","fromPacked","spriteJSON","TRILINEAR_SAMPLINGMODE","Array","sprite","baseSize","cellRef","cellIndex","num","isFinite","Math","floor","_this","_spriteMap","_xOffset","_cellData","frame","x","width","_yOffset","y","height","_xSize","w","_ySize","h","LastCreatedScene","_getComponent","NAME_SPRITE","_addComponent","_fromPacked","_scene","engine","getEngine","_spriteRenderer","cellWidth","cellHeight","undefined","spriteManagers","push","uniqueId","getUniqueId","texture","_makePacked","Object","SpriteManager","callback","_onDisposeObserver","onDisposeObservable","remove","add","sprites","value","wrapU","CLAMP_ADDRESSMODE","wrapV","_textureContent","fogEnabled","blendMode","_disableDepthWrite","disableDepthWrite","celldata","JSON","parse","frames","length","frametemp","i","_f","keys","Error","name_1","spritemap","Reflect","ownKeys","_packedAndReady","e","re","li","lastIndex","test","jsonUrl","substring","onerror_1","onload_1","data","LoadFile","ray","distance","min","max","useAlphaForPicking","textureSize","getSize","Uint8Array","readPixels","contactPoint","copyFrom","direction","normalize","scaleInPlace","addInPlace","origin","contactPointU","contactPointV","angle","rotatedU","cos","sin","rotatedV","u","v","alpha","camera","predicate","fastCheck","count","Zero","Number","MAX_VALUE","currentSprite","pickedPoint","cameraSpacePosition","cameraView","getViewMatrix","activeRay","pickedRay","index","isPickable","TransformCoordinatesToRef","position","TranslationToRef","RotationZToRef","multiplyToRef","clone","TransformNormalToRef","copyFromFloats","z","intersectsBoxMinMax","currentDistance","Distance","_checkTextureAlpha","result","invertToRef","hit","pickedSprite","addToRef","TransformCoordinates","results","deltaTime","getDeltaTime","render","getProjectionMatrix","_customUpdate","_a","rebuild","dispose","indexOf","splice","notifyObservers","clear","serializeTexture","serializationObject","serialize","textureUrl","invertY","_invertY","_i","parsedManager","rootUrl","manager","Parse","textureName","parsedSprite","url","Promise","resolve","reject","request","addEventListener","readyState","status","responseText","output","open","send","snippetId","snippet","jsonPayload","spriteManager","SnippetUrl","replace"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Sprites/spriteManager.ts"],"sourcesContent":["import type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { SpriteRenderer } from \"./spriteRenderer\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\r\ndeclare const Reflect: any;\r\n\r\n/**\r\n * Defines the minimum interface to fulfill in order to be a sprite manager.\r\n */\r\nexport interface ISpriteManager extends IDisposable {\r\n    /**\r\n     * Gets manager's name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    isPickable: boolean;\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Defines the list of sprites managed by the manager.\r\n     */\r\n    sprites: Array<Sprite>;\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    texture: Texture;\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    cellWidth: number;\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    cellHeight: number;\r\n\r\n    /**\r\n     * Tests the intersection of a sprite with a specific ray.\r\n     * @param ray The ray we are sending to test the collision\r\n     * @param camera The camera space we are sending rays in\r\n     * @param predicate A predicate allowing excluding sprites from the list of object to test\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info or null.\r\n     */\r\n    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;\r\n\r\n    /**\r\n     * Renders the list of sprites on screen.\r\n     */\r\n    render(): void;\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    rebuild(): void;\r\n}\r\n\r\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/babylon101/sprites\r\n */\r\nexport class SpriteManager implements ISpriteManager {\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the manager was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Gets the list of sprites */\r\n    public sprites = new Array<Sprite>();\r\n    /** Gets or sets the rendering group id (0 by default) */\r\n    public renderingGroupId = 0;\r\n    /** Gets or sets camera layer mask */\r\n    public layerMask: number = 0x0fffffff;\r\n    /** Gets or sets a boolean indicating if the sprites are pickable */\r\n    public isPickable = false;\r\n\r\n    /**\r\n     * An event triggered when the manager is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<SpriteManager>();\r\n\r\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the array of sprites\r\n     */\r\n    public get children() {\r\n        return this.sprites;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._spriteRenderer.capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    public get texture(): Texture {\r\n        return this._spriteRenderer.texture as Texture;\r\n    }\r\n    public set texture(value: Texture) {\r\n        value.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        value.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._spriteRenderer.texture = value;\r\n        this._textureContent = null;\r\n    }\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    public get cellWidth(): number {\r\n        return this._spriteRenderer.cellWidth;\r\n    }\r\n    public set cellWidth(value: number) {\r\n        this._spriteRenderer.cellWidth = value;\r\n    }\r\n\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    public get cellHeight(): number {\r\n        return this._spriteRenderer.cellHeight;\r\n    }\r\n    public set cellHeight(value: number) {\r\n        this._spriteRenderer.cellHeight = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\r\n    public get fogEnabled(): boolean {\r\n        return this._spriteRenderer.fogEnabled;\r\n    }\r\n    public set fogEnabled(value: boolean) {\r\n        this._spriteRenderer.fogEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public get blendMode() {\r\n        return this._spriteRenderer.blendMode;\r\n    }\r\n    public set blendMode(blendMode: number) {\r\n        this._spriteRenderer.blendMode = blendMode;\r\n    }\r\n\r\n    private _disableDepthWrite: boolean = false;\r\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n     */\r\n    public get disableDepthWrite() {\r\n        return this._disableDepthWrite;\r\n    }\r\n\r\n    public set disableDepthWrite(value: boolean) {\r\n        this._disableDepthWrite = value;\r\n        this._spriteRenderer.disableDepthWrite = value;\r\n    }\r\n\r\n    private _spriteRenderer: SpriteRenderer;\r\n    /** Associative array from JSON sprite data file */\r\n    private _cellData: any;\r\n    /** Array of sprite names from JSON sprite data file */\r\n    private _spriteMap: Array<string>;\r\n    /** True when packed cell data from JSON file is ready*/\r\n    private _packedAndReady: boolean = false;\r\n    private _textureContent: Nullable<Uint8Array>;\r\n    private _onDisposeObserver: Nullable<Observer<SpriteManager>>;\r\n    private _fromPacked: boolean;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new sprite manager\r\n     * @param name defines the manager's name\r\n     * @param imgUrl defines the sprite sheet url\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param cellSize defines the size of a sprite cell\r\n     * @param scene defines the hosting scene\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param samplingMode defines the sampling mode to use with spritesheet\r\n     * @param fromPacked set to false; do not alter\r\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n     */\r\n    constructor(\r\n        /** defines the manager's name */\r\n        public name: string,\r\n        imgUrl: string,\r\n        capacity: number,\r\n        cellSize: any,\r\n        scene: Scene,\r\n        epsilon: number = 0.01,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        fromPacked: boolean = false,\r\n        spriteJSON: any | null = null\r\n    ) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene!;\r\n        }\r\n\r\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\r\n            scene._addComponent(new SpriteSceneComponent(scene));\r\n        }\r\n        this._fromPacked = fromPacked;\r\n\r\n        this._scene = scene;\r\n        const engine = this._scene.getEngine();\r\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\r\n\r\n        if (cellSize.width && cellSize.height) {\r\n            this.cellWidth = cellSize.width;\r\n            this.cellHeight = cellSize.height;\r\n        } else if (cellSize !== undefined) {\r\n            this.cellWidth = cellSize;\r\n            this.cellHeight = cellSize;\r\n        } else {\r\n            this._spriteRenderer = <any>null;\r\n            return;\r\n        }\r\n\r\n        this._scene.spriteManagers.push(this);\r\n        this.uniqueId = this.scene.getUniqueId();\r\n\r\n        if (imgUrl) {\r\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\r\n        }\r\n\r\n        if (this._fromPacked) {\r\n            this._makePacked(imgUrl, spriteJSON);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpriteManager\"\r\n     * @returns \"SpriteManager\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"SpriteManager\";\r\n    }\r\n\r\n    private _makePacked(imgUrl: string, spriteJSON: any) {\r\n        if (spriteJSON !== null) {\r\n            try {\r\n                //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\r\n                let celldata: any;\r\n                if (typeof spriteJSON === \"string\") {\r\n                    celldata = JSON.parse(spriteJSON);\r\n                } else {\r\n                    celldata = spriteJSON;\r\n                }\r\n\r\n                if (celldata.frames.length) {\r\n                    const frametemp: any = {};\r\n                    for (let i = 0; i < celldata.frames.length; i++) {\r\n                        const _f = celldata.frames[i];\r\n                        if (typeof Object.keys(_f)[0] !== \"string\") {\r\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\r\n                        }\r\n\r\n                        const name: string = _f[Object.keys(_f)[0]];\r\n                        frametemp[name] = _f;\r\n                    }\r\n                    celldata.frames = frametemp;\r\n                }\r\n\r\n                const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n\r\n                this._spriteMap = spritemap;\r\n                this._packedAndReady = true;\r\n                this._cellData = celldata.frames;\r\n            } catch (e) {\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\r\n            }\r\n        } else {\r\n            const re = /\\./g;\r\n            let li: number;\r\n            do {\r\n                li = re.lastIndex;\r\n                re.test(imgUrl);\r\n            } while (re.lastIndex > 0);\r\n            const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\r\n            const onerror = () => {\r\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n            };\r\n            const onload = (data: string | ArrayBuffer) => {\r\n                try {\r\n                    const celldata = JSON.parse(data as string);\r\n                    const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n                    this._spriteMap = spritemap;\r\n                    this._packedAndReady = true;\r\n                    this._cellData = celldata.frames;\r\n                } catch (e) {\r\n                    this._fromPacked = false;\r\n                    this._packedAndReady = false;\r\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\r\n                }\r\n            };\r\n            Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\r\n        }\r\n    }\r\n\r\n    private _checkTextureAlpha(sprite: Sprite, ray: Ray, distance: number, min: Vector3, max: Vector3) {\r\n        if (!sprite.useAlphaForPicking || !this.texture) {\r\n            return true;\r\n        }\r\n\r\n        const textureSize = this.texture.getSize();\r\n        if (!this._textureContent) {\r\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\r\n            this.texture.readPixels(0, 0, this._textureContent);\r\n        }\r\n\r\n        const contactPoint = TmpVectors.Vector3[0];\r\n\r\n        contactPoint.copyFrom(ray.direction);\r\n\r\n        contactPoint.normalize();\r\n        contactPoint.scaleInPlace(distance);\r\n        contactPoint.addInPlace(ray.origin);\r\n\r\n        const contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\r\n        const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;\r\n\r\n        // Rotate\r\n        const angle = sprite.angle;\r\n        const rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\r\n        const rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\r\n\r\n        const u = (sprite._xOffset * textureSize.width + rotatedU * sprite._xSize) | 0;\r\n        const v = (sprite._yOffset * textureSize.height + rotatedV * sprite._ySize) | 0;\r\n\r\n        const alpha = this._textureContent![(u + v * textureSize.width) * 4 + 3];\r\n\r\n        return alpha > 0.5;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n     * @returns null if no hit or a PickingInfo\r\n     */\r\n    public intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance = Number.MAX_VALUE;\r\n        let currentSprite: Nullable<Sprite> = null;\r\n        const pickedPoint = TmpVectors.Vector3[0];\r\n        const cameraSpacePosition = TmpVectors.Vector3[1];\r\n        const cameraView = camera.getViewMatrix();\r\n        let activeRay: Ray = ray;\r\n        let pickedRay: Ray = ray;\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            if (sprite.angle) {\r\n                // Create a rotation matrix to rotate the ray to the sprite's rotation\r\n                Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\r\n                Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\r\n                Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);\r\n\r\n                // inv translation x rotation x translation\r\n                TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\r\n                TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\r\n\r\n                activeRay = ray.clone();\r\n                Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\r\n                Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\r\n            } else {\r\n                activeRay = ray;\r\n            }\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (activeRay.intersectsBoxMinMax(min, max)) {\r\n                const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\r\n\r\n                if (distance > currentDistance) {\r\n                    if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\r\n                        continue;\r\n                    }\r\n\r\n                    pickedRay = activeRay;\r\n                    distance = currentDistance;\r\n                    currentSprite = sprite;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentSprite) {\r\n            const result = new PickingInfo();\r\n\r\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n            result.hit = true;\r\n            result.pickedSprite = currentSprite;\r\n            result.distance = distance;\r\n\r\n            // Get picked point\r\n            const direction = TmpVectors.Vector3[2];\r\n            direction.copyFrom(pickedRay.direction);\r\n            direction.normalize();\r\n            direction.scaleInPlace(distance);\r\n\r\n            pickedRay.origin.addToRef(direction, pickedPoint);\r\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    public multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance: number;\r\n        const results: Nullable<PickingInfo[]> = [];\r\n        const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\r\n        const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\r\n        const cameraView = camera.getViewMatrix();\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\r\n                    continue;\r\n                }\r\n\r\n                const result = new PickingInfo();\r\n                results.push(result);\r\n\r\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n                result.hit = true;\r\n                result.pickedSprite = sprite;\r\n                result.distance = distance;\r\n\r\n                // Get picked point\r\n                const direction = TmpVectors.Vector3[2];\r\n                direction.copyFrom(ray.direction);\r\n                direction.normalize();\r\n                direction.scaleInPlace(distance);\r\n\r\n                ray.origin.addToRef(direction, pickedPoint);\r\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     */\r\n    public render(): void {\r\n        // Check\r\n        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const deltaTime = engine.getDeltaTime();\r\n        if (this._packedAndReady) {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\r\n        } else {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\r\n        }\r\n    }\r\n\r\n    private _customUpdate = (sprite: ThinSprite, baseSize: ISize): void => {\r\n        if (!sprite.cellRef) {\r\n            sprite.cellIndex = 0;\r\n        }\r\n        const num = sprite.cellIndex;\r\n        if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\r\n            sprite.cellRef = this._spriteMap[sprite.cellIndex];\r\n        }\r\n        sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\r\n        sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\r\n        sprite._xSize = this._cellData[sprite.cellRef].frame.w;\r\n        sprite._ySize = this._cellData[sprite.cellRef].frame.h;\r\n    };\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        this._spriteRenderer?.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._spriteRenderer) {\r\n            this._spriteRenderer.dispose();\r\n            (<any>this._spriteRenderer) = null;\r\n        }\r\n\r\n        this._textureContent = null;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.spriteManagers.indexOf(this);\r\n        this._scene.spriteManagers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite manager to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.capacity = this.capacity;\r\n        serializationObject.cellWidth = this.cellWidth;\r\n        serializationObject.cellHeight = this.cellHeight;\r\n\r\n        if (this.texture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = this.texture.serialize();\r\n            } else {\r\n                serializationObject.textureUrl = this.texture.name;\r\n                serializationObject.invertY = this.texture._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.sprites = [];\r\n\r\n        for (const sprite of this.sprites) {\r\n            serializationObject.sprites.push(sprite.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite manager.\r\n     * @param parsedManager The JSON object to parse\r\n     * @param scene The scene to create the sprite manager\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @returns the new sprite manager\r\n     */\r\n    public static Parse(parsedManager: any, scene: Scene, rootUrl: string): SpriteManager {\r\n        const manager = new SpriteManager(\r\n            parsedManager.name,\r\n            \"\",\r\n            parsedManager.capacity,\r\n            {\r\n                width: parsedManager.cellWidth,\r\n                height: parsedManager.cellHeight,\r\n            },\r\n            scene\r\n        );\r\n\r\n        if (parsedManager.texture) {\r\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl) as Texture;\r\n        } else if (parsedManager.textureName) {\r\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\r\n        }\r\n\r\n        for (const parsedSprite of parsedManager.sprites) {\r\n            Sprite.Parse(parsedSprite, manager);\r\n        }\r\n\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved in a remote file\r\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the sprite manager\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.spriteManager);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}