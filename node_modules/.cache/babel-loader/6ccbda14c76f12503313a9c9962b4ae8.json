{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport \"../Shaders/kernelBlur.fragment.js\";\nimport \"../Shaders/kernelBlur.vertex.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators.js\";\n/**\n * The Blur Post Process which blurs an image based on a kernel and direction.\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\n */\n\nvar BlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(BlurPostProcess, _super);\n  /**\n   * Creates a new instance BlurPostProcess\n   * @param name The name of the effect.\n   * @param direction The direction in which to blur the image.\n   * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param defines\n   * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   */\n\n\n  function BlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable, textureType, defines, _blockCompilation) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (defines === void 0) {\n      defines = \"\";\n    }\n\n    if (_blockCompilation === void 0) {\n      _blockCompilation = false;\n    }\n\n    var _this = _super.call(this, name, \"kernelBlur\", [\"delta\", \"direction\", \"cameraMinMaxZ\"], [\"circleOfConfusionSampler\"], options, camera, samplingMode, engine, reusable, null, textureType, \"kernelBlur\", {\n      varyingCount: 0,\n      depCount: 0\n    }, true) || this;\n\n    _this._blockCompilation = _blockCompilation;\n    _this._packedFloat = false;\n    _this._staticDefines = \"\";\n    _this._staticDefines = defines;\n    _this.direction = direction;\n\n    _this.onApplyObservable.add(function (effect) {\n      if (_this._outputTexture) {\n        effect.setFloat2(\"delta\", 1 / _this._outputTexture.width * _this.direction.x, 1 / _this._outputTexture.height * _this.direction.y);\n      } else {\n        effect.setFloat2(\"delta\", 1 / _this.width * _this.direction.x, 1 / _this.height * _this.direction.y);\n      }\n    });\n\n    _this.kernel = kernel;\n    return _this;\n  }\n\n  Object.defineProperty(BlurPostProcess.prototype, \"kernel\", {\n    /**\n     * Gets the length in pixels of the blur sample region\n     */\n    get: function get() {\n      return this._idealKernel;\n    },\n\n    /**\n     * Sets the length in pixels of the blur sample region\n     */\n    set: function set(v) {\n      if (this._idealKernel === v) {\n        return;\n      }\n\n      v = Math.max(v, 1);\n      this._idealKernel = v;\n      this._kernel = this._nearestBestKernel(v);\n\n      if (!this._blockCompilation) {\n        this._updateParameters();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurPostProcess.prototype, \"packedFloat\", {\n    /**\n     * Gets whether or not the blur is unpacking/repacking floats\n     */\n    get: function get() {\n      return this._packedFloat;\n    },\n\n    /**\n     * Sets whether or not the blur needs to unpack/repack floats\n     */\n    set: function set(v) {\n      if (this._packedFloat === v) {\n        return;\n      }\n\n      this._packedFloat = v;\n\n      if (!this._blockCompilation) {\n        this._updateParameters();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"BlurPostProcess\" string\n   */\n\n  BlurPostProcess.prototype.getClassName = function () {\n    return \"BlurPostProcess\";\n  };\n  /**\n   * Updates the effect with the current post process compile time values and recompiles the shader.\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param onCompiled Called when the shader has been compiled.\n   * @param onError Called if there is an error when compiling a shader.\n   */\n\n\n  BlurPostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (uniforms === void 0) {\n      uniforms = null;\n    }\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    this._updateParameters(onCompiled, onError);\n  };\n\n  BlurPostProcess.prototype._updateParameters = function (onCompiled, onError) {\n    // Generate sampling offsets and weights\n    var N = this._kernel;\n    var centerIndex = (N - 1) / 2; // Generate Gaussian sampling weights over kernel\n\n    var offsets = [];\n    var weights = [];\n    var totalWeight = 0;\n\n    for (var i = 0; i < N; i++) {\n      var u = i / (N - 1);\n\n      var w = this._gaussianWeight(u * 2.0 - 1);\n\n      offsets[i] = i - centerIndex;\n      weights[i] = w;\n      totalWeight += w;\n    } // Normalize weights\n\n\n    for (var i = 0; i < weights.length; i++) {\n      weights[i] /= totalWeight;\n    } // Optimize: combine samples to take advantage of hardware linear sampling\n    // Walk from left to center, combining pairs (symmetrically)\n\n\n    var linearSamplingWeights = [];\n    var linearSamplingOffsets = [];\n    var linearSamplingMap = [];\n\n    for (var i = 0; i <= centerIndex; i += 2) {\n      var j = Math.min(i + 1, Math.floor(centerIndex));\n      var singleCenterSample = i === j;\n\n      if (singleCenterSample) {\n        linearSamplingMap.push({\n          o: offsets[i],\n          w: weights[i]\n        });\n      } else {\n        var sharedCell = j === centerIndex;\n        var weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\n        var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\n\n        if (offsetLinear === 0) {\n          linearSamplingMap.push({\n            o: offsets[i],\n            w: weights[i]\n          });\n          linearSamplingMap.push({\n            o: offsets[i + 1],\n            w: weights[i + 1]\n          });\n        } else {\n          linearSamplingMap.push({\n            o: offsetLinear,\n            w: weightLinear\n          });\n          linearSamplingMap.push({\n            o: -offsetLinear,\n            w: weightLinear\n          });\n        }\n      }\n    }\n\n    for (var i = 0; i < linearSamplingMap.length; i++) {\n      linearSamplingOffsets[i] = linearSamplingMap[i].o;\n      linearSamplingWeights[i] = linearSamplingMap[i].w;\n    } // Replace with optimized\n\n\n    offsets = linearSamplingOffsets;\n    weights = linearSamplingWeights; // Generate shaders\n\n    var maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\n    var freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\n\n    var varyingCount = Math.min(offsets.length, freeVaryingVec2);\n    var defines = \"\";\n    defines += this._staticDefines; // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\n\n    if (this._staticDefines.indexOf(\"DOF\") != -1) {\n      defines += \"#define CENTER_WEIGHT \".concat(this._glslFloat(weights[varyingCount - 1]), \"\\r\\n\");\n      varyingCount--;\n    }\n\n    for (var i = 0; i < varyingCount; i++) {\n      defines += \"#define KERNEL_OFFSET\".concat(i, \" \").concat(this._glslFloat(offsets[i]), \"\\r\\n\");\n      defines += \"#define KERNEL_WEIGHT\".concat(i, \" \").concat(this._glslFloat(weights[i]), \"\\r\\n\");\n    }\n\n    var depCount = 0;\n\n    for (var i = freeVaryingVec2; i < offsets.length; i++) {\n      defines += \"#define KERNEL_DEP_OFFSET\".concat(depCount, \" \").concat(this._glslFloat(offsets[i]), \"\\r\\n\");\n      defines += \"#define KERNEL_DEP_WEIGHT\".concat(depCount, \" \").concat(this._glslFloat(weights[i]), \"\\r\\n\");\n      depCount++;\n    }\n\n    if (this.packedFloat) {\n      defines += \"#define PACKEDFLOAT 1\";\n    }\n\n    this._blockCompilation = false;\n\n    _super.prototype.updateEffect.call(this, defines, null, null, {\n      varyingCount: varyingCount,\n      depCount: depCount\n    }, onCompiled, onError);\n  };\n  /**\n   * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\n   * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\n   * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\n   * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\n   * The gaps between physical kernels are compensated for in the weighting of the samples\n   * @param idealKernel Ideal blur kernel.\n   * @return Nearest best kernel.\n   */\n\n\n  BlurPostProcess.prototype._nearestBestKernel = function (idealKernel) {\n    var v = Math.round(idealKernel);\n\n    for (var _i = 0, _a = [v, v - 1, v + 1, v - 2, v + 2]; _i < _a.length; _i++) {\n      var k = _a[_i];\n\n      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\n        return Math.max(k, 3);\n      }\n    }\n\n    return Math.max(v, 3);\n  };\n  /**\n   * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\n   * @param x The point on the Gaussian distribution to sample.\n   * @return the value of the Gaussian function at x.\n   */\n\n\n  BlurPostProcess.prototype._gaussianWeight = function (x) {\n    //reference: Engines/ImageProcessingBlur.cpp #dcc760\n    // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\n    // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\n    // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\n    // truncated at around 1.3% of peak strength.\n    //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\n    var sigma = 1 / 3;\n    var denominator = Math.sqrt(2.0 * Math.PI) * sigma;\n    var exponent = -(x * x / (2.0 * sigma * sigma));\n    var weight = 1.0 / denominator * Math.exp(exponent);\n    return weight;\n  };\n  /**\n   * Generates a string that can be used as a floating point number in GLSL.\n   * @param x Value to print.\n   * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\n   * @return GLSL float string.\n   */\n\n\n  BlurPostProcess.prototype._glslFloat = function (x, decimalFigures) {\n    if (decimalFigures === void 0) {\n      decimalFigures = 8;\n    }\n\n    return x.toFixed(decimalFigures).replace(/0+$/, \"\");\n  };\n  /**\n   * @param parsedPostProcess\n   * @param targetCamera\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  BlurPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, undefined, false);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize(\"kernel\")], BlurPostProcess.prototype, \"_kernel\", void 0);\n\n  __decorate([serialize(\"packedFloat\")], BlurPostProcess.prototype, \"_packedFloat\", void 0);\n\n  __decorate([serializeAsVector2()], BlurPostProcess.prototype, \"direction\", void 0);\n\n  return BlurPostProcess;\n}(PostProcess);\n\nexport { BlurPostProcess };\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);","map":{"version":3,"mappings":"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","names":["PostProcess","Texture","RegisterClass","serialize","serializeAsVector2","SerializationHelper","__extends","name","direction","kernel","options","camera","samplingMode","engine","reusable","textureType","defines","_blockCompilation","BILINEAR_SAMPLINGMODE","_super","varyingCount","depCount","_this","_staticDefines","onApplyObservable","add","effect","_outputTexture","setFloat2","width","x","height","y","Object","BlurPostProcess","_idealKernel","v","Math","max","_kernel","_nearestBestKernel","_updateParameters","_packedFloat","uniforms","samplers","indexParameters","onCompiled","onError","N","centerIndex","offsets","weights","totalWeight","i","u","w","_gaussianWeight","length","linearSamplingWeights","linearSamplingOffsets","linearSamplingMap","j","min","floor","singleCenterSample","push","o","sharedCell","weightLinear","offsetLinear","maxVaryingRows","getEngine","getCaps","maxVaryingVectors","freeVaryingVec2","indexOf","_glslFloat","concat","packedFloat","updateEffect","call","idealKernel","round","_i","k","sigma","denominator","sqrt","PI","exponent","weight","exp","decimalFigures","toFixed","replace","parsedPostProcess","targetCamera","scene","rootUrl","Parse","renderTargetSamplingMode","undefined","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/blurPostProcess.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/kernelBlur.fragment\";\r\nimport \"../Shaders/kernelBlur.vertex\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    @serialize(\"kernel\")\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    @serialize(\"packedFloat\")\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        defines = \"\",\r\n        private _blockCompilation = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"kernelBlur\",\r\n            [\"delta\", \"direction\", \"cameraMinMaxZ\"],\r\n            [\"circleOfConfusionSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            \"kernelBlur\",\r\n            { varyingCount: 0, depCount: 0 },\r\n            true\r\n        );\r\n        this._staticDefines = defines;\r\n        this.direction = direction;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (this._outputTexture) {\r\n                effect.setFloat2(\"delta\", (1 / this._outputTexture.width) * this.direction.x, (1 / this._outputTexture.height) * this.direction.y);\r\n            } else {\r\n                effect.setFloat2(\"delta\", (1 / this.width) * this.direction.x, (1 / this.height) * this.direction.y);\r\n            }\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    protected _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\r\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\r\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\r\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\r\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\r\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this._blockCompilation = false;\r\n        super.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @return Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @return the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @return GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n\r\n    /**\r\n     * @param parsedPostProcess\r\n     * @param targetCamera\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n"]},"metadata":{},"sourceType":"module"}