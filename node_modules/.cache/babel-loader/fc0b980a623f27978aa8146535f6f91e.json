{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * A behavior that when attached to a mesh will follow a camera\n * @since 5.0.0\n */\n\nvar FollowBehavior =\n/** @class */\nfunction () {\n  function FollowBehavior() {\n    // Memory cache to avoid GC usage\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n    this._tmpMatrix = new Matrix();\n    this._tmpInvertView = new Matrix();\n    this._tmpForward = new Vector3();\n    this._tmpNodeForward = new Vector3();\n    this._tmpPosition = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._recenterNextUpdate = true;\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n\n    this.lerpTime = 500;\n    /**\n     * If the behavior should ignore the pitch and roll of the camera.\n     */\n\n    this.ignoreCameraPitchAndRoll = false;\n    /**\n     * Pitch offset from camera (relative to Max Distance)\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\n     */\n\n    this.pitchOffset = 15;\n    /**\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\n     */\n\n    this.maxViewVerticalDegrees = 30;\n    /**\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\n     */\n\n    this.maxViewHorizontalDegrees = 30;\n    /**\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\n     */\n\n    this.orientToCameraDeadzoneDegrees = 60;\n    /**\n     * Option to ignore distance clamping\n     */\n\n    this.ignoreDistanceClamp = false;\n    /**\n     * Option to ignore angle clamping\n     */\n\n    this.ignoreAngleClamp = false;\n    /**\n     * Max vertical distance between the attachedNode and camera\n     */\n\n    this.verticalMaxDistance = 0;\n    /**\n     *  Default distance from eye to attached node, i.e. the sphere radius\n     */\n\n    this.defaultDistance = 0.8;\n    /**\n     *  Max distance from eye to attached node, i.e. the sphere radius\n     */\n\n    this.maximumDistance = 2;\n    /**\n     *  Min distance from eye to attached node, i.e. the sphere radius\n     */\n\n    this.minimumDistance = 0.3;\n    /**\n     * Ignore vertical movement and lock the Y position of the object.\n     */\n\n    this.useFixedVerticalOffset = false;\n    /**\n     * Fixed vertical position offset distance.\n     */\n\n    this.fixedVerticalOffset = 0;\n    /**\n     * Enables/disables the behavior\n     * @hidden\n     */\n\n    this._enabled = true;\n  }\n\n  Object.defineProperty(FollowBehavior.prototype, \"followedCamera\", {\n    /**\n     * The camera that should be followed by this behavior\n     */\n    get: function get() {\n      return this._followedCamera || this._scene.activeCamera;\n    },\n    set: function set(camera) {\n      this._followedCamera = camera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FollowBehavior.prototype, \"name\", {\n    /**\n     *  The name of the behavior\n     */\n    get: function get() {\n      return \"Follow\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   *  Initializes the behavior\n   */\n\n  FollowBehavior.prototype.init = function () {};\n  /**\n   * Attaches the follow behavior\n   * @param ownerNode The mesh that will be following once attached\n   * @param followedCamera The camera that should be followed by the node\n   */\n\n\n  FollowBehavior.prototype.attach = function (ownerNode, followedCamera) {\n    this._scene = ownerNode.getScene();\n    this.attachedNode = ownerNode;\n\n    if (followedCamera) {\n      this.followedCamera = followedCamera;\n    }\n\n    this._addObservables();\n  };\n  /**\n   *  Detaches the behavior from the mesh\n   */\n\n\n  FollowBehavior.prototype.detach = function () {\n    this.attachedNode = null;\n\n    this._removeObservables();\n  };\n  /**\n   * Recenters the attached node in front of the camera on the next update\n   */\n\n\n  FollowBehavior.prototype.recenter = function () {\n    this._recenterNextUpdate = true;\n  };\n\n  FollowBehavior.prototype._angleBetweenVectorAndPlane = function (vector, normal) {\n    // Work on copies\n    this._tmpVectors[0].copyFrom(vector);\n\n    vector = this._tmpVectors[0];\n\n    this._tmpVectors[1].copyFrom(normal);\n\n    normal = this._tmpVectors[1];\n    vector.normalize();\n    normal.normalize();\n    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\n  };\n\n  FollowBehavior.prototype._length2D = function (vector) {\n    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\n  };\n\n  FollowBehavior.prototype._distanceClamp = function (currentToTarget, moveToDefault) {\n    if (moveToDefault === void 0) {\n      moveToDefault = false;\n    }\n\n    var minDistance = this.minimumDistance;\n    var maxDistance = this.maximumDistance;\n    var defaultDistance = this.defaultDistance;\n    var direction = this._tmpVectors[0];\n    direction.copyFrom(currentToTarget);\n    var currentDistance = direction.length();\n    direction.normalizeFromLength(currentDistance);\n\n    if (this.ignoreCameraPitchAndRoll) {\n      // If we don't account for pitch offset, the casted object will float up/down as the reference\n      // gets closer to it because we will still be casting in the direction of the pitched offset.\n      // To fix this, only modify the XZ position of the object.\n      minDistance = this._length2D(direction) * minDistance;\n      maxDistance = this._length2D(direction) * maxDistance;\n\n      var currentDistance2D = this._length2D(currentToTarget);\n\n      direction.scaleInPlace(currentDistance / currentDistance2D);\n      currentDistance = currentDistance2D;\n    }\n\n    var clampedDistance = currentDistance;\n\n    if (moveToDefault) {\n      clampedDistance = defaultDistance;\n    } else {\n      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\n    }\n\n    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\n    return currentDistance !== clampedDistance;\n  };\n\n  FollowBehavior.prototype._applyVerticalClamp = function (currentToTarget) {\n    if (this.verticalMaxDistance !== 0) {\n      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\n    }\n  };\n\n  FollowBehavior.prototype._toOrientationQuatToRef = function (vector, quaternion) {\n    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\n  };\n\n  FollowBehavior.prototype._applyPitchOffset = function (invertView) {\n    var forward = this._tmpVectors[0];\n    var right = this._tmpVectors[1];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    right.copyFromFloats(1, 0, 0);\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    forward.y = 0;\n    forward.normalize();\n    Vector3.TransformNormalToRef(right, invertView, right);\n    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);\n    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\n\n    this._toOrientationQuatToRef(forward, this._tmpQuaternion);\n\n    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix); // Since we already extracted position from the invert view matrix, we can\n    // disregard the position part of the matrix in the copy\n\n\n    invertView.copyFrom(this._tmpMatrix);\n  };\n\n  FollowBehavior.prototype._angularClamp = function (invertView, currentToTarget) {\n    var forward = this._tmpVectors[5];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    var right = this._tmpVectors[6];\n    right.copyFromFloats(1, 0, 0); // forward and right are related to camera frame of reference\n\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    Vector3.TransformNormalToRef(right, invertView, right); // Up is global Z\n\n    var up = Vector3.UpReadOnly;\n    var dist = currentToTarget.length();\n\n    if (dist < Epsilon) {\n      return false;\n    }\n\n    var angularClamped = false;\n    var rotationQuat = this._tmpQuaternion; // X-axis leashing\n\n    if (this.ignoreCameraPitchAndRoll) {\n      var angle_1 = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      Quaternion.RotationAxisToRef(right, angle_1, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n    } else {\n      var angle_2 = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      var minMaxAngle_1 = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;\n\n      if (angle_2 < -minMaxAngle_1) {\n        Quaternion.RotationAxisToRef(right, -angle_2 - minMaxAngle_1, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      } else if (angle_2 > minMaxAngle_1) {\n        Quaternion.RotationAxisToRef(right, -angle_2 + minMaxAngle_1, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      }\n    } // Y-axis leashing\n\n\n    var angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\n    var minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;\n\n    if (angle < -minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    } else if (angle > minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    }\n\n    return angularClamped;\n  };\n\n  FollowBehavior.prototype._orientationClamp = function (currentToTarget, rotationQuaternion) {\n    var _a; // Construct a rotation quat from up vector and target vector\n\n\n    var toFollowed = this._tmpVectors[0];\n    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\n    var up = this._tmpVectors[1];\n    var right = this._tmpVectors[2]; // We use global up vector to orient the following node (global +Y)\n\n    up.copyFromFloats(0, 1, 0); // Gram-Schmidt to create an orthonormal frame\n\n    Vector3.CrossToRef(toFollowed, up, right);\n    var length = right.length();\n\n    if (length < Epsilon) {\n      return;\n    }\n\n    right.normalizeFromLength(length);\n    Vector3.CrossToRef(right, toFollowed, up);\n\n    if ((_a = this.attachedNode) === null || _a === void 0 ? void 0 : _a.getScene().useRightHandedSystem) {\n      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\n    } else {\n      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\n    }\n  };\n\n  FollowBehavior.prototype._passedOrientationDeadzone = function (currentToTarget, forward) {\n    var leashToFollow = this._tmpVectors[5];\n    leashToFollow.copyFrom(currentToTarget);\n    leashToFollow.normalize();\n    var angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\n    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;\n  };\n\n  FollowBehavior.prototype._updateLeashing = function (camera) {\n    if (this.attachedNode && this._enabled) {\n      var oldParent = this.attachedNode.parent;\n      this.attachedNode.setParent(null);\n      var worldMatrix = this.attachedNode.getWorldMatrix();\n      var currentToTarget = this._workingPosition;\n      var rotationQuaternion = this._workingQuaternion;\n      var pivot = this.attachedNode.getPivotPoint();\n      var invertView = this._tmpInvertView;\n      invertView.copyFrom(camera.getViewMatrix());\n      invertView.invert();\n      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\n      var position = this._tmpPosition;\n      position.copyFromFloats(0, 0, 0);\n      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\n      position.scaleInPlace(-1).subtractInPlace(pivot);\n      currentToTarget.subtractInPlace(camera.globalPosition);\n\n      if (this.ignoreCameraPitchAndRoll) {\n        this._applyPitchOffset(invertView);\n      }\n\n      var angularClamped = false;\n      var forward = this._tmpForward;\n      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(forward, invertView, forward);\n      var nodeForward = this._tmpNodeForward;\n      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\n\n      if (this._recenterNextUpdate) {\n        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\n      } else {\n        if (this.ignoreAngleClamp) {\n          var currentDistance = currentToTarget.length();\n          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\n        } else {\n          angularClamped = this._angularClamp(invertView, currentToTarget);\n        }\n      }\n\n      var distanceClamped = false;\n\n      if (!this.ignoreDistanceClamp) {\n        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\n\n        this._applyVerticalClamp(currentToTarget);\n      }\n\n      if (this.useFixedVerticalOffset) {\n        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\n      }\n\n      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\n        this._orientationClamp(currentToTarget, rotationQuaternion);\n      }\n\n      this._workingPosition.subtractInPlace(pivot);\n\n      this._recenterNextUpdate = false;\n      this.attachedNode.setParent(oldParent);\n    }\n  };\n\n  FollowBehavior.prototype._updateTransformToGoal = function (elapsed) {\n    if (!this.attachedNode || !this.followedCamera || !this._enabled) {\n      return;\n    }\n\n    if (!this.attachedNode.rotationQuaternion) {\n      this.attachedNode.rotationQuaternion = Quaternion.Identity();\n    }\n\n    var oldParent = this.attachedNode.parent;\n    this.attachedNode.setParent(null);\n\n    if (!this.interpolatePose) {\n      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\n      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    } // position\n\n\n    var currentDirection = new Vector3();\n    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\n    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\n    currentDirection.addInPlace(this.followedCamera.globalPosition);\n    this.attachedNode.position.copyFrom(currentDirection); // rotation\n\n    var currentRotation = new Quaternion();\n    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\n    this.attachedNode.setParent(oldParent);\n  };\n\n  FollowBehavior.prototype._addObservables = function () {\n    var _this = this;\n\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(function () {\n      if (!_this.followedCamera) {\n        return;\n      }\n\n      var tick = Date.now();\n\n      _this._updateLeashing(_this.followedCamera);\n\n      _this._updateTransformToGoal(tick - _this._lastTick);\n\n      _this._lastTick = tick;\n    });\n  };\n\n  FollowBehavior.prototype._removeObservables = function () {\n    if (this._onBeforeRender) {\n      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    }\n  };\n\n  return FollowBehavior;\n}();\n\nexport { FollowBehavior };","map":{"version":3,"mappings":"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","names":["Matrix","Quaternion","Vector3","Scalar","Epsilon","Object","FollowBehavior","_followedCamera","_scene","activeCamera","camera","ownerNode","followedCamera","getScene","attachedNode","_addObservables","_removeObservables","_recenterNextUpdate","vector","normal","_tmpVectors","copyFrom","normalize","Math","PI","acos","Dot","sqrt","x","z","currentToTarget","moveToDefault","minDistance","minimumDistance","maxDistance","maximumDistance","defaultDistance","direction","currentDistance","length","normalizeFromLength","ignoreCameraPitchAndRoll","_length2D","currentDistance2D","scaleInPlace","clampedDistance","Clamp","verticalMaxDistance","y","quaternion","RotationYawPitchRollToRef","atan2","invertView","forward","right","copyFromFloats","useRightHandedSystem","TransformNormalToRef","RotationAxisToRef","pitchOffset","_tmpQuaternion","rotateByQuaternionToRef","_toOrientationQuatToRef","toRotationMatrix","_tmpMatrix","up","UpReadOnly","dist","angularClamped","rotationQuat","angle_1","GetAngleBetweenVectorsOnPlane","angle_2","minMaxAngle_1","maxViewVerticalDegrees","angle","_angleBetweenVectorAndPlane","minMaxAngle","maxViewHorizontalDegrees","rotationQuaternion","toFollowed","CrossToRef","_a","FromLookDirectionRHToRef","FromLookDirectionLHToRef","leashToFollow","abs","orientToCameraDeadzoneDegrees","_enabled","oldParent","parent","setParent","worldMatrix","getWorldMatrix","_workingPosition","_workingQuaternion","pivot","getPivotPoint","_tmpInvertView","getViewMatrix","invert","TransformCoordinatesToRef","position","_tmpPosition","subtractInPlace","globalPosition","_applyPitchOffset","_tmpForward","nodeForward","_tmpNodeForward","ignoreAngleClamp","_angularClamp","distanceClamped","ignoreDistanceClamp","_distanceClamp","_applyVerticalClamp","useFixedVerticalOffset","fixedVerticalOffset","_passedOrientationDeadzone","_orientationClamp","elapsed","Identity","interpolatePose","addInPlace","currentDirection","SmoothToRef","lerpTime","currentRotation","_lastTick","Date","now","_onBeforeRender","onBeforeRenderObservable","add","_this","tick","_updateLeashing","_updateTransformToGoal","remove"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/followBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../behavior\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will follow a camera\r\n * @since 5.0.0\r\n */\r\nexport class FollowBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n\r\n    // Memory cache to avoid GC usage\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVectors: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n    private _tmpMatrix: Matrix = new Matrix();\r\n    private _tmpInvertView: Matrix = new Matrix();\r\n    private _tmpForward: Vector3 = new Vector3();\r\n    private _tmpNodeForward: Vector3 = new Vector3();\r\n    private _tmpPosition: Vector3 = new Vector3();\r\n\r\n    private _followedCamera: Nullable<Camera>;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _recenterNextUpdate = true;\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public attachedNode: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 500;\r\n\r\n    /**\r\n     * If the behavior should ignore the pitch and roll of the camera.\r\n     */\r\n    public ignoreCameraPitchAndRoll = false;\r\n\r\n    /**\r\n     * Pitch offset from camera (relative to Max Distance)\r\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\r\n     */\r\n    public pitchOffset = 15;\r\n\r\n    /**\r\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewVerticalDegrees = 30;\r\n\r\n    /**\r\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewHorizontalDegrees = 30;\r\n    /**\r\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\r\n     */\r\n    public orientToCameraDeadzoneDegrees = 60;\r\n    /**\r\n     * Option to ignore distance clamping\r\n     */\r\n    public ignoreDistanceClamp = false;\r\n    /**\r\n     * Option to ignore angle clamping\r\n     */\r\n    public ignoreAngleClamp = false;\r\n    /**\r\n     * Max vertical distance between the attachedNode and camera\r\n     */\r\n    public verticalMaxDistance = 0;\r\n    /**\r\n     *  Default distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public defaultDistance = 0.8;\r\n    /**\r\n     *  Max distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public maximumDistance = 2;\r\n    /**\r\n     *  Min distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public minimumDistance = 0.3;\r\n\r\n    /**\r\n     * Ignore vertical movement and lock the Y position of the object.\r\n     */\r\n    public useFixedVerticalOffset = false;\r\n\r\n    /**\r\n     * Fixed vertical position offset distance.\r\n     */\r\n    public fixedVerticalOffset = 0;\r\n\r\n    /**\r\n     * Enables/disables the behavior\r\n     * @hidden\r\n     */\r\n    public _enabled = true;\r\n\r\n    /**\r\n     * The camera that should be followed by this behavior\r\n     */\r\n    public get followedCamera(): Nullable<Camera> {\r\n        return this._followedCamera || this._scene.activeCamera;\r\n    }\r\n\r\n    public set followedCamera(camera: Nullable<Camera>) {\r\n        this._followedCamera = camera;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"Follow\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the follow behavior\r\n     * @param ownerNode The mesh that will be following once attached\r\n     * @param followedCamera The camera that should be followed by the node\r\n     */\r\n    public attach(ownerNode: TransformNode, followedCamera?: Camera): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        if (followedCamera) {\r\n            this.followedCamera = followedCamera;\r\n        }\r\n\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this.attachedNode = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    /**\r\n     * Recenters the attached node in front of the camera on the next update\r\n     */\r\n    public recenter() {\r\n        this._recenterNextUpdate = true;\r\n    }\r\n\r\n    private _angleBetweenVectorAndPlane(vector: Vector3, normal: Vector3) {\r\n        // Work on copies\r\n        this._tmpVectors[0].copyFrom(vector);\r\n        vector = this._tmpVectors[0];\r\n        this._tmpVectors[1].copyFrom(normal);\r\n        normal = this._tmpVectors[1];\r\n\r\n        vector.normalize();\r\n        normal.normalize();\r\n\r\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\r\n    }\r\n\r\n    private _length2D(vector: Vector3) {\r\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\r\n    }\r\n\r\n    private _distanceClamp(currentToTarget: Vector3, moveToDefault: boolean = false) {\r\n        let minDistance = this.minimumDistance;\r\n        let maxDistance = this.maximumDistance;\r\n        const defaultDistance = this.defaultDistance;\r\n\r\n        const direction = this._tmpVectors[0];\r\n        direction.copyFrom(currentToTarget);\r\n        let currentDistance = direction.length();\r\n        direction.normalizeFromLength(currentDistance);\r\n\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\r\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\r\n            // To fix this, only modify the XZ position of the object.\r\n            minDistance = this._length2D(direction) * minDistance;\r\n            maxDistance = this._length2D(direction) * maxDistance;\r\n\r\n            const currentDistance2D = this._length2D(currentToTarget);\r\n            direction.scaleInPlace(currentDistance / currentDistance2D);\r\n            currentDistance = currentDistance2D;\r\n        }\r\n\r\n        let clampedDistance = currentDistance;\r\n\r\n        if (moveToDefault) {\r\n            clampedDistance = defaultDistance;\r\n        } else {\r\n            clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\r\n        }\r\n\r\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\r\n\r\n        return currentDistance !== clampedDistance;\r\n    }\r\n\r\n    private _applyVerticalClamp(currentToTarget: Vector3) {\r\n        if (this.verticalMaxDistance !== 0) {\r\n            currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\r\n        }\r\n    }\r\n\r\n    private _toOrientationQuatToRef(vector: Vector3, quaternion: Quaternion) {\r\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\r\n    }\r\n\r\n    private _applyPitchOffset(invertView: Matrix) {\r\n        const forward = this._tmpVectors[0];\r\n        const right = this._tmpVectors[1];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        right.copyFromFloats(1, 0, 0);\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        forward.y = 0;\r\n        forward.normalize();\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\r\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\r\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\r\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\r\n\r\n        // Since we already extracted position from the invert view matrix, we can\r\n        // disregard the position part of the matrix in the copy\r\n        invertView.copyFrom(this._tmpMatrix);\r\n    }\r\n\r\n    private _angularClamp(invertView: Matrix, currentToTarget: Vector3): boolean {\r\n        const forward = this._tmpVectors[5];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        const right = this._tmpVectors[6];\r\n        right.copyFromFloats(1, 0, 0);\r\n\r\n        // forward and right are related to camera frame of reference\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        // Up is global Z\r\n        const up = Vector3.UpReadOnly;\r\n\r\n        const dist = currentToTarget.length();\r\n\r\n        if (dist < Epsilon) {\r\n            return false;\r\n        }\r\n\r\n        let angularClamped = false;\r\n        const rotationQuat = this._tmpQuaternion;\r\n\r\n        // X-axis leashing\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n        } else {\r\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\r\n            if (angle < -minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            } else if (angle > minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            }\r\n        }\r\n\r\n        // Y-axis leashing\r\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\r\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\r\n        if (angle < -minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        } else if (angle > minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        }\r\n\r\n        return angularClamped;\r\n    }\r\n\r\n    private _orientationClamp(currentToTarget: Vector3, rotationQuaternion: Quaternion) {\r\n        // Construct a rotation quat from up vector and target vector\r\n        const toFollowed = this._tmpVectors[0];\r\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\r\n\r\n        const up = this._tmpVectors[1];\r\n        const right = this._tmpVectors[2];\r\n        // We use global up vector to orient the following node (global +Y)\r\n        up.copyFromFloats(0, 1, 0);\r\n\r\n        // Gram-Schmidt to create an orthonormal frame\r\n        Vector3.CrossToRef(toFollowed, up, right);\r\n        const length = right.length();\r\n\r\n        if (length < Epsilon) {\r\n            return;\r\n        }\r\n\r\n        right.normalizeFromLength(length);\r\n\r\n        Vector3.CrossToRef(right, toFollowed, up);\r\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\r\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\r\n        } else {\r\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    private _passedOrientationDeadzone(currentToTarget: Vector3, forward: Vector3) {\r\n        const leashToFollow = this._tmpVectors[5];\r\n        leashToFollow.copyFrom(currentToTarget);\r\n        leashToFollow.normalize();\r\n\r\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\r\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\r\n    }\r\n\r\n    private _updateLeashing(camera: Camera) {\r\n        if (this.attachedNode && this._enabled) {\r\n            const oldParent = this.attachedNode.parent;\r\n            this.attachedNode.setParent(null);\r\n\r\n            const worldMatrix = this.attachedNode.getWorldMatrix();\r\n            const currentToTarget = this._workingPosition;\r\n            const rotationQuaternion = this._workingQuaternion;\r\n            const pivot = this.attachedNode.getPivotPoint();\r\n            const invertView = this._tmpInvertView;\r\n            invertView.copyFrom(camera.getViewMatrix());\r\n            invertView.invert();\r\n\r\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\r\n            const position = this._tmpPosition;\r\n            position.copyFromFloats(0, 0, 0);\r\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\r\n            position.scaleInPlace(-1).subtractInPlace(pivot);\r\n            currentToTarget.subtractInPlace(camera.globalPosition);\r\n\r\n            if (this.ignoreCameraPitchAndRoll) {\r\n                this._applyPitchOffset(invertView);\r\n            }\r\n\r\n            let angularClamped = false;\r\n            const forward = this._tmpForward;\r\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(forward, invertView, forward);\r\n\r\n            const nodeForward = this._tmpNodeForward;\r\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\r\n\r\n            if (this._recenterNextUpdate) {\r\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\r\n            } else {\r\n                if (this.ignoreAngleClamp) {\r\n                    const currentDistance = currentToTarget.length();\r\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\r\n                } else {\r\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\r\n                }\r\n            }\r\n\r\n            let distanceClamped = false;\r\n            if (!this.ignoreDistanceClamp) {\r\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\r\n                this._applyVerticalClamp(currentToTarget);\r\n            }\r\n\r\n            if (this.useFixedVerticalOffset) {\r\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\r\n            }\r\n\r\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\r\n                this._orientationClamp(currentToTarget, rotationQuaternion);\r\n            }\r\n\r\n            this._workingPosition.subtractInPlace(pivot);\r\n            this._recenterNextUpdate = false;\r\n\r\n            this.attachedNode.setParent(oldParent);\r\n        }\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (!this.attachedNode.rotationQuaternion) {\r\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n\r\n        const oldParent = this.attachedNode.parent;\r\n        this.attachedNode.setParent(null);\r\n\r\n        if (!this.interpolatePose) {\r\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\r\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const currentDirection = new Vector3();\r\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\r\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\r\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\r\n        this.attachedNode.position.copyFrom(currentDirection);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\r\n\r\n        this.attachedNode.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.followedCamera) {\r\n                return;\r\n            }\r\n\r\n            const tick = Date.now();\r\n            this._updateLeashing(this.followedCamera);\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        if (this._onBeforeRender) {\r\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}