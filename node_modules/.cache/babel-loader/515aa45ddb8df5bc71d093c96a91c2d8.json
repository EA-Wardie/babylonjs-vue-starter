{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { Octree } from \"./octree.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  if (!this._selectionOctree) {\n    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n  }\n\n  var worldExtends = this.getWorldExtends(); // Update octree\n\n  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n\n  return this._selectionOctree;\n};\n\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n  get: function get() {\n    return this._selectionOctree;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n * @param maxCapacity defines the maximum size of each block (64 by default)\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\n * @returns the new octree\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\n */\n\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var scene = this.getScene();\n\n  var component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n\n  if (!this._submeshesOctree) {\n    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n  }\n\n  this.computeWorldMatrix(true);\n  var boundingInfo = this.getBoundingInfo(); // Update octree\n\n  var bbox = boundingInfo.boundingBox;\n\n  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n\n  return this._submeshesOctree;\n};\n/**\n * Defines the octree scene component responsible to manage any octrees\n * in a given scene.\n */\n\n\nvar OctreeSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function OctreeSceneComponent(scene) {\n    /**\n     * The component name help to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_OCTREE;\n    /**\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\n     */\n\n    this.checksIsEnabled = true;\n    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n    scene = scene || EngineStore.LastCreatedScene;\n\n    if (!scene) {\n      return;\n    }\n\n    this.scene = scene;\n    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\n    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\n    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\n    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  OctreeSceneComponent.prototype.register = function () {\n    var _this = this;\n\n    this.scene.onMeshRemovedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        var index = sceneOctree.dynamicContent.indexOf(mesh);\n\n        if (index !== -1) {\n          sceneOctree.dynamicContent.splice(index, 1);\n        }\n      }\n    });\n    this.scene.onMeshImportedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        sceneOctree.addMesh(mesh);\n      }\n    });\n  };\n  /**\n   * Return the list of active meshes\n   * @returns the list of active meshes\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveMeshCandidates = function () {\n    if (this.scene._selectionOctree) {\n      var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);\n\n      return selection;\n    }\n\n    return this.scene._getDefaultMeshCandidates();\n  };\n  /**\n   * Return the list of active sub meshes\n   * @param mesh The mesh to get the candidates sub meshes from\n   * @returns the list of active sub meshes\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveSubMeshCandidates = function (mesh) {\n    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n      var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\n   * Return the list of sub meshes intersecting with a given local ray\n   * @param mesh defines the mesh to find the submesh for\n   * @param localRay defines the ray in local space\n   * @returns the list of intersecting sub meshes\n   */\n\n\n  OctreeSceneComponent.prototype.getIntersectingSubMeshCandidates = function (mesh, localRay) {\n    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n\n      var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\n   * Return the list of sub meshes colliding with a collider\n   * @param mesh defines the mesh to find the submesh for\n   * @param collider defines the collider to evaluate the collision against\n   * @returns the list of colliding sub meshes\n   */\n\n\n  OctreeSceneComponent.prototype.getCollidingSubMeshCandidates = function (mesh, collider) {\n    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n      var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n\n      var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  OctreeSceneComponent.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  OctreeSceneComponent.prototype.dispose = function () {// Nothing to do here.\n  };\n\n  return OctreeSceneComponent;\n}();\n\nexport { OctreeSceneComponent };","map":{"version":3,"mappings":"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","names":["Scene","Vector3","AbstractMesh","Ray","SceneComponentConstants","Octree","EngineStore","prototype","createOrUpdateSelectionOctree","maxCapacity","maxDepth","component","_getComponent","NAME_OCTREE","OctreeSceneComponent","_addComponent","_selectionOctree","CreationFuncForMeshes","worldExtends","getWorldExtends","update","min","max","meshes","Object","defineProperty","get","enumerable","configurable","createOrUpdateSubmeshesOctree","scene","getScene","_submeshesOctree","CreationFuncForSubMeshes","computeWorldMatrix","boundingInfo","getBoundingInfo","bbox","boundingBox","minimumWorld","maximumWorld","subMeshes","Zero","LastCreatedScene","getActiveMeshCandidates","bind","getActiveSubMeshCandidates","getCollidingSubMeshCandidates","getIntersectingSubMeshCandidates","onMeshRemovedObservable","add","mesh","sceneOctree","_this","selectionOctree","undefined","index","dynamicContent","indexOf","splice","onMeshImportedObservable","addMesh","selection","select","frustumPlanes","_getDefaultMeshCandidates","useOctreeForRenderingSelection","intersections","_getDefaultSubMeshCandidates","localRay","useOctreeForPicking","TransformToRef","getWorldMatrix","_tempRay","intersectsRay","collider","useOctreeForCollisions","radius","_velocityWorldLength","Math","_radius","x","y","z","intersects","_basePointWorld"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Culling/Octrees/octreeSceneComponent.ts"],"sourcesContent":["import type { ISmartArrayLike } from \"../../Misc/smartArray\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\n\r\nimport { Octree } from \"./octree\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\n\r\ndeclare type Collider = import(\"../../Collisions/collider\").Collider;\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * @hidden\r\n         * Backing Filed\r\n         */\r\n        _selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Gets the octree used to boost mesh selection (picking)\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         */\r\n        selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Creates or updates the octree used to boost selection (picking)\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         * @param maxCapacity defines the maximum capacity per leaf\r\n         * @param maxDepth defines the maximum depth of the octree\r\n         * @returns an octree of AbstractMesh\r\n         */\r\n        createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;\r\n    }\r\n}\r\n\r\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2): Octree<AbstractMesh> {\r\n    let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    if (!this._selectionOctree) {\r\n        this._selectionOctree = new Octree<AbstractMesh>(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    const worldExtends = this.getWorldExtends();\r\n\r\n    // Update octree\r\n    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\r\n\r\n    return this._selectionOctree;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\r\n    get: function (this: Scene) {\r\n        return this._selectionOctree;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * @hidden\r\n         * Backing Field\r\n         */\r\n        _submeshesOctree: Octree<SubMesh>;\r\n\r\n        /**\r\n         * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n         * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n         * @param maxCapacity defines the maximum size of each block (64 by default)\r\n         * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n         * @returns the new octree\r\n         * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         */\r\n        createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;\r\n    }\r\n}\r\n\r\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n */\r\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2): Octree<SubMesh> {\r\n    const scene = this.getScene();\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n\r\n    if (!this._submeshesOctree) {\r\n        this._submeshesOctree = new Octree<SubMesh>(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    this.computeWorldMatrix(true);\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n\r\n    // Update octree\r\n    const bbox = boundingInfo.boundingBox;\r\n    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\r\n\r\n    return this._submeshesOctree;\r\n};\r\n\r\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\r\nexport class OctreeSceneComponent {\r\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_OCTREE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\r\n    public readonly checksIsEnabled = true;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\r\n\r\n        this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\r\n        this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\r\n        this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene.onMeshRemovedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                const index = sceneOctree.dynamicContent.indexOf(mesh);\r\n\r\n                if (index !== -1) {\r\n                    sceneOctree.dynamicContent.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.onMeshImportedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                sceneOctree.addMesh(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the list of active meshes\r\n     * @returns the list of active meshes\r\n     */\r\n    public getActiveMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        if (this.scene._selectionOctree) {\r\n            const selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);\r\n            return selection;\r\n        }\r\n        return this.scene._getDefaultMeshCandidates();\r\n    }\r\n\r\n    /**\r\n     * Return the list of active sub meshes\r\n     * @param mesh The mesh to get the candidates sub meshes from\r\n     * @returns the list of active sub meshes\r\n     */\r\n    public getActiveSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\r\n            const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    private _tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\r\n    /**\r\n     * Return the list of sub meshes intersecting with a given local ray\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param localRay defines the ray in local space\r\n     * @returns the list of intersecting sub meshes\r\n     */\r\n    public getIntersectingSubMeshCandidates(mesh: AbstractMesh, localRay: Ray): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\r\n            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\r\n            const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Return the list of sub meshes colliding with a collider\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param collider defines the collider to evaluate the collision against\r\n     * @returns the list of colliding sub meshes\r\n     */\r\n    public getCollidingSubMeshCandidates(mesh: AbstractMesh, collider: Collider): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\r\n            const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\r\n            const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}