{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math.js\";\n/**\n * Represents one particle of a points cloud system.\n */\n\nvar CloudPoint =\n/** @class */\nfunction () {\n  /**\n   * Creates a Point Cloud object.\n   * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n   * @param group (PointsGroup) is the group the particle belongs to\n   * @param groupId (integer) is the group identifier in the PCS.\n   * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n   * @param pcs defines the PCS it is associated to\n   */\n  function CloudPoint(particleIndex, group, groupId, idxInGroup, pcs) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * The color of the particle\n     */\n\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n\n    this.rotation = Vector3.Zero();\n    /**\n     * The uv of the particle.\n     */\n\n    this.uv = new Vector2(0.0, 0.0);\n    /**\n     * The current speed of the particle.\n     */\n\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n\n    this.translateFromPivot = false;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @hidden\n     */\n\n    this._pos = 0;\n    /**\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\n     */\n\n    this._ind = 0;\n    /**\n     * Group id of this particle\n     */\n\n    this.groupId = 0;\n    /**\n     * Index of the particle in its group id (Internal use)\n     */\n\n    this.idxInGroup = 0;\n    /**\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\n     */\n\n    this._stillInvisible = false;\n    /**\n     * @hidden Last computed particle rotation matrix\n     */\n\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n\n    this.parentId = null;\n    /**\n     * @hidden Internal global position in the PCS.\n     */\n\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this._group = group;\n    this.groupId = groupId;\n    this.idxInGroup = idxInGroup;\n    this._pcs = pcs;\n  }\n\n  Object.defineProperty(CloudPoint.prototype, \"size\", {\n    /**\n     * get point size\n     */\n    get: function get() {\n      return this.size;\n    },\n\n    /**\n     * Set point size\n     */\n    set: function set(scale) {\n      this.size = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CloudPoint.prototype, \"quaternion\", {\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get: function get() {\n      return this.rotationQuaternion;\n    },\n\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set: function set(q) {\n      this.rotationQuaternion = q;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns a boolean. True if the particle intersects a mesh, else false\n   * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n   * @param target is the object (point or mesh) what the intersection is computed against\n   * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n   * @returns true if it intersects\n   */\n\n  CloudPoint.prototype.intersectsMesh = function (target, isSphere) {\n    if (!target.hasBoundingInfo) {\n      return false;\n    }\n\n    isSphere = isSphere ? isSphere : false;\n\n    if (isSphere) {\n      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n    } else {\n      var maxX = 0;\n      var minX = 0;\n      var maxY = 0;\n      var minY = 0;\n      var maxZ = 0;\n      var minZ = 0;\n      maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;\n      minX = target.getBoundingInfo().boundingBox.minimumWorld.x;\n      maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;\n      minY = target.getBoundingInfo().boundingBox.minimumWorld.y;\n      maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;\n      minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;\n      var x = this.position.x + this._pcs.mesh.position.x;\n      var y = this.position.y + this._pcs.mesh.position.y;\n      var z = this.position.z + this._pcs.mesh.position.z;\n      return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n  };\n  /**\n   * get the rotation matrix of the particle\n   * @param m\n   * @hidden\n   */\n\n\n  CloudPoint.prototype.getRotationMatrix = function (m) {\n    var quaternion;\n\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      var rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n\n    quaternion.toRotationMatrix(m);\n  };\n\n  return CloudPoint;\n}();\n\nexport { CloudPoint };\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\n\nvar PointsGroup =\n/** @class */\nfunction () {\n  /**\n   * Creates a points group object. This is an internal reference to produce particles for the PCS.\n   * PCS internal tool, don't use it manually.\n   * @param id\n   * @param posFunction\n   * @hidden\n   */\n  function PointsGroup(id, posFunction) {\n    this.groupId = id;\n    this._positionFunction = posFunction;\n  }\n\n  Object.defineProperty(PointsGroup.prototype, \"groupID\", {\n    /**\n     * Get or set the groupId\n     * @deprecated Please use groupId instead\n     */\n    get: function get() {\n      return this.groupId;\n    },\n    set: function set(groupID) {\n      this.groupId = groupID;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return PointsGroup;\n}();\n\nexport { PointsGroup };","map":{"version":3,"mappings":"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","names":["Color4","Vector2","Vector3","TmpVectors","Quaternion","particleIndex","group","groupId","idxInGroup","pcs","Zero","idx","_group","_pcs","Object","CloudPoint","size","scale","rotationQuaternion","q","target","isSphere","hasBoundingInfo","getBoundingInfo","boundingSphere","intersectsPoint","position","add","mesh","maxX","minX","maxY","minY","maxZ","minZ","boundingBox","maximumWorld","x","minimumWorld","y","z","m","quaternion","rotation","RotationYawPitchRollToRef","toRotationMatrix","id","posFunction","_positionFunction","PointsGroup","groupID"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/cloudPoint.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math\";\r\nimport { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { PointsCloudSystem } from \"./pointsCloudSystem\";\r\n/**\r\n * Represents one particle of a points cloud system.\r\n */\r\nexport class CloudPoint {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The uv of the particle.\r\n     */\r\n    public uv: Nullable<Vector2> = new Vector2(0.0, 0.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * Group this particle belongs to\r\n     */\r\n    public _group: PointsGroup;\r\n    /**\r\n     * Group id of this particle\r\n     */\r\n    public groupId: number = 0;\r\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\r\n    public idxInGroup: number = 0;\r\n    /**\r\n     * @hidden Particle BoundingInfo object (Internal use)\r\n     */\r\n    public _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @hidden Reference to the PCS that the particle belongs to (Internal use)\r\n     */\r\n    public _pcs: PointsCloudSystem;\r\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * @hidden Internal global position in the PCS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a Point Cloud object.\r\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n     * @param group (PointsGroup) is the group the particle belongs to\r\n     * @param groupId (integer) is the group identifier in the PCS.\r\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n     * @param pcs defines the PCS it is associated to\r\n     */\r\n    constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem) {\r\n        this.idx = particleIndex;\r\n        this._group = group;\r\n        this.groupId = groupId;\r\n        this.idxInGroup = idxInGroup;\r\n        this._pcs = pcs;\r\n    }\r\n\r\n    /**\r\n     * get point size\r\n     */\r\n    public get size(): Vector3 {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Set point size\r\n     */\r\n    public set size(scale: Vector3) {\r\n        this.size = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects a mesh, else false\r\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n     * @param target is the object (point or mesh) what the intersection is computed against\r\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh, isSphere: boolean): boolean {\r\n        if (!target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n        isSphere = isSphere ? isSphere : false;\r\n\r\n        if (isSphere) {\r\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\r\n        } else {\r\n            let maxX = 0;\r\n            let minX = 0;\r\n            let maxY = 0;\r\n            let minY = 0;\r\n            let maxZ = 0;\r\n            let minZ = 0;\r\n            maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;\r\n            minX = target.getBoundingInfo().boundingBox.minimumWorld.x;\r\n            maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;\r\n            minY = target.getBoundingInfo().boundingBox.minimumWorld.y;\r\n            maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;\r\n            minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;\r\n\r\n            const x = this.position.x + this._pcs.mesh.position.x;\r\n            const y = this.position.y + this._pcs.mesh.position.y;\r\n            const z = this.position.z + this._pcs.mesh.position.z;\r\n            return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @param m\r\n     * @hidden\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\r\nexport class PointsGroup {\r\n    /**\r\n     * Get or set the groupId\r\n     * @deprecated Please use groupId instead\r\n     */\r\n    public get groupID(): number {\r\n        return this.groupId;\r\n    }\r\n    public set groupID(groupID: number) {\r\n        this.groupId = groupID;\r\n    }\r\n    /**\r\n     * The group id\r\n     * @hidden\r\n     */\r\n    public groupId: number;\r\n    /**\r\n     * image data for group (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImageData: Nullable<ArrayBufferView>;\r\n    /**\r\n     * Image Width (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImgWidth: number;\r\n    /**\r\n     * Image Height (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImgHeight: number;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @hidden\r\n     */\r\n    public _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;\r\n    /**\r\n     * density per facet for surface points\r\n     * @hidden\r\n     */\r\n    public _groupDensity: number[];\r\n    /**\r\n     * Only when points are colored by texture carries pointer to texture list array\r\n     * @hidden\r\n     */\r\n    public _textureNb: number;\r\n\r\n    /**\r\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n     * PCS internal tool, don't use it manually.\r\n     * @param id\r\n     * @param posFunction\r\n     * @hidden\r\n     */\r\n    constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>) {\r\n        this.groupId = id;\r\n        this._positionFunction = posFunction;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}