{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport \"../Shaders/stereoscopicInterlace.fragment.js\";\n/**\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\n */\n\nvar StereoscopicInterlacePostProcessI =\n/** @class */\nfunction (_super) {\n  __extends(StereoscopicInterlacePostProcessI, _super);\n  /**\n   * Initializes a StereoscopicInterlacePostProcessI\n   * @param name The name of the effect.\n   * @param rigCameras The rig cameras to be applied to the post process\n   * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\n   * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n\n\n  function StereoscopicInterlacePostProcessI(name, rigCameras, isStereoscopicHoriz, isStereoscopicInterlaced, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, \"stereoscopicInterlace\", [\"stepSize\"], [\"camASampler\"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined) || this;\n\n    _this._passedProcess = rigCameras[0]._rigPostProcess;\n    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n\n    _this.onSizeChangedObservable.add(function () {\n      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n    });\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setTextureFromPostProcess(\"camASampler\", _this._passedProcess);\n      effect.setFloat2(\"stepSize\", _this._stepSize.x, _this._stepSize.y);\n    });\n\n    return _this;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"StereoscopicInterlacePostProcessI\" string\n   */\n\n\n  StereoscopicInterlacePostProcessI.prototype.getClassName = function () {\n    return \"StereoscopicInterlacePostProcessI\";\n  };\n\n  return StereoscopicInterlacePostProcessI;\n}(PostProcess);\n\nexport { StereoscopicInterlacePostProcessI };\n/**\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\n */\n\nvar StereoscopicInterlacePostProcess =\n/** @class */\nfunction (_super) {\n  __extends(StereoscopicInterlacePostProcess, _super);\n  /**\n   * Initializes a StereoscopicInterlacePostProcess\n   * @param name The name of the effect.\n   * @param rigCameras The rig cameras to be applied to the post process\n   * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n\n\n  function StereoscopicInterlacePostProcess(name, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, \"stereoscopicInterlace\", [\"stepSize\"], [\"camASampler\"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined) || this;\n\n    _this._passedProcess = rigCameras[0]._rigPostProcess;\n    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n\n    _this.onSizeChangedObservable.add(function () {\n      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n    });\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setTextureFromPostProcess(\"camASampler\", _this._passedProcess);\n      effect.setFloat2(\"stepSize\", _this._stepSize.x, _this._stepSize.y);\n    });\n\n    return _this;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"StereoscopicInterlacePostProcess\" string\n   */\n\n\n  StereoscopicInterlacePostProcess.prototype.getClassName = function () {\n    return \"StereoscopicInterlacePostProcess\";\n  };\n\n  return StereoscopicInterlacePostProcess;\n}(PostProcess);\n\nexport { StereoscopicInterlacePostProcess };","map":{"version":3,"mappings":"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","names":["Vector2","PostProcess","__extends","name","rigCameras","isStereoscopicHoriz","isStereoscopicInterlaced","samplingMode","engine","reusable","_super","undefined","_this","_passedProcess","_rigPostProcess","_stepSize","width","height","onSizeChangedObservable","add","onApplyObservable","effect","setTextureFromPostProcess","setFloat2","x","y","StereoscopicInterlacePostProcessI","StereoscopicInterlacePostProcess"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/stereoscopicInterlacePostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Shaders/stereoscopicInterlace.fragment\";\r\n\r\n/**\r\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\r\n */\r\nexport class StereoscopicInterlacePostProcessI extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcessI\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcessI\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcessI\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be applied to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n     * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, isStereoscopicInterlaced: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(\r\n            name,\r\n            \"stereoscopicInterlace\",\r\n            [\"stepSize\"],\r\n            [\"camASampler\"],\r\n            1,\r\n            rigCameras[1],\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined\r\n        );\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}\r\n/**\r\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\r\n */\r\nexport class StereoscopicInterlacePostProcess extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcess\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be applied to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(\r\n            name,\r\n            \"stereoscopicInterlace\",\r\n            [\"stepSize\"],\r\n            [\"camASampler\"],\r\n            1,\r\n            rigCameras[1],\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined\r\n        );\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}