{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { RenderTargetWrapper } from \"./renderTargetWrapper.js\";\n/**\n * Options to create the null engine\n */\n\nvar NullEngineOptions =\n/** @class */\nfunction () {\n  function NullEngineOptions() {\n    /**\n     * Render width (Default: 512)\n     */\n    this.renderWidth = 512;\n    /**\n     * Render height (Default: 256)\n     */\n\n    this.renderHeight = 256;\n    /**\n     * Texture size (Default: 512)\n     */\n\n    this.textureSize = 512;\n    /**\n     * If delta time between frames should be constant\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     */\n\n    this.deterministicLockstep = false;\n    /**\n     * Maximum about of steps between frames (Default: 4)\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     */\n\n    this.lockstepMaxSteps = 4;\n  }\n\n  return NullEngineOptions;\n}();\n\nexport { NullEngineOptions };\n/**\n * The null engine class provides support for headless version of babylon.js.\n * This can be used in server side scenario or for testing purposes\n */\n\nvar NullEngine =\n/** @class */\nfunction (_super) {\n  __extends(NullEngine, _super);\n\n  function NullEngine(options) {\n    if (options === void 0) {\n      options = new NullEngineOptions();\n    }\n\n    var _this = _super.call(this, null) || this;\n\n    Engine.Instances.push(_this);\n\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n\n    _this._options = options;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix); // Init caps\n    // We consider we are on a webgl1 capable device\n\n    _this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: false,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 0,\n      uintIndices: false,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      maxMSAASamples: 1,\n      blendMinMax: false,\n      canUseGLInstanceID: false,\n      canUseGLVertexID: false,\n      supportComputeShaders: false,\n      supportSRGBBuffers: false,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false\n    };\n    _this._features = {\n      forceBitmapOverHTMLImageElement: false,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: false,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: false,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      _collectUbosUpdatedInFrame: false\n    };\n    Logger.Log(\"Babylon.js v\".concat(Engine.Version, \" - Null engine\")); // Wrappers\n\n    var theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n\n    if (typeof URL === \"undefined\") {\n      theCurrentGlobal.URL = {\n        createObjectURL: function createObjectURL() {},\n        revokeObjectURL: function revokeObjectURL() {}\n      };\n    }\n\n    if (typeof Blob === \"undefined\") {\n      theCurrentGlobal.Blob = function () {};\n    }\n\n    return _this;\n  }\n  /**\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   * @returns true if engine is in deterministic lock step mode\n   */\n\n\n  NullEngine.prototype.isDeterministicLockStep = function () {\n    return this._options.deterministicLockstep;\n  };\n  /**\n   * Gets the max steps when engine is running in deterministic lock step\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   * @returns the max steps\n   */\n\n\n  NullEngine.prototype.getLockstepMaxSteps = function () {\n    return this._options.lockstepMaxSteps;\n  };\n  /**\n   * Gets the current hardware scaling level.\n   * By default the hardware scaling level is computed from the window device ratio.\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\n   * @returns a number indicating the current hardware scaling level\n   */\n\n\n  NullEngine.prototype.getHardwareScalingLevel = function () {\n    return 1.0;\n  };\n  /**\n   * Creates a vertex buffer\n   * @param vertices the data for the vertex buffer\n   * @returns the new WebGL static buffer\n   */\n\n\n  NullEngine.prototype.createVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @returns a new webGL buffer\n   */\n\n\n  NullEngine.prototype.createIndexBuffer = function (indices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n\n\n  NullEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    }\n  };\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n\n\n  NullEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._options.renderWidth;\n  };\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n\n\n  NullEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._options.renderHeight;\n  };\n  /**\n   * Set the WebGL's viewport\n   * @param viewport defines the viewport element to be used\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\n   */\n\n\n  NullEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n  };\n\n  NullEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context) {\n    return {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      __SPECTOR_rebuildProgram: null\n    };\n  };\n  /**\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\n   * @param pipelineContext defines the pipeline context to use\n   * @param uniformsNames defines the list of uniform names\n   * @returns an array of webGL uniform locations\n   */\n\n\n  NullEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {\n    return [];\n  };\n  /**\n   * Gets the lsit of active attributes for a given webGL program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n\n\n  NullEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    return [];\n  };\n  /**\n   * Binds an effect to the webGL context\n   * @param effect defines the effect to bind\n   */\n\n\n  NullEngine.prototype.bindSamplers = function (effect) {\n    this._currentEffect = null;\n  };\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n\n\n  NullEngine.prototype.enableEffect = function (effect) {\n    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\n\n    this._currentEffect = effect;\n\n    if (!effect) {\n      return;\n    }\n\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  };\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n\n\n  NullEngine.prototype.setState = function (culling, zOffset, force, reverseSide, cullBackFaces, stencil, zOffsetUnits) {\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    }\n\n    if (zOffsetUnits === void 0) {\n      zOffsetUnits = 0;\n    }\n  };\n  /**\n   * Set the value of an uniform to an array of int32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setIntArray = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setIntArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setIntArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setIntArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of float32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloatArray = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloatArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloatArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloatArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of number\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setArray = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of number (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of number (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of number (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to an array of float32 (stored as matrices)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrices defines the array of float32 to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setMatrices = function (uniform, matrices) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a matrix (3x3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setMatrix3x3 = function (uniform, matrix) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a matrix (2x2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setMatrix2x2 = function (uniform, matrix) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a number (float)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param value defines the float number to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloat = function (uniform, value) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a vec2\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloat2 = function (uniform, x, y) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a vec3\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloat3 = function (uniform, x, y, z) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a boolean\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param bool defines the boolean to store\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setBool = function (uniform, bool) {\n    return true;\n  };\n  /**\n   * Set the value of an uniform to a vec4\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @param w defines the 4th component of the value\n   * @returns true if value was set\n   */\n\n\n  NullEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n    return true;\n  };\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\n   */\n\n\n  NullEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {\n    if (noDepthWriteChange === void 0) {\n      noDepthWriteChange = false;\n    }\n\n    if (this._alphaMode === mode) {\n      return;\n    }\n\n    this.alphaState.alphaBlend = mode !== 0;\n\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n\n    this._alphaMode = mode;\n  };\n  /**\n   * Bind webGl buffers directly to the webGL context\n   * @param vertexBuffers defines the vertex buffer to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffer\n   */\n\n\n  NullEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {};\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n\n\n  NullEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n\n    this.resetTextureCache();\n    this._currentEffect = null;\n\n    if (bruteForce) {\n      this._currentProgram = null;\n\n      this._stencilStateComposer.reset();\n\n      this.depthCullingState.reset();\n      this.alphaState.reset();\n    }\n\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  };\n  /**\n   * Send a draw order\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n\n\n  NullEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {};\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n\n\n  NullEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {};\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n\n\n  NullEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {};\n  /** @hidden */\n\n\n  NullEngine.prototype._createTexture = function () {\n    return {};\n  };\n  /**\n   * @param texture\n   * @hidden\n   */\n\n\n  NullEngine.prototype._releaseTexture = function (texture) {};\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a WebGLTexture\n   * @param urlArg defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n\n\n  NullEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType) {\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.Url);\n    var url = String(urlArg);\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = this._options.textureSize;\n    texture.baseHeight = this._options.textureSize;\n    texture.width = this._options.textureSize;\n    texture.height = this._options.textureSize;\n\n    if (format) {\n      texture.format = format;\n    }\n\n    texture.isReady = true;\n\n    if (onLoad) {\n      onLoad();\n    }\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n  /**\n   * @param isMulti\n   * @param isCube\n   * @param size\n   * @hidden\n   */\n\n\n  NullEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {\n    var rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\n\n    this._renderTargetWrapperCache.push(rtWrapper);\n\n    return rtWrapper;\n  };\n  /**\n   * Creates a new render target wrapper\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @returns a new render target wrapper\n   */\n\n\n  NullEngine.prototype.createRenderTargetTexture = function (size, options) {\n    var rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n\n    var fullOptions = {};\n\n    if (options !== undefined && _typeof(options) === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    var width = size.width || size;\n    var height = size.height || size;\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n\n    this._internalTexturesCache.push(texture);\n\n    return rtWrapper;\n  };\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   */\n\n\n  NullEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {\n    texture.samplingMode = samplingMode;\n  };\n  /**\n   * Creates a raw texture\n   * @param data defines the data to store in the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param format defines the format of the data\n   * @param generateMipMaps defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @returns the raw texture inside an InternalTexture\n   */\n\n\n  NullEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, creationFlags) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (creationFlags === void 0) {\n      creationFlags = 0;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._compression = compression;\n    texture.type = type;\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n\n    return texture;\n  };\n  /**\n   * Update a raw texture\n   * @param texture defines the texture to update\n   * @param data defines the data to store in the texture\n   * @param format defines the format of the data\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   */\n\n\n  NullEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression, type) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (texture) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n      texture.type = type;\n    }\n  };\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param rtWrapper The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   */\n\n\n  NullEngine.prototype.bindFramebuffer = function (rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n\n    this._currentRenderTarget = rtWrapper;\n    this._currentFramebuffer = null;\n\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    }\n  };\n  /**\n   * Unbind the current render target texture from the webGL context\n   * @param rtWrapper defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n\n\n  NullEngine.prototype.unBindFramebuffer = function (rtWrapper, disableGenerateMipMaps, onBeforeUnbind) {\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    this._currentRenderTarget = null;\n\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n\n    this._currentFramebuffer = null;\n  };\n  /**\n   * Creates a dynamic vertex buffer\n   * @param vertices the data for the dynamic vertex buffer\n   * @returns the new WebGL dynamic buffer\n   */\n\n\n  NullEngine.prototype.createDynamicVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    buffer.capacity = 1;\n    return buffer;\n  };\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n\n\n  NullEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n  };\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns true if all effects are ready\n   */\n\n\n  NullEngine.prototype.areAllEffectsReady = function () {\n    return true;\n  };\n  /**\n   * @hidden\n   * Get the current error code of the webGL context\n   * @returns the error code\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\n   */\n\n\n  NullEngine.prototype.getError = function () {\n    return 0;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._getUnpackAlignement = function () {\n    return 1;\n  };\n  /**\n   * @param value\n   * @hidden\n   */\n\n\n  NullEngine.prototype._unpackFlipY = function (value) {};\n  /**\n   * Update a dynamic index buffer\n   * @param indexBuffer defines the target index buffer\n   * @param indices defines the data to update\n   * @param offset defines the offset in the target index buffer where update should start\n   */\n\n\n  NullEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n  };\n  /**\n   * Updates a dynamic vertex buffer.\n   * @param vertexBuffer the vertex buffer to update\n   * @param vertices the data used to update the vertex buffer\n   * @param byteOffset the byte offset of the data (optional)\n   * @param byteLength the byte length of the data (optional)\n   */\n\n\n  NullEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, byteOffset, byteLength) {};\n  /**\n   * @param target\n   * @param texture\n   * @hidden\n   */\n\n\n  NullEngine.prototype._bindTextureDirectly = function (target, texture) {\n    if (this._boundTexturesCache[this._activeChannel] !== texture) {\n      this._boundTexturesCache[this._activeChannel] = texture;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @param channel\n   * @param texture\n   * @hidden\n   */\n\n\n  NullEngine.prototype._bindTexture = function (channel, texture) {\n    if (channel < 0) {\n      return;\n    }\n\n    this._bindTextureDirectly(0, texture);\n  };\n\n  NullEngine.prototype._deleteBuffer = function (buffer) {};\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n\n\n  NullEngine.prototype.releaseEffects = function () {};\n\n  NullEngine.prototype.displayLoadingUI = function () {};\n\n  NullEngine.prototype.hideLoadingUI = function () {};\n\n  Object.defineProperty(NullEngine.prototype, \"loadingUIText\", {\n    set: function set(_) {},\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param texture\n   * @param internalFormat\n   * @param width\n   * @param height\n   * @param data\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n  NullEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /**\n   * @param texture\n   * @param imageData\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  NullEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /**\n   * @param texture\n   * @param imageData\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  NullEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /**\n   * @param texture\n   * @param image\n   * @param faceIndex\n   * @param lod\n   * @hidden\n   */\n\n\n  NullEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n\n  return NullEngine;\n}(Engine);\n\nexport { NullEngine };","map":{"version":3,"mappings":"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","names":["Logger","Engine","InternalTexture","InternalTextureSource","DataBuffer","PerformanceConfigurator","DrawWrapper","RenderTargetWrapper","__extends","options","NullEngineOptions","_super","Instances","push","_this","deterministicLockstep","undefined","lockstepMaxSteps","_options","SetMatrixPrecision","useHighPrecisionMatrix","_caps","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","pvrtc","etc1","etc2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatLinearFiltering","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","supportOcclusionQuery","canUseTimestampForTimerQuery","maxMSAASamples","blendMinMax","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","_collectUbosUpdatedInFrame","Log","Version","theCurrentGlobal","self","global","window","URL","createObjectURL","revokeObjectURL","Blob","NullEngine","vertices","buffer","references","indices","color","backBuffer","depth","stencil","useScreen","_currentRenderTarget","width","renderWidth","height","renderHeight","viewport","requiredWidth","requiredHeight","_cachedViewport","pipelineContext","vertexCode","fragmentCode","defines","context","__SPECTOR_rebuildProgram","uniformsNames","attributesNames","effect","_currentEffect","IsWrapper","onBind","_onBindObservable","notifyObservers","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","uniform","array","matrices","matrix","value","x","y","z","bool","w","mode","noDepthWriteChange","_alphaMode","alphaState","alphaBlend","setDepthWrite","vertexBuffers","indexBuffer","bruteForce","preventCacheWipeBetweenFrames","resetTextureCache","_currentProgram","_stencilStateComposer","reset","depthCullingState","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","useTriangles","indexStart","indexCount","instancesCount","fillMode","verticesStart","verticesCount","texture","urlArg","noMipmap","invertY","scene","samplingMode","onLoad","onError","fallback","format","forcedExtension","mimeType","Url","url","String","generateMipMaps","baseWidth","textureSize","baseHeight","isReady","_internalTexturesCache","isMulti","isCube","size","rtWrapper","_renderTargetWrapperCache","_createHardwareRenderTargetWrapper","fullOptions","generateDepthBuffer","generateStencilBuffer","type","RenderTarget","_generateDepthBuffer","_generateStencilBuffer","samples","data","compression","creationFlags","Raw","_compression","_doNotHandleContextLost","_bufferView","faceIndex","forceFullscreenViewport","unBindFramebuffer","_currentFramebuffer","setViewport","disableGenerateMipMaps","onBeforeUnbind","capacity","canvas","premulAlpha","offset","vertexBuffer","byteOffset","byteLength","target","_boundTexturesCache","_activeChannel","channel","_bindTextureDirectly","Object","_","internalFormat","lod","imageData","image"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/nullEngine.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"./constants\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\ndeclare const global: any;\r\n\r\n/**\r\n * Options to create the null engine\r\n */\r\nexport class NullEngineOptions {\r\n    /**\r\n     * Render width (Default: 512)\r\n     */\r\n    public renderWidth = 512;\r\n    /**\r\n     * Render height (Default: 256)\r\n     */\r\n    public renderHeight = 256;\r\n\r\n    /**\r\n     * Texture size (Default: 512)\r\n     */\r\n    public textureSize = 512;\r\n\r\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public deterministicLockstep = false;\r\n\r\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public lockstepMaxSteps = 4;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n}\r\n\r\n/**\r\n * The null engine class provides support for headless version of babylon.js.\r\n * This can be used in server side scenario or for testing purposes\r\n */\r\nexport class NullEngine extends Engine {\r\n    private _options: NullEngineOptions;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._options.deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._options.lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return 1.0;\r\n    }\r\n\r\n    public constructor(options: NullEngineOptions = new NullEngineOptions()) {\r\n        super(null);\r\n\r\n        Engine.Instances.push(this);\r\n\r\n        if (options.deterministicLockstep === undefined) {\r\n            options.deterministicLockstep = false;\r\n        }\r\n\r\n        if (options.lockstepMaxSteps === undefined) {\r\n            options.lockstepMaxSteps = 4;\r\n        }\r\n\r\n        this._options = options;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        // Init caps\r\n        // We consider we are on a webgl1 capable device\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: 512,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: false,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 0,\r\n            uintIndices: false,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            textureFloat: false,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: false,\r\n            textureHalfFloat: false,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: false,\r\n            textureLOD: false,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: false,\r\n            instancedArrays: false,\r\n            supportOcclusionQuery: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            maxMSAASamples: 1,\r\n            blendMinMax: false,\r\n            canUseGLInstanceID: false,\r\n            canUseGLVertexID: false,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: false,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: false,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: false,\r\n            supportRenderAndCopyToLodForFloatTextures: false,\r\n            supportDepthStencilTexture: false,\r\n            supportShadowSamplers: false,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: false,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: false,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: false,\r\n            needTypeSuffixInShaderConstants: false,\r\n            supportMSAA: false,\r\n            supportSSAO2: false,\r\n            supportExtendedTextureFormats: false,\r\n            supportSwitchCaseInShader: false,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: false,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\r\n\r\n        // Wrappers\r\n        const theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\r\n        if (typeof URL === \"undefined\") {\r\n            theCurrentGlobal.URL = {\r\n                createObjectURL: function () {},\r\n                revokeObjectURL: function () {},\r\n            };\r\n        }\r\n        if (typeof Blob === \"undefined\") {\r\n            theCurrentGlobal.Blob = function () {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param vertices the data for the vertex buffer\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public createVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @returns a new webGL buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: IColor4Like, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {}\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._options.renderWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._options.renderHeight;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n    }\r\n\r\n    public createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram {\r\n        return {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            __SPECTOR_rebuildProgram: null,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param uniformsNames defines the list of uniform names\r\n     * @returns an array of webGL uniform locations\r\n     */\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Gets the lsit of active attributes for a given webGL program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public bindSamplers(effect: Effect): void {\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\r\n\r\n        this._currentEffect = effect as Nullable<Effect>;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (effect.onBind) {\r\n            effect.onBind(effect);\r\n        }\r\n        if (effect._onBindObservable) {\r\n            effect._onBindObservable.notifyObservers(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(\r\n        culling: boolean,\r\n        zOffset: number = 0,\r\n        force?: boolean,\r\n        reverseSide = false,\r\n        cullBackFaces?: boolean,\r\n        stencil?: IStencilState,\r\n        zOffsetUnits: number = 0\r\n    ): void {}\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as matrices)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrices defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (3x3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (2x2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (float)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the float number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a boolean\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param bool defines the boolean to store\r\n     * @returns true if value was set\r\n     */\r\n    public setBool(uniform: WebGLUniformLocation, bool: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        this.alphaState.alphaBlend = mode !== Constants.ALPHA_DISABLE;\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        }\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Bind webGl buffers directly to the webGL context\r\n     * @param vertexBuffers defines the vertex buffer to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffer\r\n     */\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer }, indexBuffer: DataBuffer, effect: Effect): void {}\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this._stencilStateComposer.reset();\r\n            this.depthCullingState.reset();\r\n            this.alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Send a draw order\r\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void {}\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {}\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {}\r\n\r\n    /** @hidden */\r\n    protected _createTexture(): WebGLTexture {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * @param texture\r\n     * @hidden\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {}\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param urlArg defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        urlArg: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Url);\r\n        const url = String(urlArg);\r\n\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = this._options.textureSize;\r\n        texture.baseHeight = this._options.textureSize;\r\n        texture.width = this._options.textureSize;\r\n        texture.height = this._options.textureSize;\r\n        if (format) {\r\n            texture.format = format;\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @param isMulti\r\n     * @param isCube\r\n     * @param size\r\n     * @hidden\r\n     */\r\n    public _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: number | { width: number; height: number; layers?: number }): RenderTargetWrapper {\r\n        const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\r\n        this._renderTargetWrapperCache.push(rtWrapper);\r\n        return rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target wrapper\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target wrapper\r\n     */\r\n    public createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\r\n\r\n        const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.generateDepthBuffer = true;\r\n            fullOptions.generateStencilBuffer = false;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        }\r\n        const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n        const width = size.width || size;\r\n        const height = size.height || size;\r\n\r\n        rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Creates a raw texture\r\n     * @param data defines the data to store in the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param format defines the format of the data\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns the raw texture inside an InternalTexture\r\n     */\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags = 0\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.format = format;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture.type = type;\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Update a raw texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store in the texture\r\n     * @param format defines the format of the data\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     */\r\n    public updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        if (texture) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n            texture.type = type;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param rtWrapper The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     */\r\n    public bindFramebuffer(rtWrapper: RenderTargetWrapper, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = rtWrapper;\r\n        this._currentFramebuffer = null;\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param rtWrapper defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n        this._currentFramebuffer = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param vertices the data for the dynamic vertex buffer\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public createDynamicVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        const buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        buffer.capacity = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha: boolean = false, format?: number): void {}\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n     */\r\n    public getError(): number {\r\n        return 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @param value\r\n     * @hidden\r\n     */\r\n    public _unpackFlipY(value: boolean) {}\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset: number = 0): void {}\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param vertices the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void {}\r\n\r\n    /**\r\n     * @param target\r\n     * @param texture\r\n     * @hidden\r\n     */\r\n    public _bindTextureDirectly(target: number, texture: InternalTexture): boolean {\r\n        if (this._boundTexturesCache[this._activeChannel] !== texture) {\r\n            this._boundTexturesCache[this._activeChannel] = texture;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param channel\r\n     * @param texture\r\n     * @hidden\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        if (channel < 0) {\r\n            return;\r\n        }\r\n\r\n        this._bindTextureDirectly(0, texture);\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: WebGLBuffer): void {}\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {}\r\n\r\n    public displayLoadingUI(): void {}\r\n\r\n    public hideLoadingUI(): void {}\r\n\r\n    public set loadingUIText(_: string) {}\r\n\r\n    /**\r\n     * @param texture\r\n     * @param internalFormat\r\n     * @param width\r\n     * @param height\r\n     * @param data\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * @param texture\r\n     * @param imageData\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {}\r\n\r\n    /**\r\n     * @param texture\r\n     * @param imageData\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {}\r\n\r\n    /**\r\n     * @param texture\r\n     * @param image\r\n     * @param faceIndex\r\n     * @param lod\r\n     * @hidden\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}