{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\n/**\n * Block used to implement the anisotropy module of the PBR material\n */\n\nvar AnisotropyBlock =\n/** @class */\nfunction (_super) {\n  __extends(AnisotropyBlock, _super);\n  /**\n   * Create a new AnisotropyBlock\n   * @param name defines the block name\n   */\n\n\n  function AnisotropyBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n\n\n    _this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n\n    _this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", _this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n\n    return _this;\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n\n\n  AnisotropyBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"anisotropicOut\");\n\n    state._excludeVariableName(\"TBN\");\n  };\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n\n  AnisotropyBlock.prototype.getClassName = function () {\n    return \"AnisotropyBlock\";\n  };\n\n  Object.defineProperty(AnisotropyBlock.prototype, \"intensity\", {\n    /**\n     * Gets the intensity input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"direction\", {\n    /**\n     * Gets the direction input component\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"uv\", {\n    /**\n     * Gets the uv input component\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"worldTangent\", {\n    /**\n     * Gets the worldTangent input component\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"anisotropy\", {\n    /**\n     * Gets the anisotropy object output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AnisotropyBlock.prototype._generateTBNSpace = function (state) {\n    var code = \"\";\n    var comments = \"//\".concat(this.name);\n    var uv = this.uv;\n    var worldPosition = this.worldPositionConnectionPoint;\n    var worldNormal = this.worldNormalConnectionPoint;\n    var worldTangent = this.worldTangent;\n\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n\n    var tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n\n    if (worldTangent.isConnected) {\n      code += \"vec3 tbnNormal = normalize(\".concat(worldNormal.associatedVariableName, \".xyz);\\r\\n\");\n      code += \"vec3 tbnTangent = normalize(\".concat(worldTangent.associatedVariableName, \".xyz);\\r\\n\");\n      code += \"vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\\r\\n\";\n      code += \"mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n\";\n    }\n\n    code += \"\\n            #if defined(\".concat(worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\", \") && defined(NORMAL)\\n                mat3 TBN = vTBN;\\n            #else\\n                mat3 TBN = cotangent_frame(\").concat(worldNormal.associatedVariableName + \".xyz\", \", \").concat(\"v_\" + worldPosition.associatedVariableName + \".xyz\", \", \").concat(uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\", \", vec2(1., 1.));\\n            #endif\\r\\n\");\n\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n\n    return code;\n  };\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n   * @returns the shader code\n   */\n\n\n  AnisotropyBlock.prototype.getCode = function (state, generateTBNSpace) {\n    if (generateTBNSpace === void 0) {\n      generateTBNSpace = false;\n    }\n\n    var code = \"\";\n\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n\n    var intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    var direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    code += \"anisotropicOutParams anisotropicOut;\\n            anisotropicBlock(\\n                vec3(\".concat(direction, \", \").concat(intensity, \"),\\n            #ifdef ANISOTROPIC_TEXTURE\\n                vec3(0.),\\n            #endif\\n                TBN,\\n                normalW,\\n                viewDirectionW,\\n                anisotropicOut\\n            );\\r\\n\");\n    return code;\n  };\n\n  AnisotropyBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n  };\n\n  AnisotropyBlock.prototype._buildBlock = function (state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n\n    return this;\n  };\n\n  return AnisotropyBlock;\n}(NodeMaterialBlock);\n\nexport { AnisotropyBlock };\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","NodeMaterialConnectionPointCustomObject","__extends","name","_super","Fragment","_this","_isUnique","registerInput","Float","Vector2","Vector4","registerOutput","Object","Output","AnisotropyBlock","state","_excludeVariableName","_inputs","_outputs","code","comments","uv","worldPosition","worldPositionConnectionPoint","worldNormal","worldNormalConnectionPoint","worldTangent","isConnected","console","error","_emitExtension","tangentReplaceString","search","replace","associatedVariableName","concat","_emitFunctionFromInclude","replaceStrings","generateTBNSpace","_generateTBNSpace","intensity","direction","mesh","nodeMaterial","defines","prepareDefines","call","setValue","target","sharedData","blocksWithDefines","push"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/PBR/anisotropyBlock.ts"],"sourcesContent":["import type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @hidden */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @hidden */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n\r\n        this.registerOutput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPositionConnectionPoint;\r\n        const worldNormal = this.worldNormalConnectionPoint;\r\n        const worldTangent = this.worldTangent;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\\r\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${\r\n            uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"\r\n        }, vec2(1., 1.));\r\n            #endif\\r\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n\r\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\r\n"]},"metadata":{},"sourceType":"module"}