{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { WebVRController } from \"./webVRController.js\";\nimport { GenericController } from \"./genericController.js\";\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController.js\";\n/**\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\n */\n\nvar LoadedMeshInfo =\n/** @class */\nfunction () {\n  function LoadedMeshInfo() {\n    /**\n     * Map of the button meshes contained in the controller\n     */\n    this.buttonMeshes = {};\n    /**\n     * Map of the axis meshes contained in the controller\n     */\n\n    this.axisMeshes = {};\n  }\n\n  return LoadedMeshInfo;\n}();\n/**\n * Defines the WindowsMotionController object that the state of the windows motion controller\n */\n\n\nvar WindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(WindowsMotionController, _super);\n  /**\n   * Creates a new WindowsMotionController from a gamepad\n   * @param vrGamepad the gamepad that the controller should be created from\n   */\n\n\n  function WindowsMotionController(vrGamepad) {\n    var _this = _super.call(this, vrGamepad) || this;\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: [\"thumbstick\", \"trigger\", \"grip\", \"menu\", \"trackpad\"],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        trigger: \"SELECT\",\n        menu: \"MENU\",\n        grip: \"GRASP\",\n        thumbstick: \"THUMBSTICK_PRESS\",\n        trackpad: \"TOUCHPAD_PRESS\"\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        trigger: \"onTriggerStateChangedObservable\",\n        menu: \"onSecondaryButtonStateChangedObservable\",\n        grip: \"onMainButtonStateChangedObservable\",\n        thumbstick: \"onPadStateChangedObservable\",\n        trackpad: \"onTrackpadChangedObservable\"\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: [\"THUMBSTICK_X\", \"THUMBSTICK_Y\", \"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\"],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\n     * Fired when the trackpad on this controller is clicked\n     */\n\n    _this.onTrackpadChangedObservable = new Observable();\n    /**\n     * Fired when the trackpad on this controller is modified\n     */\n\n    _this.onTrackpadValuesChangedObservable = new Observable();\n    /**\n     * The current x and y values of this controller's trackpad\n     */\n\n    _this.trackpad = {\n      x: 0,\n      y: 0\n    };\n    _this.controllerType = PoseEnabledControllerType.WINDOWS;\n    _this._loadedMeshInfo = null;\n    return _this;\n  }\n\n  Object.defineProperty(WindowsMotionController.prototype, \"onTriggerButtonStateChangedObservable\", {\n    /**\n     * Fired when the trigger on this controller is modified\n     */\n    get: function get() {\n      return this.onTriggerStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onMenuButtonStateChangedObservable\", {\n    /**\n     * Fired when the menu button on this controller is modified\n     */\n    get: function get() {\n      return this.onSecondaryButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onGripButtonStateChangedObservable\", {\n    /**\n     * Fired when the grip button on this controller is modified\n     */\n    get: function get() {\n      return this.onMainButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\n     * Fired when the thumbstick button on this controller is modified\n     */\n    get: function get() {\n      return this.onPadStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadButtonStateChangedObservable\", {\n    /**\n     * Fired when the touchpad button on this controller is modified\n     */\n    get: function get() {\n      return this.onTrackpadChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadValuesChangedObservable\", {\n    /**\n     * Fired when the touchpad values on this controller are modified\n     */\n    get: function get() {\n      return this.onTrackpadValuesChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_X\")];\n      this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_Y\")];\n      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\n   * Called once per frame by the engine.\n   */\n\n\n  WindowsMotionController.prototype.update = function () {\n    _super.prototype.update.call(this);\n\n    if (this.browserGamepad.axes) {\n      this._updateTrackpad(); // Only need to animate axes if there is a loaded mesh\n\n\n      if (this._loadedMeshInfo) {\n        for (var axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\n          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\n        }\n      }\n    }\n  };\n  /**\n   * Called once for each button that changed state since the last frame\n   * @param buttonIdx Which button index changed\n   * @param state New state of the button\n   */\n\n\n  WindowsMotionController.prototype._handleButtonChange = function (buttonIdx, state) {\n    var buttonName = this._mapping.buttons[buttonIdx];\n\n    if (!buttonName) {\n      return;\n    } // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\n\n\n    this._updateTrackpad(); // Only emit events for buttons that we know how to map from index to name\n\n\n    var observable = this[this._mapping.buttonObservableNames[buttonName]];\n\n    if (observable) {\n      observable.notifyObservers(state);\n    }\n\n    this._lerpButtonTransform(buttonName, state.value);\n  };\n  /**\n   * Moves the buttons on the controller mesh based on their current state\n   * @param buttonName the name of the button to move\n   * @param buttonValue the value of the button which determines the buttons new position\n   */\n\n\n  WindowsMotionController.prototype._lerpButtonTransform = function (buttonName, buttonValue) {\n    // If there is no loaded mesh, there is nothing to transform.\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\n\n    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    }\n\n    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\n  };\n  /**\n   * Moves the axis on the controller mesh based on its current state\n   * @param axis the index of the axis\n   * @param axisValue the value of the axis which determines the meshes new position\n   * @hidden\n   */\n\n\n  WindowsMotionController.prototype._lerpAxisTransform = function (axis, axisValue) {\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.axisMeshes[axis];\n\n    if (!meshInfo) {\n      return;\n    }\n\n    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    } // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n\n\n    var lerpValue = axisValue * 0.5 + 0.5;\n    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\n  };\n  /**\n   * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\n   * @param scene scene in which to add meshes\n   * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\n   * @param forceDefault\n   */\n\n\n  WindowsMotionController.prototype.initControllerMesh = function (scene, meshLoaded, forceDefault) {\n    var _this = this;\n\n    if (forceDefault === void 0) {\n      forceDefault = false;\n    }\n\n    var path;\n    var filename; // Checking if GLB loader is present\n\n    if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\n      // Determine the device specific folder based on the ID suffix\n      var device = \"default\";\n\n      if (this.id && !forceDefault) {\n        var match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\n        device = match && match[0] || device;\n      } // Hand\n\n\n      if (this.hand === \"left\") {\n        filename = WindowsMotionController.MODEL_LEFT_FILENAME;\n      } else {\n        // Right is the default if no hand is specified\n        filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\n      }\n\n      path = WindowsMotionController.MODEL_BASE_URL + device + \"/\";\n    } else {\n      Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\n      path = GenericController.MODEL_BASE_URL;\n      filename = GenericController.MODEL_FILENAME;\n    }\n\n    SceneLoader.ImportMesh(\"\", path, filename, scene, function (meshes) {\n      // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\n      _this._loadedMeshInfo = _this._processModel(scene, meshes);\n\n      if (!_this._loadedMeshInfo) {\n        return;\n      }\n\n      _this._defaultModel = _this._loadedMeshInfo.rootNode;\n\n      _this.attachToMesh(_this._defaultModel);\n\n      if (meshLoaded) {\n        meshLoaded(_this._defaultModel);\n      }\n    }, null, function (scene, message) {\n      Logger.Log(message);\n      Logger.Warn(\"Failed to retrieve controller model from the remote server: \" + path + filename);\n\n      if (!forceDefault) {\n        _this.initControllerMesh(scene, meshLoaded, true);\n      }\n    });\n  };\n  /**\n   * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\n   * can be transformed by button presses and axes values, based on this._mapping.\n   *\n   * @param scene scene in which the meshes exist\n   * @param meshes list of meshes that make up the controller model to process\n   * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\n   */\n\n\n  WindowsMotionController.prototype._processModel = function (scene, meshes) {\n    var loadedMeshInfo = null; // Create a new mesh to contain the glTF hierarchy\n\n    var parentMesh = new Mesh(this.id + \" \" + this.hand, scene); // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\n\n    var childMesh = null;\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n\n      if (!mesh.parent) {\n        // Exclude controller meshes from picking results\n        mesh.isPickable = false; // Handle root node, attach to the new parentMesh\n\n        childMesh = mesh;\n        break;\n      }\n    }\n\n    if (childMesh) {\n      childMesh.setParent(parentMesh); // Create our mesh info. Note that this method will always return non-null.\n\n      loadedMeshInfo = this._createMeshInfo(parentMesh);\n    } else {\n      Logger.Warn(\"Could not find root node in model file.\");\n    }\n\n    return loadedMeshInfo;\n  };\n\n  WindowsMotionController.prototype._createMeshInfo = function (rootNode) {\n    var loadedMeshInfo = new LoadedMeshInfo();\n    var i;\n    loadedMeshInfo.rootNode = rootNode; // Reset the caches\n\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {}; // Button Meshes\n\n    for (i = 0; i < this._mapping.buttons.length; i++) {\n      var buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];\n\n      if (!buttonMeshName) {\n        Logger.Log(\"Skipping unknown button at index: \" + i + \" with mapped name: \" + this._mapping.buttons[i]);\n        continue;\n      }\n\n      var buttonMesh = getChildByName(rootNode, buttonMeshName);\n\n      if (!buttonMesh) {\n        Logger.Warn(\"Missing button mesh with name: \" + buttonMeshName);\n        continue;\n      }\n\n      var buttonMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(buttonMesh, \"VALUE\"),\n        pressed: getImmediateChildByName(buttonMesh, \"PRESSED\"),\n        unpressed: getImmediateChildByName(buttonMesh, \"UNPRESSED\")\n      };\n\n      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\n        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n        Logger.Warn(\"Missing button submesh under mesh with name: \" + buttonMeshName + \"(VALUE: \" + !!buttonMeshInfo.value + \", PRESSED: \" + !!buttonMeshInfo.pressed + \", UNPRESSED:\" + !!buttonMeshInfo.unpressed + \")\");\n      }\n    } // Axis Meshes\n\n\n    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\n      var axisMeshName = this._mapping.axisMeshNames[i];\n\n      if (!axisMeshName) {\n        Logger.Log(\"Skipping unknown axis at index: \" + i);\n        continue;\n      }\n\n      var axisMesh = getChildByName(rootNode, axisMeshName);\n\n      if (!axisMesh) {\n        Logger.Warn(\"Missing axis mesh with name: \" + axisMeshName);\n        continue;\n      }\n\n      var axisMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(axisMesh, \"VALUE\"),\n        min: getImmediateChildByName(axisMesh, \"MIN\"),\n        max: getImmediateChildByName(axisMesh, \"MAX\")\n      };\n\n      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\n        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\n        Logger.Warn(\"Missing axis submesh under mesh with name: \" + axisMeshName + \"(VALUE: \" + !!axisMeshInfo.value + \", MIN: \" + !!axisMeshInfo.min + \", MAX:\" + !!axisMeshInfo.max + \")\");\n      }\n    } // Pointing Ray\n\n\n    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\n\n    if (!loadedMeshInfo.pointingPoseNode) {\n      Logger.Warn(\"Missing pointing pose mesh with name: \" + this._mapping.pointingPoseMeshName);\n    } else {\n      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\n    }\n\n    return loadedMeshInfo; // Look through all children recursively. This will return null if no mesh exists with the given name.\n\n    function getChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name === name;\n      }, false)[0];\n    } // Look through only immediate children. This will return null if no mesh exists with the given name.\n\n\n    function getImmediateChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name == name;\n      }, true)[0];\n    }\n  };\n  /**\n   * Gets the ray of the controller in the direction the controller is pointing\n   * @param length the length the resulting ray should be\n   * @returns a ray in the direction the controller is pointing\n   */\n\n\n  WindowsMotionController.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n\n    var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\n\n    var origin = m.getTranslation();\n    var forward = new Vector3(0, 0, -1);\n    var forwardWorld = Vector3.TransformNormal(forward, m);\n    var direction = Vector3.Normalize(forwardWorld);\n    return new Ray(origin, direction, length);\n  };\n  /**\n   * Disposes of the controller\n   */\n\n\n  WindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onTrackpadChangedObservable.clear();\n    this.onTrackpadValuesChangedObservable.clear();\n  };\n  /**\n   * The base url used to load the left and right controller models\n   */\n\n\n  WindowsMotionController.MODEL_BASE_URL = \"https://controllers.babylonjs.com/microsoft/\";\n  /**\n   * The name of the left controller model file\n   */\n\n  WindowsMotionController.MODEL_LEFT_FILENAME = \"left.glb\";\n  /**\n   * The name of the right controller model file\n   */\n\n  WindowsMotionController.MODEL_RIGHT_FILENAME = \"right.glb\";\n  /**\n   * The controller name prefix for this controller type\n   */\n\n  WindowsMotionController.GAMEPAD_ID_PREFIX = \"Spatial Controller (Spatial Interaction Source) \";\n  /**\n   * The controller id pattern for this controller type\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n  WindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\n  return WindowsMotionController;\n}(WebVRController);\n\nexport { WindowsMotionController };\n/**\n * This class represents a new windows motion controller in XR.\n */\n\nvar XRWindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(XRWindowsMotionController, _super);\n  /**\n   * Construct a new XR-Based windows motion controller\n   *\n   * @param gamepadInfo the gamepad object from the browser\n   */\n\n\n  function XRWindowsMotionController(gamepadInfo) {\n    var _this = _super.call(this, gamepadInfo) || this;\n    /**\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\n     */\n\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: [\"trigger\", \"grip\", \"trackpad\", \"thumbstick\", \"menu\"],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        trigger: \"SELECT\",\n        menu: \"MENU\",\n        grip: \"GRASP\",\n        thumbstick: \"THUMBSTICK_PRESS\",\n        trackpad: \"TOUCHPAD_PRESS\"\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        trigger: \"onTriggerStateChangedObservable\",\n        menu: \"onSecondaryButtonStateChangedObservable\",\n        grip: \"onMainButtonStateChangedObservable\",\n        thumbstick: \"onThumbstickStateChangedObservable\",\n        trackpad: \"onTrackpadChangedObservable\"\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: [\"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\", \"THUMBSTICK_X\", \"THUMBSTICK_Y\"],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\n     * holds the thumbstick values (X,Y)\n     */\n\n    _this.thumbstickValues = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Fired when the thumbstick on this controller is clicked\n     */\n\n    _this.onThumbstickStateChangedObservable = new Observable();\n    /**\n     * Fired when the thumbstick on this controller is modified\n     */\n\n    _this.onThumbstickValuesChangedObservable = new Observable();\n    /**\n     * Fired when the touchpad button on this controller is modified\n     */\n\n    _this.onTrackpadChangedObservable = _this.onPadStateChangedObservable;\n    /**\n     * Fired when the touchpad values on this controller are modified\n     */\n\n    _this.onTrackpadValuesChangedObservable = _this.onPadValuesChangedObservable;\n    return _this;\n  }\n\n  Object.defineProperty(XRWindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\n     * Fired when the thumbstick button on this controller is modified\n     * here to prevent breaking changes\n     */\n    get: function get() {\n      return this.onThumbstickStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * updating the thumbstick(!) and not the trackpad.\n   * This is named this way due to the difference between WebVR and XR and to avoid\n   * changing the parent class.\n   */\n\n  XRWindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][2];\n      this.trackpad.y = this.browserGamepad[\"axes\"][3];\n      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\n   * Disposes the class with joy\n   */\n\n\n  XRWindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onThumbstickStateChangedObservable.clear();\n    this.onThumbstickValuesChangedObservable.clear();\n  };\n\n  return XRWindowsMotionController;\n}(WindowsMotionController);\n\nexport { XRWindowsMotionController };\n\nPoseEnabledControllerHelper._ControllerFactories.push({\n  canCreate: function canCreate(gamepadInfo) {\n    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\n  },\n  create: function create(gamepadInfo) {\n    return new WindowsMotionController(gamepadInfo);\n  }\n});","map":{"version":3,"mappings":"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","names":["Logger","Observable","Quaternion","Vector3","Mesh","Ray","SceneLoader","WebVRController","GenericController","PoseEnabledController","PoseEnabledControllerType","PoseEnabledControllerHelper","__extends","vrGamepad","_super","_this","buttons","buttonMeshNames","trigger","menu","grip","thumbstick","trackpad","buttonObservableNames","axisMeshNames","pointingPoseMeshName","POINTING_POSE","x","y","controllerType","WINDOWS","_loadedMeshInfo","Object","WindowsMotionController","onTriggerStateChangedObservable","onSecondaryButtonStateChangedObservable","onMainButtonStateChangedObservable","onPadStateChangedObservable","onTrackpadChangedObservable","onTrackpadValuesChangedObservable","browserGamepad","axes","_mapping","indexOf","notifyObservers","update","call","_updateTrackpad","axis","length","_lerpAxisTransform","buttonIdx","state","buttonName","observable","_lerpButtonTransform","value","buttonValue","meshInfo","buttonMeshes","unpressed","rotationQuaternion","pressed","SlerpToRef","LerpToRef","position","axisValue","axisMeshes","min","max","lerpValue","scene","meshLoaded","forceDefault","path","filename","IsPluginForExtensionAvailable","device","id","match","GAMEPAD_ID_PATTERN","hand","MODEL_LEFT_FILENAME","MODEL_RIGHT_FILENAME","MODEL_BASE_URL","Warn","MODEL_FILENAME","ImportMesh","meshes","_processModel","_defaultModel","rootNode","attachToMesh","message","Log","initControllerMesh","loadedMeshInfo","parentMesh","childMesh","i","mesh","parent","isPickable","setParent","_createMeshInfo","LoadedMeshInfo","buttonMeshName","buttonMesh","getChildByName","buttonMeshInfo","index","getImmediateChildByName","axisMeshName","axisMesh","axisMeshInfo","pointingPoseNode","_pointingPoseNode","node","name","getChildren","n","getForwardRay","m","getWorldMatrix","origin","getTranslation","forward","forwardWorld","TransformNormal","direction","Normalize","dispose","clear","gamepadInfo","onPadValuesChangedObservable","XRWindowsMotionController","onThumbstickStateChangedObservable","thumbstickValues","onThumbstickValuesChangedObservable","_ControllerFactories","push","canCreate","GAMEPAD_ID_PREFIX","create"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Gamepads/Controllers/windowsMotionController.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Node } from \"../../node\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { WebVRController } from \"./webVRController\";\r\nimport { GenericController } from \"./genericController\";\r\nimport type { ExtendedGamepadButton } from \"./poseEnabledController\";\r\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController\";\r\nimport type { StickValues } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\r\nclass LoadedMeshInfo {\r\n    /**\r\n     * Root of the mesh\r\n     */\r\n    public rootNode: AbstractMesh;\r\n    /**\r\n     * Node of the mesh corresponding to the direction the ray should be cast from the controller\r\n     */\r\n    public pointingPoseNode: TransformNode;\r\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\r\n    public buttonMeshes: { [id: string]: IButtonMeshInfo } = {};\r\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\r\n    public axisMeshes: { [id: number]: IAxisMeshInfo } = {};\r\n}\r\n\r\n/**\r\n * Defines the IMeshInfo object that describes information a webvr controller mesh\r\n */\r\ninterface IMeshInfo {\r\n    /**\r\n     * Index of the mesh inside the root mesh\r\n     */\r\n    index: number;\r\n    /**\r\n     * The mesh\r\n     */\r\n    value: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IButtonMeshInfo object that describes a button mesh\r\n */\r\ninterface IButtonMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be displayed when pressed\r\n     */\r\n    pressed: TransformNode;\r\n    /**\r\n     * The mesh that should be displayed when not pressed\r\n     */\r\n    unpressed: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IAxisMeshInfo object that describes an axis mesh\r\n */\r\ninterface IAxisMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be set when at its min\r\n     */\r\n    min: TransformNode;\r\n    /**\r\n     * The mesh that should be set when at its max\r\n     */\r\n    max: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\r\nexport class WindowsMotionController extends WebVRController {\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/microsoft/\";\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = \"left.glb\";\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = \"right.glb\";\r\n\r\n    /**\r\n     * The controller name prefix for this controller type\r\n     */\r\n    public static readonly GAMEPAD_ID_PREFIX: string = \"Spatial Controller (Spatial Interaction Source) \";\r\n    /**\r\n     * The controller id pattern for this controller type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static readonly GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\r\n\r\n    private _loadedMeshInfo: Nullable<LoadedMeshInfo>;\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: [\"thumbstick\", \"trigger\", \"grip\", \"menu\", \"trackpad\"],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            trigger: \"SELECT\",\r\n            menu: \"MENU\",\r\n            grip: \"GRASP\",\r\n            thumbstick: \"THUMBSTICK_PRESS\",\r\n            trackpad: \"TOUCHPAD_PRESS\",\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            trigger: \"onTriggerStateChangedObservable\",\r\n            menu: \"onSecondaryButtonStateChangedObservable\",\r\n            grip: \"onMainButtonStateChangedObservable\",\r\n            thumbstick: \"onPadStateChangedObservable\",\r\n            trackpad: \"onTrackpadChangedObservable\",\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\"THUMBSTICK_X\", \"THUMBSTICK_Y\", \"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\"],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE,\r\n    };\r\n\r\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\r\n    public onTrackpadChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = new Observable<StickValues>();\r\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\r\n    public trackpad: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Creates a new WindowsMotionController from a gamepad\r\n     * @param vrGamepad the gamepad that the controller should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n        this.controllerType = PoseEnabledControllerType.WINDOWS;\r\n        this._loadedMeshInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\r\n    public get onTriggerButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTriggerStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\r\n    public get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onSecondaryButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\r\n    public get onGripButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onMainButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onPadStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public get onTouchpadButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTrackpadChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public get onTouchpadValuesChangedObservable(): Observable<StickValues> {\r\n        return this.onTrackpadValuesChangedObservable;\r\n    }\r\n\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_X\")];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_Y\")];\r\n            this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once per frame by the engine.\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this.browserGamepad.axes) {\r\n            this._updateTrackpad();\r\n            // Only need to animate axes if there is a loaded mesh\r\n            if (this._loadedMeshInfo) {\r\n                for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\r\n                    this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once for each button that changed state since the last frame\r\n     * @param buttonIdx Which button index changed\r\n     * @param state New state of the button\r\n     */\r\n    protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton) {\r\n        const buttonName = this._mapping.buttons[buttonIdx];\r\n        if (!buttonName) {\r\n            return;\r\n        }\r\n\r\n        // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\r\n        this._updateTrackpad();\r\n\r\n        // Only emit events for buttons that we know how to map from index to name\r\n        const observable = (<any>this)[(<any>this._mapping.buttonObservableNames)[buttonName]];\r\n        if (observable) {\r\n            observable.notifyObservers(state);\r\n        }\r\n\r\n        this._lerpButtonTransform(buttonName, state.value);\r\n    }\r\n\r\n    /**\r\n     * Moves the buttons on the controller mesh based on their current state\r\n     * @param buttonName the name of the button to move\r\n     * @param buttonValue the value of the button which determines the buttons new position\r\n     */\r\n    protected _lerpButtonTransform(buttonName: string, buttonValue: number) {\r\n        // If there is no loaded mesh, there is nothing to transform.\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        const meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\r\n\r\n        if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axis the index of the axis\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @hidden\r\n     */\r\n    protected _lerpAxisTransform(axis: number, axisValue: number) {\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        const meshInfo = this._loadedMeshInfo.axisMeshes[axis];\r\n        if (!meshInfo) {\r\n            return;\r\n        }\r\n\r\n        if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = axisValue * 0.5 + 0.5;\r\n        Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n     * @param scene scene in which to add meshes\r\n     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n     * @param forceDefault\r\n     */\r\n    public initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault = false) {\r\n        let path: string;\r\n        let filename: string;\r\n\r\n        // Checking if GLB loader is present\r\n        if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\r\n            // Determine the device specific folder based on the ID suffix\r\n            let device = \"default\";\r\n            if (this.id && !forceDefault) {\r\n                const match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\r\n                device = (match && match[0]) || device;\r\n            }\r\n\r\n            // Hand\r\n            if (this.hand === \"left\") {\r\n                filename = WindowsMotionController.MODEL_LEFT_FILENAME;\r\n            } else {\r\n                // Right is the default if no hand is specified\r\n                filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\r\n            }\r\n\r\n            path = WindowsMotionController.MODEL_BASE_URL + device + \"/\";\r\n        } else {\r\n            Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\r\n            path = GenericController.MODEL_BASE_URL;\r\n            filename = GenericController.MODEL_FILENAME;\r\n        }\r\n\r\n        SceneLoader.ImportMesh(\r\n            \"\",\r\n            path,\r\n            filename,\r\n            scene,\r\n            (meshes: AbstractMesh[]) => {\r\n                // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\r\n                this._loadedMeshInfo = this._processModel(scene, meshes);\r\n\r\n                if (!this._loadedMeshInfo) {\r\n                    return;\r\n                }\r\n\r\n                this._defaultModel = this._loadedMeshInfo.rootNode;\r\n                this.attachToMesh(this._defaultModel);\r\n\r\n                if (meshLoaded) {\r\n                    meshLoaded(this._defaultModel);\r\n                }\r\n            },\r\n            null,\r\n            (scene: Scene, message: string) => {\r\n                Logger.Log(message);\r\n                Logger.Warn(\"Failed to retrieve controller model from the remote server: \" + path + filename);\r\n                if (!forceDefault) {\r\n                    this.initControllerMesh(scene, meshLoaded, true);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n     * can be transformed by button presses and axes values, based on this._mapping.\r\n     *\r\n     * @param scene scene in which the meshes exist\r\n     * @param meshes list of meshes that make up the controller model to process\r\n     * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n     */\r\n    private _processModel(scene: Scene, meshes: AbstractMesh[]): Nullable<LoadedMeshInfo> {\r\n        let loadedMeshInfo = null;\r\n\r\n        // Create a new mesh to contain the glTF hierarchy\r\n        const parentMesh = new Mesh(this.id + \" \" + this.hand, scene);\r\n\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        let childMesh: Nullable<AbstractMesh> = null;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            if (!mesh.parent) {\r\n                // Exclude controller meshes from picking results\r\n                mesh.isPickable = false;\r\n\r\n                // Handle root node, attach to the new parentMesh\r\n                childMesh = mesh;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (childMesh) {\r\n            childMesh.setParent(parentMesh);\r\n\r\n            // Create our mesh info. Note that this method will always return non-null.\r\n            loadedMeshInfo = this._createMeshInfo(parentMesh);\r\n        } else {\r\n            Logger.Warn(\"Could not find root node in model file.\");\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n    }\r\n\r\n    private _createMeshInfo(rootNode: AbstractMesh): LoadedMeshInfo {\r\n        const loadedMeshInfo = new LoadedMeshInfo();\r\n        let i;\r\n        loadedMeshInfo.rootNode = rootNode;\r\n\r\n        // Reset the caches\r\n        loadedMeshInfo.buttonMeshes = {};\r\n        loadedMeshInfo.axisMeshes = {};\r\n\r\n        // Button Meshes\r\n        for (i = 0; i < this._mapping.buttons.length; i++) {\r\n            const buttonMeshName = (<any>this._mapping.buttonMeshNames)[this._mapping.buttons[i]];\r\n            if (!buttonMeshName) {\r\n                Logger.Log(\"Skipping unknown button at index: \" + i + \" with mapped name: \" + this._mapping.buttons[i]);\r\n                continue;\r\n            }\r\n\r\n            const buttonMesh = getChildByName(rootNode, buttonMeshName);\r\n            if (!buttonMesh) {\r\n                Logger.Warn(\"Missing button mesh with name: \" + buttonMeshName);\r\n                continue;\r\n            }\r\n\r\n            const buttonMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(buttonMesh, \"VALUE\"),\r\n                pressed: getImmediateChildByName(buttonMesh, \"PRESSED\"),\r\n                unpressed: getImmediateChildByName(buttonMesh, \"UNPRESSED\"),\r\n            };\r\n            if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\r\n                loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                Logger.Warn(\r\n                    \"Missing button submesh under mesh with name: \" +\r\n                        buttonMeshName +\r\n                        \"(VALUE: \" +\r\n                        !!buttonMeshInfo.value +\r\n                        \", PRESSED: \" +\r\n                        !!buttonMeshInfo.pressed +\r\n                        \", UNPRESSED:\" +\r\n                        !!buttonMeshInfo.unpressed +\r\n                        \")\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Axis Meshes\r\n        for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\r\n            const axisMeshName = this._mapping.axisMeshNames[i];\r\n            if (!axisMeshName) {\r\n                Logger.Log(\"Skipping unknown axis at index: \" + i);\r\n                continue;\r\n            }\r\n\r\n            const axisMesh = getChildByName(rootNode, axisMeshName);\r\n            if (!axisMesh) {\r\n                Logger.Warn(\"Missing axis mesh with name: \" + axisMeshName);\r\n                continue;\r\n            }\r\n\r\n            const axisMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(axisMesh, \"VALUE\"),\r\n                min: getImmediateChildByName(axisMesh, \"MIN\"),\r\n                max: getImmediateChildByName(axisMesh, \"MAX\"),\r\n            };\r\n            if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\r\n                loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\r\n                Logger.Warn(\r\n                    \"Missing axis submesh under mesh with name: \" +\r\n                        axisMeshName +\r\n                        \"(VALUE: \" +\r\n                        !!axisMeshInfo.value +\r\n                        \", MIN: \" +\r\n                        !!axisMeshInfo.min +\r\n                        \", MAX:\" +\r\n                        !!axisMeshInfo.max +\r\n                        \")\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Pointing Ray\r\n        loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\r\n        if (!loadedMeshInfo.pointingPoseNode) {\r\n            Logger.Warn(\"Missing pointing pose mesh with name: \" + this._mapping.pointingPoseMeshName);\r\n        } else {\r\n            this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n\r\n        // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n        function getChildByName(node: Node, name: string) {\r\n            return <TransformNode>node.getChildren((n) => n.name === name, false)[0];\r\n        }\r\n        // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n        function getImmediateChildByName(node: Node, name: string): TransformNode {\r\n            return <TransformNode>node.getChildren((n) => n.name == name, true)[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ray of the controller in the direction the controller is pointing\r\n     * @param length the length the resulting ray should be\r\n     * @returns a ray in the direction the controller is pointing\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\r\n            return super.getForwardRay(length);\r\n        }\r\n\r\n        const m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\r\n        const origin = m.getTranslation();\r\n\r\n        const forward = new Vector3(0, 0, -1);\r\n        const forwardWorld = Vector3.TransformNormal(forward, m);\r\n\r\n        const direction = Vector3.Normalize(forwardWorld);\r\n\r\n        return new Ray(origin, direction, length);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the controller\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTrackpadChangedObservable.clear();\r\n        this.onTrackpadValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\r\nexport class XRWindowsMotionController extends WindowsMotionController {\r\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: [\"trigger\", \"grip\", \"trackpad\", \"thumbstick\", \"menu\"],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            trigger: \"SELECT\",\r\n            menu: \"MENU\",\r\n            grip: \"GRASP\",\r\n            thumbstick: \"THUMBSTICK_PRESS\",\r\n            trackpad: \"TOUCHPAD_PRESS\",\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            trigger: \"onTriggerStateChangedObservable\",\r\n            menu: \"onSecondaryButtonStateChangedObservable\",\r\n            grip: \"onMainButtonStateChangedObservable\",\r\n            thumbstick: \"onThumbstickStateChangedObservable\",\r\n            trackpad: \"onTrackpadChangedObservable\",\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\", \"THUMBSTICK_X\", \"THUMBSTICK_Y\"],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE,\r\n    };\r\n\r\n    /**\r\n     * Construct a new XR-Based windows motion controller\r\n     *\r\n     * @param gamepadInfo the gamepad object from the browser\r\n     */\r\n    constructor(gamepadInfo: any) {\r\n        super(gamepadInfo);\r\n    }\r\n\r\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\r\n    public thumbstickValues: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\r\n    public onThumbstickStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\r\n    public onThumbstickValuesChangedObservable = new Observable<StickValues>();\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public onTrackpadChangedObservable = this.onPadStateChangedObservable;\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onThumbstickStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * updating the thumbstick(!) and not the trackpad.\r\n     * This is named this way due to the difference between WebVR and XR and to avoid\r\n     * changing the parent class.\r\n     */\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][2];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][3];\r\n            this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the class with joy\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onThumbstickStateChangedObservable.clear();\r\n        this.onThumbstickValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\nPoseEnabledControllerHelper._ControllerFactories.push({\r\n    canCreate: (gamepadInfo) => {\r\n        return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\r\n    },\r\n    create: (gamepadInfo) => {\r\n        return new WindowsMotionController(gamepadInfo);\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module"}