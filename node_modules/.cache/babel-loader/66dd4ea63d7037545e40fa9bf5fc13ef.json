{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess.js\";\nimport { BlurPostProcess } from \"./blurPostProcess.js\";\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\n */\n\nvar BloomEffect =\n/** @class */\nfunction (_super) {\n  __extends(BloomEffect, _super);\n  /**\n   * Creates a new instance of @see BloomEffect\n   * @param scene The scene the effect belongs to.\n   * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\n   * @param bloomWeight The the strength of bloom.\n   * @param bloomKernel The size of the kernel to be used when applying the blur.\n   * @param pipelineTextureType The type of texture to be used when performing the post processing.\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   */\n\n\n  function BloomEffect(scene, _bloomScale, bloomWeight, bloomKernel, pipelineTextureType, blockCompilation) {\n    if (pipelineTextureType === void 0) {\n      pipelineTextureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), \"bloom\", function () {\n      return _this._effects;\n    }, true) || this;\n\n    _this._bloomScale = _bloomScale;\n    /**\n     * @hidden Internal\n     */\n\n    _this._effects = [];\n    _this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurX.alwaysForcePOT = true;\n    _this._blurX.autoClear = false;\n    _this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurY.alwaysForcePOT = true;\n    _this._blurY.autoClear = false;\n    _this.kernel = bloomKernel;\n    _this._effects = [_this._downscale, _this._blurX, _this._blurY];\n    _this._merge = new BloomMergePostProcess(\"bloomMerge\", _this._downscale, _this._blurY, bloomWeight, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._merge.autoClear = false;\n\n    _this._effects.push(_this._merge);\n\n    return _this;\n  }\n\n  Object.defineProperty(BloomEffect.prototype, \"threshold\", {\n    /**\n     * The luminance threshold to find bright areas of the image to bloom.\n     */\n    get: function get() {\n      return this._downscale.threshold;\n    },\n    set: function set(value) {\n      this._downscale.threshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"weight\", {\n    /**\n     * The strength of the bloom.\n     */\n    get: function get() {\n      return this._merge.weight;\n    },\n    set: function set(value) {\n      this._merge.weight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"kernel\", {\n    /**\n     * Specifies the size of the bloom blur kernel, relative to the final output size\n     */\n    get: function get() {\n      return this._blurX.kernel / this._bloomScale;\n    },\n    set: function set(value) {\n      this._blurX.kernel = value * this._bloomScale;\n      this._blurY.kernel = value * this._bloomScale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes each of the internal effects for a given camera.\n   * @param camera The camera to dispose the effect on.\n   */\n\n  BloomEffect.prototype.disposeEffects = function (camera) {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].dispose(camera);\n    }\n  };\n  /**\n   * @hidden Internal\n   */\n\n\n  BloomEffect.prototype._updateEffects = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].updateEffect();\n    }\n  };\n  /**\n   * Internal\n   * @returns if all the contained post processes are ready.\n   * @hidden\n   */\n\n\n  BloomEffect.prototype._isReady = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      if (!this._effects[effectIndex].isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return BloomEffect;\n}(PostProcessRenderEffect);\n\nexport { BloomEffect };","map":{"version":3,"mappings":"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","names":["PostProcessRenderEffect","ExtractHighlightsPostProcess","BlurPostProcess","BloomMergePostProcess","Vector2","Texture","__extends","scene","_bloomScale","bloomWeight","bloomKernel","pipelineTextureType","blockCompilation","_super","getEngine","_this","_effects","_downscale","BILINEAR_SAMPLINGMODE","_blurX","undefined","alwaysForcePOT","autoClear","_blurY","kernel","_merge","push","Object","BloomEffect","threshold","value","weight","camera","effectIndex","length","dispose","updateEffect","isReady"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/bloomEffect.ts"],"sourcesContent":["import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class BloomEffect extends PostProcessRenderEffect {\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _downscale: ExtractHighlightsPostProcess;\r\n    private _blurX: BlurPostProcess;\r\n    private _blurY: BlurPostProcess;\r\n    private _merge: BloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._downscale.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._downscale.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._merge.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._merge.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._blurX.kernel / this._bloomScale;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._blurX.kernel = value * this._bloomScale;\r\n        this._blurY.kernel = value * this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomEffect\r\n     * @param scene The scene the effect belongs to.\r\n     * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param bloomWeight The the strength of bloom.\r\n     * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(scene: Scene, private _bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType = 0, blockCompilation = false) {\r\n        super(\r\n            scene.getEngine(),\r\n            \"bloom\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n        this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\r\n\r\n        this._blurX = new BlurPostProcess(\r\n            \"horizontal blur\",\r\n            new Vector2(1.0, 0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurX.alwaysForcePOT = true;\r\n        this._blurX.autoClear = false;\r\n\r\n        this._blurY = new BlurPostProcess(\r\n            \"vertical blur\",\r\n            new Vector2(0, 1.0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurY.alwaysForcePOT = true;\r\n        this._blurY.autoClear = false;\r\n\r\n        this.kernel = bloomKernel;\r\n\r\n        this._effects = [this._downscale, this._blurX, this._blurY];\r\n\r\n        this._merge = new BloomMergePostProcess(\r\n            \"bloomMerge\",\r\n            this._downscale,\r\n            this._blurY,\r\n            bloomWeight,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            blockCompilation\r\n        );\r\n        this._merge.autoClear = false;\r\n        this._effects.push(this._merge);\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @hidden\r\n     */\r\n    public _isReady() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            if (!this._effects[effectIndex].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}