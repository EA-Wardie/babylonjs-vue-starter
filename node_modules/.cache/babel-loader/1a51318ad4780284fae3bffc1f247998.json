{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { ThinEngine } from \"../../Engines/thinEngine.js\";\n\nThinEngine.prototype.updateVideoTexture = function (texture, video, invertY) {\n  if (!texture || texture._isDisabled) {\n    return;\n  }\n\n  var wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n  this._unpackFlipY(!invertY); // Video are upside down by default\n\n\n  try {\n    // Testing video texture support\n    if (this._videoTextureSupported === undefined) {\n      // clear old errors just in case.\n      this._gl.getError();\n\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n\n      if (this._gl.getError() !== 0) {\n        this._videoTextureSupported = false;\n      } else {\n        this._videoTextureSupported = true;\n      }\n    } // Copy video through the current working canvas if video texture is not supported\n\n\n    if (!this._videoTextureSupported) {\n      if (!texture._workingCanvas) {\n        texture._workingCanvas = this.createCanvas(texture.width, texture.height);\n\n        var context_1 = texture._workingCanvas.getContext(\"2d\");\n\n        if (!context_1) {\n          throw new Error(\"Unable to get 2d context\");\n        }\n\n        texture._workingContext = context_1;\n        texture._workingCanvas.width = texture.width;\n        texture._workingCanvas.height = texture.height;\n      }\n\n      texture._workingContext.clearRect(0, 0, texture.width, texture.height);\n\n      texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\n\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas);\n    } else {\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n    }\n\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(this._gl.TEXTURE_2D);\n    }\n\n    if (!wasPreviouslyBound) {\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n    } //    this.resetTextureCache();\n\n\n    texture.isReady = true;\n  } catch (ex) {\n    // Something unexpected\n    // Let's disable the texture\n    texture._isDisabled = true;\n  }\n};","map":{"version":3,"mappings":"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","names":["ThinEngine","prototype","updateVideoTexture","texture","video","invertY","_isDisabled","wasPreviouslyBound","_bindTextureDirectly","_gl","TEXTURE_2D","_unpackFlipY","_videoTextureSupported","undefined","getError","texImage2D","RGBA","UNSIGNED_BYTE","_workingCanvas","createCanvas","width","height","context_1","getContext","Error","_workingContext","clearRect","drawImage","videoWidth","videoHeight","generateMipMaps","generateMipmap","isReady","ex"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.videoTexture.ts"],"sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(!invertY); // Video are upside down by default\r\n\r\n    try {\r\n        // Testing video texture support\r\n        if (this._videoTextureSupported === undefined) {\r\n            // clear old errors just in case.\r\n            this._gl.getError();\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\r\n\r\n            if (this._gl.getError() !== 0) {\r\n                this._videoTextureSupported = false;\r\n            } else {\r\n                this._videoTextureSupported = true;\r\n            }\r\n        }\r\n\r\n        // Copy video through the current working canvas if video texture is not supported\r\n        if (!this._videoTextureSupported) {\r\n            if (!texture._workingCanvas) {\r\n                texture._workingCanvas = this.createCanvas(texture.width, texture.height);\r\n                const context = texture._workingCanvas.getContext(\"2d\");\r\n\r\n                if (!context) {\r\n                    throw new Error(\"Unable to get 2d context\");\r\n                }\r\n\r\n                texture._workingContext = context;\r\n                texture._workingCanvas.width = texture.width;\r\n                texture._workingCanvas.height = texture.height;\r\n            }\r\n\r\n            texture._workingContext!.clearRect(0, 0, texture.width, texture.height);\r\n            texture._workingContext!.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas as TexImageSource);\r\n        } else {\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n        }\r\n\r\n        if (!wasPreviouslyBound) {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n        }\r\n        //    this.resetTextureCache();\r\n        texture.isReady = true;\r\n    } catch (ex) {\r\n        // Something unexpected\r\n        // Let's disable the texture\r\n        texture._isDisabled = true;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}