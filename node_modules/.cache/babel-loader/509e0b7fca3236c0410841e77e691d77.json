{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color4, TmpColors } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/gpuRenderParticles.fragment.js\";\nimport \"../Shaders/gpuRenderParticles.vertex.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * This represents a GPU particle system in Babylon\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\n */\n\nvar GPUParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(GPUParticleSystem, _super);\n  /**\n   * Instantiates a GPU particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param options The options used to create the system\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   */\n\n\n  function GPUParticleSystem(name, options, sceneOrEngine, customEffect, isAnimationSheetEnabled) {\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    var _this = _super.call(this, name) || this;\n    /**\n     * The layer mask we are rendering the particles through.\n     */\n\n\n    _this.layerMask = 0x0fffffff;\n    _this._accumulatedCount = 0;\n    _this._targetIndex = 0;\n    _this._currentRenderId = -1;\n    _this._currentRenderingCameraUniqueId = -1;\n    _this._started = false;\n    _this._stopped = false;\n    _this._timeDelta = 0;\n    _this._actualFrame = 0;\n    _this._rawTextureWidth = 256;\n    /**\n     * An event triggered when the system is disposed.\n     */\n\n    _this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n\n    _this.onStoppedObservable = new Observable();\n    /**\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n     * to override the particles.\n     */\n\n    _this.forceDepthWrite = false;\n    _this._preWarmDone = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space.\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, _this._engine.isNDCHalfZRange);\n    }\n\n    if (_this._engine.getCaps().supportComputeShaders) {\n      if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\n        throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\n      }\n\n      _this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\"))(_this, _this._engine);\n    } else {\n      if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\n        throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\n      }\n\n      _this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\"))(_this, _this._engine);\n    }\n\n    _this._customWrappers = {\n      0: new DrawWrapper(_this._engine)\n    };\n    _this._customWrappers[0].effect = customEffect;\n    _this._drawWrappers = {\n      0: new DrawWrapper(_this._engine)\n    };\n\n    if (_this._drawWrappers[0].drawContext) {\n      _this._drawWrappers[0].drawContext.useInstancing = true;\n    } // Setup the default processing configuration to the scene.\n\n\n    _this._attachImageProcessingConfiguration(null);\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (!options.randomTextureSize) {\n      delete options.randomTextureSize;\n    }\n\n    var fullOptions = __assign({\n      capacity: 50000,\n      randomTextureSize: _this._engine.getCaps().maxTextureSize\n    }, options);\n\n    var optionsAsNumber = options;\n\n    if (isFinite(optionsAsNumber)) {\n      fullOptions.capacity = optionsAsNumber;\n    }\n\n    _this._capacity = fullOptions.capacity;\n    _this._activeCount = fullOptions.capacity;\n    _this._currentActiveCount = 0;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    _this.particleEmitterType = new BoxParticleEmitter(); // Random data\n\n    var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n    var d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture.name = \"GPUParticleSystem_random1\";\n    _this._randomTexture.wrapU = 1;\n    _this._randomTexture.wrapV = 1;\n    d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture2.name = \"GPUParticleSystem_random2\";\n    _this._randomTexture2.wrapU = 1;\n    _this._randomTexture2.wrapV = 1;\n    _this._randomTextureSize = maxTextureSize;\n    return _this;\n  }\n\n  Object.defineProperty(GPUParticleSystem, \"IsSupported\", {\n    /**\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\n     */\n    get: function get() {\n      if (!EngineStore.LastCreatedEngine) {\n        return false;\n      }\n\n      var caps = EngineStore.LastCreatedEngine.getCaps();\n      return caps.supportTransformFeedbacks || caps.supportComputeShaders;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n\n  GPUParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"activeParticleCount\", {\n    /**\n     * Gets or set the number of active particles\n     */\n    get: function get() {\n      return this._activeCount;\n    },\n    set: function set(value) {\n      this._activeCount = Math.min(value, this._capacity);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Is this system ready to be used/rendered\n   * @return true if the system is ready\n   */\n\n  GPUParticleSystem.prototype.isReady = function () {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n\n    if (!this._platform.isUpdateBufferCreated()) {\n      this._recreateUpdateEffect();\n\n      return false;\n    }\n\n    return this._platform.isUpdateBufferReady();\n  };\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n\n\n  GPUParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n  /**\n   * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\n   * @returns True if it has been stopped, otherwise false.\n   */\n\n\n  GPUParticleSystem.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n\n\n  GPUParticleSystem.prototype.isStopping = function () {\n    return false; // Stop is immediate on GPU\n  };\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n\n\n  GPUParticleSystem.prototype.getActiveCount = function () {\n    return this._currentActiveCount;\n  };\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n\n\n  GPUParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    }\n\n    this._started = true;\n    this._stopped = false;\n    this._preWarmDone = false; // Animations\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\n   * Stops the particle system.\n   */\n\n\n  GPUParticleSystem.prototype.stop = function () {\n    if (this._stopped) {\n      return;\n    }\n\n    this._stopped = true;\n  };\n  /**\n   * Remove all active particles\n   */\n\n\n  GPUParticleSystem.prototype.reset = function () {\n    this._releaseBuffers();\n\n    this._platform.releaseVertexBuffers();\n\n    this._currentActiveCount = 0;\n    this._targetIndex = 0;\n  };\n  /**\n   * Returns the string \"GPUParticleSystem\"\n   * @returns a string containing the class name\n   */\n\n\n  GPUParticleSystem.prototype.getClassName = function () {\n    return \"GPUParticleSystem\";\n  };\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n\n\n  GPUParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a, _b;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n  };\n\n  GPUParticleSystem.prototype._getCustomDrawWrapper = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n  };\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n\n\n  GPUParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\n     * Observable that will be called just before the particles are drawn\n     */\n    get: function get() {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GPUParticleSystem.prototype, \"vertexShaderName\", {\n    /**\n     * Gets the name of the particle vertex shader\n     */\n    get: function get() {\n      return \"gpuRenderParticles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  GPUParticleSystem.prototype._removeGradientAndTexture = function (gradient, gradients, texture) {\n    _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addColorGradient = function (gradient, color1) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1);\n\n    this._colorGradients.push(colorGradient);\n\n    this._refreshColorGradient(true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshColorGradient = function (reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (this._colorGradients) {\n      if (reorder) {\n        this._colorGradients.sort(function (a, b) {\n          if (a.gradient < b.gradient) {\n            return -1;\n          } else if (a.gradient > b.gradient) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      if (this._colorGradientsTexture) {\n        this._colorGradientsTexture.dispose();\n\n        this._colorGradientsTexture = null;\n      }\n    }\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  GPUParticleSystem.prototype.forceRefreshGradients = function () {\n    this._refreshColorGradient();\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n\n    this.reset();\n  };\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeColorGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n\n    this._colorGradientsTexture = null;\n    return this;\n  };\n  /**\n   * Resets the draw wrappers cache\n   */\n\n\n  GPUParticleSystem.prototype.resetDrawCache = function () {\n    var _a;\n\n    for (var blendMode in this._drawWrappers) {\n      var drawWrapper = this._drawWrappers[blendMode];\n      (_a = drawWrapper.drawContext) === null || _a === void 0 ? void 0 : _a.reset();\n    }\n  };\n\n  GPUParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor) {\n    var valueGradient = new FactorGradient(gradient, factor);\n    factorGradients.push(valueGradient);\n\n    this._releaseBuffers();\n  };\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addSizeGradient = function (gradient, factor) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n\n    this._sizeGradientsTexture = null;\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshFactorGradient = function (factorGradients, textureName, reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (!factorGradients) {\n      return;\n    }\n\n    if (reorder) {\n      factorGradients.sort(function (a, b) {\n        if (a.gradient < b.gradient) {\n          return -1;\n        } else if (a.gradient > b.gradient) {\n          return 1;\n        }\n\n        return 0;\n      });\n    }\n\n    var that = this;\n\n    if (that[textureName]) {\n      that[textureName].dispose();\n      that[textureName] = null;\n    }\n  };\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n\n    this._angularSpeedGradientsTexture = null;\n    return this;\n  };\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addVelocityGradient = function (gradient, factor) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n\n    this._velocityGradientsTexture = null;\n    return this;\n  };\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n\n    this._limitVelocityGradientsTexture = null;\n    return this;\n  };\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addDragGradient = function (gradient, factor) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n\n    this._dragGradientsTexture = null;\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addEmitRateGradient = function () {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeEmitRateGradient = function () {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addStartSizeGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeStartSizeGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addColorRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeColorRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addAlphaRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeAlphaRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.addRampGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeRampGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the list of ramp gradients\n   */\n\n\n  GPUParticleSystem.prototype.getRampGradients = function () {\n    return null;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"useRampGradients\", {\n    /**\n     * Not supported by GPUParticleSystem\n     * Gets or sets a boolean indicating that ramp gradients must be used\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\n     */\n    get: function get() {\n      //Not supported by GPUParticleSystem\n      return false;\n    },\n    set: function set(value) {//Not supported by GPUParticleSystem\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n  GPUParticleSystem.prototype.addLifeTimeGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n\n\n  GPUParticleSystem.prototype.removeLifeTimeGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n\n  GPUParticleSystem.prototype._reset = function () {\n    this._releaseBuffers();\n  };\n\n  GPUParticleSystem.prototype._createVertexBuffers = function (updateBuffer, renderBuffer, spriteSource) {\n    var renderVertexBuffers = {};\n    renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n    var offset = 3;\n    renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n    offset += 3;\n    renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    offset += 4; // seed\n\n    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n    }\n\n    offset += 3; // direction\n\n    if (this._platform.alignDataInBuffer) {\n      offset += 1;\n    }\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      offset += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n\n    if (!this._colorGradientsTexture) {\n      renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n      offset += 4;\n    }\n\n    if (!this._isBillboardBased) {\n      renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n\n      renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n\n    renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n\n    if (this._angularSpeedGradientsTexture) {\n      offset++;\n    } else {\n      offset += 2;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n      offset += 1;\n\n      if (this.spriteRandomStartCell) {\n        renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n      }\n    }\n\n    renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n    renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n\n    this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\n\n    this.resetDrawCache();\n  };\n\n  GPUParticleSystem.prototype._initialize = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (this._buffer0 && !force) {\n      return;\n    }\n\n    var engine = this._engine;\n    var data = new Array();\n    this._attributesStrideSize = 21;\n    this._targetIndex = 0;\n\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 1;\n    }\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._attributesStrideSize += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n\n    if (!this.isBillboardBased) {\n      this._attributesStrideSize += 3;\n\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n\n    if (this._colorGradientsTexture) {\n      this._attributesStrideSize -= 4;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._attributesStrideSize -= 1;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._attributesStrideSize += 1;\n\n      if (this.spriteRandomStartCell) {\n        this._attributesStrideSize += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      this._attributesStrideSize += 6;\n\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 2;\n      }\n    }\n\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3); // round to multiple of 4\n    }\n\n    var usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n    var tmpVector = TmpVectors.Vector3[0];\n    var offset = 0;\n\n    for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n      // position\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0); // Age\n\n      data.push(0.0); // create the particle as a dead one to create a new one at start\n      // Size\n\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0); // life\n\n      data.push(0.0); // Seed\n\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random()); // direction\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } else {\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      }\n\n      if (this._platform.alignDataInBuffer) {\n        data.push(0.0); // dummy0\n      }\n\n      offset += 16; // position, age, size, life, seed, direction, dummy0\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy1\n        }\n\n        offset += 4;\n      }\n\n      if (!this._colorGradientsTexture) {\n        // color\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        offset += 4;\n      }\n\n      if (!this.isBillboardBased) {\n        // initialDirection\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy2\n        }\n\n        offset += 4;\n      }\n\n      if (this.noiseTexture) {\n        // Random coordinates for reading into noise texture\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy3\n        }\n\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy4\n        }\n\n        offset += 8;\n      } // angle\n\n\n      data.push(0.0);\n      offset += 1;\n\n      if (!this._angularSpeedGradientsTexture) {\n        data.push(0.0);\n        offset += 1;\n      }\n\n      if (this._isAnimationSheetEnabled) {\n        data.push(0.0);\n        offset += 1;\n\n        if (this.spriteRandomStartCell) {\n          data.push(0.0);\n          offset += 1;\n        }\n      }\n\n      if (this._platform.alignDataInBuffer) {\n        var numDummies = 3 - (offset + 3 & 3);\n        offset += numDummies;\n\n        while (numDummies-- > 0) {\n          data.push(0.0);\n        }\n      }\n    } // Sprite data\n\n\n    var spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\n\n    var bufferData1 = this._platform.createParticleBuffer(data);\n\n    var bufferData2 = this._platform.createParticleBuffer(data); // Buffers\n\n\n    this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\n    this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\n    this._spriteBuffer = new Buffer(engine, spriteData, false, 4); // Update & Render vertex buffers\n\n    this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\n\n    this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer); // Links\n\n\n    this._sourceBuffer = this._buffer0;\n    this._targetBuffer = this._buffer1;\n  };\n  /** @hidden */\n\n\n  GPUParticleSystem.prototype._recreateUpdateEffect = function () {\n    var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n\n    if (this._isBillboardBased) {\n      defines += \"\\n#define BILLBOARD\";\n    }\n\n    if (this._colorGradientsTexture) {\n      defines += \"\\n#define COLORGRADIENTS\";\n    }\n\n    if (this._sizeGradientsTexture) {\n      defines += \"\\n#define SIZEGRADIENTS\";\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n    }\n\n    if (this._velocityGradientsTexture) {\n      defines += \"\\n#define VELOCITYGRADIENTS\";\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n    }\n\n    if (this._dragGradientsTexture) {\n      defines += \"\\n#define DRAGGRADIENTS\";\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines += \"\\n#define ANIMATESHEET\";\n\n      if (this.spriteRandomStartCell) {\n        defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n      }\n    }\n\n    if (this.noiseTexture) {\n      defines += \"\\n#define NOISE\";\n    }\n\n    if (this.isLocal) {\n      defines += \"\\n#define LOCAL\";\n    }\n\n    if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\n      return;\n    }\n\n    this._cachedUpdateDefines = defines;\n    this._updateBuffer = this._platform.createUpdateBuffer(defines);\n  };\n  /**\n   * @param blendMode\n   * @hidden\n   */\n\n\n  GPUParticleSystem.prototype._getWrapper = function (blendMode) {\n    var customWrapper = this._getCustomDrawWrapper(blendMode);\n\n    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n      return customWrapper;\n    }\n\n    var defines = [];\n    this.fillDefines(defines, blendMode); // Effect\n\n    var drawWrapper = this._drawWrappers[blendMode];\n\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = true;\n      }\n\n      this._drawWrappers[blendMode] = drawWrapper;\n    }\n\n    var join = defines.join(\"\\n\");\n\n    if (drawWrapper.defines !== join) {\n      var attributes = [];\n      var uniforms = [];\n      var samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\n    }\n\n    return drawWrapper;\n  };\n  /**\n   * @param hasColorGradients\n   * @param isAnimationSheetEnabled\n   * @param isBillboardBased\n   * @param isBillboardStretched\n   * @hidden\n   */\n\n\n  GPUParticleSystem._GetAttributeNamesOrOptions = function (hasColorGradients, isAnimationSheetEnabled, isBillboardBased, isBillboardStretched) {\n    if (hasColorGradients === void 0) {\n      hasColorGradients = false;\n    }\n\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (isBillboardBased === void 0) {\n      isBillboardBased = false;\n    }\n\n    if (isBillboardStretched === void 0) {\n      isBillboardStretched = false;\n    }\n\n    var attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\n\n    if (!hasColorGradients) {\n      attributeNamesOrOptions.push(VertexBuffer.ColorKind);\n    }\n\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"initialDirection\");\n    }\n\n    if (!isBillboardStretched) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n\n    attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\n    return attributeNamesOrOptions;\n  };\n  /**\n   * @param isAnimationSheetEnabled\n   * @hidden\n   */\n\n\n  GPUParticleSystem._GetEffectCreationOptions = function (isAnimationSheetEnabled) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    var effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"translationPivot\", \"eyePosition\"];\n\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"sheetInfos\");\n    }\n\n    return effectCreationOption;\n  };\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n\n\n  GPUParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this.isLocal) {\n      defines.push(\"#define LOCAL\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._colorGradientsTexture) {\n      defines.push(\"#define COLORGRADIENTS\");\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n\n\n  GPUParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push.apply(attributes, GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));\n    uniforms.push.apply(uniforms, GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\n    samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarm defines if we are in the pre-warmimg phase\n   */\n\n\n  GPUParticleSystem.prototype.animate = function (preWarm) {\n    var _a;\n\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    this._actualFrame += this._timeDelta;\n\n    if (!this._stopped) {\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    }\n  };\n\n  GPUParticleSystem.prototype._createFactorGradientTexture = function (factorGradients, textureName) {\n    var texture = this[textureName];\n\n    if (!factorGradients || !factorGradients.length || texture) {\n      return;\n    }\n\n    var data = new Float32Array(this._rawTextureWidth);\n\n    var _loop_1 = function _loop_1(x) {\n      var ratio = x / this_1._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, factorGradients, function (currentGradient, nextGradient, scale) {\n        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n      });\n    };\n\n    var this_1 = this;\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      _loop_1(x);\n    }\n\n    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n  };\n\n  GPUParticleSystem.prototype._createSizeGradientTexture = function () {\n    this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createAngularSpeedGradientTexture = function () {\n    this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createLimitVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createDragGradientTexture = function () {\n    this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createColorGradientTexture = function () {\n    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color4[0];\n\n    var _loop_2 = function _loop_2(x) {\n      var ratio = x / this_2._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this_2._colorGradients, function (currentGradient, nextGradient, scale) {\n        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = tmpColor.a * 255;\n      });\n    };\n\n    var this_2 = this;\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      _loop_2(x);\n    }\n\n    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n\n  GPUParticleSystem.prototype._render = function (blendMode, emitterWM) {\n    var _a, _b; // Enable render effect\n\n\n    var drawWrapper = this._getWrapper(blendMode);\n\n    var effect = drawWrapper.effect;\n\n    this._engine.enableEffect(drawWrapper);\n\n    var viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setVector3(\"worldOffset\", this.worldOffset);\n\n    if (this.isLocal) {\n      effect.setMatrix(\"emitterWM\", emitterWM);\n    }\n\n    if (this._colorGradientsTexture) {\n      effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n    } else {\n      effect.setDirectColor4(\"colorDead\", this.colorDead);\n    }\n\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      var baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n    }\n\n    if (this._isBillboardBased && this._scene) {\n      var camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n\n    var defines = effect.defines;\n\n    if (this._scene) {\n      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n        MaterialHelper.BindClipPlane(effect, this._scene);\n      }\n    }\n\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      var invView = viewMatrix.clone();\n      invView.invert();\n      effect.setMatrix(\"invView\", invView);\n    } // image processing\n\n\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    } // Draw order\n\n\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        this._engine.setAlphaMode(1);\n\n        break;\n\n      case ParticleSystem.BLENDMODE_ONEONE:\n        this._engine.setAlphaMode(6);\n\n        break;\n\n      case ParticleSystem.BLENDMODE_STANDARD:\n        this._engine.setAlphaMode(2);\n\n        break;\n\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        this._engine.setAlphaMode(4);\n\n        break;\n    } // Bind source VAO\n\n\n    this._platform.bindDrawBuffers(this._targetIndex, effect);\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    } // Render\n\n\n    this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);\n\n    this._engine.setAlphaMode(0);\n\n    return this._currentActiveCount;\n  };\n  /**\n   * Renders the particle system in its current state\n   * @param preWarm defines if the system should only update the particles but not render them\n   * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\n   * @returns the current number of particles\n   */\n\n\n  GPUParticleSystem.prototype.render = function (preWarm, forceUpdateOnly) {\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    if (forceUpdateOnly === void 0) {\n      forceUpdateOnly = false;\n    }\n\n    if (!this._started) {\n      return 0;\n    }\n\n    this._createColorGradientTexture();\n\n    this._createSizeGradientTexture();\n\n    this._createAngularSpeedGradientTexture();\n\n    this._createVelocityGradientTexture();\n\n    this._createLimitVelocityGradientTexture();\n\n    this._createDragGradientTexture();\n\n    this._recreateUpdateEffect();\n\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    if (!preWarm && this._scene) {\n      if (!this._preWarmDone && this.preWarmCycles) {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n          this.render(true, true);\n        }\n\n        this._preWarmDone = true;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {\n        return 0;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n\n      if (this._scene.activeCamera) {\n        this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\n      }\n    } // Get everything ready to render\n\n\n    this._initialize();\n\n    this._accumulatedCount += this.emitRate * this._timeDelta;\n\n    if (this._accumulatedCount > 1) {\n      var intPart = this._accumulatedCount | 0;\n      this._accumulatedCount -= intPart;\n      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\n    }\n\n    if (!this._currentActiveCount) {\n      return 0;\n    } // Enable update effect\n\n\n    var emitterWM;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      emitterWM = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    var engine = this._engine;\n\n    this._platform.preUpdateParticleBuffer();\n\n    this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\n\n    this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\n\n    this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n\n    this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\n\n    this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n\n    this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n\n    if (!this._colorGradientsTexture) {\n      this._updateBuffer.setDirectColor4(\"color1\", this.color1);\n\n      this._updateBuffer.setDirectColor4(\"color2\", this.color2);\n    }\n\n    this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n\n    this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n\n    this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n\n    this._updateBuffer.setVector3(\"gravity\", this.gravity);\n\n    if (this._limitVelocityGradientsTexture) {\n      this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n    }\n\n    if (this.particleEmitterType) {\n      this.particleEmitterType.applyToShader(this._updateBuffer);\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\n    }\n\n    if (this.noiseTexture) {\n      this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\n    }\n\n    if (!this.isLocal) {\n      this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\n    }\n\n    this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\n\n    var outparticles = 0;\n\n    if (!preWarm && !forceUpdateOnly) {\n      engine.setState(false);\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n\n      if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n        outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\n      } else {\n        outparticles = this._render(this.blendMode, emitterWM);\n      }\n\n      this._engine.setAlphaMode(0);\n    } // Switch VAOs\n\n\n    this._targetIndex++;\n\n    if (this._targetIndex === 2) {\n      this._targetIndex = 0;\n    } // Switch buffers\n\n\n    var tmpBuffer = this._sourceBuffer;\n    this._sourceBuffer = this._targetBuffer;\n    this._targetBuffer = tmpBuffer;\n    return outparticles;\n  };\n  /**\n   * Rebuilds the particle system\n   */\n\n\n  GPUParticleSystem.prototype.rebuild = function () {\n    this._initialize(true);\n  };\n\n  GPUParticleSystem.prototype._releaseBuffers = function () {\n    if (this._buffer0) {\n      this._buffer0.dispose();\n\n      this._buffer0 = null;\n    }\n\n    if (this._buffer1) {\n      this._buffer1.dispose();\n\n      this._buffer1 = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    this._platform.releaseBuffers();\n  };\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\n   */\n\n\n  GPUParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    for (var blendMode in this._drawWrappers) {\n      var drawWrapper = this._drawWrappers[blendMode];\n      drawWrapper.dispose();\n    }\n\n    this._drawWrappers = {};\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n    }\n\n    this._releaseBuffers();\n\n    this._platform.releaseVertexBuffers();\n\n    if (this._colorGradientsTexture) {\n      this._colorGradientsTexture.dispose();\n\n      this._colorGradientsTexture = null;\n    }\n\n    if (this._sizeGradientsTexture) {\n      this._sizeGradientsTexture.dispose();\n\n      this._sizeGradientsTexture = null;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._angularSpeedGradientsTexture.dispose();\n\n      this._angularSpeedGradientsTexture = null;\n    }\n\n    if (this._velocityGradientsTexture) {\n      this._velocityGradientsTexture.dispose();\n\n      this._velocityGradientsTexture = null;\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      this._limitVelocityGradientsTexture.dispose();\n\n      this._limitVelocityGradientsTexture = null;\n    }\n\n    if (this._dragGradientsTexture) {\n      this._dragGradientsTexture.dispose();\n\n      this._dragGradientsTexture = null;\n    }\n\n    if (this._randomTexture) {\n      this._randomTexture.dispose();\n\n      this._randomTexture = null;\n    }\n\n    if (this._randomTexture2) {\n      this._randomTexture2.dispose();\n\n      this._randomTexture2 = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    } // Callback\n\n\n    this.onStoppedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @returns the cloned particle system\n   */\n\n\n  GPUParticleSystem.prototype.clone = function (name, newEmitter) {\n    var custom = __assign({}, this._customWrappers);\n\n    var program = null;\n    var engine = this._engine;\n\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, this);\n      }\n    }\n\n    var serialization = this.serialize();\n    var result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n\n    result.emitter = newEmitter;\n    return result;\n  };\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n\n\n  GPUParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.activeParticleCount = this.activeParticleCount;\n    serializationObject.randomTextureSize = this._randomTextureSize;\n    serializationObject.customShader = this.customShader;\n    return serializationObject;\n  };\n  /**\n   * Parses a JSON object to create a GPU particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the parsed GPU particle system\n   */\n\n\n  GPUParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart, capacity) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var engine;\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n\n    var particleSystem = new GPUParticleSystem(name, {\n      capacity: capacity || parsedParticleSystem.capacity,\n      randomTextureSize: parsedParticleSystem.randomTextureSize\n    }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem._rootUrl = rootUrl;\n\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      var program = parsedParticleSystem.customShader;\n      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      var custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, particleSystem);\n      particleSystem.setCustomEffect(custom, 0);\n      particleSystem.customShader = program;\n    }\n\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n\n    if (parsedParticleSystem.activeParticleCount) {\n      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl); // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n\n  return GPUParticleSystem;\n}(BaseParticleSystem);\n\nexport { GPUParticleSystem };","map":{"version":3,"mappings":"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","names":["FactorGradient","ColorGradient","GradientHelper","Observable","Matrix","TmpVectors","Color4","TmpColors","Scalar","VertexBuffer","Buffer","BaseParticleSystem","ParticleSystem","BoxParticleEmitter","MaterialHelper","ImageProcessingConfiguration","RawTexture","EngineStore","CustomParticleEmitter","ThinEngine","DrawWrapper","GetClass","__extends","name","options","sceneOrEngine","customEffect","isAnimationSheetEnabled","_super","_this","getClassName","_scene","LastCreatedScene","_engine","getEngine","uniqueId","getUniqueId","particleSystems","push","defaultProjectionMatrix","PerspectiveFovLH","isNDCHalfZRange","getCaps","supportComputeShaders","Error","_platform","_customWrappers","effect","_drawWrappers","drawContext","useInstancing","_attachImageProcessingConfiguration","randomTextureSize","fullOptions","capacity","maxTextureSize","optionsAsNumber","isFinite","_capacity","_activeCount","_currentActiveCount","_isAnimationSheetEnabled","particleEmitterType","Math","min","d","i","random","_randomTexture","Float32Array","wrapU","wrapV","_randomTexture2","_randomTextureSize","Object","GPUParticleSystem","LastCreatedEngine","caps","supportTransformFeedbacks","value","emitter","_imageProcessingConfiguration","isReady","particleTexture","blendMode","BLENDMODE_MULTIPLYADD","_getWrapper","BLENDMODE_MULTIPLY","BLENDMODE_ADD","isUpdateBufferCreated","_recreateUpdateEffect","isUpdateBufferReady","_started","_stopped","delay","startDelay","targetStopDuration","_hasTargetStopDurationDependantGradient","setTimeout","start","_preWarmDone","beginAnimationOnStart","animations","length","beginAnimation","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","_releaseBuffers","releaseVertexBuffers","_targetIndex","_a","_b","_onBeforeDrawParticlesObservable","gradient","gradients","texture","_removeGradientAndTexture","call","color1","_colorGradients","colorGradient","_refreshColorGradient","reorder","sort","a","b","_colorGradientsTexture","dispose","_refreshFactorGradient","_sizeGradients","_angularSpeedGradients","_velocityGradients","_limitVelocityGradients","_dragGradients","reset","drawWrapper","factorGradients","factor","valueGradient","_addFactorGradient","_sizeGradientsTexture","textureName","that","_angularSpeedGradientsTexture","_velocityGradientsTexture","_limitVelocityGradientsTexture","_dragGradientsTexture","updateBuffer","renderBuffer","spriteSource","renderVertexBuffers","createVertexBuffer","_attributesStrideSize","offset","billboardMode","BILLBOARDMODE_STRETCHED","alignDataInBuffer","_isBillboardBased","noiseTexture","spriteRandomStartCell","createVertexBuffers","resetDrawCache","force","_buffer0","engine","data","Array","isBillboardBased","usingCustomEmitter","tmpVector","Vector3","particleIndex","particleDestinationGenerator","x","y","z","particlePositionGenerator","numDummies","spriteData","bufferData1","createParticleBuffer","bufferData2","_buffer1","_spriteBuffer","_createVertexBuffers","_sourceBuffer","_targetBuffer","defines","getEffectDefines","isLocal","_cachedUpdateDefines","_updateBuffer","createUpdateBuffer","customWrapper","_getCustomDrawWrapper","fillDefines","join","attributes","uniforms","samplers","fillUniformsAttributesAndSamplerNames","setEffect","createEffect","hasColorGradients","isBillboardStretched","attributeNamesOrOptions","PositionKind","ColorKind","UVKind","effectCreationOption","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","prepareDefines","_imageProcessingConfigurationDefines","toString","apply","_GetAttributeNamesOrOptions","_GetEffectCreationOptions","PrepareUniforms","PrepareSamplers","preWarm","_timeDelta","updateSpeed","preWarmStepOffset","getAnimationRatio","_actualFrame","stop","_rawTextureWidth","ratio","this_1","GetCurrentGradient","currentGradient","nextGradient","scale","Lerp","factor1","CreateRTexture","_createFactorGradientTexture","Uint8Array","tmpColor","this_2","LerpToRef","r","g","CreateRGBATexture","emitterWM","enableEffect","viewMatrix","getViewMatrix","IdentityReadOnly","setMatrix","getProjectionMatrix","setTexture","setVector2","translationPivot","setVector3","worldOffset","setDirectColor4","colorDead","baseSize","getBaseSize","setFloat3","spriteCellWidth","width","spriteCellHeight","height","camera","activeCamera","globalPosition","BindClipPlane","indexOf","invView","clone","invert","applyByPostProcess","bind","setAlphaMode","BLENDMODE_ONEONE","BLENDMODE_STANDARD","bindDrawBuffers","notifyObservers","drawArraysType","forceUpdateOnly","_createColorGradientTexture","_createSizeGradientTexture","_createAngularSpeedGradientTexture","_createVelocityGradientTexture","_createLimitVelocityGradientTexture","_createDragGradientTexture","preWarmCycles","index","animate","render","_currentRenderId","getFrameId","_currentRenderingCameraUniqueId","_initialize","_accumulatedCount","emitRate","intPart","position","emitterMesh","getWorldMatrix","emitterPosition","Translation","preUpdateParticleBuffer","setFloat","setInt","setFloat2","minLifeTime","maxLifeTime","minEmitPower","maxEmitPower","color2","minSize","maxSize","setFloat4","minScaleX","maxScaleX","minScaleY","maxScaleY","minAngularSpeed","maxAngularSpeed","minInitialRotation","maxInitialRotation","gravity","limitVelocityDamping","applyToShader","startSpriteCellID","endSpriteCellID","spriteCellChangeSpeed","spriteCellLoop","noiseStrength","updateParticleBuffer","outparticles","setState","forceDepthWrite","setDepthWrite","_render","tmpBuffer","releaseBuffers","disposeTexture","splice","onStoppedObservable","clear","onDisposeObservable","newEmitter","custom","program","createEffectForParticles","customShader","shaderOptions","shaderPath","fragmentElement","undefined","serialization","serialize","result","Parse","_rootUrl","serializeTexture","serializationObject","_Serialize","activeParticleCount","parsedParticleSystem","rootUrl","doNotStart","scene","particleSystem","setCustomEffect","id","_Parse","preventAutoStart"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/gpuParticleSystem.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable, float, DataArray } from \"../types\";\r\nimport type { Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color4, TmpColors } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { IGPUParticleSystemPlatform } from \"./IGPUParticleSystemPlatform\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\nimport \"../Shaders/gpuRenderParticles.fragment\";\r\nimport \"../Shaders/gpuRenderParticles.vertex\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\r\nexport class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    private _capacity: number;\r\n    private _activeCount: number;\r\n    private _currentActiveCount: number;\r\n    private _accumulatedCount = 0;\r\n    private _updateBuffer: UniformBufferEffectCommonAccessor;\r\n\r\n    private _buffer0: Buffer;\r\n    private _buffer1: Buffer;\r\n    private _spriteBuffer: Buffer;\r\n\r\n    private _targetIndex = 0;\r\n    private _sourceBuffer: Buffer;\r\n    private _targetBuffer: Buffer;\r\n\r\n    private _currentRenderId = -1;\r\n    private _currentRenderingCameraUniqueId = -1;\r\n    private _started = false;\r\n    private _stopped = false;\r\n\r\n    private _timeDelta = 0;\r\n\r\n    /** @hidden */\r\n    public _randomTexture: RawTexture;\r\n    /** @hidden */\r\n    public _randomTexture2: RawTexture;\r\n\r\n    private _attributesStrideSize: number;\r\n    private _cachedUpdateDefines: string;\r\n\r\n    private _randomTextureSize: number;\r\n    private _actualFrame = 0;\r\n    private _drawWrappers: { [blendMode: number]: DrawWrapper };\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n\r\n    private _platform: IGPUParticleSystemPlatform;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        if (!EngineStore.LastCreatedEngine) {\r\n            return false;\r\n        }\r\n        const caps = EngineStore.LastCreatedEngine.getCaps();\r\n\r\n        return caps.supportTransformFeedbacks || caps.supportComputeShaders;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the system is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     */\r\n    public get activeParticleCount(): number {\r\n        return this._activeCount;\r\n    }\r\n\r\n    public set activeParticleCount(value: number) {\r\n        this._activeCount = Math.min(value, this._capacity);\r\n    }\r\n\r\n    private _preWarmDone = false;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @return true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this._platform.isUpdateBufferCreated()) {\r\n            this._recreateUpdateEffect();\r\n            return false;\r\n        }\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n     * @returns True if it has been stopped, otherwise false.\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return false; // Stop is immediate on GPU\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._preWarmDone = false;\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    public stop(): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n        this._stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n        this._currentActiveCount = 0;\r\n        this._targetIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"GPUParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GPUParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"gpuRenderParticles\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public _colorGradientsTexture: RawTexture;\r\n\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem {\r\n        super._removeGradientAndTexture(gradient, gradients, texture);\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4): GPUParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._refreshColorGradient(true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshColorGradient(reorder = false) {\r\n        if (this._colorGradients) {\r\n            if (reorder) {\r\n                this._colorGradients.sort((a, b) => {\r\n                    if (a.gradient < b.gradient) {\r\n                        return -1;\r\n                    } else if (a.gradient > b.gradient) {\r\n                        return 1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            if (this._colorGradientsTexture) {\r\n                this._colorGradientsTexture.dispose();\r\n                (<any>this._colorGradientsTexture) = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._refreshColorGradient();\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\r\n        (<any>this._colorGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _angularSpeedGradientsTexture: RawTexture;\r\n    /** @hidden */\r\n    public _sizeGradientsTexture: RawTexture;\r\n    /** @hidden */\r\n    public _velocityGradientsTexture: RawTexture;\r\n    /** @hidden */\r\n    public _limitVelocityGradientsTexture: RawTexture;\r\n    /** @hidden */\r\n    public _dragGradientsTexture: RawTexture;\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number) {\r\n        const valueGradient = new FactorGradient(gradient, factor);\r\n        factorGradients.push(valueGradient);\r\n\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\r\n\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\r\n        (<any>this._sizeGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshFactorGradient(factorGradients: Nullable<FactorGradient[]>, textureName: string, reorder = false) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        if (reorder) {\r\n            factorGradients.sort((a, b) => {\r\n                if (a.gradient < b.gradient) {\r\n                    return -1;\r\n                } else if (a.gradient > b.gradient) {\r\n                    return 1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        const that = this as any;\r\n        if (that[textureName]) {\r\n            that[textureName].dispose();\r\n            that[textureName] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\r\n        (<any>this._angularSpeedGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\r\n        (<any>this._velocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\r\n        (<any>this._limitVelocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\r\n        (<any>this._dragGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        //Not supported by GPUParticleSystem\r\n        return false;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        //Not supported by GPUParticleSystem\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a GPU particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param options The options used to create the system\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: Partial<{\r\n            capacity: number;\r\n            randomTextureSize: number;\r\n        }>,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false\r\n    ) {\r\n        super(name);\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().supportComputeShaders) {\r\n            if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\r\n                throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\") as any)(this, this._engine);\r\n        } else {\r\n            if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\r\n                throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\") as any)(this, this._engine);\r\n        }\r\n\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = { 0: new DrawWrapper(this._engine) };\r\n        if (this._drawWrappers[0].drawContext) {\r\n            this._drawWrappers[0].drawContext.useInstancing = true;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        options = options ?? {};\r\n\r\n        if (!options.randomTextureSize) {\r\n            delete options.randomTextureSize;\r\n        }\r\n\r\n        const fullOptions = {\r\n            capacity: 50000,\r\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\r\n            ...options,\r\n        };\r\n\r\n        const optionsAsNumber = <number>options;\r\n        if (isFinite(optionsAsNumber)) {\r\n            fullOptions.capacity = optionsAsNumber;\r\n        }\r\n\r\n        this._capacity = fullOptions.capacity;\r\n        this._activeCount = fullOptions.capacity;\r\n        this._currentActiveCount = 0;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n\r\n        // Random data\r\n        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\r\n        let d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture.name = \"GPUParticleSystem_random1\";\r\n        this._randomTexture.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture2 = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture2.name = \"GPUParticleSystem_random2\";\r\n        this._randomTexture2.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture2.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        this._randomTextureSize = maxTextureSize;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers(updateBuffer: Buffer, renderBuffer: Buffer, spriteSource: Buffer): void {\r\n        const renderVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\r\n        let offset = 3;\r\n        renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\r\n        offset += 3;\r\n        renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        offset += 4; // seed\r\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\r\n        }\r\n        offset += 3; // direction\r\n        if (this._platform.alignDataInBuffer) {\r\n            offset += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\r\n            offset += 4;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n            renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\r\n        if (this._angularSpeedGradientsTexture) {\r\n            offset++;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\r\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\r\n\r\n        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _initialize(force = false): void {\r\n        if (this._buffer0 && !force) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const data = new Array<float>();\r\n\r\n        this._attributesStrideSize = 21;\r\n        this._targetIndex = 0;\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (!this.isBillboardBased) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._attributesStrideSize -= 4;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._attributesStrideSize -= 1;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._attributesStrideSize += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._attributesStrideSize += 6;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 2;\r\n            }\r\n        }\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 3 - ((this._attributesStrideSize + 3) & 3); // round to multiple of 4\r\n        }\r\n\r\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        let offset = 0;\r\n        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\r\n            // position\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // Age\r\n            data.push(0.0); // create the particle as a dead one to create a new one at start\r\n\r\n            // Size\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // life\r\n            data.push(0.0);\r\n\r\n            // Seed\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n\r\n            // direction\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particleDestinationGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            } else {\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                data.push(0.0); // dummy0\r\n            }\r\n\r\n            offset += 16; // position, age, size, life, seed, direction, dummy0\r\n\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particlePositionGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy1\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this._colorGradientsTexture) {\r\n                // color\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this.isBillboardBased) {\r\n                // initialDirection\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy2\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                // Random coordinates for reading into noise texture\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy3\r\n                }\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy4\r\n                }\r\n                offset += 8;\r\n            }\r\n\r\n            // angle\r\n            data.push(0.0);\r\n            offset += 1;\r\n\r\n            if (!this._angularSpeedGradientsTexture) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n                if (this.spriteRandomStartCell) {\r\n                    data.push(0.0);\r\n                    offset += 1;\r\n                }\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                let numDummies = 3 - ((offset + 3) & 3);\r\n                offset += numDummies;\r\n                while (numDummies-- > 0) {\r\n                    data.push(0.0);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sprite data\r\n        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\r\n\r\n        const bufferData1: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n        const bufferData2: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n\r\n        // Buffers\r\n        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\r\n        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\r\n\r\n        // Update & Render vertex buffers\r\n        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\r\n        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\r\n\r\n        // Links\r\n        this._sourceBuffer = this._buffer0;\r\n        this._targetBuffer = this._buffer1;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _recreateUpdateEffect() {\r\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\r\n\r\n        if (this._isBillboardBased) {\r\n            defines += \"\\n#define BILLBOARD\";\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines += \"\\n#define COLORGRADIENTS\";\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            defines += \"\\n#define SIZEGRADIENTS\";\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            defines += \"\\n#define VELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            defines += \"\\n#define DRAGGRADIENTS\";\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines += \"\\n#define ANIMATESHEET\";\r\n            if (this.spriteRandomStartCell) {\r\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            defines += \"\\n#define NOISE\";\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines += \"\\n#define LOCAL\";\r\n        }\r\n\r\n        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\r\n            return;\r\n        }\r\n\r\n        this._cachedUpdateDefines = defines;\r\n        this._updateBuffer = this._platform.createUpdateBuffer(defines);\r\n    }\r\n\r\n    /**\r\n     * @param blendMode\r\n     * @hidden\r\n     */\r\n    public _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        let drawWrapper = this._drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = true;\r\n            }\r\n            this._drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributes: Array<string> = [];\r\n            const uniforms: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @param hasColorGradients\r\n     * @param isAnimationSheetEnabled\r\n     * @param isBillboardBased\r\n     * @param isBillboardStretched\r\n     * @hidden\r\n     */\r\n    public static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\r\n\r\n        if (!hasColorGradients) {\r\n            attributeNamesOrOptions.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"initialDirection\");\r\n        }\r\n\r\n        if (!isBillboardStretched) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @param isAnimationSheetEnabled\r\n     * @hidden\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false): string[] {\r\n        const effectCreationOption = [\r\n            \"emitterWM\",\r\n            \"worldOffset\",\r\n            \"view\",\r\n            \"projection\",\r\n            \"colorDead\",\r\n            \"invView\",\r\n            \"vClipPlane\",\r\n            \"vClipPlane2\",\r\n            \"vClipPlane3\",\r\n            \"vClipPlane4\",\r\n            \"vClipPlane5\",\r\n            \"vClipPlane6\",\r\n            \"translationPivot\",\r\n            \"eyePosition\",\r\n        ];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"sheetInfos\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number = 0) {\r\n        if (this._scene) {\r\n            if (this._scene.clipPlane) {\r\n                defines.push(\"#define CLIPPLANE\");\r\n            }\r\n            if (this._scene.clipPlane2) {\r\n                defines.push(\"#define CLIPPLANE2\");\r\n            }\r\n            if (this._scene.clipPlane3) {\r\n                defines.push(\"#define CLIPPLANE3\");\r\n            }\r\n            if (this._scene.clipPlane4) {\r\n                defines.push(\"#define CLIPPLANE4\");\r\n            }\r\n            if (this._scene.clipPlane5) {\r\n                defines.push(\"#define CLIPPLANE5\");\r\n            }\r\n            if (this._scene.clipPlane6) {\r\n                defines.push(\"#define CLIPPLANE6\");\r\n            }\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines.push(\"#define LOCAL\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines.push(\"#define COLORGRADIENTS\");\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...GPUParticleSystem._GetAttributeNamesOrOptions(\r\n                !!this._colorGradientsTexture,\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased,\r\n                this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED\r\n            )\r\n        );\r\n\r\n        uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\r\n\r\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarm defines if we are in the pre-warmimg phase\r\n     */\r\n    public animate(preWarm = false): void {\r\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n        this._actualFrame += this._timeDelta;\r\n\r\n        if (!this._stopped) {\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createFactorGradientTexture(factorGradients: Nullable<IValueGradient[]>, textureName: string) {\r\n        const texture: RawTexture = (<any>this)[textureName];\r\n\r\n        if (!factorGradients || !factorGradients.length || texture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Float32Array(this._rawTextureWidth);\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\r\n                data[x] = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n            });\r\n        }\r\n\r\n        (<any>this)[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    private _createSizeGradientTexture() {\r\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\r\n    }\r\n\r\n    private _createAngularSpeedGradientTexture() {\r\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n    }\r\n\r\n    private _createVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\r\n    }\r\n\r\n    private _createLimitVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n    }\r\n\r\n    private _createDragGradientTexture() {\r\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\r\n    }\r\n\r\n    private _createColorGradientTexture() {\r\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color4[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                Color4.LerpToRef((<ColorGradient>currentGradient).color1, (<ColorGradient>nextGradient).color1, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = tmpColor.a * 255;\r\n            });\r\n        }\r\n\r\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    private _render(blendMode: number, emitterWM: Matrix): number {\r\n        // Enable render effect\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setVector3(\"worldOffset\", this.worldOffset);\r\n        if (this.isLocal) {\r\n            effect.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n        if (this._colorGradientsTexture) {\r\n            effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\r\n        } else {\r\n            effect.setDirectColor4(\"colorDead\", this.colorDead);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\r\n        }\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\r\n                MaterialHelper.BindClipPlane(effect, this._scene);\r\n            }\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            const invView = viewMatrix.clone();\r\n            invView.invert();\r\n            effect.setMatrix(\"invView\", invView);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                this._engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        // Bind source VAO\r\n        this._platform.bindDrawBuffers(this._targetIndex, effect);\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        // Render\r\n        this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._currentActiveCount);\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state\r\n     * @param preWarm defines if the system should only update the particles but not render them\r\n     * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\r\n     * @returns the current number of particles\r\n     */\r\n    public render(preWarm = false, forceUpdateOnly = false): number {\r\n        if (!this._started) {\r\n            return 0;\r\n        }\r\n\r\n        this._createColorGradientTexture();\r\n        this._createSizeGradientTexture();\r\n        this._createAngularSpeedGradientTexture();\r\n        this._createVelocityGradientTexture();\r\n        this._createLimitVelocityGradientTexture();\r\n        this._createDragGradientTexture();\r\n\r\n        this._recreateUpdateEffect();\r\n\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        if (!preWarm && this._scene) {\r\n            if (!this._preWarmDone && this.preWarmCycles) {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                    this.render(true, true);\r\n                }\r\n\r\n                this._preWarmDone = true;\r\n            }\r\n\r\n            if (\r\n                this._currentRenderId === this._scene.getFrameId() &&\r\n                (!this._scene.activeCamera || (this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId))\r\n            ) {\r\n                return 0;\r\n            }\r\n\r\n            this._currentRenderId = this._scene.getFrameId();\r\n            if (this._scene.activeCamera) {\r\n                this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Get everything ready to render\r\n        this._initialize();\r\n\r\n        this._accumulatedCount += this.emitRate * this._timeDelta;\r\n        if (this._accumulatedCount > 1) {\r\n            const intPart = this._accumulatedCount | 0;\r\n            this._accumulatedCount -= intPart;\r\n            this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\r\n        }\r\n\r\n        if (!this._currentActiveCount) {\r\n            return 0;\r\n        }\r\n\r\n        // Enable update effect\r\n        let emitterWM: Matrix;\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            emitterWM = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        const engine = this._engine as Engine;\r\n\r\n        this._platform.preUpdateParticleBuffer();\r\n\r\n        this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\r\n        this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\r\n        this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\r\n        this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\r\n        this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\r\n        this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateBuffer.setDirectColor4(\"color1\", this.color1);\r\n            this._updateBuffer.setDirectColor4(\"color2\", this.color2);\r\n        }\r\n        this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\r\n        this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\r\n        this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\r\n        this._updateBuffer.setVector3(\"gravity\", this.gravity);\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\r\n        }\r\n        if (this.particleEmitterType) {\r\n            this.particleEmitterType.applyToShader(this._updateBuffer);\r\n        }\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\r\n        }\r\n        if (this.noiseTexture) {\r\n            this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\r\n        }\r\n        if (!this.isLocal) {\r\n            this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n\r\n        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\r\n\r\n        let outparticles = 0;\r\n        if (!preWarm && !forceUpdateOnly) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n\r\n            if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n                outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\r\n            } else {\r\n                outparticles = this._render(this.blendMode, emitterWM);\r\n            }\r\n\r\n            this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Switch VAOs\r\n        this._targetIndex++;\r\n        if (this._targetIndex === 2) {\r\n            this._targetIndex = 0;\r\n        }\r\n\r\n        // Switch buffers\r\n        const tmpBuffer = this._sourceBuffer;\r\n        this._sourceBuffer = this._targetBuffer;\r\n        this._targetBuffer = tmpBuffer;\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system\r\n     */\r\n    public rebuild(): void {\r\n        this._initialize(true);\r\n    }\r\n\r\n    private _releaseBuffers() {\r\n        if (this._buffer0) {\r\n            this._buffer0.dispose();\r\n            (<any>this._buffer0) = null;\r\n        }\r\n        if (this._buffer1) {\r\n            this._buffer1.dispose();\r\n            (<any>this._buffer1) = null;\r\n        }\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n        this._platform.releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.dispose();\r\n        }\r\n\r\n        this._drawWrappers = {};\r\n\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._colorGradientsTexture.dispose();\r\n            (<any>this._colorGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._sizeGradientsTexture.dispose();\r\n            (<any>this._sizeGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._angularSpeedGradientsTexture.dispose();\r\n            (<any>this._angularSpeedGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._velocityGradientsTexture.dispose();\r\n            (<any>this._velocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._limitVelocityGradientsTexture.dispose();\r\n            (<any>this._limitVelocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._dragGradientsTexture.dispose();\r\n            (<any>this._dragGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            (<any>this._randomTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture2) {\r\n            this._randomTexture2.dispose();\r\n            (<any>this._randomTexture2) = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onStoppedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any): GPUParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as any;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                custom[0] = engine.createEffectForParticles(\r\n                    program.shaderPath.fragmentElement,\r\n                    program.shaderOptions.uniforms,\r\n                    program.shaderOptions.samplers,\r\n                    defines,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this\r\n                );\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize();\r\n        const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.activeParticleCount = this.activeParticleCount;\r\n        serializationObject.randomTextureSize = this._randomTextureSize;\r\n        serializationObject.customShader = this.customShader;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a GPU particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the parsed GPU particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): GPUParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        const particleSystem = new GPUParticleSystem(\r\n            name,\r\n            { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize },\r\n            sceneOrEngine,\r\n            null,\r\n            parsedParticleSystem.isAnimationSheetEnabled\r\n        );\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            const program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            const custom: Nullable<Effect> = (engine as any).createEffectForParticles(\r\n                program.shaderPath.fragmentElement,\r\n                program.shaderOptions.uniforms,\r\n                program.shaderOptions.samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                particleSystem\r\n            );\r\n            particleSystem.setCustomEffect(custom, 0);\r\n            particleSystem.customShader = program;\r\n        }\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        if (parsedParticleSystem.activeParticleCount) {\r\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}