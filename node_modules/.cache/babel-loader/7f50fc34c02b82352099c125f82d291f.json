{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/** Internal class used to store shapes for emitters */\n\nvar ParticleSystemSetEmitterCreationOptions =\n/** @class */\nfunction () {\n  function ParticleSystemSetEmitterCreationOptions() {}\n\n  return ParticleSystemSetEmitterCreationOptions;\n}();\n/**\n * Represents a set of particle systems working together to create a specific effect\n */\n\n\nvar ParticleSystemSet =\n/** @class */\nfunction () {\n  function ParticleSystemSet() {\n    this._emitterNodeIsOwned = true;\n    /**\n     * Gets the particle system list\n     */\n\n    this.systems = new Array();\n  }\n\n  Object.defineProperty(ParticleSystemSet.prototype, \"emitterNode\", {\n    /**\n     * Gets or sets the emitter node used with this set\n     */\n    get: function get() {\n      return this._emitterNode;\n    },\n    set: function set(value) {\n      if (this._emitterNodeIsOwned && this._emitterNode) {\n        if (this._emitterNode.dispose) {\n          this._emitterNode.dispose();\n        }\n\n        this._emitterNodeIsOwned = false;\n      }\n\n      for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n        var system = _a[_i];\n        system.emitter = value;\n      }\n\n      this._emitterNode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new emitter mesh as a sphere\n   * @param options defines the options used to create the sphere\n   * @param options.diameter\n   * @param options.segments\n   * @param options.color\n   * @param renderingGroupId defines the renderingGroupId to use for the sphere\n   * @param scene defines the hosting scene\n   */\n\n  ParticleSystemSet.prototype.setEmitterAsSphere = function (options, renderingGroupId, scene) {\n    if (this._emitterNodeIsOwned && this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n    }\n\n    this._emitterNodeIsOwned = true;\n    this._emitterCreationOptions = {\n      kind: \"Sphere\",\n      options: options,\n      renderingGroupId: renderingGroupId\n    };\n    var emitterMesh = CreateSphere(\"emitterSphere\", {\n      diameter: options.diameter,\n      segments: options.segments\n    }, scene);\n    emitterMesh.renderingGroupId = renderingGroupId;\n    var material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n    material.emissiveColor = options.color;\n    emitterMesh.material = material;\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.emitter = emitterMesh;\n    }\n\n    this._emitterNode = emitterMesh;\n  };\n  /**\n   * Starts all particle systems of the set\n   * @param emitter defines an optional mesh to use as emitter for the particle systems\n   */\n\n\n  ParticleSystemSet.prototype.start = function (emitter) {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n\n      if (emitter) {\n        system.emitter = emitter;\n      }\n\n      system.start();\n    }\n  };\n  /**\n   * Release all associated resources\n   */\n\n\n  ParticleSystemSet.prototype.dispose = function () {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.dispose();\n    }\n\n    this.systems = [];\n\n    if (this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n\n      this._emitterNode = null;\n    }\n  };\n  /**\n   * Serialize the set into a JSON compatible object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns a JSON compatible representation of the set\n   */\n\n\n  ParticleSystemSet.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var result = {};\n    result.systems = [];\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(system.serialize(serializeTexture));\n    }\n\n    if (this._emitterNode) {\n      result.emitter = this._emitterCreationOptions;\n    }\n\n    return result;\n  };\n  /**\n   * Parse a new ParticleSystemSet from a serialized source\n   * @param data defines a JSON compatible representation of the set\n   * @param scene defines the hosting scene\n   * @param gpu defines if we want GPU particles or CPU particles\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a new ParticleSystemSet\n   */\n\n\n  ParticleSystemSet.Parse = function (data, scene, gpu, capacity) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    var result = new ParticleSystemSet();\n    var rootUrl = this.BaseAssetsUrl + \"/textures/\";\n    scene = scene || EngineStore.LastCreatedScene;\n\n    for (var _i = 0, _a = data.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\n    }\n\n    if (data.emitter) {\n      var options = data.emitter.options;\n\n      switch (data.emitter.kind) {\n        case \"Sphere\":\n          result.setEmitterAsSphere({\n            diameter: options.diameter,\n            segments: options.segments,\n            color: Color3.FromArray(options.color)\n          }, data.emitter.renderingGroupId, scene);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Gets or sets base Assets URL\n   */\n\n\n  ParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n  return ParticleSystemSet;\n}();\n\nexport { ParticleSystemSet };","map":{"version":3,"mappings":"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","names":["Color3","CreateSphere","GPUParticleSystem","EngineStore","ParticleSystem","StandardMaterial","Array","Object","ParticleSystemSet","_emitterNode","value","_emitterNodeIsOwned","dispose","systems","_i","system","emitter","options","renderingGroupId","scene","_emitterCreationOptions","kind","emitterMesh","diameter","segments","material","emissiveColor","color","start","serializeTexture","result","push","serialize","data","gpu","capacity","rootUrl","BaseAssetsUrl","LastCreatedScene","Parse","setEmitterAsSphere","FromArray"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/particleSystemSet.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { ParticleSystem } from \"../Particles/particleSystem\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/** Internal class used to store shapes for emitters */\r\nclass ParticleSystemSetEmitterCreationOptions {\r\n    public kind: string;\r\n    public options: any;\r\n    public renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Represents a set of particle systems working together to create a specific effect\r\n */\r\nexport class ParticleSystemSet implements IDisposable {\r\n    /**\r\n     * Gets or sets base Assets URL\r\n     */\r\n    public static BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\r\n\r\n    private _emitterCreationOptions: ParticleSystemSetEmitterCreationOptions;\r\n    private _emitterNode: Nullable<AbstractMesh | Vector3>;\r\n    private _emitterNodeIsOwned = true;\r\n\r\n    /**\r\n     * Gets the particle system list\r\n     */\r\n    public systems = new Array<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets or sets the emitter node used with this set\r\n     */\r\n    public get emitterNode(): Nullable<AbstractMesh | Vector3> {\r\n        return this._emitterNode;\r\n    }\r\n\r\n    public set emitterNode(value: Nullable<AbstractMesh | Vector3>) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNodeIsOwned = false;\r\n        }\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = value;\r\n        }\r\n\r\n        this._emitterNode = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new emitter mesh as a sphere\r\n     * @param options defines the options used to create the sphere\r\n     * @param options.diameter\r\n     * @param options.segments\r\n     * @param options.color\r\n     * @param renderingGroupId defines the renderingGroupId to use for the sphere\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public setEmitterAsSphere(options: { diameter: number; segments: number; color: Color3 }, renderingGroupId: number, scene: Scene) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n        }\r\n\r\n        this._emitterNodeIsOwned = true;\r\n\r\n        this._emitterCreationOptions = {\r\n            kind: \"Sphere\",\r\n            options: options,\r\n            renderingGroupId: renderingGroupId,\r\n        };\r\n\r\n        const emitterMesh = CreateSphere(\"emitterSphere\", { diameter: options.diameter, segments: options.segments }, scene);\r\n        emitterMesh.renderingGroupId = renderingGroupId;\r\n\r\n        const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\r\n        material.emissiveColor = options.color;\r\n        emitterMesh.material = material;\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = emitterMesh;\r\n        }\r\n\r\n        this._emitterNode = emitterMesh;\r\n    }\r\n\r\n    /**\r\n     * Starts all particle systems of the set\r\n     * @param emitter defines an optional mesh to use as emitter for the particle systems\r\n     */\r\n    public start(emitter?: AbstractMesh): void {\r\n        for (const system of this.systems) {\r\n            if (emitter) {\r\n                system.emitter = emitter;\r\n            }\r\n            system.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        for (const system of this.systems) {\r\n            system.dispose();\r\n        }\r\n\r\n        this.systems = [];\r\n\r\n        if (this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the set into a JSON compatible object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns a JSON compatible representation of the set\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const result: any = {};\r\n\r\n        result.systems = [];\r\n        for (const system of this.systems) {\r\n            result.systems.push(system.serialize(serializeTexture));\r\n        }\r\n\r\n        if (this._emitterNode) {\r\n            result.emitter = this._emitterCreationOptions;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parse a new ParticleSystemSet from a serialized source\r\n     * @param data defines a JSON compatible representation of the set\r\n     * @param scene defines the hosting scene\r\n     * @param gpu defines if we want GPU particles or CPU particles\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a new ParticleSystemSet\r\n     */\r\n    public static Parse(data: any, scene: Scene, gpu = false, capacity?: number): ParticleSystemSet {\r\n        const result = new ParticleSystemSet();\r\n        const rootUrl = this.BaseAssetsUrl + \"/textures/\";\r\n\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        for (const system of data.systems) {\r\n            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\r\n        }\r\n\r\n        if (data.emitter) {\r\n            const options = data.emitter.options;\r\n            switch (data.emitter.kind) {\r\n                case \"Sphere\":\r\n                    result.setEmitterAsSphere(\r\n                        {\r\n                            diameter: options.diameter,\r\n                            segments: options.segments,\r\n                            color: Color3.FromArray(options.color),\r\n                        },\r\n                        data.emitter.renderingGroupId,\r\n                        scene\r\n                    );\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}