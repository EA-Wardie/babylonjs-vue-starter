{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport \"../../../Shaders/noise.fragment.js\";\n/**\n * Class used to generate noise procedural textures\n */\n\nvar NoiseProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(NoiseProceduralTexture, _super);\n  /**\n   * Creates a new NoiseProceduralTexture\n   * @param name defines the name fo the texture\n   * @param size defines the size of the texture (default is 256)\n   * @param scene defines the hosting scene\n   * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\n   * @param generateMipMaps defines if mipmaps must be generated (true by default)\n   */\n\n\n  function NoiseProceduralTexture(name, size, scene, fallbackTexture, generateMipMaps) {\n    if (size === void 0) {\n      size = 256;\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    var _this = _super.call(this, name, size, \"noise\", scene, fallbackTexture, generateMipMaps) || this;\n    /** Gets or sets the start time (default is 0) */\n\n\n    _this.time = 0.0;\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n\n    _this.brightness = 0.2;\n    /** Defines the number of octaves to process */\n\n    _this.octaves = 3;\n    /** Defines the level of persistence (0.8 by default) */\n\n    _this.persistence = 0.8;\n    /** Gets or sets animation speed factor (default is 1) */\n\n    _this.animationSpeedFactor = 1;\n    _this.autoClear = false;\n\n    _this._updateShaderUniforms();\n\n    return _this;\n  }\n\n  NoiseProceduralTexture.prototype._updateShaderUniforms = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n    this.setFloat(\"brightness\", this.brightness);\n    this.setFloat(\"persistence\", this.persistence);\n    this.setFloat(\"timeScale\", this.time);\n  };\n\n  NoiseProceduralTexture.prototype._getDefines = function () {\n    return \"#define OCTAVES \" + (this.octaves | 0);\n  };\n  /**\n   * Generate the current state of the procedural texture\n   * @param useCameraPostProcess\n   */\n\n\n  NoiseProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    this._updateShaderUniforms();\n\n    _super.prototype.render.call(this, useCameraPostProcess);\n  };\n  /**\n   * Serializes this noise procedural texture\n   * @returns a serialized noise procedural texture object\n   */\n\n\n  NoiseProceduralTexture.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n    serializationObject.brightness = this.brightness;\n    serializationObject.octaves = this.octaves;\n    serializationObject.persistence = this.persistence;\n    serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n    serializationObject.size = this.getSize().width;\n    serializationObject.generateMipMaps = this._generateMipMaps;\n    serializationObject.time = this.time;\n    return serializationObject;\n  };\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n\n\n  NoiseProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode; // Noise Specifics\n\n    newTexture.brightness = this.brightness;\n    newTexture.octaves = this.octaves;\n    newTexture.persistence = this.persistence;\n    newTexture.animationSpeedFactor = this.animationSpeedFactor;\n    newTexture.time = this.time;\n    return newTexture;\n  };\n  /**\n   * Creates a NoiseProceduralTexture from parsed noise procedural texture data\n   * @param parsedTexture defines parsed texture data\n   * @param scene defines the current scene\n   * @returns a parsed NoiseProceduralTexture\n   */\n\n\n  NoiseProceduralTexture.Parse = function (parsedTexture, scene) {\n    var _a;\n\n    var texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n    texture.brightness = parsedTexture.brightness;\n    texture.octaves = parsedTexture.octaves;\n    texture.persistence = parsedTexture.persistence;\n    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;\n    return texture;\n  };\n\n  return NoiseProceduralTexture;\n}(ProceduralTexture);\n\nexport { NoiseProceduralTexture };\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);","map":{"version":3,"mappings":"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","names":["EngineStore","ProceduralTexture","RegisterClass","__extends","name","size","scene","fallbackTexture","generateMipMaps","LastCreatedScene","_super","_this","autoClear","_updateShaderUniforms","NoiseProceduralTexture","getScene","time","getAnimationRatio","animationSpeedFactor","setFloat","brightness","persistence","octaves","useCameraPostProcess","render","call","serializationObject","customType","getSize","width","_generateMipMaps","textureSize","newTexture","_fallbackTexture","undefined","hasAlpha","level","coordinatesMode","parsedTexture","texture","_a"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Procedurals/noiseProceduralTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport type { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\nimport \"../../../Shaders/noise.fragment\";\r\n\r\n/**\r\n * Class used to generate noise procedural textures\r\n */\r\nexport class NoiseProceduralTexture extends ProceduralTexture {\r\n    /** Gets or sets the start time (default is 0) */\r\n    public time: number = 0.0;\r\n\r\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\r\n    public brightness = 0.2;\r\n\r\n    /** Defines the number of octaves to process */\r\n    public octaves = 3;\r\n\r\n    /** Defines the level of persistence (0.8 by default) */\r\n    public persistence = 0.8;\r\n\r\n    /** Gets or sets animation speed factor (default is 1) */\r\n    public animationSpeedFactor = 1;\r\n\r\n    /**\r\n     * Creates a new NoiseProceduralTexture\r\n     * @param name defines the name fo the texture\r\n     * @param size defines the size of the texture (default is 256)\r\n     * @param scene defines the hosting scene\r\n     * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\r\n     * @param generateMipMaps defines if mipmaps must be generated (true by default)\r\n     */\r\n    constructor(name: string, size: number = 256, scene: Nullable<Scene> = EngineStore.LastCreatedScene, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\r\n        this.autoClear = false;\r\n        this._updateShaderUniforms();\r\n    }\r\n\r\n    private _updateShaderUniforms() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\r\n\r\n        this.setFloat(\"brightness\", this.brightness);\r\n        this.setFloat(\"persistence\", this.persistence);\r\n        this.setFloat(\"timeScale\", this.time);\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"#define OCTAVES \" + (this.octaves | 0);\r\n    }\r\n\r\n    /**\r\n     * Generate the current state of the procedural texture\r\n     * @param useCameraPostProcess\r\n     */\r\n    public render(useCameraPostProcess?: boolean) {\r\n        this._updateShaderUniforms();\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    /**\r\n     * Serializes this noise procedural texture\r\n     * @returns a serialized noise procedural texture object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\r\n\r\n        serializationObject.brightness = this.brightness;\r\n        serializationObject.octaves = this.octaves;\r\n        serializationObject.persistence = this.persistence;\r\n        serializationObject.animationSpeedFactor = this.animationSpeedFactor;\r\n        serializationObject.size = this.getSize().width;\r\n        serializationObject.generateMipMaps = this._generateMipMaps;\r\n        serializationObject.time = this.time;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): NoiseProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new NoiseProceduralTexture(\r\n            this.name,\r\n            textureSize.width,\r\n            this.getScene(),\r\n            this._fallbackTexture ? this._fallbackTexture : undefined,\r\n            this._generateMipMaps\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        // Noise Specifics\r\n        newTexture.brightness = this.brightness;\r\n        newTexture.octaves = this.octaves;\r\n        newTexture.persistence = this.persistence;\r\n        newTexture.animationSpeedFactor = this.animationSpeedFactor;\r\n        newTexture.time = this.time;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a NoiseProceduralTexture from parsed noise procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @returns a parsed NoiseProceduralTexture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): NoiseProceduralTexture {\r\n        const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\r\n\r\n        texture.brightness = parsedTexture.brightness;\r\n        texture.octaves = parsedTexture.octaves;\r\n        texture.persistence = parsedTexture.persistence;\r\n        texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\r\n        texture.time = parsedTexture.time ?? 0;\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);\r\n"]},"metadata":{},"sourceType":"module"}