{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { ComputePressureObserverWrapper } from \"./Misc/computePressure.js\";\nimport { SliceTools } from \"./Misc/sliceTools.js\";\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/scene\n */\n\nvar Scene =\n/** @class */\nfunction (_super) {\n  __extends(Scene, _super);\n  /**\n   * Creates a new Scene\n   * @param engine defines the engine to use to render this scene\n   * @param options defines the scene options\n   */\n\n\n  function Scene(engine, options) {\n    var _this = _super.call(this) || this; // Members\n\n    /** @hidden */\n\n\n    _this._inputManager = new InputManager(_this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n\n    _this.cameraToUseForPointers = null;\n    /** @hidden */\n\n    _this._isScene = true;\n    /** @hidden */\n\n    _this._blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n\n    _this.autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n\n    _this.autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n\n    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n\n    _this.ambientColor = new Color3(0, 0, 0);\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n\n    _this.environmentIntensity = 1;\n    _this._forceWireframe = false;\n    _this._skipFrustumClipping = false;\n    _this._forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n\n    _this.animationsEnabled = true;\n    _this._animationPropertiesOverride = null;\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n\n    _this.useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n\n    _this.constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n\n    _this.hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n\n    _this.defaultCursor = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n\n    _this.doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n\n    _this.preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n\n    _this.preventDefaultOnPointerUp = true; // Metadata\n\n    /**\n     * Gets or sets user defined metadata\n     */\n\n    _this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n\n    _this.reservedDataStore = null;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n\n    _this.disableOfflineSupportExceptionRules = new Array();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n\n    _this.onBeforeRenderObservable = new Observable();\n    _this._onBeforeRenderObserver = null;\n    /**\n     * An event triggered after rendering the scene\n     */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     */\n\n    _this.onAfterRenderCameraObservable = new Observable();\n    _this._onAfterRenderObserver = null;\n    /**\n     * An event triggered before animating the scene\n     */\n\n    _this.onBeforeAnimationsObservable = new Observable();\n    /**\n     * An event triggered after animations processing\n     */\n\n    _this.onAfterAnimationsObservable = new Observable();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n\n    _this.onBeforeDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n\n    _this.onAfterDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered when the scene is ready\n     */\n\n    _this.onReadyObservable = new Observable();\n    /**\n     * An event triggered before rendering a camera\n     */\n\n    _this.onBeforeCameraRenderObservable = new Observable();\n    _this._onBeforeCameraRenderObserver = null;\n    /**\n     * An event triggered after rendering a camera\n     */\n\n    _this.onAfterCameraRenderObservable = new Observable();\n    _this._onAfterCameraRenderObserver = null;\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n\n    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n\n    _this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n\n    _this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n\n    _this.onAfterParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n\n    _this.onDataLoadedObservable = new Observable();\n    /**\n     * An event triggered when a camera is created\n     */\n\n    _this.onNewCameraAddedObservable = new Observable();\n    /**\n     * An event triggered when a camera is removed\n     */\n\n    _this.onCameraRemovedObservable = new Observable();\n    /**\n     * An event triggered when a light is created\n     */\n\n    _this.onNewLightAddedObservable = new Observable();\n    /**\n     * An event triggered when a light is removed\n     */\n\n    _this.onLightRemovedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is created\n     */\n\n    _this.onNewGeometryAddedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is removed\n     */\n\n    _this.onGeometryRemovedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is created\n     */\n\n    _this.onNewTransformNodeAddedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is removed\n     */\n\n    _this.onTransformNodeRemovedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is created\n     */\n\n    _this.onNewMeshAddedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is removed\n     */\n\n    _this.onMeshRemovedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is created\n     */\n\n    _this.onNewSkeletonAddedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n\n    _this.onSkeletonRemovedObservable = new Observable();\n    /**\n     * An event triggered when a material is created\n     */\n\n    _this.onNewMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is created\n     */\n\n    _this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a material is removed\n     */\n\n    _this.onMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is removed\n     */\n\n    _this.onMultiMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a texture is created\n     */\n\n    _this.onNewTextureAddedObservable = new Observable();\n    /**\n     * An event triggered when a texture is removed\n     */\n\n    _this.onTextureRemovedObservable = new Observable();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n\n    _this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n\n    _this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n\n    _this.onBeforeStepObservable = new Observable();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n\n    _this.onAfterStepObservable = new Observable();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n\n    _this.onActiveCameraChanged = new Observable();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n\n    _this.onBeforeRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n\n    _this.onAfterRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n\n    _this.onMeshImportedObservable = new Observable();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n\n    _this.onAnimationFileImportedObservable = new Observable(); // Animations\n\n    /** @hidden */\n\n    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n     */\n\n    _this.skipPointerMovePicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n     */\n\n    _this.skipPointerDownPicking = false;\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n\n    _this.onPrePointerObservable = new Observable();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n\n    _this.onPointerObservable = new Observable(); // Keyboard\n\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n\n    _this.onPreKeyboardObservable = new Observable();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n\n    _this.onKeyboardObservable = new Observable(); // Coordinates system\n\n    _this._useRightHandedSystem = false; // Deterministic lockstep\n\n    _this._timeAccumulator = 0;\n    _this._currentStepId = 0;\n    _this._currentInternalStep = 0; // Fog\n\n    _this._fogEnabled = true;\n    _this._fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n\n    _this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0.1)\n     */\n\n    _this.fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0)\n     */\n\n    _this.fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 1000)\n     */\n\n    _this.fogEnd = 1000.0;\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n\n    _this.needsPreviousWorldMatrices = false; // Lights\n\n    _this._shadowsEnabled = true;\n    _this._lightsEnabled = true;\n    /** All of the active cameras added to this scene. */\n\n    _this.activeCameras = new Array(); // Textures\n\n    _this._texturesEnabled = true; // Physics\n\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n\n    _this.physicsEnabled = true; // Particles\n\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n\n    _this.particlesEnabled = true; // Sprites\n\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n\n    _this.spritesEnabled = true; // Skeletons\n\n    _this._skeletonsEnabled = true; // Lens flares\n\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n\n    _this.lensFlaresEnabled = true; // Collisions\n\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.collisionsEnabled = true;\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.gravity = new Vector3(0, -9.807, 0); // Postprocesses\n\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n\n    _this.postProcessesEnabled = true; // Customs render targets\n\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n\n    _this.renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n\n    _this.dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n\n    _this.customRenderTargets = new Array();\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n\n    _this.importedMeshesFiles = new Array(); // Probes\n\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n\n    _this.probesEnabled = true;\n    _this._meshesForIntersections = new SmartArrayNoDuplicate(256); // Procedural textures\n\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n\n    _this.proceduralTexturesEnabled = true; // Performance counters\n\n    _this._totalVertices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeIndices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeParticles = new PerfCounter();\n    /** @hidden */\n\n    _this._activeBones = new PerfCounter();\n    /** @hidden */\n\n    _this._animationTime = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n\n    _this.animationTimeScale = 1;\n    _this._renderId = 0;\n    _this._frameId = 0;\n    _this._executeWhenReadyTimeoutId = null;\n    _this._intermediateRendering = false;\n    _this._defaultFrameBufferCleared = false;\n    _this._viewUpdateFlag = -1;\n    _this._projectionUpdateFlag = -1;\n    /** @hidden */\n\n    _this._toBeDisposed = new Array(256);\n    _this._activeRequests = new Array();\n    /** @hidden */\n\n    _this._pendingData = new Array();\n    _this._isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n\n    _this.dispatchAllSubMeshesOfActiveMeshes = false;\n    _this._activeMeshes = new SmartArray(256);\n    _this._processedMaterials = new SmartArray(256);\n    _this._renderTargets = new SmartArrayNoDuplicate(256);\n    _this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n    /** @hidden */\n\n    _this._activeParticleSystems = new SmartArray(256);\n    _this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @hidden */\n\n    _this._activeAnimatables = new Array();\n    _this._transformMatrix = Matrix.Zero();\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n\n    _this.requireLightSorting = false;\n    /**\n     * @hidden\n     * Backing store of defined scene components.\n     */\n\n    _this._components = [];\n    /**\n     * @hidden\n     * Backing store of defined scene components.\n     */\n\n    _this._serializableComponents = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n\n    _this._transientComponents = [];\n    /**\n     * @hidden\n     * Defines the actions happening before camera updates.\n     */\n\n    _this._beforeCameraUpdateStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening before clear the canvas.\n     */\n\n    _this._beforeClearStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening before clear the canvas.\n     */\n\n    _this._beforeRenderTargetClearStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions when collecting render targets for the frame.\n     */\n\n    _this._gatherRenderTargetsStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening for one camera in the frame.\n     */\n\n    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening during the per mesh ready checks.\n     */\n\n    _this._isReadyForMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n\n    _this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n\n    _this._evaluateSubMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening during the active mesh stage.\n     */\n\n    _this._preActiveMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening during the per camera render target step.\n     */\n\n    _this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just before the active camera is drawing.\n     */\n\n    _this._beforeCameraDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just before a render target is drawing.\n     */\n\n    _this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n\n    _this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just before a mesh is drawing.\n     */\n\n    _this._beforeRenderingMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n\n    _this._afterRenderingMeshStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n\n    _this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n\n    _this._afterCameraDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just after a render target has been drawn.\n     */\n\n    _this._afterRenderTargetDrawStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n\n    _this._afterRenderStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer move event happens.\n     */\n\n    _this._pointerMoveStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer down event happens.\n     */\n\n    _this._pointerDownStage = Stage.Create();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer up event happens.\n     */\n\n    _this._pointerUpStage = Stage.Create();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n\n    _this._geometriesByUniqueId = null;\n    _this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @hidden */\n\n    _this._activeMeshesFrozen = false;\n    _this._skipEvaluateActiveMeshesCompletely = false;\n    /** @hidden */\n\n    _this._allowPostProcessClearColor = true;\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n\n    _this.getDeterministicFrameTime = function () {\n      return _this._engine.getTimeStep();\n    };\n\n    _this._blockMaterialDirtyMechanism = false;\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n\n    _this._perfCollector = null;\n    /**\n     * An event triggered when the cpu usage/speed meets certain thresholds.\n     * Note: Compute pressure is an experimental API.\n     */\n\n    _this.onComputePressureChanged = new Observable();\n\n    var fullOptions = __assign({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n\n    _this._engine = engine || EngineStore.LastCreatedEngine;\n\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = _this;\n\n      _this._engine.scenes.push(_this);\n    } else {\n      _this._engine._virtualScenes.push(_this);\n    }\n\n    _this._uid = null;\n    _this._renderingManager = new RenderingManager(_this);\n\n    if (PostProcessManager) {\n      _this.postProcessManager = new PostProcessManager(_this);\n    }\n\n    if (IsWindowObjectExist()) {\n      _this.attachControl();\n    } // Uniform Buffer\n\n\n    _this._createUbo(); // Default Image processing definition\n\n\n    if (ImageProcessingConfiguration) {\n      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n\n    _this.setDefaultCandidateProviders();\n\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      _this._geometriesByUniqueId = {};\n    }\n\n    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n\n    if (!options || !options.virtual) {\n      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);\n    }\n\n    if (ComputePressureObserverWrapper.IsAvailable) {\n      _this._computePressureObserver = new ComputePressureObserverWrapper(function (update) {\n        _this.onComputePressureChanged.notifyObservers(update);\n      }, {\n        // Thresholds divide the interval [0.0 .. 1.0] into ranges.\n        cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],\n        cpuSpeedThresholds: [0.5]\n      });\n\n      _this._computePressureObserver.observe();\n    }\n\n    return _this;\n  }\n  /**\n   * Factory used to create the default material.\n   * @param scene The scene to create the material for\n   * @returns The default material\n   */\n\n\n  Scene.DefaultMaterialFactory = function (scene) {\n    throw _WarnImport(\"StandardMaterial\");\n  };\n  /**\n   * Factory used to create the a collision coordinator.\n   * @returns The collision coordinator\n   */\n\n\n  Scene.CollisionCoordinatorFactory = function () {\n    throw _WarnImport(\"DefaultCollisionCoordinator\");\n  };\n\n  Object.defineProperty(Scene.prototype, \"environmentTexture\", {\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    get: function get() {\n      return this._environmentTexture;\n    },\n\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */\n    set: function set(value) {\n      if (this._environmentTexture === value) {\n        return;\n      }\n\n      this._environmentTexture = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"imageProcessingConfiguration\", {\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forceWireframe\", {\n    get: function get() {\n      return this._forceWireframe;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n    set: function set(value) {\n      if (this._forceWireframe === value) {\n        return;\n      }\n\n      this._forceWireframe = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skipFrustumClipping\", {\n    get: function get() {\n      return this._skipFrustumClipping;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */\n    set: function set(value) {\n      if (this._skipFrustumClipping === value) {\n        return;\n      }\n\n      this._skipFrustumClipping = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forcePointsCloud\", {\n    get: function get() {\n      return this._forcePointsCloud;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */\n    set: function set(value) {\n      if (this._forcePointsCloud === value) {\n        return;\n      }\n\n      this._forcePointsCloud = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"animationPropertiesOverride\", {\n    /**\n     * Gets or sets the animation properties override\n     */\n    get: function get() {\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDispose\", {\n    /** Sets a function to be executed when this scene is disposed. */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeRender\", {\n    /** Sets a function to be executed before rendering this scene */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      if (callback) {\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterRender\", {\n    /** Sets a function to be executed after rendering this scene */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      if (callback) {\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeCameraRender\", {\n    /** Sets a function to be executed before rendering a camera*/\n    set: function set(callback) {\n      if (this._onBeforeCameraRenderObserver) {\n        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n      }\n\n      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterCameraRender\", {\n    /** Sets a function to be executed after rendering a camera*/\n    set: function set(callback) {\n      if (this._onAfterCameraRenderObserver) {\n        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n      }\n\n      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"unTranslatedPointer\", {\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n    get: function get() {\n      return this._inputManager.unTranslatedPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DragMovementThreshold\", {\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n    get: function get() {\n      return InputManager.DragMovementThreshold;\n    },\n    set: function set(value) {\n      InputManager.DragMovementThreshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"LongPressDelay\", {\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n    get: function get() {\n      return InputManager.LongPressDelay;\n    },\n    set: function set(value) {\n      InputManager.LongPressDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DoubleClickDelay\", {\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n    get: function get() {\n      return InputManager.DoubleClickDelay;\n    },\n    set: function set(value) {\n      InputManager.DoubleClickDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"ExclusiveDoubleClickMode\", {\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    get: function get() {\n      return InputManager.ExclusiveDoubleClickMode;\n    },\n    set: function set(value) {\n      InputManager.ExclusiveDoubleClickMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Bind the current view position to an effect.\n   * @param effect The effect to be bound\n   * @param variableName name of the shader variable that will hold the eye position\n   * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n   * @return the computed eye position\n   */\n\n  Scene.prototype.bindEyePosition = function (effect, variableName, isVector3) {\n    var _a;\n\n    if (variableName === void 0) {\n      variableName = \"vEyePosition\";\n    }\n\n    if (isVector3 === void 0) {\n      isVector3 = false;\n    }\n\n    var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;\n    var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n\n    if (effect) {\n      if (isVector3) {\n        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n      } else {\n        effect.setVector4(variableName, TmpVectors.Vector4[0]);\n      }\n    }\n\n    return TmpVectors.Vector4[0];\n  };\n  /**\n   * Update the scene ubo before it can be used in rendering processing\n   * @returns the scene UniformBuffer\n   */\n\n\n  Scene.prototype.finalizeSceneUbo = function () {\n    var ubo = this.getSceneUniformBuffer();\n    var eyePosition = this.bindEyePosition(null);\n    ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n    ubo.update();\n    return ubo;\n  };\n\n  Object.defineProperty(Scene.prototype, \"useRightHandedSystem\", {\n    get: function get() {\n      return this._useRightHandedSystem;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n    set: function set(value) {\n      if (this._useRightHandedSystem === value) {\n        return;\n      }\n\n      this._useRightHandedSystem = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   * @param newStepId defines the step Id\n   */\n\n  Scene.prototype.setStepId = function (newStepId) {\n    this._currentStepId = newStepId;\n  };\n  /**\n   * Gets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   * @returns the step Id\n   */\n\n\n  Scene.prototype.getStepId = function () {\n    return this._currentStepId;\n  };\n  /**\n   * Gets the internal step used by deterministic lock step\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   * @returns the internal step\n   */\n\n\n  Scene.prototype.getInternalStep = function () {\n    return this._currentInternalStep;\n  };\n\n  Object.defineProperty(Scene.prototype, \"fogEnabled\", {\n    get: function get() {\n      return this._fogEnabled;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is true)\n     */\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"fogMode\", {\n    get: function get() {\n      return this._fogMode;\n    },\n\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */\n    set: function set(value) {\n      if (this._fogMode === value) {\n        return;\n      }\n\n      this._fogMode = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"prePass\", {\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */\n    get: function get() {\n      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"shadowsEnabled\", {\n    get: function get() {\n      return this._shadowsEnabled;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n    set: function set(value) {\n      if (this._shadowsEnabled === value) {\n        return;\n      }\n\n      this._shadowsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"lightsEnabled\", {\n    get: function get() {\n      return this._lightsEnabled;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */\n    set: function set(value) {\n      if (this._lightsEnabled === value) {\n        return;\n      }\n\n      this._lightsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"activeCamera\", {\n    /** Gets or sets the current active camera */\n    get: function get() {\n      return this._activeCamera;\n    },\n    set: function set(value) {\n      if (value === this._activeCamera) {\n        return;\n      }\n\n      this._activeCamera = value;\n      this.onActiveCameraChanged.notifyObservers(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"defaultMaterial\", {\n    /** The default material used on meshes when no material is affected */\n    get: function get() {\n      if (!this._defaultMaterial) {\n        this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n      }\n\n      return this._defaultMaterial;\n    },\n\n    /** The default material used on meshes when no material is affected */\n    set: function set(value) {\n      this._defaultMaterial = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"texturesEnabled\", {\n    get: function get() {\n      return this._texturesEnabled;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n    set: function set(value) {\n      if (this._texturesEnabled === value) {\n        return;\n      }\n\n      this._texturesEnabled = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skeletonsEnabled\", {\n    get: function get() {\n      return this._skeletonsEnabled;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */\n    set: function set(value) {\n      if (this._skeletonsEnabled === value) {\n        return;\n      }\n\n      this._skeletonsEnabled = value;\n      this.markAllMaterialsAsDirty(8);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"collisionCoordinator\", {\n    /** @hidden */\n    get: function get() {\n      if (!this._collisionCoordinator) {\n        this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n\n        this._collisionCoordinator.init(this);\n      }\n\n      return this._collisionCoordinator;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"frustumPlanes\", {\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n    get: function get() {\n      return this._frustumPlanes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Registers the transient components if needed.\n   */\n\n  Scene.prototype._registerTransientComponents = function () {\n    // Register components that have been associated lately to the scene.\n    if (this._transientComponents.length > 0) {\n      for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {\n        var component = _a[_i];\n        component.register();\n      }\n\n      this._transientComponents = [];\n    }\n  };\n  /**\n   * @hidden\n   * Add a component to the scene.\n   * Note that the ccomponent could be registered on th next frame if this is called after\n   * the register component stage.\n   * @param component Defines the component to add to the scene\n   */\n\n\n  Scene.prototype._addComponent = function (component) {\n    this._components.push(component);\n\n    this._transientComponents.push(component);\n\n    var serializableComponent = component;\n\n    if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n      this._serializableComponents.push(serializableComponent);\n    }\n  };\n  /**\n   * @hidden\n   * Gets a component from the scene.\n   * @param name defines the name of the component to retrieve\n   * @returns the component or null if not present\n   */\n\n\n  Scene.prototype._getComponent = function (name) {\n    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {\n      var component = _a[_i];\n\n      if (component.name === name) {\n        return component;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"Scene\" string\n   */\n\n\n  Scene.prototype.getClassName = function () {\n    return \"Scene\";\n  };\n  /**\n   * @hidden\n   */\n\n\n  Scene.prototype._getDefaultMeshCandidates = function () {\n    this._defaultMeshCandidates.data = this.meshes;\n    this._defaultMeshCandidates.length = this.meshes.length;\n    return this._defaultMeshCandidates;\n  };\n  /**\n   * @param mesh\n   * @hidden\n   */\n\n\n  Scene.prototype._getDefaultSubMeshCandidates = function (mesh) {\n    this._defaultSubMeshCandidates.data = mesh.subMeshes;\n    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n    return this._defaultSubMeshCandidates;\n  };\n  /**\n   * Sets the default candidate providers for the scene.\n   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n   * and getCollidingSubMeshCandidates to their default function\n   */\n\n\n  Scene.prototype.setDefaultCandidateProviders = function () {\n    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n  };\n\n  Object.defineProperty(Scene.prototype, \"meshUnderPointer\", {\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n    get: function get() {\n      return this._inputManager.meshUnderPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerX\", {\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n    get: function get() {\n      return this._inputManager.pointerX;\n    },\n    set: function set(value) {\n      this._inputManager.pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerY\", {\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n    get: function get() {\n      return this._inputManager.pointerY;\n    },\n    set: function set(value) {\n      this._inputManager.pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the cached material (ie. the latest rendered one)\n   * @returns the cached material\n   */\n\n  Scene.prototype.getCachedMaterial = function () {\n    return this._cachedMaterial;\n  };\n  /**\n   * Gets the cached effect (ie. the latest rendered one)\n   * @returns the cached effect\n   */\n\n\n  Scene.prototype.getCachedEffect = function () {\n    return this._cachedEffect;\n  };\n  /**\n   * Gets the cached visibility state (ie. the latest rendered one)\n   * @returns the cached visibility state\n   */\n\n\n  Scene.prototype.getCachedVisibility = function () {\n    return this._cachedVisibility;\n  };\n  /**\n   * Gets a boolean indicating if the current material / effect / visibility must be bind again\n   * @param material defines the current material\n   * @param effect defines the current effect\n   * @param visibility defines the current visibility state\n   * @returns true if one parameter is not cached\n   */\n\n\n  Scene.prototype.isCachedMaterialInvalid = function (material, effect, visibility) {\n    if (visibility === void 0) {\n      visibility = 1;\n    }\n\n    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n  };\n  /**\n   * Gets the engine associated with the scene\n   * @returns an Engine\n   */\n\n\n  Scene.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * Gets the total number of vertices rendered per frame\n   * @returns the total number of vertices rendered per frame\n   */\n\n\n  Scene.prototype.getTotalVertices = function () {\n    return this._totalVertices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalVerticesPerfCounter\", {\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    get: function get() {\n      return this._totalVertices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n   * @returns the total number of active indices rendered per frame\n   */\n\n  Scene.prototype.getActiveIndices = function () {\n    return this._activeIndices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalActiveIndicesPerfCounter\", {\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    get: function get() {\n      return this._activeIndices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the total number of active particles rendered per frame\n   * @returns the total number of active particles rendered per frame\n   */\n\n  Scene.prototype.getActiveParticles = function () {\n    return this._activeParticles.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeParticlesPerfCounter\", {\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    get: function get() {\n      return this._activeParticles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the total number of active bones rendered per frame\n   * @returns the total number of active bones rendered per frame\n   */\n\n  Scene.prototype.getActiveBones = function () {\n    return this._activeBones.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeBonesPerfCounter\", {\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    get: function get() {\n      return this._activeBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the array of active meshes\n   * @returns an array of AbstractMesh\n   */\n\n  Scene.prototype.getActiveMeshes = function () {\n    return this._activeMeshes;\n  };\n  /**\n   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n   * @returns a number\n   */\n\n\n  Scene.prototype.getAnimationRatio = function () {\n    return this._animationRatio !== undefined ? this._animationRatio : 1;\n  };\n  /**\n   * Gets an unique Id for the current render phase\n   * @returns a number\n   */\n\n\n  Scene.prototype.getRenderId = function () {\n    return this._renderId;\n  };\n  /**\n   * Gets an unique Id for the current frame\n   * @returns a number\n   */\n\n\n  Scene.prototype.getFrameId = function () {\n    return this._frameId;\n  };\n  /** Call this function if you want to manually increment the render Id*/\n\n\n  Scene.prototype.incrementRenderId = function () {\n    this._renderId++;\n  };\n\n  Scene.prototype._createUbo = function () {\n    this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n  };\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n\n    return this;\n  };\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n\n\n  Scene.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._inputManager.isPointerCaptured(pointerId);\n  };\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp defines if you want to attach events to pointerup\n   * @param attachDown defines if you want to attach events to pointerdown\n   * @param attachMove defines if you want to attach events to pointermove\n   */\n\n\n  Scene.prototype.attachControl = function (attachUp, attachDown, attachMove) {\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    this._inputManager.attachControl(attachUp, attachDown, attachMove);\n  };\n  /** Detaches all event handlers*/\n\n\n  Scene.prototype.detachControl = function () {\n    this._inputManager.detachControl();\n  };\n  /**\n   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n   * Delay loaded resources are not taking in account\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n   * @return true if all required resources are ready\n   */\n\n\n  Scene.prototype.isReady = function (checkRenderTargets) {\n    if (checkRenderTargets === void 0) {\n      checkRenderTargets = true;\n    }\n\n    if (this._isDisposed) {\n      return false;\n    }\n\n    var index;\n    var engine = this.getEngine(); // Pending data\n\n    if (this._pendingData.length > 0) {\n      return false;\n    } // Meshes\n\n\n    if (checkRenderTargets) {\n      this._processedMaterials.reset();\n\n      this._materialsRenderTargets.reset();\n    }\n\n    var isReady = true;\n\n    for (index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (!mesh.isEnabled()) {\n        continue;\n      }\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n        continue;\n      }\n\n      if (!mesh.isReady(true)) {\n        isReady = false;\n        continue;\n      }\n\n      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0; // Is Ready For Mesh\n\n      for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n\n        if (!step.action(mesh, hardwareInstancedRendering)) {\n          isReady = false;\n        }\n      }\n\n      if (!checkRenderTargets) {\n        continue;\n      }\n\n      var mat = mesh.material || this.defaultMaterial;\n\n      if (mat) {\n        if (mat._storeEffectOnSubMeshes) {\n          for (var _b = 0, _c = mesh.subMeshes; _b < _c.length; _b++) {\n            var subMesh = _c[_b];\n            var material = subMesh.getMaterial();\n\n            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n              if (this._processedMaterials.indexOf(material) === -1) {\n                this._processedMaterials.push(material);\n\n                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n              }\n            }\n          }\n        } else {\n          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n            if (this._processedMaterials.indexOf(mat) === -1) {\n              this._processedMaterials.push(mat);\n\n              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n            }\n          }\n        }\n      }\n    }\n\n    if (!isReady) {\n      return false;\n    } // Effects\n\n\n    if (!engine.areAllEffectsReady()) {\n      return false;\n    } // Render targets\n\n\n    if (checkRenderTargets) {\n      for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n        var rtt = this._materialsRenderTargets.data[index];\n\n        if (!rtt.isReadyForRendering()) {\n          return false;\n        }\n      }\n    } // Geometries\n\n\n    for (index = 0; index < this.geometries.length; index++) {\n      var geometry = this.geometries[index];\n\n      if (geometry.delayLoadState === 2) {\n        return false;\n      }\n    } // Post-processes\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var _d = 0, _e = this.activeCameras; _d < _e.length; _d++) {\n        var camera = _e[_d];\n\n        if (!camera.isReady(true)) {\n          return false;\n        }\n      }\n    } else if (this.activeCamera) {\n      if (!this.activeCamera.isReady(true)) {\n        return false;\n      }\n    } // Particles\n\n\n    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {\n      var particleSystem = _g[_f];\n\n      if (!particleSystem.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /** Resets all cached information relative to material (including effect and visibility) */\n\n\n  Scene.prototype.resetCachedMaterial = function () {\n    this._cachedMaterial = null;\n    this._cachedEffect = null;\n    this._cachedVisibility = null;\n  };\n  /**\n   * Registers a function to be called before every frame render\n   * @param func defines the function to register\n   */\n\n\n  Scene.prototype.registerBeforeRender = function (func) {\n    this.onBeforeRenderObservable.add(func);\n  };\n  /**\n   * Unregisters a function called before every frame render\n   * @param func defines the function to unregister\n   */\n\n\n  Scene.prototype.unregisterBeforeRender = function (func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n  };\n  /**\n   * Registers a function to be called after every frame render\n   * @param func defines the function to register\n   */\n\n\n  Scene.prototype.registerAfterRender = function (func) {\n    this.onAfterRenderObservable.add(func);\n  };\n  /**\n   * Unregisters a function called after every frame render\n   * @param func defines the function to unregister\n   */\n\n\n  Scene.prototype.unregisterAfterRender = function (func) {\n    this.onAfterRenderObservable.removeCallback(func);\n  };\n\n  Scene.prototype._executeOnceBeforeRender = function (func) {\n    var _this = this;\n\n    var execFunc = function execFunc() {\n      func();\n      setTimeout(function () {\n        _this.unregisterBeforeRender(execFunc);\n      });\n    };\n\n    this.registerBeforeRender(execFunc);\n  };\n  /**\n   * The provided function will run before render once and will be disposed afterwards.\n   * A timeout delay can be provided so that the function will be executed in N ms.\n   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n   * @param func The function to be executed.\n   * @param timeout optional delay in ms\n   */\n\n\n  Scene.prototype.executeOnceBeforeRender = function (func, timeout) {\n    var _this = this;\n\n    if (timeout !== undefined) {\n      setTimeout(function () {\n        _this._executeOnceBeforeRender(func);\n      }, timeout);\n    } else {\n      this._executeOnceBeforeRender(func);\n    }\n  };\n  /**\n   * @param data\n   * @hidden\n   */\n\n\n  Scene.prototype._addPendingData = function (data) {\n    this._pendingData.push(data);\n  };\n  /**\n   * @param data\n   * @hidden\n   */\n\n\n  Scene.prototype._removePendingData = function (data) {\n    var wasLoading = this.isLoading;\n\n    var index = this._pendingData.indexOf(data);\n\n    if (index !== -1) {\n      this._pendingData.splice(index, 1);\n    }\n\n    if (wasLoading && !this.isLoading) {\n      this.onDataLoadedObservable.notifyObservers(this);\n    }\n  };\n  /**\n   * Returns the number of items waiting to be loaded\n   * @returns the number of items waiting to be loaded\n   */\n\n\n  Scene.prototype.getWaitingItemsCount = function () {\n    return this._pendingData.length;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isLoading\", {\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n    get: function get() {\n      return this._pendingData.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Registers a function to be executed when the scene is ready\n   * @param {Function} func - the function to be executed\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   */\n\n  Scene.prototype.executeWhenReady = function (func, checkRenderTargets) {\n    var _this = this;\n\n    if (checkRenderTargets === void 0) {\n      checkRenderTargets = false;\n    }\n\n    this.onReadyObservable.add(func);\n\n    if (this._executeWhenReadyTimeoutId !== null) {\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady(checkRenderTargets);\n    }, 150);\n  };\n  /**\n   * Returns a promise that resolves when the scene is ready\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   * @returns A promise that resolves when the scene is ready\n   */\n\n\n  Scene.prototype.whenReadyAsync = function (checkRenderTargets) {\n    var _this = this;\n\n    if (checkRenderTargets === void 0) {\n      checkRenderTargets = false;\n    }\n\n    return new Promise(function (resolve) {\n      _this.executeWhenReady(function () {\n        resolve();\n      }, checkRenderTargets);\n    });\n  };\n  /**\n   * @param checkRenderTargets\n   * @hidden\n   */\n\n\n  Scene.prototype._checkIsReady = function (checkRenderTargets) {\n    var _this = this;\n\n    if (checkRenderTargets === void 0) {\n      checkRenderTargets = false;\n    }\n\n    this._registerTransientComponents();\n\n    if (this.isReady(checkRenderTargets)) {\n      this.onReadyObservable.notifyObservers(this);\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n\n    if (this._isDisposed) {\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady(checkRenderTargets);\n    }, 100);\n  };\n\n  Object.defineProperty(Scene.prototype, \"animatables\", {\n    /**\n     * Gets all animatable attached to the scene\n     */\n    get: function get() {\n      return this._activeAnimatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Resets the last animation time frame.\n   * Useful to override when animations start running when loading a scene for the first time.\n   */\n\n  Scene.prototype.resetLastAnimationTimeFrame = function () {\n    this._animationTimeLast = PrecisionDate.Now;\n  }; // Matrix\n\n  /**\n   * Gets the current view matrix\n   * @returns a Matrix\n   */\n\n\n  Scene.prototype.getViewMatrix = function () {\n    return this._viewMatrix;\n  };\n  /**\n   * Gets the current projection matrix\n   * @returns a Matrix\n   */\n\n\n  Scene.prototype.getProjectionMatrix = function () {\n    return this._projectionMatrix;\n  };\n  /**\n   * Gets the current transform matrix\n   * @returns a Matrix made of View * Projection\n   */\n\n\n  Scene.prototype.getTransformMatrix = function () {\n    return this._transformMatrix;\n  };\n  /**\n   * Sets the current transform matrix\n   * @param viewL defines the View matrix to use\n   * @param projectionL defines the Projection matrix to use\n   * @param viewR defines the right View matrix to use (if provided)\n   * @param projectionR defines the right Projection matrix to use (if provided)\n   */\n\n\n  Scene.prototype.setTransformMatrix = function (viewL, projectionL, viewR, projectionR) {\n    // clear the multiviewSceneUbo if no viewR and projectionR are defined\n    if (!viewR && !projectionR && this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n\n      this._multiviewSceneUbo = null;\n    }\n\n    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n      return;\n    }\n\n    this._viewUpdateFlag = viewL.updateFlag;\n    this._projectionUpdateFlag = projectionL.updateFlag;\n    this._viewMatrix = viewL;\n    this._projectionMatrix = projectionL;\n\n    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix); // Update frustum\n\n\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n\n    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n      this._updateMultiviewUbo(viewR, projectionR);\n    } else if (this._sceneUbo.useUbo) {\n      this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n\n      this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n      this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n    }\n  };\n  /**\n   * Gets the uniform buffer used to store scene data\n   * @returns a UniformBuffer\n   */\n\n\n  Scene.prototype.getSceneUniformBuffer = function () {\n    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n  };\n  /**\n   * Creates a scene UBO\n   * @param name name of the uniform buffer (optional, for debugging purpose only)\n   * @returns a new ubo\n   */\n\n\n  Scene.prototype.createSceneUniformBuffer = function (name) {\n    var sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n    sceneUbo.addUniform(\"viewProjection\", 16);\n    sceneUbo.addUniform(\"view\", 16);\n    sceneUbo.addUniform(\"projection\", 16);\n    sceneUbo.addUniform(\"vEyePosition\", 4);\n    return sceneUbo;\n  };\n  /**\n   * Sets the scene ubo\n   * @param ubo the ubo to set for the scene\n   */\n\n\n  Scene.prototype.setSceneUniformBuffer = function (ubo) {\n    this._sceneUbo = ubo;\n    this._viewUpdateFlag = -1;\n    this._projectionUpdateFlag = -1;\n  };\n  /**\n   * Gets an unique (relatively to the current scene) Id\n   * @returns an unique number for the scene\n   */\n\n\n  Scene.prototype.getUniqueId = function () {\n    return UniqueIdGenerator.UniqueId;\n  };\n  /**\n   * Add a mesh to the list of scene's meshes\n   * @param newMesh defines the mesh to add\n   * @param recursive if all child meshes should also be added to the scene\n   */\n\n\n  Scene.prototype.addMesh = function (newMesh, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.meshes.push(newMesh);\n\n    newMesh._resyncLightSources();\n\n    if (!newMesh.parent) {\n      newMesh._addToSceneRootNodes();\n    }\n\n    this.onNewMeshAddedObservable.notifyObservers(newMesh);\n\n    if (recursive) {\n      newMesh.getChildMeshes().forEach(function (m) {\n        _this.addMesh(m);\n      });\n    }\n  };\n  /**\n   * Remove a mesh for the list of scene's meshes\n   * @param toRemove defines the mesh to remove\n   * @param recursive if all child meshes should also be removed from the scene\n   * @returns the index where the mesh was in the mesh list\n   */\n\n\n  Scene.prototype.removeMesh = function (toRemove, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    var index = this.meshes.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.meshes[index] = this.meshes[this.meshes.length - 1];\n      this.meshes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this._inputManager._invalidateMesh(toRemove);\n\n    this.onMeshRemovedObservable.notifyObservers(toRemove);\n\n    if (recursive) {\n      toRemove.getChildMeshes().forEach(function (m) {\n        _this.removeMesh(m);\n      });\n    }\n\n    return index;\n  };\n  /**\n   * Add a transform node to the list of scene's transform nodes\n   * @param newTransformNode defines the transform node to add\n   */\n\n\n  Scene.prototype.addTransformNode = function (newTransformNode) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n      // Already there?\n      return;\n    }\n\n    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n    this.transformNodes.push(newTransformNode);\n\n    if (!newTransformNode.parent) {\n      newTransformNode._addToSceneRootNodes();\n    }\n\n    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n  };\n  /**\n   * Remove a transform node for the list of scene's transform nodes\n   * @param toRemove defines the transform node to remove\n   * @returns the index where the transform node was in the transform node list\n   */\n\n\n  Scene.prototype.removeTransformNode = function (toRemove) {\n    var index = toRemove._indexInSceneTransformNodesArray;\n\n    if (index !== -1) {\n      if (index !== this.transformNodes.length - 1) {\n        var lastNode = this.transformNodes[this.transformNodes.length - 1];\n        this.transformNodes[index] = lastNode;\n        lastNode._indexInSceneTransformNodesArray = index;\n      }\n\n      toRemove._indexInSceneTransformNodesArray = -1;\n      this.transformNodes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Remove a skeleton for the list of scene's skeletons\n   * @param toRemove defines the skeleton to remove\n   * @returns the index where the skeleton was in the skeleton list\n   */\n\n\n  Scene.prototype.removeSkeleton = function (toRemove) {\n    var index = this.skeletons.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.skeletons.splice(index, 1);\n      this.onSkeletonRemovedObservable.notifyObservers(toRemove); // Clean active container\n\n      this._executeActiveContainerCleanup(this._activeSkeletons);\n    }\n\n    return index;\n  };\n  /**\n   * Remove a morph target for the list of scene's morph targets\n   * @param toRemove defines the morph target to remove\n   * @returns the index where the morph target was in the morph target list\n   */\n\n\n  Scene.prototype.removeMorphTargetManager = function (toRemove) {\n    var index = this.morphTargetManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.morphTargetManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\n   * Remove a light for the list of scene's lights\n   * @param toRemove defines the light to remove\n   * @returns the index where the light was in the light list\n   */\n\n\n  Scene.prototype.removeLight = function (toRemove) {\n    var index = this.lights.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from meshes\n      for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n        var mesh = _a[_i];\n\n        mesh._removeLightSource(toRemove, false);\n      } // Remove from the scene if mesh found\n\n\n      this.lights.splice(index, 1);\n      this.sortLightsByPriority();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onLightRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Remove a camera for the list of scene's cameras\n   * @param toRemove defines the camera to remove\n   * @returns the index where the camera was in the camera list\n   */\n\n\n  Scene.prototype.removeCamera = function (toRemove) {\n    var index = this.cameras.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.cameras.splice(index, 1);\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    } // Remove from activeCameras\n\n\n    if (this.activeCameras) {\n      var index2 = this.activeCameras.indexOf(toRemove);\n\n      if (index2 !== -1) {\n        // Remove from the scene if mesh found\n        this.activeCameras.splice(index2, 1);\n      }\n    } // Reset the activeCamera\n\n\n    if (this.activeCamera === toRemove) {\n      if (this.cameras.length > 0) {\n        this.activeCamera = this.cameras[0];\n      } else {\n        this.activeCamera = null;\n      }\n    }\n\n    this.onCameraRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Remove a particle system for the list of scene's particle systems\n   * @param toRemove defines the particle system to remove\n   * @returns the index where the particle system was in the particle system list\n   */\n\n\n  Scene.prototype.removeParticleSystem = function (toRemove) {\n    var index = this.particleSystems.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.particleSystems.splice(index, 1); // Clean active container\n\n      this._executeActiveContainerCleanup(this._activeParticleSystems);\n    }\n\n    return index;\n  };\n  /**\n   * Remove a animation for the list of scene's animations\n   * @param toRemove defines the animation to remove\n   * @returns the index where the animation was in the animation list\n   */\n\n\n  Scene.prototype.removeAnimation = function (toRemove) {\n    var index = this.animations.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\n   * Will stop the animation of the given target\n   * @param target - the target\n   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   */\n\n\n  Scene.prototype.stopAnimation = function (target, animationName, targetMask) {// Do nothing as code will be provided by animation component\n  };\n  /**\n   * Removes the given animation group from this scene.\n   * @param toRemove The animation group to remove\n   * @returns The index of the removed animation group\n   */\n\n\n  Scene.prototype.removeAnimationGroup = function (toRemove) {\n    var index = this.animationGroups.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animationGroups.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\n   * Removes the given multi-material from this scene.\n   * @param toRemove The multi-material to remove\n   * @returns The index of the removed multi-material\n   */\n\n\n  Scene.prototype.removeMultiMaterial = function (toRemove) {\n    var index = this.multiMaterials.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.multiMaterials.splice(index, 1);\n    }\n\n    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Removes the given material from this scene.\n   * @param toRemove The material to remove\n   * @returns The index of the removed material\n   */\n\n\n  Scene.prototype.removeMaterial = function (toRemove) {\n    var index = toRemove._indexInSceneMaterialArray;\n\n    if (index !== -1 && index < this.materials.length) {\n      if (index !== this.materials.length - 1) {\n        var lastMaterial = this.materials[this.materials.length - 1];\n        this.materials[index] = lastMaterial;\n        lastMaterial._indexInSceneMaterialArray = index;\n      }\n\n      toRemove._indexInSceneMaterialArray = -1;\n      this.materials.pop();\n    }\n\n    this.onMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Removes the given action manager from this scene.\n   * @param toRemove The action manager to remove\n   * @returns The index of the removed action manager\n   */\n\n\n  Scene.prototype.removeActionManager = function (toRemove) {\n    var index = this.actionManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.actionManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\n   * Removes the given texture from this scene.\n   * @param toRemove The texture to remove\n   * @returns The index of the removed texture\n   */\n\n\n  Scene.prototype.removeTexture = function (toRemove) {\n    var index = this.textures.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.textures.splice(index, 1);\n    }\n\n    this.onTextureRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\n   * Adds the given light to this scene\n   * @param newLight The light to add\n   */\n\n\n  Scene.prototype.addLight = function (newLight) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.lights.push(newLight);\n    this.sortLightsByPriority();\n\n    if (!newLight.parent) {\n      newLight._addToSceneRootNodes();\n    } // Add light to all meshes (To support if the light is removed and then re-added)\n\n\n    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(newLight) === -1) {\n        mesh.lightSources.push(newLight);\n\n        mesh._resyncLightSources();\n      }\n    }\n\n    this.onNewLightAddedObservable.notifyObservers(newLight);\n  };\n  /**\n   * Sorts the list list based on light priorities\n   */\n\n\n  Scene.prototype.sortLightsByPriority = function () {\n    if (this.requireLightSorting) {\n      this.lights.sort(LightConstants.CompareLightsPriority);\n    }\n  };\n  /**\n   * Adds the given camera to this scene\n   * @param newCamera The camera to add\n   */\n\n\n  Scene.prototype.addCamera = function (newCamera) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.cameras.push(newCamera);\n    this.onNewCameraAddedObservable.notifyObservers(newCamera);\n\n    if (!newCamera.parent) {\n      newCamera._addToSceneRootNodes();\n    }\n  };\n  /**\n   * Adds the given skeleton to this scene\n   * @param newSkeleton The skeleton to add\n   */\n\n\n  Scene.prototype.addSkeleton = function (newSkeleton) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.skeletons.push(newSkeleton);\n    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n  };\n  /**\n   * Adds the given particle system to this scene\n   * @param newParticleSystem The particle system to add\n   */\n\n\n  Scene.prototype.addParticleSystem = function (newParticleSystem) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.particleSystems.push(newParticleSystem);\n  };\n  /**\n   * Adds the given animation to this scene\n   * @param newAnimation The animation to add\n   */\n\n\n  Scene.prototype.addAnimation = function (newAnimation) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animations.push(newAnimation);\n  };\n  /**\n   * Adds the given animation group to this scene.\n   * @param newAnimationGroup The animation group to add\n   */\n\n\n  Scene.prototype.addAnimationGroup = function (newAnimationGroup) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animationGroups.push(newAnimationGroup);\n  };\n  /**\n   * Adds the given multi-material to this scene\n   * @param newMultiMaterial The multi-material to add\n   */\n\n\n  Scene.prototype.addMultiMaterial = function (newMultiMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.multiMaterials.push(newMultiMaterial);\n    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n  };\n  /**\n   * Adds the given material to this scene\n   * @param newMaterial The material to add\n   */\n\n\n  Scene.prototype.addMaterial = function (newMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n      // Already there??\n      return;\n    }\n\n    newMaterial._indexInSceneMaterialArray = this.materials.length;\n    this.materials.push(newMaterial);\n    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n  };\n  /**\n   * Adds the given morph target to this scene\n   * @param newMorphTargetManager The morph target to add\n   */\n\n\n  Scene.prototype.addMorphTargetManager = function (newMorphTargetManager) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.morphTargetManagers.push(newMorphTargetManager);\n  };\n  /**\n   * Adds the given geometry to this scene\n   * @param newGeometry The geometry to add\n   */\n\n\n  Scene.prototype.addGeometry = function (newGeometry) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    if (this._geometriesByUniqueId) {\n      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n    }\n\n    this.geometries.push(newGeometry);\n  };\n  /**\n   * Adds the given action manager to this scene\n   * @param newActionManager The action manager to add\n   */\n\n\n  Scene.prototype.addActionManager = function (newActionManager) {\n    this.actionManagers.push(newActionManager);\n  };\n  /**\n   * Adds the given texture to this scene.\n   * @param newTexture The texture to add\n   */\n\n\n  Scene.prototype.addTexture = function (newTexture) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.textures.push(newTexture);\n    this.onNewTextureAddedObservable.notifyObservers(newTexture);\n  };\n  /**\n   * Switch active camera\n   * @param newCamera defines the new active camera\n   * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n   */\n\n\n  Scene.prototype.switchActiveCamera = function (newCamera, attachControl) {\n    if (attachControl === void 0) {\n      attachControl = true;\n    }\n\n    var canvas = this._engine.getInputElement();\n\n    if (!canvas) {\n      return;\n    }\n\n    if (this.activeCamera) {\n      this.activeCamera.detachControl();\n    }\n\n    this.activeCamera = newCamera;\n\n    if (attachControl) {\n      newCamera.attachControl();\n    }\n  };\n  /**\n   * sets the active camera of the scene using its Id\n   * @param id defines the camera's Id\n   * @return the new active camera or null if none found.\n   */\n\n\n  Scene.prototype.setActiveCameraById = function (id) {\n    var camera = this.getCameraById(id);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\n   * sets the active camera of the scene using its name\n   * @param name defines the camera's name\n   * @returns the new active camera or null if none found.\n   */\n\n\n  Scene.prototype.setActiveCameraByName = function (name) {\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\n   * get an animation group using its name\n   * @param name defines the material's name\n   * @return the animation group or null if none found.\n   */\n\n\n  Scene.prototype.getAnimationGroupByName = function (name) {\n    for (var index = 0; index < this.animationGroups.length; index++) {\n      if (this.animationGroups[index].name === name) {\n        return this.animationGroups[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get a material using its unique id\n   * @param uniqueId defines the material's unique id\n   * @return the material or null if none found.\n   */\n\n\n  Scene.prototype.getMaterialByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].uniqueId === uniqueId) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * get a material using its id\n   * @param id defines the material's Id\n   * @return the material or null if none found.\n   */\n\n\n  Scene.prototype.getMaterialById = function (id) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a the last added material using a given id\n   * @param id defines the material's Id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @return the last material with the given id or null if none found.\n   */\n\n\n  Scene.prototype.getLastMaterialById = function (id, allowMultiMaterials) {\n    if (allowMultiMaterials === void 0) {\n      allowMultiMaterials = false;\n    }\n\n    for (var index = this.materials.length - 1; index >= 0; index--) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    if (allowMultiMaterials) {\n      for (var index = this.multiMaterials.length - 1; index >= 0; index--) {\n        if (this.multiMaterials[index].id === id) {\n          return this.multiMaterials[index];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a material using its name\n   * @param name defines the material's name\n   * @return the material or null if none found.\n   */\n\n\n  Scene.prototype.getMaterialByName = function (name) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].name === name) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get a texture using its unique id\n   * @param uniqueId defines the texture's unique id\n   * @return the texture or null if none found.\n   */\n\n\n  Scene.prototype.getTextureByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].uniqueId === uniqueId) {\n        return this.textures[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a texture using its name\n   * @param name defines the texture's name\n   * @return the texture or null if none found.\n   */\n\n\n  Scene.prototype.getTextureByName = function (name) {\n    for (var index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].name === name) {\n        return this.textures[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a camera using its Id\n   * @param id defines the Id to look for\n   * @returns the camera or null if not found\n   */\n\n\n  Scene.prototype.getCameraById = function (id) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a camera using its unique Id\n   * @param uniqueId defines the unique Id to look for\n   * @returns the camera or null if not found\n   */\n\n\n  Scene.prototype.getCameraByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].uniqueId === uniqueId) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a camera using its name\n   * @param name defines the camera's name\n   * @return the camera or null if none found.\n   */\n\n\n  Scene.prototype.getCameraByName = function (name) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].name === name) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a bone using its Id\n   * @param id defines the bone's Id\n   * @return the bone or null if not found\n   */\n\n\n  Scene.prototype.getBoneById = function (id) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].id === id) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a bone using its id\n   * @param name defines the bone's name\n   * @return the bone or null if not found\n   */\n\n\n  Scene.prototype.getBoneByName = function (name) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].name === name) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a light node using its name\n   * @param name defines the the light's name\n   * @return the light or null if none found.\n   */\n\n\n  Scene.prototype.getLightByName = function (name) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].name === name) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a light node using its Id\n   * @param id defines the light's Id\n   * @return the light or null if none found.\n   */\n\n\n  Scene.prototype.getLightById = function (id) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a light node using its scene-generated unique Id\n   * @param uniqueId defines the light's unique Id\n   * @return the light or null if none found.\n   */\n\n\n  Scene.prototype.getLightByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].uniqueId === uniqueId) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a particle system by Id\n   * @param id defines the particle system Id\n   * @return the corresponding system or null if none found\n   */\n\n\n  Scene.prototype.getParticleSystemById = function (id) {\n    for (var index = 0; index < this.particleSystems.length; index++) {\n      if (this.particleSystems[index].id === id) {\n        return this.particleSystems[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a geometry using its Id\n   * @param id defines the geometry's Id\n   * @return the geometry or null if none found.\n   */\n\n\n  Scene.prototype.getGeometryById = function (id) {\n    for (var index = 0; index < this.geometries.length; index++) {\n      if (this.geometries[index].id === id) {\n        return this.geometries[index];\n      }\n    }\n\n    return null;\n  };\n\n  Scene.prototype._getGeometryByUniqueId = function (uniqueId) {\n    if (this._geometriesByUniqueId) {\n      var index = this._geometriesByUniqueId[uniqueId];\n\n      if (index !== undefined) {\n        return this.geometries[index];\n      }\n    } else {\n      for (var index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].uniqueId === uniqueId) {\n          return this.geometries[index];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Add a new geometry to this scene\n   * @param geometry defines the geometry to be added to the scene.\n   * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n   * @return a boolean defining if the geometry was added or not\n   */\n\n\n  Scene.prototype.pushGeometry = function (geometry, force) {\n    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n      return false;\n    }\n\n    this.addGeometry(geometry);\n    this.onNewGeometryAddedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\n   * Removes an existing geometry\n   * @param geometry defines the geometry to be removed from the scene\n   * @return a boolean defining if the geometry was removed or not\n   */\n\n\n  Scene.prototype.removeGeometry = function (geometry) {\n    var index;\n\n    if (this._geometriesByUniqueId) {\n      index = this._geometriesByUniqueId[geometry.uniqueId];\n\n      if (index === undefined) {\n        return false;\n      }\n    } else {\n      index = this.geometries.indexOf(geometry);\n\n      if (index < 0) {\n        return false;\n      }\n    }\n\n    if (index !== this.geometries.length - 1) {\n      var lastGeometry = this.geometries[this.geometries.length - 1];\n\n      if (lastGeometry) {\n        this.geometries[index] = lastGeometry;\n\n        if (this._geometriesByUniqueId) {\n          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n          this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n        }\n      }\n    }\n\n    this.geometries.pop();\n    this.onGeometryRemovedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\n   * Gets the list of geometries attached to the scene\n   * @returns an array of Geometry\n   */\n\n\n  Scene.prototype.getGeometries = function () {\n    return this.geometries;\n  };\n  /**\n   * Gets the first added mesh found of a given Id\n   * @param id defines the Id to search for\n   * @return the mesh found or null if not found at all\n   */\n\n\n  Scene.prototype.getMeshById = function (id) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a list of meshes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of meshes\n   */\n\n\n  Scene.prototype.getMeshesById = function (id) {\n    return this.meshes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\n   * Gets the first added transform node found of a given Id\n   * @param id defines the Id to search for\n   * @return the found transform node or null if not found at all.\n   */\n\n\n  Scene.prototype.getTransformNodeById = function (id) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a transform node with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @return the found transform node or null if not found at all.\n   */\n\n\n  Scene.prototype.getTransformNodeByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].uniqueId === uniqueId) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a list of transform nodes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of transform nodes\n   */\n\n\n  Scene.prototype.getTransformNodesById = function (id) {\n    return this.transformNodes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\n   * Gets a mesh with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @return the found mesh or null if not found at all.\n   */\n\n\n  Scene.prototype.getMeshByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].uniqueId === uniqueId) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a the last added mesh using a given Id\n   * @param id defines the Id to search for\n   * @return the found mesh or null if not found at all.\n   */\n\n\n  Scene.prototype.getLastMeshById = function (id) {\n    for (var index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a the last added node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @return the found node or null if not found at all\n   */\n\n\n  Scene.prototype.getLastEntryById = function (id) {\n    var index;\n\n    for (index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    for (index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    for (index = this.cameras.length - 1; index >= 0; index--) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    for (index = this.lights.length - 1; index >= 0; index--) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @return the found node or null if not found at all\n   */\n\n\n  Scene.prototype.getNodeById = function (id) {\n    var mesh = this.getMeshById(id);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeById(id);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightById(id);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraById(id);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneById(id);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given name\n   * @param name defines the name to search for\n   * @return the found node or null if not found at all.\n   */\n\n\n  Scene.prototype.getNodeByName = function (name) {\n    var mesh = this.getMeshByName(name);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeByName(name);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightByName(name);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneByName(name);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\n   * Gets a mesh using a given name\n   * @param name defines the name to search for\n   * @return the found mesh or null if not found at all.\n   */\n\n\n  Scene.prototype.getMeshByName = function (name) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].name === name) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a transform node using a given name\n   * @param name defines the name to search for\n   * @return the found transform node or null if not found at all.\n   */\n\n\n  Scene.prototype.getTransformNodeByName = function (name) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].name === name) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n   * @param id defines the Id to search for\n   * @return the found skeleton or null if not found at all.\n   */\n\n\n  Scene.prototype.getLastSkeletonById = function (id) {\n    for (var index = this.skeletons.length - 1; index >= 0; index--) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a skeleton using a given auto generated unique id\n   * @param  uniqueId defines the unique id to search for\n   * @return the found skeleton or null if not found at all.\n   */\n\n\n  Scene.prototype.getSkeletonByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].uniqueId === uniqueId) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @return the found skeleton or null if not found at all.\n   */\n\n\n  Scene.prototype.getSkeletonById = function (id) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a skeleton using a given name\n   * @param name defines the name to search for\n   * @return the found skeleton or null if not found at all.\n   */\n\n\n  Scene.prototype.getSkeletonByName = function (name) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].name === name) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n   * @param id defines the id to search for\n   * @return the found morph target manager or null if not found at all.\n   */\n\n\n  Scene.prototype.getMorphTargetManagerById = function (id) {\n    for (var index = 0; index < this.morphTargetManagers.length; index++) {\n      if (this.morphTargetManagers[index].uniqueId === id) {\n        return this.morphTargetManagers[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a morph target using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @return the found morph target or null if not found at all.\n   */\n\n\n  Scene.prototype.getMorphTargetById = function (id) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.id === id) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a morph target using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @return the found morph target or null if not found at all.\n   */\n\n\n  Scene.prototype.getMorphTargetByName = function (name) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.name === name) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a post process using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @return the found post process or null if not found at all.\n   */\n\n\n  Scene.prototype.getPostProcessByName = function (name) {\n    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n      var postProcess = this.postProcesses[postProcessIndex];\n\n      if (postProcess.name === name) {\n        return postProcess;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets a boolean indicating if the given mesh is active\n   * @param mesh defines the mesh to look for\n   * @returns true if the mesh is in the active list\n   */\n\n\n  Scene.prototype.isActiveMesh = function (mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  };\n\n  Object.defineProperty(Scene.prototype, \"uid\", {\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n    get: function get() {\n      if (!this._uid) {\n        this._uid = Tools.RandomId();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Add an externally attached data from its key.\n   * This method call will fail and return false, if such key already exists.\n   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n   * @param key the unique key that identifies the data\n   * @param data the data object to associate to the key for this Engine instance\n   * @return true if no such key were already present and the data was added successfully, false otherwise\n   */\n\n  Scene.prototype.addExternalData = function (key, data) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.add(key, data);\n  };\n  /**\n   * Get an externally attached data from its key\n   * @param key the unique key that identifies the data\n   * @return the associated data, if present (can be null), or undefined if not present\n   */\n\n\n  Scene.prototype.getExternalData = function (key) {\n    if (!this._externalData) {\n      return null;\n    }\n\n    return this._externalData.get(key);\n  };\n  /**\n   * Get an externally attached data from its key, create it using a factory if it's not already present\n   * @param key the unique key that identifies the data\n   * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n   * @return the associated data, can be null if the factory returned null.\n   */\n\n\n  Scene.prototype.getOrAddExternalDataWithFactory = function (key, factory) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.getOrAddWithFactory(key, factory);\n  };\n  /**\n   * Remove an externally attached data from the Engine instance\n   * @param key the unique key that identifies the data\n   * @return true if the data was successfully removed, false if it doesn't exist\n   */\n\n\n  Scene.prototype.removeExternalData = function (key) {\n    return this._externalData.remove(key);\n  };\n\n  Scene.prototype._evaluateSubMesh = function (subMesh, mesh, initialMesh) {\n    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\n      for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(mesh, subMesh);\n      }\n\n      var material = subMesh.getMaterial();\n\n      if (material !== null && material !== undefined) {\n        // Render targets\n        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n          if (this._processedMaterials.indexOf(material) === -1) {\n            this._processedMaterials.push(material);\n\n            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n          }\n        } // Dispatch\n\n\n        this._renderingManager.dispatch(subMesh, mesh, material);\n      }\n    }\n  };\n  /**\n   * Clear the processed materials smart array preventing retention point in material dispose.\n   */\n\n\n  Scene.prototype.freeProcessedMaterials = function () {\n    this._processedMaterials.dispose();\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockfreeActiveMeshesAndRenderingGroups\", {\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n    get: function get() {\n      return this._preventFreeActiveMeshesAndRenderingGroups;\n    },\n    set: function set(value) {\n      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n        return;\n      }\n\n      if (value) {\n        this.freeActiveMeshes();\n        this.freeRenderingGroups();\n      }\n\n      this._preventFreeActiveMeshesAndRenderingGroups = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Clear the active meshes smart array preventing retention point in mesh dispose.\n   */\n\n  Scene.prototype.freeActiveMeshes = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    this._activeMeshes.dispose();\n\n    if (this.activeCamera && this.activeCamera._activeMeshes) {\n      this.activeCamera._activeMeshes.dispose();\n    }\n\n    if (this.activeCameras) {\n      for (var i = 0; i < this.activeCameras.length; i++) {\n        var activeCamera = this.activeCameras[i];\n\n        if (activeCamera && activeCamera._activeMeshes) {\n          activeCamera._activeMeshes.dispose();\n        }\n      }\n    }\n  };\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n\n\n  Scene.prototype.freeRenderingGroups = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n\n    if (this.textures) {\n      for (var i = 0; i < this.textures.length; i++) {\n        var texture = this.textures[i];\n\n        if (texture && texture.renderList) {\n          texture.freeRenderingGroups();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._isInIntermediateRendering = function () {\n    return this._intermediateRendering;\n  };\n  /**\n   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n   * @param onSuccess optional success callback\n   * @param onError optional error callback\n   * @param freezeMeshes defines if meshes should be frozen (true by default)\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.freezeActiveMeshes = function (skipEvaluateActiveMeshes, onSuccess, onError, freezeMeshes) {\n    var _this = this;\n\n    if (skipEvaluateActiveMeshes === void 0) {\n      skipEvaluateActiveMeshes = false;\n    }\n\n    if (freezeMeshes === void 0) {\n      freezeMeshes = true;\n    }\n\n    this.executeWhenReady(function () {\n      if (!_this.activeCamera) {\n        onError && onError(\"No active camera found\");\n        return;\n      }\n\n      if (!_this._frustumPlanes) {\n        _this.updateTransformMatrix();\n      }\n\n      _this._evaluateActiveMeshes();\n\n      _this._activeMeshesFrozen = true;\n      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n\n      if (freezeMeshes) {\n        for (var index = 0; index < _this._activeMeshes.length; index++) {\n          _this._activeMeshes.data[index]._freeze();\n        }\n      }\n\n      onSuccess && onSuccess();\n    });\n    return this;\n  };\n  /**\n   * Use this function to restart evaluating active meshes on every frame\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.unfreezeActiveMeshes = function () {\n    for (var index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (mesh._internalAbstractMeshDataInfo) {\n        mesh._internalAbstractMeshDataInfo._isActive = false;\n      }\n    }\n\n    for (var index = 0; index < this._activeMeshes.length; index++) {\n      this._activeMeshes.data[index]._unFreeze();\n    }\n\n    this._activeMeshesFrozen = false;\n    return this;\n  };\n\n  Scene.prototype._executeActiveContainerCleanup = function (container) {\n    var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n\n    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n      return; // Do not execute in frozen mode\n    } // We need to ensure we are not in the rendering loop\n\n\n    this.onBeforeRenderObservable.addOnce(function () {\n      return container.dispose();\n    });\n  };\n\n  Scene.prototype._evaluateActiveMeshes = function () {\n    var _a;\n\n    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n      if (this._activeMeshes.length > 0) {\n        (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();\n\n        this._activeMeshes.reset();\n\n        this._renderingManager.reset();\n\n        this._processedMaterials.reset();\n\n        this._activeParticleSystems.reset();\n\n        this._activeSkeletons.reset();\n\n        this._softwareSkinnedMeshes.reset();\n      }\n\n      return;\n    }\n\n    if (this._activeMeshesFrozen && this._activeMeshes.length) {\n      if (!this._skipEvaluateActiveMeshesCompletely) {\n        var len_1 = this._activeMeshes.length;\n\n        for (var i = 0; i < len_1; i++) {\n          var mesh = this._activeMeshes.data[i];\n          mesh.computeWorldMatrix();\n        }\n      }\n\n      if (this._activeParticleSystems) {\n        var psLength = this._activeParticleSystems.length;\n\n        for (var i = 0; i < psLength; i++) {\n          this._activeParticleSystems.data[i].animate();\n        }\n      }\n\n      return;\n    }\n\n    if (!this.activeCamera) {\n      return;\n    }\n\n    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n\n    this.activeCamera._activeMeshes.reset();\n\n    this._activeMeshes.reset();\n\n    this._renderingManager.reset();\n\n    this._processedMaterials.reset();\n\n    this._activeParticleSystems.reset();\n\n    this._activeSkeletons.reset();\n\n    this._softwareSkinnedMeshes.reset();\n\n    this._materialsRenderTargets.reset();\n\n    for (var _i = 0, _b = this._beforeEvaluateActiveMeshStage; _i < _b.length; _i++) {\n      var step = _b[_i];\n      step.action();\n    } // Determine mesh candidates\n\n\n    var meshes = this.getActiveMeshCandidates(); // Check each mesh\n\n    var len = meshes.length;\n\n    for (var i = 0; i < len; i++) {\n      var mesh = meshes.data[i];\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n\n      if (mesh.isBlocked) {\n        continue;\n      }\n\n      this._totalVertices.addCount(mesh.getTotalVertices(), false);\n\n      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {\n        continue;\n      }\n\n      mesh.computeWorldMatrix(); // Intersections\n\n      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n        this._meshesForIntersections.pushNoDuplicate(mesh);\n      } // Switch to current LOD\n\n\n      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n\n      if (meshToRender === undefined || meshToRender === null) {\n        continue;\n      } // Compute world matrix if LOD is billboard\n\n\n      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n        meshToRender.computeWorldMatrix();\n      }\n\n      mesh._preActivate();\n\n      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n        this._activeMeshes.push(mesh);\n\n        this.activeCamera._activeMeshes.push(mesh);\n\n        if (meshToRender !== mesh) {\n          meshToRender._activate(this._renderId, false);\n        }\n\n        for (var _c = 0, _d = this._preActiveMeshStage; _c < _d.length; _c++) {\n          var step = _d[_c];\n          step.action(mesh);\n        }\n\n        if (mesh._activate(this._renderId, false)) {\n          if (!mesh.isAnInstance) {\n            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n          } else {\n            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n              meshToRender = mesh;\n            }\n          }\n\n          meshToRender._internalAbstractMeshDataInfo._isActive = true;\n\n          this._activeMesh(mesh, meshToRender);\n        }\n\n        mesh._postActivate();\n      }\n    }\n\n    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this); // Particle systems\n\n    if (this.particlesEnabled) {\n      this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n\n      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n        var particleSystem = this.particleSystems[particleIndex];\n\n        if (!particleSystem.isStarted() || !particleSystem.emitter) {\n          continue;\n        }\n\n        var emitter = particleSystem.emitter;\n\n        if (!emitter.position || emitter.isEnabled()) {\n          this._activeParticleSystems.push(particleSystem);\n\n          particleSystem.animate();\n\n          this._renderingManager.dispatchParticles(particleSystem);\n        }\n      }\n\n      this.onAfterParticlesRenderingObservable.notifyObservers(this);\n    }\n  };\n\n  Scene.prototype._activeMesh = function (sourceMesh, mesh) {\n    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n        mesh.skeleton.prepare();\n\n        this._activeBones.addCount(mesh.skeleton.bones.length, false);\n      }\n\n      if (!mesh.computeBonesUsingShaders) {\n        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n      }\n    }\n\n    if (mesh !== undefined && mesh !== null && mesh.subMeshes !== undefined && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {\n      var subMeshes = this.getActiveSubMeshCandidates(mesh);\n      var len = subMeshes.length;\n\n      for (var i = 0; i < len; i++) {\n        var subMesh = subMeshes.data[i];\n\n        this._evaluateSubMesh(subMesh, mesh, sourceMesh);\n      }\n    }\n  };\n  /**\n   * Update the transform matrix to update from the current active camera\n   * @param force defines a boolean used to force the update even if cache is up to date\n   */\n\n\n  Scene.prototype.updateTransformMatrix = function (force) {\n    if (!this.activeCamera) {\n      return;\n    }\n\n    if (this.activeCamera._renderingMultiview) {\n      var leftCamera = this.activeCamera._rigCameras[0];\n      var rightCamera = this.activeCamera._rigCameras[1];\n      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n    } else {\n      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n    }\n  };\n\n  Scene.prototype._bindFrameBuffer = function (camera, clear) {\n    if (clear === void 0) {\n      clear = true;\n    }\n\n    if (camera && camera._multiviewTexture) {\n      camera._multiviewTexture._bindFrameBuffer();\n    } else if (camera && camera.outputRenderTarget) {\n      camera.outputRenderTarget._bindFrameBuffer();\n    } else {\n      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n        this._engine.restoreDefaultFramebuffer();\n      }\n    }\n\n    if (clear) {\n      this._clearFrameBuffer(camera);\n    }\n  };\n\n  Scene.prototype._clearFrameBuffer = function (camera) {\n    // we assume the framebuffer currently bound is the right one\n    if (camera && camera._multiviewTexture) {// no clearing?\n    } else if (camera && camera.outputRenderTarget) {\n      var rtt = camera.outputRenderTarget;\n\n      if (rtt.onClearObservable.hasObservers()) {\n        rtt.onClearObservable.notifyObservers(this._engine);\n      } else if (!rtt.skipInitialClear) {\n        this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n\n        rtt._cleared = true;\n      }\n    } else {\n      if (!this._defaultFrameBufferCleared) {\n        this._defaultFrameBufferCleared = true;\n\n        this._clear();\n      } else {\n        this._engine.clear(null, false, true, true);\n      }\n    }\n  };\n  /**\n   * @param camera\n   * @param rigParent\n   * @param bindFrameBuffer\n   * @hidden\n   */\n\n\n  Scene.prototype._renderForCamera = function (camera, rigParent, bindFrameBuffer) {\n    var _a, _b, _c;\n\n    if (bindFrameBuffer === void 0) {\n      bindFrameBuffer = true;\n    }\n\n    if (camera && camera._skipRendering) {\n      return;\n    }\n\n    var engine = this._engine; // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n    this._activeCamera = camera;\n\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    } // Viewport\n\n\n    engine.setViewport(this.activeCamera.viewport); // Camera\n\n    this.resetCachedMaterial();\n    this._renderId++;\n\n    if (!this.prePass && bindFrameBuffer) {\n      var skipInitialClear = true;\n\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n\n        if (this.autoClear) {\n          camera.outputRenderTarget.skipInitialClear = false;\n        }\n      }\n\n      this._bindFrameBuffer(this._activeCamera);\n\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n      }\n    }\n\n    this.updateTransformMatrix();\n    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera); // Meshes\n\n    this._evaluateActiveMeshes(); // Software skinning\n\n\n    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n      mesh.applySkeleton(mesh.skeleton);\n    } // Render targets\n\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n\n    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n\n    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n    }\n\n    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n    }\n\n    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n      this._renderTargets.pushNoDuplicate(this.environmentTexture);\n    } // Collects render targets from external components.\n\n\n    for (var _i = 0, _d = this._gatherActiveCameraRenderTargetsStage; _i < _d.length; _i++) {\n      var step = _d[_i];\n      step.action(this._renderTargets);\n    }\n\n    var needRebind = false;\n\n    if (this.renderTargetsEnabled) {\n      this._intermediateRendering = true;\n\n      if (this._renderTargets.length > 0) {\n        Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n\n        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n          var renderTarget = this._renderTargets.data[renderIndex];\n\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n            needRebind = true;\n          }\n        }\n\n        Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        this._renderId++;\n      }\n\n      for (var _e = 0, _f = this._cameraDrawRenderTargetStage; _e < _f.length; _e++) {\n        var step = _f[_e];\n        needRebind = step.action(this.activeCamera) || needRebind;\n      }\n\n      this._intermediateRendering = false;\n    }\n\n    this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0; // Restore framebuffer after rendering to targets\n\n    if (needRebind && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this); // Prepare Frame\n\n    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n      this.postProcessManager._prepareFrame();\n    } // Before Camera Draw\n\n\n    for (var _g = 0, _h = this._beforeCameraDrawStage; _g < _h.length; _g++) {\n      var step = _h[_g];\n      step.action(this.activeCamera);\n    } // Render\n\n\n    this.onBeforeDrawPhaseObservable.notifyObservers(this);\n\n    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n      this.finalizeSceneUbo();\n    }\n\n    this._renderingManager.render(null, null, true, true);\n\n    this.onAfterDrawPhaseObservable.notifyObservers(this); // After Camera Draw\n\n    for (var _j = 0, _k = this._afterCameraDrawStage; _j < _k.length; _j++) {\n      var step = _k[_j];\n      step.action(this.activeCamera);\n    } // Finalize frame\n\n\n    if (this.postProcessManager && !camera._multiviewTexture) {\n      // if the camera has an output render target, render the post process to the render target\n      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n\n      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n    } // Reset some special arrays\n\n\n    this._renderTargets.reset();\n\n    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n  };\n\n  Scene.prototype._processSubCameras = function (camera, bindFrameBuffer) {\n    if (bindFrameBuffer === void 0) {\n      bindFrameBuffer = true;\n    }\n\n    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n      if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n        this._createMultiviewUbo();\n      }\n\n      this._renderForCamera(camera, undefined, bindFrameBuffer);\n\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n      return;\n    }\n\n    if (camera._useMultiviewToSingleView) {\n      this._renderMultiviewToSingleView(camera);\n    } else {\n      // rig cameras\n      this.onBeforeCameraRenderObservable.notifyObservers(camera);\n\n      for (var index = 0; index < camera._rigCameras.length; index++) {\n        this._renderForCamera(camera._rigCameras[index], camera);\n      }\n    } // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n\n    this._activeCamera = camera;\n    this.updateTransformMatrix();\n    this.onAfterRenderCameraObservable.notifyObservers(camera);\n  };\n\n  Scene.prototype._checkIntersections = function () {\n    for (var index = 0; index < this._meshesForIntersections.length; index++) {\n      var sourceMesh = this._meshesForIntersections.data[index];\n\n      if (!sourceMesh.actionManager) {\n        continue;\n      }\n\n      var _loop_1 = function _loop_1(actionIndex) {\n        var action = sourceMesh.actionManager.actions[actionIndex];\n\n        if (action.trigger === 12 || action.trigger === 13) {\n          var parameters = action.getTriggerParameter();\n          var otherMesh_1 = parameters.mesh ? parameters.mesh : parameters;\n          var areIntersecting = otherMesh_1.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n\n          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh_1);\n\n          if (areIntersecting && currentIntersectionInProgress === -1) {\n            if (action.trigger === 12) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh_1));\n\n              sourceMesh._intersectionsInProgress.push(otherMesh_1);\n            } else if (action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.push(otherMesh_1);\n            }\n          } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n            //They intersected, and now they don't.\n            //is this trigger an exit trigger? execute an event.\n            if (action.trigger === 13) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh_1));\n            } //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n\n\n            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function (parameter) {\n              var parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n              return otherMesh_1 === parameterMesh;\n            }) || action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n            }\n          }\n        }\n      };\n\n      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n        _loop_1(actionIndex);\n      }\n    }\n  };\n  /**\n   * @param step\n   * @hidden\n   */\n\n\n  Scene.prototype._advancePhysicsEngineStep = function (step) {// Do nothing. Code will be replaced if physics engine component is referenced\n  };\n  /** @hidden */\n\n\n  Scene.prototype._animate = function () {// Nothing to do as long as Animatable have not been imported.\n  };\n  /** Execute all animations (for a frame) */\n\n\n  Scene.prototype.animate = function () {\n    if (this._engine.isDeterministicLockStep()) {\n      var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n\n      var defaultFrameTime = this._engine.getTimeStep();\n\n      var defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n      var stepsTaken = 0;\n\n      var maxSubSteps = this._engine.getLockstepMaxSteps();\n\n      var internalSteps = Math.floor(deltaTime / defaultFrameTime);\n      internalSteps = Math.min(internalSteps, maxSubSteps);\n\n      while (deltaTime > 0 && stepsTaken < internalSteps) {\n        this.onBeforeStepObservable.notifyObservers(this); // Animations\n\n        this._animationRatio = defaultFrameTime * defaultFPS;\n\n        this._animate();\n\n        this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(defaultFrameTime);\n        }\n\n        this.onAfterStepObservable.notifyObservers(this);\n        this._currentStepId++;\n        stepsTaken++;\n        deltaTime -= defaultFrameTime;\n      }\n\n      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n    } else {\n      // Animations\n      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n      this._animationRatio = deltaTime * (60.0 / 1000.0);\n\n      this._animate();\n\n      this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n      if (this.physicsEnabled) {\n        this._advancePhysicsEngineStep(deltaTime);\n      }\n    }\n  };\n\n  Scene.prototype._clear = function () {\n    if (this.autoClearDepthAndStencil || this.autoClear) {\n      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n    }\n  };\n\n  Scene.prototype._checkCameraRenderTarget = function (camera) {\n    var _a;\n\n    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {\n      camera.outputRenderTarget._cleared = false;\n    }\n\n    if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      for (var i = 0; i < camera.rigCameras.length; ++i) {\n        var rtt = camera.rigCameras[i].outputRenderTarget;\n\n        if (rtt) {\n          rtt._cleared = false;\n        }\n      }\n    }\n  };\n  /**\n   * Resets the draw wrappers cache of all meshes\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n\n\n  Scene.prototype.resetDrawCache = function (passId) {\n    if (!this.meshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n      mesh.resetDrawCache(passId);\n    }\n  };\n  /**\n   * Render the scene\n   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n   */\n\n\n  Scene.prototype.render = function (updateCameras, ignoreAnimations) {\n    var _a, _b, _c;\n\n    if (updateCameras === void 0) {\n      updateCameras = true;\n    }\n\n    if (ignoreAnimations === void 0) {\n      ignoreAnimations = false;\n    }\n\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n      this._checkIsReady();\n    }\n\n    this._frameId++;\n    this._defaultFrameBufferCleared = false;\n\n    this._checkCameraRenderTarget(this.activeCamera);\n\n    if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      this.activeCameras.forEach(this._checkCameraRenderTarget);\n    } // Register components that have been associated lately to the scene.\n\n\n    this._registerTransientComponents();\n\n    this._activeParticles.fetchNewFrame();\n\n    this._totalVertices.fetchNewFrame();\n\n    this._activeIndices.fetchNewFrame();\n\n    this._activeBones.fetchNewFrame();\n\n    this._meshesForIntersections.reset();\n\n    this.resetCachedMaterial();\n    this.onBeforeAnimationsObservable.notifyObservers(this); // Actions\n\n    if (this.actionManager) {\n      this.actionManager.processTrigger(11);\n    } // Animations\n\n\n    if (!ignoreAnimations) {\n      this.animate();\n    } // Before camera update steps\n\n\n    for (var _i = 0, _d = this._beforeCameraUpdateStage; _i < _d.length; _i++) {\n      var step = _d[_i];\n      step.action();\n    } // Update Cameras\n\n\n    if (updateCameras) {\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n          var camera = this.activeCameras[cameraIndex];\n          camera.update();\n\n          if (camera.cameraRigMode !== 0) {\n            // rig cameras\n            for (var index = 0; index < camera._rigCameras.length; index++) {\n              camera._rigCameras[index].update();\n            }\n          }\n        }\n      } else if (this.activeCamera) {\n        this.activeCamera.update();\n\n        if (this.activeCamera.cameraRigMode !== 0) {\n          // rig cameras\n          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {\n            this.activeCamera._rigCameras[index].update();\n          }\n        }\n      }\n    } // Before render\n\n\n    this.onBeforeRenderObservable.notifyObservers(this);\n    var engine = this.getEngine(); // Customs render targets\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    var currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;\n\n    if (this.renderTargetsEnabled) {\n      Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = true;\n\n      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n        var renderTarget = this.customRenderTargets[customIndex];\n\n        if (renderTarget._shouldRender()) {\n          this._renderId++;\n          this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n\n          if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n          } // Viewport\n\n\n          engine.setViewport(this.activeCamera.viewport); // Camera\n\n          this.updateTransformMatrix();\n          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n        }\n      }\n\n      Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = false;\n      this._renderId++;\n    }\n\n    this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0; // Restore back buffer\n\n    this.activeCamera = currentActiveCamera;\n\n    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n\n    for (var _e = 0, _f = this._beforeClearStage; _e < _f.length; _e++) {\n      var step = _f[_e];\n      step.action();\n    } // Clear\n\n\n    this._clearFrameBuffer(this.activeCamera); // Collects render targets from external components.\n\n\n    for (var _g = 0, _h = this._gatherRenderTargetsStage; _g < _h.length; _g++) {\n      var step = _h[_g];\n      step.action(this._renderTargets);\n    } // Multi-cameras?\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n      }\n    } else {\n      if (!this.activeCamera) {\n        throw new Error(\"No camera defined\");\n      }\n\n      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n    } // Intersection checks\n\n\n    this._checkIntersections(); // Executes the after render stage actions.\n\n\n    for (var _j = 0, _k = this._afterRenderStage; _j < _k.length; _j++) {\n      var step = _k[_j];\n      step.action();\n    } // After render\n\n\n    if (this.afterRender) {\n      this.afterRender();\n    }\n\n    this.onAfterRenderObservable.notifyObservers(this); // Cleaning\n\n    if (this._toBeDisposed.length) {\n      for (var index = 0; index < this._toBeDisposed.length; index++) {\n        var data = this._toBeDisposed[index];\n\n        if (data) {\n          data.dispose();\n        }\n      }\n\n      this._toBeDisposed = [];\n    }\n\n    if (this.dumpNextRenderTargets) {\n      this.dumpNextRenderTargets = false;\n    }\n\n    this._activeBones.addCount(0, true);\n\n    this._activeIndices.addCount(0, true);\n\n    this._activeParticles.addCount(0, true);\n\n    this._engine.restoreDefaultFramebuffer();\n  };\n  /**\n   * Freeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   */\n\n\n  Scene.prototype.freezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].freeze();\n    }\n  };\n  /**\n   * Unfreeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   */\n\n\n  Scene.prototype.unfreezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].unfreeze();\n    }\n  };\n  /**\n   * Releases all held resources\n   */\n\n\n  Scene.prototype.dispose = function () {\n    var _a;\n\n    if (this.isDisposed) {\n      return;\n    }\n\n    this.beforeRender = null;\n    this.afterRender = null;\n    this.metadata = null;\n    this.skeletons = [];\n    this.morphTargetManagers = [];\n    this._transientComponents = [];\n\n    this._isReadyForMeshStage.clear();\n\n    this._beforeEvaluateActiveMeshStage.clear();\n\n    this._evaluateSubMeshStage.clear();\n\n    this._preActiveMeshStage.clear();\n\n    this._cameraDrawRenderTargetStage.clear();\n\n    this._beforeCameraDrawStage.clear();\n\n    this._beforeRenderTargetDrawStage.clear();\n\n    this._beforeRenderingGroupDrawStage.clear();\n\n    this._beforeRenderingMeshStage.clear();\n\n    this._afterRenderingMeshStage.clear();\n\n    this._afterRenderingGroupDrawStage.clear();\n\n    this._afterCameraDrawStage.clear();\n\n    this._afterRenderTargetDrawStage.clear();\n\n    this._afterRenderStage.clear();\n\n    this._beforeCameraUpdateStage.clear();\n\n    this._beforeClearStage.clear();\n\n    this._gatherRenderTargetsStage.clear();\n\n    this._gatherActiveCameraRenderTargetsStage.clear();\n\n    this._pointerMoveStage.clear();\n\n    this._pointerDownStage.clear();\n\n    this._pointerUpStage.clear();\n\n    this.importedMeshesFiles = new Array();\n\n    if (this.stopAllAnimations) {\n      this.stopAllAnimations();\n    }\n\n    this.resetCachedMaterial(); // Smart arrays\n\n    if (this.activeCamera) {\n      this.activeCamera._activeMeshes.dispose();\n\n      this.activeCamera = null;\n    }\n\n    this._activeMeshes.dispose();\n\n    this._renderingManager.dispose();\n\n    this._processedMaterials.dispose();\n\n    this._activeParticleSystems.dispose();\n\n    this._activeSkeletons.dispose();\n\n    this._softwareSkinnedMeshes.dispose();\n\n    this._renderTargets.dispose();\n\n    this._materialsRenderTargets.dispose();\n\n    this._registeredForLateAnimationBindings.dispose();\n\n    this._meshesForIntersections.dispose();\n\n    this._toBeDisposed = []; // Abort active requests\n\n    var activeRequests = this._activeRequests.slice();\n\n    for (var _i = 0, activeRequests_1 = activeRequests; _i < activeRequests_1.length; _i++) {\n      var request = activeRequests_1[_i];\n      request.abort();\n    }\n\n    this._activeRequests = []; // Events\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderTargetsRenderObservable.clear();\n    this.onAfterRenderTargetsRenderObservable.clear();\n    this.onAfterStepObservable.clear();\n    this.onBeforeStepObservable.clear();\n    this.onBeforeActiveMeshesEvaluationObservable.clear();\n    this.onAfterActiveMeshesEvaluationObservable.clear();\n    this.onBeforeParticlesRenderingObservable.clear();\n    this.onAfterParticlesRenderingObservable.clear();\n    this.onBeforeDrawPhaseObservable.clear();\n    this.onAfterDrawPhaseObservable.clear();\n    this.onBeforeAnimationsObservable.clear();\n    this.onAfterAnimationsObservable.clear();\n    this.onDataLoadedObservable.clear();\n    this.onBeforeRenderingGroupObservable.clear();\n    this.onAfterRenderingGroupObservable.clear();\n    this.onMeshImportedObservable.clear();\n    this.onBeforeCameraRenderObservable.clear();\n    this.onAfterCameraRenderObservable.clear();\n    this.onReadyObservable.clear();\n    this.onNewCameraAddedObservable.clear();\n    this.onCameraRemovedObservable.clear();\n    this.onNewLightAddedObservable.clear();\n    this.onLightRemovedObservable.clear();\n    this.onNewGeometryAddedObservable.clear();\n    this.onGeometryRemovedObservable.clear();\n    this.onNewTransformNodeAddedObservable.clear();\n    this.onTransformNodeRemovedObservable.clear();\n    this.onNewMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onNewSkeletonAddedObservable.clear();\n    this.onSkeletonRemovedObservable.clear();\n    this.onNewMaterialAddedObservable.clear();\n    this.onNewMultiMaterialAddedObservable.clear();\n    this.onMaterialRemovedObservable.clear();\n    this.onMultiMaterialRemovedObservable.clear();\n    this.onNewTextureAddedObservable.clear();\n    this.onTextureRemovedObservable.clear();\n    this.onPrePointerObservable.clear();\n    this.onPointerObservable.clear();\n    this.onPreKeyboardObservable.clear();\n    this.onKeyboardObservable.clear();\n    this.onActiveCameraChanged.clear();\n    this.onComputePressureChanged.clear();\n    (_a = this._computePressureObserver) === null || _a === void 0 ? void 0 : _a.unobserve();\n    this._computePressureObserver = undefined;\n    this.detachControl(); // Detach cameras\n\n    var canvas = this._engine.getInputElement();\n\n    if (canvas) {\n      for (var index_1 = 0; index_1 < this.cameras.length; index_1++) {\n        this.cameras[index_1].detachControl();\n      }\n    } // Release animation groups\n\n\n    this._disposeList(this.animationGroups); // Release lights\n\n\n    this._disposeList(this.lights); // Release meshes\n\n\n    this._disposeList(this.meshes, function (item) {\n      return item.dispose(true);\n    });\n\n    this._disposeList(this.transformNodes, function (item) {\n      return item.dispose(true);\n    }); // Release cameras\n\n\n    this._disposeList(this.cameras); // Release materials\n\n\n    if (this._defaultMaterial) {\n      this._defaultMaterial.dispose();\n    }\n\n    this._disposeList(this.multiMaterials);\n\n    this._disposeList(this.materials); // Release particles\n\n\n    this._disposeList(this.particleSystems); // Release postProcesses\n\n\n    this._disposeList(this.postProcesses); // Release textures\n\n\n    this._disposeList(this.textures); // Release morph targets\n\n\n    this._disposeList(this.morphTargetManagers); // Release UBO\n\n\n    this._sceneUbo.dispose();\n\n    if (this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n    } // Post-processes\n\n\n    this.postProcessManager.dispose(); // Components\n\n    this._disposeList(this._components); // Remove from engine\n\n\n    var index = this._engine.scenes.indexOf(this);\n\n    if (index > -1) {\n      this._engine.scenes.splice(index, 1);\n    }\n\n    if (EngineStore._LastCreatedScene === this) {\n      if (this._engine.scenes.length > 0) {\n        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n      } else {\n        EngineStore._LastCreatedScene = null;\n      }\n    }\n\n    index = this._engine._virtualScenes.indexOf(this);\n\n    if (index > -1) {\n      this._engine._virtualScenes.splice(index, 1);\n    }\n\n    this._engine.wipeCaches(true);\n\n    this._isDisposed = true;\n  };\n\n  Scene.prototype._disposeList = function (items, callback) {\n    var itemsCopy = SliceTools.Slice(items, 0);\n    callback = callback !== null && callback !== void 0 ? callback : function (item) {\n      return item.dispose();\n    };\n\n    for (var _i = 0, itemsCopy_1 = itemsCopy; _i < itemsCopy_1.length; _i++) {\n      var item = itemsCopy_1[_i];\n      callback(item);\n    }\n\n    items.length = 0;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isDisposed\", {\n    /**\n     * Gets if the scene is already disposed\n     */\n    get: function get() {\n      return this._isDisposed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call this function to reduce memory footprint of the scene.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n\n  Scene.prototype.clearCachedVertexData = function () {\n    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n      var mesh = this.meshes[meshIndex];\n      var geometry = mesh.geometry;\n\n      if (geometry) {\n        geometry.clearCachedData();\n      }\n    }\n  };\n  /**\n   * This function will remove the local cached buffer data from texture.\n   * It will save memory but will prevent the texture from being rebuilt\n   */\n\n\n  Scene.prototype.cleanCachedTextureBuffer = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var baseTexture = _a[_i];\n      var buffer = baseTexture._buffer;\n\n      if (buffer) {\n        baseTexture._buffer = null;\n      }\n    }\n  };\n  /**\n   * Get the world extend vectors with an optional filter\n   *\n   * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n   */\n\n\n  Scene.prototype.getWorldExtends = function (filterPredicate) {\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    filterPredicate = filterPredicate || function () {\n      return true;\n    };\n\n    this.meshes.filter(filterPredicate).forEach(function (mesh) {\n      mesh.computeWorldMatrix(true);\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n        return;\n      }\n\n      var boundingInfo = mesh.getBoundingInfo();\n      var minBox = boundingInfo.boundingBox.minimumWorld;\n      var maxBox = boundingInfo.boundingBox.maximumWorld;\n      Vector3.CheckExtends(minBox, min, max);\n      Vector3.CheckExtends(maxBox, min, max);\n    });\n    return {\n      min: min,\n      max: max\n    };\n  }; // Picking\n\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @returns a Ray\n   */\n\n\n  Scene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    if (enableDistantPicking === void 0) {\n      enableDistantPicking = false;\n    }\n\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param camera defines the camera to use for the picking\n   * @returns a Ray\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @returns the current scene\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n    throw _WarnImport(\"Ray\");\n  };\n  /** Launch a ray to try to pick a mesh in the scene\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n\n\n  Scene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n   */\n\n\n  Scene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Use the given ray to pick a mesh in the scene\n   * @param ray The ray to use to pick meshes\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n\n\n  Scene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Launch a ray to try to pick a mesh in the scene\n   * @param x X position on screen\n   * @param y Y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n\n\n  Scene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Launch a ray to try to pick a mesh in the scene\n   * @param ray Ray to use\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n\n\n  Scene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  };\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh defines the mesh to use\n   * @param pointerId optional pointer id when using more than one pointer\n   * @param pickResult optional pickingInfo data used to find mesh\n   */\n\n\n  Scene.prototype.setPointerOverMesh = function (mesh, pointerId, pickResult) {\n    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n  };\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n\n\n  Scene.prototype.getPointerOverMesh = function () {\n    return this._inputManager.getPointerOverMesh();\n  }; // Misc.\n\n  /** @hidden */\n\n\n  Scene.prototype._rebuildGeometries = function () {\n    for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {\n      var geometry = _a[_i];\n\n      geometry._rebuild();\n    }\n\n    for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {\n      var mesh = _c[_b];\n\n      mesh._rebuild();\n    }\n\n    if (this.postProcessManager) {\n      this.postProcessManager._rebuild();\n    }\n\n    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {\n      var component = _e[_d];\n      component.rebuild();\n    }\n\n    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {\n      var system = _g[_f];\n      system.rebuild();\n    }\n\n    if (this.spriteManagers) {\n      for (var _h = 0, _j = this.spriteManagers; _h < _j.length; _h++) {\n        var spriteMgr = _j[_h];\n        spriteMgr.rebuild();\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._rebuildTextures = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var texture = _a[_i];\n\n      texture._rebuild();\n    }\n\n    this.markAllMaterialsAsDirty(1);\n  }; // Tags\n\n\n  Scene.prototype._getByTags = function (list, tagsQuery, forEach) {\n    if (tagsQuery === undefined) {\n      // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n      return list;\n    }\n\n    var listByTags = [];\n\n    forEach = forEach || function (item) {\n      return;\n    };\n\n    for (var i in list) {\n      var item = list[i];\n\n      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n        listByTags.push(item);\n        forEach(item);\n      }\n    }\n\n    return listByTags;\n  };\n  /**\n   * Get a list of meshes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Mesh\n   */\n\n\n  Scene.prototype.getMeshesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.meshes, tagsQuery, forEach);\n  };\n  /**\n   * Get a list of cameras by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Camera\n   */\n\n\n  Scene.prototype.getCamerasByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.cameras, tagsQuery, forEach);\n  };\n  /**\n   * Get a list of lights by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Light\n   */\n\n\n  Scene.prototype.getLightsByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.lights, tagsQuery, forEach);\n  };\n  /**\n   * Get a list of materials by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Material\n   */\n\n\n  Scene.prototype.getMaterialByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n  };\n  /**\n   * Get a list of transform nodes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of TransformNode\n   */\n\n\n  Scene.prototype.getTransformNodesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.transformNodes, tagsQuery, forEach);\n  };\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversly depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n\n\n  Scene.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  };\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n\n\n  Scene.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n  };\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n\n\n  Scene.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._renderingManager.getAutoClearDepthStencilSetup(index);\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockMaterialDirtyMechanism\", {\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    get: function get() {\n      return this._blockMaterialDirtyMechanism;\n    },\n    set: function set(value) {\n      if (this._blockMaterialDirtyMechanism === value) {\n        return;\n      }\n\n      this._blockMaterialDirtyMechanism = value;\n\n      if (!value) {\n        // Do a complete update\n        this.markAllMaterialsAsDirty(63);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Will flag all materials as dirty to trigger new shader compilation\n   * @param flag defines the flag used to specify which material part must be marked as dirty\n   * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n   */\n\n  Scene.prototype.markAllMaterialsAsDirty = function (flag, predicate) {\n    if (this._blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {\n      var material = _a[_i];\n\n      if (predicate && !predicate(material)) {\n        continue;\n      }\n\n      material.markAsDirty(flag);\n    }\n  };\n  /**\n   * @param fileOrUrl\n   * @param onSuccess\n   * @param onProgress\n   * @param useOfflineSupport\n   * @param useArrayBuffer\n   * @param onError\n   * @param onOpened\n   * @hidden\n   */\n\n\n  Scene.prototype._loadFile = function (fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /**\n   * @param fileOrUrl\n   * @param onProgress\n   * @param useOfflineSupport\n   * @param useArrayBuffer\n   * @param onOpened\n   * @hidden\n   */\n\n\n  Scene.prototype._loadFileAsync = function (fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadFile(fileOrUrl, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (request, exception) {\n        reject(exception);\n      }, onOpened);\n    });\n  };\n  /**\n   * @param url\n   * @param onSuccess\n   * @param onProgress\n   * @param useOfflineSupport\n   * @param useArrayBuffer\n   * @param onError\n   * @param onOpened\n   * @hidden\n   */\n\n\n  Scene.prototype._requestFile = function (url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /**\n   * @param url\n   * @param onProgress\n   * @param useOfflineSupport\n   * @param useArrayBuffer\n   * @param onOpened\n   * @hidden\n   */\n\n\n  Scene.prototype._requestFileAsync = function (url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._requestFile(url, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (error) {\n        reject(error);\n      }, onOpened);\n    });\n  };\n  /**\n   * @param file\n   * @param onSuccess\n   * @param onProgress\n   * @param useArrayBuffer\n   * @param onError\n   * @hidden\n   */\n\n\n  Scene.prototype._readFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /**\n   * @param file\n   * @param onProgress\n   * @param useArrayBuffer\n   * @hidden\n   */\n\n\n  Scene.prototype._readFileAsync = function (file, onProgress, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._readFile(file, function (data) {\n        resolve(data);\n      }, onProgress, useArrayBuffer, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n   * @returns the perf collector belonging to the scene.\n   */\n\n\n  Scene.prototype.getPerfCollector = function () {\n    throw _WarnImport(\"performanceViewerSceneExtension\");\n  };\n  /** The fog is deactivated */\n\n\n  Scene.FOGMODE_NONE = 0;\n  /** The fog density is following an exponential function */\n\n  Scene.FOGMODE_EXP = 1;\n  /** The fog density is following an exponential function faster than FOGMODE_EXP */\n\n  Scene.FOGMODE_EXP2 = 2;\n  /** The fog density is following a linear function. */\n\n  Scene.FOGMODE_LINEAR = 3;\n  /**\n   * Gets or sets the minimum deltatime when deterministic lock step is enabled\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   */\n\n  Scene.MinDeltaTime = 1.0;\n  /**\n   * Gets or sets the maximum deltatime when deterministic lock step is enabled\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n   */\n\n  Scene.MaxDeltaTime = 1000.0;\n  return Scene;\n}(AbstractScene);\n\nexport { Scene };\n/**\n * @param id\n * @hidden\n */\n\nScene.prototype.setActiveCameraByID = function (id) {\n  return this.setActiveCameraById(id);\n};\n\nScene.prototype.getLastMaterialByID = function (id) {\n  return this.getLastMaterialById(id);\n};\n\nScene.prototype.getMaterialByID = function (id) {\n  return this.getMaterialById(id);\n};\n\nScene.prototype.getTextureByUniqueID = function (uniqueId) {\n  return this.getTextureByUniqueId(uniqueId);\n};\n\nScene.prototype.getCameraByID = function (id) {\n  return this.getCameraById(id);\n};\n\nScene.prototype.getCameraByUniqueID = function (uniqueId) {\n  return this.getCameraByUniqueId(uniqueId);\n};\n\nScene.prototype.getBoneByID = function (id) {\n  return this.getBoneById(id);\n};\n\nScene.prototype.getLightByID = function (id) {\n  return this.getLightById(id);\n};\n\nScene.prototype.getLightByUniqueID = function (uniqueId) {\n  return this.getLightByUniqueId(uniqueId);\n};\n\nScene.prototype.getParticleSystemByID = function (id) {\n  return this.getParticleSystemById(id);\n};\n\nScene.prototype.getGeometryByID = function (id) {\n  return this.getGeometryById(id);\n};\n\nScene.prototype.getMeshByID = function (id) {\n  return this.getMeshById(id);\n};\n\nScene.prototype.getMeshesByID = function (id) {\n  return this.getMeshesById(id);\n};\n\nScene.prototype.getTransformNodeByID = function (id) {\n  return this.getTransformNodeById(id);\n};\n\nScene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n  return this.getTransformNodeByUniqueId(uniqueId);\n};\n\nScene.prototype.getTransformNodesByID = function (id) {\n  return this.getTransformNodesById(id);\n};\n\nScene.prototype.getMeshByUniqueID = function (uniqueId) {\n  return this.getMeshByUniqueId(uniqueId);\n};\n\nScene.prototype.getLastMeshByID = function (id) {\n  return this.getLastMeshById(id);\n};\n\nScene.prototype.getLastEntryByID = function (id) {\n  return this.getLastEntryById(id);\n};\n\nScene.prototype.getNodeByID = function (id) {\n  return this.getNodeById(id);\n};\n\nScene.prototype.getLastSkeletonByID = function (id) {\n  return this.getLastSkeletonById(id);\n};","map":{"version":3,"mappings":"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","names":["Tools","PrecisionDate","Observable","SmartArrayNoDuplicate","SmartArray","StringDictionary","Tags","Vector3","Matrix","TmpVectors","AbstractScene","ImageProcessingConfiguration","UniformBuffer","PickingInfo","ActionEvent","PostProcessManager","RenderingManager","Stage","IsWindowObjectExist","EngineStore","_WarnImport","InputManager","PerfCounter","Color4","Color3","Frustum","UniqueIdGenerator","ReadFile","RequestFile","LoadFile","LightConstants","ComputePressureObserverWrapper","SliceTools","__extends","engine","options","_super","_this","Array","Scene","FOGMODE_NONE","Zero","Create","data","length","_engine","getTimeStep","fullOptions","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","LastCreatedEngine","_LastCreatedScene","scenes","push","_virtualScenes","_uid","_renderingManager","postProcessManager","attachControl","_createUbo","_imageProcessingConfiguration","setDefaultCandidateProviders","_geometriesByUniqueId","onNewSceneAddedObservable","notifyObservers","IsAvailable","_computePressureObserver","update","onComputePressureChanged","cpuUtilizationThresholds","cpuSpeedThresholds","observe","scene","Object","_environmentTexture","value","markAllMaterialsAsDirty","_forceWireframe","_skipFrustumClipping","_forcePointsCloud","_animationPropertiesOverride","callback","_onDisposeObserver","onDisposeObservable","remove","add","_onBeforeRenderObserver","onBeforeRenderObservable","_onAfterRenderObserver","onAfterRenderObservable","_onBeforeCameraRenderObserver","onBeforeCameraRenderObservable","_onAfterCameraRenderObserver","onAfterCameraRenderObservable","_inputManager","unTranslatedPointer","DragMovementThreshold","LongPressDelay","DoubleClickDelay","ExclusiveDoubleClickMode","effect","variableName","isVector3","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","_a","devicePosition","invertNormal","useRightHandedSystem","Vector4","set","x","y","z","setFloat3","setVector4","ubo","getSceneUniformBuffer","bindEyePosition","updateFloat4","w","_useRightHandedSystem","newStepId","_currentStepId","_currentInternalStep","_fogEnabled","_fogMode","prePassRenderer","defaultRT","enabled","_shadowsEnabled","_lightsEnabled","_activeCamera","onActiveCameraChanged","_defaultMaterial","DefaultMaterialFactory","_texturesEnabled","_skeletonsEnabled","_collisionCoordinator","CollisionCoordinatorFactory","init","_frustumPlanes","_transientComponents","_i","component","register","_components","serializableComponent","addFromContainer","serialize","_serializableComponents","name","_defaultMeshCandidates","meshes","mesh","_defaultSubMeshCandidates","subMeshes","getActiveMeshCandidates","_getDefaultMeshCandidates","bind","getActiveSubMeshCandidates","_getDefaultSubMeshCandidates","getIntersectingSubMeshCandidates","getCollidingSubMeshCandidates","meshUnderPointer","pointerX","pointerY","_cachedMaterial","_cachedEffect","_cachedVisibility","material","visibility","_totalVertices","current","_activeIndices","_activeParticles","_activeBones","_activeMeshes","_animationRatio","undefined","_renderId","_frameId","setSceneUniformBuffer","createSceneUniformBuffer","pickResult","pointerEventInit","simulatePointerMove","simulatePointerDown","doubleTap","simulatePointerUp","pointerId","isPointerCaptured","attachUp","attachDown","attachMove","detachControl","checkRenderTargets","_isDisposed","index","getEngine","_pendingData","_processedMaterials","reset","_materialsRenderTargets","isReady","isEnabled","hardwareInstancedRendering","hasThinInstances","getClassName","getCaps","instancedArrays","instances","_isReadyForMeshStage","step","action","mat","defaultMaterial","_storeEffectOnSubMeshes","_b","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","areAllEffectsReady","rtt","isReadyForRendering","geometries","geometry","delayLoadState","activeCameras","_d","camera","particleSystems","_f","particleSystem","func","removeCallback","execFunc","setTimeout","unregisterBeforeRender","registerBeforeRender","timeout","_executeOnceBeforeRender","wasLoading","isLoading","splice","onDataLoadedObservable","onReadyObservable","_executeWhenReadyTimeoutId","_checkIsReady","Promise","resolve","executeWhenReady","_registerTransientComponents","clear","_activeAnimatables","_animationTimeLast","Now","_viewMatrix","_projectionMatrix","_transformMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","_viewUpdateFlag","updateFlag","_projectionUpdateFlag","multiplyToRef","GetPlanes","GetPlanesToRef","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","UniqueId","newMesh","recursive","_blockEntityCollection","_resyncLightSources","parent","_addToSceneRootNodes","onNewMeshAddedObservable","getChildMeshes","forEach","m","addMesh","toRemove","pop","_removeFromSceneRootNodes","_invalidateMesh","onMeshRemovedObservable","removeMesh","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","onNewTransformNodeAddedObservable","lastNode","onTransformNodeRemovedObservable","skeletons","onSkeletonRemovedObservable","_executeActiveContainerCleanup","_activeSkeletons","morphTargetManagers","lights","_removeLightSource","sortLightsByPriority","onLightRemovedObservable","cameras","index2","onCameraRemovedObservable","_activeParticleSystems","animations","target","animationName","targetMask","animationGroups","multiMaterials","onMultiMaterialRemovedObservable","_indexInSceneMaterialArray","materials","lastMaterial","onMaterialRemovedObservable","actionManagers","textures","onTextureRemovedObservable","newLight","lightSources","onNewLightAddedObservable","requireLightSorting","sort","CompareLightsPriority","newCamera","onNewCameraAddedObservable","newSkeleton","onNewSkeletonAddedObservable","newParticleSystem","newAnimation","newAnimationGroup","newMultiMaterial","onNewMultiMaterialAddedObservable","newMaterial","onNewMaterialAddedObservable","newMorphTargetManager","newGeometry","uniqueId","newActionManager","newTexture","onNewTextureAddedObservable","canvas","getInputElement","id","getCameraById","getCameraByName","allowMultiMaterials","skeletonIndex","skeleton","boneIndex","bones","force","_getGeometryByUniqueId","addGeometry","onNewGeometryAddedObservable","lastGeometry","onGeometryRemovedObservable","filter","getMeshById","transformNode","getTransformNodeById","light","getLightById","bone","getBoneById","getMeshByName","getTransformNodeByName","getLightByName","getBoneByName","managerIndex","morphTargetManager","numTargets","getTarget","postProcessIndex","postProcesses","postProcess","RandomId","key","_externalData","get","factory","getOrAddWithFactory","initialMesh","hasInstances","isAnInstance","dispatchAllSubMeshesOfActiveMeshes","alwaysSelectAsActiveMesh","isInFrustum","_evaluateSubMeshStage","dispatch","_preventFreeActiveMeshesAndRenderingGroups","freeActiveMeshes","freeRenderingGroups","blockfreeActiveMeshesAndRenderingGroups","i","texture","renderList","_intermediateRendering","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","updateTransformMatrix","_evaluateActiveMeshes","_activeMeshesFrozen","_skipEvaluateActiveMeshesCompletely","_freeze","_internalAbstractMeshDataInfo","_isActive","_unFreeze","container","isInFastMode","snapshotRendering","snapshotRenderingMode","addOnce","_softwareSkinnedMeshes","len_1","computeWorldMatrix","psLength","animate","onBeforeActiveMeshesEvaluationObservable","_beforeEvaluateActiveMeshStage","len","_currentLODIsUpToDate","isBlocked","addCount","getTotalVertices","scaling","lengthSquared","actionManager","hasSpecificTriggers2","_meshesForIntersections","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","_activate","_preActiveMeshStage","_c","_onlyForInstances","_actAsRegularMesh","_activeMesh","_postActivate","onAfterActiveMeshesEvaluationObservable","particlesEnabled","onBeforeParticlesRenderingObservable","particleIndex","isStarted","emitter","position","dispatchParticles","onAfterParticlesRenderingObservable","sourceMesh","prepare","computeBonesUsingShaders","_evaluateSubMesh","_renderingMultiview","leftCamera","_rigCameras","rightCamera","setTransformMatrix","getViewMatrix","getProjectionMatrix","_multiviewTexture","_bindFrameBuffer","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","onClearObservable","hasObservers","skipInitialClear","clearColor","_cleared","_defaultFrameBufferCleared","_clear","rigParent","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","resetCachedMaterial","prePass","autoClear","softwareSkinnedMeshIndex","applySkeleton","onBeforeRenderTargetsRenderObservable","_renderTargets","customRenderTargets","environmentTexture","isRenderTarget","_gatherActiveCameraRenderTargetsStage","needRebind","renderTargetsEnabled","StartPerformanceCounter","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","dumpNextRenderTargets","EndPerformanceCounter","_cameraDrawRenderTargetStage","_e","currentRenderPassId","renderPassId","onAfterRenderTargetsRenderObservable","_prepareFrame","_beforeCameraDrawStage","_g","onBeforeDrawPhaseObservable","finalizeSceneUbo","onAfterDrawPhaseObservable","_afterCameraDrawStage","_j","_finalizeFrame","isIntermediate","cameraRigMode","_createMultiviewUbo","_renderForCamera","onAfterRenderCameraObservable","_useMultiviewToSingleView","_renderMultiviewToSingleView","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh_1","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","CreateNew","hasSpecificTrigger","parameter","parameterMesh","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","_timeAccumulator","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","onBeforeStepObservable","_animate","onAfterAnimationsObservable","physicsEnabled","_advancePhysicsEngineStep","onAfterStepObservable","useConstantAnimationDeltaTime","autoClearDepthAndStencil","forceWireframe","forcePointsCloud","isRigCamera","rigCameras","passId","resetDrawCache","updateCameras","ignoreAnimations","isDisposed","_checkCameraRenderTarget","fetchNewFrame","onBeforeAnimationsObservable","processTrigger","_beforeCameraUpdateStage","cameraIndex","currentActiveCamera","customIndex","_beforeClearStage","_gatherRenderTargetsStage","_processSubCameras","_checkIntersections","_afterRenderStage","afterRender","_toBeDisposed","freeze","unfreeze","beforeRender","metadata","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterRenderTargetDrawStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","importedMeshesFiles","stopAllAnimations","_registeredForLateAnimationBindings","activeRequests","_activeRequests","slice","request","abort","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","unobserve","index_1","_disposeList","item","wipeCaches","items","itemsCopy","Slice","meshIndex","clearCachedData","baseTexture","buffer","_buffer","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","CheckExtends","world","cameraViewSpace","result","enableDistantPicking","predicate","fastCheck","trianglePredicate","pi","_pickingUnavailable","ray","setPointerOverMesh","getPointerOverMesh","_rebuild","rebuild","system","spriteManagers","_h","spriteMgr","list","tagsQuery","listByTags","MatchesQuery","_getByTags","concat","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingOrder","autoClearDepthStencil","depth","stencil","setRenderingAutoClearDepthStencil","getAutoClearDepthStencilSetup","_blockMaterialDirtyMechanism","flag","markAsDirty","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","offlineProvider","onCompleteObservable","reject","_loadFile","exception","url","_requestFile","error","file","_readFile","prototype","setActiveCameraByID","setActiveCameraById","getLastMaterialByID","getLastMaterialById","getMaterialByID","getMaterialById","getTextureByUniqueID","getTextureByUniqueId","getCameraByID","getCameraByUniqueID","getCameraByUniqueId","getBoneByID","getLightByID","getLightByUniqueID","getLightByUniqueId","getParticleSystemByID","getParticleSystemById","getGeometryByID","getGeometryById","getMeshByID","getMeshesByID","getMeshesById","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodeByUniqueId","getTransformNodesByID","getTransformNodesById","getMeshByUniqueID","getMeshByUniqueId","getLastMeshByID","getLastMeshById","getLastEntryByID","getLastEntryById","getNodeByID","getNodeById","getLastSkeletonByID","getLastSkeletonById"],"sourceRoot":"","sources":["../../../../lts/core/generated/scene.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { Nullable } from \"./types\";\nimport { Tools } from \"./Misc/tools\";\nimport type { IAnimatable } from \"./Animations/animatable.interface\";\nimport { PrecisionDate } from \"./Misc/precisionDate\";\nimport type { Observer } from \"./Misc/observable\";\nimport { Observable } from \"./Misc/observable\";\nimport type { ISmartArrayLike } from \"./Misc/smartArray\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray\";\nimport { StringDictionary } from \"./Misc/stringDictionary\";\nimport { Tags } from \"./Misc/tags\";\nimport type { Vector2, Vector4 } from \"./Maths/math.vector\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector\";\nimport type { IParticleSystem } from \"./Particles/IParticleSystem\";\nimport { AbstractScene } from \"./abstractScene\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer\";\nimport { PickingInfo } from \"./Collisions/pickingInfo\";\nimport type { ICollisionCoordinator } from \"./Collisions/collisionCoordinator\";\nimport type { PointerEventTypes, PointerInfoPre, PointerInfo } from \"./Events/pointerEvents\";\nimport type { KeyboardInfoPre, KeyboardInfo } from \"./Events/keyboardEvents\";\nimport { ActionEvent } from \"./Actions/actionEvent\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager\";\nimport type { IOfflineProvider } from \"./Offline/IOfflineProvider\";\nimport type { RenderingGroupInfo, IRenderingManagerAutoClearSetup } from \"./Rendering/renderingManager\";\nimport { RenderingManager } from \"./Rendering/renderingManager\";\nimport type { ISceneComponent, ISceneSerializableComponent, SimpleStageAction, RenderTargetsStageAction, RenderTargetStageAction, MeshStageAction, EvaluateSubMeshStageAction, PreActiveMeshStageAction, CameraStageAction, RenderingGroupStageAction, RenderingMeshStageAction, PointerMoveStageAction, PointerUpDownStageAction, CameraStageFrameBufferAction, } from \"./sceneComponent\";\nimport { Stage } from \"./sceneComponent\";\nimport type { Engine } from \"./Engines/engine\";\nimport { Constants } from \"./Engines/constants\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement\";\nimport { EngineStore } from \"./Engines/engineStore\";\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\nimport { _WarnImport } from \"./Misc/devTools\";\nimport type { WebRequest } from \"./Misc/webRequest\";\nimport { InputManager } from \"./Inputs/scene.inputManager\";\nimport { PerfCounter } from \"./Misc/perfCounter\";\nimport type { IFileRequest } from \"./Misc/fileRequest\";\nimport { Color4, Color3 } from \"./Maths/math.color\";\nimport type { Plane } from \"./Maths/math.plane\";\nimport { Frustum } from \"./Maths/math.frustum\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator\";\nimport type { LoadFileError, RequestFileError, ReadFileError } from \"./Misc/fileTools\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools\";\nimport type { IClipPlanesHolder } from \"./Misc/interfaces/iClipPlanesHolder\";\nimport type { IPointerEvent } from \"./Events/deviceInputEvents\";\nimport { LightConstants } from \"./Lights/lightConstants\";\nimport type { IComputePressureData } from \"./Misc/computePressure\";\nimport { ComputePressureObserverWrapper } from \"./Misc/computePressure\";\nimport { SliceTools } from \"./Misc/sliceTools\";\ndeclare type Ray = import(\"./Culling/ray\").Ray;\ndeclare type TrianglePickingPredicate = import(\"./Culling/ray\").TrianglePickingPredicate;\ndeclare type Animation = import(\"./Animations/animation\").Animation;\ndeclare type Animatable = import(\"./Animations/animatable\").Animatable;\ndeclare type AnimationGroup = import(\"./Animations/animationGroup\").AnimationGroup;\ndeclare type AnimationPropertiesOverride = import(\"./Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\ndeclare type Collider = import(\"./Collisions/collider\").Collider;\ndeclare type PostProcess = import(\"./PostProcesses/postProcess\").PostProcess;\ndeclare type Material = import(\"./Materials/material\").Material;\ndeclare type AbstractMesh = import(\"./Meshes/abstractMesh\").AbstractMesh;\ndeclare type Light = import(\"./Lights/light\").Light;\ndeclare type Camera = import(\"./Cameras/camera\").Camera;\ndeclare type Texture = import(\"./Materials/Textures/texture\").Texture;\ndeclare type MultiMaterial = import(\"./Materials/multiMaterial\").MultiMaterial;\ndeclare type BaseTexture = import(\"./Materials/Textures/baseTexture\").BaseTexture;\ndeclare type TransformNode = import(\"./Meshes/transformNode\").TransformNode;\ndeclare type Skeleton = import(\"./Bones/skeleton\").Skeleton;\ndeclare type Bone = import(\"./Bones/bone\").Bone;\ndeclare type SubMesh = import(\"./Meshes/subMesh\").SubMesh;\ndeclare type Mesh = import(\"./Meshes/mesh\").Mesh;\ndeclare type Node = import(\"./node\").Node;\ndeclare type Geometry = import(\"./Meshes/geometry\").Geometry;\ndeclare type RenderTargetTexture = import(\"./Materials/Textures/renderTargetTexture\").RenderTargetTexture;\ndeclare type MorphTargetManager = import(\"./Morph/morphTargetManager\").MorphTargetManager;\ndeclare type Effect = import(\"./Materials/effect\").Effect;\ndeclare type MorphTarget = import(\"./Morph/morphTarget\").MorphTarget;\ndeclare type WebVRFreeCamera = import(\"./Cameras/VR/webVRCamera\").WebVRFreeCamera;\ndeclare type PerformanceViewerCollector = import(\"./Misc/PerformanceViewer/performanceViewerCollector\").PerformanceViewerCollector;\ndeclare type IAction = import(\"./Actions/action\").IAction;\n/**\n * Define an interface for all classes that will hold resources\n */\nexport interface IDisposable {\n    /**\n     * Releases all held resources\n     */\n    dispose(): void;\n}\n/** Interface defining initialization parameters for Scene class */\nexport interface SceneOptions {\n    /**\n     * Defines that scene should keep up-to-date a map of geometry to enable fast look-up by uniqueId\n     * It will improve performance when the number of geometries becomes important.\n     */\n    useGeometryUniqueIdsMap?: boolean;\n    /**\n     * Defines that each material of the scene should keep up-to-date a map of referencing meshes for fast disposing\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\n     */\n    useMaterialMeshMap?: boolean;\n    /**\n     * Defines that each mesh of the scene should keep up-to-date a map of referencing cloned meshes for fast disposing\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\n     */\n    useClonedMeshMap?: boolean;\n    /** Defines if the creation of the scene should impact the engine (Eg. UtilityLayer's scene) */\n    virtual?: boolean;\n}\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/scene\n */\nexport class Scene extends AbstractScene implements IAnimatable, IClipPlanesHolder {\n    /** The fog is deactivated */\n    public static readonly FOGMODE_NONE = 0;\n    /** The fog density is following an exponential function */\n    public static readonly FOGMODE_EXP = 1;\n    /** The fog density is following an exponential function faster than FOGMODE_EXP */\n    public static readonly FOGMODE_EXP2 = 2;\n    /** The fog density is following a linear function. */\n    public static readonly FOGMODE_LINEAR = 3;\n    /**\n     * Gets or sets the minimum deltatime when deterministic lock step is enabled\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     */\n    public static MinDeltaTime = 1.0;\n    /**\n     * Gets or sets the maximum deltatime when deterministic lock step is enabled\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     */\n    public static MaxDeltaTime = 1000.0;\n    /**\n     * Factory used to create the default material.\n     * @param scene The scene to create the material for\n     * @returns The default material\n     */\n    public static DefaultMaterialFactory(scene: Scene): Material {\n        throw _WarnImport(\"StandardMaterial\");\n    }\n    /**\n     * Factory used to create the a collision coordinator.\n     * @returns The collision coordinator\n     */\n    public static CollisionCoordinatorFactory(): ICollisionCoordinator {\n        throw _WarnImport(\"DefaultCollisionCoordinator\");\n    }\n    // Members\n    /** @hidden */\n    public _inputManager = new InputManager(this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n    public cameraToUseForPointers: Nullable<Camera> = null;\n    /** @hidden */\n    public readonly _isScene = true;\n    /** @hidden */\n    public _blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n    public autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n    public autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n    public clearColor: Color4 = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n    public ambientColor = new Color3(0, 0, 0);\n    /**\n     * This is use to store the default BRDF lookup for PBR materials in your scene.\n     * It should only be one of the following (if not the default embedded one):\n     * * For uncorrelated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = false) : https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\n     * * For correlated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedBRDF.dds\n     * * For correlated multi scattering BRDF (pbr.brdf.useEnergyConservation = true and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\n     * The material properties need to be setup according to the type of texture in use.\n     */\n    public environmentBRDFTexture: BaseTexture;\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    public get environmentTexture(): Nullable<BaseTexture> {\n        return this._environmentTexture;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */\n    public set environmentTexture(value: Nullable<BaseTexture>) {\n        if (this._environmentTexture === value) {\n            return;\n        }\n        this._environmentTexture = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n    }\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    public environmentIntensity: number = 1;\n    /** @hidden */\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\n        return this._imageProcessingConfiguration;\n    }\n    private _forceWireframe = false;\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n    public set forceWireframe(value: boolean) {\n        if (this._forceWireframe === value) {\n            return;\n        }\n        this._forceWireframe = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\n    }\n    public get forceWireframe(): boolean {\n        return this._forceWireframe;\n    }\n    private _skipFrustumClipping = false;\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */\n    public set skipFrustumClipping(value: boolean) {\n        if (this._skipFrustumClipping === value) {\n            return;\n        }\n        this._skipFrustumClipping = value;\n    }\n    public get skipFrustumClipping(): boolean {\n        return this._skipFrustumClipping;\n    }\n    private _forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */\n    public set forcePointsCloud(value: boolean) {\n        if (this._forcePointsCloud === value) {\n            return;\n        }\n        this._forcePointsCloud = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\n    }\n    public get forcePointsCloud(): boolean {\n        return this._forcePointsCloud;\n    }\n    /**\n     * Gets or sets the active clipplane 1\n     */\n    public clipPlane: Nullable<Plane>;\n    /**\n     * Gets or sets the active clipplane 2\n     */\n    public clipPlane2: Nullable<Plane>;\n    /**\n     * Gets or sets the active clipplane 3\n     */\n    public clipPlane3: Nullable<Plane>;\n    /**\n     * Gets or sets the active clipplane 4\n     */\n    public clipPlane4: Nullable<Plane>;\n    /**\n     * Gets or sets the active clipplane 5\n     */\n    public clipPlane5: Nullable<Plane>;\n    /**\n     * Gets or sets the active clipplane 6\n     */\n    public clipPlane6: Nullable<Plane>;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n    public animationsEnabled = true;\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\n    /**\n     * Gets or sets the animation properties override\n     */\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\n        return this._animationPropertiesOverride;\n    }\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n    public useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n    public constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n    public hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n    public defaultCursor: string = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n    public doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n    public preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n    public preventDefaultOnPointerUp = true;\n    // Metadata\n    /**\n     * Gets or sets user defined metadata\n     */\n    public metadata: any = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    public reservedDataStore: any = null;\n    /**\n     * Gets the name of the plugin used to load this scene (null by default)\n     */\n    public loadingPluginName: string;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n    public disableOfflineSupportExceptionRules = new Array<RegExp>();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n    public onDisposeObservable = new Observable<Scene>();\n    private _onDisposeObserver: Nullable<Observer<Scene>> = null;\n    /** Sets a function to be executed when this scene is disposed. */\n    public set onDispose(callback: () => void) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n    public onBeforeRenderObservable = new Observable<Scene>();\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> = null;\n    /** Sets a function to be executed before rendering this scene */\n    public set beforeRender(callback: Nullable<() => void>) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        if (callback) {\n            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n        }\n    }\n    /**\n     * An event triggered after rendering the scene\n     */\n    public onAfterRenderObservable = new Observable<Scene>();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     */\n    public onAfterRenderCameraObservable = new Observable<Camera>();\n    private _onAfterRenderObserver: Nullable<Observer<Scene>> = null;\n    /** Sets a function to be executed after rendering this scene */\n    public set afterRender(callback: Nullable<() => void>) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        if (callback) {\n            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n        }\n    }\n    /**\n     * An event triggered before animating the scene\n     */\n    public onBeforeAnimationsObservable = new Observable<Scene>();\n    /**\n     * An event triggered after animations processing\n     */\n    public onAfterAnimationsObservable = new Observable<Scene>();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n    public onBeforeDrawPhaseObservable = new Observable<Scene>();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n    public onAfterDrawPhaseObservable = new Observable<Scene>();\n    /**\n     * An event triggered when the scene is ready\n     */\n    public onReadyObservable = new Observable<Scene>();\n    /**\n     * An event triggered before rendering a camera\n     */\n    public onBeforeCameraRenderObservable = new Observable<Camera>();\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\n    /** Sets a function to be executed before rendering a camera*/\n    public set beforeCameraRender(callback: () => void) {\n        if (this._onBeforeCameraRenderObserver) {\n            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        }\n        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    }\n    /**\n     * An event triggered after rendering a camera\n     */\n    public onAfterCameraRenderObservable = new Observable<Camera>();\n    private _onAfterCameraRenderObserver: Nullable<Observer<Camera>> = null;\n    /** Sets a function to be executed after rendering a camera*/\n    public set afterCameraRender(callback: () => void) {\n        if (this._onAfterCameraRenderObserver) {\n            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n        }\n        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    }\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n    public onBeforeActiveMeshesEvaluationObservable = new Observable<Scene>();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n    public onAfterActiveMeshesEvaluationObservable = new Observable<Scene>();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    public onBeforeParticlesRenderingObservable = new Observable<Scene>();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    public onAfterParticlesRenderingObservable = new Observable<Scene>();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n    public onDataLoadedObservable = new Observable<Scene>();\n    /**\n     * An event triggered when a camera is created\n     */\n    public onNewCameraAddedObservable = new Observable<Camera>();\n    /**\n     * An event triggered when a camera is removed\n     */\n    public onCameraRemovedObservable = new Observable<Camera>();\n    /**\n     * An event triggered when a light is created\n     */\n    public onNewLightAddedObservable = new Observable<Light>();\n    /**\n     * An event triggered when a light is removed\n     */\n    public onLightRemovedObservable = new Observable<Light>();\n    /**\n     * An event triggered when a geometry is created\n     */\n    public onNewGeometryAddedObservable = new Observable<Geometry>();\n    /**\n     * An event triggered when a geometry is removed\n     */\n    public onGeometryRemovedObservable = new Observable<Geometry>();\n    /**\n     * An event triggered when a transform node is created\n     */\n    public onNewTransformNodeAddedObservable = new Observable<TransformNode>();\n    /**\n     * An event triggered when a transform node is removed\n     */\n    public onTransformNodeRemovedObservable = new Observable<TransformNode>();\n    /**\n     * An event triggered when a mesh is created\n     */\n    public onNewMeshAddedObservable = new Observable<AbstractMesh>();\n    /**\n     * An event triggered when a mesh is removed\n     */\n    public onMeshRemovedObservable = new Observable<AbstractMesh>();\n    /**\n     * An event triggered when a skeleton is created\n     */\n    public onNewSkeletonAddedObservable = new Observable<Skeleton>();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n    public onSkeletonRemovedObservable = new Observable<Skeleton>();\n    /**\n     * An event triggered when a material is created\n     */\n    public onNewMaterialAddedObservable = new Observable<Material>();\n    /**\n     * An event triggered when a multi material is created\n     */\n    public onNewMultiMaterialAddedObservable = new Observable<MultiMaterial>();\n    /**\n     * An event triggered when a material is removed\n     */\n    public onMaterialRemovedObservable = new Observable<Material>();\n    /**\n     * An event triggered when a multi material is removed\n     */\n    public onMultiMaterialRemovedObservable = new Observable<MultiMaterial>();\n    /**\n     * An event triggered when a texture is created\n     */\n    public onNewTextureAddedObservable = new Observable<BaseTexture>();\n    /**\n     * An event triggered when a texture is removed\n     */\n    public onTextureRemovedObservable = new Observable<BaseTexture>();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n    public onBeforeRenderTargetsRenderObservable = new Observable<Scene>();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n    public onAfterRenderTargetsRenderObservable = new Observable<Scene>();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n    public onBeforeStepObservable = new Observable<Scene>();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n    public onAfterStepObservable = new Observable<Scene>();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n    public onActiveCameraChanged = new Observable<Scene>();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    public onBeforeRenderingGroupObservable = new Observable<RenderingGroupInfo>();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    public onAfterRenderingGroupObservable = new Observable<RenderingGroupInfo>();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n    public onMeshImportedObservable = new Observable<AbstractMesh>();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n    public onAnimationFileImportedObservable = new Observable<Scene>();\n    /**\n     * Gets or sets a user defined funtion to select LOD from a mesh and a camera.\n     * By default this function is undefined and Babylon.js will select LOD based on distance to camera\n     */\n    public customLODSelector: (mesh: AbstractMesh, camera: Camera) => Nullable<AbstractMesh>;\n    // Animations\n    /** @hidden */\n    public _registeredForLateAnimationBindings = new SmartArrayNoDuplicate<any>(256);\n    // Pointers\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\n     */\n    public pointerDownPredicate: (Mesh: AbstractMesh) => boolean;\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\n     */\n    public pointerUpPredicate: (Mesh: AbstractMesh) => boolean;\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\n     */\n    public pointerMovePredicate: (Mesh: AbstractMesh) => boolean;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n     */\n    public skipPointerMovePicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n     */\n    public skipPointerDownPicking = false;\n    /** Callback called when a pointer move is detected */\n    public onPointerMove: (evt: IPointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\n    /** Callback called when a pointer down is detected  */\n    public onPointerDown: (evt: IPointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\n    /** Callback called when a pointer up is detected  */\n    public onPointerUp: (evt: IPointerEvent, pickInfo: Nullable<PickingInfo>, type: PointerEventTypes) => void;\n    /** Callback called when a pointer pick is detected */\n    public onPointerPick: (evt: IPointerEvent, pickInfo: PickingInfo) => void;\n    /**\n     * Gets or sets a predicate used to select candidate faces for a pointer move event\n     */\n    public pointerMoveTrianglePredicate: ((p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean) | undefined;\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n    public onPrePointerObservable = new Observable<PointerInfoPre>();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n    public onPointerObservable = new Observable<PointerInfo>();\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n    public get unTranslatedPointer(): Vector2 {\n        return this._inputManager.unTranslatedPointer;\n    }\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n    public static get DragMovementThreshold() {\n        return InputManager.DragMovementThreshold;\n    }\n    public static set DragMovementThreshold(value: number) {\n        InputManager.DragMovementThreshold = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n    public static get LongPressDelay() {\n        return InputManager.LongPressDelay;\n    }\n    public static set LongPressDelay(value: number) {\n        InputManager.LongPressDelay = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n    public static get DoubleClickDelay() {\n        return InputManager.DoubleClickDelay;\n    }\n    public static set DoubleClickDelay(value: number) {\n        InputManager.DoubleClickDelay = value;\n    }\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    public static get ExclusiveDoubleClickMode() {\n        return InputManager.ExclusiveDoubleClickMode;\n    }\n    public static set ExclusiveDoubleClickMode(value: boolean) {\n        InputManager.ExclusiveDoubleClickMode = value;\n    }\n    /**\n     * Bind the current view position to an effect.\n     * @param effect The effect to be bound\n     * @param variableName name of the shader variable that will hold the eye position\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n     * @return the computed eye position\n     */\n    public bindEyePosition(effect: Nullable<Effect>, variableName = \"vEyePosition\", isVector3 = false): Vector4 {\n        const eyePosition = this._forcedViewPosition\n            ? this._forcedViewPosition\n            : this._mirroredCameraPosition\n                ? this._mirroredCameraPosition\n                : this.activeCamera!.globalPosition ?? (this.activeCamera as WebVRFreeCamera).devicePosition;\n        const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n        if (effect) {\n            if (isVector3) {\n                effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n            }\n            else {\n                effect.setVector4(variableName, TmpVectors.Vector4[0]);\n            }\n        }\n        return TmpVectors.Vector4[0];\n    }\n    /**\n     * Update the scene ubo before it can be used in rendering processing\n     * @returns the scene UniformBuffer\n     */\n    public finalizeSceneUbo(): UniformBuffer {\n        const ubo = this.getSceneUniformBuffer();\n        const eyePosition = this.bindEyePosition(null);\n        ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n        ubo.update();\n        return ubo;\n    }\n    // Mirror\n    /** @hidden */\n    public _mirroredCameraPosition: Nullable<Vector3>;\n    // Keyboard\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n    public onPreKeyboardObservable = new Observable<KeyboardInfoPre>();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n    public onKeyboardObservable = new Observable<KeyboardInfo>();\n    // Coordinates system\n    private _useRightHandedSystem = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n    public set useRightHandedSystem(value: boolean) {\n        if (this._useRightHandedSystem === value) {\n            return;\n        }\n        this._useRightHandedSystem = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\n    }\n    public get useRightHandedSystem(): boolean {\n        return this._useRightHandedSystem;\n    }\n    // Deterministic lockstep\n    private _timeAccumulator: number = 0;\n    private _currentStepId: number = 0;\n    private _currentInternalStep: number = 0;\n    /**\n     * Sets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @param newStepId defines the step Id\n     */\n    public setStepId(newStepId: number): void {\n        this._currentStepId = newStepId;\n    }\n    /**\n     * Gets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @returns the step Id\n     */\n    public getStepId(): number {\n        return this._currentStepId;\n    }\n    /**\n     * Gets the internal step used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @returns the internal step\n     */\n    public getInternalStep(): number {\n        return this._currentInternalStep;\n    }\n    // Fog\n    private _fogEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is true)\n     */\n    public set fogEnabled(value: boolean) {\n        if (this._fogEnabled === value) {\n            return;\n        }\n        this._fogEnabled = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\n    }\n    public get fogEnabled(): boolean {\n        return this._fogEnabled;\n    }\n    private _fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */\n    public set fogMode(value: number) {\n        if (this._fogMode === value) {\n            return;\n        }\n        this._fogMode = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_MiscDirtyFlag);\n    }\n    public get fogMode(): number {\n        return this._fogMode;\n    }\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n    public fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0.1)\n     */\n    public fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0)\n     */\n    public fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 1000)\n     */\n    public fogEnd = 1000.0;\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */\n    public get prePass(): boolean {\n        return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    }\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n    public needsPreviousWorldMatrices = false;\n    // Lights\n    private _shadowsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n    public set shadowsEnabled(value: boolean) {\n        if (this._shadowsEnabled === value) {\n            return;\n        }\n        this._shadowsEnabled = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_LightDirtyFlag);\n    }\n    public get shadowsEnabled(): boolean {\n        return this._shadowsEnabled;\n    }\n    private _lightsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */\n    public set lightsEnabled(value: boolean) {\n        if (this._lightsEnabled === value) {\n            return;\n        }\n        this._lightsEnabled = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_LightDirtyFlag);\n    }\n    public get lightsEnabled(): boolean {\n        return this._lightsEnabled;\n    }\n    /** All of the active cameras added to this scene. */\n    public activeCameras: Nullable<Camera[]> = new Array<Camera>();\n    /** @hidden */\n    public _activeCamera: Nullable<Camera>;\n    /** Gets or sets the current active camera */\n    public get activeCamera(): Nullable<Camera> {\n        return this._activeCamera;\n    }\n    public set activeCamera(value: Nullable<Camera>) {\n        if (value === this._activeCamera) {\n            return;\n        }\n        this._activeCamera = value;\n        this.onActiveCameraChanged.notifyObservers(this);\n    }\n    private _defaultMaterial: Material;\n    /** The default material used on meshes when no material is affected */\n    public get defaultMaterial(): Material {\n        if (!this._defaultMaterial) {\n            this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n        }\n        return this._defaultMaterial;\n    }\n    /** The default material used on meshes when no material is affected */\n    public set defaultMaterial(value: Material) {\n        this._defaultMaterial = value;\n    }\n    // Textures\n    private _texturesEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n    public set texturesEnabled(value: boolean) {\n        if (this._texturesEnabled === value) {\n            return;\n        }\n        this._texturesEnabled = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n    }\n    public get texturesEnabled(): boolean {\n        return this._texturesEnabled;\n    }\n    // Physics\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n    public physicsEnabled = true;\n    // Particles\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n    public particlesEnabled = true;\n    // Sprites\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n    public spritesEnabled = true;\n    // Skeletons\n    private _skeletonsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */\n    public set skeletonsEnabled(value: boolean) {\n        if (this._skeletonsEnabled === value) {\n            return;\n        }\n        this._skeletonsEnabled = value;\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_AttributesDirtyFlag);\n    }\n    public get skeletonsEnabled(): boolean {\n        return this._skeletonsEnabled;\n    }\n    // Lens flares\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n    public lensFlaresEnabled = true;\n    // Collisions\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n    public collisionsEnabled = true;\n    private _collisionCoordinator: ICollisionCoordinator;\n    /** @hidden */\n    public get collisionCoordinator(): ICollisionCoordinator {\n        if (!this._collisionCoordinator) {\n            this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n            this._collisionCoordinator.init(this);\n        }\n        return this._collisionCoordinator;\n    }\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n    public gravity = new Vector3(0, -9.807, 0);\n    // Postprocesses\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n    public postProcessesEnabled = true;\n    /**\n     * Gets the current postprocess manager\n     */\n    public postProcessManager: PostProcessManager;\n    // Customs render targets\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n    public renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n    public dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n    public customRenderTargets = new Array<RenderTargetTexture>();\n    /**\n     * Defines if texture loading must be delayed\n     * If true, textures will only be loaded when they need to be rendered\n     */\n    public useDelayedTextureLoading: boolean;\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n    public importedMeshesFiles = new Array<String>();\n    // Probes\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n    public probesEnabled = true;\n    // Offline support\n    /**\n     * Gets or sets the current offline provider to use to store scene data\n     * @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb\n     */\n    public offlineProvider: IOfflineProvider;\n    /**\n     * Gets or sets the action manager associated with the scene\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\n     */\n    public actionManager: AbstractActionManager;\n    private _meshesForIntersections = new SmartArrayNoDuplicate<AbstractMesh>(256);\n    // Procedural textures\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n    public proceduralTexturesEnabled = true;\n    // Private\n    private _engine: Engine;\n    // Performance counters\n    private _totalVertices = new PerfCounter();\n    /** @hidden */\n    public _activeIndices = new PerfCounter();\n    /** @hidden */\n    public _activeParticles = new PerfCounter();\n    /** @hidden */\n    public _activeBones = new PerfCounter();\n    private _animationRatio: number;\n    /** @hidden */\n    public _animationTimeLast: number;\n    /** @hidden */\n    public _animationTime: number = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n    public animationTimeScale: number = 1;\n    /** @hidden */\n    public _cachedMaterial: Nullable<Material>;\n    /** @hidden */\n    public _cachedEffect: Nullable<Effect>;\n    /** @hidden */\n    public _cachedVisibility: Nullable<number>;\n    private _renderId = 0;\n    private _frameId = 0;\n    private _executeWhenReadyTimeoutId: Nullable<ReturnType<typeof setTimeout>> = null;\n    private _intermediateRendering = false;\n    private _defaultFrameBufferCleared = false;\n    private _viewUpdateFlag = -1;\n    private _projectionUpdateFlag = -1;\n    /** @hidden */\n    public _toBeDisposed = new Array<Nullable<IDisposable>>(256);\n    private _activeRequests = new Array<IFileRequest>();\n    /** @hidden */\n    public _pendingData = new Array();\n    private _isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n    public dispatchAllSubMeshesOfActiveMeshes: boolean = false;\n    private _activeMeshes = new SmartArray<AbstractMesh>(256);\n    private _processedMaterials = new SmartArray<Material>(256);\n    private _renderTargets = new SmartArrayNoDuplicate<RenderTargetTexture>(256);\n    private _materialsRenderTargets = new SmartArrayNoDuplicate<RenderTargetTexture>(256);\n    /** @hidden */\n    public _activeParticleSystems = new SmartArray<IParticleSystem>(256);\n    private _activeSkeletons = new SmartArrayNoDuplicate<Skeleton>(32);\n    private _softwareSkinnedMeshes = new SmartArrayNoDuplicate<Mesh>(32);\n    private _renderingManager: RenderingManager;\n    /** @hidden */\n    public _activeAnimatables = new Array<Animatable>();\n    private _transformMatrix = Matrix.Zero();\n    private _sceneUbo: UniformBuffer;\n    /** @hidden */\n    public _viewMatrix: Matrix;\n    /** @hidden */\n    public _projectionMatrix: Matrix;\n    /** @hidden */\n    public _forcedViewPosition: Nullable<Vector3>;\n    /** @hidden */\n    public _frustumPlanes: Plane[];\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n    public get frustumPlanes(): Plane[] {\n        return this._frustumPlanes;\n    }\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n    public requireLightSorting = false;\n    /** @hidden */\n    public readonly useMaterialMeshMap: boolean;\n    /** @hidden */\n    public readonly useClonedMeshMap: boolean;\n    private _externalData: StringDictionary<Object>;\n    private _uid: Nullable<string>;\n    /**\n     * @hidden\n     * Backing store of defined scene components.\n     */\n    public _components: ISceneComponent[] = [];\n    /**\n     * @hidden\n     * Backing store of defined scene components.\n     */\n    public _serializableComponents: ISceneSerializableComponent[] = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n    private _transientComponents: ISceneComponent[] = [];\n    /**\n     * Registers the transient components if needed.\n     */\n    private _registerTransientComponents(): void {\n        // Register components that have been associated lately to the scene.\n        if (this._transientComponents.length > 0) {\n            for (const component of this._transientComponents) {\n                component.register();\n            }\n            this._transientComponents = [];\n        }\n    }\n    /**\n     * @hidden\n     * Add a component to the scene.\n     * Note that the ccomponent could be registered on th next frame if this is called after\n     * the register component stage.\n     * @param component Defines the component to add to the scene\n     */\n    public _addComponent(component: ISceneComponent) {\n        this._components.push(component);\n        this._transientComponents.push(component);\n        const serializableComponent = component as any;\n        if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n            this._serializableComponents.push(serializableComponent);\n        }\n    }\n    /**\n     * @hidden\n     * Gets a component from the scene.\n     * @param name defines the name of the component to retrieve\n     * @returns the component or null if not present\n     */\n    public _getComponent(name: string): Nullable<ISceneComponent> {\n        for (const component of this._components) {\n            if (component.name === name) {\n                return component;\n            }\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     * Defines the actions happening before camera updates.\n     */\n    public _beforeCameraUpdateStage = Stage.Create<SimpleStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening before clear the canvas.\n     */\n    public _beforeClearStage = Stage.Create<SimpleStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening before clear the canvas.\n     */\n    public _beforeRenderTargetClearStage = Stage.Create<RenderTargetStageAction>();\n    /**\n     * @hidden\n     * Defines the actions when collecting render targets for the frame.\n     */\n    public _gatherRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening for one camera in the frame.\n     */\n    public _gatherActiveCameraRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening during the per mesh ready checks.\n     */\n    public _isReadyForMeshStage = Stage.Create<MeshStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n    public _beforeEvaluateActiveMeshStage = Stage.Create<SimpleStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n    public _evaluateSubMeshStage = Stage.Create<EvaluateSubMeshStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening during the active mesh stage.\n     */\n    public _preActiveMeshStage = Stage.Create<PreActiveMeshStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening during the per camera render target step.\n     */\n    public _cameraDrawRenderTargetStage = Stage.Create<CameraStageFrameBufferAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just before the active camera is drawing.\n     */\n    public _beforeCameraDrawStage = Stage.Create<CameraStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just before a render target is drawing.\n     */\n    public _beforeRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n    public _beforeRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just before a mesh is drawing.\n     */\n    public _beforeRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n    public _afterRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n    public _afterRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n    public _afterCameraDrawStage = Stage.Create<CameraStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just after a render target has been drawn.\n     */\n    public _afterRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n    public _afterRenderStage = Stage.Create<SimpleStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer move event happens.\n     */\n    public _pointerMoveStage = Stage.Create<PointerMoveStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer down event happens.\n     */\n    public _pointerDownStage = Stage.Create<PointerUpDownStageAction>();\n    /**\n     * @hidden\n     * Defines the actions happening when a pointer up event happens.\n     */\n    public _pointerUpStage = Stage.Create<PointerUpDownStageAction>();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n    private _geometriesByUniqueId: Nullable<{\n        [uniqueId: string]: number | undefined;\n    }> = null;\n    /**\n     * Creates a new Scene\n     * @param engine defines the engine to use to render this scene\n     * @param options defines the scene options\n     */\n    constructor(engine: Engine, options?: SceneOptions) {\n        super();\n        const fullOptions = {\n            useGeometryUniqueIdsMap: true,\n            useMaterialMeshMap: true,\n            useClonedMeshMap: true,\n            virtual: false,\n            ...options\n        };\n        this._engine = engine || EngineStore.LastCreatedEngine;\n        if (!fullOptions.virtual) {\n            EngineStore._LastCreatedScene = this;\n            this._engine.scenes.push(this);\n        }\n        else {\n            this._engine._virtualScenes.push(this);\n        }\n        this._uid = null;\n        this._renderingManager = new RenderingManager(this);\n        if (PostProcessManager) {\n            this.postProcessManager = new PostProcessManager(this);\n        }\n        if (IsWindowObjectExist()) {\n            this.attachControl();\n        }\n        // Uniform Buffer\n        this._createUbo();\n        // Default Image processing definition\n        if (ImageProcessingConfiguration) {\n            this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n        }\n        this.setDefaultCandidateProviders();\n        if (fullOptions.useGeometryUniqueIdsMap) {\n            this._geometriesByUniqueId = {};\n        }\n        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n        this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n        if (!options || !options.virtual) {\n            this._engine.onNewSceneAddedObservable.notifyObservers(this);\n        }\n        if (ComputePressureObserverWrapper.IsAvailable) {\n            this._computePressureObserver = new ComputePressureObserverWrapper((update) => {\n                this.onComputePressureChanged.notifyObservers(update);\n            }, {\n                // Thresholds divide the interval [0.0 .. 1.0] into ranges.\n                cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],\n                cpuSpeedThresholds: [0.5]\n            });\n            this._computePressureObserver.observe();\n        }\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"Scene\" string\n     */\n    public getClassName(): string {\n        return \"Scene\";\n    }\n    private _defaultMeshCandidates: ISmartArrayLike<AbstractMesh> = {\n        data: [],\n        length: 0\n    };\n    /**\n     * @hidden\n     */\n    public _getDefaultMeshCandidates(): ISmartArrayLike<AbstractMesh> {\n        this._defaultMeshCandidates.data = this.meshes;\n        this._defaultMeshCandidates.length = this.meshes.length;\n        return this._defaultMeshCandidates;\n    }\n    private _defaultSubMeshCandidates: ISmartArrayLike<SubMesh> = {\n        data: [],\n        length: 0\n    };\n    /**\n     * @param mesh\n     * @hidden\n     */\n    public _getDefaultSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\n        this._defaultSubMeshCandidates.data = mesh.subMeshes;\n        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n        return this._defaultSubMeshCandidates;\n    }\n    /**\n     * Sets the default candidate providers for the scene.\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n     * and getCollidingSubMeshCandidates to their default function\n     */\n    public setDefaultCandidateProviders(): void {\n        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n        this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n        this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n        this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    }\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\n        return this._inputManager.meshUnderPointer;\n    }\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n    public get pointerX(): number {\n        return this._inputManager.pointerX;\n    }\n    public set pointerX(value: number) {\n        this._inputManager.pointerX = value;\n    }\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n    public get pointerY(): number {\n        return this._inputManager.pointerY;\n    }\n    public set pointerY(value: number) {\n        this._inputManager.pointerY = value;\n    }\n    /**\n     * Gets the cached material (ie. the latest rendered one)\n     * @returns the cached material\n     */\n    public getCachedMaterial(): Nullable<Material> {\n        return this._cachedMaterial;\n    }\n    /**\n     * Gets the cached effect (ie. the latest rendered one)\n     * @returns the cached effect\n     */\n    public getCachedEffect(): Nullable<Effect> {\n        return this._cachedEffect;\n    }\n    /**\n     * Gets the cached visibility state (ie. the latest rendered one)\n     * @returns the cached visibility state\n     */\n    public getCachedVisibility(): Nullable<number> {\n        return this._cachedVisibility;\n    }\n    /**\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\n     * @param material defines the current material\n     * @param effect defines the current effect\n     * @param visibility defines the current visibility state\n     * @returns true if one parameter is not cached\n     */\n    public isCachedMaterialInvalid(material: Material, effect: Effect, visibility: number = 1) {\n        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n    }\n    /**\n     * Gets the engine associated with the scene\n     * @returns an Engine\n     */\n    public getEngine(): Engine {\n        return this._engine;\n    }\n    /**\n     * Gets the total number of vertices rendered per frame\n     * @returns the total number of vertices rendered per frame\n     */\n    public getTotalVertices(): number {\n        return this._totalVertices.current;\n    }\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    public get totalVerticesPerfCounter(): PerfCounter {\n        return this._totalVertices;\n    }\n    /**\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n     * @returns the total number of active indices rendered per frame\n     */\n    public getActiveIndices(): number {\n        return this._activeIndices.current;\n    }\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    public get totalActiveIndicesPerfCounter(): PerfCounter {\n        return this._activeIndices;\n    }\n    /**\n     * Gets the total number of active particles rendered per frame\n     * @returns the total number of active particles rendered per frame\n     */\n    public getActiveParticles(): number {\n        return this._activeParticles.current;\n    }\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    public get activeParticlesPerfCounter(): PerfCounter {\n        return this._activeParticles;\n    }\n    /**\n     * Gets the total number of active bones rendered per frame\n     * @returns the total number of active bones rendered per frame\n     */\n    public getActiveBones(): number {\n        return this._activeBones.current;\n    }\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n    public get activeBonesPerfCounter(): PerfCounter {\n        return this._activeBones;\n    }\n    /**\n     * Gets the array of active meshes\n     * @returns an array of AbstractMesh\n     */\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\n        return this._activeMeshes;\n    }\n    /**\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n     * @returns a number\n     */\n    public getAnimationRatio(): number {\n        return this._animationRatio !== undefined ? this._animationRatio : 1;\n    }\n    /**\n     * Gets an unique Id for the current render phase\n     * @returns a number\n     */\n    public getRenderId(): number {\n        return this._renderId;\n    }\n    /**\n     * Gets an unique Id for the current frame\n     * @returns a number\n     */\n    public getFrameId(): number {\n        return this._frameId;\n    }\n    /** Call this function if you want to manually increment the render Id*/\n    public incrementRenderId(): void {\n        this._renderId++;\n    }\n    private _createUbo(): void {\n        this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n    }\n    /**\n     * Use this method to simulate a pointer move on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\n        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer down on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\n        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer up on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n     * @returns the current scene\n     */\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): Scene {\n        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n        return this;\n    }\n    /**\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n     * @returns true if the pointer was captured\n     */\n    public isPointerCaptured(pointerId = 0): boolean {\n        return this._inputManager.isPointerCaptured(pointerId);\n    }\n    /**\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n     * @param attachUp defines if you want to attach events to pointerup\n     * @param attachDown defines if you want to attach events to pointerdown\n     * @param attachMove defines if you want to attach events to pointermove\n     */\n    public attachControl(attachUp = true, attachDown = true, attachMove = true): void {\n        this._inputManager.attachControl(attachUp, attachDown, attachMove);\n    }\n    /** Detaches all event handlers*/\n    public detachControl() {\n        this._inputManager.detachControl();\n    }\n    /**\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n     * Delay loaded resources are not taking in account\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n     * @return true if all required resources are ready\n     */\n    public isReady(checkRenderTargets = true): boolean {\n        if (this._isDisposed) {\n            return false;\n        }\n        let index: number;\n        const engine = this.getEngine();\n        // Pending data\n        if (this._pendingData.length > 0) {\n            return false;\n        }\n        // Meshes\n        if (checkRenderTargets) {\n            this._processedMaterials.reset();\n            this._materialsRenderTargets.reset();\n        }\n        let isReady = true;\n        for (index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (!mesh.isEnabled()) {\n                continue;\n            }\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n                continue;\n            }\n            if (!mesh.isReady(true)) {\n                isReady = false;\n                continue;\n            }\n            const hardwareInstancedRendering = mesh.hasThinInstances ||\n                mesh.getClassName() === \"InstancedMesh\" ||\n                mesh.getClassName() === \"InstancedLinesMesh\" ||\n                (engine.getCaps().instancedArrays && (<Mesh>mesh).instances.length > 0);\n            // Is Ready For Mesh\n            for (const step of this._isReadyForMeshStage) {\n                if (!step.action(mesh, hardwareInstancedRendering)) {\n                    isReady = false;\n                }\n            }\n            if (!checkRenderTargets) {\n                continue;\n            }\n            const mat = mesh.material || this.defaultMaterial;\n            if (mat) {\n                if (mat._storeEffectOnSubMeshes) {\n                    for (const subMesh of mesh.subMeshes) {\n                        const material = subMesh.getMaterial();\n                        if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                            if (this._processedMaterials.indexOf(material) === -1) {\n                                this._processedMaterials.push(material);\n                                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures!());\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n                        if (this._processedMaterials.indexOf(mat) === -1) {\n                            this._processedMaterials.push(mat);\n                            this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures!());\n                        }\n                    }\n                }\n            }\n        }\n        if (!isReady) {\n            return false;\n        }\n        // Effects\n        if (!engine.areAllEffectsReady()) {\n            return false;\n        }\n        // Render targets\n        if (checkRenderTargets) {\n            for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n                const rtt = this._materialsRenderTargets.data[index];\n                if (!rtt.isReadyForRendering()) {\n                    return false;\n                }\n            }\n        }\n        // Geometries\n        for (index = 0; index < this.geometries.length; index++) {\n            const geometry = this.geometries[index];\n            if (geometry.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\n                return false;\n            }\n        }\n        // Post-processes\n        if (this.activeCameras && this.activeCameras.length > 0) {\n            for (const camera of this.activeCameras) {\n                if (!camera.isReady(true)) {\n                    return false;\n                }\n            }\n        }\n        else if (this.activeCamera) {\n            if (!this.activeCamera.isReady(true)) {\n                return false;\n            }\n        }\n        // Particles\n        for (const particleSystem of this.particleSystems) {\n            if (!particleSystem.isReady()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** Resets all cached information relative to material (including effect and visibility) */\n    public resetCachedMaterial(): void {\n        this._cachedMaterial = null;\n        this._cachedEffect = null;\n        this._cachedVisibility = null;\n    }\n    /**\n     * Registers a function to be called before every frame render\n     * @param func defines the function to register\n     */\n    public registerBeforeRender(func: () => void): void {\n        this.onBeforeRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called before every frame render\n     * @param func defines the function to unregister\n     */\n    public unregisterBeforeRender(func: () => void): void {\n        this.onBeforeRenderObservable.removeCallback(func);\n    }\n    /**\n     * Registers a function to be called after every frame render\n     * @param func defines the function to register\n     */\n    public registerAfterRender(func: () => void): void {\n        this.onAfterRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called after every frame render\n     * @param func defines the function to unregister\n     */\n    public unregisterAfterRender(func: () => void): void {\n        this.onAfterRenderObservable.removeCallback(func);\n    }\n    private _executeOnceBeforeRender(func: () => void): void {\n        const execFunc = () => {\n            func();\n            setTimeout(() => {\n                this.unregisterBeforeRender(execFunc);\n            });\n        };\n        this.registerBeforeRender(execFunc);\n    }\n    /**\n     * The provided function will run before render once and will be disposed afterwards.\n     * A timeout delay can be provided so that the function will be executed in N ms.\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n     * @param func The function to be executed.\n     * @param timeout optional delay in ms\n     */\n    public executeOnceBeforeRender(func: () => void, timeout?: number): void {\n        if (timeout !== undefined) {\n            setTimeout(() => {\n                this._executeOnceBeforeRender(func);\n            }, timeout);\n        }\n        else {\n            this._executeOnceBeforeRender(func);\n        }\n    }\n    /**\n     * @param data\n     * @hidden\n     */\n    public _addPendingData(data: any): void {\n        this._pendingData.push(data);\n    }\n    /**\n     * @param data\n     * @hidden\n     */\n    public _removePendingData(data: any): void {\n        const wasLoading = this.isLoading;\n        const index = this._pendingData.indexOf(data);\n        if (index !== -1) {\n            this._pendingData.splice(index, 1);\n        }\n        if (wasLoading && !this.isLoading) {\n            this.onDataLoadedObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Returns the number of items waiting to be loaded\n     * @returns the number of items waiting to be loaded\n     */\n    public getWaitingItemsCount(): number {\n        return this._pendingData.length;\n    }\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n    public get isLoading(): boolean {\n        return this._pendingData.length > 0;\n    }\n    /**\n     * Registers a function to be executed when the scene is ready\n     * @param {Function} func - the function to be executed\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     */\n    public executeWhenReady(func: () => void, checkRenderTargets = false): void {\n        this.onReadyObservable.add(func);\n        if (this._executeWhenReadyTimeoutId !== null) {\n            return;\n        }\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\n            this._checkIsReady(checkRenderTargets);\n        }, 150);\n    }\n    /**\n     * Returns a promise that resolves when the scene is ready\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     * @returns A promise that resolves when the scene is ready\n     */\n    public whenReadyAsync(checkRenderTargets = false): Promise<void> {\n        return new Promise((resolve) => {\n            this.executeWhenReady(() => {\n                resolve();\n            }, checkRenderTargets);\n        });\n    }\n    /**\n     * @param checkRenderTargets\n     * @hidden\n     */\n    public _checkIsReady(checkRenderTargets = false) {\n        this._registerTransientComponents();\n        if (this.isReady(checkRenderTargets)) {\n            this.onReadyObservable.notifyObservers(this);\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        if (this._isDisposed) {\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\n            this._checkIsReady(checkRenderTargets);\n        }, 100);\n    }\n    /**\n     * Gets all animatable attached to the scene\n     */\n    public get animatables(): Animatable[] {\n        return this._activeAnimatables;\n    }\n    /**\n     * Resets the last animation time frame.\n     * Useful to override when animations start running when loading a scene for the first time.\n     */\n    public resetLastAnimationTimeFrame(): void {\n        this._animationTimeLast = PrecisionDate.Now;\n    }\n    // Matrix\n    /**\n     * Gets the current view matrix\n     * @returns a Matrix\n     */\n    public getViewMatrix(): Matrix {\n        return this._viewMatrix;\n    }\n    /**\n     * Gets the current projection matrix\n     * @returns a Matrix\n     */\n    public getProjectionMatrix(): Matrix {\n        return this._projectionMatrix;\n    }\n    /**\n     * Gets the current transform matrix\n     * @returns a Matrix made of View * Projection\n     */\n    public getTransformMatrix(): Matrix {\n        return this._transformMatrix;\n    }\n    /**\n     * Sets the current transform matrix\n     * @param viewL defines the View matrix to use\n     * @param projectionL defines the Projection matrix to use\n     * @param viewR defines the right View matrix to use (if provided)\n     * @param projectionR defines the right Projection matrix to use (if provided)\n     */\n    public setTransformMatrix(viewL: Matrix, projectionL: Matrix, viewR?: Matrix, projectionR?: Matrix): void {\n        // clear the multiviewSceneUbo if no viewR and projectionR are defined\n        if (!viewR && !projectionR && this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n            this._multiviewSceneUbo = null;\n        }\n        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n            return;\n        }\n        this._viewUpdateFlag = viewL.updateFlag;\n        this._projectionUpdateFlag = projectionL.updateFlag;\n        this._viewMatrix = viewL;\n        this._projectionMatrix = projectionL;\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        // Update frustum\n        if (!this._frustumPlanes) {\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n        }\n        else {\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n        }\n        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n            this._updateMultiviewUbo(viewR, projectionR);\n        }\n        else if (this._sceneUbo.useUbo) {\n            this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n            this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n            this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n        }\n    }\n    /**\n     * Gets the uniform buffer used to store scene data\n     * @returns a UniformBuffer\n     */\n    public getSceneUniformBuffer(): UniformBuffer {\n        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n    }\n    /**\n     * Creates a scene UBO\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\n     * @returns a new ubo\n     */\n    public createSceneUniformBuffer(name?: string): UniformBuffer {\n        const sceneUbo = new UniformBuffer(this._engine, undefined, false, name ?? \"scene\");\n        sceneUbo.addUniform(\"viewProjection\", 16);\n        sceneUbo.addUniform(\"view\", 16);\n        sceneUbo.addUniform(\"projection\", 16);\n        sceneUbo.addUniform(\"vEyePosition\", 4);\n        return sceneUbo;\n    }\n    /**\n     * Sets the scene ubo\n     * @param ubo the ubo to set for the scene\n     */\n    public setSceneUniformBuffer(ubo: UniformBuffer): void {\n        this._sceneUbo = ubo;\n        this._viewUpdateFlag = -1;\n        this._projectionUpdateFlag = -1;\n    }\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     * @returns an unique number for the scene\n     */\n    public getUniqueId() {\n        return UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Add a mesh to the list of scene's meshes\n     * @param newMesh defines the mesh to add\n     * @param recursive if all child meshes should also be added to the scene\n     */\n    public addMesh(newMesh: AbstractMesh, recursive = false) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.meshes.push(newMesh);\n        newMesh._resyncLightSources();\n        if (!newMesh.parent) {\n            newMesh._addToSceneRootNodes();\n        }\n        this.onNewMeshAddedObservable.notifyObservers(newMesh);\n        if (recursive) {\n            newMesh.getChildMeshes().forEach((m) => {\n                this.addMesh(m);\n            });\n        }\n    }\n    /**\n     * Remove a mesh for the list of scene's meshes\n     * @param toRemove defines the mesh to remove\n     * @param recursive if all child meshes should also be removed from the scene\n     * @returns the index where the mesh was in the mesh list\n     */\n    public removeMesh(toRemove: AbstractMesh, recursive = false): number {\n        const index = this.meshes.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if mesh found\n            this.meshes[index] = this.meshes[this.meshes.length - 1];\n            this.meshes.pop();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this._inputManager._invalidateMesh(toRemove);\n        this.onMeshRemovedObservable.notifyObservers(toRemove);\n        if (recursive) {\n            toRemove.getChildMeshes().forEach((m) => {\n                this.removeMesh(m);\n            });\n        }\n        return index;\n    }\n    /**\n     * Add a transform node to the list of scene's transform nodes\n     * @param newTransformNode defines the transform node to add\n     */\n    public addTransformNode(newTransformNode: TransformNode) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n            // Already there?\n            return;\n        }\n        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n        this.transformNodes.push(newTransformNode);\n        if (!newTransformNode.parent) {\n            newTransformNode._addToSceneRootNodes();\n        }\n        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n    }\n    /**\n     * Remove a transform node for the list of scene's transform nodes\n     * @param toRemove defines the transform node to remove\n     * @returns the index where the transform node was in the transform node list\n     */\n    public removeTransformNode(toRemove: TransformNode): number {\n        const index = toRemove._indexInSceneTransformNodesArray;\n        if (index !== -1) {\n            if (index !== this.transformNodes.length - 1) {\n                const lastNode = this.transformNodes[this.transformNodes.length - 1];\n                this.transformNodes[index] = lastNode;\n                lastNode._indexInSceneTransformNodesArray = index;\n            }\n            toRemove._indexInSceneTransformNodesArray = -1;\n            this.transformNodes.pop();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a skeleton for the list of scene's skeletons\n     * @param toRemove defines the skeleton to remove\n     * @returns the index where the skeleton was in the skeleton list\n     */\n    public removeSkeleton(toRemove: Skeleton): number {\n        const index = this.skeletons.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.skeletons.splice(index, 1);\n            this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeSkeletons);\n        }\n        return index;\n    }\n    /**\n     * Remove a morph target for the list of scene's morph targets\n     * @param toRemove defines the morph target to remove\n     * @returns the index where the morph target was in the morph target list\n     */\n    public removeMorphTargetManager(toRemove: MorphTargetManager): number {\n        const index = this.morphTargetManagers.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.morphTargetManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Remove a light for the list of scene's lights\n     * @param toRemove defines the light to remove\n     * @returns the index where the light was in the light list\n     */\n    public removeLight(toRemove: Light): number {\n        const index = this.lights.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from meshes\n            for (const mesh of this.meshes) {\n                mesh._removeLightSource(toRemove, false);\n            }\n            // Remove from the scene if mesh found\n            this.lights.splice(index, 1);\n            this.sortLightsByPriority();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onLightRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a camera for the list of scene's cameras\n     * @param toRemove defines the camera to remove\n     * @returns the index where the camera was in the camera list\n     */\n    public removeCamera(toRemove: Camera): number {\n        const index = this.cameras.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if mesh found\n            this.cameras.splice(index, 1);\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        // Remove from activeCameras\n        if (this.activeCameras) {\n            const index2 = this.activeCameras.indexOf(toRemove);\n            if (index2 !== -1) {\n                // Remove from the scene if mesh found\n                this.activeCameras.splice(index2, 1);\n            }\n        }\n        // Reset the activeCamera\n        if (this.activeCamera === toRemove) {\n            if (this.cameras.length > 0) {\n                this.activeCamera = this.cameras[0];\n            }\n            else {\n                this.activeCamera = null;\n            }\n        }\n        this.onCameraRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a particle system for the list of scene's particle systems\n     * @param toRemove defines the particle system to remove\n     * @returns the index where the particle system was in the particle system list\n     */\n    public removeParticleSystem(toRemove: IParticleSystem): number {\n        const index = this.particleSystems.indexOf(toRemove);\n        if (index !== -1) {\n            this.particleSystems.splice(index, 1);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeParticleSystems);\n        }\n        return index;\n    }\n    /**\n     * Remove a animation for the list of scene's animations\n     * @param toRemove defines the animation to remove\n     * @returns the index where the animation was in the animation list\n     */\n    public removeAnimation(toRemove: Animation): number {\n        const index = this.animations.indexOf(toRemove);\n        if (index !== -1) {\n            this.animations.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Will stop the animation of the given target\n     * @param target - the target\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     */\n    public stopAnimation(target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\n        // Do nothing as code will be provided by animation component\n    }\n    /**\n     * Removes the given animation group from this scene.\n     * @param toRemove The animation group to remove\n     * @returns The index of the removed animation group\n     */\n    public removeAnimationGroup(toRemove: AnimationGroup): number {\n        const index = this.animationGroups.indexOf(toRemove);\n        if (index !== -1) {\n            this.animationGroups.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given multi-material from this scene.\n     * @param toRemove The multi-material to remove\n     * @returns The index of the removed multi-material\n     */\n    public removeMultiMaterial(toRemove: MultiMaterial): number {\n        const index = this.multiMaterials.indexOf(toRemove);\n        if (index !== -1) {\n            this.multiMaterials.splice(index, 1);\n        }\n        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given material from this scene.\n     * @param toRemove The material to remove\n     * @returns The index of the removed material\n     */\n    public removeMaterial(toRemove: Material): number {\n        const index = toRemove._indexInSceneMaterialArray;\n        if (index !== -1 && index < this.materials.length) {\n            if (index !== this.materials.length - 1) {\n                const lastMaterial = this.materials[this.materials.length - 1];\n                this.materials[index] = lastMaterial;\n                lastMaterial._indexInSceneMaterialArray = index;\n            }\n            toRemove._indexInSceneMaterialArray = -1;\n            this.materials.pop();\n        }\n        this.onMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given action manager from this scene.\n     * @param toRemove The action manager to remove\n     * @returns The index of the removed action manager\n     */\n    public removeActionManager(toRemove: AbstractActionManager): number {\n        const index = this.actionManagers.indexOf(toRemove);\n        if (index !== -1) {\n            this.actionManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given texture from this scene.\n     * @param toRemove The texture to remove\n     * @returns The index of the removed texture\n     */\n    public removeTexture(toRemove: BaseTexture): number {\n        const index = this.textures.indexOf(toRemove);\n        if (index !== -1) {\n            this.textures.splice(index, 1);\n        }\n        this.onTextureRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Adds the given light to this scene\n     * @param newLight The light to add\n     */\n    public addLight(newLight: Light): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.lights.push(newLight);\n        this.sortLightsByPriority();\n        if (!newLight.parent) {\n            newLight._addToSceneRootNodes();\n        }\n        // Add light to all meshes (To support if the light is removed and then re-added)\n        for (const mesh of this.meshes) {\n            if (mesh.lightSources.indexOf(newLight) === -1) {\n                mesh.lightSources.push(newLight);\n                mesh._resyncLightSources();\n            }\n        }\n        this.onNewLightAddedObservable.notifyObservers(newLight);\n    }\n    /**\n     * Sorts the list list based on light priorities\n     */\n    public sortLightsByPriority(): void {\n        if (this.requireLightSorting) {\n            this.lights.sort(LightConstants.CompareLightsPriority);\n        }\n    }\n    /**\n     * Adds the given camera to this scene\n     * @param newCamera The camera to add\n     */\n    public addCamera(newCamera: Camera): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.cameras.push(newCamera);\n        this.onNewCameraAddedObservable.notifyObservers(newCamera);\n        if (!newCamera.parent) {\n            newCamera._addToSceneRootNodes();\n        }\n    }\n    /**\n     * Adds the given skeleton to this scene\n     * @param newSkeleton The skeleton to add\n     */\n    public addSkeleton(newSkeleton: Skeleton): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.skeletons.push(newSkeleton);\n        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n    }\n    /**\n     * Adds the given particle system to this scene\n     * @param newParticleSystem The particle system to add\n     */\n    public addParticleSystem(newParticleSystem: IParticleSystem): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.particleSystems.push(newParticleSystem);\n    }\n    /**\n     * Adds the given animation to this scene\n     * @param newAnimation The animation to add\n     */\n    public addAnimation(newAnimation: Animation): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animations.push(newAnimation);\n    }\n    /**\n     * Adds the given animation group to this scene.\n     * @param newAnimationGroup The animation group to add\n     */\n    public addAnimationGroup(newAnimationGroup: AnimationGroup): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animationGroups.push(newAnimationGroup);\n    }\n    /**\n     * Adds the given multi-material to this scene\n     * @param newMultiMaterial The multi-material to add\n     */\n    public addMultiMaterial(newMultiMaterial: MultiMaterial): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.multiMaterials.push(newMultiMaterial);\n        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n    }\n    /**\n     * Adds the given material to this scene\n     * @param newMaterial The material to add\n     */\n    public addMaterial(newMaterial: Material): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n            // Already there??\n            return;\n        }\n        newMaterial._indexInSceneMaterialArray = this.materials.length;\n        this.materials.push(newMaterial);\n        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n    }\n    /**\n     * Adds the given morph target to this scene\n     * @param newMorphTargetManager The morph target to add\n     */\n    public addMorphTargetManager(newMorphTargetManager: MorphTargetManager): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.morphTargetManagers.push(newMorphTargetManager);\n    }\n    /**\n     * Adds the given geometry to this scene\n     * @param newGeometry The geometry to add\n     */\n    public addGeometry(newGeometry: Geometry): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n        }\n        this.geometries.push(newGeometry);\n    }\n    /**\n     * Adds the given action manager to this scene\n     * @param newActionManager The action manager to add\n     */\n    public addActionManager(newActionManager: AbstractActionManager): void {\n        this.actionManagers.push(newActionManager);\n    }\n    /**\n     * Adds the given texture to this scene.\n     * @param newTexture The texture to add\n     */\n    public addTexture(newTexture: BaseTexture): void {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.textures.push(newTexture);\n        this.onNewTextureAddedObservable.notifyObservers(newTexture);\n    }\n    /**\n     * Switch active camera\n     * @param newCamera defines the new active camera\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n     */\n    public switchActiveCamera(newCamera: Camera, attachControl = true): void {\n        const canvas = this._engine.getInputElement();\n        if (!canvas) {\n            return;\n        }\n        if (this.activeCamera) {\n            this.activeCamera.detachControl();\n        }\n        this.activeCamera = newCamera;\n        if (attachControl) {\n            newCamera.attachControl();\n        }\n    }\n    /**\n     * sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @return the new active camera or null if none found.\n     */\n    public setActiveCameraById(id: string): Nullable<Camera> {\n        const camera = this.getCameraById(id);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * sets the active camera of the scene using its name\n     * @param name defines the camera's name\n     * @returns the new active camera or null if none found.\n     */\n    public setActiveCameraByName(name: string): Nullable<Camera> {\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * get an animation group using its name\n     * @param name defines the material's name\n     * @return the animation group or null if none found.\n     */\n    public getAnimationGroupByName(name: string): Nullable<AnimationGroup> {\n        for (let index = 0; index < this.animationGroups.length; index++) {\n            if (this.animationGroups[index].name === name) {\n                return this.animationGroups[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a material using its unique id\n     * @param uniqueId defines the material's unique id\n     * @return the material or null if none found.\n     */\n    public getMaterialByUniqueID(uniqueId: number): Nullable<Material> {\n        for (let index = 0; index < this.materials.length; index++) {\n            if (this.materials[index].uniqueId === uniqueId) {\n                return this.materials[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * get a material using its id\n     * @param id defines the material's Id\n     * @return the material or null if none found.\n     */\n    public getMaterialById(id: string): Nullable<Material> {\n        for (let index = 0; index < this.materials.length; index++) {\n            if (this.materials[index].id === id) {\n                return this.materials[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added material using a given id\n     * @param id defines the material's Id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @return the last material with the given id or null if none found.\n     */\n    public getLastMaterialById(id: string, allowMultiMaterials: boolean = false): Nullable<Material> {\n        for (let index = this.materials.length - 1; index >= 0; index--) {\n            if (this.materials[index].id === id) {\n                return this.materials[index];\n            }\n        }\n        if (allowMultiMaterials) {\n            for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\n                if (this.multiMaterials[index].id === id) {\n                    return this.multiMaterials[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a material using its name\n     * @param name defines the material's name\n     * @return the material or null if none found.\n     */\n    public getMaterialByName(name: string): Nullable<Material> {\n        for (let index = 0; index < this.materials.length; index++) {\n            if (this.materials[index].name === name) {\n                return this.materials[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @return the texture or null if none found.\n     */\n    public getTextureByUniqueId(uniqueId: number): Nullable<BaseTexture> {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].uniqueId === uniqueId) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a texture using its name\n     * @param name defines the texture's name\n     * @return the texture or null if none found.\n     */\n    public getTextureByName(name: string): Nullable<BaseTexture> {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].name === name) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     */\n    public getCameraById(id: string): Nullable<Camera> {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     */\n    public getCameraByUniqueId(uniqueId: number): Nullable<Camera> {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].uniqueId === uniqueId) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its name\n     * @param name defines the camera's name\n     * @return the camera or null if none found.\n     */\n    public getCameraByName(name: string): Nullable<Camera> {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].name === name) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @return the bone or null if not found\n     */\n    public getBoneById(id: string): Nullable<Bone> {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].id === id) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its id\n     * @param name defines the bone's name\n     * @return the bone or null if not found\n     */\n    public getBoneByName(name: string): Nullable<Bone> {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].name === name) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its name\n     * @param name defines the the light's name\n     * @return the light or null if none found.\n     */\n    public getLightByName(name: string): Nullable<Light> {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].name === name) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @return the light or null if none found.\n     */\n    public getLightById(id: string): Nullable<Light> {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @return the light or null if none found.\n     */\n    public getLightByUniqueId(uniqueId: number): Nullable<Light> {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].uniqueId === uniqueId) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @return the corresponding system or null if none found\n     */\n    public getParticleSystemById(id: string): Nullable<IParticleSystem> {\n        for (let index = 0; index < this.particleSystems.length; index++) {\n            if (this.particleSystems[index].id === id) {\n                return this.particleSystems[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @return the geometry or null if none found.\n     */\n    public getGeometryById(id: string): Nullable<Geometry> {\n        for (let index = 0; index < this.geometries.length; index++) {\n            if (this.geometries[index].id === id) {\n                return this.geometries[index];\n            }\n        }\n        return null;\n    }\n    private _getGeometryByUniqueId(uniqueId: number): Nullable<Geometry> {\n        if (this._geometriesByUniqueId) {\n            const index = this._geometriesByUniqueId[uniqueId];\n            if (index !== undefined) {\n                return this.geometries[index];\n            }\n        }\n        else {\n            for (let index = 0; index < this.geometries.length; index++) {\n                if (this.geometries[index].uniqueId === uniqueId) {\n                    return this.geometries[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Add a new geometry to this scene\n     * @param geometry defines the geometry to be added to the scene.\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n     * @return a boolean defining if the geometry was added or not\n     */\n    public pushGeometry(geometry: Geometry, force?: boolean): boolean {\n        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n            return false;\n        }\n        this.addGeometry(geometry);\n        this.onNewGeometryAddedObservable.notifyObservers(geometry);\n        return true;\n    }\n    /**\n     * Removes an existing geometry\n     * @param geometry defines the geometry to be removed from the scene\n     * @return a boolean defining if the geometry was removed or not\n     */\n    public removeGeometry(geometry: Geometry): boolean {\n        let index;\n        if (this._geometriesByUniqueId) {\n            index = this._geometriesByUniqueId[geometry.uniqueId];\n            if (index === undefined) {\n                return false;\n            }\n        }\n        else {\n            index = this.geometries.indexOf(geometry);\n            if (index < 0) {\n                return false;\n            }\n        }\n        if (index !== this.geometries.length - 1) {\n            const lastGeometry = this.geometries[this.geometries.length - 1];\n            if (lastGeometry) {\n                this.geometries[index] = lastGeometry;\n                if (this._geometriesByUniqueId) {\n                    this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n                    this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n                }\n            }\n        }\n        this.geometries.pop();\n        this.onGeometryRemovedObservable.notifyObservers(geometry);\n        return true;\n    }\n    /**\n     * Gets the list of geometries attached to the scene\n     * @returns an array of Geometry\n     */\n    public getGeometries(): Geometry[] {\n        return this.geometries;\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @return the mesh found or null if not found at all\n     */\n    public getMeshById(id: string): Nullable<AbstractMesh> {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     */\n    public getMeshesById(id: string): Array<AbstractMesh> {\n        return this.meshes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @return the found transform node or null if not found at all.\n     */\n    public getTransformNodeById(id: string): Nullable<TransformNode> {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @return the found transform node or null if not found at all.\n     */\n    public getTransformNodeByUniqueId(uniqueId: number): Nullable<TransformNode> {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].uniqueId === uniqueId) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     */\n    public getTransformNodesById(id: string): Array<TransformNode> {\n        return this.transformNodes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @return the found mesh or null if not found at all.\n     */\n    public getMeshByUniqueId(uniqueId: number): Nullable<AbstractMesh> {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].uniqueId === uniqueId) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @return the found mesh or null if not found at all.\n     */\n    public getLastMeshById(id: string): Nullable<AbstractMesh> {\n        for (let index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @return the found node or null if not found at all\n     */\n    public getLastEntryById(id: string): Nullable<Node> {\n        let index: number;\n        for (index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        for (index = this.transformNodes.length - 1; index >= 0; index--) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        for (index = this.cameras.length - 1; index >= 0; index--) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        for (index = this.lights.length - 1; index >= 0; index--) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @return the found node or null if not found at all\n     */\n    public getNodeById(id: string): Nullable<Node> {\n        const mesh = this.getMeshById(id);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeById(id);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightById(id);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraById(id);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneById(id);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given name\n     * @param name defines the name to search for\n     * @return the found node or null if not found at all.\n     */\n    public getNodeByName(name: string): Nullable<Node> {\n        const mesh = this.getMeshByName(name);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeByName(name);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightByName(name);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneByName(name);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a mesh using a given name\n     * @param name defines the name to search for\n     * @return the found mesh or null if not found at all.\n     */\n    public getMeshByName(name: string): Nullable<AbstractMesh> {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].name === name) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node using a given name\n     * @param name defines the name to search for\n     * @return the found transform node or null if not found at all.\n     */\n    public getTransformNodeByName(name: string): Nullable<TransformNode> {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].name === name) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @return the found skeleton or null if not found at all.\n     */\n    public getLastSkeletonById(id: string): Nullable<Skeleton> {\n        for (let index = this.skeletons.length - 1; index >= 0; index--) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given auto generated unique id\n     * @param  uniqueId defines the unique id to search for\n     * @return the found skeleton or null if not found at all.\n     */\n    public getSkeletonByUniqueId(uniqueId: number): Nullable<Skeleton> {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].uniqueId === uniqueId) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @return the found skeleton or null if not found at all.\n     */\n    public getSkeletonById(id: string): Nullable<Skeleton> {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given name\n     * @param name defines the name to search for\n     * @return the found skeleton or null if not found at all.\n     */\n    public getSkeletonByName(name: string): Nullable<Skeleton> {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].name === name) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n     * @param id defines the id to search for\n     * @return the found morph target manager or null if not found at all.\n     */\n    public getMorphTargetManagerById(id: number): Nullable<MorphTargetManager> {\n        for (let index = 0; index < this.morphTargetManagers.length; index++) {\n            if (this.morphTargetManagers[index].uniqueId === id) {\n                return this.morphTargetManagers[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @return the found morph target or null if not found at all.\n     */\n    public getMorphTargetById(id: string): Nullable<MorphTarget> {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.id === id) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @return the found morph target or null if not found at all.\n     */\n    public getMorphTargetByName(name: string): Nullable<MorphTarget> {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.name === name) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @return the found post process or null if not found at all.\n     */\n    public getPostProcessByName(name: string): Nullable<PostProcess> {\n        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n            const postProcess = this.postProcesses[postProcessIndex];\n            if (postProcess.name === name) {\n                return postProcess;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a boolean indicating if the given mesh is active\n     * @param mesh defines the mesh to look for\n     * @returns true if the mesh is in the active list\n     */\n    public isActiveMesh(mesh: AbstractMesh): boolean {\n        return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n    public get uid(): string {\n        if (!this._uid) {\n            this._uid = Tools.RandomId();\n        }\n        return this._uid;\n    }\n    /**\n     * Add an externally attached data from its key.\n     * This method call will fail and return false, if such key already exists.\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n     * @param key the unique key that identifies the data\n     * @param data the data object to associate to the key for this Engine instance\n     * @return true if no such key were already present and the data was added successfully, false otherwise\n     */\n    public addExternalData<T>(key: string, data: T): boolean {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary<Object>();\n        }\n        return this._externalData.add(key, data);\n    }\n    /**\n     * Get an externally attached data from its key\n     * @param key the unique key that identifies the data\n     * @return the associated data, if present (can be null), or undefined if not present\n     */\n    public getExternalData<T>(key: string): Nullable<T> {\n        if (!this._externalData) {\n            return null;\n        }\n        return <T>this._externalData.get(key);\n    }\n    /**\n     * Get an externally attached data from its key, create it using a factory if it's not already present\n     * @param key the unique key that identifies the data\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n     * @return the associated data, can be null if the factory returned null.\n     */\n    public getOrAddExternalDataWithFactory<T>(key: string, factory: (k: string) => T): T {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary<Object>();\n        }\n        return <T>this._externalData.getOrAddWithFactory(key, factory);\n    }\n    /**\n     * Remove an externally attached data from the Engine instance\n     * @param key the unique key that identifies the data\n     * @return true if the data was successfully removed, false if it doesn't exist\n     */\n    public removeExternalData(key: string): boolean {\n        return this._externalData.remove(key);\n    }\n    private _evaluateSubMesh(subMesh: SubMesh, mesh: AbstractMesh, initialMesh: AbstractMesh): void {\n        if (initialMesh.hasInstances ||\n            initialMesh.isAnInstance ||\n            this.dispatchAllSubMeshesOfActiveMeshes ||\n            this._skipFrustumClipping ||\n            mesh.alwaysSelectAsActiveMesh ||\n            mesh.subMeshes.length === 1 ||\n            subMesh.isInFrustum(this._frustumPlanes)) {\n            for (const step of this._evaluateSubMeshStage) {\n                step.action(mesh, subMesh);\n            }\n            const material = subMesh.getMaterial();\n            if (material !== null && material !== undefined) {\n                // Render targets\n                if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                    if (this._processedMaterials.indexOf(material) === -1) {\n                        this._processedMaterials.push(material);\n                        this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures!());\n                    }\n                }\n                // Dispatch\n                this._renderingManager.dispatch(subMesh, mesh, material);\n            }\n        }\n    }\n    /**\n     * Clear the processed materials smart array preventing retention point in material dispose.\n     */\n    public freeProcessedMaterials(): void {\n        this._processedMaterials.dispose();\n    }\n    private _preventFreeActiveMeshesAndRenderingGroups = false;\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n    public get blockfreeActiveMeshesAndRenderingGroups(): boolean {\n        return this._preventFreeActiveMeshesAndRenderingGroups;\n    }\n    public set blockfreeActiveMeshesAndRenderingGroups(value: boolean) {\n        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n            return;\n        }\n        if (value) {\n            this.freeActiveMeshes();\n            this.freeRenderingGroups();\n        }\n        this._preventFreeActiveMeshesAndRenderingGroups = value;\n    }\n    /**\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\n     */\n    public freeActiveMeshes(): void {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        this._activeMeshes.dispose();\n        if (this.activeCamera && this.activeCamera._activeMeshes) {\n            this.activeCamera._activeMeshes.dispose();\n        }\n        if (this.activeCameras) {\n            for (let i = 0; i < this.activeCameras.length; i++) {\n                const activeCamera = this.activeCameras[i];\n                if (activeCamera && activeCamera._activeMeshes) {\n                    activeCamera._activeMeshes.dispose();\n                }\n            }\n        }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n    public freeRenderingGroups(): void {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        if (this._renderingManager) {\n            this._renderingManager.freeRenderingGroups();\n        }\n        if (this.textures) {\n            for (let i = 0; i < this.textures.length; i++) {\n                const texture = this.textures[i];\n                if (texture && (<RenderTargetTexture>texture).renderList) {\n                    (<RenderTargetTexture>texture).freeRenderingGroups();\n                }\n            }\n        }\n    }\n    /** @hidden */\n    public _isInIntermediateRendering(): boolean {\n        return this._intermediateRendering;\n    }\n    /**\n     * Lambda returning the list of potentially active meshes.\n     */\n    public getActiveMeshCandidates: () => ISmartArrayLike<AbstractMesh>;\n    /**\n     * Lambda returning the list of potentially active sub meshes.\n     */\n    public getActiveSubMeshCandidates: (mesh: AbstractMesh) => ISmartArrayLike<SubMesh>;\n    /**\n     * Lambda returning the list of potentially intersecting sub meshes.\n     */\n    public getIntersectingSubMeshCandidates: (mesh: AbstractMesh, localRay: Ray) => ISmartArrayLike<SubMesh>;\n    /**\n     * Lambda returning the list of potentially colliding sub meshes.\n     */\n    public getCollidingSubMeshCandidates: (mesh: AbstractMesh, collider: Collider) => ISmartArrayLike<SubMesh>;\n    /** @hidden */\n    public _activeMeshesFrozen = false;\n    private _skipEvaluateActiveMeshesCompletely = false;\n    /**\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n     * @param onSuccess optional success callback\n     * @param onError optional error callback\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\n     * @returns the current scene\n     */\n    public freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess?: () => void, onError?: (message: string) => void, freezeMeshes = true): Scene {\n        this.executeWhenReady(() => {\n            if (!this.activeCamera) {\n                onError && onError(\"No active camera found\");\n                return;\n            }\n            if (!this._frustumPlanes) {\n                this.updateTransformMatrix();\n            }\n            this._evaluateActiveMeshes();\n            this._activeMeshesFrozen = true;\n            this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n            if (freezeMeshes) {\n                for (let index = 0; index < this._activeMeshes.length; index++) {\n                    this._activeMeshes.data[index]._freeze();\n                }\n            }\n            onSuccess && onSuccess();\n        });\n        return this;\n    }\n    /**\n     * Use this function to restart evaluating active meshes on every frame\n     * @returns the current scene\n     */\n    public unfreezeActiveMeshes(): Scene {\n        for (let index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (mesh._internalAbstractMeshDataInfo) {\n                mesh._internalAbstractMeshDataInfo._isActive = false;\n            }\n        }\n        for (let index = 0; index < this._activeMeshes.length; index++) {\n            this._activeMeshes.data[index]._unFreeze();\n        }\n        this._activeMeshesFrozen = false;\n        return this;\n    }\n    private _executeActiveContainerCleanup(container: SmartArray<any>) {\n        const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST;\n        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n            return; // Do not execute in frozen mode\n        }\n        // We need to ensure we are not in the rendering loop\n        this.onBeforeRenderObservable.addOnce(() => container.dispose());\n    }\n    private _evaluateActiveMeshes(): void {\n        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\n            if (this._activeMeshes.length > 0) {\n                this.activeCamera?._activeMeshes.reset();\n                this._activeMeshes.reset();\n                this._renderingManager.reset();\n                this._processedMaterials.reset();\n                this._activeParticleSystems.reset();\n                this._activeSkeletons.reset();\n                this._softwareSkinnedMeshes.reset();\n            }\n            return;\n        }\n        if (this._activeMeshesFrozen && this._activeMeshes.length) {\n            if (!this._skipEvaluateActiveMeshesCompletely) {\n                const len = this._activeMeshes.length;\n                for (let i = 0; i < len; i++) {\n                    const mesh = this._activeMeshes.data[i];\n                    mesh.computeWorldMatrix();\n                }\n            }\n            if (this._activeParticleSystems) {\n                const psLength = this._activeParticleSystems.length;\n                for (let i = 0; i < psLength; i++) {\n                    this._activeParticleSystems.data[i].animate();\n                }\n            }\n            return;\n        }\n        if (!this.activeCamera) {\n            return;\n        }\n        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n        this.activeCamera._activeMeshes.reset();\n        this._activeMeshes.reset();\n        this._renderingManager.reset();\n        this._processedMaterials.reset();\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        this._softwareSkinnedMeshes.reset();\n        this._materialsRenderTargets.reset();\n        for (const step of this._beforeEvaluateActiveMeshStage) {\n            step.action();\n        }\n        // Determine mesh candidates\n        const meshes = this.getActiveMeshCandidates();\n        // Check each mesh\n        const len = meshes.length;\n        for (let i = 0; i < len; i++) {\n            const mesh = meshes.data[i];\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n            if (mesh.isBlocked) {\n                continue;\n            }\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {\n                continue;\n            }\n            mesh.computeWorldMatrix();\n            // Intersections\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(Constants.ACTION_OnIntersectionEnterTrigger, Constants.ACTION_OnIntersectionExitTrigger)) {\n                this._meshesForIntersections.pushNoDuplicate(mesh);\n            }\n            // Switch to current LOD\n            let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n            mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n            if (meshToRender === undefined || meshToRender === null) {\n                continue;\n            }\n            // Compute world matrix if LOD is billboard\n            if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n                meshToRender.computeWorldMatrix();\n            }\n            mesh._preActivate();\n            if (mesh.isVisible &&\n                mesh.visibility > 0 &&\n                (mesh.layerMask & this.activeCamera.layerMask) !== 0 &&\n                (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n                this._activeMeshes.push(mesh);\n                this.activeCamera._activeMeshes.push(mesh);\n                if (meshToRender !== mesh) {\n                    meshToRender._activate(this._renderId, false);\n                }\n                for (const step of this._preActiveMeshStage) {\n                    step.action(mesh);\n                }\n                if (mesh._activate(this._renderId, false)) {\n                    if (!mesh.isAnInstance) {\n                        meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n                    }\n                    else {\n                        if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                            meshToRender = mesh;\n                        }\n                    }\n                    meshToRender._internalAbstractMeshDataInfo._isActive = true;\n                    this._activeMesh(mesh, meshToRender);\n                }\n                mesh._postActivate();\n            }\n        }\n        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n        // Particle systems\n        if (this.particlesEnabled) {\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n            for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n                const particleSystem = this.particleSystems[particleIndex];\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\n                    continue;\n                }\n                const emitter = <any>particleSystem.emitter;\n                if (!emitter.position || emitter.isEnabled()) {\n                    this._activeParticleSystems.push(particleSystem);\n                    particleSystem.animate();\n                    this._renderingManager.dispatchParticles(particleSystem);\n                }\n            }\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\n        }\n    }\n    private _activeMesh(sourceMesh: AbstractMesh, mesh: AbstractMesh): void {\n        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n            if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n                mesh.skeleton.prepare();\n                this._activeBones.addCount(mesh.skeleton.bones.length, false);\n            }\n            if (!mesh.computeBonesUsingShaders) {\n                this._softwareSkinnedMeshes.pushNoDuplicate(<Mesh>mesh);\n            }\n        }\n        if (mesh !== undefined && mesh !== null && mesh.subMeshes !== undefined && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {\n            const subMeshes = this.getActiveSubMeshCandidates(mesh);\n            const len = subMeshes.length;\n            for (let i = 0; i < len; i++) {\n                const subMesh = subMeshes.data[i];\n                this._evaluateSubMesh(subMesh, mesh, sourceMesh);\n            }\n        }\n    }\n    /**\n     * Update the transform matrix to update from the current active camera\n     * @param force defines a boolean used to force the update even if cache is up to date\n     */\n    public updateTransformMatrix(force?: boolean): void {\n        if (!this.activeCamera) {\n            return;\n        }\n        if (this.activeCamera._renderingMultiview) {\n            const leftCamera = this.activeCamera._rigCameras[0];\n            const rightCamera = this.activeCamera._rigCameras[1];\n            this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n        }\n        else {\n            this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n        }\n    }\n    private _bindFrameBuffer(camera: Nullable<Camera>, clear = true) {\n        if (camera && camera._multiviewTexture) {\n            camera._multiviewTexture._bindFrameBuffer();\n        }\n        else if (camera && camera.outputRenderTarget) {\n            camera.outputRenderTarget._bindFrameBuffer();\n        }\n        else {\n            if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n                this._engine.restoreDefaultFramebuffer();\n            }\n        }\n        if (clear) {\n            this._clearFrameBuffer(camera);\n        }\n    }\n    private _clearFrameBuffer(camera: Nullable<Camera>) {\n        // we assume the framebuffer currently bound is the right one\n        if (camera && camera._multiviewTexture) {\n            // no clearing?\n        }\n        else if (camera && camera.outputRenderTarget) {\n            const rtt = camera.outputRenderTarget;\n            if (rtt.onClearObservable.hasObservers()) {\n                rtt.onClearObservable.notifyObservers(this._engine);\n            }\n            else if (!rtt.skipInitialClear) {\n                this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n                rtt._cleared = true;\n            }\n        }\n        else {\n            if (!this._defaultFrameBufferCleared) {\n                this._defaultFrameBufferCleared = true;\n                this._clear();\n            }\n            else {\n                this._engine.clear(null, false, true, true);\n            }\n        }\n    }\n    /** @hidden */\n    public _allowPostProcessClearColor = true;\n    /**\n     * @param camera\n     * @param rigParent\n     * @param bindFrameBuffer\n     * @hidden\n     */\n    public _renderForCamera(camera: Camera, rigParent?: Camera, bindFrameBuffer = true): void {\n        if (camera && camera._skipRendering) {\n            return;\n        }\n        const engine = this._engine;\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n        }\n        // Viewport\n        engine.setViewport(this.activeCamera.viewport);\n        // Camera\n        this.resetCachedMaterial();\n        this._renderId++;\n        if (!this.prePass && bindFrameBuffer) {\n            let skipInitialClear = true;\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n                if (this.autoClear) {\n                    camera.outputRenderTarget.skipInitialClear = false;\n                }\n            }\n            this._bindFrameBuffer(this._activeCamera);\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n            }\n        }\n        this.updateTransformMatrix();\n        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n        // Meshes\n        this._evaluateActiveMeshes();\n        // Software skinning\n        for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n            const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n            mesh.applySkeleton(<Skeleton>mesh.skeleton);\n        }\n        // Render targets\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n        }\n        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n        }\n        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n            this._renderTargets.pushNoDuplicate(this.environmentTexture as RenderTargetTexture);\n        }\n        // Collects render targets from external components.\n        for (const step of this._gatherActiveCameraRenderTargetsStage) {\n            step.action(this._renderTargets);\n        }\n        let needRebind = false;\n        if (this.renderTargetsEnabled) {\n            this._intermediateRendering = true;\n            if (this._renderTargets.length > 0) {\n                Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n                    const renderTarget = this._renderTargets.data[renderIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n                        renderTarget.render(<boolean>hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n                        needRebind = true;\n                    }\n                }\n                Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                this._renderId++;\n            }\n            for (const step of this._cameraDrawRenderTargetStage) {\n                needRebind = step.action(this.activeCamera) || needRebind;\n            }\n            this._intermediateRendering = false;\n        }\n        this._engine.currentRenderPassId = camera.outputRenderTarget?.renderPassId ?? camera.renderPassId ?? Constants.RENDERPASS_MAIN;\n        // Restore framebuffer after rendering to targets\n        if (needRebind && !this.prePass) {\n            this._bindFrameBuffer(this._activeCamera, false);\n        }\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n        // Prepare Frame\n        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n            this.postProcessManager._prepareFrame();\n        }\n        // Before Camera Draw\n        for (const step of this._beforeCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Render\n        this.onBeforeDrawPhaseObservable.notifyObservers(this);\n        if (engine.snapshotRendering && engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\n            this.finalizeSceneUbo();\n        }\n        this._renderingManager.render(null, null, true, true);\n        this.onAfterDrawPhaseObservable.notifyObservers(this);\n        // After Camera Draw\n        for (const step of this._afterCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Finalize frame\n        if (this.postProcessManager && !camera._multiviewTexture) {\n            // if the camera has an output render target, render the post process to the render target\n            const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget! : undefined;\n            this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n        }\n        // Reset some special arrays\n        this._renderTargets.reset();\n        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n    }\n    private _processSubCameras(camera: Camera, bindFrameBuffer = true): void {\n        if (camera.cameraRigMode === Constants.RIG_MODE_NONE || camera._renderingMultiview) {\n            if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n                this._createMultiviewUbo();\n            }\n            this._renderForCamera(camera, undefined, bindFrameBuffer);\n            this.onAfterRenderCameraObservable.notifyObservers(camera);\n            return;\n        }\n        if (camera._useMultiviewToSingleView) {\n            this._renderMultiviewToSingleView(camera);\n        }\n        else {\n            // rig cameras\n            this.onBeforeCameraRenderObservable.notifyObservers(camera);\n            for (let index = 0; index < camera._rigCameras.length; index++) {\n                this._renderForCamera(camera._rigCameras[index], camera);\n            }\n        }\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        this.updateTransformMatrix();\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\n    }\n    private _checkIntersections(): void {\n        for (let index = 0; index < this._meshesForIntersections.length; index++) {\n            const sourceMesh = this._meshesForIntersections.data[index];\n            if (!sourceMesh.actionManager) {\n                continue;\n            }\n            for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n                const action: IAction = sourceMesh.actionManager.actions[actionIndex];\n                if (action.trigger === Constants.ACTION_OnIntersectionEnterTrigger || action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\n                    const parameters = action.getTriggerParameter();\n                    const otherMesh = parameters.mesh ? parameters.mesh : parameters;\n                    const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n                    const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n                    if (areIntersecting && currentIntersectionInProgress === -1) {\n                        if (action.trigger === Constants.ACTION_OnIntersectionEnterTrigger) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                        else if (action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                    }\n                    else if (!areIntersecting && currentIntersectionInProgress > -1) {\n                        //They intersected, and now they don't.\n                        //is this trigger an exit trigger? execute an event.\n                        if (action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                        }\n                        //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n                        if (!sourceMesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnIntersectionExitTrigger, (parameter) => {\n                            const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n                            return otherMesh === parameterMesh;\n                        }) ||\n                            action.trigger === Constants.ACTION_OnIntersectionExitTrigger) {\n                            sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param step\n     * @hidden\n     */\n    public _advancePhysicsEngineStep(step: number) {\n        // Do nothing. Code will be replaced if physics engine component is referenced\n    }\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n    public getDeterministicFrameTime: () => number = () => {\n        return this._engine.getTimeStep();\n    };\n    /** @hidden */\n    public _animate(): void {\n        // Nothing to do as long as Animatable have not been imported.\n    }\n    /** Execute all animations (for a frame) */\n    public animate() {\n        if (this._engine.isDeterministicLockStep()) {\n            let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n            const defaultFrameTime = this._engine.getTimeStep();\n            const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n            let stepsTaken = 0;\n            const maxSubSteps = this._engine.getLockstepMaxSteps();\n            let internalSteps = Math.floor(deltaTime / defaultFrameTime);\n            internalSteps = Math.min(internalSteps, maxSubSteps);\n            while (deltaTime > 0 && stepsTaken < internalSteps) {\n                this.onBeforeStepObservable.notifyObservers(this);\n                // Animations\n                this._animationRatio = defaultFrameTime * defaultFPS;\n                this._animate();\n                this.onAfterAnimationsObservable.notifyObservers(this);\n                // Physics\n                if (this.physicsEnabled) {\n                    this._advancePhysicsEngineStep(defaultFrameTime);\n                }\n                this.onAfterStepObservable.notifyObservers(this);\n                this._currentStepId++;\n                stepsTaken++;\n                deltaTime -= defaultFrameTime;\n            }\n            this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n        }\n        else {\n            // Animations\n            const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\n            this._animate();\n            this.onAfterAnimationsObservable.notifyObservers(this);\n            // Physics\n            if (this.physicsEnabled) {\n                this._advancePhysicsEngineStep(deltaTime);\n            }\n        }\n    }\n    private _clear(): void {\n        if (this.autoClearDepthAndStencil || this.autoClear) {\n            this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n        }\n    }\n    private _checkCameraRenderTarget(camera: Nullable<Camera>) {\n        if (camera?.outputRenderTarget && !camera?.isRigCamera) {\n            camera.outputRenderTarget._cleared = false;\n        }\n        if (camera?.rigCameras?.length) {\n            for (let i = 0; i < camera.rigCameras.length; ++i) {\n                const rtt = camera.rigCameras[i].outputRenderTarget;\n                if (rtt) {\n                    rtt._cleared = false;\n                }\n            }\n        }\n    }\n    /**\n     * Resets the draw wrappers cache of all meshes\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    public resetDrawCache(passId?: number): void {\n        if (!this.meshes) {\n            return;\n        }\n        for (const mesh of this.meshes) {\n            mesh.resetDrawCache(passId);\n        }\n    }\n    /**\n     * Render the scene\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n     */\n    public render(updateCameras = true, ignoreAnimations = false): void {\n        if (this.isDisposed) {\n            return;\n        }\n        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n            this._checkIsReady();\n        }\n        this._frameId++;\n        this._defaultFrameBufferCleared = false;\n        this._checkCameraRenderTarget(this.activeCamera);\n        if (this.activeCameras?.length) {\n            this.activeCameras.forEach(this._checkCameraRenderTarget);\n        }\n        // Register components that have been associated lately to the scene.\n        this._registerTransientComponents();\n        this._activeParticles.fetchNewFrame();\n        this._totalVertices.fetchNewFrame();\n        this._activeIndices.fetchNewFrame();\n        this._activeBones.fetchNewFrame();\n        this._meshesForIntersections.reset();\n        this.resetCachedMaterial();\n        this.onBeforeAnimationsObservable.notifyObservers(this);\n        // Actions\n        if (this.actionManager) {\n            this.actionManager.processTrigger(Constants.ACTION_OnEveryFrameTrigger);\n        }\n        // Animations\n        if (!ignoreAnimations) {\n            this.animate();\n        }\n        // Before camera update steps\n        for (const step of this._beforeCameraUpdateStage) {\n            step.action();\n        }\n        // Update Cameras\n        if (updateCameras) {\n            if (this.activeCameras && this.activeCameras.length > 0) {\n                for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                    const camera = this.activeCameras[cameraIndex];\n                    camera.update();\n                    if (camera.cameraRigMode !== Constants.RIG_MODE_NONE) {\n                        // rig cameras\n                        for (let index = 0; index < camera._rigCameras.length; index++) {\n                            camera._rigCameras[index].update();\n                        }\n                    }\n                }\n            }\n            else if (this.activeCamera) {\n                this.activeCamera.update();\n                if (this.activeCamera.cameraRigMode !== Constants.RIG_MODE_NONE) {\n                    // rig cameras\n                    for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\n                        this.activeCamera._rigCameras[index].update();\n                    }\n                }\n            }\n        }\n        // Before render\n        this.onBeforeRenderObservable.notifyObservers(this);\n        const engine = this.getEngine();\n        // Customs render targets\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n        const currentActiveCamera = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;\n        if (this.renderTargetsEnabled) {\n            Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n            this._intermediateRendering = true;\n            for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n                const renderTarget = this.customRenderTargets[customIndex];\n                if (renderTarget._shouldRender()) {\n                    this._renderId++;\n                    this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n                    if (!this.activeCamera) {\n                        throw new Error(\"Active camera not set\");\n                    }\n                    // Viewport\n                    engine.setViewport(this.activeCamera.viewport);\n                    // Camera\n                    this.updateTransformMatrix();\n                    renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n                }\n            }\n            Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n            this._intermediateRendering = false;\n            this._renderId++;\n        }\n        this._engine.currentRenderPassId = currentActiveCamera?.renderPassId ?? Constants.RENDERPASS_MAIN;\n        // Restore back buffer\n        this.activeCamera = currentActiveCamera;\n        if (this._activeCamera && this._activeCamera.cameraRigMode !== Constants.RIG_MODE_CUSTOM && !this.prePass) {\n            this._bindFrameBuffer(this._activeCamera, false);\n        }\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n        for (const step of this._beforeClearStage) {\n            step.action();\n        }\n        // Clear\n        this._clearFrameBuffer(this.activeCamera);\n        // Collects render targets from external components.\n        for (const step of this._gatherRenderTargetsStage) {\n            step.action(this._renderTargets);\n        }\n        // Multi-cameras?\n        if (this.activeCameras && this.activeCameras.length > 0) {\n            for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n            }\n        }\n        else {\n            if (!this.activeCamera) {\n                throw new Error(\"No camera defined\");\n            }\n            this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n        }\n        // Intersection checks\n        this._checkIntersections();\n        // Executes the after render stage actions.\n        for (const step of this._afterRenderStage) {\n            step.action();\n        }\n        // After render\n        if (this.afterRender) {\n            this.afterRender();\n        }\n        this.onAfterRenderObservable.notifyObservers(this);\n        // Cleaning\n        if (this._toBeDisposed.length) {\n            for (let index = 0; index < this._toBeDisposed.length; index++) {\n                const data = this._toBeDisposed[index];\n                if (data) {\n                    data.dispose();\n                }\n            }\n            this._toBeDisposed = [];\n        }\n        if (this.dumpNextRenderTargets) {\n            this.dumpNextRenderTargets = false;\n        }\n        this._activeBones.addCount(0, true);\n        this._activeIndices.addCount(0, true);\n        this._activeParticles.addCount(0, true);\n        this._engine.restoreDefaultFramebuffer();\n    }\n    /**\n     * Freeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n    public freezeMaterials(): void {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].freeze();\n        }\n    }\n    /**\n     * Unfreeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n    public unfreezeMaterials(): void {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].unfreeze();\n        }\n    }\n    /**\n     * Releases all held resources\n     */\n    public dispose(): void {\n        if (this.isDisposed) {\n            return;\n        }\n        this.beforeRender = null;\n        this.afterRender = null;\n        this.metadata = null;\n        this.skeletons = [];\n        this.morphTargetManagers = [];\n        this._transientComponents = [];\n        this._isReadyForMeshStage.clear();\n        this._beforeEvaluateActiveMeshStage.clear();\n        this._evaluateSubMeshStage.clear();\n        this._preActiveMeshStage.clear();\n        this._cameraDrawRenderTargetStage.clear();\n        this._beforeCameraDrawStage.clear();\n        this._beforeRenderTargetDrawStage.clear();\n        this._beforeRenderingGroupDrawStage.clear();\n        this._beforeRenderingMeshStage.clear();\n        this._afterRenderingMeshStage.clear();\n        this._afterRenderingGroupDrawStage.clear();\n        this._afterCameraDrawStage.clear();\n        this._afterRenderTargetDrawStage.clear();\n        this._afterRenderStage.clear();\n        this._beforeCameraUpdateStage.clear();\n        this._beforeClearStage.clear();\n        this._gatherRenderTargetsStage.clear();\n        this._gatherActiveCameraRenderTargetsStage.clear();\n        this._pointerMoveStage.clear();\n        this._pointerDownStage.clear();\n        this._pointerUpStage.clear();\n        this.importedMeshesFiles = new Array<string>();\n        if (this.stopAllAnimations) {\n            this.stopAllAnimations();\n        }\n        this.resetCachedMaterial();\n        // Smart arrays\n        if (this.activeCamera) {\n            this.activeCamera._activeMeshes.dispose();\n            this.activeCamera = null;\n        }\n        this._activeMeshes.dispose();\n        this._renderingManager.dispose();\n        this._processedMaterials.dispose();\n        this._activeParticleSystems.dispose();\n        this._activeSkeletons.dispose();\n        this._softwareSkinnedMeshes.dispose();\n        this._renderTargets.dispose();\n        this._materialsRenderTargets.dispose();\n        this._registeredForLateAnimationBindings.dispose();\n        this._meshesForIntersections.dispose();\n        this._toBeDisposed = [];\n        // Abort active requests\n        const activeRequests = this._activeRequests.slice();\n        for (const request of activeRequests) {\n            request.abort();\n        }\n        this._activeRequests = [];\n        // Events\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onBeforeRenderTargetsRenderObservable.clear();\n        this.onAfterRenderTargetsRenderObservable.clear();\n        this.onAfterStepObservable.clear();\n        this.onBeforeStepObservable.clear();\n        this.onBeforeActiveMeshesEvaluationObservable.clear();\n        this.onAfterActiveMeshesEvaluationObservable.clear();\n        this.onBeforeParticlesRenderingObservable.clear();\n        this.onAfterParticlesRenderingObservable.clear();\n        this.onBeforeDrawPhaseObservable.clear();\n        this.onAfterDrawPhaseObservable.clear();\n        this.onBeforeAnimationsObservable.clear();\n        this.onAfterAnimationsObservable.clear();\n        this.onDataLoadedObservable.clear();\n        this.onBeforeRenderingGroupObservable.clear();\n        this.onAfterRenderingGroupObservable.clear();\n        this.onMeshImportedObservable.clear();\n        this.onBeforeCameraRenderObservable.clear();\n        this.onAfterCameraRenderObservable.clear();\n        this.onReadyObservable.clear();\n        this.onNewCameraAddedObservable.clear();\n        this.onCameraRemovedObservable.clear();\n        this.onNewLightAddedObservable.clear();\n        this.onLightRemovedObservable.clear();\n        this.onNewGeometryAddedObservable.clear();\n        this.onGeometryRemovedObservable.clear();\n        this.onNewTransformNodeAddedObservable.clear();\n        this.onTransformNodeRemovedObservable.clear();\n        this.onNewMeshAddedObservable.clear();\n        this.onMeshRemovedObservable.clear();\n        this.onNewSkeletonAddedObservable.clear();\n        this.onSkeletonRemovedObservable.clear();\n        this.onNewMaterialAddedObservable.clear();\n        this.onNewMultiMaterialAddedObservable.clear();\n        this.onMaterialRemovedObservable.clear();\n        this.onMultiMaterialRemovedObservable.clear();\n        this.onNewTextureAddedObservable.clear();\n        this.onTextureRemovedObservable.clear();\n        this.onPrePointerObservable.clear();\n        this.onPointerObservable.clear();\n        this.onPreKeyboardObservable.clear();\n        this.onKeyboardObservable.clear();\n        this.onActiveCameraChanged.clear();\n        this.onComputePressureChanged.clear();\n        this._computePressureObserver?.unobserve();\n        this._computePressureObserver = undefined;\n        this.detachControl();\n        // Detach cameras\n        const canvas = this._engine.getInputElement();\n        if (canvas) {\n            for (let index = 0; index < this.cameras.length; index++) {\n                this.cameras[index].detachControl();\n            }\n        }\n        // Release animation groups\n        this._disposeList(this.animationGroups);\n        // Release lights\n        this._disposeList(this.lights);\n        // Release meshes\n        this._disposeList(this.meshes, (item) => item.dispose(true));\n        this._disposeList(this.transformNodes, (item) => item.dispose(true));\n        // Release cameras\n        this._disposeList(this.cameras);\n        // Release materials\n        if (this._defaultMaterial) {\n            this._defaultMaterial.dispose();\n        }\n        this._disposeList(this.multiMaterials);\n        this._disposeList(this.materials);\n        // Release particles\n        this._disposeList(this.particleSystems);\n        // Release postProcesses\n        this._disposeList(this.postProcesses);\n        // Release textures\n        this._disposeList(this.textures);\n        // Release morph targets\n        this._disposeList(this.morphTargetManagers);\n        // Release UBO\n        this._sceneUbo.dispose();\n        if (this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n        }\n        // Post-processes\n        this.postProcessManager.dispose();\n        // Components\n        this._disposeList(this._components);\n        // Remove from engine\n        let index = this._engine.scenes.indexOf(this);\n        if (index > -1) {\n            this._engine.scenes.splice(index, 1);\n        }\n        if (EngineStore._LastCreatedScene === this) {\n            if (this._engine.scenes.length > 0) {\n                EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n            }\n            else {\n                EngineStore._LastCreatedScene = null;\n            }\n        }\n        index = this._engine._virtualScenes.indexOf(this);\n        if (index > -1) {\n            this._engine._virtualScenes.splice(index, 1);\n        }\n        this._engine.wipeCaches(true);\n        this._isDisposed = true;\n    }\n    private _disposeList<T extends IDisposable>(items: T[], callback?: (item: T) => void): void {\n        const itemsCopy = SliceTools.Slice(items, 0);\n        callback = callback ?? ((item) => item.dispose());\n        for (const item of itemsCopy) {\n            callback(item);\n        }\n        items.length = 0;\n    }\n    /**\n     * Gets if the scene is already disposed\n     */\n    public get isDisposed(): boolean {\n        return this._isDisposed;\n    }\n    /**\n     * Call this function to reduce memory footprint of the scene.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n    public clearCachedVertexData(): void {\n        for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n            const mesh = this.meshes[meshIndex];\n            const geometry = (<Mesh>mesh).geometry;\n            if (geometry) {\n                geometry.clearCachedData();\n            }\n        }\n    }\n    /**\n     * This function will remove the local cached buffer data from texture.\n     * It will save memory but will prevent the texture from being rebuilt\n     */\n    public cleanCachedTextureBuffer(): void {\n        for (const baseTexture of this.textures) {\n            const buffer = (<Texture>baseTexture)._buffer;\n            if (buffer) {\n                (<Texture>baseTexture)._buffer = null;\n            }\n        }\n    }\n    /**\n     * Get the world extend vectors with an optional filter\n     *\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n     */\n    public getWorldExtends(filterPredicate?: (mesh: AbstractMesh) => boolean): {\n        min: Vector3;\n        max: Vector3;\n    } {\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        filterPredicate = filterPredicate || (() => true);\n        this.meshes.filter(filterPredicate).forEach((mesh) => {\n            mesh.computeWorldMatrix(true);\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n                return;\n            }\n            const boundingInfo = mesh.getBoundingInfo();\n            const minBox = boundingInfo.boundingBox.minimumWorld;\n            const maxBox = boundingInfo.boundingBox.maximumWorld;\n            Vector3.CheckExtends(minBox, min, max);\n            Vector3.CheckExtends(maxBox, min, max);\n        });\n        return {\n            min: min,\n            max: max\n        };\n    }\n    // Picking\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @returns a Ray\n     */\n    public createPickingRay(x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns the current scene\n     */\n    public createPickingRayToRef(x: number, y: number, world: Nullable<Matrix>, result: Ray, camera: Nullable<Camera>, cameraViewSpace = false, enableDistantPicking = false): Scene {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param camera defines the camera to use for the picking\n     * @returns a Ray\n     */\n    public createPickingRayInCameraSpace(x: number, y: number, camera?: Camera): Ray {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @returns the current scene\n     */\n    public createPickingRayInCameraSpaceToRef(x: number, y: number, result: Ray, camera?: Camera): Scene {\n        throw _WarnImport(\"Ray\");\n    }\n    /** Launch a ray to try to pick a mesh in the scene\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    public pick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\n        // Dummy info if picking as not been imported\n        const pi = new PickingInfo();\n        pi._pickingUnavailable = true;\n        return pi;\n    }\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n     */\n    public pickWithBoundingInfo(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\n        // Dummy info if picking as not been imported\n        const pi = new PickingInfo();\n        pi._pickingUnavailable = true;\n        return pi;\n    }\n    /** Use the given ray to pick a mesh in the scene\n     * @param ray The ray to use to pick meshes\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    public pickWithRay(ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param x X position on screen\n     * @param y Y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    public multiPick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param ray Ray to use\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    public multiPickWithRay(ray: Ray, predicate: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Force the value of meshUnderPointer\n     * @param mesh defines the mesh to use\n     * @param pointerId optional pointer id when using more than one pointer\n     * @param pickResult optional pickingInfo data used to find mesh\n     */\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId?: number, pickResult?: Nullable<PickingInfo>): void {\n        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n    }\n    /**\n     * Gets the mesh under the pointer\n     * @returns a Mesh or null if no mesh is under the pointer\n     */\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\n        return this._inputManager.getPointerOverMesh();\n    }\n    // Misc.\n    /** @hidden */\n    public _rebuildGeometries(): void {\n        for (const geometry of this.geometries) {\n            geometry._rebuild();\n        }\n        for (const mesh of this.meshes) {\n            mesh._rebuild();\n        }\n        if (this.postProcessManager) {\n            this.postProcessManager._rebuild();\n        }\n        for (const component of this._components) {\n            component.rebuild();\n        }\n        for (const system of this.particleSystems) {\n            system.rebuild();\n        }\n        if (this.spriteManagers) {\n            for (const spriteMgr of this.spriteManagers) {\n                spriteMgr.rebuild();\n            }\n        }\n    }\n    /** @hidden */\n    public _rebuildTextures(): void {\n        for (const texture of this.textures) {\n            texture._rebuild();\n        }\n        this.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n    }\n    // Tags\n    private _getByTags(list: any[], tagsQuery: string, forEach?: (item: any) => void): any[] {\n        if (tagsQuery === undefined) {\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n            return list;\n        }\n        const listByTags = [];\n        forEach =\n            forEach ||\n                ((item: any) => {\n                    return;\n                });\n        for (const i in list) {\n            const item = list[i];\n            if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n                listByTags.push(item);\n                forEach(item);\n            }\n        }\n        return listByTags;\n    }\n    /**\n     * Get a list of meshes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Mesh\n     */\n    public getMeshesByTags(tagsQuery: string, forEach?: (mesh: AbstractMesh) => void): Mesh[] {\n        return this._getByTags(this.meshes, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of cameras by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Camera\n     */\n    public getCamerasByTags(tagsQuery: string, forEach?: (camera: Camera) => void): Camera[] {\n        return this._getByTags(this.cameras, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of lights by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Light\n     */\n    public getLightsByTags(tagsQuery: string, forEach?: (light: Light) => void): Light[] {\n        return this._getByTags(this.lights, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of materials by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Material\n     */\n    public getMaterialByTags(tagsQuery: string, forEach?: (material: Material) => void): Material[] {\n        return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n    }\n    /**\n     * Get a list of transform nodes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of TransformNode\n     */\n    public getTransformNodesByTags(tagsQuery: string, forEach?: (transform: TransformNode) => void): TransformNode[] {\n        return this._getByTags(this.transformNodes, tagsQuery, forEach);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversly depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    public setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null, alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null, transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null): void {\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\n        return this._renderingManager.getAutoClearDepthStencilSetup(index);\n    }\n    private _blockMaterialDirtyMechanism = false;\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    public get blockMaterialDirtyMechanism(): boolean {\n        return this._blockMaterialDirtyMechanism;\n    }\n    public set blockMaterialDirtyMechanism(value: boolean) {\n        if (this._blockMaterialDirtyMechanism === value) {\n            return;\n        }\n        this._blockMaterialDirtyMechanism = value;\n        if (!value) {\n            // Do a complete update\n            this.markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\n        }\n    }\n    /**\n     * Will flag all materials as dirty to trigger new shader compilation\n     * @param flag defines the flag used to specify which material part must be marked as dirty\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n     */\n    public markAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void {\n        if (this._blockMaterialDirtyMechanism) {\n            return;\n        }\n        for (const material of this.materials) {\n            if (predicate && !predicate(material)) {\n                continue;\n            }\n            material.markAsDirty(flag);\n        }\n    }\n    /**\n     * @param fileOrUrl\n     * @param onSuccess\n     * @param onProgress\n     * @param useOfflineSupport\n     * @param useArrayBuffer\n     * @param onError\n     * @param onOpened\n     * @hidden\n     */\n    public _loadFile(fileOrUrl: File | string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest {\n        const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @param fileOrUrl\n     * @param onProgress\n     * @param useOfflineSupport\n     * @param useArrayBuffer\n     * @param onOpened\n     * @hidden\n     */\n    public _loadFileAsync(fileOrUrl: File | string, onProgress?: (data: any) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onOpened?: (request: WebRequest) => void): Promise<string | ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            this._loadFile(fileOrUrl, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\n                reject(exception);\n            }, onOpened);\n        });\n    }\n    /**\n     * @param url\n     * @param onSuccess\n     * @param onProgress\n     * @param useOfflineSupport\n     * @param useArrayBuffer\n     * @param onError\n     * @param onOpened\n     * @hidden\n     */\n    public _requestFile(url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest {\n        const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @param url\n     * @param onProgress\n     * @param useOfflineSupport\n     * @param useArrayBuffer\n     * @param onOpened\n     * @hidden\n     */\n    public _requestFileAsync(url: string, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onOpened?: (request: WebRequest) => void): Promise<string | ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            this._requestFile(url, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {\n                reject(error);\n            }, onOpened);\n        });\n    }\n    /**\n     * @param file\n     * @param onSuccess\n     * @param onProgress\n     * @param useArrayBuffer\n     * @param onError\n     * @hidden\n     */\n    public _readFile(file: File, onSuccess: (data: string | ArrayBuffer) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest {\n        const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @param file\n     * @param onProgress\n     * @param useArrayBuffer\n     * @hidden\n     */\n    public _readFileAsync(file: File, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): Promise<string | ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            this._readFile(file, (data) => {\n                resolve(data);\n            }, onProgress, useArrayBuffer, (error) => {\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n    protected _perfCollector: Nullable<PerformanceViewerCollector> = null;\n    /**\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n     * @returns the perf collector belonging to the scene.\n     */\n    public getPerfCollector(): PerformanceViewerCollector {\n        throw _WarnImport(\"performanceViewerSceneExtension\");\n    }\n    private _computePressureObserver: ComputePressureObserverWrapper | undefined;\n    /**\n     * An event triggered when the cpu usage/speed meets certain thresholds.\n     * Note: Compute pressure is an experimental API.\n     */\n    public onComputePressureChanged = new Observable<IComputePressureData>();\n}\n\n    declare module \"./scene\" {\n    interface Scene {\n        /**\n         * Sets the active camera of the scene using its Id\n         * @param id defines the camera's Id\n         * @return the new active camera or null if none found.\n         * @deprecated Please use setActiveCameraById instead\n         */\n        setActiveCameraByID(id: string): Nullable<Camera>;\n        /**\n         * Get a material using its id\n         * @param id defines the material's Id\n         * @return the material or null if none found.\n         * @deprecated Please use getMaterialById instead\n         */\n        getMaterialByID(id: string): Nullable<Material>;\n        /**\n         * Gets a the last added material using a given id\n         * @param id defines the material's Id\n         * @return the last material with the given id or null if none found.\n         * @deprecated Please use getLastMaterialById instead\n         */\n        getLastMaterialByID(id: string): Nullable<Material>;\n        /**\n         * Get a texture using its unique id\n         * @param uniqueId defines the texture's unique id\n         * @return the texture or null if none found.\n         * @deprecated Please use getTextureByUniqueId instead\n         */\n        getTextureByUniqueID(uniqueId: number): Nullable<BaseTexture>;\n        /**\n         * Gets a camera using its Id\n         * @param id defines the Id to look for\n         * @returns the camera or null if not found\n         * @deprecated Please use getCameraById instead\n         */\n        getCameraByID(id: string): Nullable<Camera>;\n        /**\n         * Gets a camera using its unique Id\n         * @param uniqueId defines the unique Id to look for\n         * @returns the camera or null if not found\n         * @deprecated Please use getCameraByUniqueId instead\n         */\n        getCameraByUniqueID(uniqueId: number): Nullable<Camera>;\n        /**\n         * Gets a bone using its Id\n         * @param id defines the bone's Id\n         * @return the bone or null if not found\n         * @deprecated Please use getBoneById instead\n         */\n        getBoneByID(id: string): Nullable<Bone>;\n        /**\n         * Gets a light node using its Id\n         * @param id defines the light's Id\n         * @return the light or null if none found.\n         * @deprecated Please use getLightById instead\n         */\n        getLightByID(id: string): Nullable<Light>;\n        /**\n         * Gets a light node using its scene-generated unique Id\n         * @param uniqueId defines the light's unique Id\n         * @return the light or null if none found.\n         * @deprecated Please use getLightByUniqueId instead\n         */\n        getLightByUniqueID(uniqueId: number): Nullable<Light>;\n        /**\n         * Gets a particle system by Id\n         * @param id defines the particle system Id\n         * @return the corresponding system or null if none found\n         * @deprecated Please use getParticleSystemById instead\n         */\n        getParticleSystemByID(id: string): Nullable<IParticleSystem>;\n        /**\n         * Gets a geometry using its Id\n         * @param id defines the geometry's Id\n         * @return the geometry or null if none found.\n         * @deprecated Please use getGeometryById instead\n         */\n        getGeometryByID(id: string): Nullable<Geometry>;\n        /**\n         * Gets the first added mesh found of a given Id\n         * @param id defines the Id to search for\n         * @return the mesh found or null if not found at all\n         * @deprecated Please use getMeshById instead\n         */\n        getMeshByID(id: string): Nullable<AbstractMesh>;\n        /**\n         * Gets a mesh with its auto-generated unique Id\n         * @param uniqueId defines the unique Id to search for\n         * @return the found mesh or null if not found at all.\n         * @deprecated Please use getMeshByUniqueId instead\n         */\n        getMeshByUniqueID(uniqueId: number): Nullable<AbstractMesh>;\n        /**\n         * Gets a the last added mesh using a given Id\n         * @param id defines the Id to search for\n         * @return the found mesh or null if not found at all.\n         * @deprecated Please use getLastMeshById instead\n         */\n        getLastMeshByID(id: string): Nullable<AbstractMesh>;\n        /**\n         * Gets a list of meshes using their Id\n         * @param id defines the Id to search for\n         * @returns a list of meshes\n         * @deprecated Please use getMeshesById instead\n         */\n        getMeshesByID(id: string): Array<AbstractMesh>;\n        /**\n         * Gets the first added transform node found of a given Id\n         * @param id defines the Id to search for\n         * @return the found transform node or null if not found at all.\n         * @deprecated Please use getTransformNodeById instead\n         */\n        getTransformNodeByID(id: string): Nullable<TransformNode>;\n        /**\n         * Gets a transform node with its auto-generated unique Id\n         * @param uniqueId defines the unique Id to search for\n         * @return the found transform node or null if not found at all.\n         * @deprecated Please use getTransformNodeByUniqueId instead\n         */\n        getTransformNodeByUniqueID(uniqueId: number): Nullable<TransformNode>;\n        /**\n         * Gets a list of transform nodes using their Id\n         * @param id defines the Id to search for\n         * @returns a list of transform nodes\n         * @deprecated Please use getTransformNodesById instead\n         */\n        getTransformNodesByID(id: string): Array<TransformNode>;\n        /**\n         * Gets a node (Mesh, Camera, Light) using a given Id\n         * @param id defines the Id to search for\n         * @return the found node or null if not found at all\n         * @deprecated Please use getNodeById instead\n         */\n        getNodeByID(id: string): Nullable<Node>;\n        /**\n         * Gets a the last added node (Mesh, Camera, Light) using a given Id\n         * @param id defines the Id to search for\n         * @return the found node or null if not found at all\n         * @deprecated Please use getLastEntryById instead\n         */\n        getLastEntryByID(id: string): Nullable<Node>;\n        /**\n         * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n         * @param id defines the Id to search for\n         * @return the found skeleton or null if not found at all.\n         * @deprecated Please use getLastSkeletonById instead\n         */\n        getLastSkeletonByID(id: string): Nullable<Skeleton>;\n    }\n}\n/**\n * @param id\n * @hidden\n */\nScene.prototype.setActiveCameraByID = function (id: string): Nullable<Camera> {\n    return this.setActiveCameraById(id);\n};\nScene.prototype.getLastMaterialByID = function (id: string): Nullable<Material> {\n    return this.getLastMaterialById(id);\n};\nScene.prototype.getMaterialByID = function (id: string): Nullable<Material> {\n    return this.getMaterialById(id);\n};\nScene.prototype.getTextureByUniqueID = function (uniqueId: number): Nullable<BaseTexture> {\n    return this.getTextureByUniqueId(uniqueId);\n};\nScene.prototype.getCameraByID = function (id: string): Nullable<Camera> {\n    return this.getCameraById(id);\n};\nScene.prototype.getCameraByUniqueID = function (uniqueId: number): Nullable<Camera> {\n    return this.getCameraByUniqueId(uniqueId);\n};\nScene.prototype.getBoneByID = function (id: string): Nullable<Bone> {\n    return this.getBoneById(id);\n};\nScene.prototype.getLightByID = function (id: string): Nullable<Light> {\n    return this.getLightById(id);\n};\nScene.prototype.getLightByUniqueID = function (uniqueId: number): Nullable<Light> {\n    return this.getLightByUniqueId(uniqueId);\n};\nScene.prototype.getParticleSystemByID = function (id: string): Nullable<IParticleSystem> {\n    return this.getParticleSystemById(id);\n};\nScene.prototype.getGeometryByID = function (id: string): Nullable<Geometry> {\n    return this.getGeometryById(id);\n};\nScene.prototype.getMeshByID = function (id: string): Nullable<AbstractMesh> {\n    return this.getMeshById(id);\n};\nScene.prototype.getMeshesByID = function (id: string): Array<AbstractMesh> {\n    return this.getMeshesById(id);\n};\nScene.prototype.getTransformNodeByID = function (id: string): Nullable<TransformNode> {\n    return this.getTransformNodeById(id);\n};\nScene.prototype.getTransformNodeByUniqueID = function (uniqueId: number): Nullable<TransformNode> {\n    return this.getTransformNodeByUniqueId(uniqueId);\n};\nScene.prototype.getTransformNodesByID = function (id: string): Array<TransformNode> {\n    return this.getTransformNodesById(id);\n};\nScene.prototype.getMeshByUniqueID = function (uniqueId: number): Nullable<AbstractMesh> {\n    return this.getMeshByUniqueId(uniqueId);\n};\nScene.prototype.getLastMeshByID = function (id: string): Nullable<AbstractMesh> {\n    return this.getLastMeshById(id);\n};\nScene.prototype.getLastEntryByID = function (id: string): Nullable<Node> {\n    return this.getLastEntryById(id);\n};\nScene.prototype.getNodeByID = function (id: string): Nullable<Node> {\n    return this.getNodeById(id);\n};\nScene.prototype.getLastSkeletonByID = function (id: string): Nullable<Skeleton> {\n    return this.getLastSkeletonById(id);\n};\n"]},"metadata":{},"sourceType":"module"}