{"ast":null,"code":"import \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables rotating a mesh along 3 axis\n */\n\nvar RotationGizmo =\n/** @class */\nfunction (_super) {\n  __extends(RotationGizmo, _super);\n  /**\n   * Creates a RotationGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\n   * @param thickness display gizmo axis thickness\n   * @param gizmoManager Gizmo manager\n   * @param options More options\n   */\n\n\n  function RotationGizmo(gizmoLayer, tessellation, useEulerRotation, thickness, gizmoManager, options) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (tessellation === void 0) {\n      tessellation = 32;\n    }\n\n    if (useEulerRotation === void 0) {\n      useEulerRotation = false;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n    /** Fires an event when any of it's sub gizmos are dragged */\n\n\n    _this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n\n    _this.onDragEndObservable = new Observable();\n    _this._observables = [];\n    /** Node Caching for quick lookup */\n\n    _this._gizmoAxisCache = new Map();\n    var xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\n    var yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\n    var zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\n    _this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, _this, useEulerRotation, thickness);\n    _this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, _this, useEulerRotation, thickness);\n    _this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, _this, useEulerRotation, thickness); // Relay drag events and set update scale\n\n    [_this.xGizmo, _this.yGizmo, _this.zGizmo].forEach(function (gizmo) {\n      //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\n      //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\n      if (options && options.updateScale != undefined) {\n        gizmo.updateScale = options.updateScale;\n      }\n\n      gizmo.dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(function () {\n        _this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    _this.attachedMesh = null;\n    _this.attachedNode = null;\n\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(_this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(RotationGizmo.prototype, \"attachedMesh\", {\n    get: function get() {\n      return this._meshAttached;\n    },\n    set: function set(mesh) {\n      this._meshAttached = mesh;\n      this._nodeAttached = mesh;\n\n      this._checkBillboardTransform();\n\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedMesh = mesh;\n        } else {\n          gizmo.attachedMesh = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"attachedNode\", {\n    get: function get() {\n      return this._nodeAttached;\n    },\n    set: function set(node) {\n      this._meshAttached = null;\n      this._nodeAttached = node;\n\n      this._checkBillboardTransform();\n\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedNode = node;\n        } else {\n          gizmo.attachedNode = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RotationGizmo.prototype._checkBillboardTransform = function () {\n    if (this._nodeAttached && this._nodeAttached.billboardMode) {\n      console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\n    }\n  };\n\n  Object.defineProperty(RotationGizmo.prototype, \"isHovered\", {\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get: function get() {\n      var hovered = false;\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        hovered = hovered || gizmo.isHovered;\n      });\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function get() {\n      return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n    },\n    set: function set(value) {\n      if (this.xGizmo) {\n        this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"snapDistance\", {\n    get: function get() {\n      return this.xGizmo.snapDistance;\n    },\n\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    set: function set(value) {\n      if (this.xGizmo) {\n        this.xGizmo.snapDistance = value;\n        this.yGizmo.snapDistance = value;\n        this.zGizmo.snapDistance = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"scaleRatio\", {\n    get: function get() {\n      return this.xGizmo.scaleRatio;\n    },\n\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set: function set(value) {\n      if (this.xGizmo) {\n        this.xGizmo.scaleRatio = value;\n        this.yGizmo.scaleRatio = value;\n        this.zGizmo.scaleRatio = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param mesh Axis gizmo mesh\n   * @param cache Gizmo axis definition used for reactive gizmo UI\n   */\n\n  RotationGizmo.prototype.addToAxisCache = function (mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  };\n  /**\n   * Disposes of the gizmo\n   */\n\n\n  RotationGizmo.prototype.dispose = function () {\n    var _this = this;\n\n    this.xGizmo.dispose();\n    this.yGizmo.dispose();\n    this.zGizmo.dispose();\n    this.onDragStartObservable.clear();\n    this.onDragEndObservable.clear();\n\n    this._observables.forEach(function (obs) {\n      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n  };\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n\n\n  RotationGizmo.prototype.setCustomMesh = function () {\n    Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n  };\n\n  return RotationGizmo;\n}(Gizmo);\n\nexport { RotationGizmo };","map":{"version":3,"mappings":"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","names":["Logger","Observable","Vector3","Color3","Gizmo","PlaneRotationGizmo","UtilityLayerRenderer","__extends","gizmoLayer","tessellation","useEulerRotation","thickness","gizmoManager","options","DefaultUtilityLayer","_super","_this","Map","xColor","xOptions","color","Red","scale","yColor","yOptions","Green","zColor","zOptions","Blue","xGizmo","yGizmo","zGizmo","forEach","gizmo","updateScale","undefined","dragBehavior","onDragStartObservable","add","notifyObservers","onDragEndObservable","attachedMesh","attachedNode","addToAxisCache","_gizmoAxisCache","GizmoAxisPointerObserver","Object","RotationGizmo","_meshAttached","mesh","_nodeAttached","_checkBillboardTransform","isEnabled","node","billboardMode","console","log","hovered","isHovered","updateGizmoRotationToMatchAttachedMesh","value","snapDistance","scaleRatio","cache","set","dispose","clear","_observables","obs","utilityLayerScene","onPointerObservable","remove","Error"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/rotationGizmo.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { GizmoAxisCache } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { GizmoManager } from \"./gizmoManager\";\r\n\r\n/**\r\n * Options for each individual plane rotation gizmo contained within RotationGizmo\r\n * @since 5.0.0\r\n */\r\nexport interface PlaneRotationGizmoOptions {\r\n    /**\r\n     * Color to use for the plane rotation gizmo\r\n     */\r\n    color?: Color3;\r\n}\r\n\r\n/**\r\n * Additional options for each rotation gizmo\r\n */\r\nexport interface RotationGizmoOptions {\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale?: boolean;\r\n\r\n    /**\r\n     * Specific options for xGizmo\r\n     */\r\n    xOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for yGizmo\r\n     */\r\n    yOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for zGizmo\r\n     */\r\n    zOptions?: PlaneRotationGizmoOptions;\r\n}\r\n\r\n/**\r\n * Gizmo that enables rotating a mesh along 3 axis\r\n */\r\nexport class RotationGizmo extends Gizmo {\r\n    /**\r\n     * Internal gizmo used for interactions on the x axis\r\n     */\r\n    public xGizmo: PlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the y axis\r\n     */\r\n    public yGizmo: PlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the z axis\r\n     */\r\n    public zGizmo: PlaneRotationGizmo;\r\n\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    public onDragStartObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    public onDragEndObservable = new Observable();\r\n\r\n    private _meshAttached: Nullable<AbstractMesh>;\r\n    private _nodeAttached: Nullable<Node>;\r\n    private _observables: Observer<PointerInfo>[] = [];\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n\r\n    public get attachedMesh() {\r\n        return this._meshAttached;\r\n    }\r\n    public set attachedMesh(mesh: Nullable<AbstractMesh>) {\r\n        this._meshAttached = mesh;\r\n        this._nodeAttached = mesh;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedMesh = mesh;\r\n            } else {\r\n                gizmo.attachedMesh = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get attachedNode() {\r\n        return this._nodeAttached;\r\n    }\r\n    public set attachedNode(node: Nullable<Node>) {\r\n        this._meshAttached = null;\r\n        this._nodeAttached = node;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedNode = node;\r\n            } else {\r\n                gizmo.attachedNode = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _checkBillboardTransform() {\r\n        if (this._nodeAttached && (<TransformNode>this._nodeAttached).billboardMode) {\r\n            console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            hovered = hovered || gizmo.isHovered;\r\n        });\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Creates a RotationGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     * @param gizmoManager Gizmo manager\r\n     * @param options More options\r\n     */\r\n    constructor(\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        tessellation = 32,\r\n        useEulerRotation = false,\r\n        thickness: number = 1,\r\n        gizmoManager?: GizmoManager,\r\n        options?: RotationGizmoOptions\r\n    ) {\r\n        super(gizmoLayer);\r\n        const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\r\n        const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\r\n        const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\r\n        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        // Relay drag events and set update scale\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\r\n            //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\r\n            if (options && options.updateScale != undefined) {\r\n                gizmo.updateScale = options.updateScale;\r\n            }\r\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\r\n                this.onDragEndObservable.notifyObservers({});\r\n            });\r\n        });\r\n\r\n        this.attachedMesh = null;\r\n        this.attachedNode = null;\r\n\r\n        if (gizmoManager) {\r\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\r\n        } else {\r\n            // Only subscribe to pointer event if gizmoManager isnt\r\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\r\n        }\r\n    }\r\n\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public set snapDistance(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.snapDistance = value;\r\n            this.yGizmo.snapDistance = value;\r\n            this.zGizmo.snapDistance = value;\r\n        }\r\n    }\r\n    public get snapDistance() {\r\n        return this.xGizmo.snapDistance;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.scaleRatio = value;\r\n            this.yGizmo.scaleRatio = value;\r\n            this.zGizmo.scaleRatio = value;\r\n        }\r\n    }\r\n    public get scaleRatio() {\r\n        return this.xGizmo.scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(mesh: Mesh, cache: GizmoAxisCache) {\r\n        this._gizmoAxisCache.set(mesh, cache);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.xGizmo.dispose();\r\n        this.yGizmo.dispose();\r\n        this.zGizmo.dispose();\r\n        this.onDragStartObservable.clear();\r\n        this.onDragEndObservable.clear();\r\n        this._observables.forEach((obs) => {\r\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\r\n            \"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\"\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}