{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __assign, __decorate } from \"tslib\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/glowMapGeneration.fragment.js\";\nimport \"../Shaders/glowMapGeneration.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../Materials/effectFallbacks.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * The effect layer Helps adding post process effect blended with the main pass.\n *\n * This can be for instance use to generate glow or highlight effects on the scene.\n *\n * The effect layer class can not be used directly and is intented to inherited from to be\n * customized per effects.\n */\n\nvar EffectLayer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new effect Layer and references it in the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   */\n  function EffectLayer(\n  /** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    /**\n     * The clear color of the texture used to generate the glow map.\n     */\n\n    this.neutralColor = new Color4();\n    /**\n     * Specifies whether the highlight layer is enabled or not.\n     */\n\n    this.isEnabled = true;\n    /**\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\n     */\n\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\n     * An event triggered when the effect layer has been disposed.\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\n     */\n\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\n     * An event triggered when the generated texture is being merged in the scene.\n     */\n\n    this.onBeforeComposeObservable = new Observable();\n    /**\n     * An event triggered when the mesh is rendered into the effect render target.\n     */\n\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered after the mesh has been rendered into the effect render target.\n     */\n\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered when the generated texture has been merged in the scene.\n     */\n\n    this.onAfterComposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer changes its size.\n     */\n\n    this.onSizeChangedObservable = new Observable();\n    this._materialForRendering = {};\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    EffectLayer._SceneComponentInitialization(this._scene);\n\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n\n    this._scene.effectLayers.push(this);\n\n    this._mergeDrawWrapper = []; // Generate Buffers\n\n    this._generateIndexBuffer();\n\n    this._generateVertexBuffer();\n  }\n\n  Object.defineProperty(EffectLayer.prototype, \"camera\", {\n    /**\n     * Gets the camera attached to the layer.\n     */\n    get: function get() {\n      return this._effectLayerOptions.camera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EffectLayer.prototype, \"renderingGroupId\", {\n    /**\n     * Gets the rendering group id the layer should render in.\n     */\n    get: function get() {\n      return this._effectLayerOptions.renderingGroupId;\n    },\n    set: function set(renderingGroupId) {\n      this._effectLayerOptions.renderingGroupId = renderingGroupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EffectLayer.prototype, \"mainTexture\", {\n    /**\n     * Gets the main texture where the effect is rendered\n     */\n    get: function get() {\n      return this._mainTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes in the layer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\n   */\n\n  EffectLayer.prototype.setMaterialForRendering = function (mesh, material) {\n    this._mainTexture.setMaterialForRendering(mesh, material);\n\n    if (Array.isArray(mesh)) {\n      for (var i = 0; i < mesh.length; ++i) {\n        var currentMesh = mesh[i];\n\n        if (!material) {\n          delete this._materialForRendering[currentMesh.uniqueId];\n        } else {\n          this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\n        }\n      }\n    } else {\n      if (!material) {\n        delete this._materialForRendering[mesh.uniqueId];\n      } else {\n        this._materialForRendering[mesh.uniqueId] = [mesh, material];\n      }\n    }\n  };\n  /**\n   * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\n   * @returns Number of times a mesh must be rendered in the layer\n   */\n\n\n  EffectLayer.prototype._numInternalDraws = function () {\n    return 1;\n  };\n  /**\n   * Initializes the effect layer with the required options.\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\n   */\n\n\n  EffectLayer.prototype._init = function (options) {\n    // Adapt options\n    this._effectLayerOptions = __assign({\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options);\n\n    this._setMainTextureSize();\n\n    this._createMainTexture();\n\n    this._createTextureAndPostProcesses();\n  };\n  /**\n   * Generates the index buffer of the full screen quad blending to the main canvas.\n   */\n\n\n  EffectLayer.prototype._generateIndexBuffer = function () {\n    // Indices\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\n   */\n\n\n  EffectLayer.prototype._generateVertexBuffer = function () {\n    // VBO\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  };\n  /**\n   * Sets the main texture desired size which is the closest power of two\n   * of the engine canvas size.\n   */\n\n\n  EffectLayer.prototype._setMainTextureSize = function () {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  };\n  /**\n   * Creates the main texture for the effect layer.\n   */\n\n\n  EffectLayer.prototype._createMainTexture = function () {\n    var _this = this;\n\n    this._mainTexture = new RenderTargetTexture(\"EffectLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, 0);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true;\n\n    for (var id in this._materialForRendering) {\n      var _a = this._materialForRendering[id],\n          mesh = _a[0],\n          material = _a[1];\n\n      this._mainTexture.setMaterialForRendering(mesh, material);\n    }\n\n    this._mainTexture.customIsReadyFunction = function (mesh, refreshRate) {\n      if (!mesh.isReady(false)) {\n        return false;\n      }\n\n      if (refreshRate === 0 && mesh.subMeshes) {\n        // full check: check that the effects are ready\n        for (var i = 0; i < mesh.subMeshes.length; ++i) {\n          var subMesh = mesh.subMeshes[i];\n          var material = subMesh.getMaterial();\n          var renderingMesh = subMesh.getRenderingMesh();\n\n          if (!material) {\n            continue;\n          }\n\n          var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n          var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n\n          _this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n\n          if (!_this._isReady(subMesh, hardwareInstancedRendering, _this._emissiveTextureAndColor.texture)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }; // Custom render function\n\n\n    this._mainTexture.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);\n\n      var index;\n\n      var engine = _this._scene.getEngine();\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          _this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        _this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        _this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      var previousAlphaMode = engine.getAlphaMode();\n\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        _this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n\n      engine.setAlphaMode(previousAlphaMode);\n    };\n\n    this._mainTexture.onClearObservable.add(function (engine) {\n      engine.clear(_this.neutralColor, true, true, true);\n    }); // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\n\n\n    if (this._scene.getBoundingBoxRenderer) {\n      var boundingBoxRendererEnabled_1 = this._scene.getBoundingBoxRenderer().enabled;\n\n      this._mainTexture.onBeforeBindObservable.add(function () {\n        _this._scene.getBoundingBoxRenderer().enabled = !_this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled_1;\n      });\n\n      this._mainTexture.onAfterUnbindObservable.add(function () {\n        _this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled_1;\n      });\n    }\n  };\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  EffectLayer.prototype._addCustomEffectDefines = function (defines) {// Nothing to add by default.\n  };\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @param emissiveTexture the associated emissive texture used to generate the glow\n   * @return true if ready otherwise, false\n   */\n\n\n  EffectLayer.prototype._isReady = function (subMesh, useInstances, emissiveTexture) {\n    var _a;\n\n    var engine = this._scene.getEngine();\n\n    var mesh = subMesh.getMesh();\n    var renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n\n    var material = subMesh.getMaterial();\n\n    if (!material) {\n      return false;\n    }\n\n    if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\n      return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var uv1 = false;\n    var uv2 = false; // Diffuse\n\n    if (material) {\n      var needAlphaTest = material.needAlphaTesting();\n      var diffuseTexture = material.getAlphaTestTexture();\n      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n\n        if (!diffuseTexture.gammaSpace) {\n          defines.push(\"#define DIFFUSE_ISLINEAR\");\n        }\n      }\n\n      var opacityTexture = material.opacityTexture;\n\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    } // Emissive\n\n\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n\n      if (!emissiveTexture.gammaSpace) {\n        defines.push(\"#define EMISSIVE_ISLINEAR\");\n      }\n    } // Vertex\n\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    } // Bones\n\n\n    var fallbacks = new EffectFallbacks();\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      var skeleton = mesh.skeleton;\n\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var manager = mesh.morphTargetManager;\n    var morphInfluencers = 0;\n\n    if (manager) {\n      if (manager.numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        morphInfluencers = manager.numInfluencers;\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n\n        if (manager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n\n    this._addCustomEffectDefines(defines); // Get correct effect\n\n\n    var drawWrapper = subMesh._getDrawWrapper(undefined, true);\n\n    var cachedDefines = drawWrapper.defines;\n    var join = defines.join(\"\\n\");\n\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(this._engine.createEffect(\"glowMapGeneration\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"], [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      }), join);\n    }\n\n    return drawWrapper.effect.isReady();\n  };\n  /**\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\n   */\n\n\n  EffectLayer.prototype.render = function () {\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n\n    var engine = this._scene.getEngine();\n\n    var numDraws = this._numInternalDraws(); // Check\n\n\n    var isReady = true;\n\n    for (var i = 0; i < numDraws; ++i) {\n      var currentEffect = this._mergeDrawWrapper[i];\n\n      if (!currentEffect) {\n        currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\n        currentEffect.setEffect(this._createMergeEffect());\n      }\n\n      isReady = isReady && currentEffect.effect.isReady();\n    }\n\n    if (!isReady) {\n      return;\n    }\n\n    this.onBeforeComposeObservable.notifyObservers(this);\n    var previousAlphaMode = engine.getAlphaMode();\n\n    for (var i = 0; i < numDraws; ++i) {\n      var currentEffect = this._mergeDrawWrapper[i]; // Render\n\n      engine.enableEffect(currentEffect);\n      engine.setState(false); // VBOs\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect); // Go Blend.\n\n      engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode); // Blends the map on the main canvas.\n\n      this._internalRender(currentEffect.effect, i);\n    } // Restore Alpha\n\n\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this); // Handle size changes.\n\n    var size = this._mainTexture.getSize();\n\n    this._setMainTextureSize();\n\n    if ((size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n\n      this._disposeTextureAndPostProcesses();\n\n      this._createMainTexture();\n\n      this._createTextureAndPostProcesses();\n    }\n  };\n  /**\n   * Determine if a given mesh will be used in the current effect.\n   * @param mesh mesh to test\n   * @returns true if the mesh will be used\n   */\n\n\n  EffectLayer.prototype.hasMesh = function (mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   * @returns true if the glow layer should be rendered\n   */\n\n\n  EffectLayer.prototype.shouldRender = function () {\n    return this.isEnabled && this._shouldRender;\n  };\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  EffectLayer.prototype._shouldRenderMesh = function (mesh) {\n    return true;\n  };\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n\n\n  EffectLayer.prototype._canRenderMesh = function (mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  };\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @returns true if it should render otherwise false\n   */\n\n\n  EffectLayer.prototype._shouldRenderEmissiveTextureForMesh = function () {\n    return true;\n  };\n  /**\n   * Renders the submesh passed in parameter to the generation map.\n   * @param subMesh\n   * @param enableAlphaMode\n   */\n\n\n  EffectLayer.prototype._renderSubMesh = function (subMesh, enableAlphaMode) {\n    var _a, _b;\n\n    if (enableAlphaMode === void 0) {\n      enableAlphaMode = false;\n    }\n\n    if (!this.shouldRender()) {\n      return;\n    }\n\n    var material = subMesh.getMaterial();\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = subMesh.getReplacementMesh();\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = subMesh.getEffectiveMesh();\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n    if (!material) {\n      return;\n    } // Do not block in blend mode.\n\n\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    } // Culling\n\n\n    var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n\n    var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n\n    var reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits); // Managing instances\n\n    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n\n    if (batch.mustReturn) {\n      return;\n    } // Early Exit per mesh\n\n\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n\n    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      var renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n\n      var drawWrapper = subMesh._getDrawWrapper();\n\n      if (!drawWrapper && renderingMaterial) {\n        drawWrapper = renderingMaterial._getDrawWrapper();\n      }\n\n      if (!drawWrapper) {\n        return;\n      }\n\n      var effect_1 = drawWrapper.effect;\n      engine.enableEffect(drawWrapper);\n\n      if (!hardwareInstancedRendering) {\n        var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : material.fillMode;\n\n        renderingMesh._bind(subMesh, effect_1, fillMode);\n      }\n\n      if (!renderingMaterial) {\n        effect_1.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect_1.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        effect_1.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n      } else {\n        renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n      }\n\n      if (!renderingMaterial) {\n        var needAlphaTest = material.needAlphaTesting();\n        var diffuseTexture = material.getAlphaTestTexture();\n        var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n        if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n          effect_1.setTexture(\"diffuseSampler\", diffuseTexture);\n          var textureMatrix = diffuseTexture.getTextureMatrix();\n\n          if (textureMatrix) {\n            effect_1.setMatrix(\"diffuseMatrix\", textureMatrix);\n          }\n        }\n\n        var opacityTexture = material.opacityTexture;\n\n        if (opacityTexture) {\n          effect_1.setTexture(\"opacitySampler\", opacityTexture);\n          effect_1.setFloat(\"opacityIntensity\", opacityTexture.level);\n          var textureMatrix = opacityTexture.getTextureMatrix();\n\n          if (textureMatrix) {\n            effect_1.setMatrix(\"opacityMatrix\", textureMatrix);\n          }\n        } // Glow emissive only\n\n\n        if (this._emissiveTextureAndColor.texture) {\n          effect_1.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n          effect_1.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n        } // Bones\n\n\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          var skeleton = renderingMesh.skeleton;\n\n          if (skeleton.isUsingTextureForMatrices) {\n            var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n\n            if (!boneTexture) {\n              return;\n            }\n\n            effect_1.setTexture(\"boneSampler\", boneTexture);\n            effect_1.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n          } else {\n            effect_1.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n          }\n        } // Morph targets\n\n\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);\n\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n          renderingMesh.morphTargetManager._bind(effect_1);\n        } // Alpha mode\n\n\n        if (enableAlphaMode) {\n          engine.setAlphaMode(material.alphaMode);\n        }\n      } // Draw\n\n\n      renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n        return effect_1.setMatrix(\"world\", world);\n      });\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  };\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  EffectLayer.prototype._useMeshMaterial = function (mesh) {\n    return false;\n  };\n  /**\n   * Rebuild the required buffers.\n   * @hidden Internal use only.\n   */\n\n\n  EffectLayer.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._generateIndexBuffer();\n  };\n  /**\n   * Dispose only the render target textures and post process.\n   */\n\n\n  EffectLayer.prototype._disposeTextureAndPostProcesses = function () {\n    this._mainTexture.dispose();\n\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n\n    this._postProcesses = [];\n\n    for (var i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n\n    this._textures = [];\n  };\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n\n\n  EffectLayer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    for (var _i = 0, _a = this._mergeDrawWrapper; _i < _a.length; _i++) {\n      var drawWrapper = _a[_i];\n      drawWrapper.dispose();\n    }\n\n    this._mergeDrawWrapper = []; // Clean textures and post processes\n\n    this._disposeTextureAndPostProcesses(); // Remove from scene\n\n\n    var index = this._scene.effectLayers.indexOf(this, 0);\n\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n\n\n  EffectLayer.prototype.getClassName = function () {\n    return \"EffectLayer\";\n  };\n  /**\n   * Creates an effect layer from parsed effect layer data\n   * @param parsedEffectLayer defines effect layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the effect layer information\n   * @returns a parsed effect Layer\n   */\n\n\n  EffectLayer.Parse = function (parsedEffectLayer, scene, rootUrl) {\n    var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  };\n  /**\n   * @param _\n   * @hidden\n   */\n\n\n  EffectLayer._SceneComponentInitialization = function (_) {\n    throw _WarnImport(\"EffectLayerSceneComponent\");\n  };\n\n  __decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n\n  __decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n\n  __decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n\n  __decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);\n\n  return EffectLayer;\n}();\n\nexport { EffectLayer };","map":{"version":3,"mappings":"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","names":["serialize","serializeAsColor4","serializeAsCameraReference","Tools","Observable","Color4","Engine","EngineStore","VertexBuffer","Texture","RenderTargetTexture","Material","MaterialHelper","_WarnImport","EffectFallbacks","DrawWrapper","name","scene","width","height","texture","color","_scene","LastCreatedScene","EffectLayer","_SceneComponentInitialization","_engine","getEngine","_maxSize","getCaps","maxTextureSize","effectLayers","push","_mergeDrawWrapper","_generateIndexBuffer","_generateVertexBuffer","Object","_effectLayerOptions","camera","renderingGroupId","_mainTexture","mesh","material","setMaterialForRendering","Array","isArray","i","length","currentMesh","_materialForRendering","uniqueId","options","__assign","mainTextureRatio","alphaBlendingMode","_setMainTextureSize","_createMainTexture","_createTextureAndPostProcesses","indices","_indexBuffer","createIndexBuffer","vertices","vertexBuffer","PositionKind","_vertexBuffers","mainTextureFixedSize","_mainTextureDesiredSize","getRenderWidth","getRenderHeight","needPOTTextures","GetExponentOfTwo","Math","floor","activeCamera","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","renderList","ignoreCameraViewport","id","customIsReadyFunction","refreshRate","isReady","subMeshes","subMesh","getMaterial","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","hasThinInstances","_this","_setEmissiveTextureAndColor","_isReady","_emissiveTextureAndColor","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","onBeforeRenderMainTextureObservable","notifyObservers","index","engine","setColorWrite","_renderSubMesh","data","previousAlphaMode","getAlphaMode","setAlphaMode","onClearObservable","add","clear","neutralColor","getBoundingBoxRenderer","boundingBoxRendererEnabled_1","enabled","onBeforeBindObservable","disableBoundingBoxesFromEffectLayer","onAfterUnbindObservable","defines","useInstances","emissiveTexture","getMesh","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","_a","currentRenderPassId","isReadyForSubMesh","_useMeshMaterial","attribs","uv1","uv2","needAlphaTest","needAlphaTesting","diffuseTexture","getAlphaTestTexture","needAlphaBlendFromDiffuse","hasAlpha","useAlphaFromDiffuseTexture","_useAlphaFromAlbedoTexture","isVerticesDataPresent","UV2Kind","coordinatesIndex","UVKind","gammaSpace","opacityTexture","ColorKind","hasVertexAlpha","fallbacks","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","skeleton","isUsingTextureForMatrices","bones","addCPUSkinningFallback","manager","morphTargetManager","morphInfluencers","numInfluencers","isUsingTextureForTargets","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","_addCustomEffectDefines","drawWrapper","_getDrawWrapper","undefined","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","effect","_postProcesses","numDraws","_numInternalDraws","currentEffect","_createMergeEffect","onBeforeComposeObservable","enableEffect","setState","bindBuffers","_internalRender","onAfterComposeObservable","size","getSize","onSizeChangedObservable","_disposeTextureAndPostProcesses","isEnabled","_shouldRender","needAlphaBlendingForMesh","enableAlphaMode","shouldRender","ownerMesh","replacementMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","_canRenderMesh","sideOrientation","overrideMaterialSideOrientation","mainDeterminant","_getWorldMatrixDeterminant","ClockWiseSideOrientation","CounterClockWiseSideOrientation","reverse","backFaceCulling","zOffset","cullBackFaces","zOffsetUnits","mustReturn","_shouldRenderMesh","onBeforeRenderMeshToEffect","render","_b","effect_1","fillMode","forcePointsCloud","PointFillMode","forceWireframe","WireFrameFillMode","_bind","setMatrix","getTransformMatrix","getWorldMatrix","setFloat4","r","g","b","a","bindForSubMesh","setTexture","textureMatrix","getTextureMatrix","setFloat","level","boneTexture","getTransformMatrixTexture","setMatrices","getTransformMatrices","BindMorphTargetParameters","alphaMode","_processRendering","isInstance","world","resetRefreshCounter","onAfterRenderMeshToEffect","vb","_rebuild","dispose","_textures","_releaseBuffer","_i","indexOf","splice","onDisposeObservable","parsedEffectLayer","rootUrl","effectLayerType","Instantiate","customType","Parse","_","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/effectLayer.ts"],"sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    /**\r\n     * @param _\r\n     * @hidden\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._mainTexture.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene\r\n    ) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        for (const id in this._materialForRendering) {\r\n            const [mesh, material] = this._materialForRendering[id];\r\n            this._mainTexture.setMaterialForRendering(mesh, material);\r\n        }\r\n\r\n        this._mainTexture.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number) => {\r\n            if (!mesh.isReady(false)) {\r\n                return false;\r\n            }\r\n            if (refreshRate === 0 && mesh.subMeshes) {\r\n                // full check: check that the effects are ready\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        if (this._scene.getBoundingBoxRenderer) {\r\n            const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n            this._mainTexture.onBeforeBindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._mainTexture.onAfterUnbindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    [\r\n                        \"world\",\r\n                        \"mBones\",\r\n                        \"viewProjection\",\r\n                        \"glowColor\",\r\n                        \"morphTargetInfluences\",\r\n                        \"boneTextureWidth\",\r\n                        \"diffuseMatrix\",\r\n                        \"emissiveMatrix\",\r\n                        \"opacityMatrix\",\r\n                        \"opacityIntensity\",\r\n                        \"morphTargetTextureInfo\",\r\n                        \"morphTargetTextureIndices\",\r\n                    ],\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: morphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        // Check\r\n        let isReady = true;\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = isReady && currentEffect.effect!.isReady();\r\n        }\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalRender(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     * @param subMesh\r\n     * @param enableAlphaMode\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\r\n        } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : material.fillMode;\r\n                renderingMesh._bind(subMesh, effect, fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTesting();\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}