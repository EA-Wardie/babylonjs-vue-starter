{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\n */\n\nvar MeshExploder =\n/** @class */\nfunction () {\n  /**\n   * Explodes meshes from a center mesh.\n   * @param meshes The meshes to explode.\n   * @param centerMesh The mesh to be center of explosion.\n   */\n  function MeshExploder(meshes, centerMesh) {\n    this._meshesOrigins = [];\n    this._toCenterVectors = [];\n    this._scaledDirection = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    this._centerPosition = Vector3.Zero();\n    this._meshes = meshes.slice();\n\n    if (centerMesh) {\n      this._centerMesh = centerMesh;\n    } else {\n      this._setCenterMesh();\n    }\n\n    var centerMeshIndex = this._meshes.indexOf(this._centerMesh);\n\n    if (centerMeshIndex >= 0) {\n      this._meshes.splice(centerMeshIndex, 1);\n    }\n\n    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\n        this._toCenterVectors[index] = Vector3.Zero();\n\n        if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\n        }\n      }\n    }\n  }\n\n  MeshExploder.prototype._setCenterMesh = function () {\n    var averageCenter = Vector3.Zero();\n    var totalCenters = Vector3.Zero();\n    var shortestToCenter = Number.MAX_VALUE;\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        var boundingInfo = mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\n        }\n      }\n    }\n\n    averageCenter = totalCenters.scale(1 / this._meshes.length);\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        var boundingInfo = mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          var distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\n\n          if (distanceToCenter < shortestToCenter) {\n            this._centerMesh = mesh;\n            shortestToCenter = distanceToCenter;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Get class name\n   * @returns \"MeshExploder\"\n   */\n\n\n  MeshExploder.prototype.getClassName = function () {\n    return \"MeshExploder\";\n  };\n  /**\n   * \"Exploded meshes\"\n   * @returns Array of meshes with the centerMesh at index 0.\n   */\n\n\n  MeshExploder.prototype.getMeshes = function () {\n    var meshArray = this._meshes.slice();\n\n    meshArray.unshift(this._centerMesh);\n    return meshArray;\n  };\n  /**\n   * Explodes meshes giving a specific direction\n   * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\n   */\n\n\n  MeshExploder.prototype.explode = function (direction) {\n    if (direction === void 0) {\n      direction = 1.0;\n    }\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\n        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\n\n        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\n\n        this._meshes[index].setAbsolutePosition(this._newPosition);\n      }\n    }\n\n    this._centerMesh.setAbsolutePosition(this._centerPosition);\n  };\n\n  return MeshExploder;\n}();\n\nexport { MeshExploder };","map":{"version":3,"mappings":"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","names":["Vector3","meshes","centerMesh","Zero","_meshes","slice","_centerMesh","_setCenterMesh","centerMeshIndex","indexOf","splice","_centerPosition","getAbsolutePosition","clone","index","length","mesh","_meshesOrigins","_toCenterVectors","hasBoundingInfo","getBoundingInfo","boundingBox","centerWorld","subtractToRef","MeshExploder","averageCenter","totalCenters","shortestToCenter","Number","MAX_VALUE","boundingInfo","addInPlace","scale","distanceToCenter","subtract","lengthSquared","meshArray","unshift","direction","scaleToRef","_scaledDirection","addToRef","_newPosition","setAbsolutePosition"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/meshExploder.ts"],"sourcesContent":["import type { Mesh } from \"../Meshes/mesh\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\r\nexport class MeshExploder {\r\n    private _centerMesh: Mesh;\r\n    private _meshes: Array<Mesh>;\r\n    private _meshesOrigins: Array<Vector3> = [];\r\n    private _toCenterVectors: Array<Vector3> = [];\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n    private _centerPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Explodes meshes from a center mesh.\r\n     * @param meshes The meshes to explode.\r\n     * @param centerMesh The mesh to be center of explosion.\r\n     */\r\n    constructor(meshes: Array<Mesh>, centerMesh?: Mesh) {\r\n        this._meshes = meshes.slice();\r\n\r\n        if (centerMesh) {\r\n            this._centerMesh = centerMesh;\r\n        } else {\r\n            this._setCenterMesh();\r\n        }\r\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\r\n        if (centerMeshIndex >= 0) {\r\n            this._meshes.splice(centerMeshIndex, 1);\r\n        }\r\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\r\n                this._toCenterVectors[index] = Vector3.Zero();\r\n                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setCenterMesh(): void {\r\n        let averageCenter = Vector3.Zero();\r\n        const totalCenters = Vector3.Zero();\r\n        let shortestToCenter = Number.MAX_VALUE;\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\r\n                }\r\n            }\r\n        }\r\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\r\n                    if (distanceToCenter < shortestToCenter) {\r\n                        this._centerMesh = mesh;\r\n                        shortestToCenter = distanceToCenter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get class name\r\n     * @returns \"MeshExploder\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshExploder\";\r\n    }\r\n\r\n    /**\r\n     * \"Exploded meshes\"\r\n     * @returns Array of meshes with the centerMesh at index 0.\r\n     */\r\n    public getMeshes(): Array<Mesh> {\r\n        const meshArray = this._meshes.slice();\r\n        meshArray.unshift(this._centerMesh);\r\n        return meshArray;\r\n    }\r\n\r\n    /**\r\n     * Explodes meshes giving a specific direction\r\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n     */\r\n    public explode(direction: number = 1.0): void {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\r\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\r\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\r\n                this._meshes[index].setAbsolutePosition(this._newPosition);\r\n            }\r\n        }\r\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}