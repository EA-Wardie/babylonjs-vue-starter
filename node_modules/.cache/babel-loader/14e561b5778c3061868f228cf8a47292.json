{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\n\nvar Light =\n/** @class */\nfunction (_super) {\n  __extends(Light, _super);\n  /**\n   * Creates a Light object in the scene.\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\n   * @param name The friendly name of the light\n   * @param scene The scene the light belongs too\n   */\n\n\n  function Light(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\n     * Diffuse gives the basic color to an object.\n     */\n\n\n    _this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Specular produces a highlight color on an object.\n     * Note: This is not affecting PBR materials.\n     */\n\n    _this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Defines the falloff type for this light. This lets overriding how punctual light are\n     * falling off base on range or angle.\n     * This can be set to any values in Light.FALLOFF_x.\n     *\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n     * other types of materials.\n     */\n\n    _this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\n     * Strength of the light.\n     * Note: By default it is define in the framework own unit.\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n     */\n\n    _this.intensity = 1.0;\n    _this._range = Number.MAX_VALUE;\n    _this._inverseSquaredRange = 0;\n    /**\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n     * of light.\n     */\n\n    _this._photometricScale = 1.0;\n    _this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    _this._radius = 0.00001;\n    /**\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n     * exceeding the number allowed of the materials.\n     */\n\n    _this.renderPriority = 0;\n    _this._shadowEnabled = true;\n    _this._excludeWithLayerMask = 0;\n    _this._includeOnlyWithLayerMask = 0;\n    _this._lightmapMode = 0;\n    /**\n     * @hidden Internal use only.\n     */\n\n    _this._excludedMeshesIds = new Array();\n    /**\n     * @hidden Internal use only.\n     */\n\n    _this._includedOnlyMeshesIds = new Array();\n    /** @hidden */\n\n    _this._isLight = true;\n\n    _this.getScene().addLight(_this);\n\n    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), undefined, undefined, name);\n\n    _this._buildUniformLayout();\n\n    _this.includedOnlyMeshes = new Array();\n    _this.excludedMeshes = new Array();\n\n    _this._resyncMeshes();\n\n    return _this;\n  }\n\n  Object.defineProperty(Light.prototype, \"range\", {\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    get: function get() {\n      return this._range;\n    },\n\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    set: function set(value) {\n      this._range = value;\n      this._inverseSquaredRange = 1.0 / (this.range * this.range);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"intensityMode\", {\n    /**\n     * Gets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    get: function get() {\n      return this._intensityMode;\n    },\n\n    /**\n     * Sets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    set: function set(value) {\n      this._intensityMode = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"radius\", {\n    /**\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    get: function get() {\n      return this._radius;\n    },\n\n    /**\n     * sets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    set: function set(value) {\n      this._radius = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"shadowEnabled\", {\n    /**\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    get: function get() {\n      return this._shadowEnabled;\n    },\n\n    /**\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    set: function set(value) {\n      if (this._shadowEnabled === value) {\n        return;\n      }\n\n      this._shadowEnabled = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includedOnlyMeshes\", {\n    /**\n     * Gets the only meshes impacted by this light.\n     */\n    get: function get() {\n      return this._includedOnlyMeshes;\n    },\n\n    /**\n     * Sets the only meshes impacted by this light.\n     */\n    set: function set(value) {\n      this._includedOnlyMeshes = value;\n\n      this._hookArrayForIncludedOnly(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludedMeshes\", {\n    /**\n     * Gets the meshes not impacted by this light.\n     */\n    get: function get() {\n      return this._excludedMeshes;\n    },\n\n    /**\n     * Sets the meshes not impacted by this light.\n     */\n    set: function set(value) {\n      this._excludedMeshes = value;\n\n      this._hookArrayForExcluded(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludeWithLayerMask\", {\n    /**\n     * Gets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    get: function get() {\n      return this._excludeWithLayerMask;\n    },\n\n    /**\n     * Sets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    set: function set(value) {\n      this._excludeWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includeOnlyWithLayerMask\", {\n    /**\n     * Gets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    get: function get() {\n      return this._includeOnlyWithLayerMask;\n    },\n\n    /**\n     * Sets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    set: function set(value) {\n      this._includeOnlyWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"lightmapMode\", {\n    /**\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    get: function get() {\n      return this._lightmapMode;\n    },\n\n    /**\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    set: function set(value) {\n      if (this._lightmapMode === value) {\n        return;\n      }\n\n      this._lightmapMode = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the passed Effect \"effect\" with the Light textures.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The light\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  Light.prototype.transferTexturesToEffect = function (effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  };\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n\n\n  Light.prototype._bindLight = function (lightIndex, scene, effect, useSpecular, receiveShadows) {\n    if (receiveShadows === void 0) {\n      receiveShadows = true;\n    }\n\n    var iAsString = lightIndex.toString();\n    var needUpdate = false;\n\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n\n    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      this._lastUseSpecular = useSpecular;\n      var scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n\n      needUpdate = true;\n    } // Textures might still need to be rebound.\n\n\n    this.transferTexturesToEffect(effect, iAsString); // Shadows\n\n    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n      var shadowGenerator = this.getShadowGenerator();\n\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    } else {\n      this._uniformBuffer.bindUniformBuffer();\n    }\n  };\n  /**\n   * Returns the string \"Light\".\n   * @returns the class name\n   */\n\n\n  Light.prototype.getClassName = function () {\n    return \"Light\";\n  };\n  /**\n   * Converts the light information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable light info\n   */\n\n\n  Light.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n\n    if (this.animations) {\n      for (var i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n\n    return ret;\n  };\n  /** @hidden */\n\n\n  Light.prototype._syncParentEnabledState = function () {\n    _super.prototype._syncParentEnabledState.call(this);\n\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  };\n  /**\n   * Set the enabled state of this node.\n   * @param value - the new enabled state\n   */\n\n\n  Light.prototype.setEnabled = function (value) {\n    _super.prototype.setEnabled.call(this, value);\n\n    this._resyncMeshes();\n  };\n  /**\n   * Returns the Light associated shadow generator if any.\n   * @return the associated shadow generator.\n   */\n\n\n  Light.prototype.getShadowGenerator = function () {\n    return this._shadowGenerator;\n  };\n  /**\n   * Returns a Vector3, the absolute light position in the World.\n   * @returns the world space position of the light\n   */\n\n\n  Light.prototype.getAbsolutePosition = function () {\n    return Vector3.Zero();\n  };\n  /**\n   * Specifies if the light will affect the passed mesh.\n   * @param mesh The mesh to test against the light\n   * @return true the mesh is affected otherwise, false.\n   */\n\n\n  Light.prototype.canAffectMesh = function (mesh) {\n    if (!mesh) {\n      return true;\n    }\n\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n\n\n  Light.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    if (this._shadowGenerator) {\n      this._shadowGenerator.dispose();\n\n      this._shadowGenerator = null;\n    } // Animations\n\n\n    this.getScene().stopAnimation(this);\n\n    if (this._parentContainer) {\n      var index = this._parentContainer.lights.indexOf(this);\n\n      if (index > -1) {\n        this._parentContainer.lights.splice(index, 1);\n      }\n\n      this._parentContainer = null;\n    } // Remove from meshes\n\n\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._removeLightSource(this, true);\n    }\n\n    this._uniformBuffer.dispose(); // Remove from scene\n\n\n    this.getScene().removeLight(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\n   * Returns the light type ID (integer).\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n\n\n  Light.prototype.getTypeID = function () {\n    return 0;\n  };\n  /**\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n   * @returns the scaled intensity in intensity mode unit\n   */\n\n\n  Light.prototype.getScaledIntensity = function () {\n    return this._photometricScale * this.intensity;\n  };\n  /**\n   * Returns a new Light object, named \"name\", from the current one.\n   * @param name The name of the cloned light\n   * @param newParent The parent of this light, if it has one\n   * @returns the new created light\n   */\n\n\n  Light.prototype.clone = function (name, newParent) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n\n    if (!constructor) {\n      return null;\n    }\n\n    var clonedLight = SerializationHelper.Clone(constructor, this);\n\n    if (name) {\n      clonedLight.name = name;\n    }\n\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n\n    clonedLight.setEnabled(this.isEnabled());\n    this.onClonedObservable.notifyObservers(clonedLight);\n    return clonedLight;\n  };\n  /**\n   * Serializes the current light into a Serialization object.\n   * @returns the serialized object.\n   */\n\n\n  Light.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.uniqueId = this.uniqueId; // Type\n\n    serializationObject.type = this.getTypeID(); // Parent\n\n    if (this.parent) {\n      serializationObject.parentId = this.parent.uniqueId;\n    } // Inclusion / exclusions\n\n\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(function (mesh) {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(function (mesh) {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    serializationObject.isEnabled = this.isEnabled();\n    return serializationObject;\n  };\n  /**\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n   * This new light is named \"name\" and added to the passed scene.\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\n   * @param name The friendly name of the light\n   * @param scene The scene the new light will belong to\n   * @returns the constructor function\n   */\n\n\n  Light.GetConstructorFromName = function (type, name, scene) {\n    var constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n\n    if (constructorFunc) {\n      return constructorFunc;\n    } // Default to no light for none present once.\n\n\n    return null;\n  };\n  /**\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n   * @param parsedLight The JSON representation of the light\n   * @param scene The scene to create the parsed light in\n   * @returns the created light after parsing\n   */\n\n\n  Light.Parse = function (parsedLight, scene) {\n    var constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n\n    if (!constructor) {\n      return null;\n    }\n\n    var light = SerializationHelper.Parse(constructor, parsedLight, scene); // Inclusion / exclusions\n\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    } // Parent\n\n\n    if (parsedLight.parentId !== undefined) {\n      light._waitingParentId = parsedLight.parentId;\n    } // Falloff\n\n\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    } // Lightmaps\n\n\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    } // Animations\n\n\n    if (parsedLight.animations) {\n      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        var parsedAnimation = parsedLight.animations[animationIndex];\n        var internalClass = GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    } // Check if isEnabled is defined to be back compatible with prior serialized versions.\n\n\n    if (parsedLight.isEnabled !== undefined) {\n      light.setEnabled(parsedLight.isEnabled);\n    }\n\n    return light;\n  };\n\n  Light.prototype._hookArrayForExcluded = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {\n        var item = items_1[_a];\n\n        item._resyncLightSource(_this);\n      }\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      for (var _i = 0, deleted_1 = deleted; _i < deleted_1.length; _i++) {\n        var item = deleted_1[_i];\n\n        item._resyncLightSource(_this);\n      }\n\n      return deleted;\n    };\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var item = array_1[_i];\n\n      item._resyncLightSource(this);\n    }\n  };\n\n  Light.prototype._hookArrayForIncludedOnly = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._resyncMeshes();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._resyncMeshes();\n\n      return deleted;\n    };\n\n    this._resyncMeshes();\n  };\n\n  Light.prototype._resyncMeshes = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._resyncLightSource(this);\n    }\n  };\n  /**\n   * Forces the meshes to update their light related information in their rendering used effects\n   * @hidden Internal Use Only\n   */\n\n\n  Light.prototype._markMeshesAsLightDirty = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  };\n  /**\n   * Recomputes the cached photometric scale if needed.\n   */\n\n\n  Light.prototype._computePhotometricScale = function () {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  };\n  /**\n   * Returns the Photometric Scale according to the light type and intensity mode.\n   */\n\n\n  Light.prototype._getPhotometricScale = function () {\n    var photometricScale = 0.0;\n    var lightTypeID = this.getTypeID(); //get photometric mode\n\n    var photometricMode = this.intensityMode;\n\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    } //compute photometric scale\n\n\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            {\n              // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n              // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n              var apexAngleRadians = this.radius; // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n\n              apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n              var solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n              photometricScale = solidAngle;\n              break;\n            }\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemispheric light.\n        photometricScale = 1.0;\n        break;\n    }\n\n    return photometricScale;\n  };\n  /**\n   * Reorder the light in the scene according to their defined priority.\n   * @hidden Internal Use Only\n   */\n\n\n  Light.prototype._reorderLightsInScene = function () {\n    var scene = this.getScene();\n\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n\n    this.getScene().sortLightsByPriority();\n  };\n  /**\n   * Falloff Default: light is falling off following the material specification:\n   * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n   */\n\n\n  Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n  /**\n   * Falloff Physical: light is falling off following the inverse squared distance law.\n   */\n\n  Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n  /**\n   * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n   * to enhance interoperability with other engines.\n   */\n\n  Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n  /**\n   * Falloff Standard: light is falling off like in the standard material\n   * to enhance interoperability with other materials.\n   */\n\n  Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD; //lightmapMode Consts\n\n  /**\n   * If every light affecting the material is in this lightmapMode,\n   * material.lightmapTexture adds or multiplies\n   * (depends on material.useLightmapAsShadowmap)\n   * after every other light calculations.\n   */\n\n  Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n  /**\n   * material.lightmapTexture as only diffuse lighting from this light\n   * adds only specular lighting from this light\n   * adds dynamic shadows\n   */\n\n  Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n  /**\n   * material.lightmapTexture as only lighting\n   * no light calculation from this light\n   * only adds dynamic shadows from this light\n   */\n\n  Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY; // Intensity Mode Consts\n\n  /**\n   * Each light type uses the default quantity according to its type:\n   *      point/spot lights use luminous intensity\n   *      directional lights use illuminance\n   */\n\n  Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n  /**\n   * lumen (lm)\n   */\n\n  Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n  /**\n   * candela (lm/sr)\n   */\n\n  Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n  /**\n   * lux (lm/m^2)\n   */\n\n  Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n  /**\n   * nit (cd/m^2)\n   */\n\n  Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE; // Light types ids const.\n\n  /**\n   * Light type const id of the point light.\n   */\n\n  Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n  /**\n   * Light type const id of the directional light.\n   */\n\n  Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n  /**\n   * Light type const id of the spot light.\n   */\n\n  Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n  /**\n   * Light type const id of the hemispheric light.\n   */\n\n  Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n\n  __decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n\n  __decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"intensity\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"range\", null);\n\n  __decorate([serialize()], Light.prototype, \"intensityMode\", null);\n\n  __decorate([serialize()], Light.prototype, \"radius\", null);\n\n  __decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n\n  __decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n\n  __decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n\n  __decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n\n  __decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n\n  __decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);\n\n  return Light;\n}(Node);\n\nexport { Light };","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","serializeAsColor3","expandToProperty","Vector3","Color3","TmpColors","Node","UniformBuffer","GetClass","LightConstants","__extends","name","scene","_super","_this","Light","FALLOFF_DEFAULT","Number","MAX_VALUE","INTENSITYMODE_AUTOMATIC","Array","getScene","addLight","_uniformBuffer","getEngine","undefined","_buildUniformLayout","includedOnlyMeshes","excludedMeshes","_resyncMeshes","Object","_range","value","_inverseSquaredRange","range","_intensityMode","_computePhotometricScale","_radius","_shadowEnabled","_markMeshesAsLightDirty","_includedOnlyMeshes","_hookArrayForIncludedOnly","_excludedMeshes","_hookArrayForExcluded","_excludeWithLayerMask","_includeOnlyWithLayerMask","_lightmapMode","effect","lightIndex","useSpecular","receiveShadows","iAsString","toString","needUpdate","bindToEffect","_renderId","getRenderId","_lastUseSpecular","useUbo","scaledIntensity","getScaledIntensity","transferToEffect","diffuse","scaleToRef","updateColor4","specular","radius","transferTexturesToEffect","shadowsEnabled","shadowEnabled","shadowGenerator","getShadowGenerator","bindShadowLight","update","bindUniformBuffer","fullDetails","ret","getTypeID","animations","i","length","_syncParentEnabledState","call","isDisposed","setEnabled","_shadowGenerator","Zero","mesh","indexOf","includeOnlyWithLayerMask","layerMask","excludeWithLayerMask","doNotRecurse","disposeMaterialAndTextures","dispose","stopAnimation","_parentContainer","index","lights","splice","meshes","_i","_removeLightSource","removeLight","_photometricScale","intensity","newParent","constructor","GetConstructorFromName","clonedLight","Clone","parent","isEnabled","onClonedObservable","notifyObservers","serializationObject","Serialize","uniqueId","type","parentId","excludedMeshesIds","forEach","push","id","includedOnlyMeshesIds","AppendSerializedAnimations","ranges","serializeAnimationRanges","constructorFunc","Construct","parsedLight","light","Parse","_excludedMeshesIds","_includedOnlyMeshesIds","_waitingParentId","falloffType","lightmapMode","animationIndex","parsedAnimation","internalClass","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","array","oldPush","items","result","apply","_a","item","_resyncLightSource","oldSplice","deleteCount","deleted","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","photometricScale","lightTypeID","photometricMode","intensityMode","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","Math","PI","INTENSITYMODE_LUMINANCE","apexAngleRadians","max","solidAngle","cos","LIGHTTYPEID_HEMISPHERICLIGHT","_renderPriority","requireLightSorting","sortLightsByPriority","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Lights/light.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generator associated to the light.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _shadowGenerator: Nullable<IShadowGenerator>;\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @return the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return this._shadowGenerator;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @return true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.dispose();\r\n            this._shadowGenerator = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.uniqueId;\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}