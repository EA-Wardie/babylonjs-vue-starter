{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { __extends } from \"tslib\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { LinesMesh, InstancedLinesMesh } from \"../Meshes/linesMesh.js\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport \"../Shaders/line.fragment.js\";\nimport \"../Shaders/line.vertex.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n\nAbstractMesh.prototype.disableEdgesRendering = function () {\n  if (this._edgesRenderer) {\n    this._edgesRenderer.dispose();\n\n    this._edgesRenderer = null;\n  }\n\n  return this;\n};\n\nAbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n  if (epsilon === void 0) {\n    epsilon = 0.95;\n  }\n\n  if (checkVerticesInsteadOfIndices === void 0) {\n    checkVerticesInsteadOfIndices = false;\n  }\n\n  this.disableEdgesRendering();\n  this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);\n  return this;\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"edgesRenderer\", {\n  get: function get() {\n    return this._edgesRenderer;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nLinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {\n  if (epsilon === void 0) {\n    epsilon = 0.95;\n  }\n\n  if (checkVerticesInsteadOfIndices === void 0) {\n    checkVerticesInsteadOfIndices = false;\n  }\n\n  this.disableEdgesRendering();\n  this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);\n  return this;\n}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nInstancedLinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {\n  if (epsilon === void 0) {\n    epsilon = 0.95;\n  }\n\n  if (checkVerticesInsteadOfIndices === void 0) {\n    checkVerticesInsteadOfIndices = false;\n  }\n\n  LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);\n  return this;\n};\n/**\n * FaceAdjacencies Helper class to generate edges\n */\n\n\nvar FaceAdjacencies =\n/** @class */\nfunction () {\n  function FaceAdjacencies() {\n    this.edges = new Array();\n    this.edgesConnectedCount = 0;\n  }\n\n  return FaceAdjacencies;\n}();\n/**\n * This class is used to generate edges of the mesh that could then easily be rendered in a scene.\n */\n\n\nvar EdgesRenderer =\n/** @class */\nfunction () {\n  /**\n   * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.\n   * Beware when you use this class with complex objects as the adjacencies computation can be really long\n   * @param  source Mesh used to create edges\n   * @param  epsilon sum of angles in adjacency to check for edge\n   * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true\n   * @param  generateEdgesLines - should generate Lines or only prepare resources.\n   * @param  options The options to apply when generating the edges\n   */\n  function EdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices, generateEdgesLines, options) {\n    if (epsilon === void 0) {\n      epsilon = 0.95;\n    }\n\n    if (checkVerticesInsteadOfIndices === void 0) {\n      checkVerticesInsteadOfIndices = false;\n    }\n\n    if (generateEdgesLines === void 0) {\n      generateEdgesLines = true;\n    }\n\n    var _this = this;\n\n    var _a;\n    /**\n     * Define the size of the edges with an orthographic camera\n     */\n\n\n    this.edgesWidthScalerForOrthographic = 1000.0;\n    /**\n     * Define the size of the edges with a perspective camera\n     */\n\n    this.edgesWidthScalerForPerspective = 50.0;\n    this._linesPositions = new Array();\n    this._linesNormals = new Array();\n    this._linesIndices = new Array();\n    this._buffers = {};\n    this._buffersForInstances = {};\n    this._checkVerticesInsteadOfIndices = false;\n    /** Gets or sets a boolean indicating if the edgesRenderer is active */\n\n    this.isEnabled = true;\n    /**\n     * List of instances to render in case the source mesh has instances\n     */\n\n    this.customInstances = new SmartArray(32);\n    this._source = source;\n    this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;\n    this._options = options !== null && options !== void 0 ? options : null;\n    this._epsilon = epsilon;\n\n    if (this._source.getScene().getEngine().isWebGPU) {\n      this._drawWrapper = new DrawWrapper(source.getEngine());\n    }\n\n    this._prepareRessources();\n\n    if (generateEdgesLines) {\n      if ((_a = options === null || options === void 0 ? void 0 : options.useAlternateEdgeFinder) !== null && _a !== void 0 ? _a : true) {\n        this._generateEdgesLinesAlternate();\n      } else {\n        this._generateEdgesLines();\n      }\n    }\n\n    this._meshRebuildObserver = this._source.onRebuildObservable.add(function () {\n      _this._rebuild();\n    });\n    this._meshDisposeObserver = this._source.onDisposeObservable.add(function () {\n      _this.dispose();\n    });\n  }\n\n  Object.defineProperty(EdgesRenderer.prototype, \"linesPositions\", {\n    /** Gets the vertices generated by the edge renderer */\n    get: function get() {\n      return this._linesPositions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EdgesRenderer.prototype, \"linesNormals\", {\n    /** Gets the normals generated by the edge renderer */\n    get: function get() {\n      return this._linesNormals;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EdgesRenderer.prototype, \"linesIndices\", {\n    /** Gets the indices generated by the edge renderer */\n    get: function get() {\n      return this._linesIndices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EdgesRenderer.prototype, \"lineShader\", {\n    /**\n     * Gets or sets the shader used to draw the lines\n     */\n    get: function get() {\n      return this._lineShader;\n    },\n    set: function set(shader) {\n      this._lineShader = shader;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EdgesRenderer._GetShader = function (scene) {\n    if (!scene._edgeRenderLineShader) {\n      var shader = new ShaderMaterial(\"lineShader\", scene, \"line\", {\n        attributes: [\"position\", \"normal\"],\n        uniforms: [\"world\", \"viewProjection\", \"color\", \"width\", \"aspectRatio\"]\n      }, false);\n      shader.disableDepthWrite = true;\n      shader.backFaceCulling = false;\n      shader.checkReadyOnEveryCall = scene.getEngine().isWebGPU;\n      scene._edgeRenderLineShader = shader;\n    }\n\n    return scene._edgeRenderLineShader;\n  };\n\n  EdgesRenderer.prototype._prepareRessources = function () {\n    if (this._lineShader) {\n      return;\n    }\n\n    this._lineShader = EdgesRenderer._GetShader(this._source.getScene());\n  };\n  /** @hidden */\n\n\n  EdgesRenderer.prototype._rebuild = function () {\n    var buffer = this._buffers[VertexBuffer.PositionKind];\n\n    if (buffer) {\n      buffer._rebuild();\n    }\n\n    buffer = this._buffers[VertexBuffer.NormalKind];\n\n    if (buffer) {\n      buffer._rebuild();\n    }\n\n    var scene = this._source.getScene();\n\n    var engine = scene.getEngine();\n    this._ib = engine.createIndexBuffer(this._linesIndices);\n  };\n  /**\n   * Releases the required resources for the edges renderer\n   */\n\n\n  EdgesRenderer.prototype.dispose = function () {\n    var _a;\n\n    this._source.onRebuildObservable.remove(this._meshRebuildObserver);\n\n    this._source.onDisposeObservable.remove(this._meshDisposeObserver);\n\n    var buffer = this._buffers[VertexBuffer.PositionKind];\n\n    if (buffer) {\n      buffer.dispose();\n      this._buffers[VertexBuffer.PositionKind] = null;\n    }\n\n    buffer = this._buffers[VertexBuffer.NormalKind];\n\n    if (buffer) {\n      buffer.dispose();\n      this._buffers[VertexBuffer.NormalKind] = null;\n    }\n\n    if (this._ib) {\n      this._source.getScene().getEngine()._releaseBuffer(this._ib);\n    }\n\n    this._lineShader.dispose();\n\n    (_a = this._drawWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n  };\n\n  EdgesRenderer.prototype._processEdgeForAdjacencies = function (pa, pb, p0, p1, p2) {\n    if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {\n      return 0;\n    }\n\n    if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {\n      return 1;\n    }\n\n    if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {\n      return 2;\n    }\n\n    return -1;\n  };\n\n  EdgesRenderer.prototype._processEdgeForAdjacenciesWithVertices = function (pa, pb, p0, p1, p2) {\n    var eps = 1e-10;\n\n    if (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps) || pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps)) {\n      return 0;\n    }\n\n    if (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps) || pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps)) {\n      return 1;\n    }\n\n    if (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps) || pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps)) {\n      return 2;\n    }\n\n    return -1;\n  };\n  /**\n   * Checks if the pair of p0 and p1 is en edge\n   * @param faceIndex\n   * @param edge\n   * @param faceNormals\n   * @param  p0\n   * @param  p1\n   * @private\n   */\n\n\n  EdgesRenderer.prototype._checkEdge = function (faceIndex, edge, faceNormals, p0, p1) {\n    var needToCreateLine;\n\n    if (edge === undefined) {\n      needToCreateLine = true;\n    } else {\n      var dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);\n      needToCreateLine = dotProduct < this._epsilon;\n    }\n\n    if (needToCreateLine) {\n      this.createLine(p0, p1, this._linesPositions.length / 3);\n    }\n  };\n  /**\n   * push line into the position, normal and index buffer\n   * @param p0\n   * @param p1\n   * @param offset\n   * @protected\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  EdgesRenderer.prototype.createLine = function (p0, p1, offset) {\n    // Positions\n    this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z); // Normals\n\n\n    this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1); // Indices\n\n\n    this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);\n  };\n  /**\n   * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm\n   * @param edgePoints\n   * @param indexTriangle\n   * @param indices\n   * @param remapVertexIndices\n   */\n\n\n  EdgesRenderer.prototype._tessellateTriangle = function (edgePoints, indexTriangle, indices, remapVertexIndices) {\n    var makePointList = function makePointList(edgePoints, pointIndices, firstIndex) {\n      if (firstIndex >= 0) {\n        pointIndices.push(firstIndex);\n      }\n\n      for (var i = 0; i < edgePoints.length; ++i) {\n        pointIndices.push(edgePoints[i][0]);\n      }\n    };\n\n    var startEdge = 0;\n\n    if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {\n      startEdge = 1;\n    } else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {\n      startEdge = 2;\n    }\n\n    for (var e = 0; e < 3; ++e) {\n      if (e === startEdge) {\n        edgePoints[e].sort(function (a, b) {\n          return a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0;\n        });\n      } else {\n        edgePoints[e].sort(function (a, b) {\n          return a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0;\n        });\n      }\n    }\n\n    var mainPointIndices = [],\n        otherPointIndices = [];\n    makePointList(edgePoints[startEdge], mainPointIndices, -1);\n    var numMainPoints = mainPointIndices.length;\n\n    for (var i = startEdge + 2; i >= startEdge + 1; --i) {\n      makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + (i + 1) % 3]] : -1);\n    }\n\n    var numOtherPoints = otherPointIndices.length;\n    var idxMain = 0;\n    var idxOther = 0;\n    indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);\n    indices.push(remapVertexIndices[indices[indexTriangle + (startEdge + 1) % 3]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);\n    var bucketIsMain = numMainPoints <= numOtherPoints;\n    var bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;\n    var bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;\n    var bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;\n    var winding = bucketIsMain ? 0 : 1;\n    var numTris = numMainPoints + numOtherPoints - 2;\n    var bucketIdx = bucketIsMain ? idxMain : idxOther;\n    var nbucketIdx = bucketIsMain ? idxOther : idxMain;\n    var bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;\n    var nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;\n    var bucket = 0;\n\n    while (numTris-- > 0) {\n      if (winding) {\n        indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);\n      } else {\n        indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);\n      }\n\n      bucket += bucketStep;\n      var lastIdx = void 0;\n\n      if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {\n        lastIdx = bucketPoints[++bucketIdx];\n        bucket -= bucketLimit;\n      } else {\n        lastIdx = nbucketPoints[++nbucketIdx];\n      }\n\n      indices.push(lastIdx);\n    }\n\n    indices[indexTriangle + 0] = indices[indices.length - 3];\n    indices[indexTriangle + 1] = indices[indices.length - 2];\n    indices[indexTriangle + 2] = indices[indices.length - 1];\n    indices.length = indices.length - 3;\n  };\n\n  EdgesRenderer.prototype._generateEdgesLinesAlternate = function () {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n\n    var indices = this._source.getIndices();\n\n    if (!indices || !positions) {\n      return;\n    }\n\n    if (!Array.isArray(indices)) {\n      indices = Tools.SliceToArray(indices);\n    }\n    /**\n     * Find all vertices that are at the same location (with an epsilon) and remapp them on the same vertex\n     */\n\n\n    var useFastVertexMerger = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.useFastVertexMerger) !== null && _b !== void 0 ? _b : true;\n    var epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.epsilonVertexMerge) !== null && _d !== void 0 ? _d : 1e-6) / Math.log(10)) : (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.epsilonVertexMerge) !== null && _f !== void 0 ? _f : 1e-6;\n    var remapVertexIndices = [];\n    var uniquePositions = []; // list of unique index of vertices - needed for tessellation\n\n    if (useFastVertexMerger) {\n      var mapVertices = {};\n\n      for (var v1 = 0; v1 < positions.length; v1 += 3) {\n        var x1 = positions[v1 + 0],\n            y1 = positions[v1 + 1],\n            z1 = positions[v1 + 2];\n        var key = x1.toFixed(epsVertexMerge) + \"|\" + y1.toFixed(epsVertexMerge) + \"|\" + z1.toFixed(epsVertexMerge);\n\n        if (mapVertices[key] !== undefined) {\n          remapVertexIndices.push(mapVertices[key]);\n        } else {\n          var idx = v1 / 3;\n          mapVertices[key] = idx;\n          remapVertexIndices.push(idx);\n          uniquePositions.push(idx);\n        }\n      }\n    } else {\n      for (var v1 = 0; v1 < positions.length; v1 += 3) {\n        var x1 = positions[v1 + 0],\n            y1 = positions[v1 + 1],\n            z1 = positions[v1 + 2];\n        var found = false;\n\n        for (var v2 = 0; v2 < v1 && !found; v2 += 3) {\n          var x2 = positions[v2 + 0],\n              y2 = positions[v2 + 1],\n              z2 = positions[v2 + 2];\n\n          if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {\n            remapVertexIndices.push(v2 / 3);\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          remapVertexIndices.push(v1 / 3);\n          uniquePositions.push(v1 / 3);\n        }\n      }\n    }\n\n    if ((_g = this._options) === null || _g === void 0 ? void 0 : _g.applyTessellation) {\n      /**\n       * Tessellate triangles if necessary:\n       *\n       *               A\n       *               +\n       *               |\\\n       *               | \\\n       *               |  \\\n       *             E +   \\\n       *              /|    \\\n       *             / |     \\\n       *            /  |      \\\n       *           +---+-------+ B\n       *           D   C\n       *\n       * For the edges to be rendered correctly, the ABC triangle has to be split into ABE and BCE, else AC is considered to be an edge, whereas only AE should be.\n       *\n       * The tessellation process looks for the vertices like E that are in-between two other vertices making of an edge and create new triangles as necessary\n       */\n      // First step: collect the triangles to tessellate\n      var epsVertexAligned = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.epsilonVertexAligned) !== null && _j !== void 0 ? _j : 1e-6;\n      var mustTesselate = []; // liste of triangles that must be tessellated\n\n      for (var index = 0; index < indices.length; index += 3) {\n        // loop over all triangles\n        var triangleToTessellate = void 0;\n\n        for (var i = 0; i < 3; ++i) {\n          // loop over the 3 edges of the triangle\n          var p0Index = remapVertexIndices[indices[index + i]];\n          var p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];\n          var p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];\n\n          if (p0Index === p1Index) {\n            continue;\n          } // degenerated triangle - don't process\n\n\n          var p0x = positions[p0Index * 3 + 0],\n              p0y = positions[p0Index * 3 + 1],\n              p0z = positions[p0Index * 3 + 2];\n          var p1x = positions[p1Index * 3 + 0],\n              p1y = positions[p1Index * 3 + 1],\n              p1z = positions[p1Index * 3 + 2];\n          var p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));\n\n          for (var v = 0; v < uniquePositions.length - 1; v++) {\n            // loop over all (unique) vertices and look for the ones that would be in-between p0 and p1\n            var vIndex = uniquePositions[v];\n\n            if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {\n              continue;\n            } // don't handle the vertex if it is a vertex of the current triangle\n\n\n            var x = positions[vIndex * 3 + 0],\n                y = positions[vIndex * 3 + 1],\n                z = positions[vIndex * 3 + 2];\n            var p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));\n            var pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));\n\n            if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {\n              // vertices are aligned and p in-between p0 and p1 if distance(p0, p) + distance (p, p1) ~ distance(p0, p1)\n              if (!triangleToTessellate) {\n                triangleToTessellate = {\n                  index: index,\n                  edgesPoints: [[], [], []]\n                };\n                mustTesselate.push(triangleToTessellate);\n              }\n\n              triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);\n            }\n          }\n        }\n      } // Second step: tesselate the triangles\n\n\n      for (var t = 0; t < mustTesselate.length; ++t) {\n        var triangle = mustTesselate[t];\n\n        this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);\n      }\n\n      mustTesselate = null;\n    }\n    /**\n     * Collect the edges to render\n     */\n\n\n    var edges = {};\n\n    for (var index = 0; index < indices.length; index += 3) {\n      var faceNormal = void 0;\n\n      for (var i = 0; i < 3; ++i) {\n        var p0Index = remapVertexIndices[indices[index + i]];\n        var p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];\n        var p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];\n\n        if (p0Index === p1Index || (p0Index === p2Index || p1Index === p2Index) && ((_k = this._options) === null || _k === void 0 ? void 0 : _k.removeDegeneratedTriangles)) {\n          continue;\n        }\n\n        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n        TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n\n        if (!faceNormal) {\n          TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);\n          TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);\n          faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);\n          faceNormal.normalize();\n        }\n\n        if (p0Index > p1Index) {\n          var tmp = p0Index;\n          p0Index = p1Index;\n          p1Index = tmp;\n        }\n\n        var key = p0Index + \"_\" + p1Index;\n        var ei = edges[key];\n\n        if (ei) {\n          if (!ei.done) {\n            var dotProduct = Vector3.Dot(faceNormal, ei.normal);\n\n            if (dotProduct < this._epsilon) {\n              this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n            }\n\n            ei.done = true;\n          }\n        } else {\n          edges[key] = {\n            normal: faceNormal,\n            done: false,\n            index: index,\n            i: i\n          };\n        }\n      }\n    }\n\n    for (var key in edges) {\n      var ei = edges[key];\n\n      if (!ei.done) {\n        // Orphaned edge - we must display it\n        var p0Index = remapVertexIndices[indices[ei.index + ei.i]];\n        var p1Index = remapVertexIndices[indices[ei.index + (ei.i + 1) % 3]];\n        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n        this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n      }\n    }\n    /**\n     * Merge into a single mesh\n     */\n\n\n    var engine = this._source.getScene().getEngine();\n\n    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n    this._ib = engine.createIndexBuffer(this._linesIndices);\n    this._indicesCount = this._linesIndices.length;\n  };\n  /**\n   * Generates lines edges from adjacencjes\n   * @private\n   */\n\n\n  EdgesRenderer.prototype._generateEdgesLines = function () {\n    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n\n    var indices = this._source.getIndices();\n\n    if (!indices || !positions) {\n      return;\n    } // First let's find adjacencies\n\n\n    var adjacencies = new Array();\n    var faceNormals = new Array();\n    var index;\n    var faceAdjacencies; // Prepare faces\n\n    for (index = 0; index < indices.length; index += 3) {\n      faceAdjacencies = new FaceAdjacencies();\n      var p0Index = indices[index];\n      var p1Index = indices[index + 1];\n      var p2Index = indices[index + 2];\n      faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n      faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n      faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n      var faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));\n      faceNormal.normalize();\n      faceNormals.push(faceNormal);\n      adjacencies.push(faceAdjacencies);\n    } // Scan\n\n\n    for (index = 0; index < adjacencies.length; index++) {\n      faceAdjacencies = adjacencies[index];\n\n      for (var otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {\n        var otherFaceAdjacencies = adjacencies[otherIndex];\n\n        if (faceAdjacencies.edgesConnectedCount === 3) {\n          // Full\n          break;\n        }\n\n        if (otherFaceAdjacencies.edgesConnectedCount === 3) {\n          // Full\n          continue;\n        }\n\n        var otherP0 = indices[otherIndex * 3];\n        var otherP1 = indices[otherIndex * 3 + 1];\n        var otherP2 = indices[otherIndex * 3 + 2];\n\n        for (var edgeIndex = 0; edgeIndex < 3; edgeIndex++) {\n          var otherEdgeIndex = 0;\n\n          if (faceAdjacencies.edges[edgeIndex] !== undefined) {\n            continue;\n          }\n\n          switch (edgeIndex) {\n            case 0:\n              if (this._checkVerticesInsteadOfIndices) {\n                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n              } else {\n                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);\n              }\n\n              break;\n\n            case 1:\n              if (this._checkVerticesInsteadOfIndices) {\n                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n              } else {\n                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);\n              }\n\n              break;\n\n            case 2:\n              if (this._checkVerticesInsteadOfIndices) {\n                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n              } else {\n                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);\n              }\n\n              break;\n          }\n\n          if (otherEdgeIndex === -1) {\n            continue;\n          }\n\n          faceAdjacencies.edges[edgeIndex] = otherIndex;\n          otherFaceAdjacencies.edges[otherEdgeIndex] = index;\n          faceAdjacencies.edgesConnectedCount++;\n          otherFaceAdjacencies.edgesConnectedCount++;\n\n          if (faceAdjacencies.edgesConnectedCount === 3) {\n            break;\n          }\n        }\n      }\n    } // Create lines\n\n\n    for (index = 0; index < adjacencies.length; index++) {\n      // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon\n      var current = adjacencies[index];\n\n      this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);\n\n      this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);\n\n      this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);\n    } // Merge into a single mesh\n\n\n    var engine = this._source.getScene().getEngine();\n\n    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n    this._ib = engine.createIndexBuffer(this._linesIndices);\n    this._indicesCount = this._linesIndices.length;\n  };\n  /**\n   * Checks whether or not the edges renderer is ready to render.\n   * @return true if ready, otherwise false.\n   */\n\n\n  EdgesRenderer.prototype.isReady = function () {\n    return this._lineShader.isReady(this._source, this._source.hasInstances && this.customInstances.length > 0 || this._source.hasThinInstances);\n  };\n  /**\n   * Renders the edges of the attached mesh,\n   */\n\n\n  EdgesRenderer.prototype.render = function () {\n    var scene = this._source.getScene();\n\n    var currentDrawWrapper = this._lineShader._getDrawWrapper();\n\n    if (this._drawWrapper) {\n      this._lineShader._setDrawWrapper(this._drawWrapper);\n    }\n\n    if (!this.isReady() || !scene.activeCamera) {\n      this._lineShader._setDrawWrapper(currentDrawWrapper);\n\n      return;\n    }\n\n    var hasInstances = this._source.hasInstances && this.customInstances.length > 0;\n    var useBuffersWithInstances = hasInstances || this._source.hasThinInstances;\n    var instanceCount = 0;\n\n    if (useBuffersWithInstances) {\n      this._buffersForInstances[\"world0\"] = this._source.getVertexBuffer(\"world0\");\n      this._buffersForInstances[\"world1\"] = this._source.getVertexBuffer(\"world1\");\n      this._buffersForInstances[\"world2\"] = this._source.getVertexBuffer(\"world2\");\n      this._buffersForInstances[\"world3\"] = this._source.getVertexBuffer(\"world3\");\n\n      if (hasInstances) {\n        var instanceStorage = this._source._instanceDataStorage;\n        instanceCount = this.customInstances.length;\n\n        if (!instanceStorage.instancesData) {\n          if (!this._source.getScene()._activeMeshesFrozen) {\n            this.customInstances.reset();\n          }\n\n          return;\n        }\n\n        if (!instanceStorage.isFrozen) {\n          var offset = 0;\n\n          for (var i = 0; i < instanceCount; ++i) {\n            this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);\n            offset += 16;\n          }\n\n          instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);\n        }\n      } else {\n        instanceCount = this._source.thinInstanceCount;\n      }\n    }\n\n    var engine = scene.getEngine();\n\n    this._lineShader._preBind();\n\n    if (this._source.edgesColor.a !== 1) {\n      engine.setAlphaMode(2);\n    } else {\n      engine.setAlphaMode(0);\n    } // VBOs\n\n\n    engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());\n    scene.resetCachedMaterial();\n\n    this._lineShader.setColor4(\"color\", this._source.edgesColor);\n\n    if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\n      this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);\n    } else {\n      this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective);\n    }\n\n    this._lineShader.setFloat(\"aspectRatio\", engine.getAspectRatio(scene.activeCamera));\n\n    this._lineShader.bind(this._source.getWorldMatrix()); // Draw order\n\n\n    engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);\n\n    this._lineShader.unbind();\n\n    if (useBuffersWithInstances) {\n      engine.unbindInstanceAttributes();\n    }\n\n    if (!this._source.getScene()._activeMeshesFrozen) {\n      this.customInstances.reset();\n    }\n\n    this._lineShader._setDrawWrapper(currentDrawWrapper);\n  };\n\n  return EdgesRenderer;\n}();\n\nexport { EdgesRenderer };\n/**\n * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation\n */\n\nvar LineEdgesRenderer =\n/** @class */\nfunction (_super) {\n  __extends(LineEdgesRenderer, _super);\n  /**\n   * This constructor turns off auto generating edges line in Edges Renderer to make it here.\n   * @param  source LineMesh used to generate edges\n   * @param  epsilon not important (specified angle for edge detection)\n   * @param  checkVerticesInsteadOfIndices not important for LineMesh\n   */\n\n\n  function LineEdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices) {\n    if (epsilon === void 0) {\n      epsilon = 0.95;\n    }\n\n    if (checkVerticesInsteadOfIndices === void 0) {\n      checkVerticesInsteadOfIndices = false;\n    }\n\n    var _this = _super.call(this, source, epsilon, checkVerticesInsteadOfIndices, false) || this;\n\n    _this._generateEdgesLines();\n\n    return _this;\n  }\n  /**\n   * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.\n   */\n\n\n  LineEdgesRenderer.prototype._generateEdgesLines = function () {\n    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n\n    var indices = this._source.getIndices();\n\n    if (!indices || !positions) {\n      return;\n    }\n\n    var p0 = TmpVectors.Vector3[0];\n    var p1 = TmpVectors.Vector3[1];\n    var len = indices.length - 1;\n\n    for (var i = 0, offset = 0; i < len; i += 2, offset += 4) {\n      Vector3.FromArrayToRef(positions, 3 * indices[i], p0);\n      Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);\n      this.createLine(p0, p1, offset);\n    } // Merge into a single mesh\n\n\n    var engine = this._source.getScene().getEngine();\n\n    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n    this._ib = engine.createIndexBuffer(this._linesIndices);\n    this._indicesCount = this._linesIndices.length;\n  };\n\n  return LineEdgesRenderer;\n}(EdgesRenderer);\n\nexport { LineEdgesRenderer };","map":{"version":3,"mappings":"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","names":["VertexBuffer","AbstractMesh","LinesMesh","InstancedLinesMesh","Vector3","TmpVectors","Material","ShaderMaterial","Camera","SmartArray","Tools","DrawWrapper","prototype","disableEdgesRendering","_edgesRenderer","dispose","enableEdgesRendering","epsilon","checkVerticesInsteadOfIndices","options","EdgesRenderer","Object","defineProperty","get","enumerable","configurable","LineEdgesRenderer","apply","arguments","Array","source","generateEdgesLines","_source","_checkVerticesInsteadOfIndices","_options","_epsilon","getScene","getEngine","isWebGPU","_drawWrapper","_prepareRessources","useAlternateEdgeFinder","_a","_generateEdgesLinesAlternate","_generateEdgesLines","_meshRebuildObserver","onRebuildObservable","add","_this","_rebuild","_meshDisposeObserver","onDisposeObservable","_linesPositions","_linesNormals","_linesIndices","_lineShader","shader","scene","_edgeRenderLineShader","attributes","uniforms","disableDepthWrite","backFaceCulling","checkReadyOnEveryCall","_GetShader","buffer","_buffers","PositionKind","NormalKind","engine","_ib","createIndexBuffer","remove","_releaseBuffer","pa","pb","p0","p1","p2","eps","equalsWithEpsilon","faceIndex","edge","faceNormals","needToCreateLine","undefined","dotProduct","Dot","createLine","length","offset","push","x","y","z","edgePoints","indexTriangle","indices","remapVertexIndices","makePointList","pointIndices","firstIndex","i","startEdge","e","sort","a","b","mainPointIndices","otherPointIndices","numMainPoints","numOtherPoints","idxMain","idxOther","bucketIsMain","bucketStep","bucketLimit","bucketIdxLimit","winding","numTris","bucketIdx","nbucketIdx","bucketPoints","nbucketPoints","bucket","lastIdx","positions","getVerticesData","getIndices","isArray","SliceToArray","useFastVertexMerger","_b","epsVertexMerge","Math","round","log","_c","epsilonVertexMerge","_d","_e","_f","uniquePositions","mapVertices","v1","x1","y1","z1","key","toFixed","idx","found","v2","x2","y2","z2","abs","_g","applyTessellation","epsVertexAligned","_h","epsilonVertexAligned","_j","mustTesselate","index","triangleToTessellate","p0Index","p1Index","p2Index","p0x","p0y","p0z","p1x","p1y","p1z","p0p1","sqrt","v","vIndex","p0p","pp1","edgesPoints","t","triangle","_tessellateTriangle","edges","faceNormal","_k","removeDegeneratedTriangles","copyFromFloats","subtractToRef","Cross","normalize","tmp","ei","done","normal","_buffersForInstances","_indicesCount","adjacencies","faceAdjacencies","FaceAdjacencies","subtract","otherIndex","otherFaceAdjacencies","edgesConnectedCount","otherP0","otherP1","otherP2","edgeIndex","otherEdgeIndex","_processEdgeForAdjacenciesWithVertices","_processEdgeForAdjacencies","current","_checkEdge","isReady","hasInstances","customInstances","hasThinInstances","currentDrawWrapper","_getDrawWrapper","_setDrawWrapper","activeCamera","useBuffersWithInstances","instanceCount","getVertexBuffer","instanceStorage","_instanceDataStorage","instancesData","_activeMeshesFrozen","reset","isFrozen","data","copyToArray","instancesBuffer","updateDirectly","thinInstanceCount","_preBind","edgesColor","setAlphaMode","bindBuffers","getEffect","resetCachedMaterial","setColor4","mode","ORTHOGRAPHIC_CAMERA","setFloat","edgesWidth","edgesWidthScalerForOrthographic","edgesWidthScalerForPerspective","getAspectRatio","bind","getWorldMatrix","drawElementsType","TriangleFillMode","unbind","unbindInstanceAttributes","__extends","_super","len","FromArrayToRef"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/edgesRenderer.ts"],"sourcesContent":["import type { Immutable, Nullable } from \"../types\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { LinesMesh, InstancedLinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Node } from \"../node\";\r\n\r\nimport \"../Shaders/line.fragment\";\r\nimport \"../Shaders/line.vertex\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _edgeRenderLineShader: Nullable<ShaderMaterial>;\r\n    }\r\n}\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Gets the edgesRenderer associated with the mesh\r\n         */\r\n        edgesRenderer: Nullable<EdgesRenderer>;\r\n    }\r\n}\r\nAbstractMesh.prototype.disableEdgesRendering = function (): AbstractMesh {\r\n    if (this._edgesRenderer) {\r\n        this._edgesRenderer.dispose();\r\n        this._edgesRenderer = null;\r\n    }\r\n    return this;\r\n};\r\n\r\nAbstractMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false, options?: IEdgesRendererOptions): AbstractMesh {\r\n    this.disableEdgesRendering();\r\n    this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);\r\n    return this;\r\n};\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"edgesRenderer\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._edgesRenderer;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Meshes/linesMesh\" {\r\n    export interface LinesMesh {\r\n        /**\r\n         * Enables the edge rendering mode on the mesh.\r\n         * This mode makes the mesh edges visible\r\n         * @param epsilon defines the maximal distance between two angles to detect a face\r\n         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n         * @returns the currentAbstractMesh\r\n         * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n         */\r\n        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;\r\n    }\r\n}\r\nLinesMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false): AbstractMesh {\r\n    this.disableEdgesRendering();\r\n    this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);\r\n    return this;\r\n};\r\n\r\ndeclare module \"../Meshes/linesMesh\" {\r\n    export interface InstancedLinesMesh {\r\n        /**\r\n         * Enables the edge rendering mode on the mesh.\r\n         * This mode makes the mesh edges visible\r\n         * @param epsilon defines the maximal distance between two angles to detect a face\r\n         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n         * @returns the current InstancedLinesMesh\r\n         * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n         */\r\n        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): InstancedLinesMesh;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nInstancedLinesMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false): InstancedLinesMesh {\r\n    LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);\r\n    return this;\r\n};\r\n\r\n/**\r\n * FaceAdjacencies Helper class to generate edges\r\n */\r\nclass FaceAdjacencies {\r\n    public edges = new Array<number>();\r\n    public p0: Vector3;\r\n    public p1: Vector3;\r\n    public p2: Vector3;\r\n    public edgesConnectedCount = 0;\r\n}\r\n\r\n/**\r\n * Defines the minimum contract an Edges renderer should follow.\r\n */\r\nexport interface IEdgesRenderer extends IDisposable {\r\n    /**\r\n     * Gets or sets a boolean indicating if the edgesRenderer is active\r\n     */\r\n    isEnabled: boolean;\r\n\r\n    /**\r\n     * Renders the edges of the attached mesh,\r\n     */\r\n    render(): void;\r\n\r\n    /**\r\n     * Checks whether or not the edges renderer is ready to render.\r\n     * @return true if ready, otherwise false.\r\n     */\r\n    isReady(): boolean;\r\n\r\n    /**\r\n     * List of instances to render in case the source mesh has instances\r\n     */\r\n    customInstances: SmartArray<Matrix>;\r\n}\r\n\r\n/**\r\n * Defines the additional options of the edges renderer\r\n */\r\nexport interface IEdgesRendererOptions {\r\n    /**\r\n     * Gets or sets a boolean indicating that the alternate edge finder algorithm must be used\r\n     * If not defined, the default value is true\r\n     */\r\n    useAlternateEdgeFinder?: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the vertex merger fast processing must be used.\r\n     * If not defined, the default value is true.\r\n     * You should normally leave it undefined (or set it to true), except if you see some artifacts in the edges rendering (can happen with complex geometries)\r\n     * This option is used only if useAlternateEdgeFinder = true\r\n     */\r\n    useFastVertexMerger?: boolean;\r\n\r\n    /**\r\n     * During edges processing, the vertices are merged if they are close enough: epsilonVertexMerge is the limit within which vertices are considered to be equal.\r\n     * The default value is 1e-6\r\n     * This option is used only if useAlternateEdgeFinder = true\r\n     */\r\n    epsilonVertexMerge?: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that tessellation should be applied before finding the edges. You may need to activate this option if your geometry is a bit\r\n     * unusual, like having a vertex of a triangle in-between two vertices of an edge of another triangle. It happens often when using CSG to construct meshes.\r\n     * This option is used only if useAlternateEdgeFinder = true\r\n     */\r\n    applyTessellation?: boolean;\r\n\r\n    /**\r\n     * The limit under which 3 vertices are considered to be aligned. 3 vertices PQR are considered aligned if distance(PQ) + distance(QR) - distance(PR) < epsilonVertexAligned\r\n     * The default value is 1e-6\r\n     * This option is used only if useAlternateEdgeFinder = true\r\n     */\r\n    epsilonVertexAligned?: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that degenerated triangles should not be processed.\r\n     * Degenerated triangles are triangles that have 2 or 3 vertices with the same coordinates\r\n     */\r\n    removeDegeneratedTriangles?: boolean;\r\n}\r\n\r\n/**\r\n * This class is used to generate edges of the mesh that could then easily be rendered in a scene.\r\n */\r\nexport class EdgesRenderer implements IEdgesRenderer {\r\n    /**\r\n     * Define the size of the edges with an orthographic camera\r\n     */\r\n    public edgesWidthScalerForOrthographic = 1000.0;\r\n\r\n    /**\r\n     * Define the size of the edges with a perspective camera\r\n     */\r\n    public edgesWidthScalerForPerspective = 50.0;\r\n\r\n    protected _source: AbstractMesh;\r\n    protected _linesPositions = new Array<number>();\r\n    protected _linesNormals = new Array<number>();\r\n    protected _linesIndices = new Array<number>();\r\n    protected _epsilon: number;\r\n    protected _indicesCount: number;\r\n    protected _drawWrapper?: DrawWrapper;\r\n\r\n    protected _lineShader: ShaderMaterial;\r\n    protected _ib: DataBuffer;\r\n    protected _buffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    protected _buffersForInstances: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    protected _checkVerticesInsteadOfIndices = false;\r\n    protected _options: Nullable<IEdgesRendererOptions>;\r\n\r\n    private _meshRebuildObserver: Nullable<Observer<AbstractMesh>>;\r\n    private _meshDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    /** Gets or sets a boolean indicating if the edgesRenderer is active */\r\n    public isEnabled = true;\r\n\r\n    /** Gets the vertices generated by the edge renderer */\r\n    public get linesPositions(): Immutable<Array<number>> {\r\n        return this._linesPositions;\r\n    }\r\n\r\n    /** Gets the normals generated by the edge renderer */\r\n    public get linesNormals(): Immutable<Array<number>> {\r\n        return this._linesNormals;\r\n    }\r\n\r\n    /** Gets the indices generated by the edge renderer */\r\n    public get linesIndices(): Immutable<Array<number>> {\r\n        return this._linesIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the shader used to draw the lines\r\n     */\r\n    public get lineShader(): ShaderMaterial {\r\n        return this._lineShader;\r\n    }\r\n\r\n    public set lineShader(shader: ShaderMaterial) {\r\n        this._lineShader = shader;\r\n    }\r\n\r\n    /**\r\n     * List of instances to render in case the source mesh has instances\r\n     */\r\n    public customInstances = new SmartArray<Matrix>(32);\r\n\r\n    private static _GetShader(scene: Scene): ShaderMaterial {\r\n        if (!scene._edgeRenderLineShader) {\r\n            const shader = new ShaderMaterial(\r\n                \"lineShader\",\r\n                scene,\r\n                \"line\",\r\n                {\r\n                    attributes: [\"position\", \"normal\"],\r\n                    uniforms: [\"world\", \"viewProjection\", \"color\", \"width\", \"aspectRatio\"],\r\n                },\r\n                false\r\n            );\r\n\r\n            shader.disableDepthWrite = true;\r\n            shader.backFaceCulling = false;\r\n            shader.checkReadyOnEveryCall = scene.getEngine().isWebGPU;\r\n\r\n            scene._edgeRenderLineShader = shader;\r\n        }\r\n\r\n        return scene._edgeRenderLineShader;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.\r\n     * Beware when you use this class with complex objects as the adjacencies computation can be really long\r\n     * @param  source Mesh used to create edges\r\n     * @param  epsilon sum of angles in adjacency to check for edge\r\n     * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true\r\n     * @param  generateEdgesLines - should generate Lines or only prepare resources.\r\n     * @param  options The options to apply when generating the edges\r\n     */\r\n    constructor(source: AbstractMesh, epsilon = 0.95, checkVerticesInsteadOfIndices = false, generateEdgesLines = true, options?: IEdgesRendererOptions) {\r\n        this._source = source;\r\n        this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;\r\n        this._options = options ?? null;\r\n\r\n        this._epsilon = epsilon;\r\n        if (this._source.getScene().getEngine().isWebGPU) {\r\n            this._drawWrapper = new DrawWrapper(source.getEngine());\r\n        }\r\n\r\n        this._prepareRessources();\r\n        if (generateEdgesLines) {\r\n            if (options?.useAlternateEdgeFinder ?? true) {\r\n                this._generateEdgesLinesAlternate();\r\n            } else {\r\n                this._generateEdgesLines();\r\n            }\r\n        }\r\n\r\n        this._meshRebuildObserver = this._source.onRebuildObservable.add(() => {\r\n            this._rebuild();\r\n        });\r\n\r\n        this._meshDisposeObserver = this._source.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    protected _prepareRessources(): void {\r\n        if (this._lineShader) {\r\n            return;\r\n        }\r\n\r\n        this._lineShader = EdgesRenderer._GetShader(this._source.getScene());\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        let buffer = this._buffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer._rebuild();\r\n        }\r\n\r\n        buffer = this._buffers[VertexBuffer.NormalKind];\r\n        if (buffer) {\r\n            buffer._rebuild();\r\n        }\r\n\r\n        const scene = this._source.getScene();\r\n        const engine = scene.getEngine();\r\n        this._ib = engine.createIndexBuffer(this._linesIndices);\r\n    }\r\n\r\n    /**\r\n     * Releases the required resources for the edges renderer\r\n     */\r\n    public dispose(): void {\r\n        this._source.onRebuildObservable.remove(this._meshRebuildObserver);\r\n        this._source.onDisposeObservable.remove(this._meshDisposeObserver);\r\n\r\n        let buffer = this._buffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._buffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n        buffer = this._buffers[VertexBuffer.NormalKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._buffers[VertexBuffer.NormalKind] = null;\r\n        }\r\n\r\n        if (this._ib) {\r\n            this._source.getScene().getEngine()._releaseBuffer(this._ib);\r\n        }\r\n        this._lineShader.dispose();\r\n\r\n        this._drawWrapper?.dispose();\r\n    }\r\n\r\n    protected _processEdgeForAdjacencies(pa: number, pb: number, p0: number, p1: number, p2: number): number {\r\n        if ((pa === p0 && pb === p1) || (pa === p1 && pb === p0)) {\r\n            return 0;\r\n        }\r\n\r\n        if ((pa === p1 && pb === p2) || (pa === p2 && pb === p1)) {\r\n            return 1;\r\n        }\r\n\r\n        if ((pa === p2 && pb === p0) || (pa === p0 && pb === p2)) {\r\n            return 2;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    protected _processEdgeForAdjacenciesWithVertices(pa: Vector3, pb: Vector3, p0: Vector3, p1: Vector3, p2: Vector3): number {\r\n        const eps = 1e-10;\r\n        if ((pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps)) || (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps))) {\r\n            return 0;\r\n        }\r\n\r\n        if ((pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps)) || (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps))) {\r\n            return 1;\r\n        }\r\n\r\n        if ((pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps)) || (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps))) {\r\n            return 2;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Checks if the pair of p0 and p1 is en edge\r\n     * @param faceIndex\r\n     * @param edge\r\n     * @param faceNormals\r\n     * @param  p0\r\n     * @param  p1\r\n     * @private\r\n     */\r\n    protected _checkEdge(faceIndex: number, edge: number, faceNormals: Array<Vector3>, p0: Vector3, p1: Vector3): void {\r\n        let needToCreateLine;\r\n\r\n        if (edge === undefined) {\r\n            needToCreateLine = true;\r\n        } else {\r\n            const dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);\r\n\r\n            needToCreateLine = dotProduct < this._epsilon;\r\n        }\r\n\r\n        if (needToCreateLine) {\r\n            this.createLine(p0, p1, this._linesPositions.length / 3);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * push line into the position, normal and index buffer\r\n     * @param p0\r\n     * @param p1\r\n     * @param offset\r\n     * @protected\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected createLine(p0: Vector3, p1: Vector3, offset: number) {\r\n        // Positions\r\n        this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);\r\n\r\n        // Normals\r\n        this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);\r\n\r\n        // Indices\r\n        this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);\r\n    }\r\n\r\n    /**\r\n     * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm\r\n     * @param edgePoints\r\n     * @param indexTriangle\r\n     * @param indices\r\n     * @param remapVertexIndices\r\n     */\r\n    private _tessellateTriangle(edgePoints: Array<Array<[number, number]>>, indexTriangle: number, indices: Array<number>, remapVertexIndices: Array<number>): void {\r\n        const makePointList = (edgePoints: Array<[number, number]>, pointIndices: Array<number>, firstIndex: number) => {\r\n            if (firstIndex >= 0) {\r\n                pointIndices.push(firstIndex);\r\n            }\r\n\r\n            for (let i = 0; i < edgePoints.length; ++i) {\r\n                pointIndices.push(edgePoints[i][0]);\r\n            }\r\n        };\r\n\r\n        let startEdge = 0;\r\n\r\n        if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {\r\n            startEdge = 1;\r\n        } else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {\r\n            startEdge = 2;\r\n        }\r\n\r\n        for (let e = 0; e < 3; ++e) {\r\n            if (e === startEdge) {\r\n                edgePoints[e].sort((a, b) => (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0));\r\n            } else {\r\n                edgePoints[e].sort((a, b) => (a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0));\r\n            }\r\n        }\r\n\r\n        const mainPointIndices: Array<number> = [],\r\n            otherPointIndices: Array<number> = [];\r\n\r\n        makePointList(edgePoints[startEdge], mainPointIndices, -1);\r\n\r\n        const numMainPoints = mainPointIndices.length;\r\n\r\n        for (let i = startEdge + 2; i >= startEdge + 1; --i) {\r\n            makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + ((i + 1) % 3)]] : -1);\r\n        }\r\n\r\n        const numOtherPoints = otherPointIndices.length;\r\n\r\n        const idxMain = 0;\r\n        const idxOther = 0;\r\n\r\n        indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);\r\n        indices.push(remapVertexIndices[indices[indexTriangle + ((startEdge + 1) % 3)]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);\r\n\r\n        const bucketIsMain = numMainPoints <= numOtherPoints;\r\n\r\n        const bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;\r\n        const bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;\r\n        const bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;\r\n        const winding = bucketIsMain ? 0 : 1;\r\n\r\n        let numTris = numMainPoints + numOtherPoints - 2;\r\n\r\n        let bucketIdx = bucketIsMain ? idxMain : idxOther;\r\n        let nbucketIdx = bucketIsMain ? idxOther : idxMain;\r\n        const bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;\r\n        const nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;\r\n\r\n        let bucket = 0;\r\n\r\n        while (numTris-- > 0) {\r\n            if (winding) {\r\n                indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);\r\n            } else {\r\n                indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);\r\n            }\r\n\r\n            bucket += bucketStep;\r\n\r\n            let lastIdx;\r\n\r\n            if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {\r\n                lastIdx = bucketPoints[++bucketIdx];\r\n                bucket -= bucketLimit;\r\n            } else {\r\n                lastIdx = nbucketPoints[++nbucketIdx];\r\n            }\r\n\r\n            indices.push(lastIdx);\r\n        }\r\n\r\n        indices[indexTriangle + 0] = indices[indices.length - 3];\r\n        indices[indexTriangle + 1] = indices[indices.length - 2];\r\n        indices[indexTriangle + 2] = indices[indices.length - 1];\r\n\r\n        indices.length = indices.length - 3;\r\n    }\r\n\r\n    private _generateEdgesLinesAlternate(): void {\r\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\r\n        let indices = this._source.getIndices();\r\n\r\n        if (!indices || !positions) {\r\n            return;\r\n        }\r\n\r\n        if (!Array.isArray(indices)) {\r\n            indices = Tools.SliceToArray(indices);\r\n        }\r\n\r\n        /**\r\n         * Find all vertices that are at the same location (with an epsilon) and remapp them on the same vertex\r\n         */\r\n        const useFastVertexMerger = this._options?.useFastVertexMerger ?? true;\r\n        const epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log(this._options?.epsilonVertexMerge ?? 1e-6) / Math.log(10)) : this._options?.epsilonVertexMerge ?? 1e-6;\r\n        const remapVertexIndices: Array<number> = [];\r\n        const uniquePositions: Array<number> = []; // list of unique index of vertices - needed for tessellation\r\n\r\n        if (useFastVertexMerger) {\r\n            const mapVertices: { [key: string]: number } = {};\r\n            for (let v1 = 0; v1 < positions.length; v1 += 3) {\r\n                const x1 = positions[v1 + 0],\r\n                    y1 = positions[v1 + 1],\r\n                    z1 = positions[v1 + 2];\r\n\r\n                const key = x1.toFixed(epsVertexMerge) + \"|\" + y1.toFixed(epsVertexMerge) + \"|\" + z1.toFixed(epsVertexMerge);\r\n\r\n                if (mapVertices[key] !== undefined) {\r\n                    remapVertexIndices.push(mapVertices[key]);\r\n                } else {\r\n                    const idx = v1 / 3;\r\n                    mapVertices[key] = idx;\r\n                    remapVertexIndices.push(idx);\r\n                    uniquePositions.push(idx);\r\n                }\r\n            }\r\n        } else {\r\n            for (let v1 = 0; v1 < positions.length; v1 += 3) {\r\n                const x1 = positions[v1 + 0],\r\n                    y1 = positions[v1 + 1],\r\n                    z1 = positions[v1 + 2];\r\n                let found = false;\r\n                for (let v2 = 0; v2 < v1 && !found; v2 += 3) {\r\n                    const x2 = positions[v2 + 0],\r\n                        y2 = positions[v2 + 1],\r\n                        z2 = positions[v2 + 2];\r\n\r\n                    if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {\r\n                        remapVertexIndices.push(v2 / 3);\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    remapVertexIndices.push(v1 / 3);\r\n                    uniquePositions.push(v1 / 3);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._options?.applyTessellation) {\r\n            /**\r\n             * Tessellate triangles if necessary:\r\n             *\r\n             *               A\r\n             *               +\r\n             *               |\\\r\n             *               | \\\r\n             *               |  \\\r\n             *             E +   \\\r\n             *              /|    \\\r\n             *             / |     \\\r\n             *            /  |      \\\r\n             *           +---+-------+ B\r\n             *           D   C\r\n             *\r\n             * For the edges to be rendered correctly, the ABC triangle has to be split into ABE and BCE, else AC is considered to be an edge, whereas only AE should be.\r\n             *\r\n             * The tessellation process looks for the vertices like E that are in-between two other vertices making of an edge and create new triangles as necessary\r\n             */\r\n\r\n            // First step: collect the triangles to tessellate\r\n            const epsVertexAligned = this._options?.epsilonVertexAligned ?? 1e-6;\r\n            const mustTesselate: Array<{ index: number; edgesPoints: Array<Array<[number, number]>> }> = []; // liste of triangles that must be tessellated\r\n\r\n            for (let index = 0; index < indices.length; index += 3) {\r\n                // loop over all triangles\r\n                let triangleToTessellate: { index: number; edgesPoints: Array<Array<[number, number]>> } | undefined;\r\n\r\n                for (let i = 0; i < 3; ++i) {\r\n                    // loop over the 3 edges of the triangle\r\n                    const p0Index = remapVertexIndices[indices[index + i]];\r\n                    const p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\r\n                    const p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\r\n\r\n                    if (p0Index === p1Index) {\r\n                        continue;\r\n                    } // degenerated triangle - don't process\r\n\r\n                    const p0x = positions[p0Index * 3 + 0],\r\n                        p0y = positions[p0Index * 3 + 1],\r\n                        p0z = positions[p0Index * 3 + 2];\r\n                    const p1x = positions[p1Index * 3 + 0],\r\n                        p1y = positions[p1Index * 3 + 1],\r\n                        p1z = positions[p1Index * 3 + 2];\r\n\r\n                    const p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));\r\n\r\n                    for (let v = 0; v < uniquePositions.length - 1; v++) {\r\n                        // loop over all (unique) vertices and look for the ones that would be in-between p0 and p1\r\n                        const vIndex = uniquePositions[v];\r\n\r\n                        if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {\r\n                            continue;\r\n                        } // don't handle the vertex if it is a vertex of the current triangle\r\n\r\n                        const x = positions[vIndex * 3 + 0],\r\n                            y = positions[vIndex * 3 + 1],\r\n                            z = positions[vIndex * 3 + 2];\r\n\r\n                        const p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));\r\n                        const pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));\r\n\r\n                        if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {\r\n                            // vertices are aligned and p in-between p0 and p1 if distance(p0, p) + distance (p, p1) ~ distance(p0, p1)\r\n                            if (!triangleToTessellate) {\r\n                                triangleToTessellate = {\r\n                                    index: index,\r\n                                    edgesPoints: [[], [], []],\r\n                                };\r\n                                mustTesselate.push(triangleToTessellate);\r\n                            }\r\n                            triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Second step: tesselate the triangles\r\n            for (let t = 0; t < mustTesselate.length; ++t) {\r\n                const triangle = mustTesselate[t];\r\n\r\n                this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);\r\n            }\r\n\r\n            (mustTesselate as any) = null;\r\n        }\r\n\r\n        /**\r\n         * Collect the edges to render\r\n         */\r\n        const edges: { [key: string]: { normal: Vector3; done: boolean; index: number; i: number } } = {};\r\n\r\n        for (let index = 0; index < indices.length; index += 3) {\r\n            let faceNormal;\r\n            for (let i = 0; i < 3; ++i) {\r\n                let p0Index = remapVertexIndices[indices[index + i]];\r\n                let p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\r\n                const p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\r\n\r\n                if (p0Index === p1Index || ((p0Index === p2Index || p1Index === p2Index) && this._options?.removeDegeneratedTriangles)) {\r\n                    continue;\r\n                }\r\n\r\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\r\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\r\n                TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\r\n\r\n                if (!faceNormal) {\r\n                    TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);\r\n                    TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);\r\n                    faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);\r\n                    faceNormal.normalize();\r\n                }\r\n\r\n                if (p0Index > p1Index) {\r\n                    const tmp = p0Index;\r\n                    p0Index = p1Index;\r\n                    p1Index = tmp;\r\n                }\r\n\r\n                const key = p0Index + \"_\" + p1Index;\r\n                const ei = edges[key];\r\n\r\n                if (ei) {\r\n                    if (!ei.done) {\r\n                        const dotProduct = Vector3.Dot(faceNormal, ei.normal);\r\n\r\n                        if (dotProduct < this._epsilon) {\r\n                            this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\r\n                        }\r\n\r\n                        ei.done = true;\r\n                    }\r\n                } else {\r\n                    edges[key] = { normal: faceNormal, done: false, index: index, i: i };\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const key in edges) {\r\n            const ei = edges[key];\r\n            if (!ei.done) {\r\n                // Orphaned edge - we must display it\r\n                const p0Index = remapVertexIndices[indices[ei.index + ei.i]];\r\n                const p1Index = remapVertexIndices[indices[ei.index + ((ei.i + 1) % 3)]];\r\n\r\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\r\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\r\n\r\n                this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merge into a single mesh\r\n         */\r\n        const engine = this._source.getScene().getEngine();\r\n\r\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\r\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\r\n\r\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\r\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\r\n\r\n        this._ib = engine.createIndexBuffer(this._linesIndices);\r\n\r\n        this._indicesCount = this._linesIndices.length;\r\n    }\r\n\r\n    /**\r\n     * Generates lines edges from adjacencjes\r\n     * @private\r\n     */\r\n    _generateEdgesLines(): void {\r\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this._source.getIndices();\r\n\r\n        if (!indices || !positions) {\r\n            return;\r\n        }\r\n\r\n        // First let's find adjacencies\r\n        const adjacencies = new Array<FaceAdjacencies>();\r\n        const faceNormals = new Array<Vector3>();\r\n        let index: number;\r\n        let faceAdjacencies: FaceAdjacencies;\r\n\r\n        // Prepare faces\r\n        for (index = 0; index < indices.length; index += 3) {\r\n            faceAdjacencies = new FaceAdjacencies();\r\n            const p0Index = indices[index];\r\n            const p1Index = indices[index + 1];\r\n            const p2Index = indices[index + 2];\r\n\r\n            faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\r\n            faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\r\n            faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\r\n            const faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));\r\n\r\n            faceNormal.normalize();\r\n\r\n            faceNormals.push(faceNormal);\r\n            adjacencies.push(faceAdjacencies);\r\n        }\r\n\r\n        // Scan\r\n        for (index = 0; index < adjacencies.length; index++) {\r\n            faceAdjacencies = adjacencies[index];\r\n\r\n            for (let otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {\r\n                const otherFaceAdjacencies = adjacencies[otherIndex];\r\n\r\n                if (faceAdjacencies.edgesConnectedCount === 3) {\r\n                    // Full\r\n                    break;\r\n                }\r\n\r\n                if (otherFaceAdjacencies.edgesConnectedCount === 3) {\r\n                    // Full\r\n                    continue;\r\n                }\r\n\r\n                const otherP0 = indices[otherIndex * 3];\r\n                const otherP1 = indices[otherIndex * 3 + 1];\r\n                const otherP2 = indices[otherIndex * 3 + 2];\r\n\r\n                for (let edgeIndex = 0; edgeIndex < 3; edgeIndex++) {\r\n                    let otherEdgeIndex: number = 0;\r\n\r\n                    if (faceAdjacencies.edges[edgeIndex] !== undefined) {\r\n                        continue;\r\n                    }\r\n\r\n                    switch (edgeIndex) {\r\n                        case 0:\r\n                            if (this._checkVerticesInsteadOfIndices) {\r\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(\r\n                                    faceAdjacencies.p0,\r\n                                    faceAdjacencies.p1,\r\n                                    otherFaceAdjacencies.p0,\r\n                                    otherFaceAdjacencies.p1,\r\n                                    otherFaceAdjacencies.p2\r\n                                );\r\n                            } else {\r\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);\r\n                            }\r\n                            break;\r\n                        case 1:\r\n                            if (this._checkVerticesInsteadOfIndices) {\r\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(\r\n                                    faceAdjacencies.p1,\r\n                                    faceAdjacencies.p2,\r\n                                    otherFaceAdjacencies.p0,\r\n                                    otherFaceAdjacencies.p1,\r\n                                    otherFaceAdjacencies.p2\r\n                                );\r\n                            } else {\r\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);\r\n                            }\r\n                            break;\r\n                        case 2:\r\n                            if (this._checkVerticesInsteadOfIndices) {\r\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(\r\n                                    faceAdjacencies.p2,\r\n                                    faceAdjacencies.p0,\r\n                                    otherFaceAdjacencies.p0,\r\n                                    otherFaceAdjacencies.p1,\r\n                                    otherFaceAdjacencies.p2\r\n                                );\r\n                            } else {\r\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);\r\n                            }\r\n                            break;\r\n                    }\r\n\r\n                    if (otherEdgeIndex === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    faceAdjacencies.edges[edgeIndex] = otherIndex;\r\n                    otherFaceAdjacencies.edges[otherEdgeIndex] = index;\r\n\r\n                    faceAdjacencies.edgesConnectedCount++;\r\n                    otherFaceAdjacencies.edgesConnectedCount++;\r\n\r\n                    if (faceAdjacencies.edgesConnectedCount === 3) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create lines\r\n        for (index = 0; index < adjacencies.length; index++) {\r\n            // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon\r\n            const current = adjacencies[index];\r\n\r\n            this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);\r\n            this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);\r\n            this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);\r\n        }\r\n\r\n        // Merge into a single mesh\r\n        const engine = this._source.getScene().getEngine();\r\n\r\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\r\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\r\n\r\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\r\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\r\n\r\n        this._ib = engine.createIndexBuffer(this._linesIndices);\r\n\r\n        this._indicesCount = this._linesIndices.length;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not the edges renderer is ready to render.\r\n     * @return true if ready, otherwise false.\r\n     */\r\n    public isReady(): boolean {\r\n        return this._lineShader.isReady(this._source, (this._source.hasInstances && this.customInstances.length > 0) || this._source.hasThinInstances);\r\n    }\r\n\r\n    /**\r\n     * Renders the edges of the attached mesh,\r\n     */\r\n    public render(): void {\r\n        const scene = this._source.getScene();\r\n\r\n        const currentDrawWrapper = this._lineShader._getDrawWrapper();\r\n        if (this._drawWrapper) {\r\n            this._lineShader._setDrawWrapper(this._drawWrapper);\r\n        }\r\n\r\n        if (!this.isReady() || !scene.activeCamera) {\r\n            this._lineShader._setDrawWrapper(currentDrawWrapper);\r\n            return;\r\n        }\r\n\r\n        const hasInstances = this._source.hasInstances && this.customInstances.length > 0;\r\n        const useBuffersWithInstances = hasInstances || this._source.hasThinInstances;\r\n\r\n        let instanceCount = 0;\r\n\r\n        if (useBuffersWithInstances) {\r\n            this._buffersForInstances[\"world0\"] = (this._source as Mesh).getVertexBuffer(\"world0\");\r\n            this._buffersForInstances[\"world1\"] = (this._source as Mesh).getVertexBuffer(\"world1\");\r\n            this._buffersForInstances[\"world2\"] = (this._source as Mesh).getVertexBuffer(\"world2\");\r\n            this._buffersForInstances[\"world3\"] = (this._source as Mesh).getVertexBuffer(\"world3\");\r\n\r\n            if (hasInstances) {\r\n                const instanceStorage = (this._source as Mesh)._instanceDataStorage;\r\n\r\n                instanceCount = this.customInstances.length;\r\n\r\n                if (!instanceStorage.instancesData) {\r\n                    if (!this._source.getScene()._activeMeshesFrozen) {\r\n                        this.customInstances.reset();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (!instanceStorage.isFrozen) {\r\n                    let offset = 0;\r\n\r\n                    for (let i = 0; i < instanceCount; ++i) {\r\n                        this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);\r\n                        offset += 16;\r\n                    }\r\n\r\n                    instanceStorage.instancesBuffer!.updateDirectly(instanceStorage.instancesData, 0, instanceCount);\r\n                }\r\n            } else {\r\n                instanceCount = (this._source as Mesh).thinInstanceCount;\r\n            }\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        this._lineShader._preBind();\r\n\r\n        if (this._source.edgesColor.a !== 1) {\r\n            engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n        } else {\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // VBOs\r\n        engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, <Effect>this._lineShader.getEffect());\r\n\r\n        scene.resetCachedMaterial();\r\n        this._lineShader.setColor4(\"color\", this._source.edgesColor);\r\n\r\n        if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\r\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);\r\n        } else {\r\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective);\r\n        }\r\n\r\n        this._lineShader.setFloat(\"aspectRatio\", engine.getAspectRatio(scene.activeCamera));\r\n        this._lineShader.bind(this._source.getWorldMatrix());\r\n\r\n        // Draw order\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);\r\n        this._lineShader.unbind();\r\n\r\n        if (useBuffersWithInstances) {\r\n            engine.unbindInstanceAttributes();\r\n        }\r\n\r\n        if (!this._source.getScene()._activeMeshesFrozen) {\r\n            this.customInstances.reset();\r\n        }\r\n\r\n        this._lineShader._setDrawWrapper(currentDrawWrapper);\r\n    }\r\n}\r\n\r\n/**\r\n * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation\r\n */\r\nexport class LineEdgesRenderer extends EdgesRenderer {\r\n    /**\r\n     * This constructor turns off auto generating edges line in Edges Renderer to make it here.\r\n     * @param  source LineMesh used to generate edges\r\n     * @param  epsilon not important (specified angle for edge detection)\r\n     * @param  checkVerticesInsteadOfIndices not important for LineMesh\r\n     */\r\n    constructor(source: AbstractMesh, epsilon = 0.95, checkVerticesInsteadOfIndices = false) {\r\n        super(source, epsilon, checkVerticesInsteadOfIndices, false);\r\n        this._generateEdgesLines();\r\n    }\r\n\r\n    /**\r\n     * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.\r\n     */\r\n    _generateEdgesLines(): void {\r\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this._source.getIndices();\r\n\r\n        if (!indices || !positions) {\r\n            return;\r\n        }\r\n\r\n        const p0 = TmpVectors.Vector3[0];\r\n        const p1 = TmpVectors.Vector3[1];\r\n        const len = indices.length - 1;\r\n        for (let i = 0, offset = 0; i < len; i += 2, offset += 4) {\r\n            Vector3.FromArrayToRef(positions, 3 * indices[i], p0);\r\n            Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);\r\n            this.createLine(p0, p1, offset);\r\n        }\r\n\r\n        // Merge into a single mesh\r\n        const engine = this._source.getScene().getEngine();\r\n\r\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\r\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\r\n\r\n        this._ib = engine.createIndexBuffer(this._linesIndices);\r\n\r\n        this._indicesCount = this._linesIndices.length;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}