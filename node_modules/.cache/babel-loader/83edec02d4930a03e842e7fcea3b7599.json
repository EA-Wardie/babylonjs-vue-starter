{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\n/**\n * A class extending Texture allowing drawing on a texture\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture\n */\n\nvar DynamicTexture =\n/** @class */\nfunction (_super) {\n  __extends(DynamicTexture, _super);\n  /**\n   * Creates a DynamicTexture\n   * @param name defines the name of the texture\n   * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\n   * @param scene defines the scene where you want the texture\n   * @param generateMipMaps defines the use of MinMaps or not (default is false)\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n   * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\n   */\n\n\n  function DynamicTexture(name, options, scene, generateMipMaps, samplingMode, format, invertY) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format) || this;\n\n    _this.name = name;\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    _this._generateMipMaps = generateMipMaps;\n\n    var engine = _this._getEngine();\n\n    if (!engine) {\n      return _this;\n    }\n\n    if (options.getContext) {\n      _this._canvas = options;\n      _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n    } else {\n      _this._canvas = engine.createCanvas(1, 1);\n\n      if (options.width || options.width === 0) {\n        _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n      } else {\n        _this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n      }\n    }\n\n    var textureSize = _this.getSize();\n\n    if (_this._canvas.width !== textureSize.width) {\n      _this._canvas.width = textureSize.width;\n    }\n\n    if (_this._canvas.height !== textureSize.height) {\n      _this._canvas.height = textureSize.height;\n    }\n\n    _this._context = _this._canvas.getContext(\"2d\");\n    return _this;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"DynamicTexture\"\n   */\n\n\n  DynamicTexture.prototype.getClassName = function () {\n    return \"DynamicTexture\";\n  };\n\n  Object.defineProperty(DynamicTexture.prototype, \"canRescale\", {\n    /**\n     * Gets the current state of canRescale\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DynamicTexture.prototype._recreate = function (textureSize) {\n    this._canvas.width = textureSize.width;\n    this._canvas.height = textureSize.height;\n    this.releaseInternalTexture();\n    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n  };\n  /**\n   * Scales the texture\n   * @param ratio the scale factor to apply to both width and height\n   */\n\n\n  DynamicTexture.prototype.scale = function (ratio) {\n    var textureSize = this.getSize();\n    textureSize.width *= ratio;\n    textureSize.height *= ratio;\n\n    this._recreate(textureSize);\n  };\n  /**\n   * Resizes the texture\n   * @param width the new width\n   * @param height the new height\n   */\n\n\n  DynamicTexture.prototype.scaleTo = function (width, height) {\n    var textureSize = this.getSize();\n    textureSize.width = width;\n    textureSize.height = height;\n\n    this._recreate(textureSize);\n  };\n  /**\n   * Gets the context of the canvas used by the texture\n   * @returns the canvas context of the dynamic texture\n   */\n\n\n  DynamicTexture.prototype.getContext = function () {\n    return this._context;\n  };\n  /**\n   * Clears the texture\n   */\n\n\n  DynamicTexture.prototype.clear = function () {\n    var size = this.getSize();\n\n    this._context.fillRect(0, 0, size.width, size.height);\n  };\n  /**\n   * Updates the texture\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\n   * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\n   */\n\n\n  DynamicTexture.prototype.update = function (invertY, premulAlpha, allowGPUOptimization) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n\n    if (allowGPUOptimization === void 0) {\n      allowGPUOptimization = false;\n    }\n\n    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined, undefined, allowGPUOptimization);\n  };\n  /**\n   * Draws text onto the texture\n   * @param text defines the text to be drawn\n   * @param x defines the placement of the text from the left\n   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\n   * @param font defines the font to be used with font-style, font-size, font-name\n   * @param color defines the color used for the text\n   * @param clearColor defines the color for the canvas, use null to not overwrite canvas\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param update defines whether texture is immediately update (default is true)\n   */\n\n\n  DynamicTexture.prototype.drawText = function (text, x, y, font, color, clearColor, invertY, update) {\n    if (update === void 0) {\n      update = true;\n    }\n\n    var size = this.getSize();\n\n    if (clearColor) {\n      this._context.fillStyle = clearColor;\n\n      this._context.fillRect(0, 0, size.width, size.height);\n    }\n\n    this._context.font = font;\n\n    if (x === null || x === undefined) {\n      var textSize = this._context.measureText(text);\n\n      x = (size.width - textSize.width) / 2;\n    }\n\n    if (y === null || y === undefined) {\n      var fontSize = parseInt(font.replace(/\\D/g, \"\"));\n      y = size.height / 2 + fontSize / 3.65;\n    }\n\n    this._context.fillStyle = color || \"\";\n\n    this._context.fillText(text, x, y);\n\n    if (update) {\n      this.update(invertY);\n    }\n  };\n  /**\n   * Clones the texture\n   * @returns the clone of the texture.\n   */\n\n\n  DynamicTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var textureSize = this.getSize();\n    var newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // Dynamic Texture\n\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    return newTexture;\n  };\n  /**\n   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\n   * @returns a serialized dynamic texture object\n   */\n\n\n  DynamicTexture.prototype.serialize = function () {\n    var scene = this.getScene();\n\n    if (scene && !scene.isReady()) {\n      Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (DynamicTexture._IsCanvasElement(this._canvas)) {\n      serializationObject.base64String = this._canvas.toDataURL();\n    }\n\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    return serializationObject;\n  };\n\n  DynamicTexture._IsCanvasElement = function (canvas) {\n    return canvas.toDataURL !== undefined;\n  };\n  /** @hidden */\n\n\n  DynamicTexture.prototype._rebuild = function () {\n    this.update();\n  };\n\n  return DynamicTexture;\n}(Texture);\n\nexport { DynamicTexture };","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,MAAT,QAAuB,sBAAvB;AAIA,SAASC,OAAT,QAAwB,qCAAxB;AAEA,OAAO,mDAAP;AAGA;;;;;AAIA;AAAA;AAAA;AAAoCC;AAKhC;;;;;;;;;;;;AAWA,0BACIC,IADJ,EAEIC,OAFJ,EAGIC,KAHJ,EAIIC,eAJJ,EAKIC,YALJ,EAMIC,MANJ,EAOIC,OAPJ,EAOqB;AAJjB;AAAAJ;AAA6B;;AAC7B;AAAAC;AAAgC;;AAChC;AAAAC,qBAAuB,CAAvB;AAAuB;;AACvB;AAAAC,eAAiB,CAAjB;AAAiB;;AANrB,gBASIE,kBAAM,IAAN,EAAYL,KAAZ,EAAmB,CAACC,eAApB,EAAqCG,OAArC,EAA8CF,YAA9C,EAA4DI,SAA5D,EAAuEA,SAAvE,EAAkFA,SAAlF,EAA6FA,SAA7F,EAAwGH,MAAxG,KAA+G,IATnH;;AAWII,SAAI,CAACT,IAAL,GAAYA,IAAZ;AACAS,SAAI,CAACC,KAAL,GAAaZ,OAAO,CAACa,iBAArB;AACAF,SAAI,CAACG,KAAL,GAAad,OAAO,CAACa,iBAArB;AAEAF,SAAI,CAACI,gBAAL,GAAwBV,eAAxB;;AAEA,QAAMW,MAAM,GAAGL,KAAI,CAACM,UAAL,EAAf;;AACA,QAAI,CAACD,MAAL,EAAa;;AAEZ;;AAED,QAAIb,OAAO,CAACe,UAAZ,EAAwB;AACpBP,WAAI,CAACQ,OAAL,GAAehB,OAAf;AACAQ,WAAI,CAACS,QAAL,GAAgBJ,MAAM,CAACK,oBAAP,CAA4BlB,OAAO,CAACmB,KAApC,EAA2CnB,OAAO,CAACoB,MAAnD,EAA2DlB,eAA3D,EAA4EC,YAA5E,CAAhB;AACH,KAHD,MAGO;AACHK,WAAI,CAACQ,OAAL,GAAeH,MAAM,CAACQ,YAAP,CAAoB,CAApB,EAAuB,CAAvB,CAAf;;AAEA,UAAIrB,OAAO,CAACmB,KAAR,IAAiBnB,OAAO,CAACmB,KAAR,KAAkB,CAAvC,EAA0C;AACtCX,aAAI,CAACS,QAAL,GAAgBJ,MAAM,CAACK,oBAAP,CAA4BlB,OAAO,CAACmB,KAApC,EAA2CnB,OAAO,CAACoB,MAAnD,EAA2DlB,eAA3D,EAA4EC,YAA5E,CAAhB;AACH,OAFD,MAEO;AACHK,aAAI,CAACS,QAAL,GAAgBJ,MAAM,CAACK,oBAAP,CAA4BlB,OAA5B,EAAqCA,OAArC,EAA8CE,eAA9C,EAA+DC,YAA/D,CAAhB;AACH;AACJ;;AAED,QAAMmB,WAAW,GAAGd,KAAI,CAACe,OAAL,EAApB;;AAEA,QAAIf,KAAI,CAACQ,OAAL,CAAaG,KAAb,KAAuBG,WAAW,CAACH,KAAvC,EAA8C;AAC1CX,WAAI,CAACQ,OAAL,CAAaG,KAAb,GAAqBG,WAAW,CAACH,KAAjC;AACH;;AACD,QAAIX,KAAI,CAACQ,OAAL,CAAaI,MAAb,KAAwBE,WAAW,CAACF,MAAxC,EAAgD;AAC5CZ,WAAI,CAACQ,OAAL,CAAaI,MAAb,GAAsBE,WAAW,CAACF,MAAlC;AACH;;AACDZ,SAAI,CAACgB,QAAL,GAAgBhB,KAAI,CAACQ,OAAL,CAAaD,UAAb,CAAwB,IAAxB,CAAhB;;AACH;AAED;;;;;;AAIOU,0CAAP;AACI,WAAO,gBAAP;AACH,GAFM;;AAOPC,wBAAWD,wBAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA;AACI,aAAO,IAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;;AAIQA,uCAAR,UAAkBH,WAAlB,EAAoC;AAChC,SAAKN,OAAL,CAAaG,KAAb,GAAqBG,WAAW,CAACH,KAAjC;AACA,SAAKH,OAAL,CAAaI,MAAb,GAAsBE,WAAW,CAACF,MAAlC;AAEA,SAAKO,sBAAL;AAEA,SAAKV,QAAL,GAAgB,KAAKH,UAAL,GAAmBI,oBAAnB,CAAwCI,WAAW,CAACH,KAApD,EAA2DG,WAAW,CAACF,MAAvE,EAA+E,KAAKR,gBAApF,EAAsG,KAAKT,YAA3G,CAAhB;AACH,GAPO;AASR;;;;;;AAIOsB,mCAAP,UAAaG,KAAb,EAA0B;AACtB,QAAMN,WAAW,GAAG,KAAKC,OAAL,EAApB;AAEAD,eAAW,CAACH,KAAZ,IAAqBS,KAArB;AACAN,eAAW,CAACF,MAAZ,IAAsBQ,KAAtB;;AAEA,SAAKC,SAAL,CAAeP,WAAf;AACH,GAPM;AASP;;;;;;;AAKOG,qCAAP,UAAeN,KAAf,EAA8BC,MAA9B,EAA4C;AACxC,QAAME,WAAW,GAAG,KAAKC,OAAL,EAApB;AAEAD,eAAW,CAACH,KAAZ,GAAoBA,KAApB;AACAG,eAAW,CAACF,MAAZ,GAAqBA,MAArB;;AAEA,SAAKS,SAAL,CAAeP,WAAf;AACH,GAPM;AASP;;;;;;AAIOG,wCAAP;AACI,WAAO,KAAKD,QAAZ;AACH,GAFM;AAIP;;;;;AAGOC,mCAAP;AACI,QAAMK,IAAI,GAAG,KAAKP,OAAL,EAAb;;AACA,SAAKC,QAAL,CAAcO,QAAd,CAAuB,CAAvB,EAA0B,CAA1B,EAA6BD,IAAI,CAACX,KAAlC,EAAyCW,IAAI,CAACV,MAA9C;AACH,GAHM;AAKP;;;;;;;;AAMOK,oCAAP,UAAcpB,OAAd,EAAiC2B,WAAjC,EAAsDC,oBAAtD,EAAkF;AAAjD;AAAAD;AAAmB;;AAAE;AAAAC;AAA4B;;AAC9E,SAAKnB,UAAL,GAAmBoB,oBAAnB,CACI,KAAKjB,QADT,EAEI,KAAKD,OAFT,EAGIX,OAAO,KAAKE,SAAZ,GAAwB,IAAxB,GAA+BF,OAHnC,EAII2B,WAJJ,EAKI,KAAKG,OAAL,IAAgB5B,SALpB,EAMIA,SANJ,EAOI0B,oBAPJ;AASH,GAVM;AAYP;;;;;;;;;;;;;AAWOR,sCAAP,UACIW,IADJ,EAEIC,CAFJ,EAGIC,CAHJ,EAIIC,IAJJ,EAKIC,KALJ,EAMIC,UANJ,EAOIpC,OAPJ,EAQIqC,MARJ,EAQiB;AAAb;AAAAA;AAAa;;AAEb,QAAMZ,IAAI,GAAG,KAAKP,OAAL,EAAb;;AACA,QAAIkB,UAAJ,EAAgB;AACZ,WAAKjB,QAAL,CAAcmB,SAAd,GAA0BF,UAA1B;;AACA,WAAKjB,QAAL,CAAcO,QAAd,CAAuB,CAAvB,EAA0B,CAA1B,EAA6BD,IAAI,CAACX,KAAlC,EAAyCW,IAAI,CAACV,MAA9C;AACH;;AAED,SAAKI,QAAL,CAAce,IAAd,GAAqBA,IAArB;;AACA,QAAIF,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK9B,SAAxB,EAAmC;AAC/B,UAAMqC,QAAQ,GAAG,KAAKpB,QAAL,CAAcqB,WAAd,CAA0BT,IAA1B,CAAjB;;AACAC,OAAC,GAAG,CAACP,IAAI,CAACX,KAAL,GAAayB,QAAQ,CAACzB,KAAvB,IAAgC,CAApC;AACH;;AACD,QAAImB,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK/B,SAAxB,EAAmC;AAC/B,UAAMuC,QAAQ,GAAGC,QAAQ,CAACR,IAAI,CAACS,OAAL,CAAa,KAAb,EAAoB,EAApB,CAAD,CAAzB;AACAV,OAAC,GAAGR,IAAI,CAACV,MAAL,GAAc,CAAd,GAAkB0B,QAAQ,GAAG,IAAjC;AACH;;AAED,SAAKtB,QAAL,CAAcmB,SAAd,GAA0BH,KAAK,IAAI,EAAnC;;AACA,SAAKhB,QAAL,CAAcyB,QAAd,CAAuBb,IAAvB,EAA6BC,CAA7B,EAAgCC,CAAhC;;AAEA,QAAII,MAAJ,EAAY;AACR,WAAKA,MAAL,CAAYrC,OAAZ;AACH;AACJ,GAhCM;AAkCP;;;;;;AAIOoB,mCAAP;AACI,QAAMxB,KAAK,GAAG,KAAKiD,QAAL,EAAd;;AAEA,QAAI,CAACjD,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AAED,QAAMqB,WAAW,GAAG,KAAKC,OAAL,EAApB;AACA,QAAM4B,UAAU,GAAG,IAAI1B,cAAJ,CAAmB,KAAK1B,IAAxB,EAA8BuB,WAA9B,EAA2CrB,KAA3C,EAAkD,KAAKW,gBAAvD,CAAnB,CARJ,CAUI;;AACAuC,cAAU,CAACC,QAAX,GAAsB,KAAKA,QAA3B;AACAD,cAAU,CAACE,KAAX,GAAmB,KAAKA,KAAxB,CAZJ,CAcI;;AACAF,cAAU,CAAC1C,KAAX,GAAmB,KAAKA,KAAxB;AACA0C,cAAU,CAACxC,KAAX,GAAmB,KAAKA,KAAxB;AAEA,WAAOwC,UAAP;AACH,GAnBM;AAqBP;;;;;;AAIO1B,uCAAP;AACI,QAAMxB,KAAK,GAAG,KAAKiD,QAAL,EAAd;;AACA,QAAIjD,KAAK,IAAI,CAACA,KAAK,CAACqD,OAAN,EAAd,EAA+B;AAC3B1D,YAAM,CAAC2D,IAAP,CAAY,gEAAZ;AACH;;AAED,QAAMC,mBAAmB,GAAGlD,iBAAMmD,SAAN,CAAeC,IAAf,CAAe,IAAf,CAA5B;;AACA,QAAIjC,cAAc,CAACkC,gBAAf,CAAgC,KAAK3C,OAArC,CAAJ,EAAmD;AAC/CwC,yBAAmB,CAACI,YAApB,GAAmC,KAAK5C,OAAL,CAAa6C,SAAb,EAAnC;AACH;;AAEDL,uBAAmB,CAACnD,OAApB,GAA8B,KAAKyD,QAAnC;AACAN,uBAAmB,CAACrD,YAApB,GAAmC,KAAKA,YAAxC;AAEA,WAAOqD,mBAAP;AACH,GAfM;;AAiBQ/B,oCAAf,UAAgCsC,MAAhC,EAAqF;AACjF,WAAQA,MAA4B,CAACF,SAA7B,KAA2CtD,SAAnD;AACH,GAFc;AAIf;;;AACOkB,sCAAP;AACI,SAAKiB,MAAL;AACH,GAFM;;AAGX;AAAC,CAtPD,CAAoC7C,OAApC","names":["Logger","Texture","__extends","name","options","scene","generateMipMaps","samplingMode","format","invertY","_super","undefined","_this","wrapU","CLAMP_ADDRESSMODE","wrapV","_generateMipMaps","engine","_getEngine","getContext","_canvas","_texture","createDynamicTexture","width","height","createCanvas","textureSize","getSize","_context","DynamicTexture","Object","releaseInternalTexture","ratio","_recreate","size","fillRect","premulAlpha","allowGPUOptimization","updateDynamicTexture","_format","text","x","y","font","color","clearColor","update","fillStyle","textSize","measureText","fontSize","parseInt","replace","fillText","getScene","newTexture","hasAlpha","level","isReady","Warn","serializationObject","serialize","call","_IsCanvasElement","base64String","toDataURL","_invertY","canvas"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/dynamicTexture.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        const size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        clearColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}