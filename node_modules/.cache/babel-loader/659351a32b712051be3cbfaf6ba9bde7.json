{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { __extends } from \"tslib\";\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\n/**\n * Mirror texture can be used to simulate the view from a mirror in a scene.\n * It will dynamically be rendered every frame to adapt to the camera point of view.\n * You can then easily use it as a reflectionTexture on a flat surface.\n * In case the surface is not a plane, please consider relying on reflection probes.\n * @see https://doc.babylonjs.com/how_to/reflect#mirrors\n */\n\nvar MirrorTexture =\n/** @class */\nfunction (_super) {\n  __extends(MirrorTexture, _super);\n  /**\n   * Instantiates a Mirror Texture.\n   * Mirror texture can be used to simulate the view from a mirror in a scene.\n   * It will dynamically be rendered every frame to adapt to the camera point of view.\n   * You can then easily use it as a reflectionTexture on a flat surface.\n   * In case the surface is not a plane, please consider relying on reflection probes.\n   * @see https://doc.babylonjs.com/how_to/reflect#mirrors\n   * @param name\n   * @param size\n   * @param scene\n   * @param generateMipMaps\n   * @param type\n   * @param samplingMode\n   * @param generateDepthBuffer\n   */\n\n\n  function MirrorTexture(name, size, scene, generateMipMaps, type, samplingMode, generateDepthBuffer) {\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    if (generateDepthBuffer === void 0) {\n      generateDepthBuffer = true;\n    }\n\n    var _this = _super.call(this, name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer) || this;\n    /**\n     * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.\n     * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.\n     * @see https://doc.babylonjs.com/how_to/reflect#mirrors\n     */\n\n\n    _this.mirrorPlane = new Plane(0, 1, 0, 1);\n    _this._transformMatrix = Matrix.Zero();\n    _this._mirrorMatrix = Matrix.Zero();\n    _this._adaptiveBlurKernel = 0;\n    _this._blurKernelX = 0;\n    _this._blurKernelY = 0;\n    _this._blurRatio = 1.0;\n    scene = _this.getScene();\n\n    if (!scene) {\n      return _this;\n    }\n\n    _this.ignoreCameraViewport = true;\n\n    _this._updateGammaSpace();\n\n    _this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(function () {\n      _this._updateGammaSpace();\n    });\n    var engine = scene.getEngine();\n\n    if (engine.supportsUniformBuffers) {\n      _this._sceneUBO = scene.createSceneUniformBuffer(\"Scene for Mirror Texture (name \\\"\".concat(name, \"\\\")\"));\n    }\n\n    _this.onBeforeBindObservable.add(function () {\n      var _a;\n\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"mirror generation for \".concat(name), 1);\n    });\n\n    _this.onAfterUnbindObservable.add(function () {\n      var _a;\n\n      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n    });\n\n    var saveClipPlane;\n\n    _this.onBeforeRenderObservable.add(function () {\n      if (_this._sceneUBO) {\n        _this._currentSceneUBO = scene.getSceneUniformBuffer();\n        scene.setSceneUniformBuffer(_this._sceneUBO);\n        scene.getSceneUniformBuffer().unbindEffect();\n      }\n\n      Matrix.ReflectionToRef(_this.mirrorPlane, _this._mirrorMatrix);\n\n      _this._mirrorMatrix.multiplyToRef(scene.getViewMatrix(), _this._transformMatrix);\n\n      scene.setTransformMatrix(_this._transformMatrix, scene.getProjectionMatrix());\n      saveClipPlane = scene.clipPlane;\n      scene.clipPlane = _this.mirrorPlane;\n      scene.getEngine().cullBackFaces = false;\n      scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.globalPosition, _this._mirrorMatrix);\n    });\n\n    _this.onAfterRenderObservable.add(function () {\n      if (_this._sceneUBO) {\n        scene.setSceneUniformBuffer(_this._currentSceneUBO);\n      }\n\n      scene.updateTransformMatrix();\n      scene.getEngine().cullBackFaces = null;\n      scene._mirroredCameraPosition = null;\n      scene.clipPlane = saveClipPlane;\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(MirrorTexture.prototype, \"blurRatio\", {\n    get: function get() {\n      return this._blurRatio;\n    },\n\n    /**\n     * Define the blur ratio used to blur the reflection if needed.\n     */\n    set: function set(value) {\n      if (this._blurRatio === value) {\n        return;\n      }\n\n      this._blurRatio = value;\n\n      this._preparePostProcesses();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MirrorTexture.prototype, \"adaptiveBlurKernel\", {\n    /**\n     * Define the adaptive blur kernel used to blur the reflection if needed.\n     * This will autocompute the closest best match for the `blurKernel`\n     */\n    set: function set(value) {\n      this._adaptiveBlurKernel = value;\n\n      this._autoComputeBlurKernel();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MirrorTexture.prototype, \"blurKernel\", {\n    /**\n     * Define the blur kernel used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set: function set(value) {\n      this.blurKernelX = value;\n      this.blurKernelY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MirrorTexture.prototype, \"blurKernelX\", {\n    get: function get() {\n      return this._blurKernelX;\n    },\n\n    /**\n     * Define the blur kernel on the X Axis used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set: function set(value) {\n      if (this._blurKernelX === value) {\n        return;\n      }\n\n      this._blurKernelX = value;\n\n      this._preparePostProcesses();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MirrorTexture.prototype, \"blurKernelY\", {\n    get: function get() {\n      return this._blurKernelY;\n    },\n\n    /**\n     * Define the blur kernel on the Y Axis used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set: function set(value) {\n      if (this._blurKernelY === value) {\n        return;\n      }\n\n      this._blurKernelY = value;\n\n      this._preparePostProcesses();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MirrorTexture.prototype._autoComputeBlurKernel = function () {\n    var engine = this.getScene().getEngine();\n    var dw = this.getRenderWidth() / engine.getRenderWidth();\n    var dh = this.getRenderHeight() / engine.getRenderHeight();\n    this.blurKernelX = this._adaptiveBlurKernel * dw;\n    this.blurKernelY = this._adaptiveBlurKernel * dh;\n  };\n\n  MirrorTexture.prototype._onRatioRescale = function () {\n    if (this._sizeRatio) {\n      this.resize(this._initialSizeParameter);\n\n      if (!this._adaptiveBlurKernel) {\n        this._preparePostProcesses();\n      }\n    }\n\n    if (this._adaptiveBlurKernel) {\n      this._autoComputeBlurKernel();\n    }\n  };\n\n  MirrorTexture.prototype._updateGammaSpace = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this.gammaSpace = !scene.imageProcessingConfiguration.isEnabled || !scene.imageProcessingConfiguration.applyByPostProcess;\n  };\n\n  MirrorTexture.prototype._preparePostProcesses = function () {\n    this.clearPostProcesses(true);\n\n    if (this._blurKernelX && this._blurKernelY) {\n      var engine = this.getScene().getEngine();\n      var textureType = engine.getCaps().textureFloatRender && engine.getCaps().textureFloatLinearFiltering ? 1 : 2;\n      this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), this._blurKernelX, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n      this._blurX.autoClear = false;\n\n      if (this._blurRatio === 1 && this.samples < 2 && this._texture) {\n        this._blurX.inputTexture = this._renderTarget;\n      } else {\n        this._blurX.alwaysForcePOT = true;\n      }\n\n      this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), this._blurKernelY, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n      this._blurY.autoClear = false;\n      this._blurY.alwaysForcePOT = this._blurRatio !== 1;\n      this.addPostProcess(this._blurX);\n      this.addPostProcess(this._blurY);\n    } else {\n      if (this._blurY) {\n        this.removePostProcess(this._blurY);\n\n        this._blurY.dispose();\n\n        this._blurY = null;\n      }\n\n      if (this._blurX) {\n        this.removePostProcess(this._blurX);\n\n        this._blurX.dispose();\n\n        this._blurX = null;\n      }\n    }\n  };\n  /**\n   * Clone the mirror texture.\n   * @returns the cloned texture\n   */\n\n\n  MirrorTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var textureSize = this.getSize();\n    var newTexture = new MirrorTexture(this.name, textureSize.width, scene, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // Mirror Texture\n\n    newTexture.mirrorPlane = this.mirrorPlane.clone();\n\n    if (this.renderList) {\n      newTexture.renderList = this.renderList.slice(0);\n    }\n\n    return newTexture;\n  };\n  /**\n   * Serialize the texture to a JSON representation you could use in Parse later on\n   * @returns the serialized JSON representation\n   */\n\n\n  MirrorTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.mirrorPlane = this.mirrorPlane.asArray();\n    return serializationObject;\n  };\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n\n  MirrorTexture.prototype.dispose = function () {\n    var _a;\n\n    _super.prototype.dispose.call(this);\n\n    var scene = this.getScene();\n\n    if (scene) {\n      scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);\n    }\n\n    (_a = this._sceneUBO) === null || _a === void 0 ? void 0 : _a.dispose();\n  };\n\n  return MirrorTexture;\n}(RenderTargetTexture);\n\nexport { MirrorTexture };\n\nTexture._CreateMirror = function (name, renderTargetSize, scene, generateMipMaps) {\n  return new MirrorTexture(name, renderTargetSize, scene, generateMipMaps);\n};","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","Vector2","Texture","RenderTargetTexture","BlurPostProcess","Plane","__extends","name","size","scene","generateMipMaps","type","samplingMode","generateDepthBuffer","BILINEAR_SAMPLINGMODE","_super","_this","Zero","getScene","ignoreCameraViewport","_updateGammaSpace","_imageProcessingConfigChangeObserver","imageProcessingConfiguration","onUpdateParameters","add","engine","getEngine","supportsUniformBuffers","_sceneUBO","createSceneUniformBuffer","onBeforeBindObservable","_debugPushGroup","_a","onAfterUnbindObservable","_debugPopGroup","saveClipPlane","onBeforeRenderObservable","_currentSceneUBO","getSceneUniformBuffer","setSceneUniformBuffer","unbindEffect","ReflectionToRef","mirrorPlane","_mirrorMatrix","multiplyToRef","getViewMatrix","_transformMatrix","setTransformMatrix","getProjectionMatrix","clipPlane","cullBackFaces","_mirroredCameraPosition","TransformCoordinates","activeCamera","globalPosition","onAfterRenderObservable","updateTransformMatrix","Object","MirrorTexture","_blurRatio","value","_preparePostProcesses","_adaptiveBlurKernel","_autoComputeBlurKernel","blurKernelX","blurKernelY","_blurKernelX","_blurKernelY","dw","getRenderWidth","dh","getRenderHeight","_sizeRatio","resize","_initialSizeParameter","gammaSpace","isEnabled","applyByPostProcess","clearPostProcesses","textureType","getCaps","textureFloatRender","textureFloatLinearFiltering","_blurX","autoClear","samples","_texture","inputTexture","_renderTarget","alwaysForcePOT","_blurY","addPostProcess","removePostProcess","dispose","textureSize","getSize","newTexture","width","_renderTargetOptions","hasAlpha","level","clone","renderList","slice","serializationObject","serialize","call","asArray","remove","_CreateMirror","renderTargetSize"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/mirrorTexture.ts"],"sourcesContent":["import type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\n/**\r\n * Mirror texture can be used to simulate the view from a mirror in a scene.\r\n * It will dynamically be rendered every frame to adapt to the camera point of view.\r\n * You can then easily use it as a reflectionTexture on a flat surface.\r\n * In case the surface is not a plane, please consider relying on reflection probes.\r\n * @see https://doc.babylonjs.com/how_to/reflect#mirrors\r\n */\r\nexport class MirrorTexture extends RenderTargetTexture {\r\n    /**\r\n     * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.\r\n     * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#mirrors\r\n     */\r\n    public mirrorPlane = new Plane(0, 1, 0, 1);\r\n\r\n    /**\r\n     * Define the blur ratio used to blur the reflection if needed.\r\n     */\r\n    public set blurRatio(value: number) {\r\n        if (this._blurRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurRatio = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurRatio(): number {\r\n        return this._blurRatio;\r\n    }\r\n\r\n    /**\r\n     * Define the adaptive blur kernel used to blur the reflection if needed.\r\n     * This will autocompute the closest best match for the `blurKernel`\r\n     */\r\n    public set adaptiveBlurKernel(value: number) {\r\n        this._adaptiveBlurKernel = value;\r\n        this._autoComputeBlurKernel();\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernel(value: number) {\r\n        this.blurKernelX = value;\r\n        this.blurKernelY = value;\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel on the X Axis used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernelX(value: number) {\r\n        if (this._blurKernelX === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurKernelX = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurKernelX(): number {\r\n        return this._blurKernelX;\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel on the Y Axis used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernelY(value: number) {\r\n        if (this._blurKernelY === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurKernelY = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurKernelY(): number {\r\n        return this._blurKernelY;\r\n    }\r\n\r\n    private _autoComputeBlurKernel(): void {\r\n        const engine = this.getScene()!.getEngine();\r\n\r\n        const dw = this.getRenderWidth() / engine.getRenderWidth();\r\n        const dh = this.getRenderHeight() / engine.getRenderHeight();\r\n        this.blurKernelX = this._adaptiveBlurKernel * dw;\r\n        this.blurKernelY = this._adaptiveBlurKernel * dh;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n            if (!this._adaptiveBlurKernel) {\r\n                this._preparePostProcesses();\r\n            }\r\n        }\r\n\r\n        if (this._adaptiveBlurKernel) {\r\n            this._autoComputeBlurKernel();\r\n        }\r\n    }\r\n\r\n    private _updateGammaSpace() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.gammaSpace = !scene.imageProcessingConfiguration.isEnabled || !scene.imageProcessingConfiguration.applyByPostProcess;\r\n    }\r\n\r\n    private _imageProcessingConfigChangeObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _mirrorMatrix = Matrix.Zero();\r\n\r\n    private _blurX: Nullable<BlurPostProcess>;\r\n    private _blurY: Nullable<BlurPostProcess>;\r\n    private _adaptiveBlurKernel = 0;\r\n    private _blurKernelX = 0;\r\n    private _blurKernelY = 0;\r\n    private _blurRatio = 1.0;\r\n    private _sceneUBO: UniformBuffer;\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /**\r\n     * Instantiates a Mirror Texture.\r\n     * Mirror texture can be used to simulate the view from a mirror in a scene.\r\n     * It will dynamically be rendered every frame to adapt to the camera point of view.\r\n     * You can then easily use it as a reflectionTexture on a flat surface.\r\n     * In case the surface is not a plane, please consider relying on reflection probes.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#mirrors\r\n     * @param name\r\n     * @param size\r\n     * @param scene\r\n     * @param generateMipMaps\r\n     * @param type\r\n     * @param samplingMode\r\n     * @param generateDepthBuffer\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: number | { width: number; height: number } | { ratio: number },\r\n        scene?: Scene,\r\n        generateMipMaps?: boolean,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        samplingMode = Texture.BILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer = true\r\n    ) {\r\n        super(name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer);\r\n\r\n        scene = <Scene>this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        this.ignoreCameraViewport = true;\r\n\r\n        this._updateGammaSpace();\r\n        this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this._updateGammaSpace();\r\n        });\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        if (engine.supportsUniformBuffers) {\r\n            this._sceneUBO = scene.createSceneUniformBuffer(`Scene for Mirror Texture (name \"${name}\")`);\r\n        }\r\n\r\n        this.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(`mirror generation for ${name}`, 1);\r\n        });\r\n\r\n        this.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        let saveClipPlane: Nullable<Plane>;\r\n\r\n        this.onBeforeRenderObservable.add(() => {\r\n            if (this._sceneUBO) {\r\n                this._currentSceneUBO = scene!.getSceneUniformBuffer();\r\n                scene!.setSceneUniformBuffer(this._sceneUBO);\r\n                scene!.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n\r\n            Matrix.ReflectionToRef(this.mirrorPlane, this._mirrorMatrix);\r\n            this._mirrorMatrix.multiplyToRef(scene!.getViewMatrix(), this._transformMatrix);\r\n\r\n            scene!.setTransformMatrix(this._transformMatrix, scene!.getProjectionMatrix());\r\n\r\n            saveClipPlane = scene!.clipPlane;\r\n            scene!.clipPlane = this.mirrorPlane;\r\n\r\n            scene!.getEngine().cullBackFaces = false;\r\n\r\n            scene!._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene!.activeCamera).globalPosition, this._mirrorMatrix);\r\n        });\r\n\r\n        this.onAfterRenderObservable.add(() => {\r\n            if (this._sceneUBO) {\r\n                scene!.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene!.updateTransformMatrix();\r\n            scene!.getEngine().cullBackFaces = null;\r\n            scene!._mirroredCameraPosition = null;\r\n\r\n            scene!.clipPlane = saveClipPlane;\r\n        });\r\n    }\r\n\r\n    private _preparePostProcesses(): void {\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._blurKernelX && this._blurKernelY) {\r\n            const engine = (<Scene>this.getScene()).getEngine();\r\n\r\n            const textureType =\r\n                engine.getCaps().textureFloatRender && engine.getCaps().textureFloatLinearFiltering ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            this._blurX = new BlurPostProcess(\r\n                \"horizontal blur\",\r\n                new Vector2(1.0, 0),\r\n                this._blurKernelX,\r\n                this._blurRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                textureType\r\n            );\r\n            this._blurX.autoClear = false;\r\n\r\n            if (this._blurRatio === 1 && this.samples < 2 && this._texture) {\r\n                this._blurX.inputTexture = this._renderTarget!;\r\n            } else {\r\n                this._blurX.alwaysForcePOT = true;\r\n            }\r\n\r\n            this._blurY = new BlurPostProcess(\r\n                \"vertical blur\",\r\n                new Vector2(0, 1.0),\r\n                this._blurKernelY,\r\n                this._blurRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                textureType\r\n            );\r\n            this._blurY.autoClear = false;\r\n            this._blurY.alwaysForcePOT = this._blurRatio !== 1;\r\n\r\n            this.addPostProcess(this._blurX);\r\n            this.addPostProcess(this._blurY);\r\n        } else {\r\n            if (this._blurY) {\r\n                this.removePostProcess(this._blurY);\r\n                this._blurY.dispose();\r\n                this._blurY = null;\r\n            }\r\n            if (this._blurX) {\r\n                this.removePostProcess(this._blurX);\r\n                this._blurX.dispose();\r\n                this._blurX = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the mirror texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): MirrorTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new MirrorTexture(\r\n            this.name,\r\n            textureSize.width,\r\n            scene,\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._renderTargetOptions.type,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Mirror Texture\r\n        newTexture.mirrorPlane = this.mirrorPlane.clone();\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation you could use in Parse later on\r\n     * @returns the serialized JSON representation\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.mirrorPlane = this.mirrorPlane.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        const scene = this.getScene();\r\n\r\n        if (scene) {\r\n            scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);\r\n        }\r\n        this._sceneUBO?.dispose();\r\n    }\r\n}\r\n\r\nTexture._CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n    return new MirrorTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}