{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a tiled box\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * @param options.pattern\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.faceUV\n * @param options.faceColors\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @returns the VertexData of the TiledBox\n */\n\nexport function CreateTiledBoxVertexData(options) {\n  var nbFaces = 6;\n  var faceUV = options.faceUV || new Array(6);\n  var faceColors = options.faceColors;\n  var flipTile = options.pattern || Mesh.NO_FLIP;\n  var width = options.width || options.size || 1;\n  var height = options.height || options.size || 1;\n  var depth = options.depth || options.size || 1;\n  var tileWidth = options.tileWidth || options.tileSize || 1;\n  var tileHeight = options.tileHeight || options.tileSize || 1;\n  var alignH = options.alignHorizontal || 0;\n  var alignV = options.alignVertical || 0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // default face colors and UV if undefined\n\n  for (var f = 0; f < nbFaces; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var halfDepth = depth / 2;\n  var faceVertexData = [];\n\n  for (var f = 0; f < 2; f++) {\n    //front and back\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  for (var f = 2; f < 4; f++) {\n    //sides\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: depth,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var baseAlignV = alignV;\n\n  if (alignV === Mesh.BOTTOM) {\n    baseAlignV = Mesh.TOP;\n  } else if (alignV === Mesh.TOP) {\n    baseAlignV = Mesh.BOTTOM;\n  }\n\n  for (var f = 4; f < 6; f++) {\n    //top and bottom\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: depth,\n      alignVertical: baseAlignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var indices = [];\n  var colors = [];\n  var facePositions = [];\n  var faceNormals = [];\n  var newFaceUV = [];\n  var lu = 0;\n  var li = 0;\n\n  for (var f = 0; f < nbFaces; f++) {\n    var len = faceVertexData[f].positions.length;\n    facePositions[f] = [];\n    faceNormals[f] = [];\n\n    for (var p = 0; p < len / 3; p++) {\n      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n    } // uvs\n\n\n    lu = faceVertexData[f].uvs.length;\n    newFaceUV[f] = [];\n\n    for (var i = 0; i < lu; i += 2) {\n      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n\n      if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n        newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\n      }\n    }\n\n    uvs = uvs.concat(newFaceUV[f]);\n    indices = indices.concat(faceVertexData[f].indices.map(function (x) {\n      return x + li;\n    }));\n    li += facePositions[f].length;\n\n    if (faceColors) {\n      for (var c = 0; c < 4; c++) {\n        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n      }\n    }\n  }\n\n  var vec0 = new Vector3(0, 0, halfDepth);\n  var mtrx0 = Matrix.RotationY(Math.PI);\n  positions = facePositions[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0).add(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  normals = faceNormals[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  positions = positions.concat(facePositions[1].map(function (entry) {\n    return entry.subtract(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[1].map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec2 = new Vector3(halfWidth, 0, 0);\n  var mtrx2 = Matrix.RotationY(-Math.PI / 2);\n  positions = positions.concat(facePositions[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2).add(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx3 = Matrix.RotationY(Math.PI / 2);\n  positions = positions.concat(facePositions[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3).subtract(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec4 = new Vector3(0, halfHeight, 0);\n  var mtrx4 = Matrix.RotationX(Math.PI / 2);\n  positions = positions.concat(facePositions[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4).add(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx5 = Matrix.RotationX(-Math.PI / 2);\n  positions = positions.concat(facePositions[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5).subtract(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, [])); // sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n}\n/**\n * Creates a tiled box mesh\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param options.pattern\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\n\nexport function CreateTiledBox(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreateTiledBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledBox instead\n */\n\nexport var TiledBoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledBox: CreateTiledBox\n};\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","Vector4","Color4","Mesh","VertexData","CreateTiledPlaneVertexData","CompatibilityOptions","CreateTiledBoxVertexData","options","nbFaces","faceUV","Array","faceColors","flipTile","pattern","NO_FLIP","width","size","height","depth","tileWidth","tileSize","tileHeight","alignH","alignHorizontal","alignV","alignVertical","sideOrientation","DEFAULTSIDE","f","undefined","halfWidth","halfHeight","halfDepth","faceVertexData","baseAlignV","BOTTOM","TOP","positions","normals","uvs","indices","colors","facePositions","faceNormals","newFaceUV","lu","li","len","length","p","push","i","x","z","y","w","UseOpenGLOrientationForUV","concat","map","c","r","g","b","a","vec0","mtrx0","RotationY","Math","PI","entry","TransformNormal","add","reduce","accumulator","currentValue","subtract","vec2","mtrx2","mtrx3","vec4","mtrx4","RotationX","mtrx5","_ComputeSides","vertexData","totalColors","DOUBLESIDE","CreateTiledBox","name","scene","box","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TiledBoxBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/tiledBoxBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled box\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * @param options.pattern\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @returns the VertexData of the TiledBox\r\n */\r\nexport function CreateTiledBoxVertexData(options: {\r\n    pattern?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n    const halfDepth = depth / 2;\r\n\r\n    const faceVertexData: Array<VertexData> = [];\r\n\r\n    for (let f = 0; f < 2; f++) {\r\n        //front and back\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    for (let f = 2; f < 4; f++) {\r\n        //sides\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    } else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (let f = 4; f < 6; f++) {\r\n        //top and bottom\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let positions: Array<number> = [];\r\n    let normals: Array<number> = [];\r\n    let uvs: Array<number> = [];\r\n    let indices: Array<number> = [];\r\n    const colors: Array<number> = [];\r\n    const facePositions: Array<Array<Vector3>> = [];\r\n    const faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    const newFaceUV: Array<Array<number>> = [];\r\n    let lu: number = 0;\r\n\r\n    let li: number = 0;\r\n\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        const len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (let p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (let i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\r\n            }\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    const vec0 = new Vector3(0, 0, halfDepth);\r\n    const mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    normals = faceNormals[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    positions = positions.concat(\r\n        facePositions[1]\r\n            .map((entry) => entry.subtract(vec0))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []));\r\n\r\n    const vec2 = new Vector3(halfWidth, 0, 0);\r\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    const vec4 = new Vector3(0, halfHeight, 0);\r\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled box mesh\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param options.pattern\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledBox(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledBox instead\r\n */\r\nexport const TiledBoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledBox,\r\n};\r\n\r\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\r\n"]},"metadata":{},"sourceType":"module"}