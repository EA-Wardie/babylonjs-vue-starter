{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { __assign, __decorate } from \"tslib\";\nimport { SerializationHelper, serialize } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TextureSampler } from \"../Materials/Textures/textureSampler.js\";\n/**\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\n */\n\nvar ComputeShader =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new compute shader.\n   * @param name Defines the name of the compute shader in the scene\n   * @param engine Defines the engine the compute shader belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\n   *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\n   *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\n   *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   */\n  function ComputeShader(name, engine, shaderPath, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._bindings = {};\n    this._samplers = {};\n    this._contextIsDirty = false;\n    /**\n     * Callback triggered when the shader is compiled\n     */\n\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n\n    this.onError = null;\n    this.name = name;\n    this._engine = engine;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n\n    if (!this._engine.getCaps().supportComputeShaders) {\n      Logger.Error(\"This engine does not support compute shaders!\");\n      return;\n    }\n\n    if (!options.bindingsMapping) {\n      Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\n      return;\n    }\n\n    this._context = engine.createComputeContext();\n    this._shaderPath = shaderPath;\n    this._options = __assign({\n      bindingsMapping: {},\n      defines: []\n    }, options);\n  }\n\n  Object.defineProperty(ComputeShader.prototype, \"options\", {\n    /**\n     * The options used to create the shader\n     */\n    get: function get() {\n      return this._options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ComputeShader.prototype, \"shaderPath\", {\n    /**\n     * The shaderPath used to create the shader\n     */\n    get: function get() {\n      return this._shaderPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current class name of the material e.g. \"ComputeShader\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n\n  ComputeShader.prototype.getClassName = function () {\n    return \"ComputeShader\";\n  };\n  /**\n   * Binds a texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\n   */\n\n\n  ComputeShader.prototype.setTexture = function (name, texture, bindSampler) {\n    if (bindSampler === void 0) {\n      bindSampler = true;\n    }\n\n    var current = this._bindings[name];\n    this._bindings[name] = {\n      type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name].type);\n  };\n  /**\n   * Binds a storage texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n\n\n  ComputeShader.prototype.setStorageTexture = function (name, texture) {\n    var current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageTexture,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  };\n  /**\n   * Binds a uniform buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n\n\n  ComputeShader.prototype.setUniformBuffer = function (name, buffer) {\n    var current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.UniformBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  };\n  /**\n   * Binds a storage buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n\n\n  ComputeShader.prototype.setStorageBuffer = function (name, buffer) {\n    var current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  };\n  /**\n   * Binds a texture sampler to the shader\n   * @param name Binding name of the sampler\n   * @param sampler Sampler to bind\n   */\n\n\n  ComputeShader.prototype.setTextureSampler = function (name, sampler) {\n    var current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));\n    this._bindings[name] = {\n      type: ComputeBindingType.Sampler,\n      object: sampler,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  };\n  /**\n   * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\n   * @returns true if the compute shader is ready to be executed\n   */\n\n\n  ComputeShader.prototype.isReady = function () {\n    var effect = this._effect;\n\n    for (var key in this._bindings) {\n      var binding = this._bindings[key],\n          type = binding.type,\n          object = binding.object;\n\n      switch (type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            var texture = object;\n\n            if (!texture.isReady()) {\n              return false;\n            }\n\n            break;\n          }\n      }\n    }\n\n    var defines = [];\n    var shaderName = this._shaderPath;\n\n    if (this._options.defines) {\n      for (var index = 0; index < this._options.defines.length; index++) {\n        defines.push(this._options.defines[index]);\n      }\n    }\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      effect = this._engine.createComputeEffect(shaderName, {\n        defines: join,\n        entryPoint: this._options.entryPoint,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      });\n      this._effect = effect;\n    }\n\n    if (!effect.isReady()) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Dispatches (executes) the compute shader\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\n   */\n\n\n  ComputeShader.prototype.dispatch = function (x, y, z) {\n    var _a;\n\n    if (!this.isReady()) {\n      return false;\n    } // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\n\n\n    for (var key in this._bindings) {\n      var binding = this._bindings[key]; // TODO: remove this when browsers support reflection for wgsl shaders\n\n      if (!this._options.bindingsMapping[key]) {\n        throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\n      }\n\n      if (binding.type !== ComputeBindingType.Texture) {\n        continue;\n      }\n\n      var sampler = this._samplers[key];\n      var texture = binding.object;\n\n      if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\n        this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) === null || _a === void 0 ? void 0 : _a._comparisonFunction);\n        this._contextIsDirty = true;\n      }\n    }\n\n    if (this._contextIsDirty) {\n      this._contextIsDirty = false;\n\n      this._context.clear();\n    }\n\n    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\n\n    return true;\n  };\n  /**\n   * Waits for the compute shader to be ready and executes it\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\n   * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\n   */\n\n\n  ComputeShader.prototype.dispatchWhenReady = function (x, y, z, delay) {\n    var _this = this;\n\n    if (delay === void 0) {\n      delay = 10;\n    }\n\n    return new Promise(function (resolve) {\n      var check = function check() {\n        if (!_this.dispatch(x, y, z)) {\n          setTimeout(check, delay);\n        } else {\n          resolve();\n        }\n      };\n\n      check();\n    });\n  };\n  /**\n   * Serializes this compute shader in a JSON representation\n   * @returns the serialized compute shader object\n   */\n\n\n  ComputeShader.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.bindings = {};\n    serializationObject.textures = {};\n\n    for (var key in this._bindings) {\n      var binding = this._bindings[key];\n      var object = binding.object;\n\n      switch (binding.type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            var serializedData = object.serialize();\n\n            if (serializedData) {\n              serializationObject.textures[key] = serializedData;\n              serializationObject.bindings[key] = {\n                type: binding.type\n              };\n            }\n\n            break;\n          }\n\n        case ComputeBindingType.UniformBuffer:\n          {\n            break;\n          }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Creates a compute shader from parsed compute shader data\n   * @param source defines the JSON representation of the compute shader\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new compute shader\n   */\n\n\n  ComputeShader.Parse = function (source, scene, rootUrl) {\n    var compute = SerializationHelper.Parse(function () {\n      return new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options);\n    }, source, scene, rootUrl);\n\n    for (var key in source.textures) {\n      var binding = source.bindings[key];\n      var texture = Texture.Parse(source.textures[key], scene, rootUrl);\n\n      if (binding.type === ComputeBindingType.Texture) {\n        compute.setTexture(key, texture);\n      } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\n        compute.setTexture(key, texture, false);\n      } else {\n        compute.setStorageTexture(key, texture);\n      }\n    }\n\n    return compute;\n  };\n\n  __decorate([serialize()], ComputeShader.prototype, \"name\", void 0);\n\n  return ComputeShader;\n}();\n\nexport { ComputeShader };\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);","map":{"version":3,"mappings":"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","names":["SerializationHelper","serialize","RegisterClass","ComputeBindingType","Texture","UniqueIdGenerator","Logger","TextureSampler","name","engine","shaderPath","options","_engine","uniqueId","UniqueId","getCaps","supportComputeShaders","Error","bindingsMapping","_context","createComputeContext","_shaderPath","_options","__assign","defines","Object","ComputeShader","texture","bindSampler","current","_bindings","type","TextureWithoutSampler","object","indexInGroupEntries","_contextIsDirty","StorageTexture","buffer","UniformBuffer","StorageBuffer","sampler","compareSampler","Sampler","effect","_effect","key","binding","isReady","shaderName","index","length","push","join","_cachedDefines","createComputeEffect","entryPoint","onCompiled","onError","x","y","z","_samplers","_texture","setParameters","wrapU","wrapV","wrapR","anisotropicFilteringLevel","samplingMode","_a","_comparisonFunction","clear","computeDispatch","delay","Promise","resolve","check","_this","dispatch","setTimeout","serializationObject","Serialize","bindings","textures","serializedData","source","scene","rootUrl","compute","Parse","getEngine","setTexture","setStorageTexture","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Compute/computeShader.ts"],"sourcesContent":["import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SerializationHelper, serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"./computeEffect\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: ThinEngine;\r\n    private _shaderPath: any;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingList = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\r\n     *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: ThinEngine, shaderPath: any, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            // TODO: remove this when browsers support reflection for wgsl shaders\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            if (binding.type !== ComputeBindingType.Texture) {\r\n                continue;\r\n            }\r\n\r\n            const sampler = this._samplers[key];\r\n            const texture = binding.object as BaseTexture;\r\n\r\n            if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                this._samplers[key] = new TextureSampler().setParameters(\r\n                    texture.wrapU,\r\n                    texture.wrapV,\r\n                    texture.wrapR,\r\n                    texture.anisotropicFilteringLevel,\r\n                    texture._texture!.samplingMode,\r\n                    texture._texture?._comparisonFunction\r\n                );\r\n                this._contextIsDirty = true;\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const check = () => {\r\n                if (!this.dispatch(x, y, z)) {\r\n                    setTimeout(check, delay);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            check();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n"]},"metadata":{},"sourceType":"module"}