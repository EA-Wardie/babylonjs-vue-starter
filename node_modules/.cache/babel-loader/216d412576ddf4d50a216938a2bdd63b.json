{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nvar NAME = \"KHR_materials_unlit\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit)\n */\n\nvar KHR_materials_unlit =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_materials_unlit(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n\n    this.order = 210;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  KHR_materials_unlit.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMaterial\n   * @hidden\n   */\n\n\n  KHR_materials_unlit.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function () {\n      return _this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\n    });\n  };\n\n  KHR_materials_unlit.prototype._loadUnlitPropertiesAsync = function (context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var promises = new Array();\n    babylonMaterial.unlit = true;\n    var properties = material.pbrMetallicRoughness;\n\n    if (properties) {\n      if (properties.baseColorFactor) {\n        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n        babylonMaterial.alpha = properties.baseColorFactor[3];\n      } else {\n        babylonMaterial.albedoColor = Color3.White();\n      }\n\n      if (properties.baseColorTexture) {\n        promises.push(this._loader.loadTextureInfoAsync(\"\".concat(context, \"/baseColorTexture\"), properties.baseColorTexture, function (texture) {\n          texture.name = \"\".concat(babylonMaterial.name, \" (Base Color)\");\n          babylonMaterial.albedoTexture = texture;\n        }));\n      }\n    }\n\n    if (material.doubleSided) {\n      babylonMaterial.backFaceCulling = false;\n      babylonMaterial.twoSidedLighting = true;\n    }\n\n    this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n\n    return Promise.all(promises).then(function () {});\n  };\n\n  return KHR_materials_unlit;\n}();\n\nexport { KHR_materials_unlit };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_unlit(loader);\n});","map":{"version":3,"mappings":";;;;;;AAEA,SAASA,MAAT,QAAiB,qCAAjB;AACA,SAASC,WAAT,QAAsB,8CAAtB;AAKA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,IAAMC,IAAI,GAAG,qBAAb;AAEA;;;;AAGA;AAAA;AAAA;AAkBI;;;;AAIA,+BAAYC,MAAZ,EAA8B;AArB9B;;;AAGgB,gBAAOD,IAAP;AAOhB;;;;AAGO,iBAAQ,GAAR;AASH,SAAKE,OAAL,GAAeD,MAAf;AACA,SAAKE,OAAL,GAAe,KAAKD,OAAL,CAAaE,eAAb,CAA6BJ,IAA7B,CAAf;AACH;AAED;;;AACOK,0CAAP;AACK,SAAKH,OAAL,GAAuB,IAAvB;AACJ,GAFM;AAIP;;;;;;;;AAMOG,8DAAP,UAAmCC,OAAnC,EAAoDC,QAApD,EAAyEC,eAAzE,EAAkG;AAAlG;;AACI,WAAOT,UAAU,CAACU,kBAAX,CAA8BH,OAA9B,EAAuCC,QAAvC,EAAiD,KAAKG,IAAtD,EAA4D;AAC/D,aAAOC,KAAI,CAACC,yBAAL,CAA+BN,OAA/B,EAAwCC,QAAxC,EAAkDC,eAAlD,CAAP;AACH,KAFM,CAAP;AAGH,GAJM;;AAMCH,4DAAR,UAAkCC,OAAlC,EAAmDC,QAAnD,EAAwEC,eAAxE,EAAiG;AAC7F,QAAI,EAAEA,eAAe,YAAYV,WAA7B,CAAJ,EAA+C;AAC3C,YAAM,IAAIe,KAAJ,CAAU,UAAGP,OAAH,EAAU,+BAAV,CAAV,CAAN;AACH;;AAED,QAAMQ,QAAQ,GAAG,IAAIC,KAAJ,EAAjB;AACAP,mBAAe,CAACQ,KAAhB,GAAwB,IAAxB;AAEA,QAAMC,UAAU,GAAGV,QAAQ,CAACW,oBAA5B;;AACA,QAAID,UAAJ,EAAgB;AACZ,UAAIA,UAAU,CAACE,eAAf,EAAgC;AAC5BX,uBAAe,CAACY,WAAhB,GAA8BvB,MAAM,CAACwB,SAAP,CAAiBJ,UAAU,CAACE,eAA5B,CAA9B;AACAX,uBAAe,CAACc,KAAhB,GAAwBL,UAAU,CAACE,eAAX,CAA2B,CAA3B,CAAxB;AACH,OAHD,MAGO;AACHX,uBAAe,CAACY,WAAhB,GAA8BvB,MAAM,CAAC0B,KAAP,EAA9B;AACH;;AAED,UAAIN,UAAU,CAACO,gBAAf,EAAiC;AAC7BV,gBAAQ,CAACW,IAAT,CACI,KAAKvB,OAAL,CAAawB,oBAAb,CAAkC,UAAGpB,OAAH,EAAU,mBAAV,CAAlC,EAAiEW,UAAU,CAACO,gBAA5E,EAA8F,UAACG,OAAD,EAAQ;AAClGA,iBAAO,CAACjB,IAAR,GAAe,UAAGF,eAAe,CAACE,IAAnB,EAAuB,eAAvB,CAAf;AACAF,yBAAe,CAACoB,aAAhB,GAAgCD,OAAhC;AACH,SAHD,CADJ;AAMH;AACJ;;AAED,QAAIpB,QAAQ,CAACsB,WAAb,EAA0B;AACtBrB,qBAAe,CAACsB,eAAhB,GAAkC,KAAlC;AACAtB,qBAAe,CAACuB,gBAAhB,GAAmC,IAAnC;AACH;;AAED,SAAK7B,OAAL,CAAa8B,2BAAb,CAAyC1B,OAAzC,EAAkDC,QAAlD,EAA4DC,eAA5D;;AAEA,WAAOyB,OAAO,CAACC,GAAR,CAAYpB,QAAZ,EAAsBqB,IAAtB,CAA2B,aAAQ,CAAnC,CAAP;AACH,GAnCO;;AAoCZ;AAAC,CAhFD;;;AAkFApC,UAAU,CAACqC,iBAAX,CAA6BpC,IAA7B,EAAmC,UAACC,MAAD,EAAO;AAAK,aAAII,mBAAJ,CAAwBJ,MAAxB;AAA+B,CAA9E","names":["Color3","PBRMaterial","GLTFLoader","NAME","loader","_loader","enabled","isExtensionUsed","KHR_materials_unlit","context","material","babylonMaterial","LoadExtensionAsync","name","_this","_loadUnlitPropertiesAsync","Error","promises","Array","unlit","properties","pbrMetallicRoughness","baseColorFactor","albedoColor","FromArray","alpha","White","baseColorTexture","push","loadTextureInfoAsync","texture","albedoTexture","doubleSided","backFaceCulling","twoSidedLighting","loadMaterialAlphaProperties","Promise","all","then","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_unlit.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit)\r\n */\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 210;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMaterial\r\n     * @hidden\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, () => {\r\n            return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n        babylonMaterial.unlit = true;\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_unlit(loader));\r\n"]},"metadata":{},"sourceType":"module"}