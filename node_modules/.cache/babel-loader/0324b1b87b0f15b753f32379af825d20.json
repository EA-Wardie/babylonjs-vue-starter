{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to read a texture from a sampler\n */\n\nvar TextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(TextureBlock, _super);\n  /**\n   * Create a new TextureBlock\n   * @param name defines the block name\n   * @param fragmentOnly\n   */\n\n\n  function TextureBlock(name, fragmentOnly) {\n    if (fragmentOnly === void 0) {\n      fragmentOnly = false;\n    }\n\n    var _this = _super.call(this, name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment) || this;\n\n    _this._convertToGammaSpace = false;\n    _this._convertToLinearSpace = false;\n    /**\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n     */\n\n    _this.disableLevelMultiplication = false;\n    _this._fragmentOnly = fragmentOnly;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", _this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this._inputs[0]._prioritizeVertex = !fragmentOnly;\n    return _this;\n  }\n\n  Object.defineProperty(TextureBlock.prototype, \"texture\", {\n    /**\n     * Gets or sets the texture associated with the node\n     */\n    get: function get() {\n      var _a;\n\n      if (this.source.isConnected) {\n        return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n      }\n\n      return this._texture;\n    },\n    set: function set(texture) {\n      var _this = this;\n\n      var _a;\n\n      if (this._texture === texture) {\n        return;\n      }\n\n      var scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n\n      if (!texture && scene) {\n        scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this._texture);\n        });\n      }\n\n      this._texture = texture;\n\n      if (texture && scene) {\n        scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(texture);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"samplerName\", {\n    /**\n     * Gets the sampler name associated with this texture\n     */\n    get: function get() {\n      if (this._imageSource) {\n        return this._imageSource.samplerName;\n      }\n\n      return this._samplerName;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"hasImageSource\", {\n    /**\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n     */\n    get: function get() {\n      return !!this._imageSource;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"convertToGammaSpace\", {\n    get: function get() {\n      return this._convertToGammaSpace;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n    set: function set(value) {\n      var _this = this;\n\n      var _a;\n\n      if (value === this._convertToGammaSpace) {\n        return;\n      }\n\n      this._convertToGammaSpace = value;\n\n      if (this.texture) {\n        var scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n        scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this.texture);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"convertToLinearSpace\", {\n    get: function get() {\n      return this._convertToLinearSpace;\n    },\n\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n    set: function set(value) {\n      var _this = this;\n\n      var _a;\n\n      if (value === this._convertToLinearSpace) {\n        return;\n      }\n\n      this._convertToLinearSpace = value;\n\n      if (this.texture) {\n        var scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n        scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this.texture);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n  TextureBlock.prototype.getClassName = function () {\n    return \"TextureBlock\";\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"uv\", {\n    /**\n     * Gets the uv input component\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"source\", {\n    /**\n     * Gets the source input component\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgba\", {\n    /**\n     * Gets the rgba output component\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgb\", {\n    /**\n     * Gets the rgb output component\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"r\", {\n    /**\n     * Gets the r output component\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"g\", {\n    /**\n     * Gets the g output component\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"b\", {\n    /**\n     * Gets the b output component\n     */\n    get: function get() {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"a\", {\n    /**\n     * Gets the a output component\n     */\n    get: function get() {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"level\", {\n    /**\n     * Gets the level output component\n     */\n    get: function get() {\n      return this._outputs[6];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"target\", {\n    get: function get() {\n      if (this._fragmentOnly) {\n        return NodeMaterialBlockTargets.Fragment;\n      } // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\n      // But we need to detect uvs coming from fragment then\n\n\n      if (!this.uv.isConnected) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      if (this.uv.sourceBlock.isInput) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      var parent = this.uv.connectedPoint;\n\n      while (parent) {\n        if (parent.target === NodeMaterialBlockTargets.Fragment) {\n          return NodeMaterialBlockTargets.Fragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Vertex) {\n          return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          var parentBlock = parent.ownerBlock;\n\n          if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {\n            return NodeMaterialBlockTargets.Fragment;\n          }\n\n          parent = null;\n\n          for (var _i = 0, _a = parentBlock.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n\n            if (input.connectedPoint) {\n              parent = input.connectedPoint;\n              break;\n            }\n          }\n        }\n      }\n\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    },\n    set: function set(value) {},\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      if (material.mode === NodeMaterialModes.PostProcess) {\n        var uvInput = material.getBlockByPredicate(function (b) {\n          return b.name === \"uv\";\n        });\n\n        if (uvInput) {\n          uvInput.connectTo(this);\n        }\n      } else {\n        var attributeName_1 = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\n        var uvInput = material.getInputBlockByPredicate(function (b) {\n          return b.isAttribute && b.name === attributeName_1;\n        });\n\n        if (!uvInput) {\n          uvInput = new InputBlock(\"uv\");\n          uvInput.setAsAttribute(attributeName_1);\n        }\n\n        uvInput.output.connectTo(this.uv);\n      }\n    }\n  };\n\n  TextureBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    if (this._mainUVDefineName !== undefined) {\n      defines.setValue(this._mainUVDefineName, false, true);\n    }\n  };\n\n  TextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    if (!this.texture || !this.texture.getTextureMatrix) {\n      if (this._isMixed) {\n        defines.setValue(this._defineName, false, true);\n        defines.setValue(this._mainUVDefineName, true, true);\n      }\n\n      return;\n    }\n\n    var toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n    var toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace; // Not a bug... Name defines the texture space not the required conversion\n\n    defines.setValue(this._linearDefineName, toGamma, true);\n    defines.setValue(this._gammaDefineName, toLinear, true);\n\n    if (this._isMixed) {\n      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\n        defines.setValue(this._defineName, true);\n\n        if (defines[this._mainUVDefineName] == undefined) {\n          defines.setValue(this._mainUVDefineName, false, true);\n        }\n      } else {\n        defines.setValue(this._defineName, false, true);\n        defines.setValue(this._mainUVDefineName, true, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  TextureBlock.prototype.bind = function (effect) {\n    if (!this.texture) {\n      return;\n    }\n\n    if (this._isMixed) {\n      effect.setFloat(this._textureInfoName, this.texture.level);\n      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\n    }\n\n    if (!this._imageSource) {\n      effect.setTexture(this._samplerName, this.texture);\n    }\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"_isMixed\", {\n    get: function get() {\n      return this.target !== NodeMaterialBlockTargets.Fragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype._injectVertexCode = function (state) {\n    var uvInput = this.uv; // Inject code in vertex\n\n    this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\n    this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\n    this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n    this.level.associatedVariableName = this._textureInfoName;\n\n    state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\n\n    state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\n\n    state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\n\n    state.compilationString += \"#ifdef \".concat(this._defineName, \"\\r\\n\");\n    state.compilationString += \"\".concat(this._transformedUVName, \" = vec2(\").concat(this._textureTransformName, \" * vec4(\").concat(uvInput.associatedVariableName, \".xy, 1.0, 0.0));\\r\\n\");\n    state.compilationString += \"#elif defined(\".concat(this._mainUVDefineName, \")\\r\\n\");\n    state.compilationString += \"\".concat(this._mainUVName, \" = \").concat(uvInput.associatedVariableName, \".xy;\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInVertexShader;\n    })) {\n      return;\n    }\n\n    this._writeTextureRead(state, true);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype._generateTextureLookup = function (state) {\n    var samplerName = this.samplerName;\n    state.compilationString += \"#ifdef \".concat(this._defineName, \"\\r\\n\");\n    state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(samplerName, \", \").concat(this._transformedUVName, \");\\r\\n\");\n    state.compilationString += \"#elif defined(\".concat(this._mainUVDefineName, \")\\r\\n\");\n    state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(samplerName, \", \").concat(this._mainUVName ? this._mainUVName : this.uv.associatedVariableName, \");\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  TextureBlock.prototype._writeTextureRead = function (state, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    var uvInput = this.uv;\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      this._generateTextureLookup(state);\n\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"vec4 \".concat(this._tempTextureRead, \" = texture2D(\").concat(this.samplerName, \", \").concat(uvInput.associatedVariableName, \");\\r\\n\");\n      return;\n    }\n\n    this._generateTextureLookup(state);\n  };\n\n  TextureBlock.prototype._generateConversionCode = function (state, output, swizzle) {\n    if (swizzle !== \"a\") {\n      // no conversion if the output is \"a\" (alpha)\n      if (!this.texture || !this.texture.gammaSpace) {\n        state.compilationString += \"#ifdef \".concat(this._linearDefineName, \"\\n                    \").concat(output.associatedVariableName, \" = toGammaSpace(\").concat(output.associatedVariableName, \");\\n                    #endif\\n                \");\n      }\n\n      state.compilationString += \"#ifdef \".concat(this._gammaDefineName, \"\\n                \").concat(output.associatedVariableName, \" = toLinearSpace(\").concat(output.associatedVariableName, \");\\n                #endif\\n            \");\n    }\n  };\n\n  TextureBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n\n      this._generateConversionCode(state, output, swizzle);\n\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle, \";\\r\\n\");\n\n      this._generateConversionCode(state, output, swizzle);\n\n      return;\n    }\n\n    var complement = \"\";\n\n    if (!this.disableLevelMultiplication) {\n      complement = \" * \".concat(this._textureInfoName);\n    }\n\n    state.compilationString += \"\".concat(this._declareOutput(output, state), \" = \").concat(this._tempTextureRead, \".\").concat(swizzle).concat(complement, \";\\r\\n\");\n\n    this._generateConversionCode(state, output, swizzle);\n  };\n\n  TextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (this.source.isConnected) {\n      this._imageSource = this.source.connectedPoint.ownerBlock;\n    } else {\n      this._imageSource = null;\n    }\n\n    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment && this._tempTextureRead === undefined) {\n      this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n      this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n      this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    }\n\n    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {\n      if (!this._imageSource) {\n        this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n\n        state._emit2DSampler(this._samplerName);\n      } // Declarations\n\n\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInFragmentShader;\n    })) {\n      return;\n    }\n\n    if (this._isMixed && !this._imageSource) {\n      // Reexport the sampler\n      state._emit2DSampler(this._samplerName);\n    }\n\n    var comments = \"//\".concat(this.name);\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    if (this._isMixed) {\n      state._emitUniformFromString(this._textureInfoName, \"float\");\n    }\n\n    this._writeTextureRead(state);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  TextureBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    codeString += \"\".concat(this._codeVariableName, \".convertToGammaSpace = \").concat(this.convertToGammaSpace, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".convertToLinearSpace = \").concat(this.convertToLinearSpace, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".disableLevelMultiplication = \").concat(this.disableLevelMultiplication, \";\\r\\n\");\n\n    if (!this.texture) {\n      return codeString;\n    }\n\n    codeString += \"\".concat(this._codeVariableName, \".texture = new BABYLON.Texture(\\\"\").concat(this.texture.name, \"\\\", null, \").concat(this.texture.noMipmap, \", \").concat(this.texture.invertY, \", \").concat(this.texture.samplingMode, \");\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.wrapU = \").concat(this.texture.wrapU, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.wrapV = \").concat(this.texture.wrapV, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.uAng = \").concat(this.texture.uAng, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.vAng = \").concat(this.texture.vAng, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.wAng = \").concat(this.texture.wAng, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.uOffset = \").concat(this.texture.uOffset, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.vOffset = \").concat(this.texture.vOffset, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.uScale = \").concat(this.texture.uScale, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.vScale = \").concat(this.texture.vScale, \";\\r\\n\");\n    codeString += \"\".concat(this._codeVariableName, \".texture.coordinatesMode = \").concat(this.texture.coordinatesMode, \";\\r\\n\");\n    return codeString;\n  };\n\n  TextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.fragmentOnly = this._fragmentOnly;\n    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n\n    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  TextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this._fragmentOnly = !!serializationObject.fragmentOnly;\n    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return TextureBlock;\n}(NodeMaterialBlock);\n\nexport { TextureBlock };\nRegisterClass(\"BABYLON.TextureBlock\", TextureBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","NodeMaterialConnectionPointDirection","NodeMaterial","InputBlock","RegisterClass","Texture","NodeMaterialModes","ImageSourceBlock","NodeMaterialConnectionPointCustomObject","EngineStore","__extends","name","fragmentOnly","_super","Fragment","VertexAndFragment","_this","_fragmentOnly","registerInput","Vector2","Object","Input","registerOutput","Color4","Neutral","Color3","Float","_inputs","acceptedConnectionPointTypes","push","Vector3","Vector4","_prioritizeVertex","TextureBlock","source","isConnected","connectedPoint","_a","ownerBlock","texture","_texture","scene","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","_imageSource","samplerName","_samplerName","_convertToGammaSpace","value","_convertToLinearSpace","_outputs","uv","sourceBlock","isInput","parent","target","Vertex","parentBlock","inputs","_i","input","material","mode","PostProcess","uvInput","getBlockByPredicate","b","connectTo","attributeName_1","Particle","getInputBlockByPredicate","isAttribute","setAsAttribute","output","mesh","nodeMaterial","defines","_areTexturesDirty","_mainUVDefineName","undefined","setValue","getTextureMatrix","_isMixed","_defineName","toGamma","convertToGammaSpace","gammaSpace","toLinear","convertToLinearSpace","_linearDefineName","_gammaDefineName","isIdentityAs3x2","isReadyOrNotBlocking","effect","setFloat","_textureInfoName","level","setMatrix","_textureTransformName","setTexture","state","_getFreeDefineName","associatedVariableName","toUpperCase","_mainUVName","_transformedUVName","_getFreeVariableName","_emitVaryingFromString","_emitUniformFromString","compilationString","concat","some","o","isConnectedInVertexShader","_writeTextureRead","hasEndpoints","_writeOutput","_tempTextureRead","vertexMode","_generateTextureLookup","swizzle","_declareOutput","_generateConversionCode","complement","disableLevelMultiplication","_buildBlock","call","_emit2DSampler","sharedData","blockingBlocks","textureBlocks","blocksWithDefines","bindableBlocks","_injectVertexCode","isConnectedInFragmentShader","comments","_emitFunctionFromInclude","codeString","_dumpPropertiesCode","_codeVariableName","noMipmap","invertY","samplingMode","wrapU","wrapV","uAng","vAng","wAng","uOffset","vOffset","uScale","vScale","coordinatesMode","serializationObject","serialize","hasImageSource","isRenderTarget","getClassName","rootUrl","_deserialize","IgnoreTexturesAtLoadTime","url","indexOf","Parse"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/textureBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\n\r\n/**\r\n * Block used to read a texture from a sampler\r\n */\r\nexport class TextureBlock extends NodeMaterialBlock {\r\n    private _defineName: string;\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _transformedUVName: string;\r\n    private _textureTransformName: string;\r\n    private _textureInfoName: string;\r\n    private _mainUVName: string;\r\n    private _mainUVDefineName: string;\r\n    private _fragmentOnly: boolean;\r\n    private _imageSource: Nullable<ImageSourceBlock>;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        if (this._imageSource) {\r\n            return this._imageSource.samplerName;\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return !!this._imageSource;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TextureBlock\r\n     * @param name defines the block name\r\n     * @param fragmentOnly\r\n     */\r\n    public constructor(name: string, fragmentOnly = false) {\r\n        super(name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._fragmentOnly = fragmentOnly;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._inputs[0]._prioritizeVertex = !fragmentOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public get target() {\r\n        if (this._fragmentOnly) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\r\n        // But we need to detect uvs coming from fragment then\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        let parent = this.uv.connectedPoint;\r\n\r\n        while (parent) {\r\n            if (parent.target === NodeMaterialBlockTargets.Fragment) {\r\n                return NodeMaterialBlockTargets.Fragment;\r\n            }\r\n\r\n            if (parent.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialBlockTargets.VertexAndFragment;\r\n            }\r\n\r\n            if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                const parentBlock = parent.ownerBlock;\r\n\r\n                if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                    return NodeMaterialBlockTargets.Fragment;\r\n                }\r\n\r\n                parent = null;\r\n                for (const input of parentBlock.inputs) {\r\n                    if (input.connectedPoint) {\r\n                        parent = input.connectedPoint;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.VertexAndFragment;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {}\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.uv.isConnected) {\r\n            if (material.mode === NodeMaterialModes.PostProcess) {\r\n                const uvInput = material.getBlockByPredicate((b) => b.name === \"uv\");\r\n\r\n                if (uvInput) {\r\n                    uvInput.connectTo(this);\r\n                }\r\n            } else {\r\n                const attributeName = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\r\n\r\n                let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName);\r\n\r\n                if (!uvInput) {\r\n                    uvInput = new InputBlock(\"uv\");\r\n                    uvInput.setAsAttribute(attributeName);\r\n                }\r\n                uvInput.output.connectTo(this.uv);\r\n            }\r\n        }\r\n    }\r\n\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        if (this._mainUVDefineName !== undefined) {\r\n            defines.setValue(this._mainUVDefineName, false, true);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        if (!this.texture || !this.texture.getTextureMatrix) {\r\n            if (this._isMixed) {\r\n                defines.setValue(this._defineName, false, true);\r\n                defines.setValue(this._mainUVDefineName, true, true);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n\r\n        if (this._isMixed) {\r\n            if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\r\n                defines.setValue(this._defineName, true);\r\n                if (defines[this._mainUVDefineName] == undefined) {\r\n                    defines.setValue(this._mainUVDefineName, false, true);\r\n                }\r\n            } else {\r\n                defines.setValue(this._defineName, false, true);\r\n                defines.setValue(this._mainUVDefineName, true, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed) {\r\n            effect.setFloat(this._textureInfoName, this.texture.level);\r\n            effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\r\n        }\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    private get _isMixed() {\r\n        return this.target !== NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        // Inject code in vertex\r\n        this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\r\n        this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n        this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\r\n        this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = this._textureInfoName;\r\n\r\n        state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\r\n\r\n        state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\r\n\r\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\r\n        state.compilationString += `${this._transformedUVName} = vec2(${this._textureTransformName} * vec4(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\\r\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n\r\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._transformedUVName});\\r\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._mainUVName ? this._mainUVName : this.uv.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            this._generateTextureLookup(state);\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this.samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        this._generateTextureLookup(state);\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            this._generateConversionCode(state, output, swizzle);\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            this._generateConversionCode(state, output, swizzle);\r\n            return;\r\n        }\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\r\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || (state.target === NodeMaterialBlockTargets.Fragment && this._tempTextureRead === undefined)) {\r\n            this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n            this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n            this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n        }\r\n\r\n        if ((!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment) || (this._isMixed && state.target === NodeMaterialBlockTargets.Vertex)) {\r\n            if (!this._imageSource) {\r\n                this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n                state._emit2DSampler(this._samplerName);\r\n            }\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed && !this._imageSource) {\r\n            // Reexport the sampler\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (this._isMixed) {\r\n            state._emitUniformFromString(this._textureInfoName, \"float\");\r\n        }\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\r\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.fragmentOnly = this._fragmentOnly;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this._fragmentOnly = !!serializationObject.fragmentOnly;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TextureBlock\", TextureBlock);\r\n"]},"metadata":{},"sourceType":"module"}