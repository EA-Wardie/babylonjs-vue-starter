{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions.js\";\n/**\n * Class used to store geometry data (vertex buffers + index buffer)\n */\n\nvar Geometry =\n/** @class */\nfunction () {\n  /**\n   * Creates a new geometry\n   * @param id defines the unique ID\n   * @param scene defines the hosting scene\n   * @param vertexData defines the VertexData used to get geometry data\n   * @param updatable defines if geometry must be updatable (false by default)\n   * @param mesh defines the mesh that will be associated with the geometry\n   */\n  function Geometry(id, scene, vertexData, updatable, mesh) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n    /**\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\n     */\n\n\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /** @hidden */\n\n    this._parentContainer = null;\n    /**\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\n     */\n\n    this.useBoundingInfoFromGeometry = false;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    if (!this._scene) {\n      return;\n    }\n\n    this.id = id;\n    this.uniqueId = this._scene.getUniqueId();\n    this._engine = this._scene.getEngine();\n    this._meshes = []; //Init vertex buffer cache\n\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable; // vertexData\n\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n      this._indices = [];\n    }\n\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    } // applyToMesh\n\n\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(Geometry.prototype, \"boundingBias\", {\n    /**\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n     */\n    get: function get() {\n      return this._boundingBias;\n    },\n\n    /**\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n     */\n    set: function set(value) {\n      if (this._boundingBias) {\n        this._boundingBias.copyFrom(value);\n      } else {\n        this._boundingBias = value.clone();\n      }\n\n      this._updateBoundingInfo(true, null);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Static function used to attach a new empty geometry to a mesh\n   * @param mesh defines the mesh to attach the geometry to\n   * @returns the new Geometry\n   */\n\n  Geometry.CreateGeometryForMesh = function (mesh) {\n    var geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"meshes\", {\n    /** Get the list of meshes using this geometry */\n    get: function get() {\n      return this._meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Geometry.prototype, \"extend\", {\n    /**\n     * Gets the current extend of the geometry\n     */\n    get: function get() {\n      return this._extend;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the hosting scene\n   * @returns the hosting Scene\n   */\n\n  Geometry.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\n   * Gets the hosting engine\n   * @returns the hosting Engine\n   */\n\n\n  Geometry.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * Defines if the geometry is ready to use\n   * @returns true if the geometry is ready to be used\n   */\n\n\n  Geometry.prototype.isReady = function () {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\n    /**\n     * Gets a value indicating that the geometry should not be serialized\n     */\n    get: function get() {\n      for (var index = 0; index < this._meshes.length; index++) {\n        if (!this._meshes[index].doNotSerialize) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  Geometry.prototype._rebuild = function () {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    } // Index buffer\n\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    } // Vertex buffers\n\n\n    for (var key in this._vertexBuffers) {\n      var vertexBuffer = this._vertexBuffers[key];\n\n      vertexBuffer._rebuild();\n    }\n  };\n  /**\n   * Affects all geometry data in one call\n   * @param vertexData defines the geometry data\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\n   */\n\n\n  Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n\n    this._notifyUpdate();\n  };\n  /**\n   * Set specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the vertex data to use\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\n   */\n\n\n  Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n\n    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n    this.setVerticesBuffer(buffer);\n  };\n  /**\n   * Removes a specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   */\n\n\n  Geometry.prototype.removeVerticesData = function (kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n\n      delete this._vertexBuffers[kind];\n    }\n\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n  };\n  /**\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\n   * @param buffer defines the vertex buffer to use\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   */\n\n\n  Geometry.prototype.setVerticesBuffer = function (buffer, totalVertices, disposeExistingBuffer) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (disposeExistingBuffer === void 0) {\n      disposeExistingBuffer = true;\n    }\n\n    var kind = buffer.getKind();\n\n    if (this._vertexBuffers[kind] && disposeExistingBuffer) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    if (buffer._buffer) {\n      buffer._buffer._increaseReferences();\n    }\n\n    this._vertexBuffers[kind] = buffer;\n    var meshes = this._meshes;\n    var numOfMeshes = meshes.length;\n\n    if (kind === VertexBuffer.PositionKind) {\n      var data = buffer.getData();\n\n      if (totalVertices != null) {\n        this._totalVertices = totalVertices;\n      } else {\n        if (data != null) {\n          this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\n        }\n      }\n\n      this._updateExtend(data);\n\n      this._resetPointsArrayCache();\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        var mesh = meshes[index];\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false);\n\n        mesh.computeWorldMatrix(true);\n        mesh.synchronizeInstances();\n      }\n    }\n\n    this._notifyUpdate(kind);\n  };\n  /**\n   * Update a specific vertex buffer\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\n   * It will do nothing if the buffer is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param useBytes set to true if the offset is in bytes\n   */\n\n\n  Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset, useBytes) {\n    if (useBytes === void 0) {\n      useBytes = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n\n    this._notifyUpdate(kind);\n  };\n  /**\n   * Update a specific vertex buffer\n   * This function will create a new buffer if the current one is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\n   */\n\n\n  Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\n    if (updateExtends === void 0) {\n      updateExtends = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.update(data);\n\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n\n    this._notifyUpdate(kind);\n  };\n\n  Geometry.prototype._updateBoundingInfo = function (updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n\n    this._resetPointsArrayCache();\n\n    if (updateExtends) {\n      var meshes = this._meshes;\n\n      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n        var mesh = meshes_1[_i];\n\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n\n        var subMeshes = mesh.subMeshes;\n\n        for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {\n          var subMesh = subMeshes_1[_a];\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  };\n  /**\n   * @param effect\n   * @param indexToBind\n   * @hidden\n   */\n\n\n  Geometry.prototype._bind = function (effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {\n    if (!effect) {\n      return;\n    }\n\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n\n    var vbs = this.getVertexBuffers();\n\n    if (!vbs) {\n      return;\n    }\n\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\n\n      return;\n    }\n\n    var vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects; // Using VAO\n\n    if (!vaos[effect.key]) {\n      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\n    }\n\n    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\n  };\n  /**\n   * Gets total number of vertices\n   * @returns the total number of vertices\n   */\n\n\n  Geometry.prototype.getTotalVertices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._totalVertices;\n  };\n  /**\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n\n\n  Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return null;\n    }\n\n    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);\n  };\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if the vertex buffer with the specified kind is updatable\n   */\n\n\n  Geometry.prototype.isVertexBufferUpdatable = function (kind) {\n    var vb = this._vertexBuffers[kind];\n\n    if (!vb) {\n      return false;\n    }\n\n    return vb.isUpdatable();\n  };\n  /**\n   * Gets a specific vertex buffer\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns a VertexBuffer\n   */\n\n\n  Geometry.prototype.getVertexBuffer = function (kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers[kind];\n  };\n  /**\n   * Returns all vertex buffers\n   * @return an object holding all vertex buffers indexed by kind\n   */\n\n\n  Geometry.prototype.getVertexBuffers = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers;\n  };\n  /**\n   * Gets a boolean indicating if specific vertex buffer is present\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if data is present\n   */\n\n\n  Geometry.prototype.isVerticesDataPresent = function (kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n\n      return false;\n    }\n\n    return this._vertexBuffers[kind] !== undefined;\n  };\n  /**\n   * Gets a list of all attached data kinds (Position, normal, etc...)\n   * @returns a list of string containing all kinds\n   */\n\n\n  Geometry.prototype.getVerticesDataKinds = function () {\n    var result = [];\n    var kind;\n\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Update index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   */\n\n\n  Geometry.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    if (!this._indexBuffer) {\n      return;\n    }\n\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      var needToUpdateSubMeshes = indices.length !== this._indices.length;\n\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n\n      if (needToUpdateSubMeshes) {\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n          var mesh = _a[_i];\n\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  };\n  /**\n   * Creates a new index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param totalVertices defines the total number of vertices (could be null)\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\n   */\n\n\n  Geometry.prototype.setIndices = function (indices, totalVertices, updatable) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n    }\n\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._createGlobalSubMesh(true);\n\n      mesh.synchronizeInstances();\n    }\n\n    this._notifyUpdate();\n  };\n  /**\n   * Return the total number of indices\n   * @returns the total number of indices\n   */\n\n\n  Geometry.prototype.getTotalIndices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._indices.length;\n  };\n  /**\n   * Gets the index buffer array\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the index buffer array\n   */\n\n\n  Geometry.prototype.getIndices = function (copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    var orig = this._indices;\n\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      return Tools.Slice(orig);\n    }\n  };\n  /**\n   * Gets the index buffer\n   * @return the index buffer\n   */\n\n\n  Geometry.prototype.getIndexBuffer = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._indexBuffer;\n  };\n  /**\n   * @param effect\n   * @hidden\n   */\n\n\n  Geometry.prototype._releaseVertexArrayObject = function (effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n\n      delete this._vertexArrayObjects[effect.key];\n    }\n  };\n  /**\n   * Release the associated resources for a specific mesh\n   * @param mesh defines the source mesh\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\n   */\n\n\n  Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\n    var meshes = this._meshes;\n    var index = meshes.indexOf(mesh);\n\n    if (index === -1) {\n      return;\n    }\n\n    meshes.splice(index, 1);\n\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n\n    mesh._geometry = null;\n\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  };\n  /**\n   * Apply current geometry to a given mesh\n   * @param mesh defines the mesh to apply geometry to\n   */\n\n\n  Geometry.prototype.applyToMesh = function (mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n\n    var previousGeometry = mesh._geometry;\n\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n\n    var meshes = this._meshes; // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n\n    mesh._geometry = this;\n    mesh._internalAbstractMeshDataInfo._positions = null;\n\n    this._scene.pushGeometry(this);\n\n    meshes.push(mesh);\n\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else if (this._boundingInfo) {\n      mesh.setBoundingInfo(this._boundingInfo);\n    }\n  };\n\n  Geometry.prototype._updateExtend = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind); // This can happen if the buffer comes from a Hardware Buffer where\n        // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\n\n        if (!data) {\n          return;\n        }\n      }\n\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  };\n\n  Geometry.prototype._applyToMesh = function (mesh) {\n    var numOfMeshes = this._meshes.length; // vertexBuffers\n\n    for (var kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false); //bounding info was just created again, world matrix should be applied again.\n\n\n        mesh._updateBoundingInfo();\n      }\n    } // indexBuffer\n\n\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    } // morphTargets\n\n\n    mesh._syncGeometryWithMorphTargetManager(); // instances\n\n\n    mesh.synchronizeInstances();\n  };\n\n  Geometry.prototype._notifyUpdate = function (kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  };\n  /**\n   * Load the geometry if it was flagged as delay loaded\n   * @param scene defines the hosting scene\n   * @param onLoaded defines a callback called when the geometry is loaded\n   */\n\n\n  Geometry.prototype.load = function (scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n\n      return;\n    }\n\n    this.delayLoadState = 2;\n\n    this._queueLoad(scene, onLoaded);\n  };\n\n  Geometry.prototype._queueLoad = function (scene, onLoaded) {\n    var _this = this;\n\n    if (!this.delayLoadingFile) {\n      return;\n    }\n\n    scene._addPendingData(this);\n\n    scene._loadFile(this.delayLoadingFile, function (data) {\n      if (!_this._delayLoadingFunction) {\n        return;\n      }\n\n      _this._delayLoadingFunction(JSON.parse(data), _this);\n\n      _this.delayLoadState = 1;\n      _this._delayInfo = [];\n\n      scene._removePendingData(_this);\n\n      var meshes = _this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        _this._applyToMesh(meshes[index]);\n      }\n\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  };\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   */\n\n\n  Geometry.prototype.toLeftHanded = function () {\n    // Flip faces\n    var tIndices = this.getIndices(false);\n\n    if (tIndices != null && tIndices.length > 0) {\n      for (var i = 0; i < tIndices.length; i += 3) {\n        var tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n\n      this.setIndices(tIndices);\n    } // Negate position.z\n\n\n    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n\n    if (tPositions != null && tPositions.length > 0) {\n      for (var i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    } // Negate normal.z\n\n\n    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n\n    if (tNormals != null && tNormals.length > 0) {\n      for (var i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }; // Cache\n\n  /** @hidden */\n\n\n  Geometry.prototype._resetPointsArrayCache = function () {\n    this._positions = null;\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._generatePointsArray = function () {\n    if (this._positions) {\n      return true;\n    }\n\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!data || data.length === 0) {\n      return false;\n    }\n\n    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n\n    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    } // just in case the number of positions was reduced, splice the array\n\n\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  };\n  /**\n   * Gets a value indicating if the geometry is disposed\n   * @returns true if the geometry was disposed\n   */\n\n\n  Geometry.prototype.isDisposed = function () {\n    return this._isDisposed;\n  };\n\n  Geometry.prototype._disposeVertexArrayObjects = function () {\n    if (this._vertexArrayObjects) {\n      for (var kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n\n      var meshes = this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        meshes[index]._invalidateInstanceVertexArrayObject();\n      }\n    }\n  };\n  /**\n   * Free all associated resources\n   */\n\n\n  Geometry.prototype.dispose = function () {\n    var meshes = this._meshes;\n    var numOfMeshes = meshes.length;\n    var index;\n\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n\n    this._meshes = [];\n\n    this._disposeVertexArrayObjects();\n\n    for (var kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n\n    this._scene.removeGeometry(this);\n\n    if (this._parentContainer) {\n      var index_1 = this._parentContainer.geometries.indexOf(this);\n\n      if (index_1 > -1) {\n        this._parentContainer.geometries.splice(index_1, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    this._isDisposed = true;\n  };\n  /**\n   * Clone the current geometry into a new geometry\n   * @param id defines the unique ID of the new geometry\n   * @returns a new geometry object\n   */\n\n\n  Geometry.prototype.copy = function (id) {\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    var indices = this.getIndices();\n\n    if (indices) {\n      for (var index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n\n    var updatable = false;\n    var stopChecking = false;\n    var kind;\n\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      var data = this.getVerticesData(kind);\n\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n\n        if (!stopChecking) {\n          var vb = this.getVertexBuffer(kind);\n\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n\n    var geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n\n      geometry._delayInfo.push(kind);\n    } // Bounding info\n\n\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  };\n  /**\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\n   * @return a JSON representation of the current geometry data (without the vertices data)\n   */\n\n\n  Geometry.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.updatable = this._updatable;\n\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    return serializationObject;\n  };\n\n  Geometry.prototype._toNumberArray = function (origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  };\n  /**\n   * Release any memory retained by the cached data on the Geometry.\n   *\n   * Call this function to reduce memory footprint of the mesh.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n\n\n  Geometry.prototype.clearCachedData = function () {\n    this._indices = [];\n\n    this._resetPointsArrayCache();\n\n    for (var vbName in this._vertexBuffers) {\n      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\n        continue;\n      }\n\n      this._vertexBuffers[vbName]._buffer._data = null;\n    }\n  };\n  /**\n   * Serialize all vertices data into a JSON object\n   * @returns a JSON representation of the current geometry data\n   */\n\n\n  Geometry.prototype.serializeVerticeData = function () {\n    var serializationObject = this.serialize();\n\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangents._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uv2s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uv3s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uv4s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uv5s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uv6s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n\n    serializationObject.indices = this._toNumberArray(this.getIndices());\n    return serializationObject;\n  }; // Statics\n\n  /**\n   * Extracts a clone of a mesh geometry\n   * @param mesh defines the source mesh\n   * @param id defines the unique ID of the new geometry object\n   * @returns the new geometry object\n   */\n\n\n  Geometry.ExtractFromMesh = function (mesh, id) {\n    var geometry = mesh._geometry;\n\n    if (!geometry) {\n      return null;\n    }\n\n    return geometry.copy(id);\n  };\n  /**\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n   * Be aware Math.random() could cause collisions, but:\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n   * @returns a string containing a new GUID\n   */\n\n\n  Geometry.RandomId = function () {\n    return Tools.RandomId();\n  };\n\n  Geometry._GetGeometryByLoadedUniqueId = function (uniqueId, scene) {\n    for (var index = 0; index < scene.geometries.length; index++) {\n      if (scene.geometries[index]._loadedUniqueId === uniqueId) {\n        return scene.geometries[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @param parsedGeometry\n   * @param mesh\n   * @hidden\n   */\n\n\n  Geometry._ImportGeometry = function (parsedGeometry, mesh) {\n    var scene = mesh.getScene(); // Geometry\n\n    var geometryUniqueId = parsedGeometry.geometryUniqueId;\n    var geometryId = parsedGeometry.geometryId;\n\n    if (geometryUniqueId || geometryId) {\n      var geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\n\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      var binaryInfo = mesh._binaryInfo;\n\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvsData.length; index += 2) {\n            uvsData[index] = 1 - uvsData[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvs2Data.length; index += 2) {\n            uvs2Data[index] = 1 - uvs2Data[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvs3Data.length; index += 2) {\n            uvs3Data[index] = 1 - uvs3Data[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvs4Data.length; index += 2) {\n            uvs4Data[index] = 1 - uvs4Data[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvs5Data.length; index += 2) {\n            uvs5Data[index] = 1 - uvs5Data[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (var index = 1; index < uvs6Data.length; index += 2) {\n            uvs6Data[index] = 1 - uvs6Data[index];\n          }\n        }\n\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n\n        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          var materialIndex = subMeshesData[i * 5 + 0];\n          var verticesStart = subMeshesData[i * 5 + 1];\n          var verticesCount = subMeshesData[i * 5 + 2];\n          var indexStart = subMeshesData[i * 5 + 3];\n          var indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n\n      mesh.setIndices(parsedGeometry.indices, null);\n    } // SubMeshes\n\n\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n\n      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    } // Flat shading\n\n\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    } // Update\n\n\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  };\n\n  Geometry._CleanMatricesWeights = function (parsedGeometry, mesh) {\n    var epsilon = 1e-3;\n\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n\n    var noInfluenceBoneIndex = 0.0;\n\n    if (parsedGeometry.skeletonId > -1) {\n      var skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\n\n      if (!skeleton) {\n        return;\n      }\n\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n\n    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    var matricesWeights = parsedGeometry.matricesWeights;\n    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    var influencers = parsedGeometry.numBoneInfluencer;\n    var size = matricesWeights.length;\n\n    for (var i = 0; i < size; i += 4) {\n      var weight = 0.0;\n      var firstZeroWeight = -1;\n\n      for (var j = 0; j < 4; j++) {\n        var w = matricesWeights[i + j];\n        weight += w;\n\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n\n      if (matricesWeightsExtra) {\n        for (var j = 0; j < 4; j++) {\n          var w = matricesWeightsExtra[i + j];\n          weight += w;\n\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n\n      if (weight > epsilon) {\n        var mweight = 1.0 / weight;\n\n        for (var j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n\n        if (matricesWeightsExtra) {\n          for (var j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  };\n  /**\n   * Create a new geometry from persisted data (Using .babylon file format)\n   * @param parsedVertexData defines the persisted data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\n   * @returns the new geometry object\n   */\n\n\n  Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\n    var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n    geometry._loadedUniqueId = parsedVertexData.uniqueId;\n\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  };\n\n  return Geometry;\n}();\n\nexport { Geometry };","map":{"version":3,"mappings":"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","names":["Vector3","Color4","VertexData","VertexBuffer","SubMesh","SceneLoaderFlags","BoundingInfo","Tools","Tags","extractMinAndMax","EngineStore","CompatibilityOptions","id","scene","vertexData","updatable","mesh","_scene","LastCreatedScene","uniqueId","getUniqueId","_engine","getEngine","_meshes","_vertexBuffers","_indices","_updatable","setAllVerticesData","_totalVertices","getCaps","vertexArrayObject","_vertexArrayObjects","applyToMesh","computeWorldMatrix","Object","Geometry","_boundingBias","value","copyFrom","clone","_updateBoundingInfo","geometry","RandomId","getScene","_extend","delayLoadState","index","length","doNotSerialize","_indexBuffer","createIndexBuffer","key","vertexBuffer","_rebuild","applyToGeometry","_notifyUpdate","kind","data","stride","Array","isArray","Float32Array","buffer","setVerticesBuffer","dispose","_disposeVertexArrayObjects","totalVertices","disposeExistingBuffer","getKind","_buffer","_increaseReferences","meshes","numOfMeshes","PositionKind","getData","type","BYTE","byteStride","_updateExtend","_resetPointsArrayCache","buildBoundingInfo","minimum","maximum","_createGlobalSubMesh","synchronizeInstances","offset","useBytes","getVertexBuffer","updateDirectly","updateExtends","update","_i","hasBoundingInfo","getBoundingInfo","reConstruct","subMeshes","_a","subMesh","refreshBoundingInfo","effect","indexToBind","overrideVertexBuffers","overrideVertexArrayObjects","undefined","vbs","getVertexBuffers","bindBuffers","vaos","recordVertexArrayObject","bindVertexArrayObject","isReady","copyWhenShared","forceCopy","getFloatData","vb","isUpdatable","_delayInfo","indexOf","result","push","indices","gpuMemoryOnly","_indexBufferIsUpdatable","setIndices","needToUpdateSubMeshes","slice","updateDynamicIndexBuffer","_releaseBuffer","orig","Slice","releaseVertexArrayObject","shouldDispose","splice","_invalidateInstanceVertexArrayObject","_geometry","previousGeometry","releaseForMesh","_internalAbstractMeshDataInfo","_positions","pushGeometry","_applyToMesh","_boundingInfo","setBoundingInfo","useBoundingInfoFromGeometry","getVerticesData","boundingBias","create","_syncGeometryWithMorphTargetManager","onGeometryUpdated","_markSubMeshesAsAttributesDirty","onLoaded","_queueLoad","delayLoadingFile","_addPendingData","_loadFile","_this","_delayLoadingFunction","JSON","parse","_removePendingData","tIndices","getIndices","i","tTemp","tPositions","setVerticesData","tNormals","NormalKind","_positionsCache","arrayIdx","FromArray","set","_isDisposed","removeGeometry","_parentContainer","index_1","geometries","stopChecking","serializationObject","HasTags","tags","GetTags","origin","prototype","call","vbName","hasOwnProperty","_data","serialize","isVerticesDataPresent","positions","_toNumberArray","isVertexBufferUpdatable","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uv2s","UV3Kind","uv3s","UV4Kind","uv4s","UV5Kind","uv5s","UV6Kind","uv6s","ColorKind","colors","MatricesIndicesKind","matricesIndices","_isExpanded","MatricesWeightsKind","matricesWeights","copy","_loadedUniqueId","parsedGeometry","geometryUniqueId","geometryId","_GetGeometryByLoadedUniqueId","getGeometryById","ArrayBuffer","binaryInfo","_binaryInfo","positionsAttrDesc","count","positionsData","normalsAttrDesc","normalsData","tangetsAttrDesc","tangentsData","uvsAttrDesc","uvsData","UseOpenGLOrientationForUV","uvs2AttrDesc","uvs2Data","uvs3AttrDesc","uvs3Data","uvs4AttrDesc","uvs4Data","uvs5AttrDesc","uvs5Data","uvs6AttrDesc","uvs6Data","colorsAttrDesc","colorsData","matricesIndicesAttrDesc","matricesIndicesData","Int32Array","floatIndices","matricesIndicesExtraAttrDesc","MatricesIndicesExtraKind","matricesWeightsAttrDesc","matricesWeightsData","indicesAttrDesc","indicesData","subMeshesAttrDesc","subMeshesData","materialIndex","verticesStart","verticesCount","indexStart","indexCount","AddToMesh","uvs2","uvs3","uvs4","uvs5","uvs6","CheckColors4","matricesIndex","matricesIndicesExtra","_CleanMatricesWeights","matricesWeightsExtra","MatricesWeightsExtraKind","subIndex","parsedSubMesh","_shouldGenerateFlatShading","convertToFlatShadedMesh","onMeshImportedObservable","notifyObservers","epsilon","CleanBoneMatrixWeights","noInfluenceBoneIndex","skeletonId","skeleton","getLastSkeletonById","bones","influencers","numBoneInfluencer","size","weight","firstZeroWeight","j","w","mweight","parsedVertexData","rootUrl","AddTagsTo","boundingBoxMinimum","boundingBoxMaximum","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","ImportVertexData"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/geometry.ts"],"sourcesContent":["import type { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    /** @hidden */\r\n    public _loadedUniqueId: string;\r\n    /** @hidden */\r\n    public _indices: IndicesArray;\r\n    /** @hidden */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @hidden */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @hidden */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @hidden */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @hidden */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene?: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        this.id = id;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._engine = this._scene.getEngine();\r\n        this._meshes = [];\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n            this._indices = [];\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === Constants.DELAYLOADSTATE_LOADED || this.delayLoadState === Constants.DELAYLOADSTATE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // Vertex buffers\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null, disposeExistingBuffer = true): void {\r\n        const kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        if (buffer._buffer) {\r\n            buffer._buffer._increaseReferences();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            const data = <FloatArray>buffer.getData();\r\n            if (totalVertices != null) {\r\n                this._totalVertices = totalVertices;\r\n            } else {\r\n                if (data != null) {\r\n                    this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\r\n                }\r\n            }\r\n\r\n            this._updateExtend(data);\r\n            this._resetPointsArrayCache();\r\n\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                const mesh = meshes[index];\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(false);\r\n                mesh.computeWorldMatrix(true);\r\n                mesh.synchronizeInstances();\r\n            }\r\n        }\r\n\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            const meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @param indexToBind\r\n     * @hidden\r\n     */\r\n    public _bind(\r\n        effect: Nullable<Effect>,\r\n        indexToBind?: Nullable<DataBuffer>,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> },\r\n        overrideVertexArrayObjects?: { [key: string]: WebGLVertexArrayObject }\r\n    ): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        const vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\r\n            return;\r\n        }\r\n\r\n        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\r\n\r\n        // Using VAO\r\n        if (!vaos[effect.key]) {\r\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        const vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @return an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        const result = [];\r\n        let kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        const orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            return Tools.Slice(orig);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @return the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @hidden\r\n     */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        const meshes = this._meshes;\r\n        const index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        const previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        const meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        mesh._internalAbstractMeshDataInfo._positions = null;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else if (this._boundingInfo) {\r\n            mesh.setBoundingInfo(this._boundingInfo);\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n                // This can happen if the buffer comes from a Hardware Buffer where\r\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\r\n                if (!data) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        const numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (const kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(false);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private _notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene._addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                this._delayInfo = [];\r\n\r\n                scene._removePendingData(this);\r\n\r\n                const meshes = this._meshes;\r\n                const numOfMeshes = meshes.length;\r\n                for (let index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        const tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                const tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        const data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (const kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n\r\n            const meshes = this._meshes;\r\n            const numOfMeshes = meshes.length;\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                meshes[index]._invalidateInstanceVertexArrayObject();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n        let index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes = [];\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (const kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.geometries.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.geometries.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        const indices = this.getIndices();\r\n        if (indices) {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        let updatable = false;\r\n        let stopChecking = false;\r\n        let kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            const data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    const vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @return a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release any memory retained by the cached data on the Geometry.\r\n     *\r\n     * Call this function to reduce memory footprint of the mesh.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedData(): void {\r\n        this._indices = [];\r\n        this._resetPointsArrayCache();\r\n\r\n        for (const vbName in this._vertexBuffers) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\r\n                continue;\r\n            }\r\n            this._vertexBuffers[vbName]._buffer._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON object\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        const serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangents._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uv2s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uv3s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uv4s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uv5s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uv6s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this._toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        const geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    private static _GetGeometryByLoadedUniqueId(uniqueId: string, scene: Scene) {\r\n        for (let index = 0; index < scene.geometries.length; index++) {\r\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\r\n                return scene.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param parsedGeometry\r\n     * @param mesh\r\n     * @hidden\r\n     */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        const geometryUniqueId = parsedGeometry.geometryUniqueId;\r\n        const geometryId = parsedGeometry.geometryId;\r\n        if (geometryUniqueId || geometryId) {\r\n            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            const binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvsData.length; index += 2) {\r\n                        uvsData[index] = 1 - uvsData[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs2Data.length; index += 2) {\r\n                        uvs2Data[index] = 1 - uvs2Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs3Data.length; index += 2) {\r\n                        uvs3Data[index] = 1 - uvs3Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs4Data.length; index += 2) {\r\n                        uvs4Data[index] = 1 - uvs4Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs5Data.length; index += 2) {\r\n                        uvs5Data[index] = 1 - uvs5Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs6Data.length; index += 2) {\r\n                        uvs6Data[index] = 1 - uvs6Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    const materialIndex = subMeshesData[i * 5 + 0];\r\n                    const verticesStart = subMeshesData[i * 5 + 1];\r\n                    const verticesCount = subMeshesData[i * 5 + 2];\r\n                    const indexStart = subMeshesData[i * 5 + 3];\r\n                    const indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(\r\n                    parsedSubMesh.materialIndex,\r\n                    parsedSubMesh.verticesStart,\r\n                    parsedSubMesh.verticesCount,\r\n                    parsedSubMesh.indexStart,\r\n                    parsedSubMesh.indexCount,\r\n                    <AbstractMesh>mesh\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        const matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        const matricesWeights = parsedGeometry.matricesWeights;\r\n        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        const influencers = parsedGeometry.numBoneInfluencer;\r\n        const size = matricesWeights.length;\r\n\r\n        for (let i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (let j = 0; j < 4; j++) {\r\n                const w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    const w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                const mweight = 1.0 / weight;\r\n                for (let j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}