{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\n\nvar SpriteMap =\n/** @class */\nfunction () {\n  /**\n   * Creates a new SpriteMap\n   * @param name defines the SpriteMaps Name\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n   * @param spriteSheet is the Texture that the Sprites are on.\n   * @param options a basic deployment configuration\n   * @param scene The Scene that the map is deployed on\n   */\n  function SpriteMap(name, atlasJSON, spriteSheet, options, scene) {\n    var _this = this;\n\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n\n    for (var i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n\n    this._animationMap = this._createTileAnimationBuffer(null);\n    var defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n\n    defines.push(\"#define MAX_ANIMATION_FRAMES \".concat(options.maxAnimationFrames, \".0\"));\n    var shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    var layerSampleString;\n\n    if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n      layerSampleString = \"\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"if (\".concat(i, \" == i) { frameID = texture2D(tileMaps[\").concat(i, \"], (tileID + 0.5) / stageSize, 0.).x; }\");\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n\n      layerSampleString += \"}\";\n    }\n\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines: defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n\n    this._material.setVector2(\"stageSize\", options.stageSize);\n\n    this._material.setVector2(\"outputSize\", options.outputSize);\n\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    var tickSave = 0;\n\n    var bindSpriteTexture = function bindSpriteTexture() {\n      if (_this.spriteSheet && _this.spriteSheet.isReady()) {\n        if (_this.spriteSheet._texture) {\n          _this._material.setVector2(\"spriteMapSize\", new Vector2(_this.spriteSheet._texture.baseWidth || 1, _this.spriteSheet._texture.baseHeight || 1));\n\n          return;\n        }\n      }\n\n      if (tickSave < 100) {\n        setTimeout(function () {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n\n    bindSpriteTexture();\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    this._material.setTexture(\"frameMap\", this._frameMap);\n\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n\n    this._material.setFloat(\"time\", this._time);\n\n    this._output = CreatePlane(name + \":output\", {\n      size: 1,\n      updatable: true\n    }, scene);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n\n    var obfunction = function obfunction() {\n      _this._time += _this._scene.getEngine().getDeltaTime();\n\n      _this._material.setFloat(\"time\", _this._time);\n    };\n\n    this._scene.onBeforeRenderObservable.add(obfunction);\n\n    this._output.material = this._material;\n  }\n\n  Object.defineProperty(SpriteMap.prototype, \"spriteCount\", {\n    /** Returns the Number of Sprites in the System */\n    get: function get() {\n      return this.sprites.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"position\", {\n    /** Returns the Position of Output Plane*/\n    get: function get() {\n      return this._output.position;\n    },\n\n    /** Returns the Position of Output Plane*/\n    set: function set(v) {\n      this._output.position = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"rotation\", {\n    /** Returns the Rotation of Output Plane*/\n    get: function get() {\n      return this._output.rotation;\n    },\n\n    /** Returns the Rotation of Output Plane*/\n    set: function set(v) {\n      this._output.rotation = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"animationMap\", {\n    /** Sets the AnimationMap*/\n    get: function get() {\n      return this._animationMap;\n    },\n\n    /** Sets the AnimationMap*/\n    set: function set(v) {\n      var buffer = v._texture._bufferView;\n\n      var am = this._createTileAnimationBuffer(buffer);\n\n      this._animationMap.dispose();\n\n      this._animationMap = am;\n\n      this._material.setTexture(\"animationMap\", this._animationMap);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns tileID location\n   * @returns Vector2 the cell position ID\n   */\n\n  SpriteMap.prototype.getTileID = function () {\n    var p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  };\n  /**\n   * Gets the UV location of the mouse over the SpriteMap.\n   * @returns Vector2 the UV position of the mouse interaction\n   */\n\n\n  SpriteMap.prototype.getMousePosition = function () {\n    var out = this._output;\n\n    var pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, function (mesh) {\n      if (mesh !== out) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n\n    var coords = pickinfo.getTextureCoordinates();\n\n    if (coords) {\n      return coords;\n    }\n\n    return new Vector2(-1, -1);\n  };\n  /**\n   * Creates the \"frame\" texture Buffer\n   * -------------------------------------\n   * Structure of frames\n   *  \"filename\": \"Falling-Water-2.png\",\n   * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n   * \"rotated\": true,\n   * \"trimmed\": true,\n   * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n   * \"sourceSize\": {\"w\":32,\"h\":32}\n   * @returns RawTexture of the frameMap\n   */\n\n\n  SpriteMap.prototype._createFrameBuffer = function () {\n    var data = new Array(); //Do two Passes\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n\n      data.push(0, 0, 0, 0); //spriteSourceSize\n\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    } //Second Pass\n\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      var f = this.sprites[i][\"frame\"];\n      var sss = this.sprites[i][\"spriteSourceSize\"];\n      var ss = this.sprites[i][\"sourceSize\"];\n      var r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      var t_1 = this.sprites[i][\"trimmed\"] ? 1 : 0; //frame\n\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h; //spriteSourceSize\n\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h; //sourceSize, rotated, trimmed\n\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t_1;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\n   * Creates the tileMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n   * @returns RawTexture of the tileMap\n   */\n\n\n  SpriteMap.prototype._createTileBuffer = function (buffer, _layer) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    var data = new Array();\n\n    var _ty = this.options.stageSize.y || 0;\n\n    var _tx = this.options.stageSize.x || 0;\n\n    if (!buffer) {\n      var bt = this.options.baseTile;\n\n      if (_layer != 0) {\n        bt = 0;\n      }\n\n      for (var y = 0; y < _ty; y++) {\n        for (var x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\n   * Modifies the data of the tileMaps\n   * @param _layer is the ID of the layer you want to edit on the SpriteMap\n   * @param pos is the iVector2 Coordinates of the Tile\n   * @param tile The SpriteIndex of the new Tile\n   */\n\n\n  SpriteMap.prototype.changeTiles = function (_layer, pos, tile) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    if (tile === void 0) {\n      tile = 0;\n    }\n\n    var buffer = this._tileMaps[_layer]._texture._bufferView;\n\n    if (buffer === null) {\n      return;\n    }\n\n    var p = new Array();\n\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n\n    var _tx = this.options.stageSize.x || 0;\n\n    for (var i = 0; i < p.length; i++) {\n      var _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      var id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n\n    var t = this._createTileBuffer(buffer);\n\n    this._tileMaps[_layer].dispose();\n\n    this._tileMaps[_layer] = t;\n\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  };\n  /**\n   * Creates the animationMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @returns RawTexture of the animationMap\n   */\n\n\n  SpriteMap.prototype._createTileAnimationBuffer = function (buffer) {\n    var data = new Array();\n    var floatArray;\n\n    if (!buffer) {\n      for (var i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        var count = 1;\n\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\n   * Modifies the data of the animationMap\n   * @param cellID is the Index of the Sprite\n   * @param _frame is the target Animation frame\n   * @param toCell is the Target Index of the next frame of the animation\n   * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n   * @param speed is a global scalar of the time variable on the map.\n   */\n\n\n  SpriteMap.prototype.addAnimationToTile = function (cellID, _frame, toCell, time, speed) {\n    if (cellID === void 0) {\n      cellID = 0;\n    }\n\n    if (_frame === void 0) {\n      _frame = 0;\n    }\n\n    if (toCell === void 0) {\n      toCell = 0;\n    }\n\n    if (time === void 0) {\n      time = 0;\n    }\n\n    if (speed === void 0) {\n      speed = 1;\n    }\n\n    var buffer = this._animationMap._texture._bufferView;\n    var id = cellID * 4 + this.spriteCount * 4 * _frame;\n\n    if (!buffer) {\n      return;\n    }\n\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n\n    var t = this._createTileAnimationBuffer(buffer);\n\n    this._animationMap.dispose();\n\n    this._animationMap = t;\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  };\n  /**\n   * Exports the .tilemaps file\n   */\n\n\n  SpriteMap.prototype.saveTileMaps = function () {\n    var maps = \"\";\n\n    for (var i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n\n    var hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  };\n  /**\n   * Imports the .tilemaps file\n   * @param url of the .tilemaps file\n   */\n\n\n  SpriteMap.prototype.loadTileMaps = function (url) {\n    var _this = this;\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n\n    var _lc = this.options.layerCount || 0;\n\n    xhr.onload = function () {\n      var data = xhr.response.split(\"\\n\\r\");\n\n      for (var i = 0; i < _lc; i++) {\n        var d = data[i].split(\",\").map(Number);\n\n        var t = _this._createTileBuffer(d);\n\n        _this._tileMaps[i].dispose();\n\n        _this._tileMaps[i] = t;\n      }\n\n      _this._material.setTextureArray(\"tileMap\", _this._tileMaps);\n    };\n\n    xhr.send();\n  };\n  /**\n   * Release associated resources\n   */\n\n\n  SpriteMap.prototype.dispose = function () {\n    this._output.dispose();\n\n    this._material.dispose();\n\n    this._animationMap.dispose();\n\n    this._tileMaps.forEach(function (tm) {\n      tm.dispose();\n    });\n\n    this._frameMap.dispose();\n  };\n\n  return SpriteMap;\n}();\n\nexport { SpriteMap };","map":{"version":3,"mappings":"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","names":["Engine","Vector2","Vector3","Texture","RawTexture","ShaderMaterial","Effect","CreatePlane","name","atlasJSON","spriteSheet","options","scene","sprites","stageSize","outputSize","outputPosition","Zero","outputRotation","layerCount","maxAnimationFrames","baseTile","flipU","colorMultiply","_scene","_frameMap","_createFrameBuffer","_tileMaps","Array","i","push","_createTileBuffer","_animationMap","_createTileAnimationBuffer","defines","shaderString","ShadersStore","layerSampleString","getEngine","_features","supportSwitchCaseInShader","concat","replace","_material","vertex","fragment","attributes","uniforms","samplers","needAlphaBlending","_time","setFloat","spriteCount","setVector2","setTexture","setVector3","tickSave","bindSpriteTexture","_this","isReady","_texture","baseWidth","baseHeight","setTimeout","setTextureArray","_output","size","updatable","scaling","x","y","position","rotation","obfunction","getDeltaTime","onBeforeRenderObservable","add","material","Object","SpriteMap","length","v","buffer","_bufferView","am","dispose","p","getMousePosition","multiplyInPlace","Math","floor","out","pickinfo","pick","pointerX","pointerY","mesh","hit","getTextureCoordinates","coords","data","f","sss","ss","r","t_1","w","h","floatArray","Float32Array","t","CreateRGBATexture","NEAREST_NEAREST","TEXTURETYPE_FLOAT","_layer","_ty","_tx","bt","pos","tile","_p","id","count","cellID","_frame","toCell","time","speed","maps","toString","hiddenElement","document","createElement","href","encodeURI","target","download","click","remove","url","xhr","XMLHttpRequest","open","_lc","onload","response","split","d","map","Number","send","forEach","tm"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Sprites/spriteMap.ts"],"sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISpriteJSONSprite, ISpriteJSONAtlas } from \"./ISprites\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport \"../Shaders/spriteMap.fragment\";\r\nimport \"../Shaders/spriteMap.vertex\";\r\n\r\n/**\r\n * Defines the basic options interface of a SpriteMap\r\n */\r\nexport interface ISpriteMapOptions {\r\n    /**\r\n     * Vector2 of the number of cells in the grid.\r\n     */\r\n    stageSize?: Vector2;\r\n\r\n    /**\r\n     * Vector2 of the size of the output plane in World Units.\r\n     */\r\n    outputSize?: Vector2;\r\n\r\n    /**\r\n     * Vector3 of the position of the output plane in World Units.\r\n     */\r\n    outputPosition?: Vector3;\r\n\r\n    /**\r\n     * Vector3 of the rotation of the output plane.\r\n     */\r\n    outputRotation?: Vector3;\r\n\r\n    /**\r\n     * number of layers that the system will reserve in resources.\r\n     */\r\n    layerCount?: number;\r\n\r\n    /**\r\n     * number of max animation frames a single cell will reserve in resources.\r\n     */\r\n    maxAnimationFrames?: number;\r\n\r\n    /**\r\n     * number cell index of the base tile when the system compiles.\r\n     */\r\n    baseTile?: number;\r\n\r\n    /**\r\n     * boolean flip the sprite after its been repositioned by the framing data.\r\n     */\r\n    flipU?: boolean;\r\n\r\n    /**\r\n     * Vector3 scalar of the global RGB values of the SpriteMap.\r\n     */\r\n    colorMultiply?: Vector3;\r\n}\r\n\r\n/**\r\n * Defines the IDisposable interface in order to be cleanable from resources.\r\n */\r\nexport interface ISpriteMap extends IDisposable {\r\n    /**\r\n     * String name of the SpriteMap.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.\r\n     */\r\n    atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /**\r\n     * Texture of the SpriteMap.\r\n     */\r\n    spriteSheet: Texture;\r\n\r\n    /**\r\n     * The parameters to initialize the SpriteMap with.\r\n     */\r\n    options: ISpriteMapOptions;\r\n}\r\n\r\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\r\nexport class SpriteMap implements ISpriteMap {\r\n    /** The Name of the spriteMap */\r\n    public name: string;\r\n\r\n    /** The JSON file with the frame and meta data */\r\n    public atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /** The systems Sprite Sheet Texture */\r\n    public spriteSheet: Texture;\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ISpriteMapOptions;\r\n\r\n    /** Public Sprite Storage array, parsed from atlasJSON */\r\n    public sprites: Array<ISpriteJSONSprite>;\r\n\r\n    /** Returns the Number of Sprites in the System */\r\n    public get spriteCount(): number {\r\n        return this.sprites.length;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public get position(): Vector3 {\r\n        return this._output.position;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public set position(v: Vector3) {\r\n        this._output.position = v;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public get rotation(): Vector3 {\r\n        return this._output.rotation;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public set rotation(v: Vector3) {\r\n        this._output.rotation = v;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public get animationMap() {\r\n        return this._animationMap;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public set animationMap(v: RawTexture) {\r\n        const buffer = v!._texture!._bufferView;\r\n        const am = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = am;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /** Scene that the SpriteMap was created in */\r\n    private _scene: Scene;\r\n\r\n    /** Texture Buffer of Float32 that holds tile frame data*/\r\n    private _frameMap: RawTexture;\r\n\r\n    /** Texture Buffers of Float32 that holds tileMap data*/\r\n    private _tileMaps: RawTexture[];\r\n\r\n    /** Texture Buffer of Float32 that holds Animation Data*/\r\n    private _animationMap: RawTexture;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _material: ShaderMaterial;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _output: Mesh;\r\n\r\n    /** Systems Time Ticker*/\r\n    private _time: number;\r\n\r\n    /**\r\n     * Creates a new SpriteMap\r\n     * @param name defines the SpriteMaps Name\r\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n     * @param spriteSheet is the Texture that the Sprites are on.\r\n     * @param options a basic deployment configuration\r\n     * @param scene The Scene that the map is deployed on\r\n     */\r\n    constructor(name: string, atlasJSON: ISpriteJSONAtlas, spriteSheet: Texture, options: ISpriteMapOptions, scene: Scene) {\r\n        this.name = name;\r\n        this.sprites = [];\r\n        this.atlasJSON = atlasJSON;\r\n        this.sprites = this.atlasJSON[\"frames\"];\r\n        this.spriteSheet = spriteSheet;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        options.stageSize = options.stageSize || new Vector2(1, 1);\r\n        options.outputSize = options.outputSize || options.stageSize;\r\n        options.outputPosition = options.outputPosition || Vector3.Zero();\r\n        options.outputRotation = options.outputRotation || Vector3.Zero();\r\n        options.layerCount = options.layerCount || 1;\r\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\r\n        options.baseTile = options.baseTile || 0;\r\n        options.flipU = options.flipU || false;\r\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\r\n\r\n        this._scene = scene;\r\n\r\n        this._frameMap = this._createFrameBuffer();\r\n\r\n        this._tileMaps = new Array();\r\n        for (let i = 0; i < options.layerCount; i++) {\r\n            this._tileMaps.push(this._createTileBuffer(null, i));\r\n        }\r\n\r\n        this._animationMap = this._createTileAnimationBuffer(null);\r\n\r\n        const defines = [];\r\n        defines.push(\"#define LAYERS \" + options.layerCount);\r\n\r\n        if (options.flipU) {\r\n            defines.push(\"#define FLIPU\");\r\n        }\r\n\r\n        defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\r\n\r\n        const shaderString: string = Effect.ShadersStore[\"spriteMapPixelShader\"];\r\n\r\n        let layerSampleString: string;\r\n        if (!scene.getEngine()._features.supportSwitchCaseInShader) {\r\n            layerSampleString = \"\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\r\n            }\r\n        } else {\r\n            layerSampleString = \"switch(i) {\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\r\n                layerSampleString += \"break;\";\r\n            }\r\n            layerSampleString += \"}\";\r\n        }\r\n\r\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\r\n\r\n        this._material = new ShaderMaterial(\r\n            \"spriteMap:\" + this.name,\r\n            this._scene,\r\n            {\r\n                vertex: \"spriteMap\",\r\n                fragment: \"spriteMap\" + this.name,\r\n            },\r\n            {\r\n                defines,\r\n                attributes: [\"position\", \"normal\", \"uv\"],\r\n                uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\r\n                samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\r\n                needAlphaBlending: true,\r\n            }\r\n        );\r\n\r\n        this._time = 0;\r\n\r\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\r\n        this._material.setVector2(\"stageSize\", options.stageSize);\r\n        this._material.setVector2(\"outputSize\", options.outputSize);\r\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\r\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n\r\n        let tickSave = 0;\r\n\r\n        const bindSpriteTexture = () => {\r\n            if (this.spriteSheet && this.spriteSheet.isReady()) {\r\n                if (this.spriteSheet._texture) {\r\n                    this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\r\n                    return;\r\n                }\r\n            }\r\n            if (tickSave < 100) {\r\n                setTimeout(() => {\r\n                    tickSave++;\r\n                    bindSpriteTexture();\r\n                }, 100);\r\n            }\r\n        };\r\n\r\n        bindSpriteTexture();\r\n\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n        this._material.setTexture(\"frameMap\", this._frameMap);\r\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n        this._material.setFloat(\"time\", this._time);\r\n\r\n        this._output = CreatePlane(name + \":output\", { size: 1, updatable: true }, scene);\r\n        this._output.scaling.x = options.outputSize.x;\r\n        this._output.scaling.y = options.outputSize.y;\r\n        this.position = options.outputPosition;\r\n        this.rotation = options.outputRotation;\r\n\r\n        const obfunction = () => {\r\n            this._time += this._scene.getEngine().getDeltaTime();\r\n            this._material.setFloat(\"time\", this._time);\r\n        };\r\n\r\n        this._scene.onBeforeRenderObservable.add(obfunction);\r\n        this._output.material = this._material;\r\n    }\r\n\r\n    /**\r\n     * Returns tileID location\r\n     * @returns Vector2 the cell position ID\r\n     */\r\n    public getTileID(): Vector2 {\r\n        const p = this.getMousePosition();\r\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\r\n        p.x = Math.floor(p.x);\r\n        p.y = Math.floor(p.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Gets the UV location of the mouse over the SpriteMap.\r\n     * @returns Vector2 the UV position of the mouse interaction\r\n     */\r\n    public getMousePosition(): Vector2 {\r\n        const out = this._output;\r\n        const pickinfo: Nullable<PickingInfo> = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {\r\n            if (mesh !== out) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n\r\n        if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\r\n            return new Vector2(-1, -1);\r\n        }\r\n\r\n        const coords = pickinfo.getTextureCoordinates();\r\n        if (coords) {\r\n            return coords;\r\n        }\r\n\r\n        return new Vector2(-1, -1);\r\n    }\r\n\r\n    /**\r\n     * Creates the \"frame\" texture Buffer\r\n     * -------------------------------------\r\n     * Structure of frames\r\n     *  \"filename\": \"Falling-Water-2.png\",\r\n     * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n     * \"rotated\": true,\r\n     * \"trimmed\": true,\r\n     * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n     * \"sourceSize\": {\"w\":32,\"h\":32}\r\n     * @returns RawTexture of the frameMap\r\n     */\r\n    private _createFrameBuffer(): RawTexture {\r\n        const data = new Array();\r\n        //Do two Passes\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            data.push(0, 0, 0, 0); //frame\r\n            data.push(0, 0, 0, 0); //spriteSourceSize\r\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\r\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\r\n        }\r\n        //Second Pass\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            const f = this.sprites[i][\"frame\"];\r\n            const sss = this.sprites[i][\"spriteSourceSize\"];\r\n            const ss = this.sprites[i][\"sourceSize\"];\r\n            const r = this.sprites[i][\"rotated\"] ? 1 : 0;\r\n            const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\r\n\r\n            //frame\r\n            data[i * 4] = f.x;\r\n            data[i * 4 + 1] = f.y;\r\n            data[i * 4 + 2] = f.w;\r\n            data[i * 4 + 3] = f.h;\r\n            //spriteSourceSize\r\n            data[i * 4 + this.spriteCount * 4] = sss.x;\r\n            data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\r\n            data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\r\n            //sourceSize, rotated, trimmed\r\n            data[i * 4 + this.spriteCount * 8] = ss.w;\r\n            data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\r\n            data[i * 4 + 2 + this.spriteCount * 8] = r;\r\n            data[i * 4 + 3 + this.spriteCount * 8] = t;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n\r\n        const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Creates the tileMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n     * @returns RawTexture of the tileMap\r\n     */\r\n    private _createTileBuffer(buffer: any, _layer: number = 0): RawTexture {\r\n        let data = new Array();\r\n        const _ty = this.options.stageSize!.y || 0;\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        if (!buffer) {\r\n            let bt = this.options.baseTile;\r\n            if (_layer != 0) {\r\n                bt = 0;\r\n            }\r\n\r\n            for (let y = 0; y < _ty; y++) {\r\n                for (let x = 0; x < _tx * 4; x += 4) {\r\n                    data.push(bt, 0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            data = buffer;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n        const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the tileMaps\r\n     * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n     * @param pos is the iVector2 Coordinates of the Tile\r\n     * @param tile The SpriteIndex of the new Tile\r\n     */\r\n    public changeTiles(_layer: number = 0, pos: Vector2 | Vector2[], tile: number = 0): void {\r\n        const buffer = this._tileMaps[_layer]!._texture!._bufferView;\r\n        if (buffer === null) {\r\n            return;\r\n        }\r\n\r\n        let p = new Array();\r\n        if (pos instanceof Vector2) {\r\n            p.push(pos);\r\n        } else {\r\n            p = pos;\r\n        }\r\n\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        for (let i = 0; i < p.length; i++) {\r\n            const _p = p[i];\r\n            _p.x = Math.floor(_p.x);\r\n            _p.y = Math.floor(_p.y);\r\n            const id: number = _p.x * 4 + _p.y * (_tx * 4);\r\n            (buffer as any)[id] = tile;\r\n        }\r\n\r\n        const t = this._createTileBuffer(buffer);\r\n        this._tileMaps[_layer].dispose();\r\n        this._tileMaps[_layer] = t;\r\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n    }\r\n\r\n    /**\r\n     * Creates the animationMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @returns RawTexture of the animationMap\r\n     */\r\n    private _createTileAnimationBuffer(buffer: Nullable<ArrayBufferView>): RawTexture {\r\n        const data = new Array();\r\n        let floatArray;\r\n        if (!buffer) {\r\n            for (let i = 0; i < this.spriteCount; i++) {\r\n                data.push(0, 0, 0, 0);\r\n                let count = 1;\r\n                while (count < (this.options.maxAnimationFrames || 4)) {\r\n                    data.push(0, 0, 0, 0);\r\n                    count++;\r\n                }\r\n            }\r\n            floatArray = new Float32Array(data);\r\n        } else {\r\n            floatArray = buffer;\r\n        }\r\n\r\n        const t = RawTexture.CreateRGBATexture(\r\n            floatArray,\r\n            this.spriteCount,\r\n            this.options.maxAnimationFrames || 4,\r\n            this._scene,\r\n            false,\r\n            false,\r\n            Texture.NEAREST_NEAREST,\r\n            Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the animationMap\r\n     * @param cellID is the Index of the Sprite\r\n     * @param _frame is the target Animation frame\r\n     * @param toCell is the Target Index of the next frame of the animation\r\n     * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n     * @param speed is a global scalar of the time variable on the map.\r\n     */\r\n    public addAnimationToTile(cellID: number = 0, _frame: number = 0, toCell: number = 0, time: number = 0, speed: number = 1): void {\r\n        const buffer: any = this._animationMap!._texture!._bufferView;\r\n        const id: number = cellID * 4 + this.spriteCount * 4 * _frame;\r\n        if (!buffer) {\r\n            return;\r\n        }\r\n        buffer[id] = toCell;\r\n        buffer[id + 1] = time;\r\n        buffer[id + 2] = speed;\r\n        const t = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = t;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /**\r\n     * Exports the .tilemaps file\r\n     */\r\n    public saveTileMaps(): void {\r\n        let maps = \"\";\r\n        for (let i = 0; i < this._tileMaps.length; i++) {\r\n            if (i > 0) {\r\n                maps += \"\\n\\r\";\r\n            }\r\n\r\n            maps += this._tileMaps[i]!._texture!._bufferView!.toString();\r\n        }\r\n        const hiddenElement = document.createElement(\"a\");\r\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\r\n        hiddenElement.target = \"_blank\";\r\n        hiddenElement.download = this.name + \".tilemaps\";\r\n        hiddenElement.click();\r\n        hiddenElement.remove();\r\n    }\r\n\r\n    /**\r\n     * Imports the .tilemaps file\r\n     * @param url of the .tilemaps file\r\n     */\r\n    public loadTileMaps(url: string): void {\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", url);\r\n\r\n        const _lc = this.options!.layerCount || 0;\r\n\r\n        xhr.onload = () => {\r\n            const data = xhr.response.split(\"\\n\\r\");\r\n            for (let i = 0; i < _lc; i++) {\r\n                const d = data[i].split(\",\").map(Number);\r\n                const t = this._createTileBuffer(d);\r\n                this._tileMaps[i].dispose();\r\n                this._tileMaps[i] = t;\r\n            }\r\n            this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._output.dispose();\r\n        this._material.dispose();\r\n        this._animationMap.dispose();\r\n        this._tileMaps.forEach((tm) => {\r\n            tm.dispose();\r\n        });\r\n        this._frameMap.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}