{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags.js\";\nimport { IsBase64DataUrl } from \"../Misc/fileTools.js\";\nimport { StartsWith } from \"../Misc/stringTools.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * Mode that determines how to handle old animation groups before loading new ones.\n */\n\nexport var SceneLoaderAnimationGroupLoadingMode;\n\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\n   * Reset all old animations to initial state then dispose them.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\n   * Stop all old animations.\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\n   * Restart old animations from first frame.\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\n   * Old animations remains untouched.\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\n * Class used to load scene from various file formats using registered plugins\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\n */\n\n\nvar SceneLoader =\n/** @class */\nfunction () {\n  function SceneLoader() {}\n\n  Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\n    /**\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n     */\n    get: function get() {\n      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\n    /**\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n     */\n    get: function get() {\n      return SceneLoaderFlags.ShowLoadingScreen;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.ShowLoadingScreen = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"loggingLevel\", {\n    /**\n     * Defines the current logging level (while loading the scene)\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get: function get() {\n      return SceneLoaderFlags.loggingLevel;\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    set: function set(value) {\n      SceneLoaderFlags.loggingLevel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"CleanBoneMatrixWeights\", {\n    /**\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n     */\n    get: function get() {\n      return SceneLoaderFlags.CleanBoneMatrixWeights;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.CleanBoneMatrixWeights = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the default plugin (used to load Babylon files)\n   * @returns the .babylon plugin\n   */\n\n  SceneLoader.GetDefaultPlugin = function () {\n    return SceneLoader._RegisteredPlugins[\".babylon\"];\n  };\n\n  SceneLoader._GetPluginForExtension = function (extension) {\n    var registeredPlugin = SceneLoader._RegisteredPlugins[extension];\n\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForDirectLoad = function (data) {\n    for (var extension in SceneLoader._RegisteredPlugins) {\n      var plugin = SceneLoader._RegisteredPlugins[extension].plugin;\n\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._RegisteredPlugins[extension];\n      }\n    }\n\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForFilename = function (sceneFilename) {\n    var queryStringPosition = sceneFilename.indexOf(\"?\");\n\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n\n    var dotPosition = sceneFilename.lastIndexOf(\".\");\n    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  };\n\n  SceneLoader._GetDirectLoad = function (sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n\n    return null;\n  };\n\n  SceneLoader._FormatErrorMessage = function (fileInfo, message, exception) {\n    var errorMessage = \"Unable to load from \" + fileInfo.url;\n\n    if (message) {\n      errorMessage += \": \".concat(message);\n    } else if (exception) {\n      errorMessage += \": \".concat(exception);\n    }\n\n    return errorMessage;\n  };\n\n  SceneLoader._LoadData = function (fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n    var directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\n\n    var registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);\n    var plugin;\n\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin); // Check if we have a direct load url. If the plugin is registered to handle\n    // it or it's not a base64 data url, then pass it through the direct load path.\n\n    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {\n      if (plugin.directLoad) {\n        var result = plugin.directLoad(scene, directLoad);\n\n        if (result.then) {\n          result.then(function (data) {\n            onSuccess(plugin, data);\n          })[\"catch\"](function (error) {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n\n      return plugin;\n    }\n\n    var useArrayBuffer = registeredPlugin.isBinary;\n\n    var dataCallback = function dataCallback(data, responseURL) {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n\n      onSuccess(plugin, data, responseURL);\n    };\n\n    var request = null;\n    var pluginDisposed = false;\n    var onDisposeObservable = plugin.onDisposeObservable;\n\n    if (onDisposeObservable) {\n      onDisposeObservable.add(function () {\n        pluginDisposed = true;\n\n        if (request) {\n          request.abort();\n          request = null;\n        }\n\n        onDispose();\n      });\n    }\n\n    var manifestChecked = function manifestChecked() {\n      if (pluginDisposed) {\n        return;\n      }\n\n      var errorCallback = function errorCallback(request, exception) {\n        onError(request === null || request === void 0 ? void 0 : request.statusText, exception);\n      };\n\n      var fileOrUrl = fileInfo.file || fileInfo.url;\n      request = plugin.loadFile ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n\n    var engine = scene.getEngine();\n    var canUseOfflineSupport = engine.enableOfflineSupport;\n\n    if (canUseOfflineSupport) {\n      // Also check for exceptions\n      var exceptionFound = false;\n\n      for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {\n        var regex = _a[_i];\n\n        if (regex.test(fileInfo.url)) {\n          exceptionFound = true;\n          break;\n        }\n      }\n\n      canUseOfflineSupport = !exceptionFound;\n    }\n\n    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n      // Checking if a manifest file has been set for this scene and if offline mode has been requested\n      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n    } else {\n      manifestChecked();\n    }\n\n    return plugin;\n  };\n\n  SceneLoader._GetFileInfo = function (rootUrl, sceneFilename) {\n    var url;\n    var name;\n    var file = null;\n\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      var sceneFile = sceneFilename;\n      url = \"file:\".concat(sceneFile.name);\n      name = sceneFile.name;\n      file = sceneFile;\n    } else if (typeof sceneFilename === \"string\" && StartsWith(sceneFilename, \"data:\")) {\n      url = sceneFilename;\n      name = \"\";\n    } else {\n      var filename = sceneFilename;\n\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n\n      url = rootUrl + filename;\n      name = filename;\n    }\n\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file\n    };\n  }; // Public functions\n\n  /**\n   * Gets a plugin that can load the given extension\n   * @param extension defines the extension to load\n   * @returns a plugin or null if none works\n   */\n\n\n  SceneLoader.GetPluginForExtension = function (extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  };\n  /**\n   * Gets a boolean indicating that the given extension can be loaded\n   * @param extension defines the extension to load\n   * @returns true if the extension is supported\n   */\n\n\n  SceneLoader.IsPluginForExtensionAvailable = function (extension) {\n    return !!SceneLoader._RegisteredPlugins[extension];\n  };\n  /**\n   * Adds a new plugin to the list of registered plugins\n   * @param plugin defines the plugin to add\n   */\n\n\n  SceneLoader.RegisterPlugin = function (plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      var extension = plugin.extensions;\n      SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      var extensions_1 = plugin.extensions;\n      Object.keys(extensions_1).forEach(function (extension) {\n        SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions_1[extension].isBinary\n        };\n      });\n    }\n  };\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n\n\n  SceneLoader.ImportMesh = function (meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n      scene.importedMeshesFiles.push(fileInfo.url);\n\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data, responseURL) {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n\n      if (plugin.importMesh) {\n        var syncedPlugin = plugin;\n        var meshes = new Array();\n        var particleSystems = new Array();\n        var skeletons = new Array();\n\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (result) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        })[\"catch\"](function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\n   */\n\n\n  SceneLoader.ImportMeshAsync = function (meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n\n\n  SceneLoader.Load = function (rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n  };\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded scene\n   */\n\n\n  SceneLoader.LoadAsync = function (rootUrl, sceneFilename, engine, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n\n\n  SceneLoader.Append = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    var _this = this;\n\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\n      this._ShowingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(function () {\n        scene.getEngine().hideLoadingUI();\n        _this._ShowingLoadingScreen = false;\n      });\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler() {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.load) {\n        var syncedPlugin = plugin;\n\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function () {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        })[\"catch\"](function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The given scene\n   */\n\n\n  SceneLoader.AppendAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n\n\n  SceneLoader.LoadAssetContainer = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler(assets) {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.loadAssetContainer) {\n        var syncedPlugin = plugin;\n        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n\n        if (!assetContainer) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (assetContainer) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        })[\"catch\"](function (error) {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\n   * @param scene is the instance of Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded asset container\n   */\n\n\n  SceneLoader.LoadAssetContainerAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, function (assetContainer) {\n        resolve(assetContainer);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   */\n\n\n  SceneLoader.ImportAnimations = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {\n        var animatable = _a[_i];\n        animatable.reset();\n      }\n\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(function (animationGroup) {\n        animationGroup.dispose();\n      });\n      var nodes = scene.getNodes();\n      nodes.forEach(function (node) {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(function (animationGroup) {\n            animationGroup.dispose();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.stop();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n\n    var startingIndexForNewAnimatables = scene.animatables.length;\n\n    var onAssetContainerLoaded = function onAssetContainerLoaded(container) {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  };\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns the updated scene with imported animations\n   */\n\n\n  SceneLoader.ImportAnimationsAsync = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onSuccess, onProgress, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function (_scene) {\n        resolve(_scene);\n      }, onProgress, function (_scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\n   * No logging while loading\n   */\n\n\n  SceneLoader.NO_LOGGING = 0;\n  /**\n   * Minimal logging while loading\n   */\n\n  SceneLoader.MINIMAL_LOGGING = 1;\n  /**\n   * Summary logging while loading\n   */\n\n  SceneLoader.SUMMARY_LOGGING = 2;\n  /**\n   * Detailed logging while loading\n   */\n\n  SceneLoader.DETAILED_LOGGING = 3; // Members\n\n  /**\n   * Event raised when a plugin is used to load a scene\n   */\n\n  SceneLoader.OnPluginActivatedObservable = new Observable();\n  SceneLoader._RegisteredPlugins = {};\n  SceneLoader._ShowingLoadingScreen = false;\n  return SceneLoader;\n}();\n\nexport { SceneLoader };","map":{"version":3,"mappings":"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","names":["Tools","Observable","Scene","Engine","EngineStore","Logger","SceneLoaderFlags","IsBase64DataUrl","StartsWith","RuntimeError","ErrorCodes","SceneLoaderAnimationGroupLoadingMode","Object","SceneLoader","ForceFullSceneLoadingForIncremental","value","ShowLoadingScreen","loggingLevel","CleanBoneMatrixWeights","_RegisteredPlugins","extension","registeredPlugin","Warn","GetDefaultPlugin","data","plugin","canDirectLoad","sceneFilename","queryStringPosition","indexOf","substring","dotPosition","lastIndexOf","length","toLowerCase","_GetPluginForExtension","substr","fileInfo","message","exception","errorMessage","url","scene","onSuccess","onProgress","onError","onDispose","pluginExtension","directLoad","_GetDirectLoad","_GetPluginForDirectLoad","_GetPluginForFilename","createPlugin","undefined","OnPluginActivatedObservable","notifyObservers","result","then","error","useArrayBuffer","isBinary","dataCallback","responseURL","isDisposed","request","pluginDisposed","onDisposeObservable","add","abort","manifestChecked","errorCallback","statusText","fileOrUrl","file","loadFile","_loadFile","engine","getEngine","canUseOfflineSupport","enableOfflineSupport","exceptionFound","disableOfflineSupportExceptionRules","_i","regex","test","OfflineProviderFactory","offlineProvider","disableManifestCheck","rootUrl","name","GetFilename","GetFolderPath","sceneFile","filename","Error","extensions","extensions_1","keys","forEach","meshNames","LastCreatedScene","_GetFileInfo","loadingToken","_addPendingData","disposeHandler","_removePendingData","errorHandler","_FormatErrorMessage","SceneLoaderError","progressHandler","event","e","successHandler","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","importedMeshesFiles","push","_LoadData","rewriteRootURL","importMesh","syncedPlugin","Array","loadingPluginName","asyncedPlugin","importMeshAsync","Promise","resolve","reject","ImportMesh","LastCreatedEngine","Append","Load","_ShowingLoadingScreen","displayLoadingUI","executeWhenReady","hideLoadingUI","_this","load","loadAsync","assets","loadAssetContainer","assetContainer","loadAssetContainerAsync","LoadAssetContainer","overwriteAnimations","animationGroupLoadingMode","targetConverter","Clean","animatables","animatable","reset","stopAllAnimations","slice","animationGroup","dispose","nodes","getNodes","node","animations","Stop","stop","Sync","restart","NoSync","startingIndexForNewAnimatables","onAssetContainerLoaded","container","mergeAnimationsTo","onAnimationFileImportedObservable","ImportAnimations","_scene"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Loading/sceneLoader.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { StartsWith } from \"../Misc/stringTools\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    [extension: string]: {\r\n        isBinary: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the factory\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @return the new plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: any, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): any;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static OnPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\n\r\n    private static _RegisteredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\n\r\n    private static _ShowingLoadingScreen = false;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin {\r\n        return SceneLoader._RegisteredPlugins[\".babylon\"];\r\n    }\r\n\r\n    private static _GetPluginForExtension(extension: string): IRegisteredPlugin {\r\n        const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\r\n            \"Unable to find a plugin to load \" +\r\n                extension +\r\n                \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\"\r\n        );\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForDirectLoad(data: string): IRegisteredPlugin {\r\n        for (const extension in SceneLoader._RegisteredPlugins) {\r\n            const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\r\n\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._RegisteredPlugins[extension];\r\n            }\r\n        }\r\n\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForFilename(sceneFilename: string): IRegisteredPlugin {\r\n        const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n\r\n        const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n        const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._GetPluginForExtension(extension);\r\n    }\r\n\r\n    private static _GetDirectLoad(sceneFilename: string): Nullable<string> {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _FormatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n        let errorMessage = \"Unable to load from \" + fileInfo.url;\r\n\r\n        if (message) {\r\n            errorMessage += `: ${message}`;\r\n        } else if (exception) {\r\n            errorMessage += `: ${exception}`;\r\n        }\r\n\r\n        return errorMessage;\r\n    }\r\n\r\n    private static _LoadData(\r\n        fileInfo: IFileInfo,\r\n        scene: Scene,\r\n        onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: any, responseURL?: string) => void,\r\n        onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n        onError: (message?: string, exception?: any) => void,\r\n        onDispose: () => void,\r\n        pluginExtension: Nullable<string>\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\r\n        const registeredPlugin = pluginExtension\r\n            ? SceneLoader._GetPluginForExtension(pluginExtension)\r\n            : directLoad\r\n            ? SceneLoader._GetPluginForDirectLoad(fileInfo.url)\r\n            : SceneLoader._GetPluginForFilename(fileInfo.url);\r\n\r\n        let plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n        if ((registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin !== undefined) {\r\n            plugin = (registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin();\r\n        } else {\r\n            plugin = <any>registeredPlugin.plugin;\r\n        }\r\n\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result.then) {\r\n                    result\r\n                        .then((data: any) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return plugin;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin.isBinary;\r\n\r\n        const dataCallback = (data: any, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        const onDisposeObservable = (plugin as any).onDisposeObservable as Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(() => {\r\n                pluginDisposed = true;\r\n\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n\r\n                onDispose();\r\n            });\r\n        }\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            const fileOrUrl = fileInfo.file || fileInfo.url;\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback)\r\n                : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n\r\n        return plugin;\r\n    }\r\n\r\n    private static _GetFileInfo(rootUrl: string, sceneFilename: string | File): Nullable<IFileInfo> {\r\n        let url: string;\r\n        let name: string;\r\n        let file: Nullable<File> = null;\r\n\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        } else if ((sceneFilename as File).name) {\r\n            const sceneFile = sceneFilename as File;\r\n            url = `file:${sceneFile.name}`;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        } else if (typeof sceneFilename === \"string\" && StartsWith(sceneFilename, \"data:\")) {\r\n            url = sceneFilename;\r\n            name = \"\";\r\n        } else {\r\n            const filename = sceneFilename as string;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file,\r\n        };\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory {\r\n        return SceneLoader._GetPluginForExtension(extension).plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return !!SceneLoader._RegisteredPlugins[extension];\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            const extension = <string>plugin.extensions;\r\n            SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false,\r\n            };\r\n        } else {\r\n            const extensions = <ISceneLoaderPluginExtensions>plugin.extensions;\r\n            Object.keys(extensions).forEach((extension) => {\r\n                SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback: \" + e, e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data, responseURL) => {\r\n                if (plugin.rewriteRootURL) {\r\n                    fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n                }\r\n\r\n                if ((<any>plugin).importMesh) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const meshes = new Array<AbstractMesh>();\r\n                    const particleSystems = new Array<IParticleSystem>();\r\n                    const skeletons = new Array<Skeleton>();\r\n\r\n                    if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(meshes, particleSystems, skeletons, [], [], [], []);\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((result) => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(\r\n                                result.meshes,\r\n                                result.particleSystems,\r\n                                result.skeletons,\r\n                                result.animationGroups,\r\n                                result.transformNodes,\r\n                                result.geometries,\r\n                                result.lights\r\n                            );\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportMesh(\r\n                meshNames,\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: particleSystems,\r\n                        skeletons: skeletons,\r\n                        animationGroups: animationGroups,\r\n                        transformNodes: transformNodes,\r\n                        geometries: geometries,\r\n                        lights: lights,\r\n                    });\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Load(\r\n                rootUrl,\r\n                sceneFilename,\r\n                engine,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\r\n            this._ShowingLoadingScreen = true;\r\n            scene.getEngine().displayLoadingUI();\r\n            scene.executeWhenReady(() => {\r\n                scene.getEngine().hideLoadingUI();\r\n                this._ShowingLoadingScreen = false;\r\n            });\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = () => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).load) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then(() => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler();\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Append(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = (assets: AssetContainer) => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).loadAssetContainer) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                    if (!assetContainer) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                } else if ((<any>plugin).loadAssetContainerAsync) {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((assetContainer) => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(assetContainer);\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                } else {\r\n                    errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<AssetContainer> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.LoadAssetContainer(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (assetContainer) => {\r\n                    resolve(assetContainer);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): void {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load animations to\");\r\n            return;\r\n        }\r\n\r\n        if (overwriteAnimations) {\r\n            // Reset, stop and dispose all animations before loading new ones\r\n            for (const animatable of scene.animatables) {\r\n                animatable.reset();\r\n            }\r\n            scene.stopAllAnimations();\r\n            scene.animationGroups.slice().forEach((animationGroup) => {\r\n                animationGroup.dispose();\r\n            });\r\n            const nodes = scene.getNodes();\r\n            nodes.forEach((node) => {\r\n                if (node.animations) {\r\n                    node.animations = [];\r\n                }\r\n            });\r\n        } else {\r\n            switch (animationGroupLoadingMode) {\r\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                    scene.animationGroups.slice().forEach((animationGroup) => {\r\n                        animationGroup.dispose();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.stop();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.reset();\r\n                        animationGroup.restart();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                    // nothing to do\r\n                    break;\r\n                default:\r\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n        const onAssetContainerLoaded = (container: AssetContainer) => {\r\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n            container.dispose();\r\n\r\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n            if (onSuccess) {\r\n                onSuccess(scene);\r\n            }\r\n        };\r\n\r\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    public static ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportAnimations(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                overwriteAnimations,\r\n                animationGroupLoadingMode,\r\n                targetConverter,\r\n                (_scene: Scene) => {\r\n                    resolve(_scene);\r\n                },\r\n                onProgress,\r\n                (_scene: Scene, message: string, exception: any) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}