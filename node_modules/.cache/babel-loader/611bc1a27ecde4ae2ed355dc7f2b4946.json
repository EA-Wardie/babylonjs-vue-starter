{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines a sound that can be played in the application.\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\n */\n\nvar Sound =\n/** @class */\nfunction () {\n  /**\n   * Create a sound and attach it to a scene\n   * @param name Name of your sound\n   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\n   * @param scene defines the scene the sound belongs to\n   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n   */\n  function Sound(name, urlOrArrayBuffer, scene, readyToPlayCallback, options) {\n    if (readyToPlayCallback === void 0) {\n      readyToPlayCallback = null;\n    }\n\n    var _this = this;\n\n    var _a, _b, _c, _d, _e;\n    /**\n     * Does the sound autoplay once loaded.\n     */\n\n\n    this.autoplay = false;\n    this._loop = false;\n    /**\n     * Does the sound use a custom attenuation curve to simulate the falloff\n     * happening when the source gets further away from the camera.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\n     */\n\n    this.useCustomAttenuation = false;\n    /**\n     * Is this sound currently played.\n     */\n\n    this.isPlaying = false;\n    /**\n     * Is this sound currently paused.\n     */\n\n    this.isPaused = false;\n    /**\n     * Define the reference distance the sound should be heard perfectly.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n\n    this.refDistance = 1;\n    /**\n     * Define the roll off factor of spatial sounds.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n\n    this.rolloffFactor = 1;\n    /**\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n\n    this.maxDistance = 100;\n    /**\n     * Define the distance attenuation model the sound will follow.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n\n    this.distanceModel = \"linear\";\n    /**\n     * Gets or sets an object used to store user defined information for the sound.\n     */\n\n    this.metadata = null;\n    /**\n     * Observable event when the current playing sound finishes.\n     */\n\n    this.onEndedObservable = new Observable();\n    this._spatialSound = false;\n    this._panningModel = \"equalpower\";\n    this._playbackRate = 1;\n    this._streaming = false;\n    this._startTime = 0;\n    this._startOffset = 0;\n    this._position = Vector3.Zero();\n    this._localDirection = new Vector3(1, 0, 0);\n    this._volume = 1;\n    this._isReadyToPlay = false;\n    this._isDirectional = false; // Used if you'd like to create a directional sound.\n    // If not set, the sound will be omnidirectional\n\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._coneOuterGain = 0;\n    this._isOutputConnected = false;\n    this._urlType = \"Unknown\";\n    this.name = name;\n    scene = scene || EngineStore.LastCreatedScene;\n\n    if (!scene) {\n      return;\n    }\n\n    this._scene = scene;\n\n    Sound._SceneComponentInitialization(scene);\n\n    this._readyToPlayCallback = readyToPlayCallback; // Default custom attenuation function is a linear attenuation\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._customAttenuationFunction = function (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {\n      if (currentDistance < maxDistance) {\n        return currentVolume * (1 - currentDistance / maxDistance);\n      } else {\n        return 0;\n      }\n    };\n\n    if (options) {\n      this.autoplay = options.autoplay || false;\n      this._loop = options.loop || false; // if volume === 0, we need another way to check this option\n\n      if (options.volume !== undefined) {\n        this._volume = options.volume;\n      }\n\n      this._spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\n      this.rolloffFactor = options.rolloffFactor || 1;\n      this.refDistance = options.refDistance || 1;\n      this.distanceModel = options.distanceModel || \"linear\";\n      this._playbackRate = options.playbackRate || 1;\n      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\n      this._length = options.length;\n      this._offset = options.offset;\n    }\n\n    if (((_e = Engine.audioEngine) === null || _e === void 0 ? void 0 : _e.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      this._soundGain = Engine.audioEngine.audioContext.createGain();\n      this._soundGain.gain.value = this._volume;\n      this._inputAudioNode = this._soundGain;\n      this._outputAudioNode = this._soundGain;\n\n      if (this._spatialSound) {\n        this._createSpatialParameters();\n      }\n\n      this._scene.mainSoundTrack.addSound(this);\n\n      var validParameter = true; // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n\n      if (urlOrArrayBuffer) {\n        try {\n          if (typeof urlOrArrayBuffer === \"string\") {\n            this._urlType = \"String\";\n          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            this._urlType = \"ArrayBuffer\";\n          } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\n            this._urlType = \"MediaElement\";\n          } else if (urlOrArrayBuffer instanceof MediaStream) {\n            this._urlType = \"MediaStream\";\n          } else if (Array.isArray(urlOrArrayBuffer)) {\n            this._urlType = \"Array\";\n          }\n\n          var urls = [];\n          var codecSupportedFound = false;\n\n          switch (this._urlType) {\n            case \"MediaElement\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\n\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n\n              break;\n\n            case \"MediaStream\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n\n              break;\n\n            case \"ArrayBuffer\":\n              if (urlOrArrayBuffer.byteLength > 0) {\n                codecSupportedFound = true;\n\n                this._soundLoaded(urlOrArrayBuffer);\n              }\n\n              break;\n\n            case \"String\":\n              urls.push(urlOrArrayBuffer);\n            // eslint-disable-next-line no-fallthrough\n\n            case \"Array\":\n              if (urls.length === 0) {\n                urls = urlOrArrayBuffer;\n              }\n\n              var _loop_1 = function _loop_1(i) {\n                var url = urls[i];\n                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(\".wav\", url.length - 4) !== -1 || url.indexOf(\".m4a\", url.length - 4) !== -1 || url.indexOf(\".mp4\", url.length - 4) !== -1 || url.indexOf(\"blob:\") !== -1;\n\n                if (codecSupportedFound) {\n                  // Loading sound\n                  if (!this_1._streaming) {\n                    this_1._scene._loadFile(url, function (data) {\n                      _this._soundLoaded(data);\n                    }, undefined, true, true, function (exception) {\n                      if (exception) {\n                        Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                      }\n\n                      Logger.Error(\"Sound creation aborted.\");\n\n                      _this._scene.mainSoundTrack.removeSound(_this);\n                    });\n                  } // Streaming sound using HTML5 Audio tag\n                  else {\n                    this_1._htmlAudioElement = new Audio(url);\n                    this_1._htmlAudioElement.controls = false;\n                    this_1._htmlAudioElement.loop = this_1.loop;\n                    Tools.SetCorsBehavior(url, this_1._htmlAudioElement);\n                    this_1._htmlAudioElement.preload = \"auto\";\n\n                    this_1._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\n                      _this._isReadyToPlay = true;\n\n                      if (_this.autoplay) {\n                        _this.play(0, _this._offset, _this._length);\n                      }\n\n                      if (_this._readyToPlayCallback) {\n                        _this._readyToPlayCallback();\n                      }\n                    });\n\n                    document.body.appendChild(this_1._htmlAudioElement);\n\n                    this_1._htmlAudioElement.load();\n                  }\n\n                  return \"break\";\n                }\n              };\n\n              var this_1 = this; // If we found a supported format, we load it immediately and stop the loop\n\n              for (var i = 0; i < urls.length; i++) {\n                var state_1 = _loop_1(i);\n\n                if (state_1 === \"break\") break;\n              }\n\n              break;\n\n            default:\n              validParameter = false;\n              break;\n          }\n\n          if (!validParameter) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n          } else {\n            if (!codecSupportedFound) {\n              this._isReadyToPlay = true; // Simulating a ready to play event to avoid breaking code path\n\n              if (this._readyToPlayCallback) {\n                window.setTimeout(function () {\n                  if (_this._readyToPlayCallback) {\n                    _this._readyToPlayCallback();\n                  }\n                }, 1000);\n              }\n            }\n          }\n        } catch (ex) {\n          Logger.Error(\"Unexpected error. Sound creation aborted.\");\n\n          this._scene.mainSoundTrack.removeSound(this);\n        }\n      }\n    } else {\n      // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n      this._scene.mainSoundTrack.addSound(this);\n\n      if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\n        Logger.Error(\"Web Audio is not supported by your browser.\");\n        Engine.audioEngine.WarnedWebAudioUnsupported = true;\n      } // Simulating a ready to play event to avoid breaking code for non web audio browsers\n\n\n      if (this._readyToPlayCallback) {\n        window.setTimeout(function () {\n          if (_this._readyToPlayCallback) {\n            _this._readyToPlayCallback();\n          }\n        }, 1000);\n      }\n    }\n  }\n\n  Object.defineProperty(Sound.prototype, \"loop\", {\n    /**\n     * Does the sound loop after it finishes playing once.\n     */\n    get: function get() {\n      return this._loop;\n    },\n    set: function set(value) {\n      if (value === this._loop) {\n        return;\n      }\n\n      this._loop = value;\n      this.updateOptions({\n        loop: value\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sound.prototype, \"currentTime\", {\n    /**\n     * Gets the current time for the sound.\n     */\n    get: function get() {\n      var _a;\n\n      if (this._htmlAudioElement) {\n        return this._htmlAudioElement.currentTime;\n      }\n\n      var currentTime = this._startOffset;\n\n      if (this.isPlaying && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n        currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n\n      return currentTime;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sound.prototype, \"spatialSound\", {\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n    get: function get() {\n      return this._spatialSound;\n    },\n\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n     */\n    set: function set(newValue) {\n      var _a;\n\n      this._spatialSound = newValue;\n\n      if (this._spatialSound && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {\n        this._createSpatialParameters();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Release the sound and its associated resources\n   */\n\n  Sound.prototype.dispose = function () {\n    var _a;\n\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      if (this.isPlaying) {\n        this.stop();\n      }\n\n      this._isReadyToPlay = false;\n\n      if (this.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(this);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[this.soundTrackId].removeSound(this);\n      }\n\n      if (this._soundGain) {\n        this._soundGain.disconnect();\n\n        this._soundGain = null;\n      }\n\n      if (this._soundPanner) {\n        this._soundPanner.disconnect();\n\n        this._soundPanner = null;\n      }\n\n      if (this._soundSource) {\n        this._soundSource.disconnect();\n\n        this._soundSource = null;\n      }\n\n      this._audioBuffer = null;\n\n      if (this._htmlAudioElement) {\n        this._htmlAudioElement.pause();\n\n        this._htmlAudioElement.src = \"\";\n        document.body.removeChild(this._htmlAudioElement);\n      }\n\n      if (this._streamingSource) {\n        this._streamingSource.disconnect();\n      }\n\n      if (this._connectedTransformNode && this._registerFunc) {\n        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n        this._connectedTransformNode = null;\n      }\n    }\n  };\n  /**\n   * Gets if the sounds is ready to be played or not.\n   * @returns true if ready, otherwise false\n   */\n\n\n  Sound.prototype.isReady = function () {\n    return this._isReadyToPlay;\n  };\n  /**\n   * Get the current class name.\n   * @returns current class name\n   */\n\n\n  Sound.prototype.getClassName = function () {\n    return \"Sound\";\n  };\n\n  Sound.prototype._soundLoaded = function (audioData) {\n    var _this = this;\n\n    var _a;\n\n    if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      return;\n    }\n\n    Engine.audioEngine.audioContext.decodeAudioData(audioData, function (buffer) {\n      _this._audioBuffer = buffer;\n      _this._isReadyToPlay = true;\n\n      if (_this.autoplay) {\n        _this.play(0, _this._offset, _this._length);\n      }\n\n      if (_this._readyToPlayCallback) {\n        _this._readyToPlayCallback();\n      }\n    }, function (err) {\n      Logger.Error(\"Error while decoding audio data for: \" + _this.name + \" / Error: \" + err);\n    });\n  };\n  /**\n   * Sets the data of the sound from an audiobuffer\n   * @param audioBuffer The audioBuffer containing the data\n   */\n\n\n  Sound.prototype.setAudioBuffer = function (audioBuffer) {\n    var _a;\n\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      this._audioBuffer = audioBuffer;\n      this._isReadyToPlay = true;\n    }\n  };\n  /**\n   * Updates the current sounds options such as maxdistance, loop...\n   * @param options A JSON object containing values named as the object properties\n   */\n\n\n  Sound.prototype.updateOptions = function (options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    if (options) {\n      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\n      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\n      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\n      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\n      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\n      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\n      this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : undefined;\n      this.setVolume((_k = options.volume) !== null && _k !== void 0 ? _k : this._volume);\n\n      this._updateSpatialParameters();\n\n      if (this.isPlaying) {\n        if (this._streaming && this._htmlAudioElement) {\n          this._htmlAudioElement.playbackRate = this._playbackRate;\n\n          if (this._htmlAudioElement.loop !== this.loop) {\n            this._htmlAudioElement.loop = this.loop;\n          }\n        } else {\n          if (this._soundSource) {\n            this._soundSource.playbackRate.value = this._playbackRate;\n\n            if (this._soundSource.loop !== this.loop) {\n              this._soundSource.loop = this.loop;\n            }\n\n            if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n              this._soundSource.loopStart = this._offset;\n            }\n\n            if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n              this._soundSource.loopEnd = (this._offset | 0) + this._length;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  Sound.prototype._createSpatialParameters = function () {\n    var _a, _b;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      if (this._scene.headphone) {\n        this._panningModel = \"HRTF\";\n      }\n\n      this._soundPanner = (_b = this._soundPanner) !== null && _b !== void 0 ? _b : Engine.audioEngine.audioContext.createPanner();\n\n      if (this._soundPanner && this._outputAudioNode) {\n        this._updateSpatialParameters();\n\n        this._soundPanner.connect(this._outputAudioNode);\n\n        this._inputAudioNode = this._soundPanner;\n      }\n    }\n  };\n\n  Sound.prototype._updateSpatialParameters = function () {\n    if (this._spatialSound && this._soundPanner) {\n      if (this.useCustomAttenuation) {\n        // Tricks to disable in a way embedded Web Audio attenuation\n        this._soundPanner.distanceModel = \"linear\";\n        this._soundPanner.maxDistance = Number.MAX_VALUE;\n        this._soundPanner.refDistance = 1;\n        this._soundPanner.rolloffFactor = 1;\n        this._soundPanner.panningModel = this._panningModel;\n      } else {\n        this._soundPanner.distanceModel = this.distanceModel;\n        this._soundPanner.maxDistance = this.maxDistance;\n        this._soundPanner.refDistance = this.refDistance;\n        this._soundPanner.rolloffFactor = this.rolloffFactor;\n        this._soundPanner.panningModel = this._panningModel;\n      }\n    }\n  };\n  /**\n   * Switch the panning model to HRTF:\n   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n   */\n\n\n  Sound.prototype.switchPanningModelToHRTF = function () {\n    this._panningModel = \"HRTF\";\n\n    this._switchPanningModel();\n  };\n  /**\n   * Switch the panning model to Equal Power:\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\n   */\n\n\n  Sound.prototype.switchPanningModelToEqualPower = function () {\n    this._panningModel = \"equalpower\";\n\n    this._switchPanningModel();\n  };\n\n  Sound.prototype._switchPanningModel = function () {\n    var _a;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n      this._soundPanner.panningModel = this._panningModel;\n    }\n  };\n  /**\n   * Connect this sound to a sound track audio node like gain...\n   * @param soundTrackAudioNode the sound track audio node to connect to\n   */\n\n\n  Sound.prototype.connectToSoundTrackAudioNode = function (soundTrackAudioNode) {\n    var _a;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {\n      if (this._isOutputConnected) {\n        this._outputAudioNode.disconnect();\n      }\n\n      this._outputAudioNode.connect(soundTrackAudioNode);\n\n      this._isOutputConnected = true;\n    }\n  };\n  /**\n   * Transform this sound into a directional source\n   * @param coneInnerAngle Size of the inner cone in degree\n   * @param coneOuterAngle Size of the outer cone in degree\n   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n   */\n\n\n  Sound.prototype.setDirectionalCone = function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    if (coneOuterAngle < coneInnerAngle) {\n      Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n      return;\n    }\n\n    this._coneInnerAngle = coneInnerAngle;\n    this._coneOuterAngle = coneOuterAngle;\n    this._coneOuterGain = coneOuterGain;\n    this._isDirectional = true;\n\n    if (this.isPlaying && this.loop) {\n      this.stop();\n      this.play(0, this._offset, this._length);\n    }\n  };\n\n  Object.defineProperty(Sound.prototype, \"directionalConeInnerAngle\", {\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    get: function get() {\n      return this._coneInnerAngle;\n    },\n\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    set: function set(value) {\n      var _a;\n\n      if (value != this._coneInnerAngle) {\n        if (this._coneOuterAngle < value) {\n          Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneInnerAngle = value;\n\n        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n          this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sound.prototype, \"directionalConeOuterAngle\", {\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    get: function get() {\n      return this._coneOuterAngle;\n    },\n\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    set: function set(value) {\n      var _a;\n\n      if (value != this._coneOuterAngle) {\n        if (value < this._coneInnerAngle) {\n          Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneOuterAngle = value;\n\n        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n          this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the position of the emitter if spatial sound is enabled\n   * @param newPosition Defines the new position\n   */\n\n  Sound.prototype.setPosition = function (newPosition) {\n    var _a;\n\n    if (newPosition.equals(this._position)) {\n      return;\n    }\n\n    this._position.copyFrom(newPosition);\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n      this._soundPanner.positionX.value = this._position.x;\n      this._soundPanner.positionY.value = this._position.y;\n      this._soundPanner.positionZ.value = this._position.z;\n    }\n  };\n  /**\n   * Sets the local direction of the emitter if spatial sound is enabled\n   * @param newLocalDirection Defines the new local direction\n   */\n\n\n  Sound.prototype.setLocalDirectionToMesh = function (newLocalDirection) {\n    var _a;\n\n    this._localDirection = newLocalDirection;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n\n  Sound.prototype._updateDirection = function () {\n    if (!this._connectedTransformNode || !this._soundPanner) {\n      return;\n    }\n\n    var mat = this._connectedTransformNode.getWorldMatrix();\n\n    var direction = Vector3.TransformNormal(this._localDirection, mat);\n    direction.normalize();\n    this._soundPanner.orientationX.value = direction.x;\n    this._soundPanner.orientationY.value = direction.y;\n    this._soundPanner.orientationZ.value = direction.z;\n  };\n  /** @hidden */\n\n\n  Sound.prototype.updateDistanceFromListener = function () {\n    var _a;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n      var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n\n      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n    }\n  };\n  /**\n   * Sets a new custom attenuation function for the sound.\n   * @param callback Defines the function used for the attenuation\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\n   */\n\n\n  Sound.prototype.setAttenuationFunction = function (callback) {\n    this._customAttenuationFunction = callback;\n  };\n  /**\n   * Play the sound\n   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n   * @param offset (optional) Start the sound at a specific time in seconds\n   * @param length (optional) Sound duration (in seconds)\n   */\n\n\n  Sound.prototype.play = function (time, offset, length) {\n    var _this = this;\n\n    var _a, _b, _c, _d;\n\n    if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      try {\n        if (this._startOffset < 0) {\n          time = -this._startOffset;\n          this._startOffset = 0;\n        }\n\n        var startTime_1 = time ? ((_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime;\n\n        if (!this._soundSource || !this._streamingSource) {\n          if (this._spatialSound && this._soundPanner) {\n            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n              this._soundPanner.positionX.value = this._position.x;\n              this._soundPanner.positionY.value = this._position.y;\n              this._soundPanner.positionZ.value = this._position.z;\n            }\n\n            if (this._isDirectional) {\n              this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n              this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n              this._soundPanner.coneOuterGain = this._coneOuterGain;\n\n              if (this._connectedTransformNode) {\n                this._updateDirection();\n              } else {\n                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n              }\n            }\n          }\n        }\n\n        if (this._streaming) {\n          if (!this._streamingSource) {\n            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n\n            this._htmlAudioElement.onended = function () {\n              _this._onended();\n            };\n\n            this._htmlAudioElement.playbackRate = this._playbackRate;\n          }\n\n          this._streamingSource.disconnect();\n\n          if (this._inputAudioNode) {\n            this._streamingSource.connect(this._inputAudioNode);\n          }\n\n          if (this._htmlAudioElement) {\n            // required to manage properly the new suspended default state of Chrome\n            // When the option 'streaming: true' is used, we need first to wait for\n            // the audio engine to be unlocked by a user gesture before trying to play\n            // an HTML Audio element\n            var tryToPlay_1 = function tryToPlay_1() {\n              var _a, _b;\n\n              if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.unlocked) {\n                var playPromise = _this._htmlAudioElement.play(); // In browsers that don’t yet support this functionality,\n                // playPromise won’t be defined.\n\n\n                if (playPromise !== undefined) {\n                  playPromise[\"catch\"](function () {\n                    var _a, _b; // Automatic playback failed.\n                    // Waiting for the audio engine to be unlocked by user click on unmute\n\n\n                    (_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.lock();\n\n                    if (_this.loop || _this.autoplay) {\n                      (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(function () {\n                        tryToPlay_1();\n                      });\n                    }\n                  });\n                }\n              } else {\n                if (_this.loop || _this.autoplay) {\n                  (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay_1();\n                  });\n                }\n              }\n            };\n\n            tryToPlay_1();\n          }\n        } else {\n          var tryToPlay_2 = function tryToPlay_2() {\n            var _a, _b, _c;\n\n            if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {\n              length = length || _this._length;\n              offset = offset || _this._offset;\n\n              if (_this._soundSource) {\n                var oldSource_1 = _this._soundSource;\n\n                oldSource_1.onended = function () {\n                  oldSource_1.disconnect();\n                };\n              }\n\n              _this._soundSource = (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.createBufferSource();\n\n              if (_this._soundSource && _this._inputAudioNode) {\n                _this._soundSource.buffer = _this._audioBuffer;\n\n                _this._soundSource.connect(_this._inputAudioNode);\n\n                _this._soundSource.loop = _this.loop;\n\n                if (offset !== undefined) {\n                  _this._soundSource.loopStart = offset;\n                }\n\n                if (length !== undefined) {\n                  _this._soundSource.loopEnd = (offset | 0) + length;\n                }\n\n                _this._soundSource.playbackRate.value = _this._playbackRate;\n\n                _this._soundSource.onended = function () {\n                  _this._onended();\n                };\n\n                startTime_1 = time ? ((_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;\n                var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;\n\n                _this._soundSource.start(startTime_1, actualOffset, _this.loop ? undefined : length);\n              }\n            }\n          };\n\n          if (((_d = Engine.audioEngine) === null || _d === void 0 ? void 0 : _d.audioContext.state) === \"suspended\") {\n            // Wait a bit for FF as context seems late to be ready.\n            setTimeout(function () {\n              var _a;\n\n              if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext.state) === \"suspended\") {\n                // Automatic playback failed.\n                // Waiting for the audio engine to be unlocked by user click on unmute\n                Engine.audioEngine.lock();\n\n                if (_this.loop || _this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay_2();\n                  });\n                }\n              } else {\n                tryToPlay_2();\n              }\n            }, 500);\n          } else {\n            tryToPlay_2();\n          }\n        }\n\n        this._startTime = startTime_1;\n        this.isPlaying = true;\n        this.isPaused = false;\n      } catch (ex) {\n        Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n      }\n    }\n  };\n\n  Sound.prototype._onended = function () {\n    this.isPlaying = false;\n    this._startOffset = 0;\n\n    if (this.onended) {\n      this.onended();\n    }\n\n    this.onEndedObservable.notifyObservers(this);\n  };\n  /**\n   * Stop the sound\n   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n   */\n\n\n  Sound.prototype.stop = function (time) {\n    var _this = this;\n\n    var _a;\n\n    if (this.isPlaying) {\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause(); // Test needed for Firefox or it will generate an Invalid State Error\n\n\n          if (this._htmlAudioElement.currentTime > 0) {\n            this._htmlAudioElement.currentTime = 0;\n          }\n        } else {\n          this._streamingSource.disconnect();\n        }\n\n        this.isPlaying = false;\n      } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {\n        var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\n\n        this._soundSource.stop(stopTime);\n\n        if (stopTime === undefined) {\n          this.isPlaying = false;\n\n          this._soundSource.onended = function () {\n            return void 0;\n          };\n        } else {\n          this._soundSource.onended = function () {\n            _this.isPlaying = false;\n          };\n        }\n\n        if (!this.isPaused) {\n          this._startOffset = 0;\n        }\n      }\n    }\n  };\n  /**\n   * Put the sound in pause\n   */\n\n\n  Sound.prototype.pause = function () {\n    var _a;\n\n    if (this.isPlaying) {\n      this.isPaused = true;\n\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n        } else {\n          this._streamingSource.disconnect();\n        }\n\n        this.isPlaying = false;\n      } else if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {\n        this.stop(0);\n        this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n    }\n  };\n  /**\n   * Sets a dedicated volume for this sounds\n   * @param newVolume Define the new volume of the sound\n   * @param time Define time for gradual change to new volume\n   */\n\n\n  Sound.prototype.setVolume = function (newVolume, time) {\n    var _a;\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._soundGain) {\n      if (time && Engine.audioEngine.audioContext) {\n        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\n      } else {\n        this._soundGain.gain.value = newVolume;\n      }\n    }\n\n    this._volume = newVolume;\n  };\n  /**\n   * Set the sound play back rate\n   * @param newPlaybackRate Define the playback rate the sound should be played at\n   */\n\n\n  Sound.prototype.setPlaybackRate = function (newPlaybackRate) {\n    this._playbackRate = newPlaybackRate;\n\n    if (this.isPlaying) {\n      if (this._streaming && this._htmlAudioElement) {\n        this._htmlAudioElement.playbackRate = this._playbackRate;\n      } else if (this._soundSource) {\n        this._soundSource.playbackRate.value = this._playbackRate;\n      }\n    }\n  };\n  /**\n   * Gets the volume of the sound.\n   * @returns the volume of the sound\n   */\n\n\n  Sound.prototype.getVolume = function () {\n    return this._volume;\n  };\n  /**\n   * Attach the sound to a dedicated mesh\n   * @param transformNode The transform node to connect the sound with\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\n   */\n\n\n  Sound.prototype.attachToMesh = function (transformNode) {\n    var _this = this;\n\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n    }\n\n    this._connectedTransformNode = transformNode;\n\n    if (!this._spatialSound) {\n      this._spatialSound = true;\n\n      this._createSpatialParameters();\n\n      if (this.isPlaying && this.loop) {\n        this.stop();\n        this.play(0, this._offset, this._length);\n      }\n    }\n\n    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n\n    this._registerFunc = function (transformNode) {\n      return _this._onRegisterAfterWorldMatrixUpdate(transformNode);\n    };\n\n    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n  };\n  /**\n   * Detach the sound from the previously attached mesh\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\n   */\n\n\n  Sound.prototype.detachFromMesh = function () {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n      this._connectedTransformNode = null;\n    }\n  };\n\n  Sound.prototype._onRegisterAfterWorldMatrixUpdate = function (node) {\n    var _a;\n\n    if (!node.getBoundingInfo) {\n      this.setPosition(node.absolutePosition);\n    } else {\n      var mesh = node;\n      var boundingInfo = mesh.getBoundingInfo();\n      this.setPosition(boundingInfo.boundingSphere.centerWorld);\n    }\n\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n  /**\n   * Clone the current sound in the scene.\n   * @returns the new sound clone\n   */\n\n\n  Sound.prototype.clone = function () {\n    var _this = this;\n\n    if (!this._streaming) {\n      var setBufferAndRun_1 = function setBufferAndRun_1() {\n        if (_this._isReadyToPlay) {\n          clonedSound_1._audioBuffer = _this.getAudioBuffer();\n          clonedSound_1._isReadyToPlay = true;\n\n          if (clonedSound_1.autoplay) {\n            clonedSound_1.play(0, _this._offset, _this._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun_1, 300);\n        }\n      };\n\n      var currentOptions = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this._spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      };\n      var clonedSound_1 = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n\n      if (this.useCustomAttenuation) {\n        clonedSound_1.setAttenuationFunction(this._customAttenuationFunction);\n      }\n\n      clonedSound_1.setPosition(this._position);\n      clonedSound_1.setPlaybackRate(this._playbackRate);\n      setBufferAndRun_1();\n      return clonedSound_1;\n    } // Can't clone a streaming sound\n    else {\n      return null;\n    }\n  };\n  /**\n   * Gets the current underlying audio buffer containing the data\n   * @returns the audio buffer\n   */\n\n\n  Sound.prototype.getAudioBuffer = function () {\n    return this._audioBuffer;\n  };\n  /**\n   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\n   * @returns the source node\n   */\n\n\n  Sound.prototype.getSoundSource = function () {\n    return this._soundSource;\n  };\n  /**\n   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\n   * @returns the gain node\n   */\n\n\n  Sound.prototype.getSoundGain = function () {\n    return this._soundGain;\n  };\n  /**\n   * Serializes the Sound in a JSON representation\n   * @returns the JSON representation of the sound\n   */\n\n\n  Sound.prototype.serialize = function () {\n    var serializationObject = {\n      name: this.name,\n      url: this.name,\n      autoplay: this.autoplay,\n      loop: this.loop,\n      volume: this._volume,\n      spatialSound: this._spatialSound,\n      maxDistance: this.maxDistance,\n      rolloffFactor: this.rolloffFactor,\n      refDistance: this.refDistance,\n      distanceModel: this.distanceModel,\n      playbackRate: this._playbackRate,\n      panningModel: this._panningModel,\n      soundTrackId: this.soundTrackId,\n      metadata: this.metadata\n    };\n\n    if (this._spatialSound) {\n      if (this._connectedTransformNode) {\n        serializationObject.connectedMeshId = this._connectedTransformNode.id;\n      }\n\n      serializationObject.position = this._position.asArray();\n      serializationObject.refDistance = this.refDistance;\n      serializationObject.distanceModel = this.distanceModel;\n      serializationObject.isDirectional = this._isDirectional;\n      serializationObject.localDirectionToMesh = this._localDirection.asArray();\n      serializationObject.coneInnerAngle = this._coneInnerAngle;\n      serializationObject.coneOuterAngle = this._coneOuterAngle;\n      serializationObject.coneOuterGain = this._coneOuterGain;\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Parse a JSON representation of a sound to instantiate in a given scene\n   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\n   * @param scene Define the scene the new parsed sound should be created in\n   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\n   * @param sourceSound Define a sound place holder if do not need to instantiate a new one\n   * @returns the newly parsed sound\n   */\n\n\n  Sound.Parse = function (parsedSound, scene, rootUrl, sourceSound) {\n    var soundName = parsedSound.name;\n    var soundUrl;\n\n    if (parsedSound.url) {\n      soundUrl = rootUrl + parsedSound.url;\n    } else {\n      soundUrl = rootUrl + soundName;\n    }\n\n    var options = {\n      autoplay: parsedSound.autoplay,\n      loop: parsedSound.loop,\n      volume: parsedSound.volume,\n      spatialSound: parsedSound.spatialSound,\n      maxDistance: parsedSound.maxDistance,\n      rolloffFactor: parsedSound.rolloffFactor,\n      refDistance: parsedSound.refDistance,\n      distanceModel: parsedSound.distanceModel,\n      playbackRate: parsedSound.playbackRate\n    };\n    var newSound;\n\n    if (!sourceSound) {\n      newSound = new Sound(soundName, soundUrl, scene, function () {\n        scene._removePendingData(newSound);\n      }, options);\n\n      scene._addPendingData(newSound);\n    } else {\n      var setBufferAndRun_2 = function setBufferAndRun_2() {\n        if (sourceSound._isReadyToPlay) {\n          newSound._audioBuffer = sourceSound.getAudioBuffer();\n          newSound._isReadyToPlay = true;\n\n          if (newSound.autoplay) {\n            newSound.play(0, newSound._offset, newSound._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun_2, 300);\n        }\n      };\n\n      newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n      setBufferAndRun_2();\n    }\n\n    if (parsedSound.position) {\n      var soundPosition = Vector3.FromArray(parsedSound.position);\n      newSound.setPosition(soundPosition);\n    }\n\n    if (parsedSound.isDirectional) {\n      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n\n      if (parsedSound.localDirectionToMesh) {\n        var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n        newSound.setLocalDirectionToMesh(localDirectionToMesh);\n      }\n    }\n\n    if (parsedSound.connectedMeshId) {\n      var connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\n\n      if (connectedMesh) {\n        newSound.attachToMesh(connectedMesh);\n      }\n    }\n\n    if (parsedSound.metadata) {\n      newSound.metadata = parsedSound.metadata;\n    }\n\n    return newSound;\n  };\n  /**\n   * @param _\n   * @hidden\n   */\n\n\n  Sound._SceneComponentInitialization = function (_) {\n    throw _WarnImport(\"AudioSceneComponent\");\n  };\n\n  return Sound;\n}();\n\nexport { Sound };","map":{"version":3,"mappings":"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","names":["Tools","Observable","Vector3","Engine","Logger","_WarnImport","EngineStore","name","urlOrArrayBuffer","scene","readyToPlayCallback","options","Zero","LastCreatedScene","_scene","Sound","_SceneComponentInitialization","_readyToPlayCallback","_customAttenuationFunction","currentVolume","currentDistance","maxDistance","refDistance","rolloffFactor","autoplay","_loop","loop","volume","undefined","_volume","_spatialSound","spatialSound","_a","_b","useCustomAttenuation","_c","distanceModel","_playbackRate","playbackRate","_streaming","streaming","_d","_length","length","_offset","offset","audioEngine","_e","canUseWebAudio","audioContext","_soundGain","createGain","gain","value","_inputAudioNode","_outputAudioNode","_createSpatialParameters","mainSoundTrack","addSound","validParameter","_urlType","ArrayBuffer","HTMLMediaElement","MediaStream","Array","isArray","urls","codecSupportedFound","_isReadyToPlay","_streamingSource","createMediaElementSource","play","createMediaStreamSource","byteLength","_soundLoaded","push","i","url","skipCodecCheck","indexOf","isMP3supported","isOGGsupported","this_1","_loadFile","data","_this","exception","Error","status","removeSound","_htmlAudioElement","Audio","controls","SetCorsBehavior","preload","addEventListener","document","body","appendChild","load","window","setTimeout","ex","WarnedWebAudioUnsupported","Object","updateOptions","currentTime","_startOffset","isPlaying","_startTime","newValue","stop","soundTrackId","soundTracks","disconnect","_soundPanner","_soundSource","_audioBuffer","pause","src","removeChild","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","audioData","decodeAudioData","buffer","err","audioBuffer","_f","_g","_h","_j","setVolume","_k","_updateSpatialParameters","loopStart","loopEnd","headphone","_panningModel","createPanner","connect","Number","MAX_VALUE","panningModel","_switchPanningModel","soundTrackAudioNode","_isOutputConnected","coneInnerAngle","coneOuterAngle","coneOuterGain","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_isDirectional","newPosition","equals","_position","copyFrom","isNaN","x","y","z","positionX","positionY","positionZ","newLocalDirection","_localDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","orientationX","orientationY","orientationZ","activeCamera","distance","getDistanceToCamera","callback","time","audioEnabled","startTime_1","setOrientation","onended","_onended","tryToPlay_1","unlocked","playPromise","lock","onAudioUnlockedObservable","addOnce","tryToPlay_2","oldSource_1","createBufferSource","actualOffset","isPaused","duration","start","state","message","onEndedObservable","notifyObservers","stopTime","newVolume","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","newPlaybackRate","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","node","getBoundingInfo","setPosition","absolutePosition","mesh","boundingInfo","boundingSphere","centerWorld","setBufferAndRun_1","clonedSound_1","getAudioBuffer","currentOptions","setAttenuationFunction","setPlaybackRate","serializationObject","metadata","connectedMeshId","id","position","asArray","isDirectional","localDirectionToMesh","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","_removePendingData","_addPendingData","setBufferAndRun_2","soundPosition","FromArray","setDirectionalCone","setLocalDirectionToMesh","connectedMesh","getMeshById","attachToMesh","_"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Audio/sound.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n\r\n    private _loop = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (value === this._loop) {\r\n            return;\r\n        }\r\n\r\n        this._loop = value;\r\n        this.updateOptions({ loop: value });\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @hidden\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        let currentTime: number = this._startOffset;\r\n        if (this.isPlaying && Engine.audioEngine?.audioContext) {\r\n            currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n        }\r\n        return currentTime;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._spatialSound;\r\n    }\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        this._spatialSound = newValue;\r\n        if (this._spatialSound && Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._createSpatialParameters();\r\n        }\r\n    }\r\n    private _spatialSound: boolean = false;\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _startOffset: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: AudioNode;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: HTMLAudioElement;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" | \"MediaElement\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n\r\n    /**\r\n     * @param _\r\n     * @hidden\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this._loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this._spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._soundGain = Engine.audioEngine.audioContext.createGain();\r\n            this._soundGain!.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this._spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            let validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n                        this._urlType = \"MediaElement\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    let urls: string[] = [];\r\n                    let codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaElement\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        // eslint-disable-next-line no-fallthrough\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (let i = 0; i < urls.length; i++) {\r\n                                const url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".mp4\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\r\n                                            this._isReadyToPlay = true;\r\n                                            if (this.autoplay) {\r\n                                                this.play(0, this._offset, this._length);\r\n                                            }\r\n                                            if (this._readyToPlayCallback) {\r\n                                                this._readyToPlayCallback();\r\n                                            }\r\n                                        });\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                window.setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                Engine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                window.setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!Engine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        Engine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBuffer = buffer;\r\n                this._isReadyToPlay = true;\r\n                if (this.autoplay) {\r\n                    this.play(0, this._offset, this._length);\r\n                }\r\n                if (this._readyToPlayCallback) {\r\n                    this._readyToPlayCallback();\r\n                }\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this._offset = options.offset ?? undefined;\r\n            this.setVolume(options.volume ?? this._volume);\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = this._soundPanner ?? Engine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (this._spatialSound && this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (newPosition.equals(this._position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(newPosition);\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n            this._soundPanner.positionX.value = this._position.x;\r\n            this._soundPanner.positionY.value = this._position.y;\r\n            this._soundPanner.positionZ.value = this._position.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.orientationX.value = direction.x;\r\n        this._soundPanner.orientationY.value = direction.y;\r\n        this._soundPanner.orientationZ.value = direction.z;\r\n    }\r\n\r\n    /** @hidden */\r\n    public updateDistanceFromListener() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            const distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine?.audioContext) {\r\n            try {\r\n                if (this._startOffset < 0) {\r\n                    time = -this._startOffset;\r\n                    this._startOffset = 0;\r\n                }\r\n                let startTime = time ? Engine.audioEngine?.audioContext.currentTime + time : Engine.audioEngine?.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this._spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.positionX.value = this._position.x;\r\n                            this._soundPanner.positionY.value = this._position.y;\r\n                            this._soundPanner.positionZ.value = this._position.z;\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource) {\r\n                        this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    this._streamingSource.disconnect();\r\n                    if (this._inputAudioNode) {\r\n                        this._streamingSource.connect(this._inputAudioNode);\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio element\r\n                        const tryToPlay = () => {\r\n                            if (Engine.audioEngine?.unlocked) {\r\n                                const playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    playPromise.catch(() => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        Engine.audioEngine?.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    const tryToPlay = () => {\r\n                        if (Engine.audioEngine?.audioContext) {\r\n                            length = length || this._length;\r\n                            offset = offset || this._offset;\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = Engine.audioEngine?.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length!;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? Engine.audioEngine?.audioContext!.currentTime + time : Engine.audioEngine.audioContext!.currentTime;\r\n                                const actualOffset = this.isPaused ? this._startOffset % this._soundSource!.buffer!.duration : offset ? offset : 0;\r\n                                this._soundSource!.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (Engine.audioEngine?.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        setTimeout(() => {\r\n                            if (Engine.audioEngine?.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                Engine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        this._startOffset = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (Engine.audioEngine?.audioContext && this._soundSource) {\r\n                const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\r\n                this._soundSource.stop(stopTime);\r\n                if (stopTime === undefined) {\r\n                    this.isPlaying = false;\r\n                    this._soundSource.onended = () => void 0;\r\n                } else {\r\n                    this._soundSource.onended = () => {\r\n                        this.isPlaying = false;\r\n                    };\r\n                }\r\n                if (!this.isPaused) {\r\n                    this._startOffset = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (Engine.audioEngine?.audioContext) {\r\n                this.stop(0);\r\n                this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._soundGain) {\r\n            if (time && Engine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this._spatialSound) {\r\n            this._spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (Engine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            const setBufferAndRun = () => {\r\n                if (this._isReadyToPlay) {\r\n                    clonedSound._audioBuffer = this.getAudioBuffer();\r\n                    clonedSound._isReadyToPlay = true;\r\n                    if (clonedSound.autoplay) {\r\n                        clonedSound.play(0, this._offset, this._length);\r\n                    }\r\n                } else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            const currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this._spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this.name,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this._spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this._spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        let newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene._removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene._addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                if (sourceSound._isReadyToPlay) {\r\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                    newSound._isReadyToPlay = true;\r\n                    if (newSound.autoplay) {\r\n                        newSound.play(0, newSound._offset, newSound._length);\r\n                    }\r\n                } else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}