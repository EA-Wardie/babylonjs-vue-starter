{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport { Animation } from \"./animation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Tags } from \"../Misc/tags.js\";\n/**\n * This class defines the direct association between an animation and a target\n */\n\nvar TargetedAnimation =\n/** @class */\nfunction () {\n  function TargetedAnimation() {}\n  /**\n   * Returns the string \"TargetedAnimation\"\n   * @returns \"TargetedAnimation\"\n   */\n\n\n  TargetedAnimation.prototype.getClassName = function () {\n    return \"TargetedAnimation\";\n  };\n  /**\n   * Serialize the object\n   * @returns the JSON object representing the current entity\n   */\n\n\n  TargetedAnimation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.animation = this.animation.serialize();\n    serializationObject.targetId = this.target.id;\n    return serializationObject;\n  };\n\n  return TargetedAnimation;\n}();\n\nexport { TargetedAnimation };\n/**\n * Use this class to create coordinated animations on multiple targets\n */\n\nvar AnimationGroup =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Animation Group.\n   * This helps managing several animations at once.\n   * @see https://doc.babylonjs.com/divingDeeper/animation/groupAnimations\n   * @param name Defines the name of the group\n   * @param scene Defines the scene the group belongs to\n   */\n  function AnimationGroup(\n  /** The name of the animation group */\n  name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    this._targetedAnimations = new Array();\n    this._animatables = new Array();\n    this._from = Number.MAX_VALUE;\n    this._to = -Number.MAX_VALUE;\n    this._speedRatio = 1;\n    this._loopAnimation = false;\n    this._isAdditive = false;\n    /** @hidden */\n\n    this._parentContainer = null;\n    /**\n     * This observable will notify when one animation have ended\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when one animation loops\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    /**\n     * Observer raised when all animations have looped\n     */\n\n    this.onAnimationGroupLoopObservable = new Observable();\n    /**\n     * This observable will notify when all animations have ended.\n     */\n\n    this.onAnimationGroupEndObservable = new Observable();\n    /**\n     * This observable will notify when all animations have paused.\n     */\n\n    this.onAnimationGroupPauseObservable = new Observable();\n    /**\n     * This observable will notify when all animations are playing.\n     */\n\n    this.onAnimationGroupPlayObservable = new Observable();\n    /**\n     * Gets or sets an object used to store user defined information for the node\n     */\n\n    this.metadata = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.uniqueId = this._scene.getUniqueId();\n\n    this._scene.addAnimationGroup(this);\n  }\n\n  Object.defineProperty(AnimationGroup.prototype, \"from\", {\n    /**\n     * Gets the first frame\n     */\n    get: function get() {\n      return this._from;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"to\", {\n    /**\n     * Gets the last frame\n     */\n    get: function get() {\n      return this._to;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isStarted\", {\n    /**\n     * Define if the animations are started\n     */\n    get: function get() {\n      return this._isStarted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isPlaying\", {\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get: function get() {\n      return this._isStarted && !this._isPaused;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"speedRatio\", {\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get: function get() {\n      return this._speedRatio;\n    },\n\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set: function set(value) {\n      if (this._speedRatio === value) {\n        return;\n      }\n\n      this._speedRatio = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.speedRatio = this._speedRatio;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"loopAnimation\", {\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get: function get() {\n      return this._loopAnimation;\n    },\n    set: function set(value) {\n      if (this._loopAnimation === value) {\n        return;\n      }\n\n      this._loopAnimation = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.loopAnimation = this._loopAnimation;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isAdditive\", {\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get: function get() {\n      return this._isAdditive;\n    },\n    set: function set(value) {\n      if (this._isAdditive === value) {\n        return;\n      }\n\n      this._isAdditive = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.isAdditive = this._isAdditive;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"targetedAnimations\", {\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get: function get() {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"animatables\", {\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get: function get() {\n      return this._animatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"children\", {\n    /**\n     * Gets the list of target animations\n     */\n    get: function get() {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Add an animation (with its target) in the group\n   * @param animation defines the animation we want to add\n   * @param target defines the target of the animation\n   * @returns the TargetedAnimation object\n   */\n\n  AnimationGroup.prototype.addTargetedAnimation = function (animation, target) {\n    var targetedAnimation = new TargetedAnimation();\n    targetedAnimation.animation = animation;\n    targetedAnimation.target = target;\n    var keys = animation.getKeys();\n\n    if (this._from > keys[0].frame) {\n      this._from = keys[0].frame;\n    }\n\n    if (this._to < keys[keys.length - 1].frame) {\n      this._to = keys[keys.length - 1].frame;\n    }\n\n    this._targetedAnimations.push(targetedAnimation);\n\n    return targetedAnimation;\n  };\n  /**\n   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n   * It can add constant keys at begin or end\n   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.normalize = function (beginFrame, endFrame) {\n    if (beginFrame === void 0) {\n      beginFrame = null;\n    }\n\n    if (endFrame === void 0) {\n      endFrame = null;\n    }\n\n    if (beginFrame == null) {\n      beginFrame = this._from;\n    }\n\n    if (endFrame == null) {\n      endFrame = this._to;\n    }\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      var targetedAnimation = this._targetedAnimations[index];\n      var keys = targetedAnimation.animation.getKeys();\n      var startKey = keys[0];\n      var endKey = keys[keys.length - 1];\n\n      if (startKey.frame > beginFrame) {\n        var newKey = {\n          frame: beginFrame,\n          value: startKey.value,\n          inTangent: startKey.inTangent,\n          outTangent: startKey.outTangent,\n          interpolation: startKey.interpolation\n        };\n        keys.splice(0, 0, newKey);\n      }\n\n      if (endKey.frame < endFrame) {\n        var newKey = {\n          frame: endFrame,\n          value: endKey.value,\n          inTangent: endKey.inTangent,\n          outTangent: endKey.outTangent,\n          interpolation: endKey.interpolation\n        };\n        keys.push(newKey);\n      }\n    }\n\n    this._from = beginFrame;\n    this._to = endFrame;\n    return this;\n  };\n\n  AnimationGroup.prototype._processLoop = function (animatable, targetedAnimation, index) {\n    var _this = this;\n\n    animatable.onAnimationLoop = function () {\n      _this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n\n      if (_this._animationLoopFlags[index]) {\n        return;\n      }\n\n      _this._animationLoopFlags[index] = true;\n      _this._animationLoopCount++;\n\n      if (_this._animationLoopCount === _this._targetedAnimations.length) {\n        _this.onAnimationGroupLoopObservable.notifyObservers(_this);\n\n        _this._animationLoopCount = 0;\n        _this._animationLoopFlags = [];\n      }\n    };\n  };\n  /**\n   * Start all animations on given targets\n   * @param loop defines if animations must loop\n   * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n   * @param from defines the from key (optional)\n   * @param to defines the to key (optional)\n   * @param isAdditive defines the additive state for the resulting animatables (optional)\n   * @returns the current animation group\n   */\n\n\n  AnimationGroup.prototype.start = function (loop, speedRatio, from, to, isAdditive) {\n    var _this = this;\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1;\n    }\n\n    if (this._isStarted || this._targetedAnimations.length === 0) {\n      return this;\n    }\n\n    this._loopAnimation = loop;\n    this._animationLoopCount = 0;\n    this._animationLoopFlags = [];\n\n    var _loop_1 = function _loop_1(index) {\n      var targetedAnimation = this_1._targetedAnimations[index];\n\n      var animatable = this_1._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this_1._from, to !== undefined ? to : this_1._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this_1._isAdditive);\n\n      animatable.onAnimationEnd = function () {\n        _this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n\n        _this._checkAnimationGroupEnded(animatable);\n      };\n\n      this_1._processLoop(animatable, targetedAnimation, index);\n\n      this_1._animatables.push(animatable);\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      _loop_1(index);\n    }\n\n    this._speedRatio = speedRatio;\n    this._isStarted = true;\n    this._isPaused = false;\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\n   * Pause all animations\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.pause = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    this._isPaused = true;\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.pause();\n    }\n\n    this.onAnimationGroupPauseObservable.notifyObservers(this);\n    return this;\n  };\n  /**\n   * Play all animations to initial state\n   * This function will start() the animations if they were not started or will restart() them if they were paused\n   * @param loop defines if animations must loop\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.play = function (loop) {\n    // only if all animatables are ready and exist\n    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n      if (loop !== undefined) {\n        this.loopAnimation = loop;\n      }\n\n      this.restart();\n    } else {\n      this.stop();\n      this.start(loop, this._speedRatio);\n    }\n\n    this._isPaused = false;\n    return this;\n  };\n  /**\n   * Reset all animations to initial state\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.reset = function () {\n    if (!this._isStarted) {\n      this.play();\n      this.goToFrame(0);\n      this.stop();\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.reset();\n    }\n\n    return this;\n  };\n  /**\n   * Restart animations from key 0\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.restart = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.restart();\n    }\n\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\n   * Stop all animations\n   * @returns the animation group\n   */\n\n\n  AnimationGroup.prototype.stop = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    var list = this._animatables.slice();\n\n    for (var index = 0; index < list.length; index++) {\n      list[index].stop();\n    }\n\n    this._isStarted = false;\n    return this;\n  };\n  /**\n   * Set animation weight for all animatables\n   * @param weight defines the weight to use\n   * @return the animationGroup\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\n   */\n\n\n  AnimationGroup.prototype.setWeightForAllAnimatables = function (weight) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.weight = weight;\n    }\n\n    return this;\n  };\n  /**\n   * Synchronize and normalize all animatables with a source animatable\n   * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n   * @return the animationGroup\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\n   */\n\n\n  AnimationGroup.prototype.syncAllAnimationsWith = function (root) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.syncWith(root);\n    }\n\n    return this;\n  };\n  /**\n   * Goes to a specific frame in this animation group\n   * @param frame the frame number to go to\n   * @return the animationGroup\n   */\n\n\n  AnimationGroup.prototype.goToFrame = function (frame) {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.goToFrame(frame);\n    }\n\n    return this;\n  };\n  /**\n   * Dispose all associated resources\n   */\n\n\n  AnimationGroup.prototype.dispose = function () {\n    this._targetedAnimations = [];\n    this._animatables = []; // Remove from scene\n\n    var index = this._scene.animationGroups.indexOf(this);\n\n    if (index > -1) {\n      this._scene.animationGroups.splice(index, 1);\n    }\n\n    if (this._parentContainer) {\n      var index_1 = this._parentContainer.animationGroups.indexOf(this);\n\n      if (index_1 > -1) {\n        this._parentContainer.animationGroups.splice(index_1, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    this.onAnimationEndObservable.clear();\n    this.onAnimationGroupEndObservable.clear();\n    this.onAnimationGroupPauseObservable.clear();\n    this.onAnimationGroupPlayObservable.clear();\n    this.onAnimationLoopObservable.clear();\n    this.onAnimationGroupLoopObservable.clear();\n  };\n\n  AnimationGroup.prototype._checkAnimationGroupEnded = function (animatable) {\n    // animatable should be taken out of the array\n    var idx = this._animatables.indexOf(animatable);\n\n    if (idx > -1) {\n      this._animatables.splice(idx, 1);\n    } // all animatables were removed? animation group ended!\n\n\n    if (this._animatables.length === 0) {\n      this._isStarted = false;\n      this.onAnimationGroupEndObservable.notifyObservers(this);\n    }\n  };\n  /**\n   * Clone the current animation group and returns a copy\n   * @param newName defines the name of the new group\n   * @param targetConverter defines an optional function used to convert current animation targets to new ones\n   * @param cloneAnimations defines if the animations should be cloned or referenced\n   * @returns the new animation group\n   */\n\n\n  AnimationGroup.prototype.clone = function (newName, targetConverter, cloneAnimations) {\n    if (cloneAnimations === void 0) {\n      cloneAnimations = false;\n    }\n\n    var newGroup = new AnimationGroup(newName || this.name, this._scene);\n\n    for (var _i = 0, _a = this._targetedAnimations; _i < _a.length; _i++) {\n      var targetAnimation = _a[_i];\n      newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n    }\n\n    return newGroup;\n  };\n  /**\n   * Serializes the animationGroup to an object\n   * @returns Serialized object\n   */\n\n\n  AnimationGroup.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.from = this.from;\n    serializationObject.to = this.to;\n    serializationObject.targetedAnimations = [];\n\n    for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n      var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n    }\n\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    } // Metadata\n\n\n    if (this.metadata) {\n      serializationObject.metadata = this.metadata;\n    }\n\n    return serializationObject;\n  }; // Statics\n\n  /**\n   * Returns a new AnimationGroup object parsed from the source provided.\n   * @param parsedAnimationGroup defines the source\n   * @param scene defines the scene that will receive the animationGroup\n   * @returns a new AnimationGroup\n   */\n\n\n  AnimationGroup.Parse = function (parsedAnimationGroup, scene) {\n    var animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\n\n    for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n      var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n      var animation = Animation.Parse(targetedAnimation.animation);\n      var id = targetedAnimation.targetId;\n\n      if (targetedAnimation.animation.property === \"influence\") {\n        // morph target animation\n        var morphTarget = scene.getMorphTargetById(id);\n\n        if (morphTarget) {\n          animationGroup.addTargetedAnimation(animation, morphTarget);\n        }\n      } else {\n        var targetNode = scene.getNodeById(id);\n\n        if (targetNode != null) {\n          animationGroup.addTargetedAnimation(animation, targetNode);\n        }\n      }\n    }\n\n    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n    }\n\n    if (Tags) {\n      Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n    }\n\n    if (parsedAnimationGroup.metadata !== undefined) {\n      animationGroup.metadata = parsedAnimationGroup.metadata;\n    }\n\n    return animationGroup;\n  };\n  /**\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\n   * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\n   * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\n   * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\n   * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\n   */\n\n\n  AnimationGroup.MakeAnimationAdditive = function (sourceAnimationGroup, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animationGroup = sourceAnimationGroup;\n\n    if (cloneOriginal) {\n      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\n    }\n\n    var targetedAnimations = animationGroup.targetedAnimations;\n\n    for (var index = 0; index < targetedAnimations.length; index++) {\n      var targetedAnimation = targetedAnimations[index];\n      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\n    }\n\n    animationGroup.isAdditive = true;\n    return animationGroup;\n  };\n  /**\n   * Returns the string \"AnimationGroup\"\n   * @returns \"AnimationGroup\"\n   */\n\n\n  AnimationGroup.prototype.getClassName = function () {\n    return \"AnimationGroup\";\n  };\n  /**\n   * Creates a detailed string about the object\n   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n   * @returns a string representing the object\n   */\n\n\n  AnimationGroup.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n\n    if (fullDetails) {\n      ret += \", from: \" + this._from;\n      ret += \", to: \" + this._to;\n      ret += \", isStarted: \" + this._isStarted;\n      ret += \", speedRatio: \" + this._speedRatio;\n      ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n      ret += \", animatables length: \" + this._animatables;\n    }\n\n    return ret;\n  };\n\n  return AnimationGroup;\n}();\n\nexport { AnimationGroup };","map":{"version":3,"mappings":"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","names":["Animation","Observable","EngineStore","Tags","TargetedAnimation","serializationObject","animation","serialize","targetId","target","id","name","scene","Array","Number","MAX_VALUE","_scene","LastCreatedScene","uniqueId","getUniqueId","addAnimationGroup","Object","AnimationGroup","_from","_to","_isStarted","_isPaused","_speedRatio","value","index","_animatables","length","animatable","speedRatio","_loopAnimation","loopAnimation","_isAdditive","isAdditive","_targetedAnimations","targetedAnimation","keys","getKeys","frame","push","beginFrame","endFrame","startKey","endKey","newKey","inTangent","outTangent","interpolation","splice","onAnimationLoop","_this","onAnimationLoopObservable","notifyObservers","_animationLoopFlags","_animationLoopCount","onAnimationGroupLoopObservable","loop","from","to","this_1","beginDirectAnimation","undefined","onAnimationEnd","onAnimationEndObservable","_checkAnimationGroupEnded","_processLoop","onAnimationGroupPlayObservable","pause","onAnimationGroupPauseObservable","isStarted","restart","stop","start","play","goToFrame","reset","list","slice","weight","root","syncWith","animationGroups","indexOf","_parentContainer","index_1","clear","onAnimationGroupEndObservable","idx","newName","targetConverter","cloneAnimations","newGroup","_i","targetAnimation","addTargetedAnimation","clone","targetedAnimations","targetedAnimationIndex","HasTags","tags","GetTags","metadata","parsedAnimationGroup","animationGroup","i","Parse","property","morphTarget","getMorphTargetById","targetNode","getNodeById","normalize","AddTagsTo","sourceAnimationGroup","referenceFrame","range","cloneOriginal","clonedName","MakeAnimationAdditive","fullDetails","ret","getClassName"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Animations/animationGroup.ts"],"sourcesContent":["import type { Animatable } from \"./animatable\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { Tags } from \"../Misc/tags\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    /**\r\n     * Gets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/divingDeeper/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation();\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._targetedAnimations.length) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags = [];\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags = [];\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if all animatables are ready and exist\r\n        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        this._isPaused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop();\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from key 0\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @returns the animation group\r\n     */\r\n    public stop(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop();\r\n        }\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     * @param weight defines the weight to use\r\n     * @return the animationGroup\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @return the animationGroup\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group\r\n     * @param frame the frame number to go to\r\n     * @return the animationGroup\r\n     */\r\n    public goToFrame(frame: number): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._targetedAnimations = [];\r\n        this._animatables = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === 0) {\r\n            this._isStarted = false;\r\n            this.onAnimationGroupEndObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene);\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): AnimationGroup {\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (cloneOriginal) {\r\n            animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}