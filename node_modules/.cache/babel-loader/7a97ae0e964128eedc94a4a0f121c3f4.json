{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager.js\";\nNode.AddNodeConstructor(\"FollowCamera\", function (name, scene) {\n  return function () {\n    return new FollowCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", function (name, scene) {\n  return function () {\n    return new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n  };\n});\n/**\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\n * an arc rotate version arcFollowCamera are available.\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\n */\n\nvar FollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(FollowCamera, _super);\n  /**\n   * Instantiates the follow camera.\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the position of the camera\n   * @param scene Define the scene the camera belong to\n   * @param lockedTarget Define the target of the camera\n   */\n\n\n  function FollowCamera(name, position, scene, lockedTarget) {\n    if (lockedTarget === void 0) {\n      lockedTarget = null;\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n    /**\n     * Distance the follow camera should follow an object at\n     */\n\n\n    _this.radius = 12;\n    /**\n     * Minimum allowed distance of the camera to the axis of rotation\n     * (The camera can not get closer).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.lowerRadiusLimit = null;\n    /**\n     * Maximum allowed distance of the camera to the axis of rotation\n     * (The camera can not get further).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.upperRadiusLimit = null;\n    /**\n     * Define a rotation offset between the camera and the object it follows\n     */\n\n    _this.rotationOffset = 0;\n    /**\n     * Minimum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.lowerRotationOffsetLimit = null;\n    /**\n     * Maximum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.upperRotationOffsetLimit = null;\n    /**\n     * Define a height offset between the camera and the object it follows.\n     * It can help following an object from the top (like a car chasing a plane)\n     */\n\n    _this.heightOffset = 4;\n    /**\n     * Minimum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.lowerHeightOffsetLimit = null;\n    /**\n     * Maximum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n\n    _this.upperHeightOffsetLimit = null;\n    /**\n     * Define how fast the camera can accelerate to follow it s target.\n     */\n\n    _this.cameraAcceleration = 0.05;\n    /**\n     * Define the speed limit of the camera following an object.\n     */\n\n    _this.maxCameraSpeed = 20;\n    _this.lockedTarget = lockedTarget;\n    _this.inputs = new FollowCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouseWheel().addPointers();\n\n    return _this; // Uncomment the following line when the relevant handlers have been implemented.\n    // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n  }\n\n  FollowCamera.prototype._follow = function (cameraTarget) {\n    if (!cameraTarget) {\n      return;\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\n    var yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n    var radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n    var targetPosition = cameraTarget.getAbsolutePosition();\n    var targetX = targetPosition.x + Math.sin(radians) * this.radius;\n    var targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n    var dx = targetX - this.position.x;\n    var dy = targetPosition.y + this.heightOffset - this.position.y;\n    var dz = targetZ - this.position.z;\n    var vx = dx * this.cameraAcceleration * 2; //this is set to .05\n\n    var vy = dy * this.cameraAcceleration;\n    var vz = dz * this.cameraAcceleration * 2;\n\n    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n    this.setTarget(targetPosition);\n  };\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n\n\n  FollowCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n\n    this._reset = function () {};\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  FollowCamera.prototype.detachControl = function () {\n    this.inputs.detachElement();\n\n    if (this._reset) {\n      this._reset();\n    }\n  };\n  /** @hidden */\n\n\n  FollowCamera.prototype._checkInputs = function () {\n    this.inputs.checkInputs();\n\n    this._checkLimits();\n\n    _super.prototype._checkInputs.call(this);\n\n    if (this.lockedTarget) {\n      this._follow(this.lockedTarget);\n    }\n  };\n\n  FollowCamera.prototype._checkLimits = function () {\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n    }\n\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n    }\n\n    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n      this.heightOffset = this.lowerHeightOffsetLimit;\n    }\n\n    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n      this.heightOffset = this.upperHeightOffsetLimit;\n    }\n\n    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n      this.rotationOffset = this.lowerRotationOffsetLimit;\n    }\n\n    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n      this.rotationOffset = this.upperRotationOffsetLimit;\n    }\n  };\n  /**\n   * Gets the camera class name.\n   * @returns the class name\n   */\n\n\n  FollowCamera.prototype.getClassName = function () {\n    return \"FollowCamera\";\n  };\n\n  __decorate([serialize()], FollowCamera.prototype, \"radius\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"rotationOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"heightOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], FollowCamera.prototype, \"lockedTarget\", void 0);\n\n  return FollowCamera;\n}(TargetCamera);\n\nexport { FollowCamera };\n/**\n * Arc Rotate version of the follow camera.\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\n */\n\nvar ArcFollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(ArcFollowCamera, _super);\n  /**\n   * Instantiates a new ArcFollowCamera\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\n   * @param name Define the name of the camera\n   * @param alpha Define the rotation angle of the camera around the longitudinal axis\n   * @param beta Define the rotation angle of the camera around the elevation axis\n   * @param radius Define the radius of the camera from its target point\n   * @param target Define the target of the camera\n   * @param scene Define the scene the camera belongs to\n   */\n\n\n  function ArcFollowCamera(name,\n  /** The longitudinal angle of the camera */\n  alpha,\n  /** The latitudinal angle of the camera */\n  beta,\n  /** The radius of the camera from its target */\n  radius,\n  /** Define the camera target (the mesh it should follow) */\n  target, scene) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this.alpha = alpha;\n    _this.beta = beta;\n    _this.radius = radius;\n    _this._cartesianCoordinates = Vector3.Zero();\n\n    _this.setMeshTarget(target);\n\n    return _this;\n  }\n  /**\n   * Sets the mesh to follow with this camera.\n   * @param target the target to follow\n   */\n\n\n  ArcFollowCamera.prototype.setMeshTarget = function (target) {\n    this._meshTarget = target;\n\n    this._follow();\n  };\n\n  ArcFollowCamera.prototype._follow = function () {\n    if (!this._meshTarget) {\n      return;\n    }\n\n    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n\n    var targetPosition = this._meshTarget.getAbsolutePosition();\n\n    this.position = targetPosition.add(this._cartesianCoordinates);\n    this.setTarget(targetPosition);\n  };\n  /** @hidden */\n\n\n  ArcFollowCamera.prototype._checkInputs = function () {\n    _super.prototype._checkInputs.call(this);\n\n    this._follow();\n  };\n  /**\n   * Returns the class name of the object.\n   * It is mostly used internally for serialization purposes.\n   */\n\n\n  ArcFollowCamera.prototype.getClassName = function () {\n    return \"ArcFollowCamera\";\n  };\n\n  return ArcFollowCamera;\n}(TargetCamera);\n\nexport { ArcFollowCamera };","map":{"version":3,"mappings":"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","names":["serialize","serializeAsMeshReference","Tools","TargetCamera","TmpVectors","Vector3","Node","FollowCameraInputsManager","AddNodeConstructor","name","scene","FollowCamera","Zero","ArcFollowCamera","__extends","position","lockedTarget","_super","_this","inputs","addKeyboard","addMouseWheel","addPointers","cameraTarget","rotMatrix","Matrix","absoluteRotationQuaternion","toRotationMatrix","yRotation","Math","atan2","m","radians","ToRadians","rotationOffset","targetPosition","getAbsolutePosition","targetX","x","sin","radius","targetZ","z","cos","dx","dy","y","heightOffset","dz","vx","cameraAcceleration","vy","vz","maxCameraSpeed","setTarget","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","_reset","detachElement","checkInputs","_checkLimits","_checkInputs","call","_follow","lowerRadiusLimit","upperRadiusLimit","lowerHeightOffsetLimit","upperHeightOffsetLimit","lowerRotationOffsetLimit","upperRotationOffsetLimit","__decorate","alpha","beta","target","setMeshTarget","_meshTarget","_cartesianCoordinates","add"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/followCamera.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager\";\r\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\r\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\r\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\r\n});\r\n\r\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class FollowCamera extends TargetCamera {\r\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\r\n    @serialize()\r\n    public radius: number = 12;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\r\n    @serialize()\r\n    public rotationOffset: number = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chasing a plane)\r\n     */\r\n    @serialize()\r\n    public heightOffset: number = 4;\r\n\r\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\r\n    @serialize()\r\n    public cameraAcceleration: number = 0.05;\r\n\r\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\r\n    @serialize()\r\n    public maxCameraSpeed: number = 20;\r\n\r\n    /**\r\n     * Define the target of the camera.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the input associated with the camera.\r\n     */\r\n    public inputs: FollowCameraInputsManager;\r\n\r\n    /**\r\n     * Instantiates the follow camera.\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the position of the camera\r\n     * @param scene Define the scene the camera belong to\r\n     * @param lockedTarget Define the target of the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, lockedTarget: Nullable<AbstractMesh> = null) {\r\n        super(name, position, scene);\r\n\r\n        this.lockedTarget = lockedTarget;\r\n        this.inputs = new FollowCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        // Uncomment the following line when the relevant handlers have been implemented.\r\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\r\n    }\r\n\r\n    private _follow(cameraTarget: AbstractMesh) {\r\n        if (!cameraTarget) {\r\n            return;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\r\n        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\r\n\r\n        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\r\n        const targetPosition = cameraTarget.getAbsolutePosition();\r\n        const targetX: number = targetPosition.x + Math.sin(radians) * this.radius;\r\n\r\n        const targetZ: number = targetPosition.z + Math.cos(radians) * this.radius;\r\n        const dx: number = targetX - this.position.x;\r\n        const dy: number = targetPosition.y + this.heightOffset - this.position.y;\r\n        const dz: number = targetZ - this.position.z;\r\n        let vx: number = dx * this.cameraAcceleration * 2; //this is set to .05\r\n        let vy: number = dy * this.cameraAcceleration;\r\n        let vz: number = dz * this.cameraAcceleration * 2;\r\n\r\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\r\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\r\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\r\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {};\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        this._checkLimits();\r\n        super._checkInputs();\r\n        if (this.lockedTarget) {\r\n            this._follow(this.lockedTarget);\r\n        }\r\n    }\r\n\r\n    private _checkLimits() {\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n        }\r\n\r\n        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\r\n            this.heightOffset = this.lowerHeightOffsetLimit;\r\n        }\r\n        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\r\n            this.heightOffset = this.upperHeightOffsetLimit;\r\n        }\r\n\r\n        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\r\n            this.rotationOffset = this.lowerRotationOffsetLimit;\r\n        }\r\n        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\r\n            this.rotationOffset = this.upperRotationOffsetLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCamera\";\r\n    }\r\n}\r\n\r\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class ArcFollowCamera extends TargetCamera {\r\n    private _cartesianCoordinates: Vector3 = Vector3.Zero();\r\n\r\n    /** Define the camera target (the mesh it should follow) */\r\n    private _meshTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Instantiates a new ArcFollowCamera\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera\r\n     * @param alpha Define the rotation angle of the camera around the longitudinal axis\r\n     * @param beta Define the rotation angle of the camera around the elevation axis\r\n     * @param radius Define the radius of the camera from its target point\r\n     * @param target Define the target of the camera\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(\r\n        name: string,\r\n        /** The longitudinal angle of the camera */\r\n        public alpha: number,\r\n        /** The latitudinal angle of the camera */\r\n        public beta: number,\r\n        /** The radius of the camera from its target */\r\n        public radius: number,\r\n        /** Define the camera target (the mesh it should follow) */\r\n        target: Nullable<AbstractMesh>,\r\n        scene: Scene\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this.setMeshTarget(target);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to follow with this camera.\r\n     * @param target the target to follow\r\n     */\r\n    public setMeshTarget(target: Nullable<AbstractMesh>) {\r\n        this._meshTarget = target;\r\n        this._follow();\r\n    }\r\n\r\n    private _follow(): void {\r\n        if (!this._meshTarget) {\r\n            return;\r\n        }\r\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\r\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\r\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\r\n\r\n        const targetPosition = this._meshTarget.getAbsolutePosition();\r\n        this.position = targetPosition.add(this._cartesianCoordinates);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._follow();\r\n    }\r\n\r\n    /**\r\n     * Returns the class name of the object.\r\n     * It is mostly used internally for serialization purposes.\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcFollowCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}