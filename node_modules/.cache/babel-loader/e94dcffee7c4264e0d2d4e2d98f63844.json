{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { Tools } from \"./tools.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/**\n * Info about the .basis files\n */\n\nvar BasisFileInfo =\n/** @class */\nfunction () {\n  function BasisFileInfo() {}\n\n  return BasisFileInfo;\n}();\n/**\n * Result of transcoding a basis file\n */\n\n\nvar TranscodeResult =\n/** @class */\nfunction () {\n  function TranscodeResult() {}\n\n  return TranscodeResult;\n}();\n/**\n * Configuration options for the Basis transcoder\n */\n\n\nvar BasisTranscodeConfiguration =\n/** @class */\nfunction () {\n  function BasisTranscodeConfiguration() {}\n\n  return BasisTranscodeConfiguration;\n}();\n\nexport { BasisTranscodeConfiguration };\n/**\n * @hidden\n * Enum of basis transcoder formats\n */\n\nvar BASIS_FORMATS;\n\n(function (BASIS_FORMATS) {\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 1] = \"cTFBC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 2] = \"cTFBC4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_OPAQUE_ONLY\"] = 3] = \"cTFPVRTC1_4_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7_M6_OPAQUE_ONLY\"] = 4] = \"cTFBC7_M6_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 5] = \"cTFETC2\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 6] = \"cTFBC3\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 7] = \"cTFBC5\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\n\n\nexport var BasisToolsOptions = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js\",\n\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm\"\n};\n/**\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\n * @param engine\n * @returns internal format corresponding to the Basis format\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nexport var GetInternalFormatFromBasisFormat = function GetInternalFormatFromBasisFormat(basisFormat, engine) {\n  var format;\n\n  switch (basisFormat) {\n    case BASIS_FORMATS.cTFETC1:\n      format = 36196;\n      break;\n\n    case BASIS_FORMATS.cTFBC1:\n      format = 33776;\n      break;\n\n    case BASIS_FORMATS.cTFBC4:\n      format = 33779;\n      break;\n  }\n\n  if (format === undefined) {\n    throw \"The chosen Basis transcoder format is not currently supported\";\n  }\n\n  return format;\n};\nvar _WorkerPromise = null;\nvar _Worker = null;\nvar _actionId = 0;\nvar _IgnoreSupportedFormats = false;\n\nvar _CreateWorkerAsync = function _CreateWorkerAsync() {\n  if (!_WorkerPromise) {\n    _WorkerPromise = new Promise(function (res, reject) {\n      if (_Worker) {\n        res(_Worker);\n      } else {\n        Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL).then(function (wasmBinary) {\n          var workerBlobUrl = URL.createObjectURL(new Blob([\"(\".concat(workerFunc, \")()\")], {\n            type: \"application/javascript\"\n          }));\n          _Worker = new Worker(workerBlobUrl);\n\n          var initHandler = function initHandler(msg) {\n            if (msg.data.action === \"init\") {\n              _Worker.removeEventListener(\"message\", initHandler);\n\n              res(_Worker);\n            } else if (msg.data.action === \"error\") {\n              reject(msg.data.error || \"error initializing worker\");\n            }\n          };\n\n          _Worker.addEventListener(\"message\", initHandler);\n\n          _Worker.postMessage({\n            action: \"init\",\n            url: BasisToolsOptions.JSModuleURL,\n            wasmBinary: wasmBinary\n          });\n        })[\"catch\"](reject);\n      }\n    });\n  }\n\n  return _WorkerPromise;\n};\n/**\n * Transcodes a loaded image file to compressed pixel data\n * @param data image data to transcode\n * @param config configuration options for the transcoding\n * @returns a promise resulting in the transcoded image\n */\n\n\nexport var TranscodeAsync = function TranscodeAsync(data, config) {\n  var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n  return new Promise(function (res, rej) {\n    _CreateWorkerAsync().then(function () {\n      var actionId = _actionId++;\n\n      var messageHandler = function messageHandler(msg) {\n        if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n          _Worker.removeEventListener(\"message\", messageHandler);\n\n          if (!msg.data.success) {\n            rej(\"Transcode is not supported on this device\");\n          } else {\n            res(msg.data);\n          }\n        }\n      };\n\n      _Worker.addEventListener(\"message\", messageHandler);\n\n      var dataViewCopy = new Uint8Array(dataView.byteLength);\n      dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n\n      _Worker.postMessage({\n        action: \"transcode\",\n        id: actionId,\n        imageData: dataViewCopy,\n        config: config,\n        ignoreSupportedFormats: _IgnoreSupportedFormats\n      }, [dataViewCopy.buffer]);\n    }, function (error) {\n      rej(error);\n    });\n  });\n};\n/**\n * Loads a texture from the transcode result\n * @param texture texture load to\n * @param transcodeResult the result of transcoding the basis file to load from\n */\n\nexport var LoadTextureFromTranscodeResult = function LoadTextureFromTranscodeResult(texture, transcodeResult) {\n  var engine = texture.getEngine();\n\n  var _loop_1 = function _loop_1(i) {\n    var rootImage = transcodeResult.fileInfo.images[i].levels[0];\n    texture._invertVScale = texture.invertY;\n\n    if (transcodeResult.format === -1) {\n      // No compatable compressed format found, fallback to RGB\n      texture.type = 10;\n      texture.format = 4;\n\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n        // Create non power of two texture\n        var source_1 = new InternalTexture(engine, InternalTextureSource.Temp);\n        texture._invertVScale = texture.invertY;\n        source_1.type = 10;\n        source_1.format = 4; // Fallback requires aligned width/height\n\n        source_1.width = rootImage.width + 3 & ~3;\n        source_1.height = rootImage.height + 3 & ~3;\n\n        engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source_1, true);\n\n        engine._uploadDataToTextureDirectly(source_1, rootImage.transcodedPixels, i, 0, 4, true); // Resize to power of two\n\n\n        engine._rescaleTexture(source_1, texture, engine.scenes[0], engine._getInternalFormat(4), function () {\n          engine._releaseTexture(source_1);\n\n          engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);\n        });\n      } else {\n        // Fallback is already inverted\n        texture._invertVScale = !texture.invertY; // Upload directly\n\n        texture.width = rootImage.width + 3 & ~3;\n        texture.height = rootImage.height + 3 & ~3;\n\n        engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, 4, true);\n      }\n    } else {\n      texture.width = rootImage.width;\n      texture.height = rootImage.height;\n      texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1; // Upload all mip levels in the file\n\n      transcodeResult.fileInfo.images[i].levels.forEach(function (level, index) {\n        engine._uploadCompressedDataToTextureDirectly(texture, BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine), level.width, level.height, level.transcodedPixels, i, index);\n      });\n\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n        Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n        texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n        texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n      }\n    }\n  };\n\n  for (var i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n    _loop_1(i);\n  }\n};\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\n\nexport var BasisTools = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: BasisToolsOptions.JSModuleURL,\n\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: BasisToolsOptions.WasmModuleURL,\n\n  /**\n   * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n   * @param basisFormat format chosen from GetSupportedTranscodeFormat\n   * @returns internal format corresponding to the Basis format\n   */\n  GetInternalFormatFromBasisFormat: GetInternalFormatFromBasisFormat,\n\n  /**\n   * Transcodes a loaded image file to compressed pixel data\n   * @param data image data to transcode\n   * @param config configuration options for the transcoding\n   * @returns a promise resulting in the transcoded image\n   */\n  TranscodeAsync: TranscodeAsync,\n\n  /**\n   * Loads a texture from the transcode result\n   * @param texture texture load to\n   * @param transcodeResult the result of transcoding the basis file to load from\n   */\n  LoadTextureFromTranscodeResult: LoadTextureFromTranscodeResult\n};\n\nfunction workerFunc() {\n  var _BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFBC1: 1,\n    cTFBC4: 2,\n    cTFPVRTC1_4_OPAQUE_ONLY: 3,\n    cTFBC7_M6_OPAQUE_ONLY: 4,\n    cTFETC2: 5,\n    cTFBC3: 6,\n    cTFBC5: 7\n  };\n  var transcoderModulePromise = null;\n\n  onmessage = function onmessage(event) {\n    if (event.data.action === \"init\") {\n      // Load the transcoder if it hasn't been yet\n      if (!transcoderModulePromise) {\n        // Override wasm binary\n        Module = {\n          wasmBinary: event.data.wasmBinary\n        }; // make sure we loaded the script correctly\n\n        try {\n          importScripts(event.data.url);\n        } catch (e) {\n          postMessage({\n            action: \"error\",\n            error: e\n          });\n        }\n\n        transcoderModulePromise = new Promise(function (res) {\n          Module.onRuntimeInitialized = function () {\n            Module.initializeBasis();\n            res();\n          };\n        });\n      }\n\n      transcoderModulePromise.then(function () {\n        postMessage({\n          action: \"init\"\n        });\n      });\n    } else if (event.data.action === \"transcode\") {\n      // Transcode the basis image and return the resulting pixels\n      var config = event.data.config;\n      var imgData = event.data.imageData;\n      var loadedFile = new Module.BasisFile(imgData);\n      var fileInfo = GetFileInfo(loadedFile);\n      var format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n      var needsConversion = false;\n\n      if (format === null) {\n        needsConversion = true;\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } // Begin transcode\n\n\n      var success = true;\n\n      if (!loadedFile.startTranscoding()) {\n        success = false;\n      }\n\n      var buffers = [];\n\n      for (var imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n        if (!success) {\n          break;\n        }\n\n        var image = fileInfo.images[imageIndex];\n\n        if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n          var mipCount = image.levels.length;\n\n          if (config.loadMipmapLevels === false) {\n            mipCount = 1;\n          }\n\n          for (var levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n            var levelInfo = image.levels[levelIndex];\n            var pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n\n            if (!pixels) {\n              success = false;\n              break;\n            }\n\n            levelInfo.transcodedPixels = pixels;\n            buffers.push(levelInfo.transcodedPixels.buffer);\n          }\n        }\n      } // Close file\n\n\n      loadedFile.close();\n      loadedFile[\"delete\"]();\n\n      if (needsConversion) {\n        format = -1;\n      }\n\n      if (!success) {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id\n        });\n      } else {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id,\n          fileInfo: fileInfo,\n          format: format\n        }, buffers);\n      }\n    }\n  };\n  /**\n   * Detects the supported transcode format for the file\n   * @param config transcode config\n   * @param fileInfo info about the file\n   * @returns the chosed format or null if none are supported\n   */\n\n\n  function GetSupportedTranscodeFormat(config, fileInfo) {\n    var format = null;\n\n    if (config.supportedCompressionFormats) {\n      if (config.supportedCompressionFormats.etc1) {\n        format = _BASIS_FORMAT.cTFETC1;\n      } else if (config.supportedCompressionFormats.s3tc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } else if (config.supportedCompressionFormats.pvrtc) {// TODO uncomment this after pvrtc bug is fixed is basis transcoder\n        // See discussion here: https://github.com/mrdoob/three.js/issues/16524#issuecomment-498929924\n        // format = _BASIS_FORMAT.cTFPVRTC1_4_OPAQUE_ONLY;\n      } else if (config.supportedCompressionFormats.etc2) {\n        format = _BASIS_FORMAT.cTFETC2;\n      }\n    }\n\n    return format;\n  }\n  /**\n   * Retrieves information about the basis file eg. dimensions\n   * @param basisFile the basis file to get the info from\n   * @returns information about the basis file\n   */\n\n\n  function GetFileInfo(basisFile) {\n    var hasAlpha = basisFile.getHasAlpha();\n    var imageCount = basisFile.getNumImages();\n    var images = [];\n\n    for (var i = 0; i < imageCount; i++) {\n      var imageInfo = {\n        levels: []\n      };\n      var levelCount = basisFile.getNumLevels(i);\n\n      for (var level = 0; level < levelCount; level++) {\n        var levelInfo = {\n          width: basisFile.getImageWidth(i, level),\n          height: basisFile.getImageHeight(i, level)\n        };\n        imageInfo.levels.push(levelInfo);\n      }\n\n      images.push(imageInfo);\n    }\n\n    var info = {\n      hasAlpha: hasAlpha,\n      images: images\n    };\n    return info;\n  }\n\n  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n    var dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n    var dst = new Uint8Array(dstSize);\n\n    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n      return null;\n    } // If no supported format is found, load as dxt and convert to rgb565\n\n\n    if (convertToRgb565) {\n      var alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;\n      var alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;\n      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n    }\n\n    return dst;\n  }\n  /**\n   * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\n   * An unoptimized version of dxtToRgb565.  Also, the floating\n   * point math used to compute the colors actually results in\n   * slightly different colors compared to hardware DXT decoders.\n   * @param src dxt src pixels\n   * @param srcByteOffset offset for the start of src\n   * @param  width aligned width of the image\n   * @param  height aligned height of the image\n   * @return the converted pixels\n   */\n\n\n  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n    var c = new Uint16Array(4);\n    var dst = new Uint16Array(width * height);\n    var blockWidth = width / 4;\n    var blockHeight = height / 4;\n\n    for (var blockY = 0; blockY < blockHeight; blockY++) {\n      for (var blockX = 0; blockX < blockWidth; blockX++) {\n        var i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n        c[0] = src[i] | src[i + 1] << 8;\n        c[1] = src[i + 2] | src[i + 3] << 8;\n        c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;\n        c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;\n\n        for (var row = 0; row < 4; row++) {\n          var m = src[i + 4 + row];\n          var dstI = (blockY * 4 + row) * width + blockX * 4;\n          dst[dstI++] = c[m & 0x3];\n          dst[dstI++] = c[m >> 2 & 0x3];\n          dst[dstI++] = c[m >> 4 & 0x3];\n          dst[dstI++] = c[m >> 6 & 0x3];\n        }\n      }\n    }\n\n    return dst;\n  }\n}\n\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\n  get: function get() {\n    return BasisToolsOptions.JSModuleURL;\n  },\n  set: function set(value) {\n    BasisToolsOptions.JSModuleURL = value;\n  }\n});\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\n  get: function get() {\n    return BasisToolsOptions.WasmModuleURL;\n  },\n  set: function set(value) {\n    BasisToolsOptions.WasmModuleURL = value;\n  }\n});","map":{"version":3,"mappings":"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","names":["Tools","Texture","InternalTexture","InternalTextureSource","Scalar","BASIS_FORMATS","BasisToolsOptions","JSModuleURL","WasmModuleURL","GetInternalFormatFromBasisFormat","basisFormat","engine","format","cTFETC1","cTFBC1","cTFBC4","undefined","_WorkerPromise","_Worker","_actionId","_IgnoreSupportedFormats","_CreateWorkerAsync","Promise","res","reject","LoadFileAsync","then","wasmBinary","workerBlobUrl","URL","createObjectURL","Blob","workerFunc","type","Worker","initHandler","msg","data","action","removeEventListener","error","addEventListener","postMessage","url","TranscodeAsync","config","dataView","ArrayBuffer","Uint8Array","rej","actionId","messageHandler","id","success","dataViewCopy","byteLength","set","buffer","byteOffset","imageData","ignoreSupportedFormats","LoadTextureFromTranscodeResult","texture","transcodeResult","getEngine","i","rootImage","fileInfo","images","levels","_invertVScale","invertY","_features","basisNeedsPOT","Log2","width","height","source_1","Temp","_bindTextureDirectly","_gl","TEXTURE_2D","_uploadDataToTextureDirectly","transcodedPixels","_rescaleTexture","scenes","_getInternalFormat","_releaseTexture","generateMipMaps","length","forEach","level","index","_uploadCompressedDataToTextureDirectly","BasisTools","Warn","_cachedWrapU","CLAMP_ADDRESSMODE","_cachedWrapV","_BASIS_FORMAT","cTFPVRTC1_4_OPAQUE_ONLY","cTFBC7_M6_OPAQUE_ONLY","cTFETC2","cTFBC3","cTFBC5","transcoderModulePromise","onmessage","event","Module","importScripts","e","onRuntimeInitialized","initializeBasis","imgData","loadedFile","BasisFile","GetFileInfo","GetSupportedTranscodeFormat","needsConversion","hasAlpha","startTranscoding","buffers","imageIndex","image","loadSingleImage","mipCount","loadMipmapLevels","levelIndex","levelInfo","pixels","TranscodeLevel","push","close","supportedCompressionFormats","etc1","s3tc","pvrtc","etc2","basisFile","getHasAlpha","imageCount","getNumImages","imageInfo","levelCount","getNumLevels","getImageWidth","getImageHeight","info","convertToRgb565","dstSize","getImageTranscodedSizeInBytes","dst","transcodeImage","alignedWidth","alignedHeight","ConvertDxtToRgb565","src","srcByteOffset","c","Uint16Array","blockWidth","blockHeight","blockY","blockX","row","m","dstI","Object","defineProperty","get","value"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/basis.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nclass BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFBC1 = 1,\r\n    cTFBC4 = 2,\r\n    cTFPVRTC1_4_OPAQUE_ONLY = 3,\r\n    cTFBC7_M6_OPAQUE_ONLY = 4,\r\n    cTFETC2 = 5,\r\n    cTFBC3 = 6,\r\n    cTFBC5 = 7,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js\",\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm\",\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: Engine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL)\r\n                    .then((wasmBinary) => {\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n\r\n                        const initHandler = (msg: any) => {\r\n                            if (msg.data.action === \"init\") {\r\n                                _Worker!.removeEventListener(\"message\", initHandler);\r\n                                res(_Worker!);\r\n                            } else if (msg.data.action === \"error\") {\r\n                                reject(msg.data.error || \"error initializing worker\");\r\n                            }\r\n                        };\r\n                        _Worker.addEventListener(\"message\", initHandler);\r\n                        _Worker.postMessage({ action: \"init\", url: BasisToolsOptions.JSModuleURL, wasmBinary: wasmBinary });\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source, true);\r\n                engine._uploadDataToTextureDirectly(source, rootImage.transcodedPixels, i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(\r\n                    texture,\r\n                    BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine),\r\n                    level.width,\r\n                    level.height,\r\n                    level.transcodedPixels,\r\n                    i,\r\n                    index\r\n                );\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let Module: any;\r\nfunction workerFunc(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFBC1: 1,\r\n        cTFBC4: 2,\r\n        cTFPVRTC1_4_OPAQUE_ONLY: 3,\r\n        cTFBC7_M6_OPAQUE_ONLY: 4,\r\n        cTFETC2: 5,\r\n        cTFBC3: 6,\r\n        cTFBC5: 7,\r\n    };\r\n    let transcoderModulePromise: Nullable<Promise<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (!transcoderModulePromise) {\r\n                // Override wasm binary\r\n                Module = { wasmBinary: event.data.wasmBinary };\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n                transcoderModulePromise = new Promise<void>((res) => {\r\n                    Module.onRuntimeInitialized = () => {\r\n                        Module.initializeBasis();\r\n                        res();\r\n                    };\r\n                });\r\n            }\r\n            transcoderModulePromise.then(() => {\r\n                postMessage({ action: \"init\" });\r\n            });\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new Module.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                // TODO uncomment this after pvrtc bug is fixed is basis transcoder\r\n                // See discussion here: https://github.com/mrdoob/three.js/issues/16524#issuecomment-498929924\r\n                // format = _BASIS_FORMAT.cTFPVRTC1_4_OPAQUE_ONLY;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @return the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module"}