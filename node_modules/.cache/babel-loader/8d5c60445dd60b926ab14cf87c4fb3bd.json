{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport { __awaiter, __generator } from \"tslib\";\n/**\n * Transform some pixel data to a base64 string\n * @param pixels defines the pixel data to transform to base64\n * @param size defines the width and height of the (texture) data\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n * @returns The base64 encoded string or null\n */\n\nexport function GenerateBase64StringFromPixelData(pixels, size, invertY) {\n  if (invertY === void 0) {\n    invertY = false;\n  }\n\n  var width = size.width;\n  var height = size.height;\n\n  if (pixels instanceof Float32Array) {\n    var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\n    var npixels = new Uint8Array(len);\n\n    while (--len >= 0) {\n      var val = pixels[len];\n\n      if (val < 0) {\n        val = 0;\n      } else if (val > 1) {\n        val = 1;\n      }\n\n      npixels[len] = val * 255;\n    }\n\n    pixels = npixels;\n  }\n\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) {\n    return null;\n  }\n\n  var imageData = ctx.createImageData(width, height);\n  var castData = imageData.data;\n  castData.set(pixels);\n  ctx.putImageData(imageData, 0, 0);\n\n  if (invertY) {\n    var canvas2 = document.createElement(\"canvas\");\n    canvas2.width = width;\n    canvas2.height = height;\n    var ctx2 = canvas2.getContext(\"2d\");\n\n    if (!ctx2) {\n      return null;\n    }\n\n    ctx2.translate(0, height);\n    ctx2.scale(1, -1);\n    ctx2.drawImage(canvas, 0, 0);\n    return canvas2.toDataURL(\"image/png\");\n  }\n\n  return canvas.toDataURL(\"image/png\");\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null\n */\n\nexport function GenerateBase64StringFromTexture(texture, faceIndex, level) {\n  if (faceIndex === void 0) {\n    faceIndex = 0;\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  var internalTexture = texture.getInternalTexture();\n\n  if (!internalTexture) {\n    return null;\n  }\n\n  var pixels = texture._readPixelsSync(faceIndex, level);\n\n  if (!pixels) {\n    return null;\n  }\n\n  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null wrapped in a promise\n */\n\nexport function GenerateBase64StringFromTextureAsync(texture, faceIndex, level) {\n  if (faceIndex === void 0) {\n    faceIndex = 0;\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var internalTexture, pixels;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          internalTexture = texture.getInternalTexture();\n\n          if (!internalTexture) {\n            return [2\n            /*return*/\n            , null];\n          }\n\n          return [4\n          /*yield*/\n          , texture.readPixels(faceIndex, level)];\n\n        case 1:\n          pixels = _a.sent();\n\n          if (!pixels) {\n            return [2\n            /*return*/\n            , null];\n          }\n\n          return [2\n          /*return*/\n          , GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY)];\n      }\n    });\n  });\n}\n/**\n * Class used to host copy specific utilities\n * (Back-compat)\n */\n\nexport var CopyTools = {\n  /**\n   * Transform some pixel data to a base64 string\n   * @param pixels defines the pixel data to transform to base64\n   * @param size defines the width and height of the (texture) data\n   * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n   * @returns The base64 encoded string or null\n   */\n  GenerateBase64StringFromPixelData: GenerateBase64StringFromPixelData,\n\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as a base64 string\n   * @param texture defines the texture to read pixels from\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @returns The base64 encoded string or null\n   */\n  GenerateBase64StringFromTexture: GenerateBase64StringFromTexture,\n\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as a base64 string\n   * @param texture defines the texture to read pixels from\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @returns The base64 encoded string or null wrapped in a promise\n   */\n  GenerateBase64StringFromTextureAsync: GenerateBase64StringFromTextureAsync\n};","map":{"version":3,"mappings":"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","names":["GenerateBase64StringFromPixelData","pixels","size","invertY","width","height","Float32Array","len","byteLength","BYTES_PER_ELEMENT","npixels","Uint8Array","val","canvas","document","createElement","ctx","getContext","imageData","createImageData","castData","data","set","putImageData","canvas2","ctx2","translate","scale","drawImage","toDataURL","GenerateBase64StringFromTexture","texture","faceIndex","level","internalTexture","getInternalTexture","_readPixelsSync","getSize","GenerateBase64StringFromTextureAsync","readPixels","_a","CopyTools"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/copyTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ndeclare type BaseTexture = import(\"../Materials/Textures/baseTexture\").BaseTexture;\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n"]},"metadata":{},"sourceType":"module"}