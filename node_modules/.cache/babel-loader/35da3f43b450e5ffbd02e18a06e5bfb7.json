{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @hidden */\n\nvar WebGPUComputeContext =\n/** @class */\nfunction () {\n  function WebGPUComputeContext(device, cacheSampler) {\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this.uniqueId = WebGPUComputeContext._Counter++;\n    this._bindGroupEntries = [];\n    this.clear();\n  }\n\n  WebGPUComputeContext.prototype.getBindGroups = function (bindings, computePipeline, bindingsMapping) {\n    if (!bindingsMapping) {\n      throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\n    }\n\n    if (this._bindGroups.length === 0) {\n      var bindGroupEntriesExist = this._bindGroupEntries.length > 0;\n\n      for (var key in bindings) {\n        var binding = bindings[key],\n            location_1 = bindingsMapping[key],\n            group = location_1.group,\n            index = location_1.binding,\n            type = binding.type,\n            object = binding.object;\n        var indexInGroupEntries = binding.indexInGroupEntries;\n        var entries = this._bindGroupEntries[group];\n\n        if (!entries) {\n          entries = this._bindGroupEntries[group] = [];\n        }\n\n        switch (type) {\n          case ComputeBindingType.Sampler:\n            {\n              var sampler = object;\n\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._cacheSampler.getSampler(sampler)\n                });\n              }\n\n              break;\n            }\n\n          case ComputeBindingType.Texture:\n          case ComputeBindingType.TextureWithoutSampler:\n            {\n              var texture = object;\n              var hardwareTexture = texture._texture._hardwareTexture;\n\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                if (type === ComputeBindingType.Texture) {\n                  entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture);\n                }\n\n                entries[indexInGroupEntries].resource = hardwareTexture.view;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n\n                if (type === ComputeBindingType.Texture) {\n                  entries.push({\n                    binding: index - 1,\n                    resource: this._cacheSampler.getSampler(texture._texture)\n                  });\n                }\n\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.view\n                });\n              }\n\n              break;\n            }\n\n          case ComputeBindingType.StorageTexture:\n            {\n              var texture = object;\n              var hardwareTexture = texture._texture._hardwareTexture;\n\n              if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\n                Logger.Error(\"computeDispatch: The texture (name=\".concat(texture.name, \", uniqueId=\").concat(texture.uniqueId, \") is not a storage texture!\"), 50);\n              }\n\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.viewForWriting\n                });\n              }\n\n              break;\n            }\n\n          case ComputeBindingType.UniformBuffer:\n          case ComputeBindingType.StorageBuffer:\n            {\n              var buffer = type === ComputeBindingType.UniformBuffer ? object : object;\n              var dataBuffer = buffer.getBuffer();\n              var webgpuBuffer = dataBuffer.underlyingResource;\n\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource.buffer = webgpuBuffer;\n                entries[indexInGroupEntries].resource.size = dataBuffer.capacity;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: {\n                    buffer: webgpuBuffer,\n                    offset: 0,\n                    size: dataBuffer.capacity\n                  }\n                });\n              }\n\n              break;\n            }\n        }\n      }\n\n      for (var i = 0; i < this._bindGroupEntries.length; ++i) {\n        var entries = this._bindGroupEntries[i];\n\n        if (!entries) {\n          this._bindGroups[i] = undefined;\n          continue;\n        }\n\n        this._bindGroups[i] = this._device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(i),\n          entries: entries\n        });\n      }\n\n      this._bindGroups.length = this._bindGroupEntries.length;\n    }\n\n    return this._bindGroups;\n  };\n\n  WebGPUComputeContext.prototype.clear = function () {\n    this._bindGroups = []; // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\n  };\n\n  WebGPUComputeContext._Counter = 0;\n  return WebGPUComputeContext;\n}();\n\nexport { WebGPUComputeContext };","map":{"version":3,"mappings":"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","names":["Logger","ComputeBindingType","WebGPUConstants","device","cacheSampler","_device","_cacheSampler","uniqueId","WebGPUComputeContext","_Counter","_bindGroupEntries","clear","bindings","computePipeline","bindingsMapping","Error","_bindGroups","length","bindGroupEntriesExist","key","binding","location_1","group","index","type","object","indexInGroupEntries","entries","Sampler","sampler","undefined","resource","getSampler","push","Texture","TextureWithoutSampler","texture","hardwareTexture","_texture","_hardwareTexture","view","StorageTexture","textureAdditionalUsages","TextureUsage","StorageBinding","name","concat","viewForWriting","UniformBuffer","StorageBuffer","buffer","dataBuffer","getBuffer","webgpuBuffer","underlyingResource","size","capacity","offset","i","createBindGroup","layout","getBindGroupLayout"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuComputeContext.ts"],"sourcesContent":["import type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\n\r\n/** @hidden */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer: {\r\n                        const buffer = type === ComputeBindingType.UniformBuffer ? (object as UniformBuffer) : (object as StorageBuffer);\r\n                        const dataBuffer = buffer.getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}