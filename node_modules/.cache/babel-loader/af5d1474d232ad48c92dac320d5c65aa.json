{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas.js\";\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget.js\";\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer.js\";\n/**\n * Manages an XRSession to work with Babylon's engine\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\n */\n\nvar WebXRSessionManager =\n/** @class */\nfunction () {\n  /**\n   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\n   * @param scene The scene which the session should be created for\n   */\n  function WebXRSessionManager(\n  /** The scene which the session should be created for */\n  scene) {\n    var _this = this;\n\n    this.scene = scene;\n    /** WebXR timestamp updated every frame */\n\n    this.currentTimestamp = -1;\n    /**\n     * Used just in case of a failure to initialize an immersive session.\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\n     */\n\n    this.defaultHeightCompensation = 1.7;\n    /**\n     * Fires every time a new xrFrame arrives which can be used to update the camera\n     */\n\n    this.onXRFrameObservable = new Observable();\n    /**\n     * Fires when the reference space changed\n     */\n\n    this.onXRReferenceSpaceChanged = new Observable();\n    /**\n     * Fires when the xr session is ended either by the device or manually done\n     */\n\n    this.onXRSessionEnded = new Observable();\n    /**\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\n     */\n\n    this.onXRSessionInit = new Observable();\n    /**\n     * Are we currently in the XR loop?\n     */\n\n    this.inXRFrameLoop = false;\n    /**\n     * Are we in an XR session?\n     */\n\n    this.inXRSession = false;\n    this._engine = scene.getEngine();\n    this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(function () {\n      _this._engine = null;\n    });\n    scene.onDisposeObservable.addOnce(function () {\n      _this.dispose();\n    });\n  }\n\n  Object.defineProperty(WebXRSessionManager.prototype, \"referenceSpace\", {\n    /**\n     * The current reference space used in this session. This reference space can constantly change!\n     * It is mainly used to offset the camera's position.\n     */\n    get: function get() {\n      return this._referenceSpace;\n    },\n\n    /**\n     * Set a new reference space and triggers the observable\n     */\n    set: function set(newReferenceSpace) {\n      this._referenceSpace = newReferenceSpace;\n      this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRSessionManager.prototype, \"sessionMode\", {\n    /**\n     * The mode for the managed XR session\n     */\n    get: function get() {\n      return this._sessionMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes of the session manager\n   * This should be called explicitly by the dev, if required.\n   */\n\n  WebXRSessionManager.prototype.dispose = function () {\n    var _a; // disposing without leaving XR? Exit XR first\n\n\n    if (this.inXRSession) {\n      this.exitXRAsync();\n    }\n\n    this.onXRFrameObservable.clear();\n    this.onXRSessionEnded.clear();\n    this.onXRReferenceSpaceChanged.clear();\n    this.onXRSessionInit.clear();\n    (_a = this._engine) === null || _a === void 0 ? void 0 : _a.onDisposeObservable.remove(this._onEngineDisposedObserver);\n    this._engine = null;\n  };\n  /**\n   * Stops the xrSession and restores the render loop\n   * @returns Promise which resolves after it exits XR\n   */\n\n\n  WebXRSessionManager.prototype.exitXRAsync = function () {\n    if (this.session && this.inXRSession) {\n      this.inXRSession = false;\n      return this.session.end()[\"catch\"](function () {\n        Logger.Warn(\"Could not end XR session.\");\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\n   * In the event of a failure, the supplied viewport is not updated.\n   * @param viewport the viewport to which the view will be rendered\n   * @param view the view for which to set the viewport\n   * @returns whether the operation was successful\n   */\n\n\n  WebXRSessionManager.prototype.trySetViewportForView = function (viewport, view) {\n    var _a;\n\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.trySetViewportForView(viewport, view)) || false;\n  };\n  /**\n   * Gets the correct render target texture to be rendered this frame for this eye\n   * @param eye the eye for which to get the render target\n   * @returns the render target for the specified eye or null if not available\n   */\n\n\n  WebXRSessionManager.prototype.getRenderTargetTextureForEye = function (eye) {\n    var _a;\n\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForEye(eye)) || null;\n  };\n  /**\n   * Gets the correct render target texture to be rendered this frame for this view\n   * @param view the view for which to get the render target\n   * @returns the render target for the specified view or null if not available\n   */\n\n\n  WebXRSessionManager.prototype.getRenderTargetTextureForView = function (view) {\n    var _a;\n\n    return ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getRenderTargetTextureForView(view)) || null;\n  };\n  /**\n   * Creates a WebXRRenderTarget object for the XR session\n   * @param options optional options to provide when creating a new render target\n   * @returns a WebXR render target to which the session can render\n   */\n\n\n  WebXRSessionManager.prototype.getWebXRRenderTarget = function (options) {\n    var engine = this.scene.getEngine();\n\n    if (this._xrNavigator.xr[\"native\"]) {\n      return new NativeXRRenderTarget(this);\n    } else {\n      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\n      options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\n      return new WebXRManagedOutputCanvas(this, options);\n    }\n  };\n  /**\n   * Initializes the manager\n   * After initialization enterXR can be called to start an XR session\n   * @returns Promise which resolves after it is initialized\n   */\n\n\n  WebXRSessionManager.prototype.initializeAsync = function () {\n    // Check if the browser supports webXR\n    this._xrNavigator = navigator;\n\n    if (!this._xrNavigator.xr) {\n      return Promise.reject(\"WebXR not available\");\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Initializes an xr session\n   * @param xrSessionMode mode to initialize\n   * @param xrSessionInit defines optional and required values to pass to the session builder\n   * @returns a promise which will resolve once the session has been initialized\n   */\n\n\n  WebXRSessionManager.prototype.initializeSessionAsync = function (xrSessionMode, xrSessionInit) {\n    var _this = this;\n\n    if (xrSessionMode === void 0) {\n      xrSessionMode = \"immersive-vr\";\n    }\n\n    if (xrSessionInit === void 0) {\n      xrSessionInit = {};\n    }\n\n    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(function (session) {\n      _this.session = session;\n      _this._sessionMode = xrSessionMode;\n\n      _this.onXRSessionInit.notifyObservers(session);\n\n      _this.inXRSession = true; // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\n\n      _this.session.addEventListener(\"end\", function () {\n        var _a;\n\n        _this.inXRSession = false; // Notify frame observers\n\n        _this.onXRSessionEnded.notifyObservers(null);\n\n        if (_this._engine) {\n          // make sure dimensions object is restored\n          _this._engine.framebufferDimensionsObject = null; // Restore frame buffer to avoid clear on xr framebuffer after session end\n\n          _this._engine.restoreDefaultFramebuffer(); // Need to restart render loop as after the session is ended the last request for new frame will never call callback\n\n\n          _this._engine.customAnimationFrameRequester = null;\n\n          _this._engine._renderLoop();\n        } // Dispose render target textures.\n        // Only dispose on native because we can't destroy opaque textures on browser.\n\n\n        if (_this.isNative) {\n          (_a = _this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n\n        _this._baseLayerRTTProvider = null;\n        _this._baseLayerWrapper = null;\n      }, {\n        once: true\n      });\n\n      return _this.session;\n    });\n  };\n  /**\n   * Checks if a session would be supported for the creation options specified\n   * @param sessionMode session mode to check if supported eg. immersive-vr\n   * @returns A Promise that resolves to true if supported and false if not\n   */\n\n\n  WebXRSessionManager.prototype.isSessionSupportedAsync = function (sessionMode) {\n    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\n  };\n  /**\n   * Resets the reference space to the one started the session\n   */\n\n\n  WebXRSessionManager.prototype.resetReferenceSpace = function () {\n    this.referenceSpace = this.baseReferenceSpace;\n  };\n  /**\n   * Starts rendering to the xr layer\n   */\n\n\n  WebXRSessionManager.prototype.runXRRenderLoop = function () {\n    var _this = this;\n\n    var _a;\n\n    if (!this.inXRSession || !this._engine) {\n      return;\n    } // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\n\n\n    this._engine.customAnimationFrameRequester = {\n      requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\n      renderFunction: function renderFunction(timestamp, xrFrame) {\n        var _a;\n\n        if (!_this.inXRSession || !_this._engine) {\n          return;\n        } // Store the XR frame and timestamp in the session manager\n\n\n        _this.currentFrame = xrFrame;\n        _this.currentTimestamp = timestamp;\n\n        if (xrFrame) {\n          _this.inXRFrameLoop = true;\n          _this._engine.framebufferDimensionsObject = ((_a = _this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getFramebufferDimensions()) || null;\n\n          _this.onXRFrameObservable.notifyObservers(xrFrame);\n\n          _this._engine._renderLoop();\n\n          _this._engine.framebufferDimensionsObject = null;\n          _this.inXRFrameLoop = false;\n        }\n      }\n    };\n    this._engine.framebufferDimensionsObject = ((_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.getFramebufferDimensions()) || null; // Stop window's animation frame and trigger sessions animation frame\n\n    if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\n      window.cancelAnimationFrame(this._engine._frameHandler);\n    }\n\n    this._engine._renderLoop();\n  };\n  /**\n   * Sets the reference space on the xr session\n   * @param referenceSpaceType space to set\n   * @returns a promise that will resolve once the reference space has been set\n   */\n\n\n  WebXRSessionManager.prototype.setReferenceSpaceTypeAsync = function (referenceSpaceType) {\n    var _this = this;\n\n    if (referenceSpaceType === void 0) {\n      referenceSpaceType = \"local-floor\";\n    }\n\n    return this.session.requestReferenceSpace(referenceSpaceType).then(function (referenceSpace) {\n      return referenceSpace;\n    }, function (rejectionReason) {\n      Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\n      Logger.Error(rejectionReason);\n      Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (referenceSpace) {\n        var heightCompensation = new XRRigidTransform({\n          x: 0,\n          y: -_this.defaultHeightCompensation,\n          z: 0\n        });\n        return referenceSpace.getOffsetReferenceSpace(heightCompensation);\n      }, function (rejectionReason) {\n        Logger.Error(rejectionReason);\n        throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\n      });\n    }).then(function (referenceSpace) {\n      // create viewer reference space before setting the first reference space\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (viewerReferenceSpace) {\n        _this.viewerReferenceSpace = viewerReferenceSpace;\n        return referenceSpace;\n      });\n    }).then(function (referenceSpace) {\n      // initialize the base and offset (currently the same)\n      _this.referenceSpace = _this.baseReferenceSpace = referenceSpace;\n      return _this.referenceSpace;\n    });\n  };\n  /**\n   * Updates the render state of the session.\n   * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\n   * @param state state to set\n   * @returns a promise that resolves once the render state has been updated\n   * @deprecated\n   */\n\n\n  WebXRSessionManager.prototype.updateRenderStateAsync = function (state) {\n    return Promise.resolve(this.session.updateRenderState(state));\n  };\n  /**\n   * @param baseLayerWrapper\n   * @hidden\n   */\n\n\n  WebXRSessionManager.prototype._setBaseLayerWrapper = function (baseLayerWrapper) {\n    var _a, _b;\n\n    if (this.isNative) {\n      (_a = this._baseLayerRTTProvider) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n\n    this._baseLayerWrapper = baseLayerWrapper;\n    this._baseLayerRTTProvider = ((_b = this._baseLayerWrapper) === null || _b === void 0 ? void 0 : _b.createRenderTargetTextureProvider(this)) || null;\n  };\n  /**\n   * Updates the render state of the session\n   * @param state state to set\n   */\n\n\n  WebXRSessionManager.prototype.updateRenderState = function (state) {\n    if (state.baseLayer) {\n      this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\n    }\n\n    this.session.updateRenderState(state);\n  };\n  /**\n   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\n   * @param sessionMode defines the session to test\n   * @returns a promise with boolean as final value\n   */\n\n\n  WebXRSessionManager.IsSessionSupportedAsync = function (sessionMode) {\n    if (!navigator.xr) {\n      return Promise.resolve(false);\n    } // When the specs are final, remove supportsSession!\n\n\n    var functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;\n\n    if (!functionToUse) {\n      return Promise.resolve(false);\n    } else {\n      return functionToUse.call(navigator.xr, sessionMode).then(function (result) {\n        var returnValue = typeof result === \"undefined\" ? true : result;\n        return Promise.resolve(returnValue);\n      })[\"catch\"](function (e) {\n        Logger.Warn(e);\n        return Promise.resolve(false);\n      });\n    }\n  };\n\n  Object.defineProperty(WebXRSessionManager.prototype, \"isNative\", {\n    /**\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\n     */\n    get: function get() {\n      var _a;\n\n      return (_a = this._xrNavigator.xr[\"native\"]) !== null && _a !== void 0 ? _a : false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRSessionManager.prototype, \"currentFrameRate\", {\n    /**\n     * The current frame rate as reported by the device\n     */\n    get: function get() {\n      var _a;\n\n      return (_a = this.session) === null || _a === void 0 ? void 0 : _a.frameRate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRSessionManager.prototype, \"supportedFrameRates\", {\n    /**\n     * A list of supported frame rates (only available in-session!\n     */\n    get: function get() {\n      var _a;\n\n      return (_a = this.session) === null || _a === void 0 ? void 0 : _a.supportedFrameRates;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Set the framerate of the session.\n   * @param rate the new framerate. This value needs to be in the supportedFrameRates array\n   * @returns a promise that resolves once the framerate has been set\n   */\n\n  WebXRSessionManager.prototype.updateTargetFrameRate = function (rate) {\n    return this.session.updateTargetFrameRate(rate);\n  };\n  /**\n   * Run a callback in the xr render loop\n   * @param callback the callback to call when in XR Frame\n   * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\n   */\n\n\n  WebXRSessionManager.prototype.runInXRFrame = function (callback, ignoreIfNotInSession) {\n    if (ignoreIfNotInSession === void 0) {\n      ignoreIfNotInSession = true;\n    }\n\n    if (this.inXRFrameLoop) {\n      callback();\n    } else if (this.inXRSession || !ignoreIfNotInSession) {\n      this.onXRFrameObservable.addOnce(callback);\n    }\n  };\n\n  Object.defineProperty(WebXRSessionManager.prototype, \"isFixedFoveationSupported\", {\n    /**\n     * Check if fixed foveation is supported on this device\n     */\n    get: function get() {\n      var _a;\n\n      return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.isFixedFoveationSupported) || false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRSessionManager.prototype, \"fixedFoveation\", {\n    /**\n     * Get the fixed foveation currently set, as specified by the webxr specs\n     * If this returns null, then fixed foveation is not supported\n     */\n    get: function get() {\n      var _a;\n\n      return ((_a = this._baseLayerWrapper) === null || _a === void 0 ? void 0 : _a.fixedFoveation) || null;\n    },\n\n    /**\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\n     */\n    set: function set(value) {\n      var val = Math.max(0, Math.min(1, value || 0));\n\n      if (this._baseLayerWrapper) {\n        this._baseLayerWrapper.fixedFoveation = val;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return WebXRSessionManager;\n}();\n\nexport { WebXRSessionManager };","map":{"version":3,"mappings":";;;AAAA,SAASA,MAAT,QAAuB,mBAAvB;AAEA,SAASC,UAAT,QAA2B,uBAA3B;AAKA,SAASC,wBAAT,EAAmCC,+BAAnC,QAA0E,+BAA1E;AAKA,SAASC,oBAAT,EAA+BC,oBAA/B,QAA2D,kCAA3D;AACA,SAASC,sBAAT,QAAuC,sBAAvC;AAGA;;;;;AAIA;AAAA;AAAA;AA2DI;;;;AAIA;AACI;AACOC,OAFX,EAEuB;AAFvB;;AAEW;AA/CX;;AACO,4BAA2B,CAAC,CAA5B;AACP;;;;;AAIO,qCAA4B,GAA5B;AACP;;;;AAGO,+BAA2C,IAAIN,UAAJ,EAA3C;AACP;;;;AAGO,qCAA0D,IAAIA,UAAJ,EAA1D;AACP;;;;AAGO,4BAAoC,IAAIA,UAAJ,EAApC;AACP;;;;AAGO,2BAAyC,IAAIA,UAAJ,EAAzC;AAUP;;;;AAGO,yBAAyB,KAAzB;AACP;;;;AAGO,uBAAuB,KAAvB;AAUH,SAAKO,OAAL,GAAeD,KAAK,CAACE,SAAN,EAAf;AACA,SAAKC,yBAAL,GAAiC,KAAKF,OAAL,CAAaG,mBAAb,CAAiCC,OAAjC,CAAyC;AACtEC,WAAI,CAACL,OAAL,GAAe,IAAf;AACH,KAFgC,CAAjC;AAGAD,SAAK,CAACI,mBAAN,CAA0BC,OAA1B,CAAkC;AAC9BC,WAAI,CAACC,OAAL;AACH,KAFD;AAGH;;AAMDC,wBAAWC,6BAAX,EAAW,gBAAX,EAAyB;AAJzB;;;;SAIA;AACI,aAAO,KAAKC,eAAZ;AACH,KAFwB;;AAIzB;;;SAGA,aAA0BC,iBAA1B,EAA6D;AACzD,WAAKD,eAAL,GAAuBC,iBAAvB;AACA,WAAKC,yBAAL,CAA+BC,eAA/B,CAA+C,KAAKH,eAApD;AACH,KAVwB;qBAAA;;AAAA,GAAzB;AAeAF,wBAAWC,6BAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA;AACI,aAAO,KAAKK,YAAZ;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAIA;;;;;AAIOL,0CAAP;WAAA,CACI;;;AACA,QAAI,KAAKM,WAAT,EAAsB;AAClB,WAAKC,WAAL;AACH;;AACD,SAAKC,mBAAL,CAAyBC,KAAzB;AACA,SAAKC,gBAAL,CAAsBD,KAAtB;AACA,SAAKN,yBAAL,CAA+BM,KAA/B;AACA,SAAKE,eAAL,CAAqBF,KAArB;AACA,eAAKjB,OAAL,MAAY,IAAZ,IAAYoB,aAAZ,GAAY,MAAZ,GAAYA,GAAEjB,mBAAF,CAAsBkB,MAAtB,CAA6B,KAAKnB,yBAAlC,CAAZ;AACA,SAAKF,OAAL,GAAe,IAAf;AACH,GAXM;AAaP;;;;;;AAIOQ,8CAAP;AACI,QAAI,KAAKc,OAAL,IAAgB,KAAKR,WAAzB,EAAsC;AAClC,WAAKA,WAAL,GAAmB,KAAnB;AACA,aAAO,KAAKQ,OAAL,CAAaC,GAAb,YAAyB;AAC5B/B,cAAM,CAACgC,IAAP,CAAY,2BAAZ;AACH,OAFM,CAAP;AAGH;;AACD,WAAOC,OAAO,CAACC,OAAR,EAAP;AACH,GARM;AAUP;;;;;;;;;AAOOlB,wDAAP,UAA6BmB,QAA7B,EAAiDC,IAAjD,EAA6D;;;AACzD,WAAO,YAAKC,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEU,qBAAF,CAAwBH,QAAxB,EAAkCC,IAAlC,CAA1B,KAAqE,KAA5E;AACH,GAFM;AAIP;;;;;;;AAKOpB,+DAAP,UAAoCuB,GAApC,EAA8C;;;AAC1C,WAAO,YAAKF,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEY,4BAAF,CAA+BD,GAA/B,CAA1B,KAAiE,IAAxE;AACH,GAFM;AAIP;;;;;;;AAKOvB,gEAAP,UAAqCoB,IAArC,EAAiD;;;AAC7C,WAAO,YAAKC,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEa,6BAAF,CAAgCL,IAAhC,CAA1B,KAAmE,IAA1E;AACH,GAFM;AAIP;;;;;;;AAKOpB,uDAAP,UAA4B0B,OAA5B,EAAqE;AACjE,QAAMC,MAAM,GAAG,KAAKpC,KAAL,CAAWE,SAAX,EAAf;;AACA,QAAI,KAAKmC,YAAL,CAAkBC,EAAlB,UAAJ,EAAiC;AAC7B,aAAO,IAAIxC,oBAAJ,CAAyB,IAAzB,CAAP;AACH,KAFD,MAEO;AACHqC,aAAO,GAAGA,OAAO,IAAIvC,+BAA+B,CAAC2C,WAAhC,CAA4CH,MAA5C,CAArB;AACAD,aAAO,CAACK,aAAR,GAAwBL,OAAO,CAACK,aAAR,IAAyBJ,MAAM,CAACK,kBAAP,EAAzB,IAAwDC,SAAhF;AACA,aAAO,IAAI/C,wBAAJ,CAA6B,IAA7B,EAAmCwC,OAAnC,CAAP;AACH;AACJ,GATM;AAWP;;;;;;;AAKO1B,kDAAP;AACI;AACA,SAAK4B,YAAL,GAAoBM,SAApB;;AACA,QAAI,CAAC,KAAKN,YAAL,CAAkBC,EAAvB,EAA2B;AACvB,aAAOZ,OAAO,CAACkB,MAAR,CAAe,qBAAf,CAAP;AACH;;AACD,WAAOlB,OAAO,CAACC,OAAR,EAAP;AACH,GAPM;AASP;;;;;;;;AAMOlB,yDAAP,UAA8BoC,aAA9B,EAA6EC,aAA7E,EAA8G;AAA9G;;AAA8B;AAAAD;AAA6C;;AAAE;AAAAC;AAAiC;;AAC1G,WAAO,KAAKT,YAAL,CAAkBC,EAAlB,CAAqBS,cAArB,CAAoCF,aAApC,EAAmDC,aAAnD,EAAkEE,IAAlE,CAAuE,UAACzB,OAAD,EAAmB;AAC7FjB,WAAI,CAACiB,OAAL,GAAeA,OAAf;AACAjB,WAAI,CAACQ,YAAL,GAAoB+B,aAApB;;AACAvC,WAAI,CAACc,eAAL,CAAqBP,eAArB,CAAqCU,OAArC;;AACAjB,WAAI,CAACS,WAAL,GAAmB,IAAnB,CAJ6F,CAM7F;;AACAT,WAAI,CAACiB,OAAL,CAAa0B,gBAAb,CACI,KADJ,EAEI;;;AACI3C,aAAI,CAACS,WAAL,GAAmB,KAAnB,CADJ,CAGI;;AACAT,aAAI,CAACa,gBAAL,CAAsBN,eAAtB,CAAsC,IAAtC;;AAEA,YAAIP,KAAI,CAACL,OAAT,EAAkB;AACd;AACAK,eAAI,CAACL,OAAL,CAAaiD,2BAAb,GAA2C,IAA3C,CAFc,CAId;;AACA5C,eAAI,CAACL,OAAL,CAAakD,yBAAb,GALc,CAOd;;;AACA7C,eAAI,CAACL,OAAL,CAAamD,6BAAb,GAA6C,IAA7C;;AACA9C,eAAI,CAACL,OAAL,CAAaoD,WAAb;AACH,SAhBL,CAkBI;AACA;;;AACA,YAAI/C,KAAI,CAACgD,QAAT,EAAmB;AACf,qBAAI,CAACxB,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEd,OAAF,EAA1B;AACH;;AACDD,aAAI,CAACwB,qBAAL,GAA6B,IAA7B;AACAxB,aAAI,CAACiD,iBAAL,GAAyB,IAAzB;AACH,OA3BL,EA4BI;AAAEC,YAAI,EAAE;AAAR,OA5BJ;;AA+BA,aAAOlD,KAAI,CAACiB,OAAZ;AACH,KAvCM,CAAP;AAwCH,GAzCM;AA2CP;;;;;;;AAKOd,0DAAP,UAA+BgD,WAA/B,EAAyD;AACrD,WAAOhD,mBAAmB,CAACiD,uBAApB,CAA4CD,WAA5C,CAAP;AACH,GAFM;AAIP;;;;;AAGOhD,sDAAP;AACI,SAAKkD,cAAL,GAAsB,KAAKC,kBAA3B;AACH,GAFM;AAIP;;;;;AAGOnD,kDAAP;AAAA;;;;AACI,QAAI,CAAC,KAAKM,WAAN,IAAqB,CAAC,KAAKd,OAA/B,EAAwC;AACpC;AACH,KAHL,CAKI;;;AACA,SAAKA,OAAL,CAAamD,6BAAb,GAA6C;AACzCS,2BAAqB,EAAE,KAAKtC,OAAL,CAAasC,qBAAb,CAAmCC,IAAnC,CAAwC,KAAKvC,OAA7C,CADkB;AAEzCwC,oBAAc,EAAE,wBAACC,SAAD,EAAoBC,OAApB,EAA8C;;;AAC1D,YAAI,CAAC3D,KAAI,CAACS,WAAN,IAAqB,CAACT,KAAI,CAACL,OAA/B,EAAwC;AACpC;AACH,SAHyD,CAI1D;;;AACAK,aAAI,CAAC4D,YAAL,GAAoBD,OAApB;AACA3D,aAAI,CAAC6D,gBAAL,GAAwBH,SAAxB;;AACA,YAAIC,OAAJ,EAAa;AACT3D,eAAI,CAAC8D,aAAL,GAAqB,IAArB;AACA9D,eAAI,CAACL,OAAL,CAAaiD,2BAAb,GAA2C,YAAI,CAACpB,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEgD,wBAAF,EAA1B,KAA0D,IAArG;;AACA/D,eAAI,CAACW,mBAAL,CAAyBJ,eAAzB,CAAyCoD,OAAzC;;AACA3D,eAAI,CAACL,OAAL,CAAaoD,WAAb;;AACA/C,eAAI,CAACL,OAAL,CAAaiD,2BAAb,GAA2C,IAA3C;AACA5C,eAAI,CAAC8D,aAAL,GAAqB,KAArB;AACH;AACJ;AAjBwC,KAA7C;AAoBA,SAAKnE,OAAL,CAAaiD,2BAAb,GAA2C,YAAKpB,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEgD,wBAAF,EAA1B,KAA0D,IAArG,CA1BJ,CA4BI;;AACA,QAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,oBAA5C,EAAkE;AAC9DD,YAAM,CAACC,oBAAP,CAA4B,KAAKtE,OAAL,CAAauE,aAAzC;AACH;;AACD,SAAKvE,OAAL,CAAaoD,WAAb;AACH,GAjCM;AAmCP;;;;;;;AAKO5C,6DAAP,UAAkCgE,kBAAlC,EAA0F;AAA1F;;AAAkC;AAAAA;AAAwD;;AACtF,WAAO,KAAKlD,OAAL,CACFmD,qBADE,CACoBD,kBADpB,EAEFzB,IAFE,CAGC,UAACW,cAAD,EAAe;AACX,aAAOA,cAAP;AACH,KALF,EAMC,UAACgB,eAAD,EAAgB;AACZlF,YAAM,CAACmF,KAAP,CAAa,4DAAb;AACAnF,YAAM,CAACmF,KAAP,CAAaD,eAAb;AACAlF,YAAM,CAACoF,GAAP,CAAW,oEAAX;AAEA,aAAOvE,KAAI,CAACiB,OAAL,CAAamD,qBAAb,CAAmC,QAAnC,EAA6C1B,IAA7C,CACH,UAACW,cAAD,EAAe;AACX,YAAMmB,kBAAkB,GAAG,IAAIC,gBAAJ,CAAqB;AAAEC,WAAC,EAAE,CAAL;AAAQC,WAAC,EAAE,CAAC3E,KAAI,CAAC4E,yBAAjB;AAA4CC,WAAC,EAAE;AAA/C,SAArB,CAA3B;AACA,eAAQxB,cAAmC,CAACyB,uBAApC,CAA4DN,kBAA5D,CAAR;AACH,OAJE,EAKH,UAACH,eAAD,EAAgB;AACZlF,cAAM,CAACmF,KAAP,CAAaD,eAAb;AACA,cAAM,iFAAN;AACH,OARE,CAAP;AAUH,KArBF,EAuBF3B,IAvBE,CAuBG,UAACW,cAAD,EAAe;AACjB;AACA,aAAOrD,KAAI,CAACiB,OAAL,CAAamD,qBAAb,CAAmC,QAAnC,EAA6C1B,IAA7C,CAAkD,UAACqC,oBAAD,EAAqB;AAC1E/E,aAAI,CAAC+E,oBAAL,GAA4BA,oBAA5B;AACA,eAAO1B,cAAP;AACH,OAHM,CAAP;AAIH,KA7BE,EA8BFX,IA9BE,CA8BG,UAACW,cAAD,EAAe;AACjB;AACArD,WAAI,CAACqD,cAAL,GAAsBrD,KAAI,CAACsD,kBAAL,GAA0BD,cAAhD;AACA,aAAOrD,KAAI,CAACqD,cAAZ;AACH,KAlCE,CAAP;AAmCH,GApCM;AAsCP;;;;;;;;;AAOOlD,yDAAP,UAA8B6E,KAA9B,EAAkD;AAC9C,WAAO5D,OAAO,CAACC,OAAR,CAAgB,KAAKJ,OAAL,CAAagE,iBAAb,CAA+BD,KAA/B,CAAhB,CAAP;AACH,GAFM;AAIP;;;;;;AAIO7E,uDAAP,UAA4B+E,gBAA5B,EAAyE;;;AACrE,QAAI,KAAKlC,QAAT,EAAmB;AACf,iBAAKxB,qBAAL,MAA0B,IAA1B,IAA0BT,aAA1B,GAA0B,MAA1B,GAA0BA,GAAEd,OAAF,EAA1B;AACH;;AACD,SAAKgD,iBAAL,GAAyBiC,gBAAzB;AACA,SAAK1D,qBAAL,GAA6B,YAAKyB,iBAAL,MAAsB,IAAtB,IAAsBkC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEC,iCAAF,CAAoC,IAApC,CAAtB,KAAmE,IAAhG;AACH,GANM;AAQP;;;;;;AAIOjF,oDAAP,UAAyB6E,KAAzB,EAAiD;AAC7C,QAAIA,KAAK,CAACK,SAAV,EAAqB;AACjB,WAAKC,oBAAL,CAA0B,KAAKtC,QAAL,GAAgB,IAAIzD,oBAAJ,CAAyByF,KAAK,CAACK,SAA/B,CAAhB,GAA4D,IAAI5F,sBAAJ,CAA2BuF,KAAK,CAACK,SAAjC,CAAtF;AACH;;AAED,SAAKpE,OAAL,CAAagE,iBAAb,CAA+BD,KAA/B;AACH,GANM;AAQP;;;;;;;AAKc7E,gDAAd,UAAsCgD,WAAtC,EAAgE;AAC5D,QAAI,CAAEd,SAAiB,CAACL,EAAxB,EAA4B;AACxB,aAAOZ,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAAP;AACH,KAH2D,CAI5D;;;AACA,QAAMkE,aAAa,GAAIlD,SAAiB,CAACL,EAAlB,CAAqBwD,kBAArB,IAA4CnD,SAAiB,CAACL,EAAlB,CAAqByD,eAAxF;;AACA,QAAI,CAACF,aAAL,EAAoB;AAChB,aAAOnE,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAAP;AACH,KAFD,MAEO;AACH,aAAOkE,aAAa,CACfG,IADE,CACIrD,SAAiB,CAACL,EADtB,EAC0BmB,WAD1B,EAEFT,IAFE,CAEG,UAACiD,MAAD,EAAgB;AAClB,YAAMC,WAAW,GAAG,OAAOD,MAAP,KAAkB,WAAlB,GAAgC,IAAhC,GAAuCA,MAA3D;AACA,eAAOvE,OAAO,CAACC,OAAR,CAAgBuE,WAAhB,CAAP;AACH,OALE,WAMI,UAACC,CAAD,EAAO;AACV1G,cAAM,CAACgC,IAAP,CAAY0E,CAAZ;AACA,eAAOzE,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAAP;AACH,OATE,CAAP;AAUH;AACJ,GApBa;;AAyBdnB,wBAAWC,6BAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA;;;AACI,aAAO,WAAK4B,YAAL,CAAkBC,EAAlB,gBAA2B,IAA3B,IAA2BjB,aAA3B,GAA2BA,EAA3B,GAA+B,KAAtC;AACH,KAFkB;qBAAA;;AAAA,GAAnB;AAOAb,wBAAWC,6BAAX,EAAW,kBAAX,EAA2B;AAH3B;;;SAGA;;;AACI,aAAO,WAAKc,OAAL,MAAY,IAAZ,IAAYF,aAAZ,GAAY,MAAZ,GAAYA,GAAE+E,SAArB;AACH,KAF0B;qBAAA;;AAAA,GAA3B;AAOA5F,wBAAWC,6BAAX,EAAW,qBAAX,EAA8B;AAH9B;;;SAGA;;;AACI,aAAO,WAAKc,OAAL,MAAY,IAAZ,IAAYF,aAAZ,GAAY,MAAZ,GAAYA,GAAEgF,mBAArB;AACH,KAF6B;qBAAA;;AAAA,GAA9B;AAIA;;;;;;AAKO5F,wDAAP,UAA6B6F,IAA7B,EAAyC;AACrC,WAAO,KAAK/E,OAAL,CAAagF,qBAAb,CAAmCD,IAAnC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO7F,+CAAP,UAAoB+F,QAApB,EAA0CC,oBAA1C,EAAqE;AAA3B;AAAAA;AAA2B;;AACjE,QAAI,KAAKrC,aAAT,EAAwB;AACpBoC,cAAQ;AACX,KAFD,MAEO,IAAI,KAAKzF,WAAL,IAAoB,CAAC0F,oBAAzB,EAA+C;AAClD,WAAKxF,mBAAL,CAAyBZ,OAAzB,CAAiCmG,QAAjC;AACH;AACJ,GANM;;AAWPhG,wBAAWC,6BAAX,EAAW,2BAAX,EAAoC;AAHpC;;;SAGA;;;AACI,aAAO,YAAK8C,iBAAL,MAAsB,IAAtB,IAAsBlC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEqF,yBAAxB,KAAqD,KAA5D;AACH,KAFmC;qBAAA;;AAAA,GAApC;AAQAlG,wBAAWC,6BAAX,EAAW,gBAAX,EAAyB;AAJzB;;;;SAIA;;;AACI,aAAO,YAAK8C,iBAAL,MAAsB,IAAtB,IAAsBlC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEsF,cAAxB,KAA0C,IAAjD;AACH,KAFwB;;AAIzB;;;;SAIA,aAA0BC,KAA1B,EAAiD;AAC7C,UAAMC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYJ,KAAK,IAAI,CAArB,CAAZ,CAAZ;;AACA,UAAI,KAAKrD,iBAAT,EAA4B;AACxB,aAAKA,iBAAL,CAAuBoD,cAAvB,GAAwCE,GAAxC;AACH;AACJ,KAbwB;qBAAA;;AAAA,GAAzB;AAcJ;AAAC,CAjdD","names":["Logger","Observable","WebXRManagedOutputCanvas","WebXRManagedOutputCanvasOptions","NativeXRLayerWrapper","NativeXRRenderTarget","WebXRWebGLLayerWrapper","scene","_engine","getEngine","_onEngineDisposedObserver","onDisposeObservable","addOnce","_this","dispose","Object","WebXRSessionManager","_referenceSpace","newReferenceSpace","onXRReferenceSpaceChanged","notifyObservers","_sessionMode","inXRSession","exitXRAsync","onXRFrameObservable","clear","onXRSessionEnded","onXRSessionInit","_a","remove","session","end","Warn","Promise","resolve","viewport","view","_baseLayerRTTProvider","trySetViewportForView","eye","getRenderTargetTextureForEye","getRenderTargetTextureForView","options","engine","_xrNavigator","xr","GetDefaults","canvasElement","getRenderingCanvas","undefined","navigator","reject","xrSessionMode","xrSessionInit","requestSession","then","addEventListener","framebufferDimensionsObject","restoreDefaultFramebuffer","customAnimationFrameRequester","_renderLoop","isNative","_baseLayerWrapper","once","sessionMode","IsSessionSupportedAsync","referenceSpace","baseReferenceSpace","requestAnimationFrame","bind","renderFunction","timestamp","xrFrame","currentFrame","currentTimestamp","inXRFrameLoop","getFramebufferDimensions","window","cancelAnimationFrame","_frameHandler","referenceSpaceType","requestReferenceSpace","rejectionReason","Error","Log","heightCompensation","XRRigidTransform","x","y","defaultHeightCompensation","z","getOffsetReferenceSpace","viewerReferenceSpace","state","updateRenderState","baseLayerWrapper","_b","createRenderTargetTextureProvider","baseLayer","_setBaseLayerWrapper","functionToUse","isSessionSupported","supportsSession","call","result","returnValue","e","frameRate","supportedFrameRates","rate","updateTargetFrameRate","callback","ignoreIfNotInSession","isFixedFoveationSupported","fixedFoveation","value","val","Math","max","min"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRSessionManager.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            return this.session.end().catch(() => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this.inXRSession = true;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @param baseLayerWrapper\r\n     * @hidden\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}