{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines the layer scene component responsible to manage any layers\n * in a given scene.\n */\n\nvar LayerSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function LayerSceneComponent(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_LAYER;\n    this.scene = scene || EngineStore.LastCreatedScene;\n\n    if (!this.scene) {\n      return;\n    }\n\n    this._engine = this.scene.getEngine();\n    this.scene.layers = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  LayerSceneComponent.prototype.register = function () {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\n\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\n\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  LayerSceneComponent.prototype.rebuild = function () {\n    var layers = this.scene.layers;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var layer = layers_1[_i];\n\n      layer._rebuild();\n    }\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  LayerSceneComponent.prototype.dispose = function () {\n    var layers = this.scene.layers;\n\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  };\n\n  LayerSceneComponent.prototype._draw = function (predicate) {\n    var layers = this.scene.layers;\n\n    if (layers.length) {\n      this._engine.setDepthBuffer(false);\n\n      for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\n        var layer = layers_2[_i];\n\n        if (predicate(layer)) {\n          layer.render();\n        }\n      }\n\n      this._engine.setDepthBuffer(true);\n    }\n  };\n\n  LayerSceneComponent.prototype._drawCameraPredicate = function (layer, isBackground, cameraLayerMask) {\n    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && (layer.layerMask & cameraLayerMask) !== 0;\n  };\n\n  LayerSceneComponent.prototype._drawCameraBackground = function (camera) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawCameraPredicate(layer, true, camera.layerMask);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawCameraForeground = function (camera) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawCameraPredicate(layer, false, camera.layerMask);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetPredicate = function (layer, isBackground, cameraLayerMask, renderTargetTexture) {\n    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetBackground = function (renderTarget) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawRenderTargetPredicate(layer, true, _this.scene.activeCamera.layerMask, renderTarget);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetForeground = function (renderTarget) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawRenderTargetPredicate(layer, false, _this.scene.activeCamera.layerMask, renderTarget);\n    });\n  };\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n\n\n  LayerSceneComponent.prototype.addFromContainer = function (container) {\n    var _this = this;\n\n    if (!container.layers) {\n      return;\n    }\n\n    container.layers.forEach(function (layer) {\n      _this.scene.layers.push(layer);\n    });\n  };\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n\n\n  LayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {\n    var _this = this;\n\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    if (!container.layers) {\n      return;\n    }\n\n    container.layers.forEach(function (layer) {\n      var index = _this.scene.layers.indexOf(layer);\n\n      if (index !== -1) {\n        _this.scene.layers.splice(index, 1);\n      }\n\n      if (dispose) {\n        layer.dispose();\n      }\n    });\n  };\n\n  return LayerSceneComponent;\n}();\n\nexport { LayerSceneComponent };","map":{"version":3,"mappings":"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","names":["SceneComponentConstants","EngineStore","scene","NAME_LAYER","LastCreatedScene","_engine","getEngine","layers","Array","LayerSceneComponent","_beforeCameraDrawStage","registerStep","STEP_BEFORECAMERADRAW_LAYER","_drawCameraBackground","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_LAYER","_drawCameraForeground","_beforeRenderTargetDrawStage","STEP_BEFORERENDERTARGETDRAW_LAYER","_drawRenderTargetBackground","_afterRenderTargetDrawStage","STEP_AFTERRENDERTARGETDRAW_LAYER","_drawRenderTargetForeground","_i","layer","_rebuild","length","dispose","predicate","setDepthBuffer","render","isBackground","cameraLayerMask","renderOnlyInRenderTargetTextures","layerMask","camera","_draw","_this","_drawCameraPredicate","renderTargetTexture","renderTargetTextures","indexOf","renderTarget","_drawRenderTargetPredicate","activeCamera","container","forEach","push","index","splice"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/layerSceneComponent.ts"],"sourcesContent":["import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number): boolean {\r\n        return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && (layer.layerMask & cameraLayerMask) !== 0;\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForeground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForeground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}