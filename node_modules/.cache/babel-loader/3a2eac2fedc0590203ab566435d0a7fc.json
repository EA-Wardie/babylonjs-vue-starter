{"ast":null,"code":"import \"core-js/modules/es.array.reverse.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n * @param options the constructors options used to shape the mesh.\n * @returns the capsule VertexData\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/capsule\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport function CreateCapsuleVertexData(options) {\n  if (options === void 0) {\n    options = {\n      subdivisions: 2,\n      tessellation: 16,\n      height: 1,\n      radius: 0.25,\n      capSubdivisions: 6\n    };\n  }\n\n  var subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n  var tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n  var height = Math.max(options.height ? options.height : 1, 0);\n  var radius = Math.max(options.radius ? options.radius : 0.25, 0);\n  var capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n  var radialSegments = tessellation;\n  var heightSegments = subdivisions;\n  var radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\n  var radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\n  var heightMinusCaps = height - (radiusTop + radiusBottom);\n  var thetaStart = 0.0;\n  var thetaLength = 2.0 * Math.PI;\n  var capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n  var capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n  var alpha = Math.acos((radiusBottom - radiusTop) / height);\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var index = 0;\n  var indexArray = [],\n      halfHeight = heightMinusCaps * 0.5;\n  var pi2 = Math.PI * 0.5;\n  var x, y;\n  var normal = Vector3.Zero();\n  var vertex = Vector3.Zero();\n  var cosAlpha = Math.cos(alpha);\n  var sinAlpha = Math.sin(alpha);\n  var coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length(); // Total length for v texture coord\n\n  var vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\n  var v = 0;\n\n  for (y = 0; y <= capsTopSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha * (y / capsTopSegments);\n    v += radiusTop * alpha / capsTopSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusTop;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + sinA * radiusTop;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  var coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n  var slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;\n\n  for (y = 1; y <= heightSegments; y++) {\n    var indexRow = [];\n    v += coneLength / heightSegments; // calculate the radius of the current row\n\n    var _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(sinTheta, slope, cosTheta).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  for (y = 1; y <= capsBottomSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n    v += radiusBottom * alpha / capsBottomSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusBottom;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = -halfHeight + sinA * radiusBottom;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  } // generate indices\n\n\n  for (x = 0; x < radialSegments; x++) {\n    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n      // we use the index array to access the correct indices\n      var i1 = indexArray[y][x];\n      var i2 = indexArray[y + 1][x];\n      var i3 = indexArray[y + 1][x + 1];\n      var i4 = indexArray[y][x + 1]; // face one\n\n      indices.push(i1);\n      indices.push(i2);\n      indices.push(i4); // face two\n\n      indices.push(i2);\n      indices.push(i3);\n      indices.push(i4);\n    }\n  }\n\n  indices = indices.reverse();\n\n  if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n    var m = new Matrix();\n    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);\n    var v_1 = Vector3.Zero();\n\n    for (var i = 0; i < vertices.length; i += 3) {\n      v_1.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n      Vector3.TransformCoordinatesToRef(v_1.clone(), m, v_1);\n      vertices[i] = v_1.x;\n      vertices[i + 1] = v_1.y;\n      vertices[i + 2] = v_1.z;\n    }\n  }\n\n  var vDat = new VertexData();\n  vDat.positions = vertices;\n  vDat.normals = normals;\n  vDat.uvs = uvs;\n  vDat.indices = indices;\n  return vDat;\n}\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh\n * @param options The constructors options.\n * @param scene The scene the mesh is scoped to.\n * @returns Capsule Mesh\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport function CreateCapsule(name, options, scene) {\n  if (options === void 0) {\n    options = {\n      orientation: Vector3.Up(),\n      subdivisions: 2,\n      tessellation: 16,\n      height: 1,\n      radius: 0.25,\n      capSubdivisions: 6,\n      updatable: false\n    };\n  }\n\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var capsule = new Mesh(name, scene);\n  var vertexData = CreateCapsuleVertexData(options);\n  vertexData.applyToMesh(capsule, options.updatable);\n  return capsule;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateCapsule directly\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var CapsuleBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCapsule: CreateCapsule\n};\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh.\n * @param options the constructors options used to shape the mesh.\n * @param scene defines the scene the mesh is scoped to.\n * @returns the capsule mesh\n * @see https://doc.babylonjs.com/how_to/capsule_shape\n */\n\nMesh.CreateCapsule = function (name, options, scene) {\n  return CreateCapsule(name, options, scene);\n};\n\nVertexData.CreateCapsule = CreateCapsuleVertexData;","map":{"version":3,"mappings":"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","names":["VertexData","Vector2","Vector3","Matrix","Mesh","CompatibilityOptions","CreateCapsuleVertexData","options","subdivisions","tessellation","height","radius","capSubdivisions","Math","max","capDetail","radialSegments","heightSegments","radiusTop","radiusBottom","heightMinusCaps","thetaStart","thetaLength","PI","capsTopSegments","topCapSubdivisions","capsBottomSegments","bottomCapSubdivisions","alpha","acos","indices","vertices","normals","uvs","index","indexArray","halfHeight","pi2","x","y","normal","Zero","vertex","cosAlpha","cos","sinAlpha","sin","coneLength","subtract","length","vl","v","indexRow","a","cosA","sinA","_radius","u","theta","sinTheta","cosTheta","z","push","set","UseOpenGLOrientationForUV","coneHeight","slope","normalize","i1","i2","i3","i4","reverse","orientation","equals","Up","m","clone","scale","cross","toQuaternion","toRotationMatrix","v_1","i","TransformCoordinatesToRef","vDat","positions","CreateCapsule","name","scene","updatable","capsule","vertexData","applyToMesh","CapsuleBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/capsuleBuilder.ts"],"sourcesContent":["import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/capsule\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsuleVertexData(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n    }\r\n): VertexData {\r\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\r\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\r\n    const height = Math.max(options.height ? options.height : 1, 0);\r\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\r\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\r\n\r\n    const radialSegments = tessellation;\r\n    const heightSegments = subdivisions;\r\n\r\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\r\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\r\n\r\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    const thetaStart = 0.0;\r\n    const thetaLength = 2.0 * Math.PI;\r\n\r\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    let indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    let index = 0;\r\n    const indexArray = [],\r\n        halfHeight = heightMinusCaps * 0.5;\r\n    const pi2 = Math.PI * 0.5;\r\n\r\n    let x, y;\r\n    const normal = Vector3.Zero();\r\n    const vertex = Vector3.Zero();\r\n\r\n    const cosAlpha = Math.cos(alpha);\r\n    const sinAlpha = Math.sin(alpha);\r\n\r\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\r\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\r\n        .length();\r\n\r\n    // Total length for v texture coord\r\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\r\n\r\n    let v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n        const indexRow = [];\r\n\r\n        const a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += (radiusTop * alpha) / capsTopSegments;\r\n\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        const indexRow = [];\r\n        v += coneLength / heightSegments;\r\n        // calculate the radius of the current row\r\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        const indexRow = [];\r\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += (radiusBottom * alpha) / capsBottomSegments;\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\r\n            // we use the index array to access the correct indices\r\n            const i1 = indexArray[y][x];\r\n            const i2 = indexArray[y + 1][x];\r\n            const i3 = indexArray[y + 1][x + 1];\r\n            const i4 = indexArray[y][x + 1];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        const m = new Matrix();\r\n        options.orientation\r\n            .clone()\r\n            .scale(Math.PI * 0.5)\r\n            .cross(Vector3.Up())\r\n            .toQuaternion()\r\n            .toRotationMatrix(m);\r\n        const v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    const vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n}\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions {\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions?: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation?: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height?: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius?: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions?: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n\r\n    /** Internal geometry is supposed to change once created. */\r\n    updatable?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh\r\n * @param options The constructors options.\r\n * @param scene The scene the mesh is scoped to.\r\n * @returns Capsule Mesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsule(\r\n    name: string,\r\n    options: ICreateCapsuleOptions = {\r\n        orientation: Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n        updatable: false,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const capsule = new Mesh(name, scene);\r\n    const vertexData = CreateCapsuleVertexData(options);\r\n    vertexData.applyToMesh(capsule, options.updatable);\r\n    return capsule;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateCapsule directly\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const CapsuleBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCapsule,\r\n};\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\n(Mesh as any).CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh => {\r\n    return CreateCapsule(name, options, scene);\r\n};\r\n\r\nVertexData.CreateCapsule = CreateCapsuleVertexData;\r\n"]},"metadata":{},"sourceType":"module"}