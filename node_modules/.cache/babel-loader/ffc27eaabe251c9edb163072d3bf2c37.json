{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Base block used to read a reflection texture from a sampler\n */\n\nvar ReflectionTextureBaseBlock =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionTextureBaseBlock, _super);\n  /**\n   * Create a new ReflectionTextureBaseBlock\n   * @param name defines the block name\n   */\n\n\n  function ReflectionTextureBaseBlock(name) {\n    return _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n  }\n\n  Object.defineProperty(ReflectionTextureBaseBlock.prototype, \"texture\", {\n    /**\n     * Gets or sets the texture associated with the node\n     */\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(texture) {\n      var _this = this;\n\n      var _a;\n\n      if (this._texture === texture) {\n        return;\n      }\n\n      var scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n\n      if (!texture && scene) {\n        scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this._texture);\n        });\n      }\n\n      this._texture = texture;\n\n      if (texture && scene) {\n        scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(texture);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n\n  ReflectionTextureBaseBlock.prototype.getClassName = function () {\n    return \"ReflectionTextureBaseBlock\";\n  };\n\n  ReflectionTextureBaseBlock.prototype._getTexture = function () {\n    return this.texture;\n  };\n\n  ReflectionTextureBaseBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.world.isConnected) {\n      var worldInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.World;\n      });\n\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n\n      worldInput.output.connectTo(this.world);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  ReflectionTextureBaseBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    var texture = this._getTexture();\n\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  };\n\n  ReflectionTextureBaseBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ReflectionTextureBaseBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    var texture = this._getTexture();\n\n    if (!mesh || !texture) {\n      return;\n    }\n\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n\n    if (texture.boundingBoxSize) {\n      var cubeTexture = texture;\n      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\n      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\n    }\n  };\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleVertexSide = function (state) {\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n\n    var code = \"\";\n    var worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\n\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += \"\".concat(worldPosVaryingName, \" = \").concat(this.worldPosition.associatedVariableName, \";\\r\\n\");\n    }\n\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n\n    if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += \"#ifdef \".concat(this._defineSkyboxName, \"\\r\\n\");\n      code += \"\".concat(this._positionUVWName, \" = \").concat(this.position.associatedVariableName, \".xyz;\\r\\n\");\n      code += \"#endif\\r\\n\";\n    }\n\n    if (state._emitVaryingFromString(this._directionWName, \"vec3\", \"defined(\".concat(this._defineEquirectangularFixedName, \") || defined(\").concat(this._defineMirroredEquirectangularFixedName, \")\"))) {\n      code += \"#if defined(\".concat(this._defineEquirectangularFixedName, \") || defined(\").concat(this._defineMirroredEquirectangularFixedName, \")\\r\\n\");\n      code += \"\".concat(this._directionWName, \" = normalize(vec3(\").concat(this.world.associatedVariableName, \" * vec4(\").concat(this.position.associatedVariableName, \".xyz, 0.0)));\\r\\n\");\n      code += \"#endif\\r\\n\";\n    }\n\n    return code;\n  };\n  /**\n   * Handles the inits for the fragment code path\n   * @param state node material build state\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideInits = function (state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += \"#ifdef \".concat(this._define3DName, \"\\r\\n\");\n    state._samplerDeclaration += \"uniform samplerCube \".concat(this._cubeSamplerName, \";\\r\\n\");\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \".concat(this._2DSamplerName, \";\\r\\n\");\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    var comments = \"//\".concat(this.name);\n\n    state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n    this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\n\n    state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\n\n    this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\n\n    state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\n  };\n  /**\n   * Generates the reflection coords code for the fragment code path\n   * @param worldNormalVarName name of the world normal variable\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\n   * @param doNotEmitInvertZ if true, does not emit the invertZ code\n   * @returns the shader code\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionCoords = function (worldNormalVarName, worldPos, onlyReflectionVector, doNotEmitInvertZ) {\n    if (onlyReflectionVector === void 0) {\n      onlyReflectionVector = false;\n    }\n\n    if (doNotEmitInvertZ === void 0) {\n      doNotEmitInvertZ = false;\n    }\n\n    if (!worldPos) {\n      worldPos = \"v_\".concat(this.worldPosition.associatedVariableName);\n    }\n\n    var reflectionMatrix = this._reflectionMatrixName;\n    var direction = \"normalize(\".concat(this._directionWName, \")\");\n    var positionUVW = \"\".concat(this._positionUVWName);\n    var vEyePosition = \"\".concat(this.cameraPosition.associatedVariableName);\n    var view = \"\".concat(this.view.associatedVariableName);\n    worldNormalVarName += \".xyz\";\n    var code = \"\\n            #ifdef \".concat(this._defineMirroredEquirectangularFixedName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeMirroredFixedEquirectangularCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(direction, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineEquirectangularFixedName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeFixedEquirectangularCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(direction, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineEquirectangularName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeEquirectangularCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(vEyePosition, \".xyz, \").concat(reflectionMatrix, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineSphericalName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeSphericalCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(view, \", \").concat(reflectionMatrix, \");\\n            #endif\\n\\n            #ifdef \").concat(this._definePlanarName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computePlanarCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(vEyePosition, \".xyz, \").concat(reflectionMatrix, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineCubicName, \"\\n                #ifdef \").concat(this._defineLocalCubicName, \"\\n                    vec3 \").concat(this._reflectionVectorName, \" = computeCubicLocalCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(vEyePosition, \".xyz, \").concat(reflectionMatrix, \", \").concat(this._reflectionSizeName, \", \").concat(this._reflectionPositionName, \");\\n                #else\\n                vec3 \").concat(this._reflectionVectorName, \" = computeCubicCoords(\").concat(worldPos, \", \").concat(worldNormalVarName, \", \").concat(vEyePosition, \".xyz, \").concat(reflectionMatrix, \");\\n                #endif\\n            #endif\\n\\n            #ifdef \").concat(this._defineProjectionName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeProjectionCoords(\").concat(worldPos, \", \").concat(view, \", \").concat(reflectionMatrix, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineSkyboxName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = computeSkyBoxCoords(\").concat(positionUVW, \", \").concat(reflectionMatrix, \");\\n            #endif\\n\\n            #ifdef \").concat(this._defineExplicitName, \"\\n                vec3 \").concat(this._reflectionVectorName, \" = vec3(0, 0, 0);\\n            #endif\\r\\n\");\n\n    if (!doNotEmitInvertZ) {\n      code += \"#ifdef \".concat(this._defineOppositeZ, \"\\n                \").concat(this._reflectionVectorName, \".z *= -1.0;\\n            #endif\\r\\n\");\n    }\n\n    if (!onlyReflectionVector) {\n      code += \"\\n                #ifdef \".concat(this._define3DName, \"\\n                    vec3 \").concat(this._reflectionCoordsName, \" = \").concat(this._reflectionVectorName, \";\\n                #else\\n                    vec2 \").concat(this._reflectionCoordsName, \" = \").concat(this._reflectionVectorName, \".xy;\\n                    #ifdef \").concat(this._defineProjectionName, \"\\n                        \").concat(this._reflectionCoordsName, \" /= \").concat(this._reflectionVectorName, \".z;\\n                    #endif\\n                    \").concat(this._reflectionCoordsName, \".y = 1.0 - \").concat(this._reflectionCoordsName, \".y;\\n                #endif\\r\\n\");\n    }\n\n    return code;\n  };\n  /**\n   * Generates the reflection color code for the fragment code path\n   * @param lodVarName name of the lod variable\n   * @param swizzleLookupTexture swizzle to use for the final color variable\n   * @returns the shader code\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionColor = function (lodVarName, swizzleLookupTexture) {\n    if (swizzleLookupTexture === void 0) {\n      swizzleLookupTexture = \".rgb\";\n    }\n\n    var colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    var code = \"\".concat(colorType, \" \").concat(this._reflectionColorName, \";\\n            #ifdef \").concat(this._define3DName, \"\\r\\n\");\n\n    if (lodVarName) {\n      code += \"\".concat(this._reflectionColorName, \" = textureCubeLodEXT(\").concat(this._cubeSamplerName, \", \").concat(this._reflectionVectorName, \", \").concat(lodVarName, \")\").concat(swizzleLookupTexture, \";\\r\\n\");\n    } else {\n      code += \"\".concat(this._reflectionColorName, \" = textureCube(\").concat(this._cubeSamplerName, \", \").concat(this._reflectionVectorName, \")\").concat(swizzleLookupTexture, \";\\r\\n\");\n    }\n\n    code += \"\\n            #else\\r\\n\";\n\n    if (lodVarName) {\n      code += \"\".concat(this._reflectionColorName, \" = texture2DLodEXT(\").concat(this._2DSamplerName, \", \").concat(this._reflectionCoordsName, \", \").concat(lodVarName, \")\").concat(swizzleLookupTexture, \";\\r\\n\");\n    } else {\n      code += \"\".concat(this._reflectionColorName, \" = texture2D(\").concat(this._2DSamplerName, \", \").concat(this._reflectionCoordsName, \")\").concat(swizzleLookupTexture, \";\\r\\n\");\n    }\n\n    code += \"#endif\\r\\n\";\n    return code;\n  };\n  /**\n   * Generates the code corresponding to the connected output points\n   * @param state node material build state\n   * @param varName name of the variable to output\n   * @returns the shader code\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.writeOutputs = function (state, varName) {\n    var code = \"\";\n\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (output.hasEndpoints) {\n          code += \"\".concat(this._declareOutput(output, state), \" = \").concat(varName, \".\").concat(output.name, \";\\r\\n\");\n        }\n      }\n    }\n\n    return code;\n  };\n\n  ReflectionTextureBaseBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    return this;\n  };\n\n  ReflectionTextureBaseBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    if (!this.texture) {\n      return codeString;\n    }\n\n    if (this.texture.isCube) {\n      var forcedExtension = this.texture.forcedExtension;\n      codeString += \"\".concat(this._codeVariableName, \".texture = new BABYLON.CubeTexture(\\\"\").concat(this.texture.name, \"\\\", undefined, undefined, \").concat(this.texture.noMipmap, \", null, undefined, undefined, undefined, \").concat(this.texture._prefiltered, \", \").concat(forcedExtension ? '\"' + forcedExtension + '\"' : \"null\", \");\\r\\n\");\n    } else {\n      codeString += \"\".concat(this._codeVariableName, \".texture = new BABYLON.Texture(\\\"\").concat(this.texture.name, \"\\\", null);\\r\\n\");\n    }\n\n    codeString += \"\".concat(this._codeVariableName, \".texture.coordinatesMode = \").concat(this.texture.coordinatesMode, \";\\r\\n\");\n    return codeString;\n  };\n\n  ReflectionTextureBaseBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ReflectionTextureBaseBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n  };\n\n  return ReflectionTextureBaseBlock;\n}(NodeMaterialBlock);\n\nexport { ReflectionTextureBaseBlock };\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockTargets","RegisterClass","InputBlock","NodeMaterialSystemValues","CubeTexture","Texture","EngineStore","__extends","name","_super","VertexAndFragment","Object","ReflectionTextureBaseBlock","_texture","texture","scene","getScene","_a","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","_this","material","position","isConnected","positionInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","world","worldInput","systemValue","World","setAsSystemValue","view","viewInput","View","mesh","nodeMaterial","defines","_areTexturesDirty","_getTexture","getTextureMatrix","setValue","_define3DName","isCube","_defineLocalCubicName","boundingBoxSize","_defineExplicitName","coordinatesMode","_defineSkyboxName","_defineCubicName","_defineSphericalName","_definePlanarName","_defineProjectionName","_defineEquirectangularName","_defineEquirectangularFixedName","_defineMirroredEquirectangularFixedName","isReadyOrNotBlocking","effect","setMatrix","_reflectionMatrixName","getReflectionTextureMatrix","setTexture","_cubeSamplerName","_2DSamplerName","cubeTexture","setVector3","_reflectionPositionName","boundingBoxPosition","_reflectionSizeName","state","_getFreeDefineName","_defineOppositeZ","_getFreeVariableName","_emitUniformFromString","code","worldPosVaryingName","worldPosition","associatedVariableName","_emitVaryingFromString","concat","_positionUVWName","_directionWName","sharedData","blockingBlocks","push","textureBlocks","samplers","_samplerDeclaration","blocksWithDefines","bindableBlocks","comments","_emitFunction","_emitFunctionFromInclude","replaceStrings","search","replace","_reflectionColorName","_reflectionVectorName","_reflectionCoordsName","worldNormalVarName","worldPos","onlyReflectionVector","doNotEmitInvertZ","reflectionMatrix","direction","positionUVW","vEyePosition","cameraPosition","lodVarName","swizzleLookupTexture","colorType","length","varName","target","Fragment","_outputs","_i","hasEndpoints","_declareOutput","_buildBlock","call","codeString","_dumpPropertiesCode","forcedExtension","_codeVariableName","noMipmap","_prefiltered","serializationObject","serialize","isRenderTarget","rootUrl","_deserialize","url","indexOf","Parse"],"sourceRoot":"","sources":["../../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @hidden */\r\n    public _define3DName: string;\r\n    /** @hidden */\r\n    public _defineCubicName: string;\r\n    /** @hidden */\r\n    public _defineExplicitName: string;\r\n    /** @hidden */\r\n    public _defineProjectionName: string;\r\n    /** @hidden */\r\n    public _defineLocalCubicName: string;\r\n    /** @hidden */\r\n    public _defineSphericalName: string;\r\n    /** @hidden */\r\n    public _definePlanarName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularName: string;\r\n    /** @hidden */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineSkyboxName: string;\r\n    /** @hidden */\r\n    public _defineOppositeZ: string;\r\n    /** @hidden */\r\n    public _cubeSamplerName: string;\r\n    /** @hidden */\r\n    public _2DSamplerName: string;\r\n    /** @hidden */\r\n    public _reflectionPositionName: string;\r\n    /** @hidden */\r\n    public _reflectionSizeName: string;\r\n\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @hidden */\r\n    public _reflectionCoordsName: string;\r\n    /** @hidden */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n\r\n    protected _texture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<BaseTexture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === Constants.TEXTURE_EXPLICIT_MODE, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === Constants.TEXTURE_SKYBOX_MODE, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === Constants.TEXTURE_CUBIC_MODE || texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === Constants.TEXTURE_SPHERICAL_MODE, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === Constants.TEXTURE_PLANAR_MODE, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === Constants.TEXTURE_PROJECTION_MODE, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === Constants.TEXTURE_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n\r\n        if ((<any>texture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>texture;\r\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        const worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\r\n            code += `${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (\r\n            state._emitVaryingFromString(\r\n                this._directionWName,\r\n                \"vec3\",\r\n                `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`\r\n            )\r\n        ) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\r\n            code += `${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }],\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n\r\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\r\n\r\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false, doNotEmitInvertZ = false): string {\r\n        if (!worldPos) {\r\n            worldPos = `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        const reflectionMatrix = this._reflectionMatrixName;\r\n        const direction = `normalize(${this._directionWName})`;\r\n        const positionUVW = `${this._positionUVWName}`;\r\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        const view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\\r\\n`;\r\n\r\n        if (!doNotEmitInvertZ) {\r\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\r\\n`;\r\n        }\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `#endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (const output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        if (this.texture.isCube) {\r\n            const forcedExtension = (this.texture as CubeTexture).forcedExtension;\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${\r\n                this.texture.noMipmap\r\n            }, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\r\\n`;\r\n        } else {\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\r\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\r\n"]},"metadata":{},"sourceType":"module"}