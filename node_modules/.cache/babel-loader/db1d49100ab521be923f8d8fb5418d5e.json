{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\nimport \"../Shaders/sprites.fragment.js\";\nimport \"../Shaders/sprites.vertex.js\";\n/**\n * Class used to render sprites.\n *\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\n */\n\nvar SpriteRenderer =\n/** @class */\nfunction () {\n  /**\n   * Creates a new sprite Renderer\n   * @param engine defines the engine the renderer works with\n   * @param capacity defines the maximum allowed number of sprites\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param scene defines the hosting scene\n   */\n  function SpriteRenderer(engine, capacity, epsilon, scene) {\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n    /**\n     * Blend mode use to render the particle, it can be any of\n     * the static undefined properties provided in this class.\n     * Default value is 2\n     */\n\n\n    this.blendMode = 2;\n    /**\n     * Gets or sets a boolean indicating if alpha mode is automatically\n     * reset.\n     */\n\n    this.autoResetAlpha = true;\n    /**\n     * Disables writing to the depth buffer when rendering the sprites.\n     * It can be handy to disable depth writing when using textures without alpha channel\n     * and setting some specific blend modes.\n     */\n\n    this.disableDepthWrite = false;\n    /**\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\n     */\n\n    this.fogEnabled = true;\n    this._useVAO = false;\n    this._useInstancing = false;\n    this._vertexBuffers = {};\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._engine = engine;\n    this._useInstancing = engine.getCaps().instancedArrays;\n    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n    this._scene = scene;\n    this._drawWrapperBase = new DrawWrapper(engine);\n    this._drawWrapperFog = new DrawWrapper(engine);\n    this._drawWrapperDepth = new DrawWrapper(engine, false);\n    this._drawWrapperFogDepth = new DrawWrapper(engine, false);\n\n    if (!this._useInstancing) {\n      this._buildIndexBuffer();\n    }\n\n    if (this._drawWrapperBase.drawContext) {\n      this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\n    }\n\n    if (this._drawWrapperFog.drawContext) {\n      this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\n    }\n\n    if (this._drawWrapperDepth.drawContext) {\n      this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\n    }\n\n    if (this._drawWrapperFogDepth.drawContext) {\n      this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\n    } // VBO\n    // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n    // 16 when using instances\n\n\n    this._vertexBufferSize = this._useInstancing ? 16 : 18;\n    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n\n    var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n\n    var options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n\n    var offset = 6;\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n    } else {\n      offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n      offset += 2;\n    }\n\n    var inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n\n    var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n\n    var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    this._vertexBuffers[\"options\"] = options;\n    this._vertexBuffers[\"offsets\"] = offsets;\n    this._vertexBuffers[\"inverts\"] = inverts;\n    this._vertexBuffers[\"cellInfo\"] = cellInfo;\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors; // Effects\n\n    this._drawWrapperBase.effect = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\");\n    this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\n    this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\n\n    if (this._scene) {\n      this._drawWrapperFog.effect = this._scene.getEngine().createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n      this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\n      this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\n    }\n  }\n\n  Object.defineProperty(SpriteRenderer.prototype, \"capacity\", {\n    /**\n     * Gets the capacity of the manager\n     */\n    get: function get() {\n      return this._capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Render all child sprites\n   * @param sprites defines the list of sprites to render\n   * @param deltaTime defines the time since last frame\n   * @param viewMatrix defines the viewMatrix to use to render the sprites\n   * @param projectionMatrix defines the projectionMatrix to use to render the sprites\n   * @param customSpriteUpdate defines a custom function to update the sprites data before they render\n   */\n\n  SpriteRenderer.prototype.render = function (sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate) {\n    if (customSpriteUpdate === void 0) {\n      customSpriteUpdate = null;\n    }\n\n    if (!this.texture || !this.texture.isReady() || !sprites.length) {\n      return;\n    }\n\n    var drawWrapper = this._drawWrapperBase;\n    var drawWrapperDepth = this._drawWrapperDepth;\n    var shouldRenderFog = false;\n\n    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n      drawWrapper = this._drawWrapperFog;\n      drawWrapperDepth = this._drawWrapperFogDepth;\n      shouldRenderFog = true;\n    }\n\n    var effect = drawWrapper.effect; // Check\n\n    if (!effect.isReady()) {\n      return;\n    }\n\n    var engine = this._engine;\n    var useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n    var baseSize = this.texture.getBaseSize(); // Sprites\n\n    var max = Math.min(this._capacity, sprites.length);\n    var offset = 0;\n    var noSprite = true;\n\n    for (var index = 0; index < max; index++) {\n      var sprite = sprites[index];\n\n      if (!sprite || !sprite.isVisible) {\n        continue;\n      }\n\n      noSprite = false;\n\n      sprite._animate(deltaTime);\n\n      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n      if (!this._useInstancing) {\n        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n      }\n    }\n\n    if (noSprite) {\n      return;\n    }\n\n    this._buffer.update(this._vertexData);\n\n    var culling = !!engine.depthCullingState.cull;\n    var zOffset = engine.depthCullingState.zOffset;\n    var zOffsetUnits = engine.depthCullingState.zOffsetUnits;\n    engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits); // Render\n\n    engine.enableEffect(drawWrapper);\n    effect.setTexture(\"diffuseSampler\", this.texture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", projectionMatrix); // Scene Info\n\n    if (shouldRenderFog) {\n      var scene = this._scene; // Fog\n\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n\n    if (this._useVAO) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // Draw order\n\n\n    engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;\n\n    if (!this.disableDepthWrite) {\n      effect.setBool(\"alphaTest\", true);\n      engine.setColorWrite(false);\n      engine.enableEffect(drawWrapperDepth);\n\n      if (this._useInstancing) {\n        engine.drawArraysType(7, 0, 4, offset);\n      } else {\n        engine.drawElementsType(0, 0, offset / 4 * 6);\n      }\n\n      engine.enableEffect(drawWrapper);\n      engine.setColorWrite(true);\n      effect.setBool(\"alphaTest\", false);\n    }\n\n    engine.setAlphaMode(this.blendMode);\n\n    if (this._useInstancing) {\n      engine.drawArraysType(7, 0, 4, offset);\n    } else {\n      engine.drawElementsType(0, 0, offset / 4 * 6);\n    }\n\n    if (this.autoResetAlpha) {\n      engine.setAlphaMode(0);\n    } // Restore Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\n    }\n\n    engine.unbindInstanceAttributes();\n  };\n\n  SpriteRenderer.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n    var arrayOffset = index * this._vertexBufferSize;\n\n    if (offsetX === 0) {\n      offsetX = this._epsilon;\n    } else if (offsetX === 1) {\n      offsetX = 1 - this._epsilon;\n    }\n\n    if (offsetY === 0) {\n      offsetY = this._epsilon;\n    } else if (offsetY === 1) {\n      offsetY = 1 - this._epsilon;\n    }\n\n    if (customSpriteUpdate) {\n      customSpriteUpdate(sprite, baseSize);\n    } else {\n      if (!sprite.cellIndex) {\n        sprite.cellIndex = 0;\n      }\n\n      var rowSize = baseSize.width / this.cellWidth;\n      var offset = sprite.cellIndex / rowSize >> 0;\n      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\n      sprite._yOffset = offset * this.cellHeight / baseSize.height;\n      sprite._xSize = this.cellWidth;\n      sprite._ySize = this.cellHeight;\n    } // Positions\n\n\n    this._vertexData[arrayOffset] = sprite.position.x;\n    this._vertexData[arrayOffset + 1] = sprite.position.y;\n    this._vertexData[arrayOffset + 2] = sprite.position.z;\n    this._vertexData[arrayOffset + 3] = sprite.angle; // Options\n\n    this._vertexData[arrayOffset + 4] = sprite.width;\n    this._vertexData[arrayOffset + 5] = sprite.height;\n\n    if (!this._useInstancing) {\n      this._vertexData[arrayOffset + 6] = offsetX;\n      this._vertexData[arrayOffset + 7] = offsetY;\n    } else {\n      arrayOffset -= 2;\n    } // Inverts according to Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n    } else {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n    }\n\n    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n    this._vertexData[arrayOffset + 10] = sprite._xOffset;\n    this._vertexData[arrayOffset + 11] = sprite._yOffset;\n    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height; // Color\n\n    this._vertexData[arrayOffset + 14] = sprite.color.r;\n    this._vertexData[arrayOffset + 15] = sprite.color.g;\n    this._vertexData[arrayOffset + 16] = sprite.color.b;\n    this._vertexData[arrayOffset + 17] = sprite.color.a;\n  };\n\n  SpriteRenderer.prototype._buildIndexBuffer = function () {\n    var indices = [];\n    var index = 0;\n\n    for (var count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\n   * Rebuilds the renderer (after a context lost, for eg)\n   */\n\n\n  SpriteRenderer.prototype.rebuild = function () {\n    var _a;\n\n    if (this._indexBuffer) {\n      this._buildIndexBuffer();\n    }\n\n    if (this._useVAO) {\n      this._vertexArrayObject = undefined;\n    }\n\n    this._buffer._rebuild();\n\n    for (var key in this._vertexBuffers) {\n      var vertexBuffer = this._vertexBuffers[key];\n\n      vertexBuffer._rebuild();\n    }\n\n    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n  };\n  /**\n   * Release associated resources\n   */\n\n\n  SpriteRenderer.prototype.dispose = function () {\n    if (this._buffer) {\n      this._buffer.dispose();\n\n      this._buffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n\n    this._drawWrapperBase.dispose();\n\n    this._drawWrapperFog.dispose();\n\n    this._drawWrapperDepth.dispose();\n\n    this._drawWrapperFogDepth.dispose();\n  };\n\n  return SpriteRenderer;\n}();\n\nexport { SpriteRenderer };","map":{"version":3,"mappings":"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","names":["Buffer","VertexBuffer","DrawWrapper","engine","capacity","epsilon","scene","_capacity","_epsilon","_engine","_useInstancing","getCaps","instancedArrays","_useVAO","vertexArrayObject","disableVertexArrayObjects","_scene","_drawWrapperBase","_drawWrapperFog","_drawWrapperDepth","_drawWrapperFogDepth","_buildIndexBuffer","drawContext","useInstancing","_vertexBufferSize","_vertexData","Float32Array","_buffer","positions","createVertexBuffer","PositionKind","options","offset","offsets","spriteData","_spriteBuffer","inverts","cellInfo","colors","ColorKind","_vertexBuffers","effect","createEffect","materialContext","getEngine","Object","SpriteRenderer","sprites","deltaTime","viewMatrix","projectionMatrix","customSpriteUpdate","texture","isReady","length","drawWrapper","drawWrapperDepth","shouldRenderFog","fogEnabled","fogMode","useRightHandedSystem","baseSize","getBaseSize","max","Math","min","noSprite","index","sprite","isVisible","_animate","_appendSpriteVertex","update","culling","depthCullingState","cull","zOffset","zOffsetUnits","setState","undefined","enableEffect","setTexture","setMatrix","setFloat4","fogStart","fogEnd","fogDensity","setColor3","fogColor","_vertexArrayObject","recordVertexArrayObject","_indexBuffer","bindVertexArrayObject","bindBuffers","depthFunc","useReverseDepthBuffer","disableDepthWrite","setBool","setColorWrite","drawArraysType","drawElementsType","setAlphaMode","blendMode","autoResetAlpha","unbindInstanceAttributes","offsetX","offsetY","arrayOffset","cellIndex","rowSize","width","cellWidth","_xOffset","_yOffset","cellHeight","height","_xSize","_ySize","position","x","y","z","angle","invertU","invertV","color","r","g","b","a","indices","count","push","createIndexBuffer","_rebuild","key","vertexBuffer","_a","dispose","_releaseBuffer","releaseVertexArrayObject"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Sprites/spriteRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IMatrixLike } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\n\r\ndeclare type ThinTexture = import(\"../Materials/Textures/thinTexture\").ThinTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\n\r\nimport \"../Shaders/sprites.fragment\";\r\nimport \"../Shaders/sprites.vertex\";\r\n\r\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\r\n */\r\nexport class SpriteRenderer {\r\n    /**\r\n     * Defines the texture of the spritesheet\r\n     */\r\n    public texture: Nullable<ThinTexture>;\r\n\r\n    /**\r\n     * Defines the default width of a cell in the spritesheet\r\n     */\r\n    public cellWidth: number;\r\n\r\n    /**\r\n     * Defines the default height of a cell in the spritesheet\r\n     */\r\n    public cellHeight: number;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public blendMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\r\n    public autoResetAlpha = true;\r\n\r\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\r\n    public fogEnabled = true;\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._capacity;\r\n    }\r\n\r\n    private readonly _engine: ThinEngine;\r\n    private readonly _useVAO: boolean = false;\r\n    private readonly _useInstancing: boolean = false;\r\n    private readonly _scene: Nullable<Scene>;\r\n\r\n    private readonly _capacity: number;\r\n    private readonly _epsilon: number;\r\n\r\n    private _vertexBufferSize: number;\r\n    private _vertexData: Float32Array;\r\n    private _buffer: Buffer;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: DataBuffer;\r\n    private _drawWrapperBase: DrawWrapper;\r\n    private _drawWrapperFog: DrawWrapper;\r\n    private _drawWrapperDepth: DrawWrapper;\r\n    private _drawWrapperFogDepth: DrawWrapper;\r\n    private _vertexArrayObject: WebGLVertexArrayObject;\r\n\r\n    /**\r\n     * Creates a new sprite Renderer\r\n     * @param engine defines the engine the renderer works with\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(engine: ThinEngine, capacity: number, epsilon: number = 0.01, scene: Nullable<Scene> = null) {\r\n        this._capacity = capacity;\r\n        this._epsilon = epsilon;\r\n\r\n        this._engine = engine;\r\n        this._useInstancing = engine.getCaps().instancedArrays;\r\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\r\n        this._scene = scene;\r\n        this._drawWrapperBase = new DrawWrapper(engine);\r\n        this._drawWrapperFog = new DrawWrapper(engine);\r\n        this._drawWrapperDepth = new DrawWrapper(engine, false);\r\n        this._drawWrapperFogDepth = new DrawWrapper(engine, false);\r\n\r\n        if (!this._useInstancing) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        if (this._drawWrapperBase.drawContext) {\r\n            this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFog.drawContext) {\r\n            this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperDepth.drawContext) {\r\n            this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFogDepth.drawContext) {\r\n            this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n\r\n        // VBO\r\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\r\n        // 16 when using instances\r\n        this._vertexBufferSize = this._useInstancing ? 16 : 18;\r\n        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\r\n        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\r\n\r\n        const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\r\n        const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\r\n\r\n        let offset = 6;\r\n        let offsets: VertexBuffer;\r\n\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\r\n        } else {\r\n            offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n            offset += 2;\r\n        }\r\n\r\n        const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n        const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\r\n        const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        this._vertexBuffers[\"options\"] = options;\r\n        this._vertexBuffers[\"offsets\"] = offsets;\r\n        this._vertexBuffers[\"inverts\"] = inverts;\r\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n\r\n        // Effects\r\n        this._drawWrapperBase.effect = this._engine.createEffect(\r\n            \"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"],\r\n            [\"diffuseSampler\"],\r\n            \"\"\r\n        );\r\n\r\n        this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\r\n        this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\r\n\r\n        if (this._scene) {\r\n            this._drawWrapperFog.effect = this._scene\r\n                .getEngine()\r\n                .createEffect(\r\n                    \"sprites\",\r\n                    [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n                    [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"],\r\n                    [\"diffuseSampler\"],\r\n                    \"#define FOG\"\r\n                );\r\n            this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\r\n            this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     * @param sprites defines the list of sprites to render\r\n     * @param deltaTime defines the time since last frame\r\n     * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n     * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n     * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n     */\r\n    public render(\r\n        sprites: ThinSprite[],\r\n        deltaTime: number,\r\n        viewMatrix: IMatrixLike,\r\n        projectionMatrix: IMatrixLike,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void> = null\r\n    ): void {\r\n        if (!this.texture || !this.texture.isReady() || !sprites.length) {\r\n            return;\r\n        }\r\n\r\n        let drawWrapper = this._drawWrapperBase;\r\n        let drawWrapperDepth = this._drawWrapperDepth;\r\n        let shouldRenderFog = false;\r\n        if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\r\n            drawWrapper = this._drawWrapperFog;\r\n            drawWrapperDepth = this._drawWrapperFogDepth;\r\n            shouldRenderFog = true;\r\n        }\r\n\r\n        const effect = drawWrapper.effect!;\r\n\r\n        // Check\r\n        if (!effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\r\n        const baseSize = this.texture.getBaseSize();\r\n\r\n        // Sprites\r\n        const max = Math.min(this._capacity, sprites.length);\r\n\r\n        let offset = 0;\r\n        let noSprite = true;\r\n        for (let index = 0; index < max; index++) {\r\n            const sprite = sprites[index];\r\n            if (!sprite || !sprite.isVisible) {\r\n                continue;\r\n            }\r\n\r\n            noSprite = false;\r\n            sprite._animate(deltaTime);\r\n\r\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            if (!this._useInstancing) {\r\n                this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            }\r\n        }\r\n\r\n        if (noSprite) {\r\n            return;\r\n        }\r\n\r\n        this._buffer.update(this._vertexData);\r\n\r\n        const culling = !!engine.depthCullingState.cull;\r\n        const zOffset = engine.depthCullingState.zOffset;\r\n        const zOffsetUnits = engine.depthCullingState.zOffsetUnits;\r\n\r\n        engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        effect.setTexture(\"diffuseSampler\", this.texture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", projectionMatrix);\r\n\r\n        // Scene Info\r\n        if (shouldRenderFog) {\r\n            const scene = this._scene!;\r\n\r\n            // Fog\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n            engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        } else {\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // Draw order\r\n        engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? Constants.GEQUAL : Constants.LEQUAL;\r\n        if (!this.disableDepthWrite) {\r\n            effect.setBool(\"alphaTest\", true);\r\n            engine.setColorWrite(false);\r\n            engine.enableEffect(drawWrapperDepth);\r\n            if (this._useInstancing) {\r\n                engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n            } else {\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n            }\r\n            engine.enableEffect(drawWrapper);\r\n            engine.setColorWrite(true);\r\n            effect.setBool(\"alphaTest\", false);\r\n        }\r\n\r\n        engine.setAlphaMode(this.blendMode);\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n        } else {\r\n            engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n        }\r\n\r\n        if (this.autoResetAlpha) {\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._scene!.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n    }\r\n\r\n    private _appendSpriteVertex(\r\n        index: number,\r\n        sprite: ThinSprite,\r\n        offsetX: number,\r\n        offsetY: number,\r\n        baseSize: ISize,\r\n        useRightHandedSystem: boolean,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void>\r\n    ): void {\r\n        let arrayOffset = index * this._vertexBufferSize;\r\n\r\n        if (offsetX === 0) {\r\n            offsetX = this._epsilon;\r\n        } else if (offsetX === 1) {\r\n            offsetX = 1 - this._epsilon;\r\n        }\r\n\r\n        if (offsetY === 0) {\r\n            offsetY = this._epsilon;\r\n        } else if (offsetY === 1) {\r\n            offsetY = 1 - this._epsilon;\r\n        }\r\n\r\n        if (customSpriteUpdate) {\r\n            customSpriteUpdate(sprite, baseSize);\r\n        } else {\r\n            if (!sprite.cellIndex) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n\r\n            const rowSize = baseSize.width / this.cellWidth;\r\n            const offset = (sprite.cellIndex / rowSize) >> 0;\r\n            sprite._xOffset = ((sprite.cellIndex - offset * rowSize) * this.cellWidth) / baseSize.width;\r\n            sprite._yOffset = (offset * this.cellHeight) / baseSize.height;\r\n            sprite._xSize = this.cellWidth;\r\n            sprite._ySize = this.cellHeight;\r\n        }\r\n\r\n        // Positions\r\n        this._vertexData[arrayOffset] = sprite.position.x;\r\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\r\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\r\n        this._vertexData[arrayOffset + 3] = sprite.angle;\r\n        // Options\r\n        this._vertexData[arrayOffset + 4] = sprite.width;\r\n        this._vertexData[arrayOffset + 5] = sprite.height;\r\n\r\n        if (!this._useInstancing) {\r\n            this._vertexData[arrayOffset + 6] = offsetX;\r\n            this._vertexData[arrayOffset + 7] = offsetY;\r\n        } else {\r\n            arrayOffset -= 2;\r\n        }\r\n\r\n        // Inverts according to Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\r\n        } else {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\r\n        }\r\n\r\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\r\n\r\n        this._vertexData[arrayOffset + 10] = sprite._xOffset;\r\n        this._vertexData[arrayOffset + 11] = sprite._yOffset;\r\n        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\r\n        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\r\n\r\n        // Color\r\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\r\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\r\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\r\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        const indices = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the renderer (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        if (this._indexBuffer) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            this._vertexArrayObject = undefined as any;\r\n        }\r\n\r\n        this._buffer._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n\r\n        this._spriteBuffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._buffer) {\r\n            this._buffer.dispose();\r\n            (<any>this._buffer) = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            (<any>this._indexBuffer) = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            (<any>this._vertexArrayObject) = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            (<any>this.texture) = null;\r\n        }\r\n        this._drawWrapperBase.dispose();\r\n        this._drawWrapperFog.dispose();\r\n        this._drawWrapperDepth.dispose();\r\n        this._drawWrapperFogDepth.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}