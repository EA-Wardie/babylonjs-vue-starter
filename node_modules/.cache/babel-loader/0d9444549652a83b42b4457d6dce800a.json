{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nvar anchorIdProvider = 0;\n/**\n * An implementation of the anchor system for WebXR.\n * For further information see https://github.com/immersive-web/anchors/\n */\n\nvar WebXRAnchorSystem =\n/** @class */\nfunction (_super) {\n  __extends(WebXRAnchorSystem, _super);\n  /**\n   * constructs a new anchor system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n\n\n  function WebXRAnchorSystem(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._lastFrameDetected = new Set();\n    _this._trackedAnchors = [];\n    _this._futureAnchors = [];\n    /**\n     * Observers registered here will be executed when a new anchor was added to the session\n     */\n\n    _this.onAnchorAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an anchor was removed from the session\n     */\n\n    _this.onAnchorRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing anchor updates\n     * This can execute N times every frame\n     */\n\n    _this.onAnchorUpdatedObservable = new Observable();\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    _this.xrNativeFeatureName = \"anchors\";\n    return _this;\n  }\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"referenceSpaceForFrameAnchors\", {\n    /**\n     * Set the reference space to use for anchor creation, when not using a hit test.\n     * Will default to the session's reference space if not defined\n     */\n    set: function set(referenceSpace) {\n      this._referenceSpaceForFrameAnchors = referenceSpace;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRAnchorSystem.prototype._populateTmpTransformation = function (position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  };\n  /**\n   * Create a new anchor point using a hit test result at a specific point in the scene\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param hitTestResult The hit test result to use for this anchor creation\n   * @param position an optional position offset for this anchor\n   * @param rotationQuaternion an optional rotation offset for this anchor\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorPointUsingHitTestResultAsync = function (hitTestResult, position, rotationQuaternion) {\n    if (position === void 0) {\n      position = new Vector3();\n    }\n\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var m, nativeAnchor_1, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            m = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!!hitTestResult.xrHitResult.createAnchor) return [3\n            /*break*/\n            , 1];\n            this.detach();\n            throw new Error(\"Anchors not enabled in this environment/browser\");\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , hitTestResult.xrHitResult.createAnchor(m)];\n\n          case 2:\n            nativeAnchor_1 = _a.sent();\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: nativeAnchor_1,\n                resolved: false,\n                submitted: true,\n                xrTransformation: m,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n\n          case 3:\n            error_1 = _a.sent();\n            throw new Error(error_1);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Add a new anchor at a specific position and rotation\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param position the position in which to add an anchor\n   * @param rotationQuaternion an optional rotation for the anchor transformation\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorAtPositionAndRotationAsync = function (position, rotationQuaternion, forceCreateInCurrentFrame) {\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    if (forceCreateInCurrentFrame === void 0) {\n      forceCreateInCurrentFrame = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var xrTransformation, xrAnchor, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            xrTransformation = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!(forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = undefined;\n            _b.label = 3;\n\n          case 3:\n            xrAnchor = _a; // add the transformation to the future anchors list\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: xrAnchor,\n                resolved: false,\n                submitted: false,\n                xrTransformation: xrTransformation,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"anchors\", {\n    /**\n     * Get the list of anchors currently being tracked by the system\n     */\n    get: function get() {\n      return this._trackedAnchors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n  WebXRAnchorSystem.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        var toRemove = this._trackedAnchors.pop();\n\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {// no-op\n          } // as the xr frame loop is removed, we need to notify manually\n\n\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n\n\n  WebXRAnchorSystem.prototype.dispose = function () {\n    this._futureAnchors.length = 0;\n\n    _super.prototype.dispose.call(this);\n\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  };\n\n  WebXRAnchorSystem.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    if (!this.attached || !frame) {\n      return;\n    }\n\n    var trackedAnchors = frame.trackedAnchors;\n\n    if (trackedAnchors) {\n      var toRemove = this._trackedAnchors.filter(function (anchor) {\n        return !trackedAnchors.has(anchor.xrAnchor);\n      }).map(function (anchor) {\n        var index = _this._trackedAnchors.indexOf(anchor);\n\n        return index;\n      });\n\n      var idxTracker_1 = 0;\n      toRemove.forEach(function (index) {\n        var anchor = _this._trackedAnchors.splice(index - idxTracker_1, 1)[0];\n\n        _this.onAnchorRemovedObservable.notifyObservers(anchor);\n\n        idxTracker_1++;\n      }); // now check for new ones\n\n      trackedAnchors.forEach(function (xrAnchor) {\n        if (!_this._lastFrameDetected.has(xrAnchor)) {\n          var newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: function remove() {\n              return xrAnchor[\"delete\"]();\n            }\n          };\n\n          var anchor = _this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n\n          _this._trackedAnchors.push(anchor);\n\n          _this.onAnchorAddedObservable.notifyObservers(anchor); // search for the future anchor promise that matches this\n\n\n          var results = _this._futureAnchors.filter(function (futureAnchor) {\n            return futureAnchor.nativeAnchor === xrAnchor;\n          });\n\n          var result = results[0];\n\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          var index = _this._findIndexInAnchorArray(xrAnchor);\n\n          var anchor = _this._trackedAnchors[index];\n\n          try {\n            // anchors update every frame\n            _this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n\n            _this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(\"Anchor could not be updated\");\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    } // process future anchors\n\n\n    this._futureAnchors.forEach(function (futureAnchor) {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        _this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(function (nativeAnchor) {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, function (error) {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n\n        futureAnchor.submitted = true;\n      }\n    });\n  };\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrAnchor the plane to find in the array\n   */\n\n\n  WebXRAnchorSystem.prototype._findIndexInAnchorArray = function (xrAnchor) {\n    for (var i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  WebXRAnchorSystem.prototype._updateAnchorWithXRFrame = function (xrAnchor, anchor, xrFrame) {\n    // matrix\n    var pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n\n    if (pose) {\n      var mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n\n      anchor.transformationMatrix = mat;\n\n      if (!this._options.worldParentNode) {// Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n\n    return anchor;\n  };\n\n  WebXRAnchorSystem.prototype._createAnchorAtTransformation = function (xrTransformation, xrFrame) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        if (xrFrame.createAnchor) {\n          try {\n            return [2\n            /*return*/\n            , xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace)];\n          } catch (error) {\n            throw new Error(error);\n          }\n        } else {\n          this.detach();\n          throw new Error(\"Anchors are not enabled in your browser\");\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRAnchorSystem.Version = 1;\n  return WebXRAnchorSystem;\n}(WebXRAbstractFeature);\n\nexport { WebXRAnchorSystem }; // register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRAnchorSystem(xrSessionManager, options);\n  };\n}, WebXRAnchorSystem.Version);","map":{"version":3,"mappings":"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","names":["WebXRFeatureName","WebXRFeaturesManager","Observable","Matrix","Vector3","Quaternion","WebXRAbstractFeature","Tools","anchorIdProvider","__extends","_xrSessionManager","_options","_super","_this","Set","xrNativeFeatureName","Object","WebXRAnchorSystem","referenceSpace","_referenceSpaceForFrameAnchors","position","rotationQuaternion","_tmpVector","copyFrom","_tmpQuaternion","scene","useRightHandedSystem","z","w","hitTestResult","_populateTmpTransformation","m","XRRigidTransform","x","y","xrHitResult","createAnchor","detach","Error","nativeAnchor_1","_a","Promise","resolve","reject","_futureAnchors","push","nativeAnchor","resolved","submitted","xrTransformation","error_1","forceCreateInCurrentFrame","attached","currentFrame","_createAnchorAtTransformation","xrAnchor","_trackedAnchors","call","doNotRemoveAnchorsOnSessionEnded","length","toRemove","pop","remove","e","onAnchorRemovedObservable","notifyObservers","dispose","onAnchorAddedObservable","clear","onAnchorUpdatedObservable","frame","trackedAnchors","filter","anchor","has","map","index","indexOf","idxTracker_1","forEach","splice","_lastFrameDetected","newAnchor","id","_updateAnchorWithXRFrame","results","futureAnchor","result","_findIndexInAnchorArray","attachedNode","transformationMatrix","decompose","scaling","Warn","then","error","i","xrFrame","pose","getPose","anchorSpace","mat","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","worldParentNode","multiplyToRef","getWorldMatrix","ANCHOR_SYSTEM","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRAnchorSystem.ts"],"sourcesContent":["import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRHitResult } from \"./WebXRHitTest\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created anchors will be kept until the next session starts\r\n     * If not defined, anchors will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveAnchorsOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n\r\n    /**\r\n     * if defined, this object will be constantly updated by the anchor's position and rotation\r\n     */\r\n    attachedNode?: TransformNode;\r\n\r\n    /**\r\n     * Remove this anchor from the scene\r\n     */\r\n    remove(): void;\r\n}\r\n\r\n/**\r\n * An internal interface for a future (promise based) anchor\r\n */\r\ninterface IWebXRFutureAnchor {\r\n    /**\r\n     * The native anchor\r\n     */\r\n    nativeAnchor?: XRAnchor;\r\n    /**\r\n     * Was this request submitted to the xr frame?\r\n     */\r\n    submitted: boolean;\r\n    /**\r\n     * Was this promise resolved already?\r\n     */\r\n    resolved: boolean;\r\n    /**\r\n     * A resolve function\r\n     */\r\n    resolve: (xrAnchor: IWebXRAnchor) => void;\r\n    /**\r\n     * A reject function\r\n     */\r\n    reject: (msg?: string) => void;\r\n    /**\r\n     * The XR Transformation of the future anchor\r\n     */\r\n    xrTransformation: XRRigidTransform;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    private _referenceSpaceForFrameAnchors: XRReferenceSpace;\r\n\r\n    private _futureAnchors: IWebXRFutureAnchor[] = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\r\n    public set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace) {\r\n        this._referenceSpaceForFrameAnchors = referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRAnchorSystemOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"anchors\";\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    private _populateTmpTransformation(position: Vector3, rotationQuaternion: Quaternion) {\r\n        this._tmpVector.copyFrom(position);\r\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\r\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n            this._tmpVector.z *= -1;\r\n            this._tmpQuaternion.z *= -1;\r\n            this._tmpQuaternion.w *= -1;\r\n        }\r\n        return {\r\n            position: this._tmpVector,\r\n            rotationQuaternion: this._tmpQuaternion,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a new anchor point using a hit test result at a specific point in the scene\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param hitTestResult The hit test result to use for this anchor creation\r\n     * @param position an optional position offset for this anchor\r\n     * @param rotationQuaternion an optional rotation offset for this anchor\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorPointUsingHitTestResultAsync(\r\n        hitTestResult: IWebXRHitResult,\r\n        position: Vector3 = new Vector3(),\r\n        rotationQuaternion: Quaternion = new Quaternion()\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const m = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        if (!hitTestResult.xrHitResult.createAnchor) {\r\n            this.detach();\r\n            throw new Error(\"Anchors not enabled in this environment/browser\");\r\n        } else {\r\n            try {\r\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\r\n                return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n                    this._futureAnchors.push({\r\n                        nativeAnchor,\r\n                        resolved: false,\r\n                        submitted: true,\r\n                        xrTransformation: m,\r\n                        resolve,\r\n                        reject,\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new anchor at a specific position and rotation\r\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param position the position in which to add an anchor\r\n     * @param rotationQuaternion an optional rotation for the anchor transformation\r\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorAtPositionAndRotationAsync(\r\n        position: Vector3,\r\n        rotationQuaternion: Quaternion = new Quaternion(),\r\n        forceCreateInCurrentFrame = false\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const xrTransformation = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        const xrAnchor =\r\n            forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame\r\n                ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)\r\n                : undefined;\r\n        // add the transformation to the future anchors list\r\n        return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n            this._futureAnchors.push({\r\n                nativeAnchor: xrAnchor,\r\n                resolved: false,\r\n                submitted: false,\r\n                xrTransformation,\r\n                resolve,\r\n                reject,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\r\n    public get anchors(): IWebXRAnchor[] {\r\n        return this._trackedAnchors;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\r\n            while (this._trackedAnchors.length) {\r\n                const toRemove = this._trackedAnchors.pop();\r\n                if (toRemove) {\r\n                    try {\r\n                        // try to natively remove it as well\r\n                        toRemove.remove();\r\n                    } catch (e) {\r\n                        // no-op\r\n                    }\r\n                    // as the xr frame loop is removed, we need to notify manually\r\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._futureAnchors.length = 0;\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors) {\r\n            const toRemove = this._trackedAnchors\r\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\r\n                .map((anchor) => {\r\n                    const index = this._trackedAnchors.indexOf(anchor);\r\n                    return index;\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor,\r\n                        remove: () => xrAnchor.delete(),\r\n                    };\r\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(anchor);\r\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\r\n                    // search for the future anchor promise that matches this\r\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\r\n                    const result = results[0];\r\n                    if (result) {\r\n                        result.resolve(anchor);\r\n                        result.resolved = true;\r\n                    }\r\n                } else {\r\n                    const index = this._findIndexInAnchorArray(xrAnchor);\r\n                    const anchor = this._trackedAnchors[index];\r\n                    try {\r\n                        // anchors update every frame\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        if (anchor.attachedNode) {\r\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\r\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\r\n                        }\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    } catch (e) {\r\n                        Tools.Warn(`Anchor could not be updated`);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n\r\n        // process future anchors\r\n        this._futureAnchors.forEach((futureAnchor) => {\r\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\r\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(\r\n                    (nativeAnchor) => {\r\n                        futureAnchor.nativeAnchor = nativeAnchor;\r\n                    },\r\n                    (error) => {\r\n                        futureAnchor.resolved = true;\r\n                        futureAnchor.reject(error);\r\n                    }\r\n                );\r\n                futureAnchor.submitted = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n\r\n    private async _createAnchorAtTransformation(xrTransformation: XRRigidTransform, xrFrame: XRFrame) {\r\n        if (xrFrame.createAnchor) {\r\n            try {\r\n                return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        } else {\r\n            this.detach();\r\n            throw new Error(\"Anchors are not enabled in your browser\");\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRAnchorSystem.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n    },\r\n    WebXRAnchorSystem.Version\r\n);\r\n"]},"metadata":{},"sourceType":"module"}