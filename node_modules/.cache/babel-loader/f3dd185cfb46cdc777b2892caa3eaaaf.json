{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @hidden\n */\n\nvar MaterialAnisotropicDefines =\n/** @class */\nfunction (_super) {\n  __extends(MaterialAnisotropicDefines, _super);\n\n  function MaterialAnisotropicDefines() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ANISOTROPIC = false;\n    _this.ANISOTROPIC_TEXTURE = false;\n    _this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n    _this.MAINUV1 = false;\n    return _this;\n  }\n\n  return MaterialAnisotropicDefines;\n}(MaterialDefines);\n\nexport { MaterialAnisotropicDefines };\n/**\n * Plugin that implements the anisotropic component of the PBR material\n */\n\nvar PBRAnisotropicConfiguration =\n/** @class */\nfunction (_super) {\n  __extends(PBRAnisotropicConfiguration, _super);\n\n  function PBRAnisotropicConfiguration(material, addToPluginList) {\n    if (addToPluginList === void 0) {\n      addToPluginList = true;\n    }\n\n    var _this = _super.call(this, material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList) || this;\n\n    _this._isEnabled = false;\n    /**\n     * Defines if the anisotropy is enabled in the material.\n     */\n\n    _this.isEnabled = false;\n    /**\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\n     */\n\n    _this.intensity = 1;\n    /**\n     * Defines if the effect is along the tangents, bitangents or in between.\n     * By default, the effect is \"stretching\" the highlights along the tangents.\n     */\n\n    _this.direction = new Vector2(1, 0);\n    _this._texture = null;\n    /**\n     * Stores the anisotropy values in a texture.\n     * rg is direction (like normal from -1 to 1)\n     * b is a intensity\n     */\n\n    _this.texture = null;\n    _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    return _this;\n  }\n  /** @hidden */\n\n\n  PBRAnisotropicConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._enable(this._isEnabled);\n\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n\n  PBRAnisotropicConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (!this._isEnabled) {\n      return true;\n    }\n\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  PBRAnisotropicConfiguration.prototype.prepareDefines = function (defines, scene, mesh) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n    }\n  };\n\n  PBRAnisotropicConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var isFrozen = this._material.isFrozen;\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      } // Anisotropy\n\n\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  };\n\n  PBRAnisotropicConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n\n  PBRAnisotropicConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  };\n\n  PBRAnisotropicConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  };\n\n  PBRAnisotropicConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  };\n\n  PBRAnisotropicConfiguration.prototype.getClassName = function () {\n    return \"PBRAnisotropicConfiguration\";\n  };\n\n  PBRAnisotropicConfiguration.prototype.addFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n\n    return currentRank;\n  };\n\n  PBRAnisotropicConfiguration.prototype.getSamplers = function (samplers) {\n    samplers.push(\"anisotropySampler\");\n  };\n\n  PBRAnisotropicConfiguration.prototype.getUniforms = function () {\n    return {\n      ubo: [{\n        name: \"vAnisotropy\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vAnisotropyInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"anisotropyMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }]\n    };\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n\n  __decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n\n  return PBRAnisotropicConfiguration;\n}(MaterialPluginBase);\n\nexport { PBRAnisotropicConfiguration };","map":{"version":3,"mappings":"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","names":["serialize","expandToProperty","serializeAsVector2","serializeAsTexture","VertexBuffer","Vector2","MaterialFlags","MaterialHelper","MaterialPluginBase","MaterialDefines","__extends","_this","material","addToPluginList","_super","MaterialAnisotropicDefines","_internalMarkAllSubMeshesAsTexturesDirty","_dirtyCallbacks","PBRAnisotropicConfiguration","_enable","_isEnabled","defines","scene","_areTexturesDirty","texturesEnabled","_texture","AnisotropicTextureEnabled","isReadyOrNotBlocking","mesh","ANISOTROPIC","isVerticesDataPresent","TangentKind","_needUVs","MAINUV1","PrepareDefinesForMergedUV","ANISOTROPIC_TEXTURE","uniformBuffer","isFrozen","_material","useUbo","isSync","updateFloat2","coordinatesIndex","level","BindTextureMatrix","updateFloat3","direction","x","y","intensity","setTexture","texture","activeTextures","push","animatables","animations","length","forceDisposeTextures","dispose","fallbacks","currentRank","addFallback","samplers","ubo","name","size","type","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/PBR/pbrAnisotropicConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\ndeclare type AbstractMesh = import(\"../../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type PBRBaseMaterial = import(\"./pbrBaseMaterial\").PBRBaseMaterial;\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}