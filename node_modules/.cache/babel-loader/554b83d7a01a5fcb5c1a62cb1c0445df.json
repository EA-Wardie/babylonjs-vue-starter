{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport { SceneSerializer } from \"./sceneSerializer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Light } from \"../Lights/light.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Skeleton } from \"../Bones/skeleton.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { MorphTargetManager } from \"../Morph/morphTargetManager.js\";\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SerializationHelper } from \"./decorators.js\";\n/**\n * Class used to record delta files between 2 scene states\n */\n\nvar SceneRecorder =\n/** @class */\nfunction () {\n  function SceneRecorder() {\n    this._trackedScene = null;\n  }\n  /**\n   * Track a given scene. This means the current scene state will be considered the original state\n   * @param scene defines the scene to track\n   */\n\n\n  SceneRecorder.prototype.track = function (scene) {\n    this._trackedScene = scene;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    this._savedJSON = SceneSerializer.Serialize(scene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n  };\n  /**\n   * Get the delta between current state and original state\n   * @returns a any containing the delta\n   */\n\n\n  SceneRecorder.prototype.getDelta = function () {\n    if (!this._trackedScene) {\n      return null;\n    }\n\n    var currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\n    Texture.ForceSerializeBuffers = false;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    var newJSON = SceneSerializer.Serialize(this._trackedScene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n    var deltaJSON = {};\n\n    for (var node in newJSON) {\n      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n    }\n\n    Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\n    return deltaJSON;\n  };\n\n  SceneRecorder.prototype._compareArray = function (key, original, current, deltaJSON) {\n    if (original.length === 0 && current.length === 0) {\n      return true;\n    } // Numbers?\n\n\n    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\n      if (original.length !== current.length) {\n        return false;\n      }\n\n      if (original.length === 0) {\n        return true;\n      }\n\n      for (var index = 0; index < original.length; index++) {\n        if (original[index] !== current[index]) {\n          deltaJSON[key] = current;\n          return false;\n        }\n      }\n\n      return true;\n    } // let's use uniqueId to find similar objects\n\n\n    var originalUniqueIds = [];\n\n    var _loop_1 = function _loop_1(index) {\n      var originalObject = original[index];\n      var originalUniqueId = originalObject.uniqueId;\n      originalUniqueIds.push(originalUniqueId); // Look for that object in current state\n\n      var currentObjects = current.filter(function (c) {\n        return c.uniqueId === originalUniqueId;\n      });\n\n      if (currentObjects.length) {\n        // We have a candidate\n        var currentObject = currentObjects[0];\n        var newObject = {};\n\n        if (!this_1._compareObjects(originalObject, currentObject, newObject)) {\n          if (!deltaJSON[key]) {\n            deltaJSON[key] = [];\n          }\n\n          newObject.__state = {\n            id: currentObject.id || currentObject.name\n          };\n          deltaJSON[key].push(newObject);\n        }\n      } else {\n        // We need to delete\n        var newObject = {\n          __state: {\n            deleteId: originalObject.id || originalObject.name\n          }\n        };\n        deltaJSON[key].push(newObject);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < original.length; index++) {\n      _loop_1(index);\n    } // Checking for new objects\n\n\n    for (var index = 0; index < current.length; index++) {\n      var currentObject = current[index];\n      var currentUniqueId = currentObject.uniqueId; // Object was added\n\n      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n\n        deltaJSON[key].push(currentObject);\n      }\n    }\n\n    return true;\n  };\n\n  SceneRecorder.prototype._compareObjects = function (originalObjet, currentObject, deltaJSON) {\n    var aDifferenceWasFound = false;\n\n    for (var prop in originalObjet) {\n      if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\n        continue;\n      }\n\n      var originalValue = originalObjet[prop];\n      var currentValue = currentObject[prop];\n      var diffFound = false;\n\n      if (Array.isArray(originalValue)) {\n        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\n        diffFound = originalValue !== currentValue;\n      } else if (_typeof(originalValue) === \"object\" && _typeof(currentValue) === \"object\") {\n        var newObject = {};\n\n        if (!this._compareObjects(originalValue, currentValue, newObject)) {\n          deltaJSON[prop] = newObject;\n          aDifferenceWasFound = true;\n        }\n      }\n\n      if (diffFound) {\n        aDifferenceWasFound = true;\n        deltaJSON[prop] = currentValue;\n      }\n    }\n\n    return !aDifferenceWasFound;\n  };\n\n  SceneRecorder.prototype._compareCollections = function (key, original, current, deltaJSON) {\n    // Same ?\n    if (original === current) {\n      return;\n    }\n\n    if (original && current) {\n      // Array?\n      if (Array.isArray(original) && Array.isArray(current)) {\n        if (this._compareArray(key, original, current, deltaJSON)) {\n          return;\n        }\n      } else if (_typeof(original) === \"object\" && _typeof(current) === \"object\") {\n        // Object\n        var newObject = {};\n\n        if (!this._compareObjects(original, current, newObject)) {\n          deltaJSON[key] = newObject;\n        }\n\n        return;\n      }\n    }\n  };\n\n  SceneRecorder.GetShadowGeneratorById = function (scene, id) {\n    var generators = scene.lights.map(function (l) {\n      return l.getShadowGenerator();\n    });\n\n    for (var _i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\n      var generator = generators_1[_i];\n\n      if (generator && generator.id === id) {\n        return generator;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Apply a given delta to a given scene\n   * @param deltaJSON defines the JSON containing the delta\n   * @param scene defines the scene to apply the delta to\n   */\n\n\n  SceneRecorder.ApplyDelta = function (deltaJSON, scene) {\n    var _this = this;\n\n    if (typeof deltaJSON === \"string\") {\n      deltaJSON = JSON.parse(deltaJSON);\n    } // Scene\n\n\n    var anyScene = scene;\n\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = anyScene[prop];\n\n      if (Array.isArray(property) || prop === \"shadowGenerators\") {\n        // Restore array\n        switch (prop) {\n          case \"cameras\":\n            this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), function (data) {\n              return Camera.Parse(data, scene);\n            });\n\n            break;\n\n          case \"lights\":\n            this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), function (data) {\n              return Light.Parse(data, scene);\n            });\n\n            break;\n\n          case \"shadowGenerators\":\n            this._ApplyDeltaForEntity(source, scene, function (id) {\n              return _this.GetShadowGeneratorById(scene, id);\n            }, function (data) {\n              return ShadowGenerator.Parse(data, scene);\n            });\n\n            break;\n\n          case \"meshes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), function (data) {\n              return Mesh.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"skeletons\":\n            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), function (data) {\n              return Skeleton.Parse(data, scene);\n            });\n\n            break;\n\n          case \"materials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), function (data) {\n              return Material.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"multiMaterials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), function (data) {\n              return MultiMaterial.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"transformNodes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), function (data) {\n              return TransformNode.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"particleSystems\":\n            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), function (data) {\n              return ParticleSystem.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"morphTargetManagers\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), function (data) {\n              return MorphTargetManager.Parse(data, scene);\n            });\n\n            break;\n\n          case \"postProcesses\":\n            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), function (data) {\n              return PostProcess.Parse(data, scene, \"\");\n            });\n\n            break;\n        }\n      } else if (!isNaN(property)) {\n        anyScene[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyPropertiesToEntity = function (deltaJSON, entity) {\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = entity[prop];\n\n      if (property === undefined) {\n        continue;\n      }\n\n      if (!isNaN(property) || Array.isArray(property)) {\n        entity[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      } else if (_typeof(property) === \"object\" && property !== null) {\n        this._ApplyPropertiesToEntity(source, property);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyDeltaForEntity = function (sources, scene, finder, addNew) {\n    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n      var source = sources_1[_i]; // Update\n\n      if (source.__state && source.__state.id !== undefined) {\n        var targetEntity = finder(source.__state.id);\n\n        if (targetEntity) {\n          this._ApplyPropertiesToEntity(source, targetEntity);\n        }\n      } else if (source.__state && source.__state.deleteId !== undefined) {\n        var target = finder(source.__state.deleteId);\n        target === null || target === void 0 ? void 0 : target.dispose();\n      } else {\n        // New\n        addNew(source);\n      }\n    }\n  };\n\n  return SceneRecorder;\n}();\n\nexport { SceneRecorder };","map":{"version":3,"mappings":"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","names":["SceneSerializer","Mesh","Light","Camera","Skeleton","Material","MultiMaterial","TransformNode","ParticleSystem","MorphTargetManager","ShadowGenerator","PostProcess","Texture","SerializationHelper","SceneRecorder","scene","_trackedScene","AllowLoadingUniqueId","_savedJSON","Serialize","currentForceSerializeBuffers","ForceSerializeBuffers","newJSON","deltaJSON","node","_compareCollections","key","original","current","length","isNaN","index","originalUniqueIds","originalObject","originalUniqueId","uniqueId","push","currentObjects","filter","c","currentObject","newObject","this_1","_compareObjects","__state","id","name","deleteId","currentUniqueId","indexOf","originalObjet","aDifferenceWasFound","prop","Object","prototype","hasOwnProperty","call","originalValue","currentValue","diffFound","Array","isArray","JSON","stringify","toString","_compareArray","generators","lights","map","l","getShadowGenerator","_i","generator","parse","anyScene","source","property","_ApplyDeltaForEntity","getCameraById","bind","data","Parse","getLightById","GetShadowGeneratorById","getMeshById","getSkeletonById","getMaterialById","getTransformNodeById","getParticleSystemById","getMorphTargetById","getPostProcessByName","fromArray","entity","undefined","_ApplyPropertiesToEntity","sources","finder","addNew","targetEntity","target","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/sceneRecorder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SceneSerializer } from \"./sceneSerializer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { ParticleSystem } from \"../Particles/particleSystem\";\r\nimport { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SerializationHelper } from \"./decorators\";\r\n\r\n/**\r\n * Class used to record delta files between 2 scene states\r\n */\r\nexport class SceneRecorder {\r\n    private _trackedScene: Nullable<Scene> = null;\r\n    private _savedJSON: any;\r\n\r\n    /**\r\n     * Track a given scene. This means the current scene state will be considered the original state\r\n     * @param scene defines the scene to track\r\n     */\r\n    public track(scene: Scene) {\r\n        this._trackedScene = scene;\r\n\r\n        SerializationHelper.AllowLoadingUniqueId = true;\r\n        this._savedJSON = SceneSerializer.Serialize(scene);\r\n        SerializationHelper.AllowLoadingUniqueId = false;\r\n    }\r\n\r\n    /**\r\n     * Get the delta between current state and original state\r\n     * @returns a any containing the delta\r\n     */\r\n    public getDelta(): any {\r\n        if (!this._trackedScene) {\r\n            return null;\r\n        }\r\n\r\n        const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\r\n        Texture.ForceSerializeBuffers = false;\r\n\r\n        SerializationHelper.AllowLoadingUniqueId = true;\r\n        const newJSON = SceneSerializer.Serialize(this._trackedScene);\r\n        SerializationHelper.AllowLoadingUniqueId = false;\r\n        const deltaJSON: any = {};\r\n\r\n        for (const node in newJSON) {\r\n            this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\r\n        }\r\n\r\n        Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\r\n\r\n        return deltaJSON;\r\n    }\r\n\r\n    private _compareArray(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        if (original.length === 0 && current.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        // Numbers?\r\n        if ((original.length && !isNaN(original[0])) || (current.length && !isNaN(current[0]))) {\r\n            if (original.length !== current.length) {\r\n                return false;\r\n            }\r\n\r\n            if (original.length === 0) {\r\n                return true;\r\n            }\r\n            for (let index = 0; index < original.length; index++) {\r\n                if (original[index] !== current[index]) {\r\n                    deltaJSON[key] = current;\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        // let's use uniqueId to find similar objects\r\n        const originalUniqueIds: number[] = [];\r\n        for (let index = 0; index < original.length; index++) {\r\n            const originalObject = original[index];\r\n            const originalUniqueId = originalObject.uniqueId;\r\n\r\n            originalUniqueIds.push(originalUniqueId);\r\n            // Look for that object in current state\r\n            const currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);\r\n            if (currentObjects.length) {\r\n                // We have a candidate\r\n                const currentObject = currentObjects[0];\r\n\r\n                const newObject: any = {};\r\n                if (!this._compareObjects(originalObject, currentObject, newObject)) {\r\n                    if (!deltaJSON[key]) {\r\n                        deltaJSON[key] = [];\r\n                    }\r\n                    newObject.__state = {\r\n                        id: currentObject.id || currentObject.name,\r\n                    };\r\n                    deltaJSON[key].push(newObject);\r\n                }\r\n            } else {\r\n                // We need to delete\r\n                const newObject: any = {\r\n                    __state: {\r\n                        deleteId: originalObject.id || originalObject.name,\r\n                    },\r\n                };\r\n                deltaJSON[key].push(newObject);\r\n            }\r\n        }\r\n\r\n        // Checking for new objects\r\n        for (let index = 0; index < current.length; index++) {\r\n            const currentObject = current[index];\r\n            const currentUniqueId = currentObject.uniqueId;\r\n\r\n            // Object was added\r\n            if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\r\n                if (!deltaJSON[key]) {\r\n                    deltaJSON[key] = [];\r\n                }\r\n\r\n                deltaJSON[key].push(currentObject);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _compareObjects(originalObjet: any, currentObject: any, deltaJSON: any) {\r\n        let aDifferenceWasFound = false;\r\n\r\n        for (const prop in originalObjet) {\r\n            if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\r\n                continue;\r\n            }\r\n            const originalValue = originalObjet[prop];\r\n            const currentValue = currentObject[prop];\r\n            let diffFound = false;\r\n\r\n            if (Array.isArray(originalValue)) {\r\n                diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\r\n            } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\r\n                diffFound = originalValue !== currentValue;\r\n            } else if (typeof originalValue === \"object\" && typeof currentValue === \"object\") {\r\n                const newObject = {};\r\n                if (!this._compareObjects(originalValue, currentValue, newObject)) {\r\n                    deltaJSON[prop] = newObject;\r\n                    aDifferenceWasFound = true;\r\n                }\r\n            }\r\n\r\n            if (diffFound) {\r\n                aDifferenceWasFound = true;\r\n                deltaJSON[prop] = currentValue;\r\n            }\r\n        }\r\n\r\n        return !aDifferenceWasFound;\r\n    }\r\n\r\n    private _compareCollections(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        // Same ?\r\n        if (original === current) {\r\n            return;\r\n        }\r\n\r\n        if (original && current) {\r\n            // Array?\r\n            if (Array.isArray(original) && Array.isArray(current)) {\r\n                if (this._compareArray(key, original, current, deltaJSON)) {\r\n                    return;\r\n                }\r\n            } else if (typeof original === \"object\" && typeof current === \"object\") {\r\n                // Object\r\n                const newObject = {};\r\n                if (!this._compareObjects(original, current, newObject)) {\r\n                    deltaJSON[key] = newObject;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static GetShadowGeneratorById(scene: Scene, id: string) {\r\n        const generators = scene.lights.map((l) => l.getShadowGenerator());\r\n\r\n        for (const generator of generators) {\r\n            if (generator && generator.id === id) {\r\n                return generator;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply a given delta to a given scene\r\n     * @param deltaJSON defines the JSON containing the delta\r\n     * @param scene defines the scene to apply the delta to\r\n     */\r\n    public static ApplyDelta(deltaJSON: any | string, scene: Scene) {\r\n        if (typeof deltaJSON === \"string\") {\r\n            deltaJSON = JSON.parse(deltaJSON);\r\n        }\r\n\r\n        // Scene\r\n        const anyScene = scene as any;\r\n        for (const prop in deltaJSON) {\r\n            const source = deltaJSON[prop];\r\n            const property = anyScene[prop];\r\n\r\n            if (Array.isArray(property) || prop === \"shadowGenerators\") {\r\n                // Restore array\r\n                switch (prop) {\r\n                    case \"cameras\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data) => Camera.Parse(data, scene));\r\n                        break;\r\n                    case \"lights\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data) => Light.Parse(data, scene));\r\n                        break;\r\n                    case \"shadowGenerators\":\r\n                        this._ApplyDeltaForEntity(\r\n                            source,\r\n                            scene,\r\n                            (id) => this.GetShadowGeneratorById(scene, id),\r\n                            (data) => ShadowGenerator.Parse(data, scene)\r\n                        );\r\n                        break;\r\n                    case \"meshes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data) => Mesh.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"skeletons\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));\r\n                        break;\r\n                    case \"materials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => Material.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"multiMaterials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => MultiMaterial.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"transformNodes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data) => TransformNode.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"particleSystems\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data) => ParticleSystem.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"morphTargetManagers\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));\r\n                        break;\r\n                    case \"postProcesses\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, \"\"));\r\n                        break;\r\n                }\r\n            } else if (!isNaN(property)) {\r\n                anyScene[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyPropertiesToEntity(deltaJSON: any, entity: any) {\r\n        for (const prop in deltaJSON) {\r\n            const source = deltaJSON[prop];\r\n            const property = entity[prop];\r\n\r\n            if (property === undefined) {\r\n                continue;\r\n            }\r\n\r\n            if (!isNaN(property) || Array.isArray(property)) {\r\n                entity[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            } else if (typeof property === \"object\" && property !== null) {\r\n                this._ApplyPropertiesToEntity(source, property);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyDeltaForEntity(sources: any[], scene: Scene, finder: (id: string) => any, addNew: (data: any) => void) {\r\n        for (const source of sources) {\r\n            // Update\r\n            if (source.__state && source.__state.id !== undefined) {\r\n                const targetEntity = finder(source.__state.id);\r\n\r\n                if (targetEntity) {\r\n                    this._ApplyPropertiesToEntity(source, targetEntity);\r\n                }\r\n            } else if (source.__state && source.__state.deleteId !== undefined) {\r\n                const target = finder(source.__state.deleteId);\r\n                target?.dispose();\r\n            } else {\r\n                // New\r\n                addNew(source);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}