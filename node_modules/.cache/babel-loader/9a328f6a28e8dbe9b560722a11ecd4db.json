{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nvar NAME = \"KHR_materials_variants\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_variants/README.md)\n */\n\nvar KHR_materials_variants =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_materials_variants(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  KHR_materials_variants.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /**\n   * Gets the list of available variant names for this asset.\n   * @param rootMesh The glTF root mesh\n   * @returns the list of all the variant names for this model\n   */\n\n\n  KHR_materials_variants.GetAvailableVariants = function (rootMesh) {\n    var extensionMetadata = this._GetExtensionMetadata(rootMesh);\n\n    if (!extensionMetadata) {\n      return [];\n    }\n\n    return Object.keys(extensionMetadata.variants);\n  };\n  /**\n   * Gets the list of available variant names for this asset.\n   * @param rootMesh The glTF root mesh\n   * @returns the list of all the variant names for this model\n   */\n\n\n  KHR_materials_variants.prototype.getAvailableVariants = function (rootMesh) {\n    return KHR_materials_variants.GetAvailableVariants(rootMesh);\n  };\n  /**\n   * Select a variant given a variant name or a list of variant names.\n   * @param rootMesh The glTF root mesh\n   * @param variantName The variant name(s) to select.\n   */\n\n\n  KHR_materials_variants.SelectVariant = function (rootMesh, variantName) {\n    var extensionMetadata = this._GetExtensionMetadata(rootMesh);\n\n    if (!extensionMetadata) {\n      throw new Error(\"Cannot select variant on a glTF mesh that does not have the \".concat(NAME, \" extension\"));\n    }\n\n    var select = function select(variantName) {\n      var entries = extensionMetadata.variants[variantName];\n\n      if (entries) {\n        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n          var entry = entries_1[_i];\n          entry.mesh.material = entry.material;\n        }\n      }\n    };\n\n    if (variantName instanceof Array) {\n      for (var _i = 0, variantName_1 = variantName; _i < variantName_1.length; _i++) {\n        var name_1 = variantName_1[_i];\n        select(name_1);\n      }\n    } else {\n      select(variantName);\n    }\n\n    extensionMetadata.lastSelected = variantName;\n  };\n  /**\n   * Select a variant given a variant name or a list of variant names.\n   * @param rootMesh The glTF root mesh\n   * @param variantName The variant name(s) to select.\n   */\n\n\n  KHR_materials_variants.prototype.selectVariant = function (rootMesh, variantName) {\n    return KHR_materials_variants.SelectVariant(rootMesh, variantName);\n  };\n  /**\n   * Reset back to the original before selecting a variant.\n   * @param rootMesh The glTF root mesh\n   */\n\n\n  KHR_materials_variants.Reset = function (rootMesh) {\n    var extensionMetadata = this._GetExtensionMetadata(rootMesh);\n\n    if (!extensionMetadata) {\n      throw new Error(\"Cannot reset on a glTF mesh that does not have the \".concat(NAME, \" extension\"));\n    }\n\n    for (var _i = 0, _a = extensionMetadata.original; _i < _a.length; _i++) {\n      var entry = _a[_i];\n      entry.mesh.material = entry.material;\n    }\n\n    extensionMetadata.lastSelected = null;\n  };\n  /**\n   * Reset back to the original before selecting a variant.\n   * @param rootMesh The glTF root mesh\n   */\n\n\n  KHR_materials_variants.prototype.reset = function (rootMesh) {\n    return KHR_materials_variants.Reset(rootMesh);\n  };\n  /**\n   * Gets the last selected variant name(s) or null if original.\n   * @param rootMesh The glTF root mesh\n   * @returns The selected variant name(s).\n   */\n\n\n  KHR_materials_variants.GetLastSelectedVariant = function (rootMesh) {\n    var extensionMetadata = this._GetExtensionMetadata(rootMesh);\n\n    if (!extensionMetadata) {\n      throw new Error(\"Cannot get the last selected variant on a glTF mesh that does not have the \".concat(NAME, \" extension\"));\n    }\n\n    return extensionMetadata.lastSelected;\n  };\n  /**\n   * Gets the last selected variant name(s) or null if original.\n   * @param rootMesh The glTF root mesh\n   * @returns The selected variant name(s).\n   */\n\n\n  KHR_materials_variants.prototype.getLastSelectedVariant = function (rootMesh) {\n    return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\n  };\n\n  KHR_materials_variants._GetExtensionMetadata = function (rootMesh) {\n    var _a, _b;\n\n    return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh.metadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;\n  };\n  /** @hidden */\n\n\n  KHR_materials_variants.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._variants = extension.variants;\n    }\n  };\n  /**\n   * @param context\n   * @param name\n   * @param node\n   * @param mesh\n   * @param primitive\n   * @param assign\n   * @hidden\n   */\n\n\n  KHR_materials_variants.prototype._loadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, function (babylonMesh) {\n        assign(babylonMesh);\n\n        if (babylonMesh instanceof Mesh) {\n          var babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n\n          var root_1 = _this._loader.rootBabylonMesh;\n          var metadata = root_1 ? root_1.metadata = root_1.metadata || {} : {};\n          var gltf = metadata.gltf = metadata.gltf || {};\n          var extensionMetadata_1 = gltf[NAME] = gltf[NAME] || {\n            lastSelected: null,\n            original: [],\n            variants: {}\n          }; // Store the original material.\n\n          extensionMetadata_1.original.push({\n            mesh: babylonMesh,\n            material: babylonMesh.material\n          });\n\n          var _loop_1 = function _loop_1(mappingIndex) {\n            var mapping = extension.mappings[mappingIndex];\n            var material = ArrayItem.Get(\"\".concat(extensionContext, \"/mappings/\").concat(mappingIndex, \"/material\"), _this._loader.gltf.materials, mapping.material);\n            promises.push(_this._loader._loadMaterialAsync(\"#/materials/\".concat(mapping.material), material, babylonMesh, babylonDrawMode, function (babylonMaterial) {\n              var _loop_2 = function _loop_2(mappingVariantIndex) {\n                var variantIndex = mapping.variants[mappingVariantIndex];\n                var variant = ArrayItem.Get(\"/extensions/\".concat(NAME, \"/variants/\").concat(variantIndex), _this._variants, variantIndex);\n                extensionMetadata_1.variants[variant.name] = extensionMetadata_1.variants[variant.name] || [];\n                extensionMetadata_1.variants[variant.name].push({\n                  mesh: babylonMesh,\n                  material: babylonMaterial\n                }); // Replace the target when original mesh is cloned\n\n                babylonMesh.onClonedObservable.add(function (newOne) {\n                  var newMesh = newOne;\n                  var metadata = null;\n                  var newRoot = newMesh; // Find root to get medata\n\n                  do {\n                    newRoot = newRoot.parent;\n\n                    if (!newRoot) {\n                      return;\n                    }\n\n                    metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);\n                  } while (metadata === null); // Need to clone the metadata on the root (first time only)\n\n\n                  if (root_1 && metadata === KHR_materials_variants._GetExtensionMetadata(root_1)) {\n                    // Copy main metadata\n                    newRoot.metadata = {};\n\n                    for (var key in root_1.metadata) {\n                      newRoot.metadata[key] = root_1.metadata[key];\n                    } // Copy the gltf metadata\n\n\n                    newRoot.metadata.gltf = [];\n\n                    for (var key in root_1.metadata.gltf) {\n                      newRoot.metadata.gltf[key] = root_1.metadata.gltf[key];\n                    } // Duplicate the extension specific metadata\n\n\n                    newRoot.metadata.gltf[NAME] = {\n                      lastSelected: null,\n                      original: [],\n                      variants: {}\n                    };\n\n                    for (var _i = 0, _a = metadata.original; _i < _a.length; _i++) {\n                      var original = _a[_i];\n                      newRoot.metadata.gltf[NAME].original.push({\n                        mesh: original.mesh,\n                        material: original.material\n                      });\n                    }\n\n                    for (var key in metadata.variants) {\n                      if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\n                        newRoot.metadata.gltf[NAME].variants[key] = [];\n\n                        for (var _b = 0, _c = metadata.variants[key]; _b < _c.length; _b++) {\n                          var variantEntry = _c[_b];\n                          newRoot.metadata.gltf[NAME].variants[key].push({\n                            mesh: variantEntry.mesh,\n                            material: variantEntry.material\n                          });\n                        }\n                      }\n                    }\n\n                    metadata = newRoot.metadata.gltf[NAME];\n                  } // Relocate\n\n\n                  for (var _d = 0, _e = metadata.original; _d < _e.length; _d++) {\n                    var target = _e[_d];\n\n                    if (target.mesh === babylonMesh) {\n                      target.mesh = newMesh;\n                    }\n                  }\n\n                  for (var _f = 0, _g = metadata.variants[variant.name]; _f < _g.length; _f++) {\n                    var target = _g[_f];\n\n                    if (target.mesh === babylonMesh) {\n                      target.mesh = newMesh;\n                    }\n                  }\n                });\n              };\n\n              for (var mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\n                _loop_2(mappingVariantIndex);\n              }\n            }));\n          }; // For each mapping, look at the variants and make a new entry for them.\n\n\n          for (var mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\n            _loop_1(mappingIndex);\n          }\n        }\n      }));\n      return Promise.all(promises).then(function (_a) {\n        var babylonMesh = _a[0];\n        return babylonMesh;\n      });\n    });\n  };\n\n  return KHR_materials_variants;\n}();\n\nexport { KHR_materials_variants };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_variants(loader);\n});","map":{"version":3,"mappings":"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","names":["GLTFLoader","ArrayItem","Mesh","NAME","loader","_loader","enabled","isExtensionUsed","KHR_materials_variants","rootMesh","extensionMetadata","_GetExtensionMetadata","Object","keys","variants","GetAvailableVariants","variantName","Error","select","entries","_i","entry","mesh","material","Array","name_1","lastSelected","SelectVariant","original","Reset","GetLastSelectedVariant","metadata","_a","gltf","_b","extensions","name","extension","_variants","context","node","primitive","assign","LoadExtensionAsync","extensionContext","promises","push","_this","_loadMeshPrimitiveAsync","babylonMesh","babylonDrawMode","_GetDrawMode","mode","root_1","rootBabylonMesh","extensionMetadata_1","mappingIndex","mapping","mappings","Get","concat","materials","_loadMaterialAsync","babylonMaterial","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","parent","key","prototype","hasOwnProperty","call","variantEntry","_d","target","_f","length","Promise","all","then","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_variants.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootMesh: Mesh): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootMesh: Mesh): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        return KHR_materials_variants.SelectVariant(rootMesh, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public static Reset(rootMesh: Mesh): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public reset(rootMesh: Mesh): void {\r\n        return KHR_materials_variants.Reset(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootMesh: Nullable<Mesh>): Nullable<IExtensionMetadata> {\r\n        return rootMesh?.metadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param name\r\n     * @param node\r\n     * @param mesh\r\n     * @param primitive\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root.metadata = root.metadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot!.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot.metadata = {};\r\n                                                for (const key in root.metadata) {\r\n                                                    newRoot.metadata[key] = root.metadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot.metadata.gltf = [];\r\n                                                for (const key in root.metadata.gltf) {\r\n                                                    newRoot.metadata.gltf[key] = root.metadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot.metadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot.metadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot.metadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot.metadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot.metadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            return Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_variants(loader));\r\n"]},"metadata":{},"sourceType":"module"}