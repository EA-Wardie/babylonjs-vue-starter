{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\n\nMesh._GoldbergMeshParser = function (parsedMesh, scene) {\n  return GoldbergMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n */\n\n\nvar GoldbergMesh =\n/** @class */\nfunction (_super) {\n  __extends(GoldbergMesh, _super);\n\n  function GoldbergMesh() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Defines the specific Goldberg data used in this mesh construction.\n     */\n\n\n    _this.goldbergData = {\n      faceColors: [],\n      faceCenters: [],\n      faceZaxis: [],\n      faceXaxis: [],\n      faceYaxis: [],\n      nbSharedFaces: 0,\n      nbUnsharedFaces: 0,\n      nbFaces: 0,\n      nbFacesAtPole: 0,\n      adjacentFaces: []\n    };\n    return _this;\n  }\n  /**\n   * Gets the related Goldberg face from pole infos\n   * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\n   * @param fromPole Defines an optional pole index to find the related info from\n   * @returns the goldberg face number\n   */\n\n\n  GoldbergMesh.prototype.relatedGoldbergFace = function (poleOrShared, fromPole) {\n    if (fromPole === void 0) {\n      if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\n        Logger.Warn(\"Maximum number of unshared faces used\");\n        poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\n      }\n\n      return this.goldbergData.nbUnsharedFaces + poleOrShared;\n    }\n\n    if (poleOrShared > 11) {\n      Logger.Warn(\"Last pole used\");\n      poleOrShared = 11;\n    }\n\n    if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\n      Logger.Warn(\"Maximum number of faces at a pole used\");\n      fromPole = this.goldbergData.nbFacesAtPole - 1;\n    }\n\n    return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\n  };\n\n  GoldbergMesh.prototype._changeGoldbergFaceColors = function (colorRange) {\n    for (var i = 0; i < colorRange.length; i++) {\n      var min = colorRange[i][0];\n      var max = colorRange[i][1];\n      var col = colorRange[i][2];\n\n      for (var f = min; f < max + 1; f++) {\n        this.goldbergData.faceColors[f] = col;\n      }\n    }\n\n    var newCols = [];\n\n    for (var f = 0; f < 12; f++) {\n      for (var i = 0; i < 5; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n\n    for (var f = 12; f < this.goldbergData.faceColors.length; f++) {\n      for (var i = 0; i < 6; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n\n    return newCols;\n  };\n  /**\n   * Set new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n\n\n  GoldbergMesh.prototype.setGoldbergFaceColors = function (colorRange) {\n    var newCols = this._changeGoldbergFaceColors(colorRange);\n\n    this.setVerticesData(VertexBuffer.ColorKind, newCols);\n  };\n  /**\n   * Updates new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n\n\n  GoldbergMesh.prototype.updateGoldbergFaceColors = function (colorRange) {\n    var newCols = this._changeGoldbergFaceColors(colorRange);\n\n    this.updateVerticesData(VertexBuffer.ColorKind, newCols);\n  };\n\n  GoldbergMesh.prototype._changeGoldbergFaceUVs = function (uvRange) {\n    var uvs = this.getVerticesData(VertexBuffer.UVKind);\n\n    for (var i = 0; i < uvRange.length; i++) {\n      var min = uvRange[i][0];\n      var max = uvRange[i][1];\n      var center = uvRange[i][2];\n      var radius = uvRange[i][3];\n      var angle = uvRange[i][4];\n      var points5 = [];\n      var points6 = [];\n      var u = void 0;\n      var v = void 0;\n\n      for (var p = 0; p < 5; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);\n\n        if (u < 0) {\n          u = 0;\n        }\n\n        if (u > 1) {\n          u = 1;\n        }\n\n        points5.push(u, v);\n      }\n\n      for (var p = 0; p < 6; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 3);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 3);\n\n        if (u < 0) {\n          u = 0;\n        }\n\n        if (u > 1) {\n          u = 1;\n        }\n\n        points6.push(u, v);\n      }\n\n      for (var f = min; f < Math.min(12, max + 1); f++) {\n        for (var p = 0; p < 5; p++) {\n          uvs[10 * f + 2 * p] = points5[2 * p];\n          uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\n        }\n      }\n\n      for (var f = Math.max(12, min); f < max + 1; f++) {\n        for (var p = 0; p < 6; p++) {\n          //120 + 12 * (f - 12) = 12 * f - 24\n          uvs[12 * f - 24 + 2 * p] = points6[2 * p];\n          uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\n        }\n      }\n    }\n\n    return uvs;\n  };\n  /**\n   * set new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n\n\n  GoldbergMesh.prototype.setGoldbergFaceUVs = function (uvRange) {\n    var newUVs = this._changeGoldbergFaceUVs(uvRange);\n\n    this.setVerticesData(VertexBuffer.UVKind, newUVs);\n  };\n  /**\n   * Updates new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n\n\n  GoldbergMesh.prototype.updateGoldbergFaceUVs = function (uvRange) {\n    var newUVs = this._changeGoldbergFaceUVs(uvRange);\n\n    this.updateVerticesData(VertexBuffer.UVKind, newUVs);\n  };\n  /**\n   * Places a mesh on a particular face of the goldberg polygon\n   * @param mesh Defines the mesh to position\n   * @param face Defines the face to position onto\n   * @param position Defines the position relative to the face we are positioning the mesh onto\n   */\n\n\n  GoldbergMesh.prototype.placeOnGoldbergFaceAt = function (mesh, face, position) {\n    var orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\n    mesh.rotation = orientation;\n    mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));\n  };\n  /**\n   * Serialize current mesh\n   * @param serializationObject defines the object which will receive the serialization data\n   */\n\n\n  GoldbergMesh.prototype.serialize = function (serializationObject) {\n    _super.prototype.serialize.call(this, serializationObject);\n\n    serializationObject.type = \"GoldbergMesh\";\n    var goldbergData = {};\n    goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\n    goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\n    goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\n    goldbergData.nbFaces = this.goldbergData.nbFaces;\n    goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\n\n    if (this.goldbergData.faceColors) {\n      goldbergData.faceColors = [];\n\n      for (var _i = 0, _a = this.goldbergData.faceColors; _i < _a.length; _i++) {\n        var color = _a[_i];\n        goldbergData.faceColors.push(color.asArray());\n      }\n    }\n\n    if (this.goldbergData.faceCenters) {\n      goldbergData.faceCenters = [];\n\n      for (var _b = 0, _c = this.goldbergData.faceCenters; _b < _c.length; _b++) {\n        var vector = _c[_b];\n        goldbergData.faceCenters.push(vector.asArray());\n      }\n    }\n\n    if (this.goldbergData.faceZaxis) {\n      goldbergData.faceZaxis = [];\n\n      for (var _d = 0, _e = this.goldbergData.faceZaxis; _d < _e.length; _d++) {\n        var vector = _e[_d];\n        goldbergData.faceZaxis.push(vector.asArray());\n      }\n    }\n\n    if (this.goldbergData.faceYaxis) {\n      goldbergData.faceYaxis = [];\n\n      for (var _f = 0, _g = this.goldbergData.faceYaxis; _f < _g.length; _f++) {\n        var vector = _g[_f];\n        goldbergData.faceYaxis.push(vector.asArray());\n      }\n    }\n\n    if (this.goldbergData.faceXaxis) {\n      goldbergData.faceXaxis = [];\n\n      for (var _h = 0, _j = this.goldbergData.faceXaxis; _h < _j.length; _h++) {\n        var vector = _j[_h];\n        goldbergData.faceXaxis.push(vector.asArray());\n      }\n    }\n\n    serializationObject.goldbergData = goldbergData;\n  };\n  /**\n   * Parses a serialized goldberg mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the goldberg mesh in\n   * @returns the created goldberg mesh\n   */\n\n\n  GoldbergMesh.Parse = function (parsedMesh, scene) {\n    var goldbergData = parsedMesh.goldbergData;\n    goldbergData.faceColors = goldbergData.faceColors.map(function (el) {\n      return Color4.FromArray(el);\n    });\n    goldbergData.faceCenters = goldbergData.faceCenters.map(function (el) {\n      return Vector3.FromArray(el);\n    });\n    goldbergData.faceZaxis = goldbergData.faceZaxis.map(function (el) {\n      return Vector3.FromArray(el);\n    });\n    goldbergData.faceXaxis = goldbergData.faceXaxis.map(function (el) {\n      return Vector3.FromArray(el);\n    });\n    goldbergData.faceYaxis = goldbergData.faceYaxis.map(function (el) {\n      return Vector3.FromArray(el);\n    });\n    var goldberg = new GoldbergMesh(parsedMesh.name, scene);\n    goldberg.goldbergData = goldbergData;\n    return goldberg;\n  };\n\n  return GoldbergMesh;\n}(Mesh);\n\nexport { GoldbergMesh };","map":{"version":3,"mappings":"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","names":["Vector3","VertexBuffer","Mesh","Color4","Logger","_GoldbergMeshParser","parsedMesh","scene","GoldbergMesh","Parse","__extends","_this","faceColors","faceCenters","faceZaxis","faceXaxis","faceYaxis","nbSharedFaces","nbUnsharedFaces","nbFaces","nbFacesAtPole","adjacentFaces","poleOrShared","fromPole","goldbergData","Warn","colorRange","i","length","min","max","col","f","newCols","push","r","g","b","a","_changeGoldbergFaceColors","setVerticesData","ColorKind","updateVerticesData","uvRange","uvs","getVerticesData","UVKind","center","radius","angle","points5","points6","u","v","p","x","Math","cos","PI","y","sin","newUVs","_changeGoldbergFaceUVs","mesh","face","position","orientation","RotationFromAxis","rotation","add","scale","z","serializationObject","_super","serialize","call","type","_i","color","asArray","_b","vector","_d","_f","_h","map","el","FromArray","goldberg","name"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/goldbergMesh.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}