{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport { __decorate } from \"tslib\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\n\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n  if (!this.reflectionProbes) {\n    return -1;\n  }\n\n  var index = this.reflectionProbes.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.reflectionProbes.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n  if (!this.reflectionProbes) {\n    this.reflectionProbes = [];\n  }\n\n  this.reflectionProbes.push(newReflectionProbe);\n};\n/**\n * Class used to generate realtime reflection / refraction cube textures\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\n */\n\n\nvar ReflectionProbe =\n/** @class */\nfunction () {\n  /**\n   * Creates a new reflection probe\n   * @param name defines the name of the probe\n   * @param size defines the texture resolution (for each face)\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\n   * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\n   * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\n   */\n  function ReflectionProbe(\n  /** defines the name of the probe */\n  name, size, scene, generateMipMaps, useFloat, linearSpace) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (useFloat === void 0) {\n      useFloat = false;\n    }\n\n    if (linearSpace === void 0) {\n      linearSpace = false;\n    }\n\n    var _this = this;\n\n    this.name = name;\n    this._viewMatrix = Matrix.Identity();\n    this._target = Vector3.Zero();\n    this._add = Vector3.Zero();\n    this._invertYAxis = false;\n    /** Gets or sets probe position (center of the cube map) */\n\n    this.position = Vector3.Zero();\n    /** @hidden */\n\n    this._parentContainer = null;\n    this._scene = scene;\n\n    if (scene.getEngine().supportsUniformBuffers) {\n      this._sceneUBOs = [];\n\n      for (var i = 0; i < 6; ++i) {\n        this._sceneUBOs.push(scene.createSceneUniformBuffer(\"Scene for Reflection Probe (name \\\"\".concat(name, \"\\\") face #\").concat(i)));\n      }\n    } // Create the scene field if not exist.\n\n\n    if (!this._scene.reflectionProbes) {\n      this._scene.reflectionProbes = new Array();\n    }\n\n    this._scene.reflectionProbes.push(this);\n\n    var textureType = 0;\n\n    if (useFloat) {\n      var caps = this._scene.getEngine().getCaps();\n\n      if (caps.textureHalfFloatRender) {\n        textureType = 2;\n      } else if (caps.textureFloatRender) {\n        textureType = 1;\n      }\n    }\n\n    this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n    this._renderTargetTexture.gammaSpace = !linearSpace;\n    var useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n\n    this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {\n      if (_this._sceneUBOs) {\n        scene.setSceneUniformBuffer(_this._sceneUBOs[faceIndex]);\n        scene.getSceneUniformBuffer().unbindEffect();\n      }\n\n      switch (faceIndex) {\n        case 0:\n          _this._add.copyFromFloats(1, 0, 0);\n\n          break;\n\n        case 1:\n          _this._add.copyFromFloats(-1, 0, 0);\n\n          break;\n\n        case 2:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);\n\n          break;\n\n        case 3:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);\n\n          break;\n\n        case 4:\n          _this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\n\n          break;\n\n        case 5:\n          _this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\n\n          break;\n      }\n\n      if (_this._attachedMesh) {\n        _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());\n      }\n\n      _this.position.addToRef(_this._add, _this._target);\n\n      var lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\n      var perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\n      lookAtFunction(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);\n\n      if (scene.activeCamera) {\n        _this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, _this._scene.getEngine().isNDCHalfZRange);\n        scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);\n\n        if (scene.activeCamera.isRigCamera && !_this._renderTargetTexture.activeCamera) {\n          _this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\n        }\n      }\n\n      scene._forcedViewPosition = _this.position;\n    });\n\n    var currentApplyByPostProcess;\n\n    this._renderTargetTexture.onBeforeBindObservable.add(function () {\n      var _a, _b;\n\n      _this._currentSceneUBO = scene.getSceneUniformBuffer();\n      (_b = (_a = scene.getEngine())._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(_a, \"reflection probe generation for \".concat(name), 1);\n      currentApplyByPostProcess = _this._scene.imageProcessingConfiguration.applyByPostProcess;\n\n      if (linearSpace) {\n        scene.imageProcessingConfiguration.applyByPostProcess = true;\n      }\n    });\n\n    this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n      var _a, _b;\n\n      scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\n      scene._forcedViewPosition = null;\n\n      if (_this._sceneUBOs) {\n        scene.setSceneUniformBuffer(_this._currentSceneUBO);\n      }\n\n      scene.updateTransformMatrix(true);\n      (_b = (_a = scene.getEngine())._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(_a, 1);\n    });\n  }\n\n  Object.defineProperty(ReflectionProbe.prototype, \"samples\", {\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n    get: function get() {\n      return this._renderTargetTexture.samples;\n    },\n    set: function set(value) {\n      this._renderTargetTexture.samples = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"refreshRate\", {\n    /** Gets or sets the refresh rate to use (on every frame by default) */\n    get: function get() {\n      return this._renderTargetTexture.refreshRate;\n    },\n    set: function set(value) {\n      this._renderTargetTexture.refreshRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the hosting scene\n   * @returns a Scene\n   */\n\n  ReflectionProbe.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(ReflectionProbe.prototype, \"cubeTexture\", {\n    /** Gets the internal CubeTexture used to render to */\n    get: function get() {\n      return this._renderTargetTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"renderList\", {\n    /** Gets the list of meshes to render */\n    get: function get() {\n      return this._renderTargetTexture.renderList;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\n   * @param mesh defines the mesh to attach to\n   */\n\n  ReflectionProbe.prototype.attachToMesh = function (mesh) {\n    this._attachedMesh = mesh;\n  };\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   */\n\n\n  ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n  };\n  /**\n   * Clean all associated resources\n   */\n\n\n  ReflectionProbe.prototype.dispose = function () {\n    var index = this._scene.reflectionProbes.indexOf(this);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this._scene.reflectionProbes.splice(index, 1);\n    }\n\n    if (this._parentContainer) {\n      var index_1 = this._parentContainer.reflectionProbes.indexOf(this);\n\n      if (index_1 > -1) {\n        this._parentContainer.reflectionProbes.splice(index_1, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    if (this._renderTargetTexture) {\n      this._renderTargetTexture.dispose();\n\n      this._renderTargetTexture = null;\n    }\n\n    if (this._sceneUBOs) {\n      for (var _i = 0, _a = this._sceneUBOs; _i < _a.length; _i++) {\n        var ubo = _a[_i];\n        ubo.dispose();\n      }\n\n      this._sceneUBOs = [];\n    }\n  };\n  /**\n   * Converts the reflection probe information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable reflection probe info\n   */\n\n\n  ReflectionProbe.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n\n    if (fullDetails) {\n      ret += \", position: \" + this.position.toString();\n\n      if (this._attachedMesh) {\n        ret += \", attached mesh: \" + this._attachedMesh.name;\n      }\n    }\n\n    return ret;\n  };\n  /**\n   * Get the class name of the refection probe.\n   * @returns \"ReflectionProbe\"\n   */\n\n\n  ReflectionProbe.prototype.getClassName = function () {\n    return \"ReflectionProbe\";\n  };\n  /**\n   * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\n   * @returns The JSON representation of the texture\n   */\n\n\n  ReflectionProbe.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n    serializationObject.isReflectionProbe = true;\n    return serializationObject;\n  };\n  /**\n   * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\n   * @param parsedReflectionProbe Define the JSON representation of the reflection probe\n   * @param scene Define the scene the parsed reflection probe should be instantiated in\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n   * @returns The parsed reflection probe if successful\n   */\n\n\n  ReflectionProbe.Parse = function (parsedReflectionProbe, scene, rootUrl) {\n    var reflectionProbe = null;\n\n    if (scene.reflectionProbes) {\n      for (var index = 0; index < scene.reflectionProbes.length; index++) {\n        var rp = scene.reflectionProbes[index];\n\n        if (rp.name === parsedReflectionProbe.name) {\n          reflectionProbe = rp;\n          break;\n        }\n      }\n    }\n\n    reflectionProbe = SerializationHelper.Parse(function () {\n      return reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps);\n    }, parsedReflectionProbe, scene, rootUrl);\n    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n\n    if (parsedReflectionProbe._attachedMesh) {\n      reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\n    }\n\n    return reflectionProbe;\n  };\n\n  __decorate([serializeAsMeshReference()], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n\n  __decorate([serializeAsVector3()], ReflectionProbe.prototype, \"position\", void 0);\n\n  return ReflectionProbe;\n}();\n\nexport { ReflectionProbe };","map":{"version":3,"mappings":"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","names":["serializeAsMeshReference","serializeAsVector3","SerializationHelper","RenderTargetTexture","Matrix","Vector3","AbstractScene","prototype","removeReflectionProbe","toRemove","reflectionProbes","index","indexOf","splice","addReflectionProbe","newReflectionProbe","push","name","size","scene","generateMipMaps","useFloat","linearSpace","Identity","Zero","_scene","getEngine","supportsUniformBuffers","_sceneUBOs","i","createSceneUniformBuffer","concat","Array","textureType","caps","getCaps","textureHalfFloatRender","textureFloatRender","_renderTargetTexture","gammaSpace","useReverseDepthBuffer","onBeforeRenderObservable","add","faceIndex","_this","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","_add","copyFromFloats","_invertYAxis","useRightHandedSystem","_attachedMesh","position","copyFrom","getAbsolutePosition","addToRef","_target","lookAtFunction","LookAtRHToRef","LookAtLHToRef","perspectiveFunction","PerspectiveFovRH","PerspectiveFovLH","Up","_viewMatrix","activeCamera","_projectionMatrix","Math","PI","maxZ","minZ","isNDCHalfZRange","setTransformMatrix","isRigCamera","rigParent","_forcedViewPosition","currentApplyByPostProcess","onBeforeBindObservable","_currentSceneUBO","_debugPushGroup","_b","imageProcessingConfiguration","applyByPostProcess","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","Object","ReflectionProbe","samples","value","refreshRate","renderList","mesh","renderingGroupId","autoClearDepthStencil","setRenderingAutoClearDepthStencil","_parentContainer","index_1","dispose","_i","ubo","fullDetails","ret","toString","serializationObject","Serialize","serialize","isReflectionProbe","parsedReflectionProbe","rootUrl","reflectionProbe","length","rp","Parse","renderTargetSize","_generateMipMaps","cubeTexture","_waitingRenderList","attachToMesh","getMeshById","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Probes/reflectionProbe.ts"],"sourcesContent":["import { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of reflection probes added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n         */\r\n        reflectionProbes: Array<ReflectionProbe>;\r\n\r\n        /**\r\n         * Removes the given reflection probe from this scene.\r\n         * @param toRemove The reflection probe to remove\r\n         * @returns The index of the removed reflection probe\r\n         */\r\n        removeReflectionProbe(toRemove: ReflectionProbe): number;\r\n\r\n        /**\r\n         * Adds the given reflection probe to this scene.\r\n         * @param newReflectionProbe The reflection probe to add\r\n         */\r\n        addReflectionProbe(newReflectionProbe: ReflectionProbe): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeReflectionProbe = function (toRemove: ReflectionProbe): number {\r\n    if (!this.reflectionProbes) {\r\n        return -1;\r\n    }\r\n\r\n    const index = this.reflectionProbes.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.reflectionProbes.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe: ReflectionProbe): void {\r\n    if (!this.reflectionProbes) {\r\n        this.reflectionProbes = [];\r\n    }\r\n\r\n    this.reflectionProbes.push(newReflectionProbe);\r\n};\r\n\r\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n */\r\nexport class ReflectionProbe {\r\n    private _scene: Scene;\r\n    private _renderTargetTexture: RenderTargetTexture;\r\n    private _projectionMatrix: Matrix;\r\n    private _viewMatrix = Matrix.Identity();\r\n    private _target = Vector3.Zero();\r\n    private _add = Vector3.Zero();\r\n    @serializeAsMeshReference()\r\n    private _attachedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _invertYAxis = false;\r\n    private _sceneUBOs: UniformBuffer[];\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /** Gets or sets probe position (center of the cube map) */\r\n    @serializeAsVector3()\r\n    public position = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Creates a new reflection probe\r\n     * @param name defines the name of the probe\r\n     * @param size defines the texture resolution (for each face)\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\r\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\r\n     */\r\n    constructor(\r\n        /** defines the name of the probe */\r\n        public name: string,\r\n        size: number,\r\n        scene: Scene,\r\n        generateMipMaps = true,\r\n        useFloat = false,\r\n        linearSpace = false\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        if (scene.getEngine().supportsUniformBuffers) {\r\n            this._sceneUBOs = [];\r\n            for (let i = 0; i < 6; ++i) {\r\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\r\n            }\r\n        }\r\n\r\n        // Create the scene field if not exist.\r\n        if (!this._scene.reflectionProbes) {\r\n            this._scene.reflectionProbes = new Array<ReflectionProbe>();\r\n        }\r\n        this._scene.reflectionProbes.push(this);\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (useFloat) {\r\n            const caps = this._scene.getEngine().getCaps();\r\n            if (caps.textureHalfFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        }\r\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\r\n        this._renderTargetTexture.gammaSpace = !linearSpace;\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\r\n                scene.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    this._add.copyFromFloats(1, 0, 0);\r\n                    break;\r\n                case 1:\r\n                    this._add.copyFromFloats(-1, 0, 0);\r\n                    break;\r\n                case 2:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\r\n                    break;\r\n                case 3:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\r\n                    break;\r\n                case 4:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\r\n                    break;\r\n                case 5:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\r\n                    break;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\r\n            }\r\n\r\n            this.position.addToRef(this._add, this._target);\r\n\r\n            const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\r\n            const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\r\n\r\n            lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\r\n\r\n            if (scene.activeCamera) {\r\n                this._projectionMatrix = perspectiveFunction(\r\n                    Math.PI / 2,\r\n                    1,\r\n                    useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ,\r\n                    useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ,\r\n                    this._scene.getEngine().isNDCHalfZRange\r\n                );\r\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n                if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\r\n                    this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\r\n                }\r\n            }\r\n            scene._forcedViewPosition = this.position;\r\n        });\r\n\r\n        let currentApplyByPostProcess: boolean;\r\n\r\n        this._renderTargetTexture.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = scene.getSceneUniformBuffer();\r\n            scene.getEngine()._debugPushGroup?.(`reflection probe generation for ${name}`, 1);\r\n            currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (linearSpace) {\r\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\r\n            }\r\n        });\r\n\r\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\r\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\r\n            scene._forcedViewPosition = null;\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene.updateTransformMatrix(true);\r\n            scene.getEngine()._debugPopGroup?.(1);\r\n        });\r\n    }\r\n\r\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\r\n    public get samples(): number {\r\n        return this._renderTargetTexture.samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        this._renderTargetTexture.samples = value;\r\n    }\r\n\r\n    /** Gets or sets the refresh rate to use (on every frame by default) */\r\n    public get refreshRate(): number {\r\n        return this._renderTargetTexture.refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._renderTargetTexture.refreshRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets the internal CubeTexture used to render to */\r\n    public get cubeTexture(): RenderTargetTexture {\r\n        return this._renderTargetTexture;\r\n    }\r\n\r\n    /** Gets the list of meshes to render */\r\n    public get renderList(): Nullable<AbstractMesh[]> {\r\n        return this._renderTargetTexture.renderList;\r\n    }\r\n\r\n    /**\r\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n     * @param mesh defines the mesh to attach to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>): void {\r\n        this._attachedMesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clean all associated resources\r\n     */\r\n    public dispose() {\r\n        const index = this._scene.reflectionProbes.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this._scene.reflectionProbes.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.reflectionProbes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.reflectionProbes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._renderTargetTexture) {\r\n            this._renderTargetTexture.dispose();\r\n            (<any>this._renderTargetTexture) = null;\r\n        }\r\n\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n            this._sceneUBOs = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the reflection probe information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable reflection probe info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n\r\n        if (fullDetails) {\r\n            ret += \", position: \" + this.position.toString();\r\n\r\n            if (this._attachedMesh) {\r\n                ret += \", attached mesh: \" + this._attachedMesh.name;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the refection probe.\r\n     * @returns \"ReflectionProbe\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ReflectionProbe\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\r\n        serializationObject.isReflectionProbe = true;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed reflection probe if successful\r\n     */\r\n    public static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe> {\r\n        let reflectionProbe: Nullable<ReflectionProbe> = null;\r\n        if (scene.reflectionProbes) {\r\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const rp = scene.reflectionProbes[index];\r\n                if (rp.name === parsedReflectionProbe.name) {\r\n                    reflectionProbe = rp;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        reflectionProbe = SerializationHelper.Parse(\r\n            () => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps),\r\n            parsedReflectionProbe,\r\n            scene,\r\n            rootUrl\r\n        );\r\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\r\n\r\n        if (parsedReflectionProbe._attachedMesh) {\r\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\r\n        }\r\n\r\n        return reflectionProbe;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}