{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer.js\";\nimport { FromHalfFloat } from \"../../Misc/textureTools.js\";\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @hidden */\n\nvar WebGPUBufferManager =\n/** @class */\nfunction () {\n  function WebGPUBufferManager(device) {\n    this._deferredReleaseBuffers = [];\n    this._device = device;\n  }\n\n  WebGPUBufferManager._IsGPUBuffer = function (buffer) {\n    return buffer.underlyingResource === undefined;\n  };\n\n  WebGPUBufferManager.prototype.createRawBuffer = function (viewOrSize, flags, mappedAtCreation) {\n    if (mappedAtCreation === void 0) {\n      mappedAtCreation = false;\n    }\n\n    var alignedLength = viewOrSize.byteLength !== undefined ? viewOrSize.byteLength + 3 & ~3 : viewOrSize + 3 & ~3; // 4 bytes alignments (because of the upload which requires this)\n\n    var verticesBufferDescriptor = {\n      mappedAtCreation: mappedAtCreation,\n      size: alignedLength,\n      usage: flags\n    };\n    return this._device.createBuffer(verticesBufferDescriptor);\n  };\n\n  WebGPUBufferManager.prototype.createBuffer = function (viewOrSize, flags) {\n    var isView = viewOrSize.byteLength !== undefined;\n    var buffer = this.createRawBuffer(viewOrSize, flags);\n    var dataBuffer = new WebGPUDataBuffer(buffer);\n    dataBuffer.references = 1;\n    dataBuffer.capacity = isView ? viewOrSize.byteLength : viewOrSize;\n\n    if (isView) {\n      this.setSubData(dataBuffer, 0, viewOrSize);\n    }\n\n    return dataBuffer;\n  };\n\n  WebGPUBufferManager.prototype.setRawData = function (buffer, dstByteOffset, src, srcByteOffset, byteLength) {\n    this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\n  };\n\n  WebGPUBufferManager.prototype.setSubData = function (dataBuffer, dstByteOffset, src, srcByteOffset, byteLength) {\n    if (srcByteOffset === void 0) {\n      srcByteOffset = 0;\n    }\n\n    if (byteLength === void 0) {\n      byteLength = 0;\n    }\n\n    var buffer = dataBuffer.underlyingResource;\n    byteLength = byteLength || src.byteLength;\n    byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset); // After Migration to Canary\n\n    var chunkStart = src.byteOffset + srcByteOffset;\n    var chunkEnd = chunkStart + byteLength; // 4 bytes alignments for upload\n\n    var alignedLength = byteLength + 3 & ~3;\n\n    if (alignedLength !== byteLength) {\n      var tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\n      src = new Uint8Array(alignedLength);\n      src.set(tempView);\n      srcByteOffset = 0;\n      chunkStart = 0;\n      chunkEnd = alignedLength;\n      byteLength = alignedLength;\n    } // Chunk\n\n\n    var maxChunk = 1024 * 1024 * 15;\n    var offset = 0;\n\n    while (chunkEnd - (chunkStart + offset) > maxChunk) {\n      this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\n\n      offset += maxChunk;\n    }\n\n    this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\n  };\n\n  WebGPUBufferManager.prototype._getHalfFloatAsFloatRGBAArrayBuffer = function (dataLength, arrayBuffer, destArray) {\n    if (!destArray) {\n      destArray = new Float32Array(dataLength);\n    }\n\n    var srcData = new Uint16Array(arrayBuffer);\n\n    while (dataLength--) {\n      destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\n    }\n\n    return destArray;\n  };\n\n  WebGPUBufferManager.prototype.readDataFromBuffer = function (gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, type, offset, buffer, destroyBuffer, noDataConversion) {\n    var _this = this;\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (destroyBuffer === void 0) {\n      destroyBuffer = true;\n    }\n\n    if (noDataConversion === void 0) {\n      noDataConversion = false;\n    }\n\n    var floatFormat = type === 1 ? 2 : type === 2 ? 1 : 0;\n    return new Promise(function (resolve, reject) {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(function () {\n        var copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\n        var data = buffer;\n\n        if (noDataConversion) {\n          if (data === null) {\n            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\n          } else {\n            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\n          }\n        } else {\n          if (data === null) {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(size);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = _this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\n                break;\n\n              case 2:\n                // float\n                data = new Float32Array(size / 4);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          } else {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(data.buffer);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = _this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer);\n                break;\n\n              case 2:\n                // float\n                data = new Float32Array(data.buffer);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          }\n        }\n\n        if (bytesPerRow !== bytesPerRowAligned) {\n          // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\n          if (floatFormat === 1 && !noDataConversion) {\n            // half float have been converted to float above\n            bytesPerRow *= 2;\n            bytesPerRowAligned *= 2;\n          }\n\n          var data2 = new Uint8Array(data.buffer);\n          var offset_1 = bytesPerRow,\n              offset2 = 0;\n\n          for (var y = 1; y < height; ++y) {\n            offset2 = y * bytesPerRowAligned;\n\n            for (var x = 0; x < bytesPerRow; ++x) {\n              data2[offset_1++] = data2[offset2++];\n            }\n          }\n\n          if (floatFormat !== 0 && !noDataConversion) {\n            data = new Float32Array(data2.buffer, 0, offset_1 / 4);\n          } else {\n            data = new Uint8Array(data2.buffer, 0, offset_1);\n          }\n        }\n\n        gpuBuffer.unmap();\n\n        if (destroyBuffer) {\n          _this.releaseBuffer(gpuBuffer);\n        }\n\n        resolve(data);\n      }, function (reason) {\n        return reject(reason);\n      });\n    });\n  };\n\n  WebGPUBufferManager.prototype.releaseBuffer = function (buffer) {\n    if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\n      this._deferredReleaseBuffers.push(buffer);\n\n      return true;\n    }\n\n    buffer.references--;\n\n    if (buffer.references === 0) {\n      this._deferredReleaseBuffers.push(buffer.underlyingResource);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  WebGPUBufferManager.prototype.destroyDeferredBuffers = function () {\n    for (var i = 0; i < this._deferredReleaseBuffers.length; ++i) {\n      this._deferredReleaseBuffers[i].destroy();\n    }\n\n    this._deferredReleaseBuffers.length = 0;\n  };\n\n  return WebGPUBufferManager;\n}();\n\nexport { WebGPUBufferManager };","map":{"version":3,"mappings":"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","names":["WebGPUDataBuffer","FromHalfFloat","allocateAndCopyTypedBuffer","WebGPUConstants","device","_device","WebGPUBufferManager","buffer","underlyingResource","undefined","viewOrSize","flags","mappedAtCreation","alignedLength","byteLength","verticesBufferDescriptor","size","usage","createBuffer","isView","createRawBuffer","dataBuffer","references","capacity","setSubData","dstByteOffset","src","srcByteOffset","queue","writeBuffer","Math","min","chunkStart","byteOffset","chunkEnd","tempView","Uint8Array","slice","set","maxChunk","offset","dataLength","arrayBuffer","destArray","Float32Array","srcData","Uint16Array","gpuBuffer","width","height","bytesPerRow","bytesPerRowAligned","type","destroyBuffer","noDataConversion","floatFormat","Promise","resolve","reject","mapAsync","MapMode","Read","then","copyArrayBuffer","getMappedRange","data","_this","_getHalfFloatAsFloatRGBAArrayBuffer","data2","offset_1","offset2","y","x","unmap","releaseBuffer","reason","_IsGPUBuffer","_deferredReleaseBuffers","push","i","length","destroy"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuBufferManager.ts"],"sourcesContent":["import type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport { FromHalfFloat } from \"../../Misc/textureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @hidden */\r\nexport class WebGPUBufferManager {\r\n    private _device: GPUDevice;\r\n    private _deferredReleaseBuffers: Array<GPUBuffer> = [];\r\n\r\n    private static _IsGPUBuffer(buffer: DataBuffer | GPUBuffer): buffer is GPUBuffer {\r\n        return (buffer as DataBuffer).underlyingResource === undefined;\r\n    }\r\n\r\n    constructor(device: GPUDevice) {\r\n        this._device = device;\r\n    }\r\n\r\n    public createRawBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, mappedAtCreation = false): GPUBuffer {\r\n        const alignedLength = (viewOrSize as ArrayBufferView).byteLength !== undefined ? ((viewOrSize as ArrayBufferView).byteLength + 3) & ~3 : ((viewOrSize as number) + 3) & ~3; // 4 bytes alignments (because of the upload which requires this)\r\n        const verticesBufferDescriptor = {\r\n            mappedAtCreation,\r\n            size: alignedLength,\r\n            usage: flags,\r\n        };\r\n\r\n        return this._device.createBuffer(verticesBufferDescriptor);\r\n    }\r\n\r\n    public createBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags): WebGPUDataBuffer {\r\n        const isView = (viewOrSize as ArrayBufferView).byteLength !== undefined;\r\n        const buffer = this.createRawBuffer(viewOrSize, flags);\r\n        const dataBuffer = new WebGPUDataBuffer(buffer);\r\n        dataBuffer.references = 1;\r\n        dataBuffer.capacity = isView ? (viewOrSize as ArrayBufferView).byteLength : (viewOrSize as number);\r\n\r\n        if (isView) {\r\n            this.setSubData(dataBuffer, 0, viewOrSize as ArrayBufferView);\r\n        }\r\n\r\n        return dataBuffer;\r\n    }\r\n\r\n    public setRawData(buffer: GPUBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset: number, byteLength: number): void {\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\r\n    }\r\n\r\n    public setSubData(dataBuffer: WebGPUDataBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset = 0, byteLength = 0): void {\r\n        const buffer = dataBuffer.underlyingResource as GPUBuffer;\r\n\r\n        byteLength = byteLength || src.byteLength;\r\n        byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);\r\n\r\n        // After Migration to Canary\r\n        let chunkStart = src.byteOffset + srcByteOffset;\r\n        let chunkEnd = chunkStart + byteLength;\r\n\r\n        // 4 bytes alignments for upload\r\n        const alignedLength = (byteLength + 3) & ~3;\r\n        if (alignedLength !== byteLength) {\r\n            const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\r\n            src = new Uint8Array(alignedLength);\r\n            (src as Uint8Array).set(tempView);\r\n            srcByteOffset = 0;\r\n            chunkStart = 0;\r\n            chunkEnd = alignedLength;\r\n            byteLength = alignedLength;\r\n        }\r\n\r\n        // Chunk\r\n        const maxChunk = 1024 * 1024 * 15;\r\n        let offset = 0;\r\n        while (chunkEnd - (chunkStart + offset) > maxChunk) {\r\n            this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\r\n            offset += maxChunk;\r\n        }\r\n\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\r\n    }\r\n\r\n    private _getHalfFloatAsFloatRGBAArrayBuffer(dataLength: number, arrayBuffer: ArrayBuffer, destArray?: Float32Array): Float32Array {\r\n        if (!destArray) {\r\n            destArray = new Float32Array(dataLength);\r\n        }\r\n        const srcData = new Uint16Array(arrayBuffer);\r\n        while (dataLength--) {\r\n            destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    public readDataFromBuffer(\r\n        gpuBuffer: GPUBuffer,\r\n        size: number,\r\n        width: number,\r\n        height: number,\r\n        bytesPerRow: number,\r\n        bytesPerRowAligned: number,\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        offset = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        destroyBuffer = true,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const floatFormat = type === Constants.TEXTURETYPE_FLOAT ? 2 : type === Constants.TEXTURETYPE_HALF_FLOAT ? 1 : 0;\r\n        return new Promise((resolve, reject) => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\r\n                    let data: Nullable<ArrayBufferView> | Uint8Array | Float32Array = buffer;\r\n                    if (noDataConversion) {\r\n                        if (data === null) {\r\n                            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\r\n                        } else {\r\n                            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\r\n                        }\r\n                    } else {\r\n                        if (data === null) {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(size);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(size / 4);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        } else {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(data.buffer);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer as Float32Array);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(data.buffer);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bytesPerRow !== bytesPerRowAligned) {\r\n                        // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\r\n                        if (floatFormat === 1 && !noDataConversion) {\r\n                            // half float have been converted to float above\r\n                            bytesPerRow *= 2;\r\n                            bytesPerRowAligned *= 2;\r\n                        }\r\n                        const data2 = new Uint8Array(data!.buffer);\r\n                        let offset = bytesPerRow,\r\n                            offset2 = 0;\r\n                        for (let y = 1; y < height; ++y) {\r\n                            offset2 = y * bytesPerRowAligned;\r\n                            for (let x = 0; x < bytesPerRow; ++x) {\r\n                                data2[offset++] = data2[offset2++];\r\n                            }\r\n                        }\r\n                        if (floatFormat !== 0 && !noDataConversion) {\r\n                            data = new Float32Array(data2.buffer, 0, offset / 4);\r\n                        } else {\r\n                            data = new Uint8Array(data2.buffer, 0, offset);\r\n                        }\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    if (destroyBuffer) {\r\n                        this.releaseBuffer(gpuBuffer);\r\n                    }\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    }\r\n\r\n    public releaseBuffer(buffer: DataBuffer | GPUBuffer): boolean {\r\n        if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\r\n            this._deferredReleaseBuffers.push(buffer);\r\n            return true;\r\n        }\r\n\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deferredReleaseBuffers.push(buffer.underlyingResource as GPUBuffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public destroyDeferredBuffers(): void {\r\n        for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\r\n            this._deferredReleaseBuffers[i].destroy();\r\n        }\r\n\r\n        this._deferredReleaseBuffers.length = 0;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}