{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Enum that describes the state of the image trackability score status for this session.\n */\n\nvar ImageTrackingScoreStatus;\n\n(function (ImageTrackingScoreStatus) {\n  // AR Session has not yet assessed image trackability scores.\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"NotReceived\"] = 0] = \"NotReceived\"; // A request to retrieve trackability scores has been sent, but no response has been received.\n\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Waiting\"] = 1] = \"Waiting\"; // Image trackability scores have been received for this session\n\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Received\"] = 2] = \"Received\";\n})(ImageTrackingScoreStatus || (ImageTrackingScoreStatus = {}));\n/**\n * Image tracking for immersive AR sessions.\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\n */\n\n\nvar WebXRImageTracking =\n/** @class */\nfunction (_super) {\n  __extends(WebXRImageTracking, _super);\n  /**\n   * constructs the image tracking feature\n   * @param _xrSessionManager the session manager for this module\n   * @param options read-only options to be used in this module\n   */\n\n\n  function WebXRImageTracking(_xrSessionManager,\n  /**\n   * read-only options to be used in this module\n   */\n  options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    /**\n     * This will be triggered if the underlying system deems an image untrackable.\n     * The index is the index of the image from the array used to initialize the feature.\n     */\n\n    _this.onUntrackableImageFoundObservable = new Observable();\n    /**\n     * An image was deemed trackable, and the system will start tracking it.\n     */\n\n    _this.onTrackableImageFoundObservable = new Observable();\n    /**\n     * The image was found and its state was updated.\n     */\n\n    _this.onTrackedImageUpdatedObservable = new Observable();\n    _this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n    _this._trackedImages = [];\n    _this.xrNativeFeatureName = \"image-tracking\";\n    return _this;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRImageTracking.prototype.attach = function () {\n    return _super.prototype.attach.call(this);\n  };\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRImageTracking.prototype.detach = function () {\n    return _super.prototype.detach.call(this);\n  };\n  /**\n   * Get a tracked image by its ID.\n   *\n   * @param id the id of the image to load (position in the init array)\n   * @returns a trackable image, if exists in this location\n   */\n\n\n  WebXRImageTracking.prototype.getTrackedImageById = function (id) {\n    return this._trackedImages[id] || null;\n  };\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n\n\n  WebXRImageTracking.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._trackedImages.forEach(function (trackedImage) {\n      trackedImage.originalBitmap.close();\n    });\n\n    this._trackedImages.length = 0;\n    this.onTrackableImageFoundObservable.clear();\n    this.onUntrackableImageFoundObservable.clear();\n    this.onTrackedImageUpdatedObservable.clear();\n  };\n  /**\n   * Extends the session init object if needed\n   * @returns augmentation object fo the xr session init object.\n   */\n\n\n  WebXRImageTracking.prototype.getXRSessionInitExtension = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises, images, ex_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.options.images || !this.options.images.length) {\n              return [2\n              /*return*/\n              , {}];\n            }\n\n            promises = this.options.images.map(function (image) {\n              if (typeof image.src === \"string\") {\n                return _this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\n              } else {\n                return Promise.resolve(image.src); // resolve is probably unneeded\n              }\n            });\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 2:\n            images = _a.sent();\n            this._originalTrackingRequest = images.map(function (image, idx) {\n              return {\n                image: image,\n                widthInMeters: _this.options.images[idx].estimatedRealWorldWidth\n              };\n            });\n            return [2\n            /*return*/\n            , {\n              trackedImages: this._originalTrackingRequest\n            }];\n\n          case 3:\n            ex_1 = _a.sent();\n            Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\n            return [2\n            /*return*/\n            , {}];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebXRImageTracking.prototype._onXRFrame = function (_xrFrame) {\n    if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\n      return;\n    } // Image tracking scores may be generated a few frames after the XR Session initializes.\n    // If we haven't received scores yet, then kick off the task to check scores and return immediately.\n\n\n    if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\n      this._checkScoresAsync();\n\n      return;\n    }\n\n    var imageTrackedResults = _xrFrame.getImageTrackingResults();\n\n    for (var _i = 0, imageTrackedResults_1 = imageTrackedResults; _i < imageTrackedResults_1.length; _i++) {\n      var result = imageTrackedResults_1[_i];\n      var changed = false;\n      var imageIndex = result.index;\n      var imageObject = this._trackedImages[imageIndex];\n\n      if (!imageObject) {\n        // something went wrong!\n        continue;\n      }\n\n      imageObject.xrTrackingResult = result;\n\n      if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\n        imageObject.realWorldWidth = result.measuredWidthInMeters;\n        changed = true;\n      } // Get the pose of the image relative to a reference space.\n\n\n      var pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\n\n      if (pose) {\n        var mat = imageObject.transformationMatrix;\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n\n        changed = true;\n      }\n\n      var state = result.trackingState;\n      var emulated = state === \"emulated\";\n\n      if (imageObject.emulated !== emulated) {\n        imageObject.emulated = emulated;\n        changed = true;\n      }\n\n      if (changed) {\n        this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\n      }\n    }\n  };\n\n  WebXRImageTracking.prototype._checkScoresAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var imageScores, idx, originalBitmap, imageObject;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\n            return [4\n            /*yield*/\n            , this._xrSessionManager.session.getTrackedImageScores()];\n\n          case 1:\n            imageScores = _a.sent();\n\n            if (!imageScores || imageScores.length === 0) {\n              this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n              return [2\n              /*return*/\n              ];\n            } // check the scores for all\n\n\n            for (idx = 0; idx < imageScores.length; ++idx) {\n              if (imageScores[idx] == \"untrackable\") {\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\n              } else {\n                originalBitmap = this._originalTrackingRequest[idx].image;\n                imageObject = {\n                  id: idx,\n                  originalBitmap: originalBitmap,\n                  transformationMatrix: new Matrix(),\n                  ratio: originalBitmap.width / originalBitmap.height\n                };\n                this._trackedImages[idx] = imageObject;\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\n              }\n            }\n\n            this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRImageTracking.Name = WebXRFeatureName.IMAGE_TRACKING;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRImageTracking.Version = 1;\n  return WebXRImageTracking;\n}(WebXRAbstractFeature);\n\nexport { WebXRImageTracking }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRImageTracking.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRImageTracking(xrSessionManager, options);\n  };\n}, WebXRImageTracking.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","WebXRAbstractFeature","Matrix","Tools","ImageTrackingScoreStatus","__extends","_xrSessionManager","options","_super","_this","NotReceived","xrNativeFeatureName","WebXRImageTracking","attach","call","detach","id","_trackedImages","dispose","forEach","trackedImage","originalBitmap","close","length","onTrackableImageFoundObservable","clear","onUntrackableImageFoundObservable","onTrackedImageUpdatedObservable","images","promises","map","image","src","scene","getEngine","_createImageBitmapFromSource","Promise","resolve","all","_a","_originalTrackingRequest","idx","widthInMeters","estimatedRealWorldWidth","trackedImages","Error","_xrFrame","getImageTrackingResults","_trackableScoreStatus","Waiting","_checkScoresAsync","imageTrackedResults","_i","result","changed","imageIndex","index","imageObject","xrTrackingResult","realWorldWidth","measuredWidthInMeters","pose","getPose","imageSpace","referenceSpace","mat","transformationMatrix","FromArrayToRef","transform","matrix","useRightHandedSystem","toggleModelMatrixHandInPlace","state","trackingState","emulated","notifyObservers","session","getTrackedImageScores","imageScores","ratio","width","height","Received","IMAGE_TRACKING","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRImageTracking.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the background remover plugin\r\n */\r\nexport interface IWebXRImageTrackingOptions {\r\n    /**\r\n     * A required array with images to track\r\n     */\r\n    images: {\r\n        /**\r\n         * The source of the image. can be a URL or an image bitmap\r\n         */\r\n        src: string | ImageBitmap;\r\n        /**\r\n         * The estimated width in the real world (in meters)\r\n         */\r\n        estimatedRealWorldWidth: number; // In meters!\r\n    }[];\r\n}\r\n\r\n/**\r\n * An object representing an image tracked by the system\r\n */\r\nexport interface IWebXRTrackedImage {\r\n    /**\r\n     * The ID of this image (which is the same as the position in the array that was used to initialize the feature)\r\n     */\r\n    id: number;\r\n    /**\r\n     * Is the transformation provided emulated. If it is, the system \"guesses\" its real position. Otherwise it can be considered as exact position.\r\n     */\r\n    emulated?: boolean;\r\n    /**\r\n     * Just in case it is needed - the image bitmap that is being tracked\r\n     */\r\n    originalBitmap: ImageBitmap;\r\n    /**\r\n     * The native XR result image tracking result, untouched\r\n     */\r\n    xrTrackingResult?: XRImageTrackingResult;\r\n    /**\r\n     * Width in real world (meters)\r\n     */\r\n    realWorldWidth?: number;\r\n    /**\r\n     * A transformation matrix of this current image in the current reference space.\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The width/height ratio of this image. can be used to calculate the size of the detected object/image\r\n     */\r\n    ratio?: number;\r\n}\r\n\r\n/**\r\n * Enum that describes the state of the image trackability score status for this session.\r\n */\r\nenum ImageTrackingScoreStatus {\r\n    // AR Session has not yet assessed image trackability scores.\r\n    NotReceived,\r\n    // A request to retrieve trackability scores has been sent, but no response has been received.\r\n    Waiting,\r\n    // Image trackability scores have been received for this session\r\n    Received,\r\n}\r\n\r\n/**\r\n * Image tracking for immersive AR sessions.\r\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\r\n */\r\nexport class WebXRImageTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.IMAGE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This will be triggered if the underlying system deems an image untrackable.\r\n     * The index is the index of the image from the array used to initialize the feature.\r\n     */\r\n    public onUntrackableImageFoundObservable: Observable<number> = new Observable();\r\n    /**\r\n     * An image was deemed trackable, and the system will start tracking it.\r\n     */\r\n    public onTrackableImageFoundObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n    /**\r\n     * The image was found and its state was updated.\r\n     */\r\n    public onTrackedImageUpdatedObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n\r\n    private _trackableScoreStatus: ImageTrackingScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n    private _trackedImages: IWebXRTrackedImage[] = [];\r\n\r\n    private _originalTrackingRequest: XRTrackedImageInit[];\r\n\r\n    /**\r\n     * constructs the image tracking feature\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * read-only options to be used in this module\r\n         */\r\n        public readonly options: IWebXRImageTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"image-tracking\";\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        return super.attach();\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        return super.detach();\r\n    }\r\n\r\n    /**\r\n     * Get a tracked image by its ID.\r\n     *\r\n     * @param id the id of the image to load (position in the init array)\r\n     * @returns a trackable image, if exists in this location\r\n     */\r\n    public getTrackedImageById(id: number): Nullable<IWebXRTrackedImage> {\r\n        return this._trackedImages[id] || null;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._trackedImages.forEach((trackedImage) => {\r\n            trackedImage.originalBitmap.close();\r\n        });\r\n        this._trackedImages.length = 0;\r\n        this.onTrackableImageFoundObservable.clear();\r\n        this.onUntrackableImageFoundObservable.clear();\r\n        this.onTrackedImageUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object fo the xr session init object.\r\n     */\r\n    public async getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        if (!this.options.images || !this.options.images.length) {\r\n            return {};\r\n        }\r\n        const promises = this.options.images.map((image) => {\r\n            if (typeof image.src === \"string\") {\r\n                return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\r\n            } else {\r\n                return Promise.resolve(image.src); // resolve is probably unneeded\r\n            }\r\n        });\r\n\r\n        try {\r\n            const images = await Promise.all(promises);\r\n\r\n            this._originalTrackingRequest = images.map((image, idx) => {\r\n                return {\r\n                    image,\r\n                    widthInMeters: this.options.images[idx].estimatedRealWorldWidth,\r\n                };\r\n            });\r\n\r\n            return {\r\n                trackedImages: this._originalTrackingRequest,\r\n            };\r\n        } catch (ex) {\r\n            Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\r\n            return {};\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\r\n            return;\r\n        }\r\n\r\n        // Image tracking scores may be generated a few frames after the XR Session initializes.\r\n        // If we haven't received scores yet, then kick off the task to check scores and return immediately.\r\n        if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\r\n            this._checkScoresAsync();\r\n            return;\r\n        }\r\n\r\n        const imageTrackedResults = _xrFrame.getImageTrackingResults();\r\n        for (const result of imageTrackedResults) {\r\n            let changed = false;\r\n            const imageIndex = result.index;\r\n\r\n            const imageObject = this._trackedImages[imageIndex];\r\n            if (!imageObject) {\r\n                // something went wrong!\r\n                continue;\r\n            }\r\n\r\n            imageObject.xrTrackingResult = result;\r\n            if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\r\n                imageObject.realWorldWidth = result.measuredWidthInMeters;\r\n                changed = true;\r\n            }\r\n\r\n            // Get the pose of the image relative to a reference space.\r\n            const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\r\n\r\n            if (pose) {\r\n                const mat = imageObject.transformationMatrix;\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                changed = true;\r\n            }\r\n\r\n            const state = result.trackingState;\r\n            const emulated = state === \"emulated\";\r\n\r\n            if (imageObject.emulated !== emulated) {\r\n                imageObject.emulated = emulated;\r\n                changed = true;\r\n            }\r\n            if (changed) {\r\n                this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _checkScoresAsync(): Promise<void> {\r\n        if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\r\n            return;\r\n        }\r\n\r\n        this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\r\n        const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\r\n        if (!imageScores || imageScores.length === 0) {\r\n            this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n            return;\r\n        }\r\n\r\n        // check the scores for all\r\n        for (let idx = 0; idx < imageScores.length; ++idx) {\r\n            if (imageScores[idx] == \"untrackable\") {\r\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\r\n            } else {\r\n                const originalBitmap = this._originalTrackingRequest[idx].image;\r\n                const imageObject: IWebXRTrackedImage = {\r\n                    id: idx,\r\n                    originalBitmap,\r\n                    transformationMatrix: new Matrix(),\r\n                    ratio: originalBitmap.width / originalBitmap.height,\r\n                };\r\n                this._trackedImages[idx] = imageObject;\r\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n\r\n        this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRImageTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRImageTracking(xrSessionManager, options);\r\n    },\r\n    WebXRImageTracking.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}