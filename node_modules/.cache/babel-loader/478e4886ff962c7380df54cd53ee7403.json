{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * Particle emitter emitting particles from a custom list of positions.\n */\n\nvar CustomParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance CustomParticleEmitter\n   */\n  function CustomParticleEmitter() {\n    /**\n     * Gets or sets the position generator that will create the initial position of each particle.\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n     */\n    this.particlePositionGenerator = function () {};\n    /**\n     * Gets or sets the destination generator that will create the final destination of each particle.\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n     */\n\n\n    this.particleDestinationGenerator = function () {};\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n\n  CustomParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var tmpVector = TmpVectors.Vector3[0];\n\n    if (this.particleDestinationGenerator) {\n      this.particleDestinationGenerator(-1, particle, tmpVector); // Get direction\n\n      var diffVector = TmpVectors.Vector3[1];\n      tmpVector.subtractToRef(particle.position, diffVector);\n      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n\n    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  CustomParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var tmpVector = TmpVectors.Vector3[0];\n\n    if (this.particlePositionGenerator) {\n      this.particlePositionGenerator(-1, particle, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n\n    if (isLocal) {\n      positionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n\n    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  CustomParticleEmitter.prototype.clone = function () {\n    var newOne = new CustomParticleEmitter();\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  CustomParticleEmitter.prototype.applyToShader = function (uboOrEffect) {};\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  CustomParticleEmitter.prototype.buildUniformLayout = function (ubo) {};\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  CustomParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CUSTOMEMITTER\";\n  };\n  /**\n   * Returns the string \"PointParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  CustomParticleEmitter.prototype.getClassName = function () {\n    return \"CustomParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  CustomParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  CustomParticleEmitter.prototype.parse = function (serializationObject) {};\n\n  return CustomParticleEmitter;\n}();\n\nexport { CustomParticleEmitter };","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,QAA2B,0BAA3B;AAEA,SAASC,OAAT,EAAkBC,UAAlB,QAAoC,4BAApC;AAMA;;;;AAGA;AAAA;AAAA;AAaI;;;AAGA;AAfA;;;;AAIO,qCAAyG,aAAQ,CAAjH;AAEP;;;;;;AAIO,wCAA+G,aAAQ,CAAvH;AAKS;AAEhB;;;;;;;;;AAOOC,2DAAP,UAA8BC,WAA9B,EAAmDC,iBAAnD,EAA+EC,QAA/E,EAAmGC,OAAnG,EAAmH;AAC/G,QAAMC,SAAS,GAAGN,UAAU,CAACD,OAAX,CAAmB,CAAnB,CAAlB;;AAEA,QAAI,KAAKQ,4BAAT,EAAuC;AACnC,WAAKA,4BAAL,CAAkC,CAAC,CAAnC,EAAsCH,QAAtC,EAAgDE,SAAhD,EADmC,CAGnC;;AACA,UAAME,UAAU,GAAGR,UAAU,CAACD,OAAX,CAAmB,CAAnB,CAAnB;AACAO,eAAS,CAACG,aAAV,CAAwBL,QAAQ,CAACM,QAAjC,EAA2CF,UAA3C;AAEAA,gBAAU,CAACG,UAAX,CAAsB,IAAIP,QAAQ,CAACQ,QAAnC,EAA6CN,SAA7C;AACH,KARD,MAQO;AACHA,eAAS,CAACO,GAAV,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB;AACH;;AAED,QAAIR,OAAJ,EAAa;AACTF,uBAAiB,CAACW,QAAlB,CAA2BR,SAA3B;AACA;AACH;;AAEDP,WAAO,CAACgB,oBAAR,CAA6BT,SAA7B,EAAwCJ,WAAxC,EAAqDC,iBAArD;AACH,GArBM;AAuBP;;;;;;;;;AAOOF,0DAAP,UAA6BC,WAA7B,EAAkDc,gBAAlD,EAA6EZ,QAA7E,EAAiGC,OAAjG,EAAiH;AAC7G,QAAMC,SAAS,GAAGN,UAAU,CAACD,OAAX,CAAmB,CAAnB,CAAlB;;AAEA,QAAI,KAAKkB,yBAAT,EAAoC;AAChC,WAAKA,yBAAL,CAA+B,CAAC,CAAhC,EAAmCb,QAAnC,EAA6CE,SAA7C;AACH,KAFD,MAEO;AACHA,eAAS,CAACO,GAAV,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB;AACH;;AAED,QAAIR,OAAJ,EAAa;AACTW,sBAAgB,CAACF,QAAjB,CAA0BR,SAA1B;AACA;AACH;;AAEDP,WAAO,CAACmB,yBAAR,CAAkCZ,SAAlC,EAA6CJ,WAA7C,EAA0Dc,gBAA1D;AACH,GAfM;AAiBP;;;;;;AAIOf,0CAAP;AACI,QAAMkB,MAAM,GAAG,IAAIlB,qBAAJ,EAAf;AAEAH,cAAU,CAACsB,QAAX,CAAoB,IAApB,EAA0BD,MAA1B;AAEA,WAAOA,MAAP;AACH,GANM;AAQP;;;;AAIA;;;AACOlB,kDAAP,UAAqBoB,WAArB,EAAmE,CAAU,CAAtE;AAEP;;;;AAIA;;;AACOpB,uDAAP,UAA0BqB,GAA1B,EAA4C,CAAU,CAA/C;AAEP;;;;;;AAIOrB,qDAAP;AACI,WAAO,uBAAP;AACH,GAFM;AAIP;;;;;;AAIOA,iDAAP;AACI,WAAO,uBAAP;AACH,GAFM;AAIP;;;;;;AAIOA,8CAAP;AACI,QAAMsB,mBAAmB,GAAQ,EAAjC;AAEAA,uBAAmB,CAACC,IAApB,GAA2B,KAAKC,YAAL,EAA3B;AAEA,WAAOF,mBAAP;AACH,GANM;AAQP;;;;AAIA;;;AACOtB,0CAAP,UAAasB,mBAAb,EAAqC,CAAU,CAAxC;;AACX;AAAC,CApID","names":["DeepCopier","Vector3","TmpVectors","CustomParticleEmitter","worldMatrix","directionToUpdate","particle","isLocal","tmpVector","particleDestinationGenerator","diffVector","subtractToRef","position","scaleToRef","lifeTime","set","copyFrom","TransformNormalToRef","positionToUpdate","particlePositionGenerator","TransformCoordinatesToRef","newOne","DeepCopy","uboOrEffect","ubo","serializationObject","type","getClassName"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/customParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Particle } from \"../particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\r\nexport class CustomParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Gets or sets the position generator that will create the initial position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Creates a new instance CustomParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particleDestinationGenerator) {\r\n            this.particleDestinationGenerator(-1, particle, tmpVector);\r\n\r\n            // Get direction\r\n            const diffVector = TmpVectors.Vector3[1];\r\n            tmpVector.subtractToRef(particle.position, diffVector);\r\n\r\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particlePositionGenerator) {\r\n            this.particlePositionGenerator(-1, particle, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CustomParticleEmitter {\r\n        const newOne = new CustomParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {}\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public buildUniformLayout(ubo: UniformBuffer): void {}\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CUSTOMEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CustomParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public parse(serializationObject: any): void {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}