{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n */\n\nvar ArcRotateCameraPointersInput =\n/** @class */\nfunction (_super) {\n  __extends(ArcRotateCameraPointersInput, _super);\n\n  function ArcRotateCameraPointersInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n\n\n    _this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X axis or how fast is\n     * the camera rotating.\n     */\n\n    _this.angularSensibilityX = 1000.0;\n    /**\n     * Defines the pointer angular sensibility along the Y axis or how fast is\n     * the camera rotating.\n     */\n\n    _this.angularSensibilityY = 1000.0;\n    /**\n     * Defines the pointer pinch precision or how fast is the camera zooming.\n     */\n\n    _this.pinchPrecision = 12.0;\n    /**\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\n     * from 0.\n     * It defines the percentage of current camera.radius to use as delta when\n     * pinch zoom is used.\n     */\n\n    _this.pinchDeltaPercentage = 0;\n    /**\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\n     * that any object in the plane at the camera's target point will scale\n     * perfectly with finger motion.\n     * Overrides pinchDeltaPercentage and pinchPrecision.\n     */\n\n    _this.useNaturalPinchZoom = false;\n    /**\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\n     */\n\n    _this.pinchZoom = true;\n    /**\n     * Defines the pointer panning sensibility or how fast is the camera moving.\n     */\n\n    _this.panningSensibility = 1000.0;\n    /**\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\n     */\n\n    _this.multiTouchPanning = true;\n    /**\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\n     * zoom (pinch) through multitouch.\n     */\n\n    _this.multiTouchPanAndZoom = true;\n    /**\n     * Revers pinch action direction.\n     */\n\n    _this.pinchInwards = true;\n    _this._isPanClick = false;\n    _this._twoFingerActivityCount = 0;\n    _this._isPinching = false;\n    return _this;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.getClassName = function () {\n    return \"ArcRotateCameraPointersInput\";\n  };\n  /**\n   * Move camera from multi touch panning positions.\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n\n\n  ArcRotateCameraPointersInput.prototype._computeMultiTouchPanning = function (previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n      var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n      var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n      this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n      this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n    }\n  };\n  /**\n   * Move camera from pinch zoom distances.\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   */\n\n\n  ArcRotateCameraPointersInput.prototype._computePinchZoom = function (previousPinchSquaredDistance, pinchSquaredDistance) {\n    var radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\n\n    if (this.useNaturalPinchZoom) {\n      this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\n    } else if (this.pinchDeltaPercentage) {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\n    } else {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n    }\n  };\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * @param point\n   * @param offsetX\n   * @param offsetY\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {\n    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {\n      this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n      this.camera.inertialPanningY += offsetY / this.panningSensibility;\n    } else {\n      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n    }\n  };\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onDoubleTap = function () {\n    if (this.camera.useInputToRestoreState) {\n      this.camera.restoreState();\n    }\n  };\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * @param pointA\n   * @param pointB\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    } // Zoom and panning enabled together\n\n\n    if (this.multiTouchPanAndZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition); // Zoom and panning enabled but only one at a time\n\n    } else if (this.multiTouchPanning && this.pinchZoom) {\n      this._twoFingerActivityCount++;\n\n      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {\n        // Since pinch has not been active long, assume we intend to zoom.\n        this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance); // Since we are pinching, remain pinching on next iteration.\n\n\n        this._isPinching = true;\n      } else {\n        // Pause between pinch starting and moving implies not a zoom event. Pan instead.\n        this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      } // Panning enabled, zoom disabled\n\n    } else if (this.multiTouchPanning) {\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition); // Zoom enabled, panning disabled\n\n    } else if (this.pinchZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n    }\n  };\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * @param evt\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonDown = function (evt) {\n    this._isPanClick = evt.button === this.camera._panningMouseButton;\n  };\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonUp = function () {\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n  /**\n   * Called when window becomes inactive.\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onLostFocus = function () {\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n  /**\n   * The minimum radius used for pinch, to avoid radius lock at 0\n   */\n\n\n  ArcRotateCameraPointersInput.MinimumRadiusForPinch = 0.001;\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchZoom\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\n\n  return ArcRotateCameraPointersInput;\n}(BaseCameraPointersInput);\n\nexport { ArcRotateCameraPointersInput };\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","BaseCameraPointersInput","__extends","_this","ArcRotateCameraPointersInput","previousMultiTouchPanPosition","multiTouchPanPosition","panningSensibility","moveDeltaX","x","moveDeltaY","y","camera","inertialPanningX","inertialPanningY","previousPinchSquaredDistance","pinchSquaredDistance","radius","MinimumRadiusForPinch","useNaturalPinchZoom","Math","sqrt","pinchDeltaPercentage","inertialRadiusOffset","pinchPrecision","pinchInwards","angularSensibilityX","angularSensibilityY","point","offsetX","offsetY","_ctrlKey","_useCtrlForPanning","_isPanClick","inertialAlphaOffset","inertialBetaOffset","useInputToRestoreState","restoreState","pointA","pointB","multiTouchPanAndZoom","_computePinchZoom","_computeMultiTouchPanning","multiTouchPanning","pinchZoom","_twoFingerActivityCount","_isPinching","abs","pinchToPanMaxDistance","evt","button","_panningMouseButton","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/arcRotateCameraPointersInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA\r\n     * @param pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     */\r\n    public onButtonUp(): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n"]},"metadata":{},"sourceType":"module"}