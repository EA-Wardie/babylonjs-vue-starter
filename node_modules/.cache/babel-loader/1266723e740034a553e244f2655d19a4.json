{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { ExternalTexture } from \"../../Materials/Textures/externalTexture.js\";\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler.js\";\n/** @hidden */\n\nvar WebGPUMaterialContext =\n/** @class */\nfunction () {\n  function WebGPUMaterialContext() {\n    this.uniqueId = WebGPUMaterialContext._Counter++;\n    this.updateId = 0;\n    this.reset();\n  }\n\n  Object.defineProperty(WebGPUMaterialContext.prototype, \"forceBindGroupCreation\", {\n    get: function get() {\n      // If there is at least one external texture to bind, we must recreate the bind groups each time\n      // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\n      return this._numExternalTextures > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebGPUMaterialContext.prototype, \"hasFloatTextures\", {\n    get: function get() {\n      return this._numFloatTextures > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebGPUMaterialContext.prototype.reset = function () {\n    this.samplers = {};\n    this.textures = {};\n    this.isDirty = true;\n    this._numFloatTextures = 0;\n    this._numExternalTextures = 0;\n  };\n\n  WebGPUMaterialContext.prototype.setSampler = function (name, sampler) {\n    var samplerCache = this.samplers[name];\n    var currentHashCode = -1;\n\n    if (!samplerCache) {\n      this.samplers[name] = samplerCache = {\n        sampler: sampler,\n        hashCode: 0\n      };\n    } else {\n      currentHashCode = samplerCache.hashCode;\n    }\n\n    samplerCache.sampler = sampler;\n    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\n    var isDirty = currentHashCode !== samplerCache.hashCode;\n\n    if (isDirty) {\n      this.updateId++;\n    }\n\n    this.isDirty || (this.isDirty = isDirty);\n  };\n\n  WebGPUMaterialContext.prototype.setTexture = function (name, texture) {\n    var _a, _b, _c;\n\n    var textureCache = this.textures[name];\n    var currentTextureId = -1;\n\n    if (!textureCache) {\n      this.textures[name] = textureCache = {\n        texture: texture,\n        isFloatTexture: false,\n        isExternalTexture: false\n      };\n    } else {\n      currentTextureId = (_b = (_a = textureCache.texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : -1;\n    }\n\n    if (textureCache.isExternalTexture) {\n      this._numExternalTextures--;\n    }\n\n    if (textureCache.isFloatTexture) {\n      this._numFloatTextures--;\n    }\n\n    if (texture) {\n      textureCache.isFloatTexture = texture.type === 1;\n      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\n\n      if (textureCache.isFloatTexture) {\n        this._numFloatTextures++;\n      }\n\n      if (textureCache.isExternalTexture) {\n        this._numExternalTextures++;\n      }\n    } else {\n      textureCache.isFloatTexture = false;\n      textureCache.isExternalTexture = false;\n    }\n\n    textureCache.texture = texture;\n    var isDirty = currentTextureId !== ((_c = texture === null || texture === void 0 ? void 0 : texture.uniqueId) !== null && _c !== void 0 ? _c : -1);\n\n    if (isDirty) {\n      this.updateId++;\n    }\n\n    this.isDirty || (this.isDirty = isDirty);\n  };\n\n  WebGPUMaterialContext._Counter = 0;\n  return WebGPUMaterialContext;\n}();\n\nexport { WebGPUMaterialContext };","map":{"version":3,"mappings":"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","names":["ExternalTexture","WebGPUCacheSampler","uniqueId","WebGPUMaterialContext","_Counter","updateId","reset","Object","_numExternalTextures","_numFloatTextures","samplers","textures","isDirty","name","sampler","samplerCache","currentHashCode","hashCode","GetSamplerHashCode","texture","textureCache","currentTextureId","isFloatTexture","isExternalTexture","_a","_b","type","IsExternalTexture","_c"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuMaterialContext.ts"],"sourcesContent":["import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @hidden */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @hidden */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @hidden */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatTextures() {\r\n        return this._numFloatTextures > 0;\r\n    }\r\n\r\n    protected _numFloatTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatTexture) {\r\n            this._numFloatTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatTexture = texture.type === Constants.TEXTURETYPE_FLOAT;\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatTexture) {\r\n                this._numFloatTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}