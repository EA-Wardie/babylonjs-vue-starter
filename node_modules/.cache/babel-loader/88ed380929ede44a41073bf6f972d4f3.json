{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport \"../../Engines/Extensions/engine.cubeTexture.js\";\nimport { StartsWith } from \"../../Misc/stringTools.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Class for creating a cube texture\n */\n\nvar CubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(CubeTexture, _super);\n  /**\n   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\n   * as prefiltered data.\n   * @param rootUrl defines the url of the texture or the root name of the six images\n   * @param sceneOrEngine defines the scene or engine the texture is attached to\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n   * @param noMipmap defines if mipmaps should be created or not\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n   * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\n   * @param onError defines a callback triggered in case of error during load\n   * @param format defines the internal format to use for the texture once loaded\n   * @param prefiltered defines whether or not the texture is created from prefiltered data\n   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @param loaderOptions options to be passed to the loader\n   * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\n   * @return the cube texture\n   */\n\n\n  function CubeTexture(rootUrl, sceneOrEngine, extensions, noMipmap, files, onLoad, onError, format, prefiltered, forcedExtension, createPolynomials, lodScale, lodOffset, loaderOptions, useSRGBBuffer) {\n    if (extensions === void 0) {\n      extensions = null;\n    }\n\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (files === void 0) {\n      files = null;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = false;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    var _this = this;\n\n    var _a;\n\n    _this = _super.call(this, sceneOrEngine) || this;\n    _this._lodScale = 0.8;\n    _this._lodOffset = 0;\n    /**\n     * Observable triggered once the texture has been loaded.\n     */\n\n    _this.onLoadObservable = new Observable();\n    /**\n     * Gets or sets the center of the bounding box associated with the cube texture.\n     * It must define where the camera used to render the texture was set\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    _this._rotationY = 0;\n    _this._files = null;\n    _this._forcedExtension = null;\n    _this._extensions = null;\n    _this.name = rootUrl;\n    _this.url = rootUrl;\n    _this._noMipmap = noMipmap;\n    _this.hasAlpha = false;\n    _this._format = format;\n    _this.isCube = true;\n    _this._textureMatrix = Matrix.Identity();\n    _this._createPolynomials = createPolynomials;\n    _this.coordinatesMode = Texture.CUBIC_MODE;\n    _this._extensions = extensions;\n    _this._files = files;\n    _this._forcedExtension = forcedExtension;\n    _this._loaderOptions = loaderOptions;\n    _this._useSRGBBuffer = useSRGBBuffer;\n    _this._lodScale = lodScale;\n    _this._lodOffset = lodOffset;\n\n    if (!rootUrl && !files) {\n      return _this;\n    }\n\n    _this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading, files);\n\n    return _this;\n  }\n\n  Object.defineProperty(CubeTexture.prototype, \"boundingBoxSize\", {\n    /**\n     * Returns the bounding box size\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\n     */\n    get: function get() {\n      return this._boundingBoxSize;\n    },\n\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set: function set(value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"rotationY\", {\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get: function get() {\n      return this._rotationY;\n    },\n\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set: function set(value) {\n      this._rotationY = value;\n      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"noMipmap\", {\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get: function get() {\n      return this._noMipmap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"forcedExtension\", {\n    /**\n     * Gets the forced extension (if any)\n     */\n    get: function get() {\n      return this._forcedExtension;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a cube texture from an array of image urls\n   * @param files defines an array of image urls\n   * @param scene defines the hosting scene\n   * @param noMipmap specifies if mip maps are not used\n   * @returns a cube texture\n   */\n\n  CubeTexture.CreateFromImages = function (files, scene, noMipmap) {\n    var rootUrlKey = \"\";\n    files.forEach(function (url) {\n      return rootUrlKey += url;\n    });\n    return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n  };\n  /**\n   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\n   * @param url defines the url of the prefiltered texture\n   * @param scene defines the scene the texture is attached to\n   * @param forcedExtension defines the extension of the file if different from the url\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n   * @return the prefiltered texture\n   */\n\n\n  CubeTexture.CreateFromPrefilteredData = function (url, scene, forcedExtension, createPolynomials) {\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = true;\n    }\n\n    var oldValue = scene.useDelayedTextureLoading;\n    scene.useDelayedTextureLoading = false;\n    var result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n    scene.useDelayedTextureLoading = oldValue;\n    return result;\n  };\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"CubeTexture\"\n   */\n\n\n  CubeTexture.prototype.getClassName = function () {\n    return \"CubeTexture\";\n  };\n  /**\n   * Update the url (and optional buffer) of this texture if url was null during construction.\n   * @param url the url of the texture\n   * @param forcedExtension defines the extension to use\n   * @param onLoad callback called when the texture is loaded  (defaults to null)\n   * @param prefiltered Defines whether the updated texture is prefiltered or not\n   * @param onError callback called if there was an error during the loading process (defaults to null)\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n   * @param delayLoad defines if the texture should be loaded now (false by default)\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n   */\n\n\n  CubeTexture.prototype.updateURL = function (url, forcedExtension, onLoad, prefiltered, onError, extensions, delayLoad, files) {\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (extensions === void 0) {\n      extensions = null;\n    }\n\n    if (delayLoad === void 0) {\n      delayLoad = false;\n    }\n\n    if (files === void 0) {\n      files = null;\n    }\n\n    if (!this.name || StartsWith(this.name, \"data:\")) {\n      this.name = url;\n    }\n\n    this.url = url;\n    var lastDot = url.lastIndexOf(\".\");\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    var isDDS = extension.indexOf(\".dds\") === 0;\n    var isEnv = extension.indexOf(\".env\") === 0;\n\n    if (isEnv) {\n      this.gammaSpace = false;\n      this._prefiltered = false;\n      this.anisotropicFilteringLevel = 1;\n    } else {\n      this._prefiltered = prefiltered;\n\n      if (prefiltered) {\n        this.gammaSpace = false;\n        this.anisotropicFilteringLevel = 1;\n      }\n    }\n\n    if (files) {\n      this._files = files;\n    } else {\n      if (!isEnv && !isDDS && !extensions) {\n        extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n      }\n\n      this._files = this._files || [];\n      this._files.length = 0;\n\n      if (extensions) {\n        for (var index = 0; index < extensions.length; index++) {\n          this._files.push(url + extensions[index]);\n        }\n\n        this._extensions = extensions;\n      }\n    }\n\n    if (delayLoad) {\n      this.delayLoadState = 4;\n      this._delayedOnLoad = onLoad;\n      this._delayedOnError = onError;\n    } else {\n      this._loadTexture(onLoad, onError);\n    }\n  };\n  /**\n   * Delays loading of the cube texture\n   * @param forcedExtension defines the extension to use\n   */\n\n\n  CubeTexture.prototype.delayLoad = function (forcedExtension) {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    if (forcedExtension) {\n      this._forcedExtension = forcedExtension;\n    }\n\n    this.delayLoadState = 1;\n\n    this._loadTexture(this._delayedOnLoad, this._delayedOnError);\n  };\n  /**\n   * Returns the reflection texture matrix\n   * @returns the reflection texture matrix\n   */\n\n\n  CubeTexture.prototype.getReflectionTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\n   * Sets the reflection texture matrix\n   * @param value Reflection texture matrix\n   */\n\n\n  CubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n    var _this = this;\n\n    var _a;\n\n    if (value.updateFlag === this._textureMatrix.updateFlag) {\n      return;\n    }\n\n    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function (mat) {\n        return mat.getActiveTextures().indexOf(_this) !== -1;\n      });\n    }\n\n    this._textureMatrix = value;\n  };\n\n  CubeTexture.prototype._loadTexture = function (onLoad, onError) {\n    var _this = this;\n\n    var _a;\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var scene = this.getScene();\n    var oldTexture = this._texture;\n    this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer);\n\n    var onLoadProcessing = function onLoadProcessing() {\n      var _a;\n\n      _this.onLoadObservable.notifyObservers(_this);\n\n      if (oldTexture) {\n        oldTexture.dispose();\n        (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);\n      }\n\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      _this._loadingError = true;\n      _this._errorObject = {\n        message: message,\n        exception: exception\n      };\n\n      if (onError) {\n        onError(message, exception);\n      }\n\n      Texture.OnTextureLoadErrorObservable.notifyObservers(_this);\n    };\n\n    if (!this._texture) {\n      if (this._prefiltered) {\n        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);\n      } else {\n        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);\n      }\n\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function () {\n        return _this.onLoadObservable.notifyObservers(_this);\n      });\n    } else {\n      if (this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoadProcessing();\n        });\n      } else {\n        this._texture.onLoadedObservable.add(function () {\n          return onLoadProcessing();\n        });\n      }\n    }\n  };\n  /**\n   * Parses text to create a cube texture\n   * @param parsedTexture define the serialized text to read from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url of the cube texture\n   * @returns a cube texture\n   */\n\n\n  CubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n    var texture = SerializationHelper.Parse(function () {\n      var prefiltered = false;\n\n      if (parsedTexture.prefiltered) {\n        prefiltered = parsedTexture.prefiltered;\n      }\n\n      return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n    }, parsedTexture, scene); // Local Cubemaps\n\n    if (parsedTexture.boundingBoxPosition) {\n      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n    }\n\n    if (parsedTexture.boundingBoxSize) {\n      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n    } // Animations\n\n\n    if (parsedTexture.animations) {\n      for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n        var parsedAnimation = parsedTexture.animations[animationIndex];\n        var internalClass = GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          texture.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n\n    return texture;\n  };\n  /**\n   * Makes a clone, or deep copy, of the cube texture\n   * @returns a new cube texture\n   */\n\n\n  CubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    var uniqueId = 0;\n    var newCubeTexture = SerializationHelper.Clone(function () {\n      var cubeTexture = new CubeTexture(_this.url, _this.getScene() || _this._getEngine(), _this._extensions, _this._noMipmap, _this._files);\n      uniqueId = cubeTexture.uniqueId;\n      return cubeTexture;\n    }, this);\n    newCubeTexture.uniqueId = uniqueId;\n    return newCubeTexture;\n  };\n\n  __decorate([serialize()], CubeTexture.prototype, \"url\", void 0);\n\n  __decorate([serialize(\"rotationY\")], CubeTexture.prototype, \"rotationY\", null);\n\n  __decorate([serialize(\"files\")], CubeTexture.prototype, \"_files\", void 0);\n\n  __decorate([serialize(\"forcedExtension\")], CubeTexture.prototype, \"_forcedExtension\", void 0);\n\n  __decorate([serialize(\"extensions\")], CubeTexture.prototype, \"_extensions\", void 0);\n\n  __decorate([serializeAsMatrix(\"textureMatrix\")], CubeTexture.prototype, \"_textureMatrix\", void 0);\n\n  return CubeTexture;\n}(BaseTexture);\n\nexport { CubeTexture };\nTexture._CubeTextureParser = CubeTexture.Parse; // Some exporters relies on Tools.Instantiate\n\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsMatrix","SerializationHelper","Tools","Matrix","Vector3","BaseTexture","Texture","GetClass","RegisterClass","StartsWith","Observable","__extends","rootUrl","sceneOrEngine","extensions","noMipmap","files","onLoad","onError","format","prefiltered","forcedExtension","createPolynomials","lodScale","lodOffset","loaderOptions","useSRGBBuffer","_super","_this","Zero","name","url","_noMipmap","hasAlpha","_format","isCube","_textureMatrix","Identity","_createPolynomials","coordinatesMode","CUBIC_MODE","_extensions","_files","_forcedExtension","_loaderOptions","_useSRGBBuffer","_lodScale","_lodOffset","updateURL","getScene","_a","useDelayedTextureLoading","Object","CubeTexture","_boundingBoxSize","value","equals","scene","markAllMaterialsAsDirty","_rotationY","setReflectionTextureMatrix","RotationY","rootUrlKey","forEach","oldValue","result","undefined","delayLoad","lastDot","lastIndexOf","extension","substring","toLowerCase","isDDS","indexOf","isEnv","gammaSpace","_prefiltered","anisotropicFilteringLevel","length","index","push","delayLoadState","_delayedOnLoad","_delayedOnError","_loadTexture","updateFlag","isIdentity","mat","oldTexture","_texture","_getFromCache","onLoadProcessing","onLoadObservable","notifyObservers","dispose","errorHandler","message","exception","_loadingError","_errorObject","OnTextureLoadErrorObservable","_getEngine","createPrefilteredCubeTexture","createCubeTexture","onLoadedObservable","add","isReady","SetImmediate","parsedTexture","texture","Parse","boundingBoxPosition","FromArray","boundingBoxSize","animations","animationIndex","parsedAnimation","internalClass","uniqueId","newCubeTexture","Clone","cubeTexture","__decorate","_CubeTextureParser"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/cubeTexture.ts"],"sourcesContent":["import { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { StartsWith } from \"../../Misc/stringTools\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number = 0.8;\r\n    private _lodOffset: number = 0;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    @serialize(\"files\")\r\n    private _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => (rootUrlKey += url));\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @return the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @return the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        extensions: Nullable<string[]> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = 0.8,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._lodScale = lodScale;\r\n        this._lodOffset = lodOffset;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension?: string,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null\r\n    ): void {\r\n        if (!this.name || StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + parsedTexture.name,\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n"]},"metadata":{},"sourceType":"module"}