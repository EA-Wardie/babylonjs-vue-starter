{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\n/**\n * Unique ID when we import meshes from Babylon to CSG\n */\n\nvar currentCSGMeshId = 0;\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n */\n\nvar Vertex =\n/** @class */\nfunction () {\n  /**\n   * Initializes the vertex\n   * @param pos The position of the vertex\n   * @param normal The normal of the vertex\n   * @param uv The texture coordinate of the vertex\n   * @param vertColor The RGBA color of the vertex\n   */\n  function Vertex(\n  /**\n   * The position of the vertex\n   */\n  pos,\n  /**\n   * The normal of the vertex\n   */\n  normal,\n  /**\n   * The texture coordinate of the vertex\n   */\n  uv,\n  /**\n   * The texture coordinate of the vertex\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\n   * Make a clone, or deep copy, of the vertex\n   * @returns A new Vertex\n   */\n\n\n  Vertex.prototype.clone = function () {\n    var _a, _b;\n\n    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n  };\n  /**\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\n   * orientation of a polygon is flipped.\n   */\n\n\n  Vertex.prototype.flip = function () {\n    this.normal = this.normal.scale(-1);\n  };\n  /**\n   * Create a new vertex between this vertex and `other` by linearly\n   * interpolating all properties using a parameter of `t`. Subclasses should\n   * override this to interpolate additional properties.\n   * @param other the vertex to interpolate against\n   * @param t The factor used to linearly interpolate between the vertices\n   */\n\n\n  Vertex.prototype.interpolate = function (other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  };\n\n  return Vertex;\n}();\n/**\n * Represents a plane in 3D space.\n */\n\n\nvar Plane =\n/** @class */\nfunction () {\n  /**\n   * Initializes the plane\n   * @param normal The normal for the plane\n   * @param w\n   */\n  function Plane(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\n   * Construct a plane from three points\n   * @param a Point a\n   * @param b Point b\n   * @param c Point c\n   */\n\n\n  Plane.FromPoints = function (a, b, c) {\n    var v0 = c.subtract(a);\n    var v1 = b.subtract(a);\n\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n\n    var n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new Plane(n, Vector3.Dot(n, a));\n  };\n  /**\n   * Clone, or make a deep copy of the plane\n   * @returns a new Plane\n   */\n\n\n  Plane.prototype.clone = function () {\n    return new Plane(this.normal.clone(), this.w);\n  };\n  /**\n   * Flip the face of the plane\n   */\n\n\n  Plane.prototype.flip = function () {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  };\n  /**\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\n   * fragments in the appropriate lists. Coplanar polygons go into either\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\n   * respect to this plane. Polygons in front or in back of this plane go into\n   * either `front` or `back`\n   * @param polygon The polygon to be split\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\n   * @param front Will contain the polygons in front of the plane\n   * @param back Will contain the polygons begind the plane\n   */\n\n\n  Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {\n    var COPLANAR = 0;\n    var FRONT = 1;\n    var BACK = 2;\n    var SPANNING = 3; // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n\n    var polygonType = 0;\n    var types = [];\n    var i;\n    var t;\n\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      var type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    } // Put the polygon in the correct list, splitting it when necessary\n\n\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n\n      case FRONT:\n        front.push(polygon);\n        break;\n\n      case BACK:\n        back.push(polygon);\n        break;\n\n      case SPANNING:\n        {\n          var f = [],\n              b = [];\n\n          for (i = 0; i < polygon.vertices.length; i++) {\n            var j = (i + 1) % polygon.vertices.length;\n            var ti = types[i],\n                tj = types[j];\n            var vi = polygon.vertices[i],\n                vj = polygon.vertices[j];\n\n            if (ti !== BACK) {\n              f.push(vi);\n            }\n\n            if (ti !== FRONT) {\n              b.push(ti !== BACK ? vi.clone() : vi);\n            }\n\n            if ((ti | tj) === SPANNING) {\n              t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n              var v = vi.interpolate(vj, t);\n              f.push(v);\n              b.push(v.clone());\n            }\n          }\n\n          var poly = void 0;\n\n          if (f.length >= 3) {\n            poly = new Polygon(f, polygon.shared);\n\n            if (poly.plane) {\n              front.push(poly);\n            }\n          }\n\n          if (b.length >= 3) {\n            poly = new Polygon(b, polygon.shared);\n\n            if (poly.plane) {\n              back.push(poly);\n            }\n          }\n\n          break;\n        }\n    }\n  };\n  /**\n   * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n   * point is on the plane\n   */\n\n\n  Plane.EPSILON = 1e-5;\n  return Plane;\n}();\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop.\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color)\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  /**\n   * Initializes the polygon\n   * @param vertices The vertices of the polygon\n   * @param shared The properties shared across all polygons\n   */\n  function Polygon(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\n   * Clones, or makes a deep copy, or the polygon\n   */\n\n\n  Polygon.prototype.clone = function () {\n    var vertices = this.vertices.map(function (v) {\n      return v.clone();\n    });\n    return new Polygon(vertices, this.shared);\n  };\n  /**\n   * Flips the faces of the polygon\n   */\n\n\n  Polygon.prototype.flip = function () {\n    this.vertices.reverse().map(function (v) {\n      v.flip();\n    });\n    this.plane.flip();\n  };\n\n  return Polygon;\n}();\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\n   * Initializes the node\n   * @param polygons A collection of polygons held in the node\n   */\n  function Node(polygons) {\n    this._plane = null;\n    this._front = null;\n    this._back = null;\n    this._polygons = new Array();\n\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\n   * Clones, or makes a deep copy, of the node\n   * @returns The cloned node\n   */\n\n\n  Node.prototype.clone = function () {\n    var node = new Node();\n    node._plane = this._plane && this._plane.clone();\n    node._front = this._front && this._front.clone();\n    node._back = this._back && this._back.clone();\n    node._polygons = this._polygons.map(function (p) {\n      return p.clone();\n    });\n    return node;\n  };\n  /**\n   * Convert solid space to empty space and empty space to solid space\n   */\n\n\n  Node.prototype.invert = function () {\n    for (var i = 0; i < this._polygons.length; i++) {\n      this._polygons[i].flip();\n    }\n\n    if (this._plane) {\n      this._plane.flip();\n    }\n\n    if (this._front) {\n      this._front.invert();\n    }\n\n    if (this._back) {\n      this._back.invert();\n    }\n\n    var temp = this._front;\n    this._front = this._back;\n    this._back = temp;\n  };\n  /**\n   * Recursively remove all polygons in `polygons` that are inside this BSP\n   * tree.\n   * @param polygons Polygons to remove from the BSP\n   * @returns Polygons clipped from the BSP\n   */\n\n\n  Node.prototype.clipPolygons = function (polygons) {\n    if (!this._plane) {\n      return polygons.slice();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n\n    if (this._front) {\n      front = this._front.clipPolygons(front);\n    }\n\n    if (this._back) {\n      back = this._back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n\n    return front.concat(back);\n  };\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `bsp`.\n   * @param bsp BSP containing polygons to remove from this BSP\n   */\n\n\n  Node.prototype.clipTo = function (bsp) {\n    this._polygons = bsp.clipPolygons(this._polygons);\n\n    if (this._front) {\n      this._front.clipTo(bsp);\n    }\n\n    if (this._back) {\n      this._back.clipTo(bsp);\n    }\n  };\n  /**\n   * Return a list of all polygons in this BSP tree\n   * @returns List of all polygons in this BSP tree\n   */\n\n\n  Node.prototype.allPolygons = function () {\n    var polygons = this._polygons.slice();\n\n    if (this._front) {\n      polygons = polygons.concat(this._front.allPolygons());\n    }\n\n    if (this._back) {\n      polygons = polygons.concat(this._back.allPolygons());\n    }\n\n    return polygons;\n  };\n  /**\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\n   * new polygons are filtered down to the bottom of the tree and become new\n   * nodes there. Each set of polygons is partitioned using the first polygon\n   * (no heuristic is used to pick a good split)\n   * @param polygons Polygons used to construct the BSP tree\n   */\n\n\n  Node.prototype.build = function (polygons) {\n    if (!polygons.length) {\n      return;\n    }\n\n    if (!this._plane) {\n      this._plane = polygons[0].plane.clone();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\n    }\n\n    if (front.length) {\n      if (!this._front) {\n        this._front = new Node();\n      }\n\n      this._front.build(front);\n    }\n\n    if (back.length) {\n      if (!this._back) {\n        this._back = new Node();\n      }\n\n      this._back.build(back);\n    }\n  };\n\n  return Node;\n}();\n/**\n * Class for building Constructive Solid Geometry\n */\n\n\nvar CSG =\n/** @class */\nfunction () {\n  function CSG() {\n    this._polygons = new Array();\n  }\n  /**\n   * Convert the Mesh to CSG\n   * @param mesh The Mesh to convert to CSG\n   * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\n   * @returns A new CSG from the Mesh\n   */\n\n\n  CSG.FromMesh = function (mesh, absolute) {\n    if (absolute === void 0) {\n      absolute = false;\n    }\n\n    var vertex,\n        normal,\n        uv = undefined,\n        position,\n        vertColor = undefined,\n        polygon,\n        vertices;\n    var polygons = new Array();\n    var matrix,\n        meshPosition,\n        meshRotation,\n        meshRotationQuaternion = null,\n        meshScaling;\n    var invertWinding = false;\n\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n\n      meshScaling = mesh.scaling.clone();\n\n      if (mesh.material && absolute) {\n        invertWinding = mesh.material.sideOrientation === 0;\n      }\n    } else {\n      throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n    }\n\n    var indices = mesh.getIndices(),\n        positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n        normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n        uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n        vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var subMeshes = mesh.subMeshes;\n\n    for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n\n        for (var j = 0; j < 3; j++) {\n          var indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\n          var sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\n\n          if (uvs) {\n            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\n          }\n\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);\n          }\n\n          var sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n\n        polygon = new Polygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        }); // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n\n    var csg = CSG._FromPolygons(polygons);\n\n    csg.matrix = absolute ? Matrix.Identity() : matrix;\n    csg.position = absolute ? Vector3.Zero() : meshPosition;\n    csg.rotation = absolute ? Vector3.Zero() : meshRotation;\n    csg.scaling = absolute ? Vector3.One() : meshScaling;\n    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  };\n  /**\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\n   * @param polygons Polygons used to construct a CSG solid\n   */\n\n\n  CSG._FromPolygons = function (polygons) {\n    var csg = new CSG();\n    csg._polygons = polygons;\n    return csg;\n  };\n  /**\n   * Clones, or makes a deep copy, of the CSG\n   * @returns A new CSG\n   */\n\n\n  CSG.prototype.clone = function () {\n    var csg = new CSG();\n    csg._polygons = this._polygons.map(function (p) {\n      return p.clone();\n    });\n    csg.copyTransformAttributes(this);\n    return csg;\n  };\n  /**\n   * Unions this CSG with another CSG\n   * @param csg The CSG to union against this CSG\n   * @returns The unioned CSG\n   */\n\n\n  CSG.prototype.union = function (csg) {\n    var a = new Node(this.clone()._polygons);\n    var b = new Node(csg.clone()._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\n   * Unions this CSG with another CSG in place\n   * @param csg The CSG to union against this CSG\n   */\n\n\n  CSG.prototype.unionInPlace = function (csg) {\n    var a = new Node(this._polygons);\n    var b = new Node(csg._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this._polygons = a.allPolygons();\n  };\n  /**\n   * Subtracts this CSG with another CSG\n   * @param csg The CSG to subtract against this CSG\n   * @returns A new CSG\n   */\n\n\n  CSG.prototype.subtract = function (csg) {\n    var a = new Node(this.clone()._polygons);\n    var b = new Node(csg.clone()._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\n   * Subtracts this CSG with another CSG in place\n   * @param csg The CSG to subtract against this CSG\n   */\n\n\n  CSG.prototype.subtractInPlace = function (csg) {\n    var a = new Node(this._polygons);\n    var b = new Node(csg._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  };\n  /**\n   * Intersect this CSG with another CSG\n   * @param csg The CSG to intersect against this CSG\n   * @returns A new CSG\n   */\n\n\n  CSG.prototype.intersect = function (csg) {\n    var a = new Node(this.clone()._polygons);\n    var b = new Node(csg.clone()._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\n   * Intersects this CSG with another CSG in place\n   * @param csg The CSG to intersect against this CSG\n   */\n\n\n  CSG.prototype.intersectInPlace = function (csg) {\n    var a = new Node(this._polygons);\n    var b = new Node(csg._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  };\n  /**\n   * Return a new CSG solid with solid and empty space switched. This solid is\n   * not modified.\n   * @returns A new CSG solid with solid and empty space switched\n   */\n\n\n  CSG.prototype.inverse = function () {\n    var csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  };\n  /**\n   * Inverses the CSG in place\n   */\n\n\n  CSG.prototype.inverseInPlace = function () {\n    this._polygons.map(function (p) {\n      p.flip();\n    });\n  };\n  /**\n   * This is used to keep meshes transformations so they can be restored\n   * when we build back a Babylon Mesh\n   * NB : All CSG operations are performed in world coordinates\n   * @param csg The CSG to copy the transform attributes from\n   * @returns This CSG\n   */\n\n\n  CSG.prototype.copyTransformAttributes = function (csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  };\n  /**\n   * Build Raw mesh from CSG\n   * Coordinates here are in world space\n   * @param name The name of the mesh geometry\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if the submeshes should be kept\n   * @returns A new Mesh\n   */\n\n\n  CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {\n    var matrix = this.matrix.clone();\n    matrix.invert();\n    var mesh = new Mesh(name, scene);\n    var vertices = [];\n    var indices = [];\n    var normals = [];\n    var uvs = null;\n    var vertColors = null;\n    var vertex = Vector3.Zero();\n    var normal = Vector3.Zero();\n    var uv = Vector2.Zero();\n    var vertColor = new Color4(0, 0, 0, 0);\n    var polygons = this._polygons;\n    var polygonIndices = [0, 0, 0];\n    var polygon;\n    var vertice_dict = {};\n    var vertex_idx;\n    var currentIndex = 0;\n    var subMeshDict = {};\n    var subMeshObj;\n\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort(function (a, b) {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n\n    for (var i = 0, il = polygons.length; i < il; i++) {\n      polygon = polygons[i]; // Building SubMeshes\n\n      if (!subMeshDict[polygon.shared.meshId]) {\n        subMeshDict[polygon.shared.meshId] = {};\n      }\n\n      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n\n      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];\n\n      for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n\n        for (var k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n\n          var localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          var localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\n          var areUvsDifferent = false;\n\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n\n          var areColorsDifferent = false;\n\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          } // Check if 2 points can be merged\n\n\n          if (!(typeof vertex_idx !== \"undefined\" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n\n            normals.push(normal.x, normal.y, normal.z);\n\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n\n            vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\n          }\n\n          indices.push(vertex_idx);\n          subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\n          subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\n          currentIndex++;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n\n    if (uvs) {\n      mesh.setVerticesData(VertexBuffer.UVKind, uvs);\n    }\n\n    if (vertColors) {\n      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\n    }\n\n    mesh.setIndices(indices, null);\n\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      var materialIndexOffset = 0,\n          materialMaxIndex = void 0;\n      mesh.subMeshes = new Array();\n\n      for (var m in subMeshDict) {\n        materialMaxIndex = -1;\n\n        for (var sm in subMeshDict[m]) {\n          subMeshObj = subMeshDict[m][sm];\n          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\n        }\n\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n\n    return mesh;\n  };\n  /**\n   * Build Mesh from CSG taking material and transforms into account\n   * @param name The name of the Mesh\n   * @param material The material of the Mesh\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if submeshes should be kept\n   * @returns The new Mesh\n   */\n\n\n  CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {\n    if (material === void 0) {\n      material = null;\n    }\n\n    var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  };\n\n  return CSG;\n}();\n\nexport { CSG };","map":{"version":3,"mappings":"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","names":["Quaternion","Matrix","Vector3","Vector2","VertexBuffer","SubMesh","Mesh","Color4","currentCSGMeshId","pos","normal","uv","vertColor","Vertex","clone","_a","_b","scale","other","t","Lerp","undefined","w","Plane","a","b","c","v0","subtract","v1","lengthSquared","n","Normalize","Cross","Dot","scaleInPlace","polygon","coplanarFront","coplanarBack","front","back","COPLANAR","FRONT","BACK","SPANNING","polygonType","types","i","vertices","length","type","EPSILON","push","plane","f","j","ti","tj","vi","vj","v","interpolate","poly","Polygon","shared","FromPoints","map","reverse","flip","polygons","Array","build","Node","node","_plane","_front","_back","_polygons","p","invert","temp","slice","splitPolygon","clipPolygons","concat","bsp","clipTo","allPolygons","CSG","mesh","absolute","vertex","position","matrix","meshPosition","meshRotation","meshRotationQuaternion","meshScaling","invertWinding","computeWorldMatrix","getWorldMatrix","rotation","rotationQuaternion","scaling","material","sideOrientation","indices","getIndices","positions","getVerticesData","PositionKind","normals","NormalKind","uvs","UVKind","vertColors","ColorKind","subMeshes","sm","sml","indexStart","il","indexCount","indexIndices","sourceNormal","sourcePosition","TransformCoordinates","TransformNormal","subMeshId","meshId","materialIndex","csg","_FromPolygons","Identity","Zero","One","copyTransformAttributes","inverseInPlace","name","scene","keepSubMeshes","polygonIndices","vertice_dict","vertex_idx","currentIndex","subMeshDict","subMeshObj","sort","Infinity","indexEnd","jl","k","copyFrom","localVertex","localNormal","x","y","z","areUvsDifferent","areColorsDifferent","r","g","Math","min","max","setVerticesData","setIndices","materialIndexOffset","materialMaxIndex","m","CreateFromIndices","buildMeshGeometry"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/csg.ts"],"sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<Plane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: Polygon,\r\n            vertices;\r\n        const polygons = new Array<Polygon>();\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: Polygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const mesh = new Mesh(name, scene);\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygons = this._polygons;\r\n        const polygonIndices = [0, 0, 0];\r\n        let polygon;\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj;\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            polygon = polygons[i];\r\n\r\n            // Building SubMeshes\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n            }\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                    indexStart: +Infinity,\r\n                    indexEnd: -Infinity,\r\n                    materialIndex: polygon.shared.materialIndex,\r\n                };\r\n            }\r\n            subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                    subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                    currentIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        if (uvs) {\r\n            mesh.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        }\r\n        if (vertColors) {\r\n            mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\r\n        }\r\n        mesh.setIndices(indices, null);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}