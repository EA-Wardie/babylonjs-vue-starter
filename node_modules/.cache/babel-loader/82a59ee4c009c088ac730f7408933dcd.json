{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Curve3 } from \"../../Maths/math.path.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { setAndStartTimer } from \"../../Misc/timer.js\";\n/**\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\n\nvar WebXRMotionControllerTeleportation =\n/** @class */\nfunction (_super) {\n  __extends(WebXRMotionControllerTeleportation, _super);\n  /**\n   * constructs a new teleportation system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n\n\n  function WebXRMotionControllerTeleportation(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._controllers = {};\n    _this._snappedToPoint = false;\n    _this._tmpRay = new Ray(new Vector3(), new Vector3());\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    /**\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\n     */\n\n    _this.skipNextTeleportation = false;\n    /**\n     * Is movement backwards enabled\n     */\n\n    _this.backwardsMovementEnabled = true;\n    /**\n     * Distance to travel when moving backwards\n     */\n\n    _this.backwardsTeleportationDistance = 0.7;\n    /**\n     * The distance from the user to the inspection point in the direction of the controller\n     * A higher number will allow the user to move further\n     * defaults to 5 (meters, in xr units)\n     */\n\n    _this.parabolicCheckRadius = 5;\n    /**\n     * Should the module support parabolic ray on top of direct ray\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\n     * Very helpful when moving between floors / different heights\n     */\n\n    _this.parabolicRayEnabled = true;\n    /**\n     * The second type of ray - straight line.\n     * Should it be enabled or should the parabolic line be the only one.\n     */\n\n    _this.straightRayEnabled = true;\n    /**\n     * How much rotation should be applied when rotating right and left\n     */\n\n    _this.rotationAngle = Math.PI / 8;\n    /**\n     * This observable will notify when the target mesh position was updated.\n     * The picking info it provides contains the point to which the target mesh will move ()\n     */\n\n    _this.onTargetMeshPositionUpdatedObservable = new Observable();\n    /**\n     * Is teleportation enabled. Can be used to allow rotation only.\n     */\n\n    _this.teleportationEnabled = true;\n    _this._rotationEnabled = true;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId] || _this._options.forceHandedness && xrController.inputSource.handedness !== _this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0\n        }\n      };\n      var controllerData = _this._controllers[xrController.uniqueId]; // motion controller only available to gamepad-enabled input sources.\n\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        var initMotionController_1 = function initMotionController_1() {\n          if (xrController.motionController) {\n            var movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n\n            if (!movementController || _this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              var mainComponent_1 = xrController.motionController.getMainComponent();\n\n              if (!mainComponent_1) {\n                return;\n              }\n\n              controllerData.teleportationComponent = mainComponent_1;\n              controllerData.onButtonChangedObserver = mainComponent_1.onButtonStateChangedObservable.add(function () {\n                if (!_this.teleportationEnabled) {\n                  return;\n                } // did \"pressed\" changed?\n\n\n                if (mainComponent_1.changes.pressed) {\n                  if (mainComponent_1.changes.pressed.current) {\n                    // simulate \"forward\" thumbstick push\n                    controllerData.teleportationState.forward = true;\n                    _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                    controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                    controllerData.teleportationState.currentRotation = 0;\n                    var timeToSelect = _this._options.timeToTeleport || 3000;\n                    setAndStartTimer({\n                      timeout: timeToSelect,\n                      contextObservable: _this._xrSessionManager.onXRFrameObservable,\n                      breakCondition: function breakCondition() {\n                        return !mainComponent_1.pressed;\n                      },\n                      onEnded: function onEnded() {\n                        if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                          _this._teleportForward(xrController.uniqueId);\n                        }\n                      }\n                    });\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    _this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController; // use thumbstick (or touchpad if thumbstick not available)\n\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(function (axesData) {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && _this.backwardsMovementEnabled && !_this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true; // teleport backwards ONCE\n\n                    _this._tmpQuaternion.copyFrom(_this._options.xrInput.xrCamera.rotationQuaternion);\n\n                    _this._tmpQuaternion.toEulerAnglesToRef(_this._tmpVector); // get only the y rotation\n\n\n                    _this._tmpVector.x = 0;\n                    _this._tmpVector.z = 0; // get the quaternion\n\n                    Quaternion.FromEulerVectorToRef(_this._tmpVector, _this._tmpQuaternion);\n\n                    _this._tmpVector.set(0, 0, _this.backwardsTeleportationDistance * (_this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n\n                    _this._tmpVector.rotateByQuaternionToRef(_this._tmpQuaternion, _this._tmpVector);\n\n                    _this._tmpVector.addInPlace(_this._options.xrInput.xrCamera.position);\n\n                    _this._tmpRay.origin.copyFrom(_this._tmpVector); // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n\n\n                    _this._tmpRay.length = _this._options.xrInput.xrCamera.realWorldHeight + 0.1; // Right handed system had here \"1\" instead of -1. This is unneeded.\n\n                    _this._tmpRay.direction.set(0, -1, 0);\n\n                    var pick = _this._xrSessionManager.scene.pickWithRay(_this._tmpRay, function (o) {\n                      return _this._floorMeshes.indexOf(o) !== -1;\n                    }); // pick must exist, but stay safe\n\n\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      _this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      _this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n\n                if (axesData.y < -0.7 && !_this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && _this.teleportationEnabled) {\n                  controllerData.teleportationState.forward = true;\n                  _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      var rotation = _this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (_this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(_this._options.xrInput.xrCamera.rotationQuaternion, _this._options.xrInput.xrCamera.rotationQuaternion);\n                    }\n                  } else {\n                    if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (_this.rotationEnabled) {\n                        setTimeout(function () {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (_this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.forward) {\n                    _this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n\n        if (xrController.motionController) {\n          initMotionController_1();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(function () {\n            initMotionController_1();\n          });\n        }\n      } else {\n        _this._xrSessionManager.scene.onPointerObservable.add(function (pointerInfo) {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            controllerData.teleportationState.forward = true;\n            _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n            controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n            controllerData.teleportationState.currentRotation = 0;\n            var timeToSelect = _this._options.timeToTeleport || 3000;\n            setAndStartTimer({\n              timeout: timeToSelect,\n              contextObservable: _this._xrSessionManager.onXRFrameObservable,\n              onEnded: function onEnded() {\n                if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                  _this._teleportForward(xrController.uniqueId);\n                }\n              }\n            });\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            controllerData.teleportationState.forward = false;\n            _this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    }; // create default mesh if not provided\n\n\n    if (!_this._options.teleportationTargetMesh) {\n      _this._createDefaultTargetMesh();\n    }\n\n    _this._floorMeshes = _this._options.floorMeshes || [];\n    _this._snapToPositions = _this._options.snapPositions || [];\n\n    _this._setTargetMeshVisibility(false);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"rotationEnabled\", {\n    /**\n     * Is rotation enabled when moving forward?\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\n     */\n    get: function get() {\n      return this._rotationEnabled;\n    },\n\n    /**\n     * Sets whether rotation is enabled or not\n     * @param enabled is rotation enabled when teleportation is shown\n     */\n    set: function set(enabled) {\n      this._rotationEnabled = enabled;\n\n      if (this._options.teleportationTargetMesh) {\n        var children = this._options.teleportationTargetMesh.getChildMeshes(false, function (node) {\n          return node.name === \"rotationCone\";\n        });\n\n        if (children[0]) {\n          children[0].setEnabled(enabled);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"teleportationTargetMesh\", {\n    /**\n     * Exposes the currently set teleportation target mesh.\n     */\n    get: function get() {\n      return this._options.teleportationTargetMesh || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"snapPointsOnly\", {\n    /**\n     * Get the snapPointsOnly flag\n     */\n    get: function get() {\n      return !!this._options.snapPointsOnly;\n    },\n\n    /**\n     * Sets the snapPointsOnly flag\n     * @param snapToPoints should teleportation be exclusively to snap points\n     */\n    set: function set(snapToPoints) {\n      this._options.snapPointsOnly = snapToPoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Add a new mesh to the floor meshes array\n   * @param mesh the mesh to use as floor mesh\n   */\n\n  WebXRMotionControllerTeleportation.prototype.addFloorMesh = function (mesh) {\n    this._floorMeshes.push(mesh);\n  };\n  /**\n   * Add a mesh to the list of meshes blocking the teleportation ray\n   * @param mesh The mesh to add to the teleportation-blocking meshes\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.addBlockerMesh = function (mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n\n    this._options.pickBlockerMeshes.push(mesh);\n  };\n  /**\n   * Add a new snap-to point to fix teleportation to this position\n   * @param newSnapPoint The new Snap-To point\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.addSnapPoint = function (newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  };\n\n  WebXRMotionControllerTeleportation.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Safety reset\n\n\n    this._currentTeleportationControllerId = \"\";\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    this._setTargetMeshVisibility(false);\n\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n  };\n  /**\n   * Remove a mesh from the floor meshes array\n   * @param mesh the mesh to remove\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMesh = function (mesh) {\n    var index = this._floorMeshes.indexOf(mesh);\n\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  };\n  /**\n   * Remove a mesh from the blocker meshes array\n   * @param mesh the mesh to remove\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeBlockerMesh = function (mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n\n    var index = this._options.pickBlockerMeshes.indexOf(mesh);\n\n    if (index !== -1) {\n      this._options.pickBlockerMeshes.splice(index, 1);\n    }\n  };\n  /**\n   * Remove a mesh from the floor meshes array using its name\n   * @param name the mesh name to remove\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMeshByName = function (name) {\n    var mesh = this._xrSessionManager.scene.getMeshByName(name);\n\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  };\n  /**\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\n   * @returns was the point found and removed or not\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeSnapPoint = function (snapPointToRemove) {\n    // check if the object is in the array\n    var index = this._snapToPositions.indexOf(snapPointToRemove); // if not found as an object, compare to the points\n\n\n    if (index === -1) {\n      for (var i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    } // index is not -1? remove the object\n\n\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * This function sets a selection feature that will be disabled when\n   * the forward ray is shown and will be reattached when hidden.\n   * This is used to remove the selection rays when moving.\n   * @param selectionFeature the feature to disable when forward movement is enabled\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.setSelectionFeature = function (selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    var frame = this._xrSessionManager.currentFrame;\n    var scene = this._xrSessionManager.scene;\n\n    if (!this.attach || !frame) {\n      return;\n    } // render target if needed\n\n\n    var targetMesh = this._options.teleportationTargetMesh;\n\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      var controllerData = this._controllers[this._currentTeleportationControllerId];\n\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion); // set the ray and position\n\n        var hitPossible = false;\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            var index = _this._floorMeshes.indexOf(o);\n\n            if (index === -1) {\n              return false;\n            }\n\n            return _this._floorMeshes[index].absolutePosition.y < _this._options.xrInput.xrCamera.globalPosition.y;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n\n\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          var xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          var compensation = 1 + (Math.PI / 2 - Math.abs(xRotation)); // check parabolic ray\n\n          var radius = this.parabolicCheckRadius * compensation;\n\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n\n          this._tmpVector.y = this._tmpRay.origin.y;\n\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n\n          this._tmpRay.direction.normalize();\n\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            return _this._floorMeshes.indexOf(o) !== -1;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // if needed, set visible:\n\n\n        this._setTargetMeshVisibility(hitPossible);\n      } else {\n        this._setTargetMeshVisibility(false);\n      }\n    } else {\n      this._setTargetMeshVisibility(false);\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._createDefaultTargetMesh = function () {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    var teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    var length = 512;\n    var dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n    dynamicTexture.hasAlpha = true;\n    var context = dynamicTexture.getContext();\n    var centerX = length / 2;\n    var centerY = length / 2;\n    var radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    var teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    teleportationTarget.material = teleportationCircleMaterial;\n    var torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      var animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      var keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      var easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n\n    var cone = CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      var torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    this._options.teleportationTargetMesh = teleportationTarget;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n\n  WebXRMotionControllerTeleportation.prototype._findClosestSnapPointWithRadius = function (realPosition, radius) {\n    if (radius === void 0) {\n      radius = this._options.snapToPositionRadius || 0.8;\n    }\n\n    var closestPoint = null;\n    var closestDistance = Number.MAX_VALUE;\n\n    if (this._snapToPositions.length) {\n      var radiusSquared_1 = radius * radius;\n\n      this._snapToPositions.forEach(function (position) {\n        var dist = Vector3.DistanceSquared(position, realPosition);\n\n        if (dist <= radiusSquared_1 && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n\n    return closestPoint;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshPosition = function (pickInfo) {\n    var newPosition = pickInfo.pickedPoint;\n\n    if (!this._options.teleportationTargetMesh || !newPosition) {\n      return;\n    }\n\n    var snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n\n    this._snappedToPoint = !!snapPosition;\n\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n\n    this._options.teleportationTargetMesh.position.y += 0.01;\n    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshVisibility = function (visible) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n\n    if (this._options.teleportationTargetMesh.isVisible === visible) {\n      return;\n    }\n\n    this._options.teleportationTargetMesh.isVisible = visible;\n\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(function (m) {\n      m.isVisible = visible;\n    });\n\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n\n        this._quadraticBezierCurve = null;\n      }\n\n      if (this._selectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._showParabolicPath = function (pickInfo) {\n    if (!pickInfo.pickedPoint) {\n      return;\n    }\n\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    var controllerData = this._controllers[this._currentTeleportationControllerId];\n    var quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = CreateLines(\"teleportation path line\", {\n        points: quadraticBezierVectors.getPoints(),\n        instance: this._quadraticBezierCurve,\n        updatable: true\n      }, sceneToRenderTo);\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\n    }\n\n    this._quadraticBezierCurve.isPickable = false;\n\n    if (this._options.renderingGroupId !== undefined) {\n      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._teleportForward = function (controllerId) {\n    var controllerData = this._controllers[controllerId];\n\n    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\n      return;\n    }\n\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    }\n\n    if (this.skipNextTeleportation) {\n      this.skipNextTeleportation = false;\n      return;\n    } // do the movement forward here\n\n\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      var height = this._options.xrInput.xrCamera.realWorldHeight;\n\n      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n\n      this._options.xrInput.xrCamera.position.y += height;\n      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n\n      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the webxr specs version\n   */\n\n  WebXRMotionControllerTeleportation.Version = 1;\n  return WebXRMotionControllerTeleportation;\n}(WebXRAbstractFeature);\n\nexport { WebXRMotionControllerTeleportation };\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRMotionControllerTeleportation(xrSessionManager, options);\n  };\n}, WebXRMotionControllerTeleportation.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","WebXRControllerComponent","Vector3","Quaternion","Ray","DynamicTexture","CreateCylinder","SineEase","EasingFunction","Animation","Axis","StandardMaterial","CreateGround","CreateTorus","Curve3","CreateLines","WebXRAbstractFeature","Color3","UtilityLayerRenderer","PointerEventTypes","setAndStartTimer","__extends","_xrSessionManager","_options","_super","_this","Math","PI","xrController","_controllers","uniqueId","forceHandedness","inputSource","handedness","teleportationState","forward","backwards","rotating","currentRotation","baseRotation","controllerData","targetRayMode","gamepad","initMotionController_1","motionController","movementController","getComponentOfType","THUMBSTICK_TYPE","TOUCHPAD_TYPE","useMainComponentOnly","mainComponent_1","getMainComponent","teleportationComponent","onButtonChangedObserver","onButtonStateChangedObservable","add","teleportationEnabled","changes","pressed","current","_currentTeleportationControllerId","xrInput","xrCamera","rotationQuaternion","toEulerAngles","y","timeToSelect","timeToTeleport","timeout","contextObservable","onXRFrameObservable","breakCondition","onEnded","_teleportForward","onAxisChangedObserver","onAxisValueChangedObservable","axesData","backwardsMovementEnabled","snapPointsOnly","_tmpQuaternion","copyFrom","toEulerAnglesToRef","_tmpVector","x","z","FromEulerVectorToRef","set","backwardsTeleportationDistance","scene","useRightHandedSystem","rotateByQuaternionToRef","addInPlace","position","_tmpRay","origin","length","realWorldHeight","direction","pick","pickWithRay","o","_floorMeshes","indexOf","pickedPoint","abs","rotation","rotationAngle","FromEulerAngles","multiplyToRef","rotationEnabled","setTimeout","atan2","onMotionControllerInitObservable","addOnce","onPointerObservable","pointerInfo","type","POINTERDOWN","POINTERUP","teleportationTargetMesh","_createDefaultTargetMesh","floorMeshes","_snapToPositions","snapPositions","_setTargetMeshVisibility","Object","WebXRMotionControllerTeleportation","_rotationEnabled","enabled","children","getChildMeshes","node","name","setEnabled","snapToPoints","mesh","push","pickBlockerMeshes","newSnapPoint","attach","call","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","keys","controllerId","dispose","index","splice","getMeshByName","removeFloorMesh","snapPointToRemove","i","equals","selectionFeature","_selectionFeature","_xrFrame","frame","currentFrame","targetMesh","RotationYawPitchRollToRef","hitPossible","getWorldPointerRayToRef","straightRayEnabled","absolutePosition","globalPosition","pickedMesh","_setTargetMeshPosition","_showParabolicPath","parabolicRayEnabled","xRotation","pointer","compensation","radius","parabolicCheckRadius","addToRef","scale","subtractToRef","normalize","defaultTargetMeshOptions","sceneToRenderTo","useUtilityLayer","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","teleportationTarget","width","height","subdivisions","isPickable","dynamicTexture","hasAlpha","context","getContext","centerX","centerY","beginPath","arc","fillStyle","teleportationFillColor","fill","lineWidth","strokeStyle","teleportationBorderColor","stroke","closePath","update","teleportationCircleMaterial","diffuseTexture","material","torus","diameter","thickness","tessellation","parent","disableAnimation","animationInnerCircle","ANIMATIONTYPE_FLOAT","ANIMATIONLOOPMODE_CYCLE","value","setKeys","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","setEasingFunction","animations","beginAnimation","cone","diameterTop","scaling","rotate","X","torusArrowMaterial","torusConeMaterial","disableLighting","emissiveColor","diffuseColor","alpha","_teleportationRingMaterial","renderingGroupId","undefined","xrControllerUniqueId","remove","realPosition","snapToPositionRadius","closestPoint","closestDistance","Number","MAX_VALUE","radiusSquared_1","dist","DistanceSquared","pickInfo","newPosition","snapPosition","_findClosestSnapPointWithRadius","_snappedToPoint","onTargetMeshPositionUpdatedObservable","notifyObservers","visible","isVisible","getChildren","m","_quadraticBezierCurve","quadraticBezierVectors","CreateQuadraticBezier","ray","generateRayPathMesh","points","getPoints","instance","updatable","skipNextTeleportation","onBeforeCameraTeleport","onAfterCameraTeleport","TELEPORTATION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRControllerTeleportation.ts"],"sourcesContent":["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long should the \"long press\" take before teleport\r\n     */\r\n    timeToTeleport?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRTeleportationOptions) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible);\r\n            } else {\r\n                this._setTargetMeshVisibility(false);\r\n            }\r\n        } else {\r\n            this._setTargetMeshVisibility(false);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // simulate \"forward\" thumbstick push\r\n                                    controllerData.teleportationState.forward = true;\r\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                    controllerData.teleportationState.currentRotation = 0;\r\n                                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                    setAndStartTimer({\r\n                                        timeout: timeToSelect,\r\n                                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                        breakCondition: () => !mainComponent.pressed,\r\n                                        onEnded: () => {\r\n                                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                                this._teleportForward(xrController.uniqueId);\r\n                                            }\r\n                                        },\r\n                                    });\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    controllerData.teleportationState.forward = true;\r\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                    controllerData.teleportationState.currentRotation = 0;\r\n                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                    setAndStartTimer({\r\n                        timeout: timeToSelect,\r\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                        onEnded: () => {\r\n                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                this._teleportForward(xrController.uniqueId);\r\n                            }\r\n                        },\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n        const length = 512;\r\n        const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n        dynamicTexture.hasAlpha = true;\r\n        const context = dynamicTexture.getContext();\r\n        const centerX = length / 2;\r\n        const centerY = length / 2;\r\n        const radius = 200;\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n        context.fill();\r\n        context.lineWidth = 10;\r\n        context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n        context.stroke();\r\n        context.closePath();\r\n        dynamicTexture.update();\r\n        const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n        teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n        teleportationTarget.material = teleportationCircleMaterial;\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve as LinesMesh, updatable: true },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module"}