{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrHelperFunctions\";\nvar shader = \"#define RECIPROCAL_PI2 0.15915494\\n#define RECIPROCAL_PI 0.31830988618\\n#define MINIMUMVARIANCE 0.0005\\nfloat convertRoughnessToAverageSlope(float roughness)\\n{\\nreturn square(roughness)+MINIMUMVARIANCE;\\n}\\nfloat fresnelGrazingReflectance(float reflectance0) {\\nfloat reflectance90=saturate(reflectance0*25.0);\\nreturn reflectance90;\\n}\\nvec2 getAARoughnessFactors(vec3 normalVector) {\\n#ifdef SPECULARAA\\nvec3 nDfdx=dFdx(normalVector.xyz);\\nvec3 nDfdy=dFdy(normalVector.xyz);\\nfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\\nfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\\nfloat geometricAlphaGFactor=sqrt(slopeSquare);\\ngeometricAlphaGFactor*=0.75;\\nreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\\n#else\\nreturn vec2(0.);\\n#endif\\n}\\n#ifdef ANISOTROPIC\\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\\nfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\\nfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\\nreturn vec2(alphaT,alphaB);\\n}\\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\\nvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\\nvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\\nvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\\nvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\\nreturn anisotropicNormal;\\n}\\n#endif\\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\\nvec3 cocaLambert(vec3 alpha,float distance) {\\nreturn exp(-alpha*distance);\\n}\\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\\nreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\\n}\\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\\nreturn -log(color)/distance;\\n}\\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\\nvec3 clearCoatAbsorption=mix(vec3(1.0),\\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\\nclearCoatIntensity);\\nreturn clearCoatAbsorption;\\n}\\n#endif\\n#ifdef MICROSURFACEAUTOMATIC\\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\\n{\\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\\nreturn microSurface;\\n}\\n#endif\\n\"; // Sideeffect\n\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\n\nexport var pbrHelperFunctions = {\n  name: name,\n  shader: shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAT,QAA4B,8BAA5B;AAEA,IAAMC,IAAI,GAAG,oBAAb;AACA,IAAMC,MAAM,GAAG,kiFAAf,C,CAkEA;;AACAF,WAAW,CAACG,oBAAZ,CAAiCF,IAAjC,IAAyCC,MAAzC;AACA;;AACA,OAAO,IAAME,kBAAkB,GAAG;AAAEH,MAAI,MAAN;AAAQC,QAAM;AAAd,CAA3B","names":["ShaderStore","name","shader","IncludesShadersStore","pbrHelperFunctions"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Shaders/ShadersInclude/pbrHelperFunctions.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrHelperFunctions\";\nconst shader = `#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\r{\rreturn square(roughness)+MINIMUMVARIANCE;\r}\rfloat fresnelGrazingReflectance(float reflectance0) {\rfloat reflectance90=saturate(reflectance0*25.0);\rreturn reflectance90;\r}\rvec2 getAARoughnessFactors(vec3 normalVector) {\r#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);\rvec3 nDfdy=dFdy(normalVector.xyz);\rfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\rfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\rfloat geometricAlphaGFactor=sqrt(slopeSquare);\rgeometricAlphaGFactor*=0.75;\rreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\r#else\nreturn vec2(0.);\r#endif\n}\r#ifdef ANISOTROPIC\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\rfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\rfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\rreturn vec2(alphaT,alphaB);\r}\rvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\rvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\rvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\rvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\rvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\rreturn anisotropicNormal;\r}\r#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {\rreturn exp(-alpha*distance);\r}\rvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\rreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\r}\rvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\rreturn -log(color)/distance;\r}\rvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\rvec3 clearCoatAbsorption=mix(vec3(1.0),\rcocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\rclearCoatIntensity);\rreturn clearCoatAbsorption;\r}\r#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\r{\rconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\rfloat reflectivityLuminance=getLuminance(reflectivityColor);\rfloat reflectivityLuma=sqrt(reflectivityLuminance);\rmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\rreturn microSurface;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport const pbrHelperFunctions = { name, shader };\n"]},"metadata":{},"sourceType":"module"}