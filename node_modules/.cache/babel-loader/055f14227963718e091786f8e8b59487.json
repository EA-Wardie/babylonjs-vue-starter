{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\n/** @hidden */\n\nvar WebGPUShaderProcessorGLSL =\n/** @class */\nfunction (_super) {\n  __extends(WebGPUShaderProcessorGLSL, _super);\n\n  function WebGPUShaderProcessorGLSL() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._missingVaryings = [];\n    _this._textureArrayProcessing = [];\n    _this.shaderLanguage = ShaderLanguage.GLSL;\n    return _this;\n  }\n\n  WebGPUShaderProcessorGLSL.prototype._getArraySize = function (name, type, preProcessors) {\n    var length = 0;\n    var startArray = name.indexOf(\"[\");\n    var endArray = name.indexOf(\"]\");\n\n    if (startArray > 0 && endArray > 0) {\n      var lengthInString = name.substring(startArray + 1, endArray);\n      length = +lengthInString;\n\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n\n      name = name.substr(0, startArray);\n    }\n\n    return [name, type, length];\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.initializeShaders = function (processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._missingVaryings.length = 0;\n    this._textureArrayProcessing.length = 0;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.preProcessShaderCode = function (code, isFragment) {\n    var ubDeclaration = \"uniform \".concat(WebGPUShaderProcessor.InternalsUBOName, \" {\\nfloat yFactor__;\\nfloat textureOutputHeight__;\\n};\\n\");\n\n    if (isFragment) {\n      return ubDeclaration + \"##INJECTCODE##\\n\" + code;\n    }\n\n    return ubDeclaration + code;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.varyingProcessor = function (varying, isFragment, preProcessors) {\n    this._preProcessors = preProcessors;\n    var varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    var match = varyingRegex.exec(varying);\n\n    if (match != null) {\n      var varyingType = match[1];\n      var name_1 = match[2];\n      var location_1;\n\n      if (isFragment) {\n        location_1 = this._webgpuProcessingContext.availableVaryings[name_1];\n        this._missingVaryings[location_1] = \"\";\n\n        if (location_1 === undefined) {\n          Logger.Warn(\"Invalid fragment shader: The varying named \\\"\".concat(name_1, \"\\\" is not declared in the vertex shader! This declaration will be ignored.\"));\n        }\n      } else {\n        location_1 = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name_1, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name_1] = location_1;\n        this._missingVaryings[location_1] = \"layout(location = \".concat(location_1, \") in \").concat(varyingType, \" \").concat(name_1, \";\");\n      }\n\n      varying = varying.replace(match[0], location_1 === undefined ? \"\" : \"layout(location = \".concat(location_1, \") \").concat(isFragment ? \"in\" : \"out\", \" \").concat(varyingType, \" \").concat(name_1, \";\"));\n    }\n\n    return varying;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.attributeProcessor = function (attribute, preProcessors) {\n    this._preProcessors = preProcessors;\n    var attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    var match = attribRegex.exec(attribute);\n\n    if (match != null) {\n      var attributeType = match[1];\n      var name_2 = match[2];\n\n      var location_2 = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name_2, attributeType, preProcessors)[2]);\n\n      this._webgpuProcessingContext.availableAttributes[name_2] = location_2;\n      this._webgpuProcessingContext.orderedAttributes[location_2] = name_2;\n      attribute = attribute.replace(match[0], \"layout(location = \".concat(location_2, \") in \").concat(attributeType, \" \").concat(name_2, \";\"));\n    }\n\n    return attribute;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.uniformProcessor = function (uniform, isFragment, preProcessors) {\n    var _a;\n\n    var _b;\n\n    this._preProcessors = preProcessors;\n    var uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    var match = uniformRegex.exec(uniform);\n\n    if (match != null) {\n      var uniformType = match[1];\n      var name_3 = match[2];\n\n      if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\n        var arraySize = 0; // 0 means the texture is not declared as an array\n\n        _a = this._getArraySize(name_3, uniformType, preProcessors), name_3 = _a[0], uniformType = _a[1], arraySize = _a[2];\n        var textureInfo = this._webgpuProcessingContext.availableTextures[name_3];\n\n        if (!textureInfo) {\n          textureInfo = {\n            autoBindSampler: true,\n            isTextureArray: arraySize > 0,\n            isStorageTexture: false,\n            textures: [],\n            sampleType: WebGPUConstants.TextureSampleType.Float\n          };\n\n          for (var i = 0; i < (arraySize || 1); ++i) {\n            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n          }\n        }\n\n        var samplerType = (_b = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType]) !== null && _b !== void 0 ? _b : \"sampler\";\n        var isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\n        var samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n        var samplerName = name_3 + WebGPUShaderProcessor.AutoSamplerSuffix;\n        var samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\n\n        if (!samplerInfo) {\n          samplerInfo = {\n            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n            type: samplerBindingType\n          };\n        }\n\n        var componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\n\n        if (componentType) {\n          uniformType = uniformType.substr(1);\n        }\n\n        var sampleType = isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n        textureInfo.sampleType = sampleType;\n        var isTextureArray = arraySize > 0;\n        var samplerGroupIndex = samplerInfo.binding.groupIndex;\n        var samplerBindingIndex = samplerInfo.binding.bindingIndex;\n        var samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\n        var textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\n        var textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType]; // Manage textures and samplers.\n\n        if (!isTextureArray) {\n          arraySize = 1;\n          uniform = \"layout(set = \".concat(samplerGroupIndex, \", binding = \").concat(samplerBindingIndex, \") uniform \").concat(componentType).concat(samplerType, \" \").concat(samplerName, \";\\n                        layout(set = \").concat(textureInfo.textures[0].groupIndex, \", binding = \").concat(textureInfo.textures[0].bindingIndex, \") uniform \").concat(textureType, \" \").concat(name_3, \"Texture;\\n                        #define \").concat(name_3, \" \").concat(componentType).concat(samplerFunction, \"(\").concat(name_3, \"Texture, \").concat(samplerName, \")\");\n        } else {\n          var layouts = [];\n          layouts.push(\"layout(set = \".concat(samplerGroupIndex, \", binding = \").concat(samplerBindingIndex, \") uniform \").concat(componentType).concat(samplerType, \" \").concat(samplerName, \";\"));\n          uniform = \"\\r\\n\";\n\n          for (var i = 0; i < arraySize; ++i) {\n            var textureSetIndex = textureInfo.textures[i].groupIndex;\n            var textureBindingIndex = textureInfo.textures[i].bindingIndex;\n            layouts.push(\"layout(set = \".concat(textureSetIndex, \", binding = \").concat(textureBindingIndex, \") uniform \").concat(textureType, \" \").concat(name_3, \"Texture\").concat(i, \";\"));\n            uniform += \"\".concat(i > 0 ? \"\\r\\n\" : \"\", \"#define \").concat(name_3).concat(i, \" \").concat(componentType).concat(samplerFunction, \"(\").concat(name_3, \"Texture\").concat(i, \", \").concat(samplerName, \")\");\n          }\n\n          uniform = layouts.join(\"\\r\\n\") + uniform;\n\n          this._textureArrayProcessing.push(name_3);\n        }\n\n        this._webgpuProcessingContext.availableTextures[name_3] = textureInfo;\n        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\n\n        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\n\n        for (var i = 0; i < arraySize; ++i) {\n          this._addTextureBindingDescription(name_3, textureInfo, i, textureDimension, null, !isFragment);\n        }\n      } else {\n        this._addUniformToLeftOverUBO(name_3, uniformType, preProcessors);\n\n        uniform = \"\";\n      }\n    }\n\n    return uniform;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.uniformBufferProcessor = function (uniformBuffer, isFragment) {\n    var uboRegex = /uniform\\s+(\\w+)/gm;\n    var match = uboRegex.exec(uniformBuffer);\n\n    if (match != null) {\n      var name_4 = match[1];\n      var uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name_4];\n\n      if (!uniformBufferInfo) {\n        var knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name_4];\n        var binding = void 0;\n\n        if (knownUBO && knownUBO.binding.groupIndex !== -1) {\n          binding = knownUBO.binding;\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n\n        uniformBufferInfo = {\n          binding: binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name_4] = uniformBufferInfo;\n      }\n\n      this._addBufferBindingDescription(name_4, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\n\n      uniformBuffer = uniformBuffer.replace(\"uniform\", \"layout(set = \".concat(uniformBufferInfo.binding.groupIndex, \", binding = \").concat(uniformBufferInfo.binding.bindingIndex, \") uniform\"));\n    }\n\n    return uniformBuffer;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.postProcessor = function (code, defines, isFragment, processingContext, engine) {\n    var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1; // Remove extensions\n\n    var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\n    code = code.replace(regex, \"\"); // Replace instructions\n\n    code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\n\n    if (isFragment) {\n      var hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\n      var fragCoordCode = \"\\n                glFragCoord__ = gl_FragCoord;\\n                if (yFactor__ == 1.) {\\n                    glFragCoord__.y = textureOutputHeight__ - glFragCoord__.y;\\n                }\\n            \";\n      var injectCode = hasFragCoord ? \"vec4 glFragCoord__;\\n\" : \"\";\n      code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\n      code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n      code = code.replace(/gl_FragColor/g, \"glFragColor\");\n      code = code.replace(/gl_FragData/g, \"glFragData\");\n      code = code.replace(/gl_FragCoord/g, \"glFragCoord__\");\n      code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\n      code = code.replace(/dFdy/g, \"(-yFactor__)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\n\n      code = code.replace(\"##INJECTCODE##\", injectCode);\n\n      if (hasFragCoord) {\n        code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\n      }\n    } else {\n      code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\n      code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\n      var hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\n\n      if (hasMultiviewExtension) {\n        return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\n      }\n    } // Flip Y + convert z range from [-1,1] to [0,1]\n\n\n    if (!isFragment) {\n      var lastClosingCurly = code.lastIndexOf(\"}\");\n      code = code.substring(0, lastClosingCurly);\n      code += \"gl_Position.y *= yFactor__;\\n\";\n\n      if (!engine.isNDCHalfZRange) {\n        code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\n      }\n\n      code += \"}\";\n    }\n\n    return code;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype._applyTextureArrayProcessing = function (code, name) {\n    // Replaces the occurrences of name[XX] by nameXX\n    var regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\n    var match = regex.exec(code);\n\n    while (match != null) {\n      var index = match[1];\n      var iindex = +index;\n\n      if (this._preProcessors && isNaN(iindex)) {\n        iindex = +this._preProcessors[index.trim()];\n      }\n\n      code = code.replace(match[0], name + iindex);\n      match = regex.exec(code);\n    }\n\n    return code;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype._generateLeftOverUBOCode = function (name, uniformBufferDescription) {\n    var ubo = \"layout(set = \".concat(uniformBufferDescription.binding.groupIndex, \", binding = \").concat(uniformBufferDescription.binding.bindingIndex, \") uniform \").concat(name, \" {\\n    \");\n\n    for (var _i = 0, _a = this._webgpuProcessingContext.leftOverUniforms; _i < _a.length; _i++) {\n      var leftOverUniform = _a[_i];\n\n      if (leftOverUniform.length > 0) {\n        ubo += \"    \".concat(leftOverUniform.type, \" \").concat(leftOverUniform.name, \"[\").concat(leftOverUniform.length, \"];\\n\");\n      } else {\n        ubo += \"    \".concat(leftOverUniform.type, \" \").concat(leftOverUniform.name, \";\\n\");\n      }\n    }\n\n    ubo += \"};\\n\\n\";\n    return ubo;\n  };\n\n  WebGPUShaderProcessorGLSL.prototype.finalizeShaders = function (vertexCode, fragmentCode) {\n    // make replacements for texture names in the texture array case\n    for (var i = 0; i < this._textureArrayProcessing.length; ++i) {\n      var name_5 = this._textureArrayProcessing[i];\n      vertexCode = this._applyTextureArrayProcessing(vertexCode, name_5);\n      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name_5);\n    } // inject the missing varying in the fragment shader\n\n\n    for (var i = 0; i < this._missingVaryings.length; ++i) {\n      var decl = this._missingVaryings[i];\n\n      if (decl && decl.length > 0) {\n        fragmentCode = decl + \"\\n\" + fragmentCode;\n      }\n    } // Builds the leftover UBOs.\n\n\n    var leftOverUBO = this._buildLeftOverUBO();\n\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n\n    this._collectBindingNames();\n\n    this._preCreateBindGroupEntries();\n\n    this._preProcessors = null;\n    return {\n      vertexCode: vertexCode,\n      fragmentCode: fragmentCode\n    };\n  };\n\n  return WebGPUShaderProcessorGLSL;\n}(WebGPUShaderProcessor);\n\nexport { WebGPUShaderProcessorGLSL };","map":{"version":3,"mappings":"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","names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","ShaderLanguage","__extends","_this","GLSL","WebGPUShaderProcessorGLSL","name","type","preProcessors","length","startArray","indexOf","endArray","lengthInString","substring","isNaN","trim","substr","processingContext","_webgpuProcessingContext","_missingVaryings","_textureArrayProcessing","code","isFragment","ubDeclaration","InternalsUBOName","varying","_preProcessors","varyingRegex","match","exec","varyingType","name_1","location_1","availableVaryings","undefined","Warn","getVaryingNextLocation","_getArraySize","concat","replace","attribute","attribRegex","attributeType","name_2","location_2","getAttributeNextLocation","availableAttributes","orderedAttributes","uniform","uniformRegex","uniformType","name_3","arraySize","_a","textureInfo","availableTextures","autoBindSampler","isTextureArray","isStorageTexture","textures","sampleType","TextureSampleType","Float","i","push","getNextFreeUBOBinding","samplerType","_SamplerTypeByWebGLSamplerType","_b","isComparisonSampler","_IsComparisonSamplerByWebGPUSamplerType","samplerBindingType","SamplerBindingType","Comparison","Filtering","samplerName","AutoSamplerSuffix","samplerInfo","availableSamplers","binding","componentType","charAt","Depth","Uint","Sint","samplerGroupIndex","groupIndex","samplerBindingIndex","bindingIndex","samplerFunction","_SamplerFunctionByWebGLSamplerType","textureType","_TextureTypeByWebGLSamplerType","textureDimension","_GpuTextureViewDimensionByWebGPUTextureType","layouts","textureSetIndex","textureBindingIndex","join","_addSamplerBindingDescription","_addTextureBindingDescription","_addUniformToLeftOverUBO","uniformBuffer","uboRegex","name_4","uniformBufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Uniform","defines","engine","hasDrawBuffersExtension","search","regex","hasFragCoord","fragCoordCode","injectCode","_injectStartingAndEndingCode","hasMultiviewExtension","lastClosingCurly","lastIndexOf","isNDCHalfZRange","RegExp","index","iindex","uniformBufferDescription","ubo","leftOverUniforms","_i","leftOverUniform","vertexCode","fragmentCode","name_5","_applyTextureArrayProcessing","decl","leftOverUBO","_buildLeftOverUBO","_collectBindingNames","_preCreateBindGroupEntries"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @hidden */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substr(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `uniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor__;\\nfloat textureOutputHeight__;\\n};\\n`;\r\n\r\n        if (isFragment) {\r\n            return ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n        return ubDeclaration + code;\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match != null) {\r\n            const varyingType = match[1];\r\n            const name = match[2];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match != null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match != null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substr(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                    ? WebGPUConstants.TextureSampleType.Uint\r\n                    : componentType === \"i\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\r\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\r\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\r\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match != null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(code: string, defines: string[], isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>, engine: ThinEngine) {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord__ = gl_FragCoord;\r\n                if (yFactor__ == 1.) {\r\n                    glFragCoord__.y = textureOutputHeight__ - glFragCoord__.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord__;\\n\" : \"\";\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord__\");\r\n            code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            code = code.replace(/dFdy/g, \"(-yFactor__)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor__;\\n\";\r\n            if (!engine.isNDCHalfZRange) {\r\n                code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\r\n            }\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match != null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}