{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to mouse events to control the camera.\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n */\n\nvar FlyCameraMouseInput =\n/** @class */\nfunction () {\n  /**\n   * Listen to mouse events to control the camera.\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n   */\n  function FlyCameraMouseInput() {\n    /**\n     * Defines the buttons associated with the input to handle camera rotation.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Assign buttons for Yaw control.\n     */\n\n    this.buttonsYaw = [-1, 0, 1];\n    /**\n     * Assign buttons for Pitch control.\n     */\n\n    this.buttonsPitch = [-1, 0, 1];\n    /**\n     * Assign buttons for Roll control.\n     */\n\n    this.buttonsRoll = [2];\n    /**\n     * Detect if any button is being pressed while mouse is moved.\n     * -1 = Mouse locked.\n     * 0 = Left button.\n     * 1 = Middle Button.\n     * 2 = Right Button.\n     */\n\n    this.activeButton = -1;\n    /**\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\n     * Higher values reduce its sensitivity.\n     */\n\n    this.angularSensibility = 1000.0;\n    this._previousPosition = null;\n  }\n  /**\n   * Attach the mouse control to the HTML DOM element.\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\n   */\n\n\n  FlyCameraMouseInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this; // eslint-disable-next-line prefer-rest-params\n\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene().onPointerObservable.add(function (p) {\n      _this._pointerInput(p);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE); // Correct Roll by rate, if enabled.\n\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(function () {\n      if (_this.camera.rollCorrect) {\n        _this.camera.restoreRoll(_this.camera.rollCorrect);\n      }\n    });\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  FlyCameraMouseInput.prototype.detachControl = function () {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this._previousPosition = null;\n      this._noPreventDefault = undefined;\n    }\n  };\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name.\n   */\n\n\n  FlyCameraMouseInput.prototype.getClassName = function () {\n    return \"FlyCameraMouseInput\";\n  };\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input's friendly name.\n   */\n\n\n  FlyCameraMouseInput.prototype.getSimpleName = function () {\n    return \"mouse\";\n  }; // Track mouse movement, when the pointer is not locked.\n\n\n  FlyCameraMouseInput.prototype._pointerInput = function (p) {\n    var e = p.event;\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    } // Mouse is moved but an unknown mouse button is pressed.\n\n\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n\n    var srcElement = e.srcElement || e.target; // Mouse down.\n\n    if (p.type === PointerEventTypes.POINTERDOWN) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(e.pointerId);\n      } catch (e) {// Nothing to do with the error. Execution continues.\n      }\n\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n\n        this._element.focus();\n      } // This is required to move while pointer button is down\n\n\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    } // Mouse up.\n    else if (p.type === PointerEventTypes.POINTERUP) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(e.pointerId);\n      } catch (e) {// Nothing to do with the error. Execution continues.\n      }\n\n      this.activeButton = -1;\n      this._previousPosition = null;\n\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    } // Mouse move.\n    else if (p.type === PointerEventTypes.POINTERMOVE) {\n      if (!this._previousPosition) {\n        if (engine.isPointerLock) {\n          this._onMouseMove(p.event);\n        }\n\n        return;\n      }\n\n      var offsetX = e.clientX - this._previousPosition.x;\n      var offsetY = e.clientY - this._previousPosition.y;\n\n      this._rotateCamera(offsetX, offsetY);\n\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n  }; // Track mouse movement, when pointer is locked.\n\n\n  FlyCameraMouseInput.prototype._onMouseMove = function (e) {\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\n    var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\n\n    this._rotateCamera(offsetX, offsetY);\n\n    this._previousPosition = null;\n\n    if (!this._noPreventDefault) {\n      e.preventDefault();\n    }\n  };\n  /**\n   * Rotate camera by mouse offset.\n   * @param offsetX\n   * @param offsetY\n   */\n\n\n  FlyCameraMouseInput.prototype._rotateCamera = function (offsetX, offsetY) {\n    var _this = this;\n\n    var camera = this.camera;\n    var scene = this.camera.getScene();\n\n    if (scene.useRightHandedSystem) {\n      offsetX *= -1;\n    }\n\n    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\n      offsetX *= -1;\n    }\n\n    var x = offsetX / this.angularSensibility;\n    var y = offsetY / this.angularSensibility; // Initialize to current rotation.\n\n    var currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    var rotationChange; // Pitch.\n\n    if (this.buttonsPitch.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y); // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Yaw.\n\n\n    if (this.buttonsYaw.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x); // Apply Yaw to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange); // Add Roll, if banked turning is enabled, within Roll limit.\n\n      var limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\n\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        var bankingDelta = camera.bankedTurnMultiplier * -x; // Apply change in Radians to vector Angle.\n\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta); // Apply Yaw to quaternion.\n\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    } // Roll.\n\n\n    if (this.buttonsRoll.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x); // Track Rolling.\n\n      camera._trackRoll -= x; // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Apply rotationQuaternion to Euler camera.rotation.\n\n\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  };\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\n\n  return FlyCameraMouseInput;\n}();\n\nexport { FlyCameraMouseInput };\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","PointerEventTypes","Quaternion","Axis","Tools","FlyCameraMouseInput","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","_noPreventDefault","_observer","camera","getScene","onPointerObservable","add","p","_this","_pointerInput","POINTERDOWN","POINTERUP","POINTERMOVE","_rollObserver","onBeforeRenderObservable","rollCorrect","restoreRoll","remove","_previousPosition","undefined","e","event","engine","getEngine","isInVRExclusivePointerMode","touchEnabled","pointerType","type","buttons","indexOf","button","srcElement","target","setPointerCapture","pointerId","x","clientX","y","clientY","activeButton","preventDefault","_element","focus","isPointerLock","_onMouseMove","releasePointerCapture","offsetX","offsetY","_rotateCamera","movementX","mozMovementX","webkitMovementX","msMovementX","movementY","mozMovementY","webkitMovementY","msMovementY","scene","useRightHandedSystem","parent","_getWorldMatrixDeterminant","angularSensibility","currentRotation","RotationYawPitchRoll","rotation","z","rotationChange","buttonsPitch","some","v","RotationAxis","X","multiplyInPlace","buttonsYaw","Y","limit","bankedTurnLimit","_trackRoll","bankedTurn","bankingDelta","bankedTurnMultiplier","Z","buttonsRoll","toEulerAnglesToRef","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/flyCameraMouseInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Pitch control.\r\n     */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Roll control.\r\n     */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n    private _noPreventDefault: boolean | undefined;\r\n    private _element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add((p: any) => {\r\n            this._pointerInput(p);\r\n        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.camera.rollCorrect) {\r\n                this.camera.restoreRoll(this.camera.rollCorrect);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this._previousPosition = null;\r\n            this._noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any): void {\r\n        const e = <IPointerEvent>p.event;\r\n\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        const srcElement = <HTMLElement>(e.srcElement || e.target);\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN) {\r\n            try {\r\n                srcElement?.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n                this._element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        }\r\n        // Mouse up.\r\n        else if (p.type === PointerEventTypes.POINTERUP) {\r\n            try {\r\n                srcElement?.releasePointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.activeButton = -1;\r\n\r\n            this._previousPosition = null;\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        // Mouse move.\r\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._previousPosition) {\r\n                if (engine.isPointerLock) {\r\n                    this._onMouseMove(p.event);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            const offsetX = e.clientX - this._previousPosition.x;\r\n            const offsetY = e.clientY - this._previousPosition.y;\r\n\r\n            this._rotateCamera(offsetX, offsetY);\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        const offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\r\n        const offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\r\n\r\n        this._rotateCamera(offsetX, offsetY);\r\n\r\n        this._previousPosition = null;\r\n\r\n        if (!this._noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    private _rotateCamera(offsetX: number, offsetY: number): void {\r\n        const camera = this.camera;\r\n        const scene = this.camera.getScene();\r\n\r\n        if (scene.useRightHandedSystem) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        const x = offsetX / this.angularSensibility;\r\n        const y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\r\n        let rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (\r\n            this.buttonsPitch.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (\r\n            this.buttonsYaw.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (\r\n            this.buttonsRoll.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n"]},"metadata":{},"sourceType":"module"}