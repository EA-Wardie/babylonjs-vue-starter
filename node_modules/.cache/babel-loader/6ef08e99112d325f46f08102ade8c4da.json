{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { GroundMesh } from \"../groundMesh.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ground\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n *  - width the width (x direction) of the ground, optional, default 1\n *  - height the height (z direction) of the ground, optional, default 1\n *  - subdivisions the number of subdivisions per side, optional, default 1\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @returns the VertexData of the Ground\n */\n\nexport function CreateGroundVertexData(options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var width = options.width || 1;\n  var height = options.height || 1;\n  var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n\n  for (row = 0; row <= subdivisionsY; row++) {\n    for (col = 0; col <= subdivisionsX; col++) {\n      var position = new Vector3(col * width / subdivisionsX - width / 2.0, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2.0);\n      var normal = new Vector3(0, 1.0, 0);\n      positions.push(position.x, position.y, position.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\n    }\n  }\n\n  for (row = 0; row < subdivisionsY; row++) {\n    for (col = 0; col < subdivisionsX; col++) {\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + row * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n      indices.push(col + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n * * xmin the ground minimum X coordinate, optional, default -1\n * * zmin the ground minimum Z coordinate, optional, default -1\n * * xmax the ground maximum X coordinate, optional, default 1\n * * zmax the ground maximum Z coordinate, optional, default 1\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @returns the VertexData of the TiledGround\n */\n\nexport function CreateTiledGroundVertexData(options) {\n  var xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n  var zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n  var xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n  var zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n  var subdivisions = options.subdivisions || {\n    w: 1,\n    h: 1\n  };\n  var precision = options.precision || {\n    w: 1,\n    h: 1\n  };\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var row, col, tileRow, tileCol;\n  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n  precision.w = precision.w < 1 ? 1 : precision.w;\n  precision.h = precision.h < 1 ? 1 : precision.h;\n  var tileSize = {\n    w: (xmax - xmin) / subdivisions.w,\n    h: (zmax - zmin) / subdivisions.h\n  };\n\n  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n    // Indices\n    var base = positions.length / 3;\n    var rowLength = precision.w + 1;\n\n    for (row = 0; row < precision.h; row++) {\n      for (col = 0; col < precision.w; col++) {\n        var square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n        indices.push(square[1]);\n        indices.push(square[2]);\n        indices.push(square[3]);\n        indices.push(square[0]);\n        indices.push(square[1]);\n        indices.push(square[3]);\n      }\n    } // Position, normals and uvs\n\n\n    var position = Vector3.Zero();\n    var normal = new Vector3(0, 1.0, 0);\n\n    for (row = 0; row <= precision.h; row++) {\n      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;\n\n      for (col = 0; col <= precision.w; col++) {\n        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;\n        position.y = 0;\n        positions.push(position.x, position.y, position.z);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(col / precision.w, row / precision.h);\n      }\n    }\n  }\n\n  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData of the Ground designed from a heightmap\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n * * width the width (x direction) of the ground\n * * height the height (z direction) of the ground\n * * subdivisions the number of subdivisions per side\n * * minHeight the minimum altitude on the ground, optional, default 0\n * * maxHeight the maximum altitude on the ground, optional default 1\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n * * buffer the array holding the image color data\n * * bufferWidth the width of image\n * * bufferHeight the height of image\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.buffer\n * @param options.bufferWidth\n * @param options.bufferHeight\n * @param options.alphaFilter\n * @returns the VertexData of the Ground designed from a heightmap\n */\n\nexport function CreateGroundFromHeightMapVertexData(options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  var alphaFilter = options.alphaFilter || 0.0;\n  var invert = false;\n\n  if (options.minHeight > options.maxHeight) {\n    invert = true;\n    var temp = options.maxHeight;\n    options.maxHeight = options.minHeight;\n    options.minHeight = temp;\n  } // Vertices\n\n\n  for (row = 0; row <= options.subdivisions; row++) {\n    for (col = 0; col <= options.subdivisions; col++) {\n      var position = new Vector3(col * options.width / options.subdivisions - options.width / 2.0, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2.0); // Compute height\n\n      var heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;\n      var heightMapY = (1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;\n      var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n      var r = options.buffer[pos] / 255.0;\n      var g = options.buffer[pos + 1] / 255.0;\n      var b = options.buffer[pos + 2] / 255.0;\n      var a = options.buffer[pos + 3] / 255.0;\n\n      if (invert) {\n        r = 1.0 - r;\n        g = 1.0 - g;\n        b = 1.0 - b;\n      }\n\n      var gradient = r * filter.r + g * filter.g + b * filter.b; // If our alpha channel is not within our filter then we will assign a 'special' height\n      // Then when building the indices, we will ignore any vertex that is using the special height\n\n      if (a >= alphaFilter) {\n        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n      } else {\n        position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n      } // Add  vertex\n\n\n      positions.push(position.x, position.y, position.z);\n      normals.push(0, 0, 0);\n      uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n    }\n  } // Indices\n\n\n  for (row = 0; row < options.subdivisions; row++) {\n    for (col = 0; col < options.subdivisions; col++) {\n      // Calculate Indices\n      var idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n      var idx2 = col + 1 + row * (options.subdivisions + 1);\n      var idx3 = col + row * (options.subdivisions + 1);\n      var idx4 = col + (row + 1) * (options.subdivisions + 1); // Check that all indices are visible (based on our special height)\n      // Only display the vertex if all Indices are visible\n      // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n\n      var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n        indices.push(idx1);\n        indices.push(idx2);\n        indices.push(idx3);\n      }\n\n      var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n        indices.push(idx4);\n        indices.push(idx1);\n        indices.push(idx3);\n      }\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Result\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a ground mesh\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground\n */\n\nexport function CreateGround(name, options, scene) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ground = new GroundMesh(name, scene);\n\n  ground._setReady(false);\n\n  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n  ground._width = options.width || 1;\n  ground._height = options.height || 1;\n  ground._maxX = ground._width / 2;\n  ground._maxZ = ground._height / 2;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n  var vertexData = CreateGroundVertexData(options);\n  vertexData.applyToMesh(ground, options.updatable);\n\n  ground._setReady(true);\n\n  return ground;\n}\n/**\n * Creates a tiled ground mesh\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the tiled ground mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\n */\n\nexport function CreateTiledGround(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var tiledGround = new Mesh(name, scene);\n  var vertexData = CreateTiledGroundVertexData(options);\n  vertexData.applyToMesh(tiledGround, options.updatable);\n  return tiledGround;\n}\n/**\n * Creates a ground mesh from a height map\n * * The parameter `url` sets the URL of the height map image resource.\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param url defines the url to the height map\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.alphaFilter\n * @param options.updatable\n * @param options.onReady\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/babylon101/height_map\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\n */\n\nexport function CreateGroundFromHeightMap(name, url, options, scene) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var width = options.width || 10.0;\n  var height = options.height || 10.0;\n  var subdivisions = options.subdivisions || 1 | 0;\n  var minHeight = options.minHeight || 0.0;\n  var maxHeight = options.maxHeight || 1.0;\n  var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  var alphaFilter = options.alphaFilter || 0.0;\n  var updatable = options.updatable;\n  var onReady = options.onReady;\n  scene = scene || EngineStore.LastCreatedScene;\n  var ground = new GroundMesh(name, scene);\n  ground._subdivisionsX = subdivisions;\n  ground._subdivisionsY = subdivisions;\n  ground._width = width;\n  ground._height = height;\n  ground._maxX = ground._width / 2.0;\n  ground._maxZ = ground._height / 2.0;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n\n  ground._setReady(false);\n\n  var onload = function onload(img) {\n    var bufferWidth = img.width;\n    var bufferHeight = img.height;\n\n    if (scene.isDisposed) {\n      return;\n    }\n\n    var buffer = scene === null || scene === void 0 ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\n    var vertexData = CreateGroundFromHeightMapVertexData({\n      width: width,\n      height: height,\n      subdivisions: subdivisions,\n      minHeight: minHeight,\n      maxHeight: maxHeight,\n      colorFilter: filter,\n      buffer: buffer,\n      bufferWidth: bufferWidth,\n      bufferHeight: bufferHeight,\n      alphaFilter: alphaFilter\n    });\n    vertexData.applyToMesh(ground, updatable); //execute ready callback, if set\n\n    if (onReady) {\n      onReady(ground);\n    }\n\n    ground._setReady(true);\n  };\n\n  Tools.LoadImage(url, onload, function () {}, scene.offlineProvider);\n  return ground;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\n\nexport var GroundBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGround: CreateGround,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGroundFromHeightMap: CreateGroundFromHeightMap,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledGround: CreateTiledGround\n};\nVertexData.CreateGround = CreateGroundVertexData;\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\n\nMesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    updatable: updatable\n  };\n  return CreateGround(name, options, scene);\n};\n\nMesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\n  var options = {\n    xmin: xmin,\n    zmin: zmin,\n    xmax: xmax,\n    zmax: zmax,\n    subdivisions: subdivisions,\n    precision: precision,\n    updatable: updatable\n  };\n  return CreateTiledGround(name, options, scene);\n};\n\nMesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    minHeight: minHeight,\n    maxHeight: maxHeight,\n    updatable: updatable,\n    onReady: onReady,\n    alphaFilter: alphaFilter\n  };\n  return CreateGroundFromHeightMap(name, url, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Color3","Mesh","VertexData","GroundMesh","Tools","EngineStore","Epsilon","CompatibilityOptions","CreateGroundVertexData","options","indices","positions","normals","uvs","row","col","width","height","subdivisionsX","subdivisions","subdivisionsY","position","normal","push","x","y","z","UseOpenGLOrientationForUV","vertexData","CreateTiledGroundVertexData","xmin","undefined","zmin","xmax","zmax","w","h","precision","Array","tileRow","tileCol","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","length","rowLength","square","Zero","CreateGroundFromHeightMapVertexData","filter","colorFilter","alphaFilter","invert","minHeight","maxHeight","temp","heightMapX","bufferWidth","heightMapY","bufferHeight","pos","r","buffer","g","b","a","gradient","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","isVisibleIdx4","ComputeNormals","CreateGround","name","scene","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","applyToMesh","updatable","CreateTiledGround","tiledGround","CreateGroundFromHeightMap","url","onReady","LastCreatedScene","onload","img","isDisposed","getEngine","resizeImageBitmap","LoadImage","offlineProvider","GroundBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/groundBuilder.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n *  - width the width (x direction) of the ground, optional, default 1\r\n *  - height the height (z direction) of the ground, optional, default 1\r\n *  - subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || 1;\r\n    const height: number = options.height || 1;\r\n    const subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    const subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * * xmin the ground minimum X coordinate, optional, default -1\r\n * * zmin the ground minimum Z coordinate, optional, default -1\r\n * * xmax the ground maximum X coordinate, optional, default 1\r\n * * zmax the ground maximum Z coordinate, optional, default 1\r\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * * width the width (x direction) of the ground\r\n * * height the height (z direction) of the ground\r\n * * subdivisions the number of subdivisions per side\r\n * * minHeight the minimum altitude on the ground, optional, default 0\r\n * * maxHeight the maximum altitude on the ground, optional default 1\r\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * * buffer the array holding the image color data\r\n * * bufferWidth the width of image\r\n * * bufferHeight the height of image\r\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.buffer\r\n * @param options.bufferWidth\r\n * @param options.bufferHeight\r\n * @param options.alphaFilter\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map\r\n * * The parameter `url` sets the URL of the height map image resource.\r\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param url defines the url to the height map\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.alphaFilter\r\n * @param options.updatable\r\n * @param options.onReady\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/babylon101/height_map\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string,\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh) => void;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        const bufferWidth = img.width;\r\n        const bufferHeight = img.height;\r\n\r\n        if (scene!.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        const buffer = <Uint8Array>scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\n(Mesh as any).CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}