{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { Animation } from \"./animation.js\";\nimport { RuntimeAnimation } from \"./runtimeAnimation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PrecisionDate } from \"../Misc/precisionDate.js\";\nimport { Bone } from \"../Bones/bone.js\";\n/**\n * Class used to store an actual running animation\n */\n\nvar Animatable =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Animatable\n   * @param scene defines the hosting scene\n   * @param target defines the target object\n   * @param fromFrame defines the starting frame number (default is 0)\n   * @param toFrame defines the ending frame number (default is 100)\n   * @param loopAnimation defines if the animation must loop (default is false)\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n   * @param animations defines a group of animation to add to the new Animatable\n   * @param onAnimationLoop defines a callback to call when animation loops\n   * @param isAdditive defines whether the animation should be evaluated additively\n   */\n  function Animatable(scene,\n  /** defines the target object */\n  target,\n  /** defines the starting frame number (default is 0) */\n  fromFrame,\n  /** defines the ending frame number (default is 100) */\n  toFrame,\n  /** defines if the animation must loop (default is false)  */\n  loopAnimation, speedRatio,\n  /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations,\n  /** defines a callback to call when animation loops */\n  onAnimationLoop,\n  /** defines whether the animation should be evaluated additively */\n  isAdditive) {\n    if (fromFrame === void 0) {\n      fromFrame = 0;\n    }\n\n    if (toFrame === void 0) {\n      toFrame = 100;\n    }\n\n    if (loopAnimation === void 0) {\n      loopAnimation = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1.0;\n    }\n\n    if (isAdditive === void 0) {\n      isAdditive = false;\n    }\n\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._manualJumpDelay = null;\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    this._frameToSyncFromJump = 0;\n    /**\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n     * This will only apply for non looping animation (default is true)\n     */\n\n    this.disposeOnEnd = true;\n    /**\n     * Gets a boolean indicating if the animation has started\n     */\n\n    this.animationStarted = false;\n    /**\n     * Observer raised when the animation ends\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when the animation loops\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n\n    this._speedRatio = speedRatio;\n\n    scene._activeAnimatables.push(this);\n  }\n\n  Object.defineProperty(Animatable.prototype, \"syncRoot\", {\n    /**\n     * Gets the root Animatable used to synchronize and normalize animations\n     */\n    get: function get() {\n      return this._syncRoot;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"masterFrame\", {\n    /**\n     * Gets the current frame of the first RuntimeAnimation\n     * Used to synchronize Animatables\n     */\n    get: function get() {\n      if (this._runtimeAnimations.length === 0) {\n        return 0;\n      }\n\n      return this._runtimeAnimations[0].currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"weight\", {\n    /**\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n     */\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(value) {\n      if (value === -1) {\n        // -1 is ok and means no weight\n        this._weight = -1;\n        return;\n      } // Else weight must be in [0, 1] range\n\n\n      this._weight = Math.min(Math.max(value, 0), 1.0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"speedRatio\", {\n    /**\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n     */\n    get: function get() {\n      return this._speedRatio;\n    },\n    set: function set(value) {\n      for (var index = 0; index < this._runtimeAnimations.length; index++) {\n        var animation = this._runtimeAnimations[index];\n\n        animation._prepareForSpeedRatioChange(value);\n      }\n\n      this._speedRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\n   * Synchronize and normalize current Animatable with a source Animatable\n   * This is useful when using animation weights and when animations are not of the same length\n   * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n   * @returns the current Animatable\n   */\n\n  Animatable.prototype.syncWith = function (root) {\n    this._syncRoot = root;\n\n    if (root) {\n      // Make sure this animatable will animate after the root\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Gets the list of runtime animations\n   * @returns an array of RuntimeAnimation\n   */\n\n\n  Animatable.prototype.getAnimations = function () {\n    return this._runtimeAnimations;\n  };\n  /**\n   * Adds more animations to the current animatable\n   * @param target defines the target of the animations\n   * @param animations defines the new animations to add\n   */\n\n\n  Animatable.prototype.appendAnimations = function (target, animations) {\n    var _this = this;\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n\n      newRuntimeAnimation._onLoop = function () {\n        _this.onAnimationLoopObservable.notifyObservers(_this);\n\n        if (_this.onAnimationLoop) {\n          _this.onAnimationLoop();\n        }\n      };\n\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  };\n  /**\n   * Gets the source animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the source animation for the given property\n   */\n\n\n  Animatable.prototype.getAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Gets the runtime animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the runtime animation for the given property\n   */\n\n\n  Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Resets the animatable to its original state\n   */\n\n\n  Animatable.prototype.reset = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  };\n  /**\n   * Allows the animatable to blend with current running animations\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\n   * @param blendingSpeed defines the blending speed to use\n   */\n\n\n  Animatable.prototype.enableBlending = function (blendingSpeed) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  };\n  /**\n   * Disable animation blending\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\n   */\n\n\n  Animatable.prototype.disableBlending = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  };\n  /**\n   * Jump directly to a given frame\n   * @param frame defines the frame to jump to\n   */\n\n\n  Animatable.prototype.goToFrame = function (frame) {\n    var _a;\n\n    var runtimeAnimations = this._runtimeAnimations;\n\n    if (runtimeAnimations[0]) {\n      var fps = runtimeAnimations[0].animation.framePerSecond;\n      this._frameToSyncFromJump = (_a = this._frameToSyncFromJump) !== null && _a !== void 0 ? _a : runtimeAnimations[0].currentFrame;\n      var delay = this.speedRatio === 0 ? 0 : (frame - this._frameToSyncFromJump) / fps * 1000 / this.speedRatio;\n      this._manualJumpDelay = -delay;\n    }\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n  };\n  /**\n   * Pause the animation\n   */\n\n\n  Animatable.prototype.pause = function () {\n    if (this._paused) {\n      return;\n    }\n\n    this._paused = true;\n  };\n  /**\n   * Restart the animation\n   */\n\n\n  Animatable.prototype.restart = function () {\n    this._paused = false;\n  };\n\n  Animatable.prototype._raiseOnAnimationEnd = function () {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n\n    this.onAnimationEndObservable.notifyObservers(this);\n  };\n  /**\n   * Stop and delete the current animation\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   */\n\n\n  Animatable.prototype.stop = function (animationName, targetMask) {\n    if (animationName || targetMask) {\n      var idx = this._scene._activeAnimatables.indexOf(this);\n\n      if (idx > -1) {\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\n          var runtimeAnimation = runtimeAnimations[index];\n\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n\n        if (runtimeAnimations.length == 0) {\n          this._scene._activeAnimatables.splice(idx, 1);\n\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index_1 = 0; index_1 < runtimeAnimations.length; index_1++) {\n          runtimeAnimations[index_1].dispose();\n        }\n\n        this._raiseOnAnimationEnd();\n      }\n    }\n  };\n  /**\n   * Wait asynchronously for the animation to end\n   * @returns a promise which will be fulfilled when the animation ends\n   */\n\n\n  Animatable.prototype.waitAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.onAnimationEndObservable.add(function () {\n        resolve(_this);\n      }, undefined, undefined, _this, true);\n    });\n  };\n  /**\n   * @param delay\n   * @hidden\n   */\n\n\n  Animatable.prototype._animate = function (delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n\n      return true;\n    }\n\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n\n    if (this._manualJumpDelay !== null) {\n      this._localDelayOffset += this._manualJumpDelay;\n      this._manualJumpDelay = null;\n      this._frameToSyncFromJump = null;\n    }\n\n    if (this._weight === 0) {\n      // We consider that an animation with a weight === 0 is \"actively\" paused\n      return true;\n    } // Animating\n\n\n    var running = false;\n    var runtimeAnimations = this._runtimeAnimations;\n    var index;\n\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      var animation = runtimeAnimations[index];\n      var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n\n    this.animationStarted = running;\n\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n\n        this._scene._activeAnimatables.splice(index, 1); // Dispose all runtime animations\n\n\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n\n      this._raiseOnAnimationEnd();\n\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n\n    return running;\n  };\n\n  return Animatable;\n}();\n\nexport { Animatable };\n\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  } // Getting time\n\n\n  var now = PrecisionDate.Now;\n\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n\n    this._animationTimeLast = now;\n  }\n\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  var animatables = this._activeAnimatables;\n\n  if (animatables.length === 0) {\n    return;\n  }\n\n  this._animationTime += this.deltaTime;\n  var animationTime = this._animationTime;\n\n  for (var index = 0; index < animatables.length; index++) {\n    var animatable = animatables[index];\n\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  } // Late animation bindings\n\n\n  this._processLateAnimationBindings();\n};\n\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\n  if (weight === void 0) {\n    weight = 1.0;\n  }\n\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\n\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n\n  var shouldRunTargetAnimations = targetMask ? targetMask(target) : true; // Local animations\n\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  } // Children animations\n\n\n  if (target.getAnimatables) {\n    var animatables = target.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n\n  animatable.reset();\n  return animatable;\n};\n\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n\n  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n    var child = children_1[_i];\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  } else if (to > from && speedRatio < 0) {\n    var temp = to;\n    to = from;\n    from = temp;\n  }\n\n  var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\n\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n\n  for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\n    var child = children_2[_i];\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n\n  return null;\n};\n\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  var result = [];\n\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n\n  return result;\n};\n/**\n * Will stop the animation of the given target\n * @param target - the target\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n */\n\n\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  var animatables = this.getAllAnimatablesByTarget(target);\n\n  for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\n    var animatable = animatables_1[_i];\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\n * Stops and removes all animations that have been applied to the scene\n */\n\n\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (var i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop();\n    }\n\n    this._activeAnimatables = [];\n  }\n\n  for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\n    var group = _a[_i];\n    group.stop();\n  }\n};\n\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  var target = runtimeAnimation.target;\n\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\n\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n\n  var normalizer = 1.0;\n  var finalPosition = TmpVectors.Vector3[0];\n  var finalScaling = TmpVectors.Vector3[1];\n  var finalQuaternion = TmpVectors.Quaternion[0];\n  var startIndex = 0;\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var scale = 1;\n  var skipOverride = false;\n\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1; // We need to normalize the weights\n\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } // Add up the override animations\n\n\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n\n    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n\n      scale = runtimeAnimation.weight / normalizer;\n      var currentPosition = TmpVectors.Vector3[2];\n      var currentScaling = TmpVectors.Vector3[3];\n      var currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    var currentPosition = TmpVectors.Vector3[2];\n    var currentScaling = TmpVectors.Vector3[3];\n    var currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n\n  var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\n\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var cumulativeQuaternion = refQuaternion;\n\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    var normalizer = 1.0;\n    var quaternions = void 0;\n    var weights = void 0;\n\n    if (holder.totalWeight < 1.0) {\n      var scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n\n    for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    } // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n\n\n    var cumulativeAmount = 0;\n\n    for (var index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n\n  return cumulativeQuaternion;\n};\n\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n\n  for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    var target = this._registeredForLateAnimationBindings.data[index];\n\n    for (var path in target._lateAnimationHolders) {\n      var holder = target._lateAnimationHolders[path];\n      var originalAnimation = holder.animations[0];\n      var originalValue = holder.originalValue;\n      var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n\n      var finalValue = target[path];\n\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        var quaternionMode = originalValue.w !== undefined;\n\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          var startIndex = 0;\n          var normalizer = 1.0;\n\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            var scale = originalAnimation.weight / normalizer;\n\n            if (scale !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale);\n              } else {\n                finalValue = originalAnimation.currentValue * scale;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n\n            startIndex = 1;\n          } // Add up the override animations\n\n\n          for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            var runtimeAnimation = holder.animations[animIndex];\n            var scale = runtimeAnimation.weight / normalizer;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          } // Add up the additive animations\n\n\n          for (var animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n            var runtimeAnimation = holder.additiveAnimations[animIndex];\n            var scale = runtimeAnimation.weight;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n\n      target[path] = finalValue;\n    }\n\n    target._lateAnimationHolders = {};\n  }\n\n  this._registeredForLateAnimationBindings.reset();\n};\n\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\n  if (rescaleAsRequired === void 0) {\n    rescaleAsRequired = false;\n  }\n\n  if (skelDimensionsRatio === void 0) {\n    skelDimensionsRatio = null;\n  } // all animation may be coming from a library skeleton, so may need to create animation\n\n\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  } // get animation info / verify there is such a range from the source bone\n\n\n  var sourceRange = source.animations[0].getRange(rangeName);\n\n  if (!sourceRange) {\n    return false;\n  }\n\n  var from = sourceRange.from;\n  var to = sourceRange.to;\n  var sourceKeys = source.animations[0].getKeys(); // rescaling prep\n\n  var sourceBoneLength = source.length;\n  var sourceParent = source.getParent();\n  var parent = this.getParent();\n  var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  var destKeys = this.animations[0].getKeys(); // loop vars declaration\n\n  var orig;\n  var origTranslation;\n  var mat;\n\n  for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone(); // scale based on parent ratio, when bone has parent\n\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio)); // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio)); // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":{"version":3,"mappings":"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","names":["Animation","RuntimeAnimation","Observable","Scene","Matrix","Quaternion","Vector3","TmpVectors","PrecisionDate","Bone","scene","target","fromFrame","toFrame","loopAnimation","speedRatio","onAnimationEnd","animations","onAnimationLoop","isAdditive","Array","_scene","appendAnimations","_speedRatio","_activeAnimatables","push","Object","Animatable","_syncRoot","_runtimeAnimations","length","currentFrame","_weight","value","Math","min","max","index","animation","_prepareForSpeedRatioChange","root","indexOf","splice","newRuntimeAnimation","_onLoop","_this","onAnimationLoopObservable","notifyObservers","property","runtimeAnimations","targetProperty","reset","_localDelayOffset","_pausedDelay","blendingSpeed","enableBlending","frame","fps","framePerSecond","_frameToSyncFromJump","_a","delay","_manualJumpDelay","goToFrame","_paused","onAnimationEndObservable","animationName","targetMask","idx","runtimeAnimation","name","dispose","_raiseOnAnimationEnd","index_1","Promise","resolve","add","undefined","animationStarted","running","isRunning","animate","disposeOnEnd","clear","prototype","_animate","animationsEnabled","now","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","_animationTime","animationTime","animatable","_processLateAnimationBindings","beginWeightedAnimation","from","to","weight","loop","returnedAnimatable","beginAnimation","stopCurrent","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","_i","child","beginDirectAnimation","temp","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stop","stopAllAnimations","i","animationGroups","group","_registerTargetForLateAnimationBinding","originalValue","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","targetPath","totalWeight","totalAdditiveWeight","additiveAnimations","_processLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","finalScaling","finalQuaternion","startIndex","originalAnimation","scale","skipOverride","decompose","currentValue","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","multiplyToRef","LerpToRef","SlerpToRef","workValue","_animationState","clone","ComposeToRef","_processLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","copyFrom","quaternions","weights","cumulativeAmount","data","path","matrixDecomposeMode","AllowMatrixDecomposeForInterpolation","m","finalValue","quaternionMode","w","Identity","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","ANIMATIONTYPE_MATRIX","setKeys","sourceRange","getRange","sourceKeys","getKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","key","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Animations/animatable.ts"],"sourcesContent":["import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    private _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param delay\r\n     * @hidden\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        if (this._weight === 0) {\r\n            // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindingsForMatrices(holder: {\r\n            totalWeight: number;\r\n            totalAdditiveWeight: number;\r\n            animations: RuntimeAnimation[];\r\n            additiveAnimations: RuntimeAnimation[];\r\n            originalValue: Matrix;\r\n        }): any;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindingsForQuaternions(\r\n            holder: {\r\n                totalWeight: number;\r\n                totalAdditiveWeight: number;\r\n                animations: RuntimeAnimation[];\r\n                additiveAnimations: RuntimeAnimation[];\r\n                originalValue: Quaternion;\r\n            },\r\n            refQuaternion: Quaternion\r\n        ): Quaternion;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindings(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n\r\n        /**\r\n         * Gets the current delta time used by animation engine\r\n         */\r\n        deltaTime: number;\r\n    }\r\n}\r\n\r\nScene.prototype._animate = function (): void {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n\r\n    // Getting time\r\n    const now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n\r\n    const animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n\r\n    this._animationTime += this.deltaTime;\r\n    const animationTime = this._animationTime;\r\n\r\n    for (let index = 0; index < animatables.length; index++) {\r\n        const animatable = animatables[index];\r\n\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\n\r\nScene.prototype.beginWeightedAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    weight = 1.0,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n\r\n    return returnedAnimatable;\r\n};\r\n\r\nScene.prototype.beginAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n\r\n    const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        const animatables = target.getAnimatables();\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n\r\n    animatable.reset();\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginHierarchyAnimation = function (\r\n    target: any,\r\n    directDescendantsOnly: boolean,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.beginDirectAnimation = function (\r\n    target: any,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    } else if (to > from && speedRatio < 0) {\r\n        const temp = to;\r\n        to = from;\r\n        from = temp;\r\n    }\r\n\r\n    const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginDirectHierarchyAnimation = function (\r\n    target: Node,\r\n    directDescendantsOnly: boolean,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n    const result = [];\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n    const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n    for (const animatable of animatables) {\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function (): void {\r\n    if (this._activeAnimatables) {\r\n        for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables = [];\r\n    }\r\n\r\n    for (const group of this.animationGroups) {\r\n        group.stop();\r\n    }\r\n};\r\n\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindings = function (): void {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        const target = this._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\nBone.prototype.copyAnimationRange = function (\r\n    source: Bone,\r\n    rangeName: string,\r\n    frameOffset: number,\r\n    rescaleAsRequired = false,\r\n    skelDimensionsRatio: Nullable<Vector3> = null\r\n): boolean {\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n\r\n    // get animation info / verify there is such a range from the source bone\r\n    const sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    const from = sourceRange.from;\r\n    const to = sourceRange.to;\r\n    const sourceKeys = source.animations[0].getKeys();\r\n\r\n    // rescaling prep\r\n    const sourceBoneLength = source.length;\r\n    const sourceParent = source.getParent();\r\n    const parent = this.getParent();\r\n    const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n    const dimensionsScalingReqd =\r\n        rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n    const destKeys = this.animations[0].getKeys();\r\n\r\n    // loop vars declaration\r\n    let orig: { frame: number; value: Matrix };\r\n    let origTranslation: Vector3;\r\n    let mat: Matrix;\r\n\r\n    for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                } else {\r\n                    mat = orig.value;\r\n                }\r\n            } else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}