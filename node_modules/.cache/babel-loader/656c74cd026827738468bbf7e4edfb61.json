{"ast":null,"code":"import { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\n/**\n * Class used to host RGBD texture specific utilities\n */\n\nvar RGBDTextureTools =\n/** @class */\nfunction () {\n  function RGBDTextureTools() {}\n  /**\n   * Expand the RGBD Texture from RGBD to Half Float if possible.\n   * @param texture the texture to expand.\n   */\n\n\n  RGBDTextureTools.ExpandRGBDTexture = function (texture) {\n    var internalTexture = texture._texture;\n\n    if (!internalTexture || !texture.isRGBD) {\n      return;\n    } // Gets everything ready.\n\n\n    var engine = internalTexture.getEngine();\n    var caps = engine.getCaps();\n    var isReady = internalTexture.isReady;\n    var expandTexture = false; // If half float available we can uncompress the texture\n\n    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 2;\n    } // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 1;\n    }\n\n    if (expandTexture) {\n      // Do not use during decode.\n      internalTexture.isReady = false;\n      internalTexture._isRGBD = false;\n      internalTexture.invertY = false;\n    }\n\n    var expandRGBDTexture = function expandRGBDTexture() {\n      // Expand the texture if possible\n      if (expandTexture) {\n        // Simply run through the decode PP.\n        var rgbdPostProcess_1 = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false);\n        rgbdPostProcess_1.externalTextureSamplerBinding = true; // Hold the output of the decoding.\n\n        var expandedTexture_1 = engine.createRenderTargetTexture(internalTexture.width, {\n          generateDepthBuffer: false,\n          generateMipMaps: false,\n          generateStencilBuffer: false,\n          samplingMode: internalTexture.samplingMode,\n          type: internalTexture.type,\n          format: 5\n        });\n        rgbdPostProcess_1.getEffect().executeWhenCompiled(function () {\n          // PP Render Pass\n          rgbdPostProcess_1.onApply = function (effect) {\n            effect._bindTexture(\"textureSampler\", internalTexture);\n\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n\n          texture.getScene().postProcessManager.directRender([rgbdPostProcess_1], expandedTexture_1, true); // Cleanup\n\n          engine.restoreDefaultFramebuffer();\n\n          engine._releaseTexture(internalTexture);\n\n          if (rgbdPostProcess_1) {\n            rgbdPostProcess_1.dispose();\n          } // Internal Swap\n\n\n          expandedTexture_1._swapAndDie(internalTexture); // Ready to get rolling again.\n\n\n          internalTexture.isReady = true;\n        });\n      }\n    };\n\n    if (isReady) {\n      expandRGBDTexture();\n    } else {\n      texture.onLoadObservable.addOnce(expandRGBDTexture);\n    }\n  };\n  /**\n   * Encode the texture to RGBD if possible.\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param outputTextureType type of the texture in which the encoding is performed\n   * @return a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n\n\n  RGBDTextureTools.EncodeTextureToRGBD = function (internalTexture, scene, outputTextureType) {\n    if (outputTextureType === void 0) {\n      outputTextureType = 0;\n    }\n\n    return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, 1, 5);\n  };\n\n  return RGBDTextureTools;\n}();\n\nexport { RGBDTextureTools };","map":{"version":3,"mappings":"AACA,SAASA,WAAT,QAA4B,iCAA5B;AACA,OAAO,mCAAP;AAGA,OAAO,8CAAP;AACA,SAASC,gBAAT,QAAiC,mBAAjC;AAMA;;;;AAGA;AAAA;AAAA;AAAA,+BA4GC;AA3GG;;;;;;AAIcC,uCAAd,UAAgCC,OAAhC,EAAgD;AAC5C,QAAMC,eAAe,GAAGD,OAAO,CAACE,QAAhC;;AACA,QAAI,CAACD,eAAD,IAAoB,CAACD,OAAO,CAACG,MAAjC,EAAyC;AACrC;AACH,KAJ2C,CAM5C;;;AACA,QAAMC,MAAM,GAAGH,eAAe,CAACI,SAAhB,EAAf;AACA,QAAMC,IAAI,GAAGF,MAAM,CAACG,OAAP,EAAb;AACA,QAAMC,OAAO,GAAGP,eAAe,CAACO,OAAhC;AACA,QAAIC,aAAa,GAAG,KAApB,CAV4C,CAY5C;;AACA,QAAIH,IAAI,CAACI,sBAAL,IAA+BJ,IAAI,CAACK,+BAAxC,EAAyE;AACrEF,mBAAa,GAAG,IAAhB;AACAR,qBAAe,CAACW,IAAhB,GAAuB,CAAvB;AACH,KAHD,CAIA;AAJA,SAKK,IAAIN,IAAI,CAACO,kBAAL,IAA2BP,IAAI,CAACQ,2BAApC,EAAiE;AAClEL,mBAAa,GAAG,IAAhB;AACAR,qBAAe,CAACW,IAAhB,GAAuB,CAAvB;AACH;;AAED,QAAIH,aAAJ,EAAmB;AACf;AACAR,qBAAe,CAACO,OAAhB,GAA0B,KAA1B;AACAP,qBAAe,CAACc,OAAhB,GAA0B,KAA1B;AACAd,qBAAe,CAACe,OAAhB,GAA0B,KAA1B;AACH;;AAED,QAAMC,iBAAiB,GAAG,SAApBA,iBAAoB;AACtB;AACA,UAAIR,aAAJ,EAAmB;AACf;AACA,YAAMS,iBAAe,GAAG,IAAIrB,WAAJ,CACpB,YADoB,EAEpB,YAFoB,EAGpB,IAHoB,EAIpB,IAJoB,EAKpB,CALoB,EAMpB,IANoB,EAOpB,CAPoB,EAOpBO,MAPoB,EAOV,KAPU,EAOVe,SAPU,EAOVlB,eACV,KARoB,EASpBkB,SAToB,EAUpB,IAVoB,EAWpB,KAXoB,CAAxB;AAgBAD,yBAAe,CAACE,6BAAhB,GAAgD,IAAhD,CAlBe,CAoBf;;AACA,YAAMC,iBAAe,GAAGjB,MAAM,CAACkB,yBAAP,CAAiCrB,eAAe,CAACsB,KAAjD,EAAwD;AAC5EC,6BAAmB,EAAE,KADuD;AAE5EC,yBAAe,EAAE,KAF2D;AAG5EC,+BAAqB,EAAE,KAHqD;AAI5EC,sBAAY,EAAE1B,eAAe,CAAC0B,YAJ8C;AAK5Ef,cAAI,EAAEX,eAAe,CAACW,IALsD;AAM5EgB,gBAAM,EAAE;AANoE,SAAxD,CAAxB;AASAV,yBAAe,CAACW,SAAhB,GAA4BC,mBAA5B,CAAgD;AAC5C;AACAZ,2BAAe,CAACa,OAAhB,GAA0B,UAACC,MAAD,EAAO;AAC7BA,kBAAM,CAACC,YAAP,CAAoB,gBAApB,EAAsChC,eAAtC;;AACA+B,kBAAM,CAACE,SAAP,CAAiB,OAAjB,EAA0B,CAA1B,EAA6B,CAA7B;AACH,WAHD;;AAIAlC,iBAAO,CAACmC,QAAR,GAAoBC,kBAApB,CAAuCC,YAAvC,CAAoD,CAACnB,iBAAD,CAApD,EAAwEG,iBAAxE,EAAyF,IAAzF,EAN4C,CAQ5C;;AACAjB,gBAAM,CAACkC,yBAAP;;AACAlC,gBAAM,CAACmC,eAAP,CAAuBtC,eAAvB;;AACA,cAAIiB,iBAAJ,EAAqB;AACjBA,6BAAe,CAACsB,OAAhB;AACH,WAb2C,CAe5C;;;AACAnB,2BAAe,CAACoB,WAAhB,CAA4BxC,eAA5B,EAhB4C,CAkB5C;;;AACAA,yBAAe,CAACO,OAAhB,GAA0B,IAA1B;AACH,SApBD;AAqBH;AACJ,KAtDD;;AAwDA,QAAIA,OAAJ,EAAa;AACTS,uBAAiB;AACpB,KAFD,MAEO;AACHjB,aAAO,CAAC0C,gBAAR,CAAyBC,OAAzB,CAAiC1B,iBAAjC;AACH;AACJ,GA3Fa;AA6Fd;;;;;;;;;AAOclB,yCAAd,UAAkCE,eAAlC,EAAoE2C,KAApE,EAAkFC,iBAAlF,EAAyI;AAAvD;AAAAA,0BAAoB,CAApB;AAAoB;;AAClG,WAAO/C,gBAAgB,CAAC,YAAD,EAAeG,eAAf,EAAgC2C,KAAhC,EAAuCC,iBAAvC,EAA0D,CAA1D,EAA0D,CAA1D,CAAvB;AACH,GAFa;;AAGlB;AAAC,CA5GD","names":["PostProcess","ApplyPostProcess","RGBDTextureTools","texture","internalTexture","_texture","isRGBD","engine","getEngine","caps","getCaps","isReady","expandTexture","textureHalfFloatRender","textureHalfFloatLinearFiltering","type","textureFloatRender","textureFloatLinearFiltering","_isRGBD","invertY","expandRGBDTexture","rgbdPostProcess_1","undefined","externalTextureSamplerBinding","expandedTexture_1","createRenderTargetTexture","width","generateDepthBuffer","generateMipMaps","generateStencilBuffer","samplingMode","format","getEffect","executeWhenCompiled","onApply","effect","_bindTexture","setFloat2","getScene","postProcessManager","directRender","restoreDefaultFramebuffer","_releaseTexture","dispose","_swapAndDie","onLoadObservable","addOnce","scene","outputTextureType"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/rgbdTextureTools.ts"],"sourcesContent":["import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\ndeclare type Texture = import(\"../Materials/Textures/texture\").Texture;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            if (expandTexture) {\r\n                // Simply run through the decode PP.\r\n                const rgbdPostProcess = new PostProcess(\r\n                    \"rgbdDecode\",\r\n                    \"rgbdDecode\",\r\n                    null,\r\n                    null,\r\n                    1,\r\n                    null,\r\n                    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    false,\r\n                    undefined,\r\n                    internalTexture.type,\r\n                    undefined,\r\n                    null,\r\n                    false\r\n                );\r\n                rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n                // Hold the output of the decoding.\r\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                    generateDepthBuffer: false,\r\n                    generateMipMaps: false,\r\n                    generateStencilBuffer: false,\r\n                    samplingMode: internalTexture.samplingMode,\r\n                    type: internalTexture.type,\r\n                    format: Constants.TEXTUREFORMAT_RGBA,\r\n                });\r\n\r\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                    // PP Render Pass\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", internalTexture);\r\n                        effect.setFloat2(\"scale\", 1, 1);\r\n                    };\r\n                    texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    engine._releaseTexture(internalTexture);\r\n                    if (rgbdPostProcess) {\r\n                        rgbdPostProcess.dispose();\r\n                    }\r\n\r\n                    // Internal Swap\r\n                    expandedTexture._swapAndDie(internalTexture);\r\n\r\n                    // Ready to get rolling again.\r\n                    internalTexture.isReady = true;\r\n                });\r\n            }\r\n        };\r\n\r\n        if (isReady) {\r\n            expandRGBDTexture();\r\n        } else {\r\n            texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @return a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}