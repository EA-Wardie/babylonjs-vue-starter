{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * RecastJS navigation plugin\n */\n\nvar RecastJSPlugin =\n/** @class */\nfunction () {\n  /**\n   * Initializes the recastJS plugin\n   * @param recastInjection can be used to inject your own recast reference\n   */\n  function RecastJSPlugin(recastInjection) {\n    if (recastInjection === void 0) {\n      recastInjection = Recast;\n    }\n    /**\n     * Reference to the Recast library\n     */\n\n\n    this.bjsRECAST = {};\n    /**\n     * plugin name\n     */\n\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n    this._worker = null;\n\n    if (typeof recastInjection === \"function\") {\n      Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this.setTimeStep();\n    this._tempVec1 = new this.bjsRECAST.Vec3();\n    this._tempVec2 = new this.bjsRECAST.Vec3();\n  }\n  /**\n   * Set worker URL to be used when generating a new navmesh\n   * @param workerURL url string\n   * @returns boolean indicating if worker is created\n   */\n\n\n  RecastJSPlugin.prototype.setWorkerURL = function (workerURL) {\n    if (window && window.Worker) {\n      this._worker = new Worker(workerURL);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Set the time step of the navigation tick update.\n   * Default is 1/60.\n   * A value of 0 will disable fixed time update\n   * @param newTimeStep the new timestep to apply to this world.\n   */\n\n\n  RecastJSPlugin.prototype.setTimeStep = function (newTimeStep) {\n    if (newTimeStep === void 0) {\n      newTimeStep = 1 / 60;\n    }\n\n    this._timeStep = newTimeStep;\n  };\n  /**\n   * Get the time step of the navigation tick update.\n   * @returns the current time step\n   */\n\n\n  RecastJSPlugin.prototype.getTimeStep = function () {\n    return this._timeStep;\n  };\n  /**\n   * If delta time in navigation tick update is greater than the time step\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\n   * they will be discarded.\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\n   * @param newStepCount the maximum number of iterations\n   */\n\n\n  RecastJSPlugin.prototype.setMaximumSubStepCount = function (newStepCount) {\n    if (newStepCount === void 0) {\n      newStepCount = 10;\n    }\n\n    this._maximumSubStepCount = newStepCount;\n  };\n  /**\n   * Get the maximum number of iterations per navigation tick update\n   * @returns the maximum number of iterations\n   */\n\n\n  RecastJSPlugin.prototype.getMaximumSubStepCount = function () {\n    return this._maximumSubStepCount;\n  };\n  /**\n   * Creates a navigation mesh\n   * @param meshes array of all the geometry used to compute the navigation mesh\n   * @param parameters bunch of parameters used to filter geometry\n   * @param completion callback when data is available from the worker. Not used without a worker\n   */\n\n\n  RecastJSPlugin.prototype.createNavMesh = function (meshes, parameters, completion) {\n    if (this._worker && !completion) {\n      console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\n    } else if (!this._worker && completion) {\n      console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\n    }\n\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    var index;\n    var tri;\n    var pt;\n    var indices = [];\n    var positions = [];\n    var offset = 0;\n\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        var mesh = meshes[index];\n        var meshIndices = mesh.getIndices();\n\n        if (!meshIndices) {\n          continue;\n        }\n\n        var meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n\n        if (!meshPositions) {\n          continue;\n        }\n\n        var worldMatrices = [];\n        var worldMatrix = mesh.computeWorldMatrix(true);\n\n        if (mesh.hasThinInstances) {\n          var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n          for (var instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n            var tmpMatrix = new Matrix();\n            var thinMatrix = thinMatrices[instanceIndex];\n            thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n            worldMatrices.push(tmpMatrix);\n          }\n        } else {\n          worldMatrices.push(worldMatrix);\n        }\n\n        for (var matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n          var wm = worldMatrices[matrixIndex];\n\n          for (tri = 0; tri < meshIndices.length; tri++) {\n            indices.push(meshIndices[tri] + offset);\n          }\n\n          var transformed = Vector3.Zero();\n          var position = Vector3.Zero();\n\n          for (pt = 0; pt < meshPositions.length; pt += 3) {\n            Vector3.FromArrayToRef(meshPositions, pt, position);\n            Vector3.TransformCoordinatesToRef(position, wm, transformed);\n            positions.push(transformed.x, transformed.y, transformed.z);\n          }\n\n          offset += meshPositions.length / 3;\n        }\n      }\n    }\n\n    if (this._worker && completion) {\n      // spawn worker and send message\n      this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\n\n      this._worker.onmessage = function (e) {\n        completion(e.data);\n      };\n    } else {\n      // blocking calls\n      var rc = new this.bjsRECAST.rcConfig();\n      rc.cs = parameters.cs;\n      rc.ch = parameters.ch;\n      rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\n      rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\n      rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n      rc.walkableHeight = parameters.walkableHeight;\n      rc.walkableClimb = parameters.walkableClimb;\n      rc.walkableRadius = parameters.walkableRadius;\n      rc.maxEdgeLen = parameters.maxEdgeLen;\n      rc.maxSimplificationError = parameters.maxSimplificationError;\n      rc.minRegionArea = parameters.minRegionArea;\n      rc.mergeRegionArea = parameters.mergeRegionArea;\n      rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n      rc.detailSampleDist = parameters.detailSampleDist;\n      rc.detailSampleMaxError = parameters.detailSampleMaxError;\n      this.navMesh.build(positions, offset, indices, indices.length, rc);\n    }\n  };\n  /**\n   * Create a navigation mesh debug mesh\n   * @param scene is where the mesh will be added\n   * @returns debug display mesh\n   */\n\n\n  RecastJSPlugin.prototype.createDebugNavMesh = function (scene) {\n    var tri;\n    var pt;\n    var debugNavMesh = this.navMesh.getDebugNavMesh();\n    var triangleCount = debugNavMesh.getTriangleCount();\n    var indices = [];\n    var positions = [];\n\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        var point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n\n    var mesh = new Mesh(\"NavMeshDebug\", scene);\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  };\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPoint = function (position) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    var ret = this.navMesh.getClosestPoint(this._tempVec1);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPointToRef = function (position, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    var ret = this.navMesh.getClosestPoint(this._tempVec1);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAround = function (position, maxRadius) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    var ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAroundToRef = function (position, maxRadius, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    var ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @returns the resulting point along the navmesh\n   */\n\n\n  RecastJSPlugin.prototype.moveAlong = function (position, destination) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    var ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @param result output the resulting point along the navmesh\n   */\n\n\n  RecastJSPlugin.prototype.moveAlongToRef = function (position, destination, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    var ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n   * @param start world position\n   * @param end world position\n   * @returns array containing world position composing the path\n   */\n\n\n  RecastJSPlugin.prototype.computePath = function (start, end) {\n    var pt;\n    this._tempVec1.x = start.x;\n    this._tempVec1.y = start.y;\n    this._tempVec1.z = start.z;\n    this._tempVec2.x = end.x;\n    this._tempVec2.y = end.y;\n    this._tempVec2.z = end.z;\n    var navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\n    var pointCount = navPath.getPointCount();\n    var positions = [];\n\n    for (pt = 0; pt < pointCount; pt++) {\n      var p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n\n    return positions;\n  };\n  /**\n   * Create a new Crowd so you can add agents\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n\n\n  RecastJSPlugin.prototype.createCrowd = function (maxAgents, maxAgentRadius, scene) {\n    var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  };\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n\n\n  RecastJSPlugin.prototype.setDefaultQueryExtent = function (extent) {\n    this._tempVec1.x = extent.x;\n    this._tempVec1.y = extent.y;\n    this._tempVec1.z = extent.z;\n    this.navMesh.setDefaultQueryExtent(this._tempVec1);\n  };\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtent = function () {\n    var p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\n   * build the navmesh from a previously saved state using getNavmeshData\n   * @param data the Uint8Array returned by getNavmeshData\n   */\n\n\n  RecastJSPlugin.prototype.buildFromNavmeshData = function (data) {\n    var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n\n    var dataPtr = this.bjsRECAST._malloc(nDataBytes);\n\n    var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    var buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf); // Free memory\n\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  };\n  /**\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n   * @returns data the Uint8Array that can be saved and reused\n   */\n\n\n  RecastJSPlugin.prototype.getNavmeshData = function () {\n    var navmeshData = this.navMesh.getNavmeshData();\n    var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    var ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  };\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\n   * Disposes\n   */\n\n\n  RecastJSPlugin.prototype.dispose = function () {};\n  /**\n   * Creates a cylinder obstacle and add it to the navigation\n   * @param position world position\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns the obstacle freshly created\n   */\n\n\n  RecastJSPlugin.prototype.addCylinderObstacle = function (position, radius, height) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\n  };\n  /**\n   * Creates an oriented box obstacle and add it to the navigation\n   * @param position world position\n   * @param extent box size\n   * @param angle angle in radians of the box orientation on Y axis\n   * @returns the obstacle freshly created\n   */\n\n\n  RecastJSPlugin.prototype.addBoxObstacle = function (position, extent, angle) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = extent.x;\n    this._tempVec2.y = extent.y;\n    this._tempVec2.z = extent.z;\n    return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\n  };\n  /**\n   * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n   * @param obstacle obstacle to remove from the navigation\n   */\n\n\n  RecastJSPlugin.prototype.removeObstacle = function (obstacle) {\n    this.navMesh.removeObstacle(obstacle);\n  };\n  /**\n   * If this plugin is supported\n   * @returns true if plugin is supported\n   */\n\n\n  RecastJSPlugin.prototype.isSupported = function () {\n    return this.bjsRECAST !== undefined;\n  };\n\n  return RecastJSPlugin;\n}();\n\nexport { RecastJSPlugin };\n/**\n * Recast detour crowd implementation\n */\n\nvar RecastJSCrowd =\n/** @class */\nfunction () {\n  /**\n   * Constructor\n   * @param plugin recastJS plugin\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  function RecastJSCrowd(plugin, maxAgents, maxAgentRadius, scene) {\n    var _this = this;\n    /**\n     * Link to the detour crowd\n     */\n\n\n    this.recastCrowd = {};\n    /**\n     * One transform per agent\n     */\n\n    this.transforms = new Array();\n    /**\n     * All agents created\n     */\n\n    this.agents = new Array();\n    /**\n     * agents reach radius\n     */\n\n    this.reachRadii = new Array();\n    /**\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\n     */\n\n    this._agentDestinationArmed = new Array();\n    /**\n     * agent current target\n     */\n\n    this._agentDestination = new Array();\n    /**\n     * Observer for crowd updates\n     */\n\n    this._onBeforeAnimationsObserver = null;\n    /**\n     * Fires each time an agent is in reach radius of its destination\n     */\n\n    this.onReachTargetObservable = new Observable();\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function () {\n      _this.update(scene.getEngine().getDeltaTime() * 0.001);\n    });\n  }\n  /**\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n   * You can attach anything to that node. The node position is updated in the scene update tick.\n   * @param pos world position that will be constrained by the navigation mesh\n   * @param parameters agent parameters\n   * @param transform hooked to the agent that will be update by the scene\n   * @returns agent index\n   */\n\n\n  RecastJSCrowd.prototype.addAgent = function (pos, parameters, transform) {\n    var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n\n    this._agentDestinationArmed.push(false);\n\n    this._agentDestination.push(new Vector3(0, 0, 0));\n\n    return agentIndex;\n  };\n  /**\n   * Returns the agent position in world space\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPosition = function (index) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\n   * Returns the agent position result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPositionToRef = function (index, result) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\n   * Returns the agent velocity in world space\n   * @param index agent index returned by addAgent\n   * @returns world space velocity\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocity = function (index) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\n   * Returns the agent velocity result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space velocity\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocityToRef = function (index, result) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPath = function (index) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPathToRef = function (index, result) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\n   * Gets the agent state\n   * @param index agent index returned by addAgent\n   * @returns agent state\n   */\n\n\n  RecastJSCrowd.prototype.getAgentState = function (index) {\n    return this.recastCrowd.getAgentState(index);\n  };\n  /**\n   * returns true if the agent in over an off mesh link connection\n   * @param index agent index returned by addAgent\n   * @returns true if over an off mesh link connection\n   */\n\n\n  RecastJSCrowd.prototype.overOffmeshConnection = function (index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  };\n  /**\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n\n\n  RecastJSCrowd.prototype.agentGoto = function (index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z)); // arm observer\n\n    var item = this.agents.indexOf(index);\n\n    if (item > -1) {\n      this._agentDestinationArmed[item] = true;\n\n      this._agentDestination[item].set(destination.x, destination.y, destination.z);\n    }\n  };\n  /**\n   * Teleport the agent to a new position\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n\n\n  RecastJSCrowd.prototype.agentTeleport = function (index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  };\n  /**\n   * Update agent parameters\n   * @param index agent index returned by addAgent\n   * @param parameters agent parameters\n   */\n\n\n  RecastJSCrowd.prototype.updateAgentParameters = function (index, parameters) {\n    var agentParams = this.recastCrowd.getAgentParameters(index);\n\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  };\n  /**\n   * remove a particular agent previously created\n   * @param index agent index returned by addAgent\n   */\n\n\n  RecastJSCrowd.prototype.removeAgent = function (index) {\n    this.recastCrowd.removeAgent(index);\n    var item = this.agents.indexOf(index);\n\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n      this.reachRadii.splice(item, 1);\n\n      this._agentDestinationArmed.splice(item, 1);\n\n      this._agentDestination.splice(item, 1);\n    }\n  };\n  /**\n   * get the list of all agents attached to this crowd\n   * @returns list of agent indices\n   */\n\n\n  RecastJSCrowd.prototype.getAgents = function () {\n    return this.agents;\n  };\n  /**\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n   * @param deltaTime in seconds\n   */\n\n\n  RecastJSCrowd.prototype.update = function (deltaTime) {\n    // update obstacles\n    this.bjsRECASTPlugin.navMesh.update(); // update crowd\n\n    var timeStep = this.bjsRECASTPlugin.getTimeStep();\n    var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      var iterationCount = Math.floor(deltaTime / timeStep);\n\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n\n      var step = deltaTime / iterationCount;\n\n      for (var i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(step);\n      }\n    } // update transforms\n\n\n    for (var index = 0; index < this.agents.length; index++) {\n      // update transform position\n      var agentIndex = this.agents[index];\n      var agentPosition = this.getAgentPosition(agentIndex);\n      this.transforms[index].position = agentPosition; // check agent reach destination\n\n      if (this._agentDestinationArmed[index]) {\n        var dx = agentPosition.x - this._agentDestination[index].x;\n        var dz = agentPosition.z - this._agentDestination[index].z;\n        var radius = this.reachRadii[index];\n        var groundY = this._agentDestination[index].y - this.reachRadii[index];\n        var ceilingY = this._agentDestination[index].y + this.reachRadii[index];\n        var distanceXZSquared = dx * dx + dz * dz;\n\n        if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n          this.onReachTargetObservable.notifyObservers({\n            agentIndex: agentIndex,\n            destination: this._agentDestination[index]\n          });\n          this._agentDestinationArmed[index] = false;\n        }\n      }\n    }\n  };\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n\n\n  RecastJSCrowd.prototype.setDefaultQueryExtent = function (extent) {\n    var ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  };\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtent = function () {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\n   * Get the next corner points composing the path (max 4 points)\n   * @param index agent index returned by addAgent\n   * @returns array containing world position composing the path\n   */\n\n\n  RecastJSCrowd.prototype.getCorners = function (index) {\n    var pt;\n    var navPath = this.recastCrowd.getPath(index);\n    var pointCount = navPath.getPointCount();\n    var positions = [];\n\n    for (pt = 0; pt < pointCount; pt++) {\n      var p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n\n    return positions;\n  };\n  /**\n   * Release all resources\n   */\n\n\n  RecastJSCrowd.prototype.dispose = function () {\n    this.recastCrowd.destroy();\n\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n\n    this._onBeforeAnimationsObserver = null;\n    this.onReachTargetObservable.clear();\n  };\n\n  return RecastJSCrowd;\n}();\n\nexport { RecastJSCrowd };","map":{"version":3,"mappings":"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","names":["Logger","VertexData","Mesh","Epsilon","Vector3","Matrix","Observable","VertexBuffer","recastInjection","Error","bjsRECAST","isSupported","setTimeStep","_tempVec1","Vec3","_tempVec2","RecastJSPlugin","workerURL","window","Worker","_worker","newTimeStep","_timeStep","newStepCount","_maximumSubStepCount","meshes","parameters","completion","console","warn","navMesh","NavMesh","index","tri","pt","indices","positions","offset","length","mesh","meshIndices","getIndices","meshPositions","getVerticesData","PositionKind","worldMatrices","worldMatrix","computeWorldMatrix","hasThinInstances","thinMatrices","thinInstanceGetWorldMatrices","instanceIndex","tmpMatrix","thinMatrix","multiplyToRef","push","matrixIndex","wm","transformed","Zero","position","FromArrayToRef","TransformCoordinatesToRef","x","y","z","postMessage","onmessage","e","data","rc","rcConfig","cs","ch","borderSize","tileSize","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","build","scene","debugNavMesh","getDebugNavMesh","triangleCount","getTriangleCount","point","getTriangle","getPoint","vertexData","applyToMesh","ret","getClosestPoint","pr","result","set","maxRadius","getRandomPointAround","destination","moveAlong","start","end","navPath","computePath","pointCount","getPointCount","p","maxAgents","maxAgentRadius","crowd","RecastJSCrowd","extent","setDefaultQueryExtent","getDefaultQueryExtent","nDataBytes","BYTES_PER_ELEMENT","dataPtr","_malloc","dataHeap","Uint8Array","HEAPU8","buffer","buf","NavmeshData","dataPointer","byteOffset","size","buildFromNavmeshData","_free","navmeshData","getNavmeshData","arrView","freeNavmeshData","radius","height","addCylinderObstacle","angle","addBoxObstacle","obstacle","removeObstacle","undefined","plugin","Array","bjsRECASTPlugin","recastCrowd","Crowd","getNavMesh","_scene","_onBeforeAnimationsObserver","onBeforeAnimationsObservable","add","_this","update","getEngine","getDeltaTime","pos","transform","agentParams","dtCrowdAgentParams","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","updateFlags","obstacleAvoidanceType","queryFilterType","userData","agentIndex","addAgent","transforms","agents","reachRadii","reachRadius","_agentDestinationArmed","_agentDestination","agentPos","getAgentPosition","agentVel","getAgentVelocity","pathTargetPos","getAgentNextTargetPath","getAgentState","overOffmeshConnection","agentGoto","item","indexOf","agentTeleport","getAgentParameters","setAgentParameters","removeAgent","splice","deltaTime","timeStep","getTimeStep","maxStepCount","getMaximumSubStepCount","iterationCount","Math","floor","step","i","agentPosition","dx","dz","groundY","ceilingY","distanceXZSquared","onReachTargetObservable","notifyObservers","ext","getPath","destroy","remove","clear"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Navigation/Plugins/recastJSPlugin.ts"],"sourcesContent":["import type { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters, IObstacle } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n\r\n    private _tempVec1: any;\r\n    private _tempVec2: any;\r\n\r\n    private _worker: Nullable<Worker> = null;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n\r\n        this._tempVec1 = new this.bjsRECAST.Vec3();\r\n        this._tempVec2 = new this.bjsRECAST.Vec3();\r\n    }\r\n\r\n    /**\r\n     * Set worker URL to be used when generating a new navmesh\r\n     * @param workerURL url string\r\n     * @returns boolean indicating if worker is created\r\n     */\r\n    public setWorkerURL(workerURL: string): boolean {\r\n        if (window && window.Worker) {\r\n            this._worker = new Worker(workerURL);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigation mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     * @param completion callback when data is available from the worker. Not used without a worker\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters, completion?: (navmeshData: Uint8Array) => void): void {\r\n        if (this._worker && !completion) {\r\n            console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\r\n        } else if (!this._worker && completion) {\r\n            console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\r\n        }\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        let index: number;\r\n        let tri: number;\r\n        let pt: number;\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        let offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                const mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const worldMatrices = [];\r\n                const worldMatrix = mesh.computeWorldMatrix(true);\r\n\r\n                if (mesh.hasThinInstances) {\r\n                    const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                    for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\r\n                        const tmpMatrix = new Matrix();\r\n                        const thinMatrix = thinMatrices[instanceIndex];\r\n                        thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\r\n                        worldMatrices.push(tmpMatrix);\r\n                    }\r\n                } else {\r\n                    worldMatrices.push(worldMatrix);\r\n                }\r\n\r\n                for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\r\n                    const wm = worldMatrices[matrixIndex];\r\n                    for (tri = 0; tri < meshIndices.length; tri++) {\r\n                        indices.push(meshIndices[tri] + offset);\r\n                    }\r\n\r\n                    const transformed = Vector3.Zero();\r\n                    const position = Vector3.Zero();\r\n                    for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                        Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                        Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                        positions.push(transformed.x, transformed.y, transformed.z);\r\n                    }\r\n\r\n                    offset += meshPositions.length / 3;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._worker && completion) {\r\n            // spawn worker and send message\r\n            this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\r\n            this._worker.onmessage = function (e) {\r\n                completion(e.data);\r\n            };\r\n        } else {\r\n            // blocking calls\r\n            const rc = new this.bjsRECAST.rcConfig();\r\n            rc.cs = parameters.cs;\r\n            rc.ch = parameters.ch;\r\n            rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\r\n            rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\r\n            rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n            rc.walkableHeight = parameters.walkableHeight;\r\n            rc.walkableClimb = parameters.walkableClimb;\r\n            rc.walkableRadius = parameters.walkableRadius;\r\n            rc.maxEdgeLen = parameters.maxEdgeLen;\r\n            rc.maxSimplificationError = parameters.maxSimplificationError;\r\n            rc.minRegionArea = parameters.minRegionArea;\r\n            rc.mergeRegionArea = parameters.mergeRegionArea;\r\n            rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n            rc.detailSampleDist = parameters.detailSampleDist;\r\n            rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n            this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        let tri: number;\r\n        let pt: number;\r\n        const debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        const triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++) {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++) {\r\n            for (pt = 0; pt < 3; pt++) {\r\n                const point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        const mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[] {\r\n        let pt: number;\r\n        this._tempVec1.x = start.x;\r\n        this._tempVec1.y = start.y;\r\n        this._tempVec1.z = start.z;\r\n        this._tempVec2.x = end.x;\r\n        this._tempVec2.y = end.y;\r\n        this._tempVec2.z = end.z;\r\n        const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\r\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        this._tempVec1.x = extent.x;\r\n        this._tempVec1.y = extent.y;\r\n        this._tempVec1.z = extent.z;\r\n        this.navMesh.setDefaultQueryExtent(this._tempVec1);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void {\r\n        const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        const dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        const buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array {\r\n        const navmeshData = this.navMesh.getNavmeshData();\r\n        const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        const ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {}\r\n\r\n    /**\r\n     * Creates a cylinder obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addCylinderObstacle(position: Vector3, radius: number, height: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\r\n    }\r\n\r\n    /**\r\n     * Creates an oriented box obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param extent box size\r\n     * @param angle angle in radians of the box orientation on Y axis\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addBoxObstacle(position: Vector3, extent: Vector3, angle: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = extent.x;\r\n        this._tempVec2.y = extent.y;\r\n        this._tempVec2.z = extent.z;\r\n        return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\r\n    }\r\n\r\n    /**\r\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\r\n     * @param obstacle obstacle to remove from the navigation\r\n     */\r\n    removeObstacle(obstacle: IObstacle): void {\r\n        this.navMesh.removeObstacle(obstacle);\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * agents reach radius\r\n     */\r\n    public reachRadii: number[] = new Array<number>();\r\n    /**\r\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\r\n     */\r\n    private _agentDestinationArmed: boolean[] = new Array<boolean>();\r\n    /**\r\n     * agent current target\r\n     */\r\n    private _agentDestination: Vector3[] = new Array<Vector3>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Fires each time an agent is in reach radius of its destination\r\n     */\r\n    public onReachTargetObservable = new Observable<{ agentIndex: number; destination: Vector3 }>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number {\r\n        const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\r\n        this._agentDestinationArmed.push(false);\r\n        this._agentDestination.push(new Vector3(0, 0, 0));\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n\r\n        // arm observer\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this._agentDestinationArmed[item] = true;\r\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        const agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n            this.reachRadii.splice(item, 1);\r\n            this._agentDestinationArmed.splice(item, 1);\r\n            this._agentDestination.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update obstacles\r\n        this.bjsRECASTPlugin.navMesh.update();\r\n        // update crowd\r\n        const timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            let iterationCount = Math.floor(deltaTime / timeStep);\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n\r\n            const step = deltaTime / iterationCount;\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(step);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            // update transform position\r\n            const agentIndex = this.agents[index];\r\n            const agentPosition = this.getAgentPosition(agentIndex);\r\n            this.transforms[index].position = agentPosition;\r\n            // check agent reach destination\r\n            if (this._agentDestinationArmed[index]) {\r\n                const dx = agentPosition.x - this._agentDestination[index].x;\r\n                const dz = agentPosition.z - this._agentDestination[index].z;\r\n                const radius = this.reachRadii[index];\r\n                const groundY = this._agentDestination[index].y - this.reachRadii[index];\r\n                const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\r\n                const distanceXZSquared = dx * dx + dz * dz;\r\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\r\n                    this.onReachTargetObservable.notifyObservers({ agentIndex: agentIndex, destination: this._agentDestination[index] });\r\n                    this._agentDestinationArmed[index] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the next corner points composing the path (max 4 points)\r\n     * @param index agent index returned by addAgent\r\n     * @returns array containing world position composing the path\r\n     */\r\n    getCorners(index: number): Vector3[] {\r\n        let pt: number;\r\n        const navPath = this.recastCrowd.getPath(index);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n        this.onReachTargetObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}