{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { Texture } from \"../texture.js\";\nimport { DynamicTexture } from \"../dynamicTexture.js\";\nimport { Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../Maths/math.color.js\";\nimport { TexturePackerFrame } from \"./frame.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * This is a support class that generates a series of packed texture sets.\n * @see https://doc.babylonjs.com/babylon101/materials\n */\n\nvar TexturePacker =\n/** @class */\nfunction () {\n  /**\n   * Initializes a texture package series from an array of meshes or a single mesh.\n   * @param name The name of the package\n   * @param meshes The target meshes to compose the package from\n   * @param options The arguments that texture packer should follow while building.\n   * @param scene The scene which the textures are scoped to.\n   * @returns TexturePacker\n   */\n  function TexturePacker(name, meshes, options, scene) {\n    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n\n    this.options = options;\n    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [\"ambientTexture\", \"bumpTexture\", \"diffuseTexture\", \"emissiveTexture\", \"lightmapTexture\", \"opacityTexture\", \"reflectionTexture\", \"refractionTexture\", \"specularTexture\"];\n    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n    }\n\n    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n    this._expecting = 0;\n    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : \"black\";\n    }\n\n    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio); //Make it an even padding Number.\n\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n\n    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n    }\n\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\n   * Starts the package process\n   * @param resolve The promises resolution function\n   * @returns TexturePacker\n   */\n\n\n  TexturePacker.prototype._createFrames = function (resolve) {\n    var _this = this;\n\n    var dtSize = this._calculateSize();\n\n    var dtUnits = new Vector2(1, 1).divide(dtSize);\n    var doneCount = 0;\n    var expecting = this._expecting;\n    var meshLength = this.meshes.length;\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n      var dt = new DynamicTexture(this.name + \".TexturePack.\" + setName + \"Set\", {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true, //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      var dtx = dt.getContext();\n      dtx.fillStyle = \"rgba(0,0,0,0)\";\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n\n    var baseSize = this.options.frameSize || 256;\n    var padding = this._paddingValue;\n    var tcs = baseSize + 2 * padding;\n\n    var done = function done() {\n      _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);\n    }; //Update the Textures\n\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var mat = m.material;\n\n      var _loop_1 = function _loop_1(j) {\n        var tempTexture = new DynamicTexture(\"temp\", tcs, this_1.scene, true);\n        var tcx = tempTexture.getContext();\n\n        var offset = this_1._getFrameOffset(i);\n\n        var updateDt = function updateDt() {\n          doneCount++;\n          tempTexture.update(false);\n          var iDat = tcx.getImageData(0, 0, tcs, tcs); //Update Set\n\n          var dt = _this.sets[setName];\n          var dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n\n        var setName = sKeys[j] || \"_blank\";\n\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = \"rgba(0,0,0,0)\";\n\n          if (this_1.options.fillBlanks) {\n            tcx.fillStyle = this_1.options.customFillColor;\n          }\n\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          var setTexture = mat[setName];\n          var img_1 = new Image();\n\n          if (setTexture instanceof DynamicTexture) {\n            img_1.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img_1.src = setTexture.url;\n          }\n\n          Tools.SetCorsBehavior(img_1.src, img_1);\n\n          img_1.onload = function () {\n            tcx.fillStyle = \"rgba(0,0,0,0)\";\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n\n            switch (_this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (var i_1 = 0; i_1 < 9; i_1++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[i_1], padding + baseSize * cellOffsets[i_1 + 1] - tcs, baseSize, baseSize);\n                }\n\n                break;\n              //Extend Mode\n\n              case 1:\n                for (var i_2 = 0; i_2 < padding; i_2++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding * 2 - i_2, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, padding * 2 - i_2 - tcs, baseSize, baseSize);\n                }\n\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n\n              case 2:\n                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      };\n\n      var this_1 = this; //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n\n      for (var j = 0; j < sKeys.length; j++) {\n        _loop_1(j);\n      }\n    }\n  };\n  /**\n   * Calculates the Size of the Channel Sets\n   * @returns Vector2\n   */\n\n\n  TexturePacker.prototype._calculateSize = function () {\n    var meshLength = this.meshes.length || 0;\n    var baseSize = this.options.frameSize || 0;\n    var padding = this._paddingValue || 0;\n\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        }\n\n      case 1:\n        {\n          //POWER2\n          var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          var size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n          return new Vector2(size, size);\n        }\n\n      case 2:\n        {\n          //COLNUM\n          var cols = this.options.colnum || 1;\n          var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        }\n    }\n\n    return Vector2.Zero();\n  };\n  /**\n   * Calculates the UV data for the frames.\n   * @param baseSize the base frameSize\n   * @param padding the base frame padding\n   * @param dtSize size of the Dynamic Texture for that channel\n   * @param dtUnits is 1/dtSize\n   * @param update flag to update the input meshes\n   */\n\n\n  TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {\n    var meshLength = this.meshes.length;\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      var pOffset = dtUnits.clone().scale(padding);\n\n      var frameOffset = this._getFrameOffset(i);\n\n      var offset = frameOffset.add(pOffset);\n      var frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame); //Update Output UVs\n\n      if (update) {\n        this._updateMeshUV(m, i);\n\n        this._updateTextureReferences(m);\n      }\n    }\n  };\n  /**\n   * Calculates the frames Offset.\n   * @param index of the frame\n   * @returns Vector2\n   */\n\n\n  TexturePacker.prototype._getFrameOffset = function (index) {\n    var meshLength = this.meshes.length;\n    var uvStep, yStep, xStep;\n\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          uvStep = 1 / meshLength;\n          return new Vector2(index * uvStep, 0);\n        }\n\n      case 1:\n        {\n          //POWER2\n          var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          yStep = Math.floor(index / sqrtCount);\n          xStep = index - yStep * sqrtCount;\n          uvStep = 1 / sqrtCount;\n          return new Vector2(xStep * uvStep, yStep * uvStep);\n        }\n\n      case 2:\n        {\n          //COLNUM\n          var cols = this.options.colnum || 1;\n          var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          xStep = Math.floor(index / rowCnt);\n          yStep = index - xStep * rowCnt;\n          uvStep = new Vector2(1 / cols, 1 / rowCnt);\n          return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        }\n    }\n\n    return Vector2.Zero();\n  };\n  /**\n   * Updates a Mesh to the frame data\n   * @param mesh that is the target\n   * @param frameID or the frame index\n   */\n\n\n  TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {\n    var frame = this.frames[frameID];\n    var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    var uvOut = [];\n    var toCount = 0;\n\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n\n    for (var i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  };\n  /**\n   * Updates a Meshes materials to use the texture packer channels\n   * @param m is the mesh to target\n   * @param force all channels on the packer to be set.\n   */\n\n\n  TexturePacker.prototype._updateTextureReferences = function (m, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var mat = m.material;\n    var sKeys = Object.keys(this.sets);\n\n    var _dispose = function _dispose(_t) {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n\n        mat[setName] = this.sets[setName];\n      }\n    }\n  };\n  /**\n   * Public method to set a Mesh to a frame\n   * @param m that is the target\n   * @param frameID or the frame index\n   * @param updateMaterial trigger for if the Meshes attached Material be updated?\n   */\n\n\n  TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {\n    if (updateMaterial === void 0) {\n      updateMaterial = false;\n    }\n\n    this._updateMeshUV(m, frameID);\n\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  };\n  /**\n   * Starts the async promise to compile the texture packer.\n   * @returns Promise<void>\n   */\n\n\n  TexturePacker.prototype.processAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n\n        var done_1 = 0;\n\n        var doneCheck_1 = function doneCheck_1(mat) {\n          done_1++; //Check Status of all Textures on all meshes, till they are ready.\n\n          if (_this.options.map) {\n            for (var j = 0; j < _this.options.map.length; j++) {\n              var index = _this.options.map[j];\n              var t = mat[index];\n\n              if (t !== null) {\n                if (!_this.sets[_this.options.map[j]]) {\n                  _this.sets[_this.options.map[j]] = true;\n                }\n\n                _this._expecting++;\n              }\n            }\n\n            if (done_1 === _this.meshes.length) {\n              _this._createFrames(resolve);\n            }\n          }\n        };\n\n        var _loop_2 = function _loop_2(i) {\n          var mesh = _this.meshes[i];\n          var material = mesh.material;\n\n          if (!material) {\n            done_1++;\n\n            if (done_1 === _this.meshes.length) {\n              return {\n                value: _this._createFrames(resolve)\n              };\n            }\n\n            return \"continue\";\n          }\n\n          material.forceCompilationAsync(mesh).then(function () {\n            doneCheck_1(material);\n          });\n        };\n\n        for (var i = 0; i < _this.meshes.length; i++) {\n          var state_1 = _loop_2(i);\n\n          if (_typeof(state_1) === \"object\") return state_1.value;\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\n   * Disposes all textures associated with this packer\n   */\n\n\n  TexturePacker.prototype.dispose = function () {\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  };\n  /**\n   * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\n   * @param imageType is the image type to use.\n   * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\n   */\n\n\n  TexturePacker.prototype.download = function (imageType, quality) {\n    var _this = this;\n\n    if (imageType === void 0) {\n      imageType = \"png\";\n    }\n\n    if (quality === void 0) {\n      quality = 1;\n    }\n\n    setTimeout(function () {\n      var pack = {\n        name: _this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      var sKeys = Object.keys(_this.sets);\n      var oKeys = Object.keys(_this.options);\n\n      try {\n        for (var i = 0; i < sKeys.length; i++) {\n          var channel = sKeys[i];\n          var dt = _this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\n        }\n\n        for (var i = 0; i < oKeys.length; i++) {\n          var opt = oKeys[i];\n          pack.options[opt] = _this.options[opt];\n        }\n\n        for (var i = 0; i < _this.frames.length; i++) {\n          var _f = _this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n\n      var data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n\n      var _a = document.createElement(\"a\");\n\n      _a.setAttribute(\"href\", data);\n\n      _a.setAttribute(\"download\", _this.name + \"_texurePackage.json\");\n\n      document.body.appendChild(_a);\n\n      _a.click();\n\n      _a.remove();\n    }, 0);\n  };\n  /**\n   * Public method to load a texturePacker JSON file.\n   * @param data of the JSON file in string format.\n   */\n\n\n  TexturePacker.prototype.updateFromJSON = function (data) {\n    try {\n      var parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n\n      var _options = Object.keys(parsedData.options);\n\n      for (var i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n\n      for (var i = 0; i < parsedData.frames.length; i += 4) {\n        var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n\n      var channels = Object.keys(parsedData.sets);\n\n      for (var i = 0; i < channels.length; i++) {\n        var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  };\n  /** Packer Layout Constant 0 */\n\n\n  TexturePacker.LAYOUT_STRIP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.LAYOUT_POWER2 = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.LAYOUT_COLNUM = 2;\n  /** Packer Layout Constant 0 */\n\n  TexturePacker.SUBUV_WRAP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.SUBUV_EXTEND = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.SUBUV_COLOR = 2;\n  return TexturePacker;\n}();\n\nexport { TexturePacker };","map":{"version":3,"mappings":"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","names":["Engine","VertexBuffer","Texture","DynamicTexture","Vector2","Color3","Color4","TexturePackerFrame","Logger","Tools","name","meshes","options","scene","map","_b","uvsIn","_c","UVKind","uvsOut","_d","layout","_e","TexturePacker","LAYOUT_STRIP","LAYOUT_COLNUM","colnum","_g","updateInputMeshes","_h","disposeSources","_j","_expecting","fillBlanks","_k","customFillColor","_l","frameSize","_m","paddingRatio","_o","_paddingValue","Math","ceil","paddingMode","_p","SUBUV_WRAP","SUBUV_COLOR","paddingColor","_q","sets","frames","resolve","dtSize","_calculateSize","dtUnits","divide","doneCount","expecting","meshLength","length","sKeys","Object","keys","i","setName","dt","width","x","height","y","TRILINEAR_SAMPLINGMODE","TEXTUREFORMAT_RGBA","dtx","getContext","fillStyle","fillRect","update","baseSize","padding","tcs","done","_this","_calculateMeshUVFrames","m","mat","material","j","tempTexture","this_1","tcx","offset","_getFrameOffset","updateDt","iDat","getImageData","putImageData","dispose","setTexture","img_1","Image","src","canvas","toDataURL","url","SetCorsBehavior","onload","setTransform","cellOffsets","i_1","drawImage","i_2","Black","toHexString","clearRect","sqrtCount","max","sqrt","size","cols","rowCnt","Zero","scale","pOffset","clone","frameOffset","add","frame","push","_updateMeshUV","_updateTextureReferences","index","uvStep","yStep","xStep","floor","mesh","frameID","uvIn","getVerticesData","uvOut","toCount","setVerticesData","force","_dispose","_t","updateMaterial","Promise","reject","done_1","doneCheck_1","t","_createFrames","forceCompilationAsync","then","e","channel","imageType","quality","setTimeout","pack","oKeys","opt","_f","err","Warn","data","encodeURIComponent","JSON","stringify","_a","document","createElement","setAttribute","body","appendChild","click","remove","parsedData","parse","_options","channels"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Packer/packer.ts"],"sourcesContent":["import { Engine } from \"../../../Engines/engine\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Material } from \"../../material\";\r\nimport { Texture } from \"../texture\";\r\nimport { DynamicTexture } from \"../dynamicTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\r\nimport { TexturePackerFrame } from \"./frame\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\n/**\r\n * Defines the basic options interface of a TexturePacker\r\n */\r\nexport interface ITexturePackerOptions {\r\n    /**\r\n     * Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material\r\n     */\r\n    map?: string[];\r\n\r\n    /**\r\n     * the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind\r\n     */\r\n    uvsIn?: string;\r\n\r\n    /**\r\n     * the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind\r\n     */\r\n    uvsOut?: string;\r\n\r\n    /**\r\n     * number representing the layout style. Defaults to LAYOUT_STRIP\r\n     */\r\n    layout?: number;\r\n\r\n    /**\r\n     * number of columns if using custom column count layout(2).  This defaults to 4.\r\n     */\r\n    colnum?: number;\r\n\r\n    /**\r\n     * flag to update the input meshes to the new packed texture after compilation. Defaults to true.\r\n     */\r\n    updateInputMeshes?: boolean;\r\n\r\n    /**\r\n     * boolean flag to dispose all the source textures.  Defaults to true.\r\n     */\r\n    disposeSources?: boolean;\r\n\r\n    /**\r\n     * Fills the blank cells in a set to the customFillColor.  Defaults to true.\r\n     */\r\n    fillBlanks?: boolean;\r\n\r\n    /**\r\n     * string value representing the context fill style color.  Defaults to 'black'.\r\n     */\r\n    customFillColor?: string;\r\n\r\n    /**\r\n     * Width and Height Value of each Frame in the TexturePacker Sets\r\n     */\r\n    frameSize?: number;\r\n\r\n    /**\r\n     * Ratio of the value to add padding wise to each cell.  Defaults to 0.0115\r\n     */\r\n    paddingRatio?: number;\r\n\r\n    /**\r\n     * Number that declares the fill method for the padding gutter.\r\n     */\r\n    paddingMode?: number;\r\n\r\n    /**\r\n     * If in SUBUV_COLOR padding mode what color to use.\r\n     */\r\n    paddingColor?: Color3 | Color4;\r\n}\r\n\r\n/**\r\n * Defines the basic interface of a TexturePacker JSON File\r\n */\r\nexport interface ITexturePackerJSON {\r\n    /**\r\n     * The frame ID\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The base64 channel data\r\n     */\r\n    sets: any;\r\n\r\n    /**\r\n     * The options of the Packer\r\n     */\r\n    options: ITexturePackerOptions;\r\n\r\n    /**\r\n     * The frame data of the Packer\r\n     */\r\n    frames: Array<number>;\r\n}\r\n\r\n/**\r\n * This is a support class that generates a series of packed texture sets.\r\n * @see https://doc.babylonjs.com/babylon101/materials\r\n */\r\nexport class TexturePacker {\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly LAYOUT_STRIP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly LAYOUT_POWER2 = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly LAYOUT_COLNUM = 2;\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly SUBUV_WRAP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly SUBUV_EXTEND = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly SUBUV_COLOR = 2;\r\n\r\n    /** The Name of the Texture Package */\r\n    public name: string;\r\n\r\n    /** The scene scope of the TexturePacker */\r\n    public scene: Scene;\r\n\r\n    /** The Meshes to target */\r\n    public meshes: AbstractMesh[];\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ITexturePackerOptions;\r\n\r\n    /** The promise that is started upon initialization */\r\n    public promise: Nullable<Promise<TexturePacker | string>>;\r\n\r\n    /** The Container object for the channel sets that are generated */\r\n    public sets: object;\r\n\r\n    /** The Container array for the frames that are generated */\r\n    public frames: TexturePackerFrame[];\r\n\r\n    /** The expected number of textures the system is parsing. */\r\n    private _expecting: number;\r\n\r\n    /** The padding value from Math.ceil(frameSize * paddingRatio) */\r\n    private _paddingValue: number;\r\n\r\n    /**\r\n     * Initializes a texture package series from an array of meshes or a single mesh.\r\n     * @param name The name of the package\r\n     * @param meshes The target meshes to compose the package from\r\n     * @param options The arguments that texture packer should follow while building.\r\n     * @param scene The scene which the textures are scoped to.\r\n     * @returns TexturePacker\r\n     */\r\n    constructor(name: string, meshes: AbstractMesh[], options: ITexturePackerOptions, scene: Scene) {\r\n        this.name = name;\r\n        this.meshes = meshes;\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        this.options.map = this.options.map ?? [\r\n            \"ambientTexture\",\r\n            \"bumpTexture\",\r\n            \"diffuseTexture\",\r\n            \"emissiveTexture\",\r\n            \"lightmapTexture\",\r\n            \"opacityTexture\",\r\n            \"reflectionTexture\",\r\n            \"refractionTexture\",\r\n            \"specularTexture\",\r\n        ];\r\n\r\n        this.options.uvsIn = this.options.uvsIn ?? VertexBuffer.UVKind;\r\n        this.options.uvsOut = this.options.uvsOut ?? VertexBuffer.UVKind;\r\n        this.options.layout = this.options.layout ?? TexturePacker.LAYOUT_STRIP;\r\n\r\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\r\n            this.options.colnum = this.options.colnum ?? 8;\r\n        }\r\n\r\n        this.options.updateInputMeshes = this.options.updateInputMeshes ?? true;\r\n        this.options.disposeSources = this.options.disposeSources ?? true;\r\n        this._expecting = 0;\r\n\r\n        this.options.fillBlanks = this.options.fillBlanks ?? true;\r\n\r\n        if (this.options.fillBlanks === true) {\r\n            this.options.customFillColor = this.options.customFillColor ?? \"black\";\r\n        }\r\n\r\n        this.options.frameSize = this.options.frameSize ?? 256;\r\n        this.options.paddingRatio = this.options.paddingRatio ?? 0.0115;\r\n\r\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\r\n\r\n        //Make it an even padding Number.\r\n        if (this._paddingValue % 2 !== 0) {\r\n            this._paddingValue++;\r\n        }\r\n\r\n        this.options.paddingMode = this.options.paddingMode ?? TexturePacker.SUBUV_WRAP;\r\n\r\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\r\n            this.options.paddingColor = this.options.paddingColor ?? new Color4(0, 0, 0, 1.0);\r\n        }\r\n\r\n        this.sets = {};\r\n        this.frames = [];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Starts the package process\r\n     * @param resolve The promises resolution function\r\n     * @returns TexturePacker\r\n     */\r\n    private _createFrames(resolve: () => void) {\r\n        const dtSize = this._calculateSize();\r\n        const dtUnits = new Vector2(1, 1).divide(dtSize);\r\n        let doneCount = 0;\r\n        const expecting = this._expecting;\r\n        const meshLength = this.meshes.length;\r\n\r\n        const sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const setName = sKeys[i];\r\n\r\n            const dt = new DynamicTexture(\r\n                this.name + \".TexturePack.\" + setName + \"Set\",\r\n                { width: dtSize.x, height: dtSize.y },\r\n                this.scene,\r\n                true, //Generate Mips\r\n                Texture.TRILINEAR_SAMPLINGMODE,\r\n                Engine.TEXTUREFORMAT_RGBA\r\n            );\r\n\r\n            const dtx = dt.getContext();\r\n            dtx.fillStyle = \"rgba(0,0,0,0)\";\r\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y);\r\n            dt.update(false);\r\n            (this.sets as any)[setName] = dt;\r\n        }\r\n\r\n        const baseSize = this.options.frameSize || 256;\r\n        const padding = this._paddingValue;\r\n        const tcs = baseSize + 2 * padding;\r\n\r\n        const done = () => {\r\n            this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\r\n        };\r\n\r\n        //Update the Textures\r\n        for (let i = 0; i < meshLength; i++) {\r\n            const m = this.meshes[i];\r\n            const mat = m.material;\r\n\r\n            //Check if the material has the texture\r\n            //Create a temporary canvas the same size as 1 frame\r\n            //Then apply the texture to the center and the 8 offsets\r\n            //Copy the Context and place in the correct frame on the DT\r\n\r\n            for (let j = 0; j < sKeys.length; j++) {\r\n                const tempTexture = new DynamicTexture(\"temp\", tcs, this.scene, true);\r\n                const tcx = tempTexture.getContext();\r\n                const offset = this._getFrameOffset(i);\r\n\r\n                const updateDt = () => {\r\n                    doneCount++;\r\n                    tempTexture.update(false);\r\n                    const iDat = tcx.getImageData(0, 0, tcs, tcs);\r\n\r\n                    //Update Set\r\n                    const dt = (this.sets as any)[setName];\r\n                    const dtx = dt.getContext();\r\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\r\n                    tempTexture.dispose();\r\n                    dt.update(false);\r\n                    if (doneCount == expecting) {\r\n                        done();\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                };\r\n\r\n                const setName = sKeys[j] || \"_blank\";\r\n                if (!mat || (mat as any)[setName] === null) {\r\n                    tcx.fillStyle = \"rgba(0,0,0,0)\";\r\n\r\n                    if (this.options.fillBlanks) {\r\n                        tcx.fillStyle = this.options.customFillColor as string;\r\n                    }\r\n\r\n                    tcx.fillRect(0, 0, tcs, tcs);\r\n\r\n                    updateDt();\r\n                } else {\r\n                    const setTexture = (mat as any)[setName];\r\n                    const img = new Image();\r\n\r\n                    if (setTexture instanceof DynamicTexture) {\r\n                        img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\r\n                    } else {\r\n                        img.src = setTexture!.url;\r\n                    }\r\n                    Tools.SetCorsBehavior(img.src, img);\r\n\r\n                    img.onload = () => {\r\n                        tcx.fillStyle = \"rgba(0,0,0,0)\";\r\n                        tcx.fillRect(0, 0, tcs, tcs);\r\n                        tempTexture.update(false);\r\n\r\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\r\n                        const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\r\n\r\n                        switch (this.options.paddingMode) {\r\n                            //Wrap Mode\r\n                            case 0:\r\n                                for (let i = 0; i < 9; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding + baseSize * cellOffsets[i],\r\n                                        padding + baseSize * cellOffsets[i + 1] - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n                                break;\r\n                            //Extend Mode\r\n                            case 1:\r\n                                for (let i = 0; i < padding; i++) {\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, i + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i, padding - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, i - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i - tcs, baseSize, baseSize);\r\n                                }\r\n\r\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\r\n\r\n                                break;\r\n                            //Color Mode\r\n                            case 2:\r\n                                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\r\n                                tcx.fillRect(0, 0, tcs, -tcs);\r\n                                tcx.clearRect(padding, padding, baseSize, baseSize);\r\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\r\n\r\n                                break;\r\n                        }\r\n\r\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n                        updateDt();\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the Size of the Channel Sets\r\n     * @returns Vector2\r\n     */\r\n    private _calculateSize(): Vector2 {\r\n        const meshLength: number = this.meshes.length || 0;\r\n        const baseSize: number = this.options.frameSize || 0;\r\n        const padding: number = this._paddingValue || 0;\r\n\r\n        switch (this.options.layout) {\r\n            case 0: {\r\n                //STRIP_LAYOUT\r\n                return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\r\n            }\r\n            case 1: {\r\n                //POWER2\r\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                const size = baseSize * sqrtCount + 2 * padding * sqrtCount;\r\n                return new Vector2(size, size);\r\n            }\r\n            case 2: {\r\n                //COLNUM\r\n                const cols = this.options.colnum || 1;\r\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\r\n            }\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Calculates the UV data for the frames.\r\n     * @param baseSize the base frameSize\r\n     * @param padding the base frame padding\r\n     * @param dtSize size of the Dynamic Texture for that channel\r\n     * @param dtUnits is 1/dtSize\r\n     * @param update flag to update the input meshes\r\n     */\r\n    private _calculateMeshUVFrames(baseSize: number, padding: number, dtSize: Vector2, dtUnits: Vector2, update: boolean) {\r\n        const meshLength = this.meshes.length;\r\n\r\n        for (let i = 0; i < meshLength; i++) {\r\n            const m = this.meshes[i];\r\n\r\n            const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\r\n\r\n            const pOffset: Vector2 = dtUnits.clone().scale(padding);\r\n            const frameOffset: Vector2 = this._getFrameOffset(i);\r\n            const offset: Vector2 = frameOffset.add(pOffset);\r\n\r\n            const frame: TexturePackerFrame = new TexturePackerFrame(i, scale, offset);\r\n\r\n            this.frames.push(frame);\r\n\r\n            //Update Output UVs\r\n            if (update) {\r\n                this._updateMeshUV(m, i);\r\n                this._updateTextureReferences(m);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the frames Offset.\r\n     * @param index of the frame\r\n     * @returns Vector2\r\n     */\r\n    private _getFrameOffset(index: number): Vector2 {\r\n        const meshLength = this.meshes.length;\r\n        let uvStep, yStep, xStep;\r\n\r\n        switch (this.options.layout) {\r\n            case 0: {\r\n                //STRIP_LAYOUT\r\n                uvStep = 1 / meshLength;\r\n                return new Vector2(index * uvStep, 0);\r\n            }\r\n            case 1: {\r\n                //POWER2\r\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                yStep = Math.floor(index / sqrtCount);\r\n                xStep = index - yStep * sqrtCount;\r\n                uvStep = 1 / sqrtCount;\r\n                return new Vector2(xStep * uvStep, yStep * uvStep);\r\n            }\r\n            case 2: {\r\n                //COLNUM\r\n                const cols = this.options.colnum || 1;\r\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                xStep = Math.floor(index / rowCnt);\r\n                yStep = index - xStep * rowCnt;\r\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\r\n                return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\r\n            }\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Updates a Mesh to the frame data\r\n     * @param mesh that is the target\r\n     * @param frameID or the frame index\r\n     */\r\n    private _updateMeshUV(mesh: AbstractMesh, frameID: number): void {\r\n        const frame: TexturePackerFrame = (this.frames as any)[frameID];\r\n        const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\r\n        const uvOut = [];\r\n        let toCount = 0;\r\n\r\n        if (uvIn!.length) {\r\n            toCount = uvIn!.length || 0;\r\n        }\r\n\r\n        for (let i = 0; i < toCount; i += 2) {\r\n            uvOut.push((uvIn as any)[i] * frame.scale.x + frame.offset.x, (uvIn as any)[i + 1] * frame.scale.y + frame.offset.y);\r\n        }\r\n\r\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\r\n    }\r\n\r\n    /**\r\n     * Updates a Meshes materials to use the texture packer channels\r\n     * @param m is the mesh to target\r\n     * @param force all channels on the packer to be set.\r\n     */\r\n    private _updateTextureReferences(m: AbstractMesh, force: boolean = false): void {\r\n        const mat = m.material;\r\n        const sKeys = Object.keys(this.sets);\r\n\r\n        const _dispose = (_t: any) => {\r\n            if (_t.dispose) {\r\n                _t.dispose();\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const setName = sKeys[i];\r\n            if (!force) {\r\n                if (!mat) {\r\n                    return;\r\n                }\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                    (mat as any)[setName] = (this.sets as any)[setName];\r\n                }\r\n            } else {\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                }\r\n                (mat as any)[setName] = (this.sets as any)[setName];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Public method to set a Mesh to a frame\r\n     * @param m that is the target\r\n     * @param frameID or the frame index\r\n     * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n     */\r\n    public setMeshToFrame(m: AbstractMesh, frameID: number, updateMaterial: boolean = false): void {\r\n        this._updateMeshUV(m, frameID);\r\n        if (updateMaterial) {\r\n            this._updateTextureReferences(m, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the async promise to compile the texture packer.\r\n     * @returns Promise<void>\r\n     */\r\n    public processAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                if (this.meshes.length === 0) {\r\n                    //Must be a JSON load!\r\n                    resolve();\r\n                    return;\r\n                }\r\n                let done = 0;\r\n                const doneCheck = (mat: Material) => {\r\n                    done++;\r\n                    //Check Status of all Textures on all meshes, till they are ready.\r\n                    if (this.options.map) {\r\n                        for (let j = 0; j < this.options.map.length; j++) {\r\n                            const index: string = this.options.map[j];\r\n                            const t: Texture | DynamicTexture = (mat as any)[index];\r\n\r\n                            if (t !== null) {\r\n                                if (!(this.sets as any)[this.options.map[j]]) {\r\n                                    (this.sets as any)[this.options.map[j]] = true;\r\n                                }\r\n\r\n                                this._expecting++;\r\n                            }\r\n                        }\r\n\r\n                        if (done === this.meshes.length) {\r\n                            this._createFrames(resolve);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                for (let i = 0; i < this.meshes.length; i++) {\r\n                    const mesh = this.meshes[i];\r\n                    const material: Nullable<Material> = mesh.material;\r\n\r\n                    if (!material) {\r\n                        done++;\r\n                        if (done === this.meshes.length) {\r\n                            return this._createFrames(resolve);\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    material.forceCompilationAsync(mesh).then(() => {\r\n                        doneCheck(material as Material);\r\n                    });\r\n                }\r\n            } catch (e) {\r\n                return reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes all textures associated with this packer\r\n     */\r\n    public dispose(): void {\r\n        const sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const channel = sKeys[i];\r\n            (this.sets as any)[channel].dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n     * @param imageType is the image type to use.\r\n     * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n     */\r\n    public download(imageType: string = \"png\", quality: number = 1): void {\r\n        setTimeout(() => {\r\n            const pack = {\r\n                name: this.name,\r\n                sets: {},\r\n                options: {},\r\n                frames: [],\r\n            };\r\n\r\n            const sKeys = Object.keys(this.sets);\r\n            const oKeys = Object.keys(this.options);\r\n            try {\r\n                for (let i = 0; i < sKeys.length; i++) {\r\n                    const channel: string = sKeys[i];\r\n                    const dt = (this.sets as any)[channel];\r\n                    (pack.sets as any)[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\r\n                }\r\n                for (let i = 0; i < oKeys.length; i++) {\r\n                    const opt: string = oKeys[i];\r\n                    (pack.options as any)[opt] = (this.options as any)[opt];\r\n                }\r\n                for (let i = 0; i < this.frames.length; i++) {\r\n                    const _f = this.frames[i];\r\n                    (pack.frames as Array<number>).push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\r\n                }\r\n            } catch (err) {\r\n                Logger.Warn(\"Unable to download: \" + err);\r\n                return;\r\n            }\r\n\r\n            const data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\r\n            const _a = document.createElement(\"a\");\r\n            _a.setAttribute(\"href\", data);\r\n            _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\r\n            document.body.appendChild(_a);\r\n            _a.click();\r\n            _a.remove();\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n     * Public method to load a texturePacker JSON file.\r\n     * @param data of the JSON file in string format.\r\n     */\r\n    public updateFromJSON(data: string): void {\r\n        try {\r\n            const parsedData: ITexturePackerJSON = JSON.parse(data);\r\n            this.name = parsedData.name;\r\n            const _options = Object.keys(parsedData.options);\r\n\r\n            for (let i = 0; i < _options.length; i++) {\r\n                (this.options as any)[_options[i]] = (parsedData.options as any)[_options[i]];\r\n            }\r\n\r\n            for (let i = 0; i < parsedData.frames.length; i += 4) {\r\n                const frame: TexturePackerFrame = new TexturePackerFrame(\r\n                    i / 4,\r\n                    new Vector2(parsedData.frames[i], parsedData.frames[i + 1]),\r\n                    new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3])\r\n                );\r\n                this.frames.push(frame);\r\n            }\r\n\r\n            const channels = Object.keys(parsedData.sets);\r\n\r\n            for (let i = 0; i < channels.length; i++) {\r\n                const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\r\n                (this.sets as any)[channels[i]] = _t;\r\n            }\r\n        } catch (err) {\r\n            Logger.Warn(\"Unable to update from JSON: \" + err);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}