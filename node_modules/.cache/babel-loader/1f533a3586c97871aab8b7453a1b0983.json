{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/web.atob.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces.js\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh.js\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { GLTFUtils } from \"./glTFLoaderUtils.js\";\nimport { GLTFFileLoader } from \"../glTFFileLoader.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\n/**\n * Tokenizer. Used for shaders compatibility\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\n */\n\nvar ETokenType;\n\n(function (ETokenType) {\n  ETokenType[ETokenType[\"IDENTIFIER\"] = 1] = \"IDENTIFIER\";\n  ETokenType[ETokenType[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n  ETokenType[ETokenType[\"END_OF_INPUT\"] = 3] = \"END_OF_INPUT\";\n})(ETokenType || (ETokenType = {}));\n\nvar Tokenizer =\n/** @class */\nfunction () {\n  function Tokenizer(toParse) {\n    this._pos = 0;\n    this.currentToken = ETokenType.UNKNOWN;\n    this.currentIdentifier = \"\";\n    this.currentString = \"\";\n    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;\n    this._toParse = toParse;\n    this._maxPos = toParse.length;\n  }\n\n  Tokenizer.prototype.getNextToken = function () {\n    if (this.isEnd()) {\n      return ETokenType.END_OF_INPUT;\n    }\n\n    this.currentString = this.read();\n    this.currentToken = ETokenType.UNKNOWN;\n\n    if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\n      this.currentToken = ETokenType.IDENTIFIER;\n      this.currentIdentifier = this.currentString;\n\n      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\n        this.currentIdentifier += this.currentString;\n        this.forward();\n      }\n    }\n\n    return this.currentToken;\n  };\n\n  Tokenizer.prototype.peek = function () {\n    return this._toParse[this._pos];\n  };\n\n  Tokenizer.prototype.read = function () {\n    return this._toParse[this._pos++];\n  };\n\n  Tokenizer.prototype.forward = function () {\n    this._pos++;\n  };\n\n  Tokenizer.prototype.isEnd = function () {\n    return this._pos >= this._maxPos;\n  };\n\n  return Tokenizer;\n}();\n/**\n * Values\n */\n\n\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\n/**\n * Parse\n * @param parsedBuffers\n * @param gltfRuntime\n */\n\nvar parseBuffers = function parseBuffers(parsedBuffers, gltfRuntime) {\n  for (var buf in parsedBuffers) {\n    var parsedBuffer = parsedBuffers[buf];\n    gltfRuntime.buffers[buf] = parsedBuffer;\n    gltfRuntime.buffersCount++;\n  }\n};\n\nvar parseShaders = function parseShaders(parsedShaders, gltfRuntime) {\n  for (var sha in parsedShaders) {\n    var parsedShader = parsedShaders[sha];\n    gltfRuntime.shaders[sha] = parsedShader;\n    gltfRuntime.shaderscount++;\n  }\n};\n\nvar parseObject = function parseObject(parsedObjects, runtimeProperty, gltfRuntime) {\n  for (var object in parsedObjects) {\n    var parsedObject = parsedObjects[object];\n    gltfRuntime[runtimeProperty][object] = parsedObject;\n  }\n};\n/**\n * Utils\n * @param buffer\n */\n\n\nvar normalizeUVs = function normalizeUVs(buffer) {\n  if (!buffer) {\n    return;\n  }\n\n  for (var i = 0; i < buffer.length / 2; i++) {\n    buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\n  }\n};\n\nvar getAttribute = function getAttribute(attributeParameter) {\n  if (attributeParameter.semantic === \"NORMAL\") {\n    return \"normal\";\n  } else if (attributeParameter.semantic === \"POSITION\") {\n    return \"position\";\n  } else if (attributeParameter.semantic === \"JOINT\") {\n    return \"matricesIndices\";\n  } else if (attributeParameter.semantic === \"WEIGHT\") {\n    return \"matricesWeights\";\n  } else if (attributeParameter.semantic === \"COLOR\") {\n    return \"color\";\n  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\n    var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\n    return \"uv\" + (channel === 0 ? \"\" : channel + 1);\n  }\n\n  return null;\n};\n/**\n * Loads and creates animations\n * @param gltfRuntime\n */\n\n\nvar loadAnimations = function loadAnimations(gltfRuntime) {\n  for (var anim in gltfRuntime.animations) {\n    var animation = gltfRuntime.animations[anim];\n\n    if (!animation.channels || !animation.samplers) {\n      continue;\n    }\n\n    var lastAnimation = null;\n\n    for (var i = 0; i < animation.channels.length; i++) {\n      // Get parameters and load buffers\n      var channel = animation.channels[i];\n      var sampler = animation.samplers[channel.sampler];\n\n      if (!sampler) {\n        continue;\n      }\n\n      var inputData = null;\n      var outputData = null;\n\n      if (animation.parameters) {\n        inputData = animation.parameters[sampler.input];\n        outputData = animation.parameters[sampler.output];\n      } else {\n        inputData = sampler.input;\n        outputData = sampler.output;\n      }\n\n      var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\n      var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\n      var targetId = channel.target.id;\n      var targetNode = gltfRuntime.scene.getNodeById(targetId);\n\n      if (targetNode === null) {\n        targetNode = gltfRuntime.scene.getNodeByName(targetId);\n      }\n\n      if (targetNode === null) {\n        Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\n        continue;\n      }\n\n      var isBone = targetNode instanceof Bone; // Get target path (position, rotation or scaling)\n\n      var targetPath = channel.target.path;\n      var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\n\n      if (targetPathIndex !== -1) {\n        targetPath = babylonAnimationPaths[targetPathIndex];\n      } // Determine animation type\n\n\n      var animationType = Animation.ANIMATIONTYPE_MATRIX;\n\n      if (!isBone) {\n        if (targetPath === \"rotationQuaternion\") {\n          animationType = Animation.ANIMATIONTYPE_QUATERNION;\n          targetNode.rotationQuaternion = new Quaternion();\n        } else {\n          animationType = Animation.ANIMATIONTYPE_VECTOR3;\n        }\n      } // Create animation and key frames\n\n\n      var babylonAnimation = null;\n      var keys = [];\n      var arrayOffset = 0;\n      var modifyKey = false;\n\n      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\n        babylonAnimation = lastAnimation;\n        modifyKey = true;\n      }\n\n      if (!modifyKey) {\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n        babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\n        gltfRuntime.scene._blockEntityCollection = false;\n      } // For each frame\n\n\n      for (var j = 0; j < bufferInput.length; j++) {\n        var value = null;\n\n        if (targetPath === \"rotationQuaternion\") {\n          // VEC4\n          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\n          arrayOffset += 4;\n        } else {\n          // Position and scaling are VEC3\n          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\n          arrayOffset += 3;\n        }\n\n        if (isBone) {\n          var bone = targetNode;\n          var translation = Vector3.Zero();\n          var rotationQuaternion = new Quaternion();\n          var scaling = Vector3.Zero(); // Warning on decompose\n\n          var mat = bone.getBaseMatrix();\n\n          if (modifyKey && lastAnimation) {\n            mat = lastAnimation.getKeys()[j].value;\n          }\n\n          mat.decompose(scaling, rotationQuaternion, translation);\n\n          if (targetPath === \"position\") {\n            translation = value;\n          } else if (targetPath === \"rotationQuaternion\") {\n            rotationQuaternion = value;\n          } else {\n            scaling = value;\n          }\n\n          value = Matrix.Compose(scaling, rotationQuaternion, translation);\n        }\n\n        if (!modifyKey) {\n          keys.push({\n            frame: bufferInput[j],\n            value: value\n          });\n        } else if (lastAnimation) {\n          lastAnimation.getKeys()[j].value = value;\n        }\n      } // Finish\n\n\n      if (!modifyKey && babylonAnimation) {\n        babylonAnimation.setKeys(keys);\n        targetNode.animations.push(babylonAnimation);\n      }\n\n      lastAnimation = babylonAnimation;\n      gltfRuntime.scene.stopAnimation(targetNode);\n      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\n    }\n  }\n};\n/**\n * Returns the bones transformation matrix\n * @param node\n */\n\n\nvar configureBoneTransformation = function configureBoneTransformation(node) {\n  var mat = null;\n\n  if (node.translation || node.rotation || node.scale) {\n    var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\n    var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\n    var position = Vector3.FromArray(node.translation || [0, 0, 0]);\n    mat = Matrix.Compose(scale, rotation, position);\n  } else {\n    mat = Matrix.FromArray(node.matrix);\n  }\n\n  return mat;\n};\n/**\n * Returns the parent bone\n * @param gltfRuntime\n * @param skins\n * @param jointName\n * @param newSkeleton\n */\n\n\nvar getParentBone = function getParentBone(gltfRuntime, skins, jointName, newSkeleton) {\n  // Try to find\n  for (var i = 0; i < newSkeleton.bones.length; i++) {\n    if (newSkeleton.bones[i].name === jointName) {\n      return newSkeleton.bones[i];\n    }\n  } // Not found, search in gltf nodes\n\n\n  var nodes = gltfRuntime.nodes;\n\n  for (var nde in nodes) {\n    var node = nodes[nde];\n\n    if (!node.jointName) {\n      continue;\n    }\n\n    var children = node.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = gltfRuntime.nodes[children[i]];\n\n      if (!child.jointName) {\n        continue;\n      }\n\n      if (child.jointName === jointName) {\n        var mat = configureBoneTransformation(node);\n        var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\n        bone.id = nde;\n        return bone;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the appropriate root node\n * @param nodesToRoot\n * @param id\n */\n\n\nvar getNodeToRoot = function getNodeToRoot(nodesToRoot, id) {\n  for (var i = 0; i < nodesToRoot.length; i++) {\n    var nodeToRoot = nodesToRoot[i];\n\n    for (var j = 0; j < nodeToRoot.node.children.length; j++) {\n      var child = nodeToRoot.node.children[j];\n\n      if (child === id) {\n        return nodeToRoot.bone;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the node with the joint name\n * @param gltfRuntime\n * @param jointName\n */\n\n\nvar getJointNode = function getJointNode(gltfRuntime, jointName) {\n  var nodes = gltfRuntime.nodes;\n  var node = nodes[jointName];\n\n  if (node) {\n    return {\n      node: node,\n      id: jointName\n    };\n  }\n\n  for (var nde in nodes) {\n    node = nodes[nde];\n\n    if (node.jointName === jointName) {\n      return {\n        node: node,\n        id: nde\n      };\n    }\n  }\n\n  return null;\n};\n/**\n * Checks if a nodes is in joints\n * @param skins\n * @param id\n */\n\n\nvar nodeIsInJoints = function nodeIsInJoints(skins, id) {\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    if (skins.jointNames[i] === id) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Fills the nodes to root for bones and builds hierarchy\n * @param gltfRuntime\n * @param newSkeleton\n * @param skins\n * @param nodesToRoot\n */\n\n\nvar getNodesToRoot = function getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot) {\n  // Creates nodes for root\n  for (var nde in gltfRuntime.nodes) {\n    var node = gltfRuntime.nodes[nde];\n    var id = nde;\n\n    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\n      continue;\n    } // Create node to root bone\n\n\n    var mat = configureBoneTransformation(node);\n    var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\n    bone.id = id;\n    nodesToRoot.push({\n      bone: bone,\n      node: node,\n      id: id\n    });\n  } // Parenting\n\n\n  for (var i = 0; i < nodesToRoot.length; i++) {\n    var nodeToRoot = nodesToRoot[i];\n    var children = nodeToRoot.node.children;\n\n    for (var j = 0; j < children.length; j++) {\n      var child = null;\n\n      for (var k = 0; k < nodesToRoot.length; k++) {\n        if (nodesToRoot[k].id === children[j]) {\n          child = nodesToRoot[k];\n          break;\n        }\n      }\n\n      if (child) {\n        child.bone._parent = nodeToRoot.bone;\n        nodeToRoot.bone.children.push(child.bone);\n      }\n    }\n  }\n};\n/**\n * Imports a skeleton\n * @param gltfRuntime\n * @param skins\n * @param mesh\n * @param newSkeleton\n */\n\n\nvar importSkeleton = function importSkeleton(gltfRuntime, skins, mesh, newSkeleton) {\n  if (!newSkeleton) {\n    newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\n  }\n\n  if (!skins.babylonSkeleton) {\n    return newSkeleton;\n  } // Find the root bones\n\n\n  var nodesToRoot = [];\n  var nodesToRootToAdd = [];\n  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\n  newSkeleton.bones = []; // Joints\n\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n\n    if (!jointNode) {\n      continue;\n    }\n\n    var node = jointNode.node;\n\n    if (!node) {\n      Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\n      continue;\n    }\n\n    var id = jointNode.id; // Optimize, if the bone already exists...\n\n    var existingBone = gltfRuntime.scene.getBoneById(id);\n\n    if (existingBone) {\n      newSkeleton.bones.push(existingBone);\n      continue;\n    } // Search for parent bone\n\n\n    var foundBone = false;\n    var parentBone = null;\n\n    for (var j = 0; j < i; j++) {\n      var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);\n\n      if (!jointNode_1) {\n        continue;\n      }\n\n      var joint = jointNode_1.node;\n\n      if (!joint) {\n        Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\n        continue;\n      }\n\n      var children = joint.children;\n\n      if (!children) {\n        continue;\n      }\n\n      foundBone = false;\n\n      for (var k = 0; k < children.length; k++) {\n        if (children[k] === id) {\n          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\n          foundBone = true;\n          break;\n        }\n      }\n\n      if (foundBone) {\n        break;\n      }\n    } // Create bone\n\n\n    var mat = configureBoneTransformation(node);\n\n    if (!parentBone && nodesToRoot.length > 0) {\n      parentBone = getNodeToRoot(nodesToRoot, id);\n\n      if (parentBone) {\n        if (nodesToRootToAdd.indexOf(parentBone) === -1) {\n          nodesToRootToAdd.push(parentBone);\n        }\n      }\n    }\n\n    var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\n    bone.id = id;\n  } // Polish\n\n\n  var bones = newSkeleton.bones;\n  newSkeleton.bones = [];\n\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n\n    if (!jointNode) {\n      continue;\n    }\n\n    for (var j = 0; j < bones.length; j++) {\n      if (bones[j].id === jointNode.id) {\n        newSkeleton.bones.push(bones[j]);\n        break;\n      }\n    }\n  }\n\n  newSkeleton.prepare(); // Finish\n\n  for (var i = 0; i < nodesToRootToAdd.length; i++) {\n    newSkeleton.bones.push(nodesToRootToAdd[i]);\n  }\n\n  return newSkeleton;\n};\n/**\n * Imports a mesh and its geometries\n * @param gltfRuntime\n * @param node\n * @param meshes\n * @param id\n * @param newMesh\n */\n\n\nvar importMesh = function importMesh(gltfRuntime, node, meshes, id, newMesh) {\n  if (!newMesh) {\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n    newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\n    newMesh._parentContainer = gltfRuntime.assetContainer;\n    gltfRuntime.scene._blockEntityCollection = false;\n    newMesh.id = id;\n  }\n\n  if (!node.babylonNode) {\n    return newMesh;\n  }\n\n  var subMaterials = [];\n  var vertexData = null;\n  var verticesStarts = new Array();\n  var verticesCounts = new Array();\n  var indexStarts = new Array();\n  var indexCounts = new Array();\n\n  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    var meshId = meshes[meshIndex];\n    var mesh = gltfRuntime.meshes[meshId];\n\n    if (!mesh) {\n      continue;\n    } // Positions, normals and UVs\n\n\n    for (var i = 0; i < mesh.primitives.length; i++) {\n      // Temporary vertex data\n      var tempVertexData = new VertexData();\n      var primitive = mesh.primitives[i];\n\n      if (primitive.mode !== 4) {// continue;\n      }\n\n      var attributes = primitive.attributes;\n      var accessor = null;\n      var buffer = null; // Set positions, normal and uvs\n\n      for (var semantic in attributes) {\n        // Link accessor and buffer view\n        accessor = gltfRuntime.accessors[attributes[semantic]];\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n\n        if (semantic === \"NORMAL\") {\n          tempVertexData.normals = new Float32Array(buffer.length);\n          tempVertexData.normals.set(buffer);\n        } else if (semantic === \"POSITION\") {\n          if (GLTFFileLoader.HomogeneousCoordinates) {\n            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\n\n            for (var j = 0; j < buffer.length; j += 4) {\n              tempVertexData.positions[j] = buffer[j];\n              tempVertexData.positions[j + 1] = buffer[j + 1];\n              tempVertexData.positions[j + 2] = buffer[j + 2];\n            }\n          } else {\n            tempVertexData.positions = new Float32Array(buffer.length);\n            tempVertexData.positions.set(buffer);\n          }\n\n          verticesCounts.push(tempVertexData.positions.length);\n        } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\n          var channel = Number(semantic.split(\"_\")[1]);\n          var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\n          var uvs = new Float32Array(buffer.length);\n          uvs.set(buffer);\n          normalizeUVs(uvs);\n          tempVertexData.set(uvs, uvKind);\n        } else if (semantic === \"JOINT\") {\n          tempVertexData.matricesIndices = new Float32Array(buffer.length);\n          tempVertexData.matricesIndices.set(buffer);\n        } else if (semantic === \"WEIGHT\") {\n          tempVertexData.matricesWeights = new Float32Array(buffer.length);\n          tempVertexData.matricesWeights.set(buffer);\n        } else if (semantic === \"COLOR\") {\n          tempVertexData.colors = new Float32Array(buffer.length);\n          tempVertexData.colors.set(buffer);\n        }\n      } // Indices\n\n\n      accessor = gltfRuntime.accessors[primitive.indices];\n\n      if (accessor) {\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n        tempVertexData.indices = new Int32Array(buffer.length);\n        tempVertexData.indices.set(buffer);\n        indexCounts.push(tempVertexData.indices.length);\n      } else {\n        // Set indices on the fly\n        var indices = [];\n\n        for (var j = 0; j < tempVertexData.positions.length / 3; j++) {\n          indices.push(j);\n        }\n\n        tempVertexData.indices = new Int32Array(indices);\n        indexCounts.push(tempVertexData.indices.length);\n      }\n\n      if (!vertexData) {\n        vertexData = tempVertexData;\n      } else {\n        vertexData.merge(tempVertexData);\n      } // Sub material\n\n\n      var material_1 = gltfRuntime.scene.getMaterialById(primitive.material);\n      subMaterials.push(material_1 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1); // Update vertices start and index start\n\n      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\n      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\n    }\n  }\n\n  var material;\n  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n\n  if (subMaterials.length > 1) {\n    material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\n    material.subMaterials = subMaterials;\n  } else {\n    material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\n  }\n\n  if (subMaterials.length === 1) {\n    material = subMaterials[0];\n  }\n\n  material._parentContainer = gltfRuntime.assetContainer;\n\n  if (!newMesh.material) {\n    newMesh.material = material;\n  } // Apply geometry\n\n\n  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);\n  newMesh.computeWorldMatrix(true);\n  gltfRuntime.scene._blockEntityCollection = false; // Apply submeshes\n\n  newMesh.subMeshes = [];\n  var index = 0;\n\n  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    var meshId = meshes[meshIndex];\n    var mesh = gltfRuntime.meshes[meshId];\n\n    if (!mesh) {\n      continue;\n    }\n\n    for (var i = 0; i < mesh.primitives.length; i++) {\n      if (mesh.primitives[i].mode !== 4) {//continue;\n      }\n\n      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\n      index++;\n    }\n  } // Finish\n\n\n  return newMesh;\n};\n/**\n * Configure node transformation from position, rotation and scaling\n * @param newNode\n * @param position\n * @param rotation\n * @param scaling\n */\n\n\nvar configureNode = function configureNode(newNode, position, rotation, scaling) {\n  if (newNode.position) {\n    newNode.position = position;\n  }\n\n  if (newNode.rotationQuaternion || newNode.rotation) {\n    newNode.rotationQuaternion = rotation;\n  }\n\n  if (newNode.scaling) {\n    newNode.scaling = scaling;\n  }\n};\n/**\n * Configures node from transformation matrix\n * @param newNode\n * @param node\n */\n\n\nvar configureNodeFromMatrix = function configureNodeFromMatrix(newNode, node) {\n  if (node.matrix) {\n    var position = new Vector3(0, 0, 0);\n    var rotation = new Quaternion();\n    var scaling = new Vector3(0, 0, 0);\n    var mat = Matrix.FromArray(node.matrix);\n    mat.decompose(scaling, rotation, position);\n    configureNode(newNode, position, rotation, scaling);\n  } else if (node.translation && node.rotation && node.scale) {\n    configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\n  }\n\n  newNode.computeWorldMatrix(true);\n};\n/**\n * Imports a node\n * @param gltfRuntime\n * @param node\n * @param id\n */\n\n\nvar importNode = function importNode(gltfRuntime, node, id) {\n  var lastNode = null;\n\n  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\n    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\n      return null;\n    }\n  } // Meshes\n\n\n  if (node.skin) {\n    if (node.meshes) {\n      var skin = gltfRuntime.skins[node.skin];\n      var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);\n      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\n\n      if (newMesh.skeleton === null) {\n        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\n\n        if (!skin.babylonSkeleton) {\n          skin.babylonSkeleton = newMesh.skeleton;\n        }\n      }\n\n      lastNode = newMesh;\n    }\n  } else if (node.meshes) {\n    /**\n     * Improve meshes property\n     */\n    var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);\n    lastNode = newMesh;\n  } // Lights\n  else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    var light = gltfRuntime.lights[node.light];\n\n    if (light) {\n      if (light.type === \"ambient\") {\n        var ambienLight = light[light.type];\n        var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        hemiLight.name = node.name || \"\";\n\n        if (ambienLight.color) {\n          hemiLight.diffuse = Color3.FromArray(ambienLight.color);\n        }\n\n        lastNode = hemiLight;\n      } else if (light.type === \"directional\") {\n        var directionalLight = light[light.type];\n        var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        dirLight.name = node.name || \"\";\n\n        if (directionalLight.color) {\n          dirLight.diffuse = Color3.FromArray(directionalLight.color);\n        }\n\n        lastNode = dirLight;\n      } else if (light.type === \"point\") {\n        var pointLight = light[light.type];\n        var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        ptLight.name = node.name || \"\";\n\n        if (pointLight.color) {\n          ptLight.diffuse = Color3.FromArray(pointLight.color);\n        }\n\n        lastNode = ptLight;\n      } else if (light.type === \"spot\") {\n        var spotLight = light[light.type];\n        var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\n        spLight.name = node.name || \"\";\n\n        if (spotLight.color) {\n          spLight.diffuse = Color3.FromArray(spotLight.color);\n        }\n\n        if (spotLight.fallOfAngle) {\n          spLight.angle = spotLight.fallOfAngle;\n        }\n\n        if (spotLight.fallOffExponent) {\n          spLight.exponent = spotLight.fallOffExponent;\n        }\n\n        lastNode = spLight;\n      }\n    }\n  } // Cameras\n  else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    var camera = gltfRuntime.cameras[node.camera];\n\n    if (camera) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n\n      if (camera.type === \"orthographic\") {\n        var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        orthoCamera.name = node.name || \"\";\n        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n        orthoCamera.attachControl();\n        lastNode = orthoCamera;\n        orthoCamera._parentContainer = gltfRuntime.assetContainer;\n      } else if (camera.type === \"perspective\") {\n        var perspectiveCamera = camera[camera.type];\n        var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        persCamera.name = node.name || \"\";\n        persCamera.attachControl();\n\n        if (!perspectiveCamera.aspectRatio) {\n          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\n        }\n\n        if (perspectiveCamera.znear && perspectiveCamera.zfar) {\n          persCamera.maxZ = perspectiveCamera.zfar;\n          persCamera.minZ = perspectiveCamera.znear;\n        }\n\n        lastNode = persCamera;\n        persCamera._parentContainer = gltfRuntime.assetContainer;\n      }\n\n      gltfRuntime.scene._blockEntityCollection = false;\n    }\n  } // Empty node\n\n\n  if (!node.jointName) {\n    if (node.babylonNode) {\n      return node.babylonNode;\n    } else if (lastNode === null) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n      var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\n      dummy._parentContainer = gltfRuntime.assetContainer;\n      gltfRuntime.scene._blockEntityCollection = false;\n      node.babylonNode = dummy;\n      lastNode = dummy;\n    }\n  }\n\n  if (lastNode !== null) {\n    if (node.matrix && lastNode instanceof Mesh) {\n      configureNodeFromMatrix(lastNode, node);\n    } else {\n      var translation = node.translation || [0, 0, 0];\n      var rotation = node.rotation || [0, 0, 0, 1];\n      var scale = node.scale || [1, 1, 1];\n      configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\n    }\n\n    lastNode.updateCache(true);\n    node.babylonNode = lastNode;\n  }\n\n  return lastNode;\n};\n/**\n * Traverses nodes and creates them\n * @param gltfRuntime\n * @param id\n * @param parent\n * @param meshIncluded\n */\n\n\nvar traverseNodes = function traverseNodes(gltfRuntime, id, parent, meshIncluded) {\n  if (meshIncluded === void 0) {\n    meshIncluded = false;\n  }\n\n  var node = gltfRuntime.nodes[id];\n  var newNode = null;\n\n  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\n    if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\n      meshIncluded = true;\n    } else {\n      meshIncluded = false;\n    }\n  } else {\n    meshIncluded = true;\n  }\n\n  if (!node.jointName && meshIncluded) {\n    newNode = importNode(gltfRuntime, node, id);\n\n    if (newNode !== null) {\n      newNode.id = id;\n      newNode.parent = parent;\n    }\n  }\n\n  if (node.children) {\n    for (var i = 0; i < node.children.length; i++) {\n      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\n    }\n  }\n};\n/**\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\n * @param gltfRuntime\n */\n\n\nvar postLoad = function postLoad(gltfRuntime) {\n  // Nodes\n  var currentScene = gltfRuntime.currentScene;\n\n  if (currentScene) {\n    for (var i = 0; i < currentScene.nodes.length; i++) {\n      traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n    }\n  } else {\n    for (var thing in gltfRuntime.scenes) {\n      currentScene = gltfRuntime.scenes[thing];\n\n      for (var i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    }\n  } // Set animations\n\n\n  loadAnimations(gltfRuntime);\n\n  for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\n    var skeleton = gltfRuntime.scene.skeletons[i];\n    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\n  }\n};\n/**\n * onBind shaderrs callback to set uniforms and matrices\n * @param mesh\n * @param gltfRuntime\n * @param unTreatedUniforms\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param onSuccess\n */\n\n\nvar onBindShaderMaterial = function onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {\n  var materialValues = material.values || technique.parameters;\n\n  for (var unif in unTreatedUniforms) {\n    var uniform = unTreatedUniforms[unif];\n    var type = uniform.type;\n\n    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\n      if (uniform.semantic && !uniform.source && !uniform.node) {\n        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\n      } else if (uniform.semantic && (uniform.source || uniform.node)) {\n        var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\n\n        if (source === null) {\n          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\n        }\n\n        if (source === null) {\n          continue;\n        }\n\n        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\n      }\n    } else {\n      var value = materialValues[technique.uniforms[unif]];\n\n      if (!value) {\n        continue;\n      }\n\n      if (type === EParameterType.SAMPLER_2D) {\n        var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\n\n        if (texture === null || texture === undefined) {\n          continue;\n        }\n\n        shaderMaterial.getEffect().setTexture(unif, texture);\n      } else {\n        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\n      }\n    }\n  }\n\n  onSuccess(shaderMaterial);\n};\n/**\n * Prepare uniforms to send the only one time\n * Loads the appropriate textures\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n */\n\n\nvar prepareShaderMaterialUniforms = function prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {\n  var materialValues = material.values || technique.parameters;\n  var techniqueUniforms = technique.uniforms;\n\n  var _loop_1 = function _loop_1(unif) {\n    var uniform = unTreatedUniforms[unif];\n    var type = uniform.type;\n    var value = materialValues[techniqueUniforms[unif]];\n\n    if (value === undefined) {\n      // In case the value is the same for all materials\n      value = uniform.value;\n    }\n\n    if (!value) {\n      return \"continue\";\n    }\n\n    var onLoadTexture = function onLoadTexture(uniformName) {\n      return function (texture) {\n        if (uniform.value && uniformName) {\n          // Static uniform\n          shaderMaterial.setTexture(uniformName, texture);\n          delete unTreatedUniforms[uniformName];\n        }\n      };\n    }; // Texture (sampler2D)\n\n\n    if (type === EParameterType.SAMPLER_2D) {\n      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), function () {\n        return onLoadTexture(null);\n      });\n    } // Others\n    else {\n      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\n        // Static uniform\n        delete unTreatedUniforms[unif];\n      }\n    }\n  };\n  /**\n   * Prepare values here (not matrices)\n   */\n\n\n  for (var unif in unTreatedUniforms) {\n    _loop_1(unif);\n  }\n};\n/**\n * Shader compilation failed\n * @param program\n * @param shaderMaterial\n * @param onError\n */\n\n\nvar onShaderCompileError = function onShaderCompileError(program, shaderMaterial, onError) {\n  return function (effect, error) {\n    shaderMaterial.dispose(true);\n    onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\n  };\n};\n/**\n * Shader compilation success\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param unTreatedUniforms\n * @param onSuccess\n */\n\n\nvar onShaderCompileSuccess = function onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {\n  return function (_) {\n    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\n\n    shaderMaterial.onBind = function (mesh) {\n      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\n    };\n  };\n};\n/**\n * Returns the appropriate uniform if already handled by babylon\n * @param tokenizer\n * @param technique\n */\n\n\nvar parseShaderUniforms = function parseShaderUniforms(tokenizer, technique, unTreatedUniforms) {\n  for (var unif in technique.uniforms) {\n    var uniform = technique.uniforms[unif];\n    var uniformParameter = technique.parameters[uniform];\n\n    if (tokenizer.currentIdentifier === unif) {\n      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\n        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n\n        if (transformIndex !== -1) {\n          delete unTreatedUniforms[unif];\n          return babylonTransforms[transformIndex];\n        }\n      }\n    }\n  }\n\n  return tokenizer.currentIdentifier;\n};\n/**\n * All shaders loaded. Create materials one by one\n * @param gltfRuntime\n */\n\n\nvar importMaterials = function importMaterials(gltfRuntime) {\n  // Create materials\n  for (var mat in gltfRuntime.materials) {\n    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function () {}, function () {});\n  }\n};\n/**\n * Implementation of the base glTF spec\n * @hidden\n */\n\n\nvar GLTFLoaderBase =\n/** @class */\nfunction () {\n  function GLTFLoaderBase() {}\n\n  GLTFLoaderBase.CreateRuntime = function (parsedData, scene, rootUrl) {\n    var gltfRuntime = {\n      extensions: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      meshes: {},\n      lights: {},\n      cameras: {},\n      nodes: {},\n      images: {},\n      textures: {},\n      shaders: {},\n      programs: {},\n      samplers: {},\n      techniques: {},\n      materials: {},\n      animations: {},\n      skins: {},\n      extensionsUsed: [],\n      scenes: {},\n      buffersCount: 0,\n      shaderscount: 0,\n      scene: scene,\n      rootUrl: rootUrl,\n      loadedBufferCount: 0,\n      loadedBufferViews: {},\n      loadedShaderCount: 0,\n      importOnlyMeshes: false,\n      dummyNodes: [],\n      assetContainer: null\n    }; // Parse\n\n    if (parsedData.extensions) {\n      parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\n    }\n\n    if (parsedData.extensionsUsed) {\n      parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\n    }\n\n    if (parsedData.buffers) {\n      parseBuffers(parsedData.buffers, gltfRuntime);\n    }\n\n    if (parsedData.bufferViews) {\n      parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\n    }\n\n    if (parsedData.accessors) {\n      parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\n    }\n\n    if (parsedData.meshes) {\n      parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\n    }\n\n    if (parsedData.lights) {\n      parseObject(parsedData.lights, \"lights\", gltfRuntime);\n    }\n\n    if (parsedData.cameras) {\n      parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\n    }\n\n    if (parsedData.nodes) {\n      parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\n    }\n\n    if (parsedData.images) {\n      parseObject(parsedData.images, \"images\", gltfRuntime);\n    }\n\n    if (parsedData.textures) {\n      parseObject(parsedData.textures, \"textures\", gltfRuntime);\n    }\n\n    if (parsedData.shaders) {\n      parseShaders(parsedData.shaders, gltfRuntime);\n    }\n\n    if (parsedData.programs) {\n      parseObject(parsedData.programs, \"programs\", gltfRuntime);\n    }\n\n    if (parsedData.samplers) {\n      parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\n    }\n\n    if (parsedData.techniques) {\n      parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\n    }\n\n    if (parsedData.materials) {\n      parseObject(parsedData.materials, \"materials\", gltfRuntime);\n    }\n\n    if (parsedData.animations) {\n      parseObject(parsedData.animations, \"animations\", gltfRuntime);\n    }\n\n    if (parsedData.skins) {\n      parseObject(parsedData.skins, \"skins\", gltfRuntime);\n    }\n\n    if (parsedData.scenes) {\n      gltfRuntime.scenes = parsedData.scenes;\n    }\n\n    if (parsedData.scene && parsedData.scenes) {\n      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\n    }\n\n    return gltfRuntime;\n  };\n\n  GLTFLoaderBase.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    var buffer = gltfRuntime.buffers[id];\n\n    if (Tools.IsBase64(buffer.uri)) {\n      setTimeout(function () {\n        return onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri)));\n      });\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function (data) {\n        return onSuccess(new Uint8Array(data));\n      }, onProgress, undefined, true, function (request) {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var texture = gltfRuntime.textures[id];\n\n    if (!texture || !texture.source) {\n      onError(\"\");\n      return;\n    }\n\n    if (texture.babylonTexture) {\n      onSuccess(null);\n      return;\n    }\n\n    var source = gltfRuntime.images[texture.source];\n\n    if (Tools.IsBase64(source.uri)) {\n      setTimeout(function () {\n        return onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri)));\n      });\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function (data) {\n        return onSuccess(new Uint8Array(data));\n      }, undefined, undefined, true, function (request) {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess) {\n    var texture = gltfRuntime.textures[id];\n\n    if (texture.babylonTexture) {\n      onSuccess(texture.babylonTexture);\n      return;\n    }\n\n    var sampler = gltfRuntime.samplers[texture.sampler];\n    var createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\n    var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    var blob = buffer == null ? new Blob() : new Blob([buffer]);\n    var blobURL = URL.createObjectURL(blob);\n\n    var revokeBlobURL = function revokeBlobURL() {\n      return URL.revokeObjectURL(blobURL);\n    };\n\n    var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\n\n    if (sampler.wrapS !== undefined) {\n      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\n    }\n\n    if (sampler.wrapT !== undefined) {\n      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\n    }\n\n    newTexture.name = id;\n    texture.babylonTexture = newTexture;\n    onSuccess(newTexture);\n  };\n\n  GLTFLoaderBase.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var shader = gltfRuntime.shaders[id];\n\n    if (Tools.IsBase64(shader.uri)) {\n      var shaderString = atob(shader.uri.split(\",\")[1]);\n\n      if (onSuccess) {\n        onSuccess(shaderString);\n      }\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, function (request) {\n        if (request && onError) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var material = gltfRuntime.materials[id];\n\n    if (!material.technique) {\n      if (onError) {\n        onError(\"No technique found.\");\n      }\n\n      return;\n    }\n\n    var technique = gltfRuntime.techniques[material.technique];\n\n    if (!technique) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n      var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\n      defaultMaterial._parentContainer = gltfRuntime.assetContainer;\n      gltfRuntime.scene._blockEntityCollection = false;\n      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\n      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n      onSuccess(defaultMaterial);\n      return;\n    }\n\n    var program = gltfRuntime.programs[technique.program];\n    var states = technique.states;\n    var vertexShader = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\n    var pixelShader = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\n    var newVertexShader = \"\";\n    var newPixelShader = \"\";\n    var vertexTokenizer = new Tokenizer(vertexShader);\n    var pixelTokenizer = new Tokenizer(pixelShader);\n    var unTreatedUniforms = {};\n    var uniforms = [];\n    var attributes = [];\n    var samplers = []; // Fill uniform, sampler2D and attributes\n\n    for (var unif in technique.uniforms) {\n      var uniform = technique.uniforms[unif];\n      var uniformParameter = technique.parameters[uniform];\n      unTreatedUniforms[unif] = uniformParameter;\n\n      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\n        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n\n        if (transformIndex !== -1) {\n          uniforms.push(babylonTransforms[transformIndex]);\n          delete unTreatedUniforms[unif];\n        } else {\n          uniforms.push(unif);\n        }\n      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\n        samplers.push(unif);\n      } else {\n        uniforms.push(unif);\n      }\n    }\n\n    for (var attr in technique.attributes) {\n      var attribute = technique.attributes[attr];\n      var attributeParameter = technique.parameters[attribute];\n\n      if (attributeParameter.semantic) {\n        var name_1 = getAttribute(attributeParameter);\n\n        if (name_1) {\n          attributes.push(name_1);\n        }\n      }\n    } // Configure vertex shader\n\n\n    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\n      var tokenType = vertexTokenizer.currentToken;\n\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newVertexShader += vertexTokenizer.currentString;\n        continue;\n      }\n\n      var foundAttribute = false;\n\n      for (var attr in technique.attributes) {\n        var attribute = technique.attributes[attr];\n        var attributeParameter = technique.parameters[attribute];\n\n        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\n          newVertexShader += getAttribute(attributeParameter);\n          foundAttribute = true;\n          break;\n        }\n      }\n\n      if (foundAttribute) {\n        continue;\n      }\n\n      newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\n    } // Configure pixel shader\n\n\n    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\n      var tokenType = pixelTokenizer.currentToken;\n\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newPixelShader += pixelTokenizer.currentString;\n        continue;\n      }\n\n      newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\n    } // Create shader material\n\n\n    var shaderPath = {\n      vertex: program.vertexShader + id,\n      fragment: program.fragmentShader + id\n    };\n    var options = {\n      attributes: attributes,\n      uniforms: uniforms,\n      samplers: samplers,\n      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\n    };\n    Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\n    Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\n    var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\n    shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\n    shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\n    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n    if (states && states.functions) {\n      var functions = states.functions;\n\n      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\n        shaderMaterial.backFaceCulling = false;\n      }\n\n      var blendFunc = functions.blendFuncSeparate;\n\n      if (blendFunc) {\n        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\n        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ADD;\n        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\n        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\n        }\n      }\n    }\n  };\n\n  return GLTFLoaderBase;\n}();\n\nexport { GLTFLoaderBase };\n/**\n * glTF V1 Loader\n * @hidden\n */\n\nvar GLTFLoader =\n/** @class */\nfunction () {\n  function GLTFLoader() {}\n\n  GLTFLoader.RegisterExtension = function (extension) {\n    if (GLTFLoader.Extensions[extension.name]) {\n      Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\n      return;\n    }\n\n    GLTFLoader.Extensions[extension.name] = extension;\n  };\n\n  GLTFLoader.prototype.dispose = function () {// do nothing\n  };\n\n  GLTFLoader.prototype._importMeshAsync = function (meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {\n    var _this = this;\n\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {\n      gltfRuntime.assetContainer = assetContainer;\n      gltfRuntime.importOnlyMeshes = true;\n\n      if (meshesNames === \"\") {\n        gltfRuntime.importMeshesNames = [];\n      } else if (typeof meshesNames === \"string\") {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else if (meshesNames && !(meshesNames instanceof Array)) {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else {\n        gltfRuntime.importMeshesNames = [];\n        Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\n      } // Create nodes\n\n\n      _this._createNodes(gltfRuntime);\n\n      var meshes = new Array();\n      var skeletons = new Array(); // Fill arrays of meshes and skeletons\n\n      for (var nde in gltfRuntime.nodes) {\n        var node = gltfRuntime.nodes[nde];\n\n        if (node.babylonNode instanceof AbstractMesh) {\n          meshes.push(node.babylonNode);\n        }\n      }\n\n      for (var skl in gltfRuntime.skins) {\n        var skin = gltfRuntime.skins[skl];\n\n        if (skin.babylonSkeleton instanceof Skeleton) {\n          skeletons.push(skin.babylonSkeleton);\n        }\n      } // Load buffers, shaders, materials, etc.\n\n\n      _this._loadBuffersAsync(gltfRuntime, function () {\n        _this._loadShadersAsync(gltfRuntime, function () {\n          importMaterials(gltfRuntime);\n          postLoad(gltfRuntime);\n\n          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\n            onSuccess(meshes, skeletons);\n          }\n        });\n      });\n\n      if (GLTFFileLoader.IncrementalLoading && onSuccess) {\n        onSuccess(meshes, skeletons);\n      }\n    }, onError);\n    return true;\n  };\n  /**\n   * Imports one or more meshes from a loaded gltf file and adds them to the scene\n   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene the scene the meshes should be added to\n   * @param assetContainer defines the asset container to use (can be null)\n   * @param data gltf data containing information of the meshes in a loaded file\n   * @param rootUrl root url to load from\n   * @param onProgress event that fires when loading progress has occured\n   * @returns a promise containg the loaded meshes, particles, skeletons and animations\n   */\n\n\n  GLTFLoader.prototype.importMeshAsync = function (meshesNames, scene, assetContainer, data, rootUrl, onProgress) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, function (meshes, skeletons) {\n        resolve({\n          meshes: meshes,\n          particleSystems: [],\n          skeletons: skeletons,\n          animationGroups: [],\n          lights: [],\n          transformNodes: [],\n          geometries: []\n        });\n      }, onProgress, function (message) {\n        reject(new Error(message));\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadAsync = function (scene, data, rootUrl, onSuccess, onProgress, onError) {\n    var _this = this;\n\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {\n      // Load runtime extensios\n      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function () {\n        // Create nodes\n        _this._createNodes(gltfRuntime); // Load buffers, shaders, materials, etc.\n\n\n        _this._loadBuffersAsync(gltfRuntime, function () {\n          _this._loadShadersAsync(gltfRuntime, function () {\n            importMaterials(gltfRuntime);\n            postLoad(gltfRuntime);\n\n            if (!GLTFFileLoader.IncrementalLoading) {\n              onSuccess();\n            }\n          });\n        });\n\n        if (GLTFFileLoader.IncrementalLoading) {\n          onSuccess();\n        }\n      }, onError);\n    }, onError);\n  };\n  /**\n   * Imports all objects from a loaded gltf file and adds them to the scene\n   * @param scene the scene the objects should be added to\n   * @param data gltf data containing information of the meshes in a loaded file\n   * @param rootUrl root url to load from\n   * @param onProgress event that fires when loading progress has occured\n   * @returns a promise which completes when objects have been loaded to the scene\n   */\n\n\n  GLTFLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadAsync(scene, data, rootUrl, function () {\n        resolve();\n      }, onProgress, function (message) {\n        reject(new Error(message));\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadShadersAsync = function (gltfRuntime, onload) {\n    var hasShaders = false;\n\n    var processShader = function processShader(sha, shader) {\n      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, function (shaderString) {\n        if (shaderString instanceof ArrayBuffer) {\n          return;\n        }\n\n        gltfRuntime.loadedShaderCount++;\n\n        if (shaderString) {\n          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\n        }\n\n        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\n          onload();\n        }\n      }, function () {\n        Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\n      });\n    };\n\n    for (var sha in gltfRuntime.shaders) {\n      hasShaders = true;\n      var shader = gltfRuntime.shaders[sha];\n\n      if (shader) {\n        processShader.bind(this, sha, shader)();\n      } else {\n        Tools.Error(\"No shader named: \" + sha);\n      }\n    }\n\n    if (!hasShaders) {\n      onload();\n    }\n  };\n\n  GLTFLoader.prototype._loadBuffersAsync = function (gltfRuntime, onLoad) {\n    var hasBuffers = false;\n\n    var processBuffer = function processBuffer(buf, buffer) {\n      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, function (bufferView) {\n        gltfRuntime.loadedBufferCount++;\n\n        if (bufferView) {\n          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\n            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\n          }\n\n          gltfRuntime.loadedBufferViews[buf] = bufferView;\n        }\n\n        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\n          onLoad();\n        }\n      }, function () {\n        Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\n      });\n    };\n\n    for (var buf in gltfRuntime.buffers) {\n      hasBuffers = true;\n      var buffer = gltfRuntime.buffers[buf];\n\n      if (buffer) {\n        processBuffer.bind(this, buf, buffer)();\n      } else {\n        Tools.Error(\"No buffer named: \" + buf);\n      }\n    }\n\n    if (!hasBuffers) {\n      onLoad();\n    }\n  };\n\n  GLTFLoader.prototype._createNodes = function (gltfRuntime) {\n    var currentScene = gltfRuntime.currentScene;\n\n    if (currentScene) {\n      // Only one scene even if multiple scenes are defined\n      for (var i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    } else {\n      // Load all scenes\n      for (var thing in gltfRuntime.scenes) {\n        currentScene = gltfRuntime.scenes[thing];\n\n        for (var i = 0; i < currentScene.nodes.length; i++) {\n          traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n        }\n      }\n    }\n  };\n\n  GLTFLoader.Extensions = {};\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };\n/** @hidden */\n\nvar GLTFLoaderExtension =\n/** @class */\nfunction () {\n  function GLTFLoaderExtension(name) {\n    this._name = name;\n  }\n\n  Object.defineProperty(GLTFLoaderExtension.prototype, \"name\", {\n    get: function get() {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Defines an override for loading the runtime\n   * Return true to stop further extensions from loading the runtime\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onSuccess\n   * @param onError\n   */\n\n  GLTFLoaderExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {\n    return false;\n  };\n  /**\n   * Defines an onverride for creating gltf runtime\n   * Return true to stop further extensions from creating the runtime\n   * @param gltfRuntime\n   * @param onSuccess\n   * @param onError\n   */\n\n\n  GLTFLoaderExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {\n    return false;\n  };\n  /**\n   * Defines an override for loading buffers\n   * Return true to stop further extensions from loading this buffer\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   * @param onProgress\n   */\n\n\n  GLTFLoaderExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    return false;\n  };\n  /**\n   * Defines an override for loading texture buffers\n   * Return true to stop further extensions from loading this texture data\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n\n\n  GLTFLoaderExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  };\n  /**\n   * Defines an override for creating textures\n   * Return true to stop further extensions from loading this texture\n   * @param gltfRuntime\n   * @param id\n   * @param buffer\n   * @param onSuccess\n   * @param onError\n   */\n\n\n  GLTFLoaderExtension.prototype.createTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {\n    return false;\n  };\n  /**\n   * Defines an override for loading shader strings\n   * Return true to stop further extensions from loading this shader data\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n\n\n  GLTFLoaderExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  };\n  /**\n   * Defines an override for loading materials\n   * Return true to stop further extensions from loading this material\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n\n\n  GLTFLoaderExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  }; // ---------\n  // Utilities\n  // ---------\n\n\n  GLTFLoaderExtension.LoadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\n    }, function () {\n      setTimeout(function () {\n        if (!onSuccess) {\n          return;\n        }\n\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\n      });\n    });\n  };\n\n  GLTFLoaderExtension.LoadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\n    }, function () {\n      setTimeout(function () {\n        onSuccess();\n      });\n    });\n  };\n\n  GLTFLoaderExtension.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    }, function () {\n      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    });\n  };\n\n  GLTFLoaderExtension.LoadTextureAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {\n      if (buffer) {\n        GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n      }\n    }, onError);\n  };\n\n  GLTFLoaderExtension.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension._LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension._CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\n    });\n  };\n\n  GLTFLoaderExtension._ApplyExtensions = function (func, defaultFunc) {\n    for (var extensionName in GLTFLoader.Extensions) {\n      var loaderExtension = GLTFLoader.Extensions[extensionName];\n\n      if (func(loaderExtension)) {\n        return;\n      }\n    }\n\n    defaultFunc();\n  };\n\n  return GLTFLoaderExtension;\n}();\n\nexport { GLTFLoaderExtension };\n\nGLTFFileLoader._CreateGLTF1Loader = function () {\n  return new GLTFLoader();\n};","map":{"version":3,"mappings":"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","names":["EParameterType","ETextureFilterType","ECullingType","EBlendingFunction","EShaderType","Quaternion","Vector3","Matrix","Color3","Tools","Camera","FreeCamera","Animation","Bone","Skeleton","Effect","Material","MultiMaterial","StandardMaterial","ShaderMaterial","Texture","VertexData","VertexBuffer","Geometry","SubMesh","AbstractMesh","Mesh","HemisphericLight","DirectionalLight","PointLight","SpotLight","GLTFUtils","GLTFFileLoader","Constants","ETokenType","toParse","UNKNOWN","_toParse","_maxPos","length","Tokenizer","isEnd","END_OF_INPUT","currentString","read","currentToken","isLetterOrDigitPattern","test","IDENTIFIER","currentIdentifier","peek","forward","_pos","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseBuffers","parsedBuffers","gltfRuntime","buf","parsedBuffer","buffers","buffersCount","parseShaders","parsedShaders","sha","parsedShader","shaders","shaderscount","parseObject","parsedObjects","runtimeProperty","object","parsedObject","normalizeUVs","buffer","i","getAttribute","attributeParameter","semantic","indexOf","channel","Number","split","loadAnimations","anim","animations","animation","channels","samplers","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","GetBufferFromAccessor","accessors","bufferOutput","targetId","target","id","targetNode","scene","getNodeById","getNodeByName","Warn","isBone","targetPath","path","targetPathIndex","animationType","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","rotationQuaternion","ANIMATIONTYPE_VECTOR3","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","_blockEntityCollection","assetContainer","ANIMATIONLOOPMODE_CYCLE","j","value","FromArray","bone","translation","Zero","scaling","mat","getBaseMatrix","decompose","Compose","push","frame","setKeys","stopAnimation","beginAnimation","configureBoneTransformation","node","rotation","scale","position","matrix","getParentBone","skins","jointName","newSkeleton","bones","name","nodes","nde","children","child","getNodeToRoot","nodesToRoot","nodeToRoot","getJointNode","nodeIsInJoints","jointNames","getNodesToRoot","k","_parent","importSkeleton","mesh","babylonSkeleton","nodesToRootToAdd","jointNode","existingBone","getBoneById","foundBone","parentBone","jointNode_1","joint","prepare","importMesh","meshes","newMesh","_parentContainer","babylonNode","subMaterials","vertexData","verticesStarts","Array","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","primitives","tempVertexData","primitive","mode","attributes","accessor","normals","Float32Array","set","HomogeneousCoordinates","positions","uvKind","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","material_1","getMaterialById","material","GetDefaultMaterial","computeWorldMatrix","subMeshes","index","AddToMesh","configureNode","newNode","configureNodeFromMatrix","importNode","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonById","light","lights","type","ambienLight","hemiLight","color","diffuse","directionalLight","dirLight","pointLight","ptLight","spotLight","spLight","fallOfAngle","angle","fallOffExponent","exponent","camera","cameras","orthoCamera","ORTHOGRAPHIC_CAMERA","attachControl","perspectiveCamera","persCamera","aspectRatio","getEngine","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","dummy","updateCache","traverseNodes","parent","meshIncluded","postLoad","currentScene","thing","scenes","skeletons","MAX_VALUE","onBindShaderMaterial","unTreatedUniforms","shaderMaterial","technique","onSuccess","materialValues","values","unif","uniform","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","source","SetMatrix","getEffect","uniforms","SAMPLER_2D","texture","textures","babylonTexture","undefined","setTexture","SetUniform","prepareShaderMaterialUniforms","techniqueUniforms","onLoadTexture","uniformName","GLTFLoaderExtension","LoadTextureAsync","onShaderCompileError","program","onError","effect","error","dispose","onShaderCompileSuccess","_","onBind","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","materials","LoadMaterialAsync","GLTFLoaderBase","parsedData","rootUrl","extensions","bufferViews","images","programs","techniques","extensionsUsed","loadedBufferCount","loadedBufferViews","loadedShaderCount","dummyNodes","onProgress","IsBase64","uri","setTimeout","Uint8Array","DecodeBase64","LoadFile","data","request","status","statusText","createMipMaps","minFilter","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","samplingMode","BILINEAR_SAMPLINGMODE","blob","Blob","blobURL","URL","createObjectURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","GetWrapMode","wrapT","wrapV","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","CounterClockWiseSideOrientation","states","vertexShader","ShadersStore","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","attr","attribute","name_1","getNextToken","tokenType","foundAttribute","shaderPath","vertex","fragment","options","needAlphaBlending","enable","onCompiled","functions","cullFace","BACK","backFaceCulling","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","GLTFLoader","extension","Extensions","Error","meshesNames","useRightHandedSystem","LoadRuntimeAsync","_this","_createNodes","skl","_loadBuffersAsync","_loadShadersAsync","IncrementalLoading","Promise","resolve","reject","_importMeshAsync","particleSystems","animationGroups","transformNodes","geometries","message","LoadRuntimeExtensionsAsync","_loadAsync","onload","hasShaders","processShader","LoadShaderStringAsync","ArrayBuffer","VERTEX","bind","onLoad","hasBuffers","processBuffer","LoadBufferAsync","bufferView","byteLength","_name","Object","_ApplyExtensions","loaderExtension","loadRuntimeAsync","CreateRuntime","json","loadRuntimeExtensionsAsync","loadBufferAsync","_LoadTextureBufferAsync","_CreateTextureAsync","loadShaderStringAsync","loadMaterialAsync","loadTextureBufferAsync","LoadTextureBufferAsync","createTextureAsync","CreateTextureAsync","func","defaultFunc","extensionName","_CreateGLTF1Loader"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/1.0/glTFLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n */\r\nconst getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = configureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n */\r\nconst getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n */\r\nconst getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n */\r\nconst nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = configureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n */\r\nconst importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n */\r\nconst importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts = new Array<number>();\r\n    const verticesCounts = new Array<number>();\r\n    const indexStarts = new Array<number>();\r\n    const indexCounts = new Array<number>();\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n */\r\nconst importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst onBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(<Effect>shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst prepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n */\r\nconst onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n */\r\nconst onShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n */\r\nconst parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @hidden\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @hidden\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes = new Array<AbstractMesh>();\r\n                const skeletons = new Array<Skeleton>();\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(<AbstractMesh>node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                importMaterials(gltfRuntime);\r\n                                postLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @hidden */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     */\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n"]},"metadata":{},"sourceType":"module"}