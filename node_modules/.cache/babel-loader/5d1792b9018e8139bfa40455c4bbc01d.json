{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools.js\";\n/**\n * Class used to inline functions in shader code\n */\n\nvar ShaderCodeInliner =\n/** @class */\nfunction () {\n  /**\n   * Initializes the inliner\n   * @param sourceCode shader code source to inline\n   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\n   */\n  function ShaderCodeInliner(sourceCode, numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n    /** Gets or sets the debug mode */\n\n\n    this.debug = false;\n    this._sourceCode = sourceCode;\n    this._numMaxIterations = numMaxIterations;\n    this._functionDescr = [];\n    this.inlineToken = \"#define inline\";\n  }\n\n  Object.defineProperty(ShaderCodeInliner.prototype, \"code\", {\n    /** Gets the code after the inlining process */\n    get: function get() {\n      return this._sourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Start the processing of the shader code\n   */\n\n  ShaderCodeInliner.prototype.processCode = function () {\n    if (this.debug) {\n      console.log(\"Start inlining process (code size=\".concat(this._sourceCode.length, \")...\"));\n    }\n\n    this._collectFunctions();\n\n    this._processInlining(this._numMaxIterations);\n\n    if (this.debug) {\n      console.log(\"End of inlining process.\");\n    }\n  };\n\n  ShaderCodeInliner.prototype._collectFunctions = function () {\n    var startIndex = 0;\n\n    while (startIndex < this._sourceCode.length) {\n      // locate the function to inline and extract its name\n      var inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\n\n      if (inlineTokenIndex < 0) {\n        break;\n      }\n\n      var funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\n\n      if (funcParamsStartIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not find the opening parenthesis after the token. startIndex=\".concat(startIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n\n      if (!funcNameMatch) {\n        if (this.debug) {\n          console.warn(\"Could not extract the name/type of the function from: \".concat(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var _a = [funcNameMatch[3], funcNameMatch[4]],\n          funcType = _a[0],\n          funcName = _a[1]; // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\n\n      var funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\n\n      if (funcParamsEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the parameters the function '\".concat(funcName, \"' (type=\").concat(funcType, \"). funcParamsStartIndex=\").concat(funcParamsStartIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex); // extract the body of the function (with the curly brackets)\n\n\n      var funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\n\n      if (funcBodyStartIndex === this._sourceCode.length) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\".concat(funcName, \"' (type=\").concat(funcType, \"). funcParamsEndIndex=\").concat(funcParamsEndIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\n\n      if (funcBodyEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\".concat(funcName, \"' (type=\").concat(funcType, \"). funcBodyStartIndex=\").concat(funcBodyStartIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1); // process the parameters: extract each names\n\n\n      var params = RemoveComments(funcParams).split(\",\");\n      var paramNames = [];\n\n      for (var p = 0; p < params.length; ++p) {\n        var param = params[p].trim();\n        var idx = param.lastIndexOf(\" \");\n\n        if (idx >= 0) {\n          paramNames.push(param.substring(idx + 1));\n        }\n      }\n\n      if (funcType !== \"void\") {\n        // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\n        paramNames.push(\"return\");\n      } // collect the function\n\n\n      this._functionDescr.push({\n        name: funcName,\n        type: funcType,\n        parameters: paramNames,\n        body: funcBody,\n        callIndex: 0\n      });\n\n      startIndex = funcBodyEndIndex + 1; // remove the function from the source code\n\n      var partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\n      var partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\n      this._sourceCode = partBefore + partAfter;\n      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\n    }\n\n    if (this.debug) {\n      console.log(\"Collect functions: \".concat(this._functionDescr.length, \" functions found. functionDescr=\"), this._functionDescr);\n    }\n  };\n\n  ShaderCodeInliner.prototype._processInlining = function (numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n\n    while (numMaxIterations-- >= 0) {\n      if (!this._replaceFunctionCallsByCode()) {\n        break;\n      }\n    }\n\n    if (this.debug) {\n      console.log(\"numMaxIterations is \".concat(numMaxIterations, \" after inlining process\"));\n    }\n\n    return numMaxIterations >= 0;\n  };\n\n  ShaderCodeInliner.prototype._replaceFunctionCallsByCode = function () {\n    var doAgain = false;\n\n    for (var _i = 0, _a = this._functionDescr; _i < _a.length; _i++) {\n      var func = _a[_i];\n      var name_1 = func.name,\n          type = func.type,\n          parameters = func.parameters,\n          body = func.body;\n      var startIndex = 0;\n\n      while (startIndex < this._sourceCode.length) {\n        // Look for the function name in the source code\n        var functionCallIndex = this._sourceCode.indexOf(name_1, startIndex);\n\n        if (functionCallIndex < 0) {\n          break;\n        } // Make sure \"name\" is not part of a bigger string\n\n\n        if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        } // Find the opening parenthesis\n\n\n        var callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name_1.length);\n\n        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        } // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\n\n\n        var callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\n\n        if (callParamsEndIndex < 0) {\n          if (this.debug) {\n            console.warn(\"Could not extract the parameters of the function call. Function '\".concat(name_1, \"' (type=\").concat(type, \"). callParamsStartIndex=\").concat(callParamsStartIndex));\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        var callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex); // process the parameter call: extract each names\n        // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\n        //      myfunc(a, vec2(1., 0.), 4.)\n\n\n        var splitParameterCall = function splitParameterCall(s) {\n          var parameters = [];\n          var curIdx = 0,\n              startParamIdx = 0;\n\n          while (curIdx < s.length) {\n            if (s.charAt(curIdx) === \"(\") {\n              var idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\n\n              if (idx2 < 0) {\n                return null;\n              }\n\n              curIdx = idx2;\n            } else if (s.charAt(curIdx) === \",\") {\n              parameters.push(s.substring(startParamIdx, curIdx));\n              startParamIdx = curIdx + 1;\n            }\n\n            curIdx++;\n          }\n\n          if (startParamIdx < curIdx) {\n            parameters.push(s.substring(startParamIdx, curIdx));\n          }\n\n          return parameters;\n        };\n\n        var params = splitParameterCall(RemoveComments(callParams));\n\n        if (params === null) {\n          if (this.debug) {\n            console.warn(\"Invalid function call: can't extract the parameters of the function call. Function '\".concat(name_1, \"' (type=\").concat(type, \"). callParamsStartIndex=\").concat(callParamsStartIndex, \", callParams=\") + callParams);\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        var paramNames = [];\n\n        for (var p = 0; p < params.length; ++p) {\n          var param = params[p].trim();\n          paramNames.push(param);\n        }\n\n        var retParamName = type !== \"void\" ? name_1 + \"_\" + func.callIndex++ : null;\n\n        if (retParamName) {\n          paramNames.push(retParamName + \" =\");\n        }\n\n        if (paramNames.length !== parameters.length) {\n          if (this.debug) {\n            console.warn(\"Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '\".concat(name_1, \"' (type=\").concat(type, \"). function parameters=\").concat(parameters, \", call parameters=\").concat(paramNames));\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        startIndex = callParamsEndIndex + 1; // replace the function call by the body function\n\n        var funcBody = this._replaceNames(body, parameters, paramNames);\n\n        var partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\n        var partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\n\n        if (retParamName) {\n          // case where the function returns a value. We generate:\n          // FUNCTYPE retParamName;\n          // {function body}\n          // and replace the function call by retParamName\n          var injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\");\n          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\n\n          var partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\n\n          this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\".concat(name_1, \"' (type=\").concat(type, \"). injectDeclarationIndex=\").concat(injectDeclarationIndex, \", call parameters=\").concat(paramNames));\n          }\n        } else {\n          // simple case where the return value of the function is \"void\"\n          this._sourceCode = partBefore + funcBody + partAfter;\n          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\".concat(name_1, \"' (type=\").concat(type, \"). functionCallIndex=\").concat(functionCallIndex, \", call parameters=\").concat(paramNames));\n          }\n        }\n\n        doAgain = true;\n      }\n    }\n\n    return doAgain;\n  };\n\n  ShaderCodeInliner.prototype._replaceNames = function (code, sources, destinations) {\n    var _loop_1 = function _loop_1(i) {\n      var source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\n          sourceLen = sources[i].length,\n          destination = destinations[i];\n      code = code.replace(source, function (match) {\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments[_i];\n        }\n\n        var offset = args[0]; // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\n\n        if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\n          return sources[i];\n        }\n\n        return destination;\n      });\n    };\n\n    for (var i = 0; i < sources.length; ++i) {\n      _loop_1(i);\n    }\n\n    return code;\n  };\n\n  ShaderCodeInliner._RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\n  return ShaderCodeInliner;\n}();\n\nexport { ShaderCodeInliner };","map":{"version":3,"mappings":"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","names":["EscapeRegExp","ExtractBetweenMarkers","FindBackward","IsIdentifierChar","RemoveComments","SkipWhitespaces","sourceCode","numMaxIterations","_sourceCode","_numMaxIterations","_functionDescr","inlineToken","Object","ShaderCodeInliner","debug","console","log","length","_collectFunctions","_processInlining","startIndex","inlineTokenIndex","indexOf","funcParamsStartIndex","warn","funcNameMatch","_RegexpFindFunctionNameAndType","exec","substring","funcType","funcName","funcParamsEndIndex","concat","funcParams","funcBodyStartIndex","funcBodyEndIndex","funcBody","params","split","paramNames","p","param","trim","idx","lastIndexOf","push","name","type","parameters","body","callIndex","partBefore","partAfter","_replaceFunctionCallsByCode","doAgain","_i","func","functionCallIndex","name_1","charAt","callParamsStartIndex","callParamsEndIndex","callParams","splitParameterCall","s","curIdx","startParamIdx","idx2","retParamName","_replaceNames","injectDeclarationIndex","partBetween","code","sources","destinations","i","source","RegExp","sourceLen","destination","replace","match","args","offset"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Processors/shaderCodeInliner.ts"],"sourcesContent":["import { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            console.log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            console.log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    console.warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        console.warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        console.warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        console.warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        console.log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}