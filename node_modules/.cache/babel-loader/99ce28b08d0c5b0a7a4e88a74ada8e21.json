{"ast":null,"code":"import \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"./math.scalar.js\";\nimport { Epsilon } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { PerformanceConfigurator } from \"../Engines/performanceConfigurator.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\"; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _ExtractAsInt = function _ExtractAsInt(value) {\n  return parseInt(value.toString().replace(/\\W/g, \"\"));\n};\n/**\n * Class representing a vector containing 2 coordinates\n */\n\n\nvar Vector2 =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Vector2 from the given x and y coordinates\n   * @param x defines the first coordinate\n   * @param y defines the second coordinate\n   */\n  function Vector2(\n  /** defines the first coordinate */\n  x,\n  /** defines the second coordinate */\n  y) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Gets a string with the Vector2 coordinates\n   * @returns a string with the Vector2 coordinates\n   */\n\n\n  Vector2.prototype.toString = function () {\n    return \"{X: \".concat(this.x, \" Y: \").concat(this.y, \"}\");\n  };\n  /**\n   * Gets class name\n   * @returns the string \"Vector2\"\n   */\n\n\n  Vector2.prototype.getClassName = function () {\n    return \"Vector2\";\n  };\n  /**\n   * Gets current vector hash code\n   * @returns the Vector2 hash code as a number\n   */\n\n\n  Vector2.prototype.getHashCode = function () {\n    var x = _ExtractAsInt(this.x);\n\n    var y = _ExtractAsInt(this.y);\n\n    var hash = x;\n    hash = hash * 397 ^ y;\n    return hash;\n  }; // Operators\n\n  /**\n   * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\n   * @param array defines the source array\n   * @param index defines the offset in source array\n   * @returns the current Vector2\n   */\n\n\n  Vector2.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this.x;\n    array[index + 1] = this.y;\n    return this;\n  };\n  /**\n   * Update the current vector from an array\n   * @param array defines the destination array\n   * @param index defines the offset in the destination array\n   * @returns the current Vector3\n   */\n\n\n  Vector2.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector2.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\n   * Copy the current vector to an array\n   * @returns a new array with 2 elements: the Vector2 coordinates.\n   */\n\n\n  Vector2.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\n   * Sets the Vector2 coordinates with the given Vector2 coordinates\n   * @param source defines the source Vector2\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.copyFrom = function (source) {\n    this.x = source.x;\n    this.y = source.y;\n    return this;\n  };\n  /**\n   * Sets the Vector2 coordinates with the given floats\n   * @param x defines the first coordinate\n   * @param y defines the second coordinate\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.copyFromFloats = function (x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  };\n  /**\n   * Sets the Vector2 coordinates with the given floats\n   * @param x defines the first coordinate\n   * @param y defines the second coordinate\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.set = function (x, y) {\n    return this.copyFromFloats(x, y);\n  };\n  /**\n   * Add another vector with the current one\n   * @param otherVector defines the other vector\n   * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\n   */\n\n\n  Vector2.prototype.add = function (otherVector) {\n    return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n  };\n  /**\n   * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\n   * @param otherVector defines the other vector\n   * @param result defines the target vector\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.addToRef = function (otherVector, result) {\n    result.x = this.x + otherVector.x;\n    result.y = this.y + otherVector.y;\n    return this;\n  };\n  /**\n   * Set the Vector2 coordinates by adding the given Vector2 coordinates\n   * @param otherVector defines the other vector\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.addInPlace = function (otherVector) {\n    this.x += otherVector.x;\n    this.y += otherVector.y;\n    return this;\n  };\n  /**\n   * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\n   * @param otherVector defines the other vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.addVector3 = function (otherVector) {\n    return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n  };\n  /**\n   * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\n   * @param otherVector defines the other vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.subtract = function (otherVector) {\n    return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n  };\n  /**\n   * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\n   * @param otherVector defines the other vector\n   * @param result defines the target vector\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.subtractToRef = function (otherVector, result) {\n    result.x = this.x - otherVector.x;\n    result.y = this.y - otherVector.y;\n    return this;\n  };\n  /**\n   * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\n   * @param otherVector defines the other vector\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector.x;\n    this.y -= otherVector.y;\n    return this;\n  };\n  /**\n   * Multiplies in place the current Vector2 coordinates by the given ones\n   * @param otherVector defines the other vector\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector.x;\n    this.y *= otherVector.y;\n    return this;\n  };\n  /**\n   * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\n   * @param otherVector defines the other vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.multiply = function (otherVector) {\n    return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n  };\n  /**\n   * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\n   * @param otherVector defines the other vector\n   * @param result defines the target vector\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.multiplyToRef = function (otherVector, result) {\n    result.x = this.x * otherVector.x;\n    result.y = this.y * otherVector.y;\n    return this;\n  };\n  /**\n   * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\n   * @param x defines the first coordinate\n   * @param y defines the second coordinate\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.multiplyByFloats = function (x, y) {\n    return new Vector2(this.x * x, this.y * y);\n  };\n  /**\n   * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\n   * @param otherVector defines the other vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.divide = function (otherVector) {\n    return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n  };\n  /**\n   * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\n   * @param otherVector defines the other vector\n   * @param result defines the target vector\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.divideToRef = function (otherVector, result) {\n    result.x = this.x / otherVector.x;\n    result.y = this.y / otherVector.y;\n    return this;\n  };\n  /**\n   * Divides the current Vector2 coordinates by the given ones\n   * @param otherVector defines the other vector\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\n   * Gets a new Vector2 with current Vector2 negated coordinates\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.negate = function () {\n    return new Vector2(-this.x, -this.y);\n  };\n  /**\n   * Negate this vector in place\n   * @returns this\n   */\n\n\n  Vector2.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    return this;\n  };\n  /**\n   * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector2\n   */\n\n\n  Vector2.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this.x * -1, this.y * -1);\n  };\n  /**\n   * Multiply the Vector2 coordinates by scale\n   * @param scale defines the scaling factor\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    return this;\n  };\n  /**\n   * Returns a new Vector2 scaled by \"scale\" from the current Vector2\n   * @param scale defines the scaling factor\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.scale = function (scale) {\n    var result = new Vector2(0, 0);\n    this.scaleToRef(scale, result);\n    return result;\n  };\n  /**\n   * Scale the current Vector2 values by a factor to a given Vector2\n   * @param scale defines the scale factor\n   * @param result defines the Vector2 object where to store the result\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.scaleToRef = function (scale, result) {\n    result.x = this.x * scale;\n    result.y = this.y * scale;\n    return this;\n  };\n  /**\n   * Scale the current Vector2 values by a factor and add the result to a given Vector2\n   * @param scale defines the scale factor\n   * @param result defines the Vector2 object where to store the result\n   * @returns the unmodified current Vector2\n   */\n\n\n  Vector2.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this.x * scale;\n    result.y += this.y * scale;\n    return this;\n  };\n  /**\n   * Gets a boolean if two vectors are equals\n   * @param otherVector defines the other vector\n   * @returns true if the given vector coordinates strictly equal the current Vector2 ones\n   */\n\n\n  Vector2.prototype.equals = function (otherVector) {\n    return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n  };\n  /**\n   * Gets a boolean if two vectors are equals (using an epsilon value)\n   * @param otherVector defines the other vector\n   * @param epsilon defines the minimal distance to consider equality\n   * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\n   */\n\n\n  Vector2.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\n  };\n  /**\n   * Gets a new Vector2 from current Vector2 floored values\n   * eg (1.2, 2.31) returns (1, 2)\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.floor = function () {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  };\n  /**\n   * Gets a new Vector2 from current Vector2 fractional values\n   * eg (1.2, 2.31) returns (0.2, 0.31)\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.fract = function () {\n    return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n  };\n  /**\n   * Rotate the current vector into a given result vector\n   * @param angle defines the rotation angle\n   * @param result defines the result vector where to store the rotated vector\n   * @returns the current vector\n   */\n\n\n  Vector2.prototype.rotateToRef = function (angle, result) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    result.x = cos * this.x - sin * this.y;\n    result.y = sin * this.x + cos * this.y;\n    return this;\n  }; // Properties\n\n  /**\n   * Gets the length of the vector\n   * @returns the vector length (float)\n   */\n\n\n  Vector2.prototype.length = function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  };\n  /**\n   * Gets the vector squared length\n   * @returns the vector squared length (float)\n   */\n\n\n  Vector2.prototype.lengthSquared = function () {\n    return this.x * this.x + this.y * this.y;\n  }; // Methods\n\n  /**\n   * Normalize the vector\n   * @returns the current updated Vector2\n   */\n\n\n  Vector2.prototype.normalize = function () {\n    Vector2.NormalizeToRef(this, this);\n    return this;\n  };\n  /**\n   * Gets a new Vector2 copied from the Vector2\n   * @returns a new Vector2\n   */\n\n\n  Vector2.prototype.clone = function () {\n    return new Vector2(this.x, this.y);\n  }; // Statics\n\n  /**\n   * Gets a new Vector2(0, 0)\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Zero = function () {\n    return new Vector2(0, 0);\n  };\n  /**\n   * Gets a new Vector2(1, 1)\n   * @returns a new Vector2\n   */\n\n\n  Vector2.One = function () {\n    return new Vector2(1, 1);\n  };\n  /**\n   * Gets a new Vector2 set from the given index element of the given array\n   * @param array defines the data source\n   * @param offset defines the offset in the data source\n   * @returns a new Vector2\n   */\n\n\n  Vector2.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Vector2(array[offset], array[offset + 1]);\n  };\n  /**\n   * Sets \"result\" from the given index element of the given array\n   * @param array defines the data source\n   * @param offset defines the offset in the data source\n   * @param result defines the target vector\n   */\n\n\n  Vector2.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n  };\n  /**\n   * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\n   * @param value1 defines 1st point of control\n   * @param value2 defines 2nd point of control\n   * @param value3 defines 3rd point of control\n   * @param value4 defines 4th point of control\n   * @param amount defines the interpolation factor\n   * @returns a new Vector2\n   */\n\n\n  Vector2.CatmullRom = function (value1, value2, value3, value4, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var x = 0.5 * (2.0 * value2.x + (-value1.x + value3.x) * amount + (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) * squared + (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n    var y = 0.5 * (2.0 * value2.y + (-value1.y + value3.y) * amount + (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) * squared + (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n    return new Vector2(x, y);\n  };\n  /**\n   * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n   * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n   * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\n   * @param value defines the value to clamp\n   * @param min defines the lower limit\n   * @param max defines the upper limit\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Clamp = function (value, min, max) {\n    var x = value.x;\n    x = x > max.x ? max.x : x;\n    x = x < min.x ? min.x : x;\n    var y = value.y;\n    y = y > max.y ? max.y : y;\n    y = y < min.y ? min.y : y;\n    return new Vector2(x, y);\n  };\n  /**\n   * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\"\n   * @param value1 defines the 1st control point\n   * @param tangent1 defines the outgoing tangent\n   * @param value2 defines the 2nd control point\n   * @param tangent2 defines the incoming tangent\n   * @param amount defines the interpolation factor\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;\n    var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;\n    return new Vector2(x, y);\n  };\n  /**\n   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n\n\n  Vector2.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n    var result = Vector2.Zero();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  };\n  /**\n   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where the derivative will be stored\n   */\n\n\n  Vector2.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n    var t2 = time * time;\n    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n  };\n  /**\n   * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n   * @param start defines the start vector\n   * @param end defines the end vector\n   * @param amount defines the interpolation factor\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Lerp = function (start, end, amount) {\n    var x = start.x + (end.x - start.x) * amount;\n    var y = start.y + (end.y - start.y) * amount;\n    return new Vector2(x, y);\n  };\n  /**\n   * Gets the dot product of the vector \"left\" and the vector \"right\"\n   * @param left defines first vector\n   * @param right defines second vector\n   * @returns the dot product (float)\n   */\n\n\n  Vector2.Dot = function (left, right) {\n    return left.x * right.x + left.y * right.y;\n  };\n  /**\n   * Returns a new Vector2 equal to the normalized given vector\n   * @param vector defines the vector to normalize\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Normalize = function (vector) {\n    var newVector = Vector2.Zero();\n    this.NormalizeToRef(vector, newVector);\n    return newVector;\n  };\n  /**\n   * Normalize a given vector into a second one\n   * @param vector defines the vector to normalize\n   * @param result defines the vector where to store the result\n   */\n\n\n  Vector2.NormalizeToRef = function (vector, result) {\n    var len = vector.length();\n\n    if (len === 0) {\n      return;\n    }\n\n    result.x = vector.x / len;\n    result.y = vector.y / len;\n  };\n  /**\n   * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\n   * @param left defines 1st vector\n   * @param right defines 2nd vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Minimize = function (left, right) {\n    var x = left.x < right.x ? left.x : right.x;\n    var y = left.y < right.y ? left.y : right.y;\n    return new Vector2(x, y);\n  };\n  /**\n   * Gets a new Vector2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\n   * @param left defines 1st vector\n   * @param right defines 2nd vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Maximize = function (left, right) {\n    var x = left.x > right.x ? left.x : right.x;\n    var y = left.y > right.y ? left.y : right.y;\n    return new Vector2(x, y);\n  };\n  /**\n   * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\n   * @param vector defines the vector to transform\n   * @param transformation defines the matrix to apply\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Transform = function (vector, transformation) {\n    var r = Vector2.Zero();\n    Vector2.TransformToRef(vector, transformation, r);\n    return r;\n  };\n  /**\n   * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\n   * @param vector defines the vector to transform\n   * @param transformation defines the matrix to apply\n   * @param result defines the target vector\n   */\n\n\n  Vector2.TransformToRef = function (vector, transformation, result) {\n    var m = transformation.m;\n    var x = vector.x * m[0] + vector.y * m[4] + m[12];\n    var y = vector.x * m[1] + vector.y * m[5] + m[13];\n    result.x = x;\n    result.y = y;\n  };\n  /**\n   * Determines if a given vector is included in a triangle\n   * @param p defines the vector to test\n   * @param p0 defines 1st triangle point\n   * @param p1 defines 2nd triangle point\n   * @param p2 defines 3rd triangle point\n   * @returns true if the point \"p\" is in the triangle defined by the vectors \"p0\", \"p1\", \"p2\"\n   */\n\n\n  Vector2.PointInTriangle = function (p, p0, p1, p2) {\n    var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n    var sign = a < 0 ? -1 : 1;\n    var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n    var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n    return s > 0 && t > 0 && s + t < 2 * a * sign;\n  };\n  /**\n   * Gets the distance between the vectors \"value1\" and \"value2\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @returns the distance between vectors\n   */\n\n\n  Vector2.Distance = function (value1, value2) {\n    return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n  };\n  /**\n   * Returns the squared distance between the vectors \"value1\" and \"value2\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @returns the squared distance between vectors\n   */\n\n\n  Vector2.DistanceSquared = function (value1, value2) {\n    var x = value1.x - value2.x;\n    var y = value1.y - value2.y;\n    return x * x + y * y;\n  };\n  /**\n   * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @returns a new Vector2\n   */\n\n\n  Vector2.Center = function (value1, value2) {\n    return Vector2.CenterToRef(value1, value2, Vector2.Zero());\n  };\n  /**\n   * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @param ref defines third vector\n   * @returns ref\n   */\n\n\n  Vector2.CenterToRef = function (value1, value2, ref) {\n    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);\n  };\n  /**\n   * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n   * @param p defines the middle point\n   * @param segA defines one point of the segment\n   * @param segB defines the other point of the segment\n   * @returns the shortest distance\n   */\n\n\n  Vector2.DistanceOfPointFromSegment = function (p, segA, segB) {\n    var l2 = Vector2.DistanceSquared(segA, segB);\n\n    if (l2 === 0.0) {\n      return Vector2.Distance(p, segA);\n    }\n\n    var v = segB.subtract(segA);\n    var t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n    var proj = segA.add(v.multiplyByFloats(t, t));\n    return Vector2.Distance(p, proj);\n  };\n\n  return Vector2;\n}();\n\nexport { Vector2 };\n/**\n * Class used to store (x,y,z) vector representation\n * A Vector3 is the main object used in 3D geometry\n * It can represent either the coordinates of a point the space, either a direction\n * Reminder: js uses a left handed forward facing system\n */\n\nvar Vector3 =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\n   * @param x defines the first coordinates (on X axis)\n   * @param y defines the second coordinates (on Y axis)\n   * @param z defines the third coordinates (on Z axis)\n   */\n  function Vector3(x, y, z) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (z === void 0) {\n      z = 0;\n    }\n    /** @hidden */\n\n\n    this._isDirty = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n  }\n\n  Object.defineProperty(Vector3.prototype, \"x\", {\n    /** Gets or sets the x coordinate */\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3.prototype, \"y\", {\n    /** Gets or sets the y coordinate */\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3.prototype, \"z\", {\n    /** Gets or sets the z coordinate */\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      this._z = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a string representation of the Vector3\n   * @returns a string with the Vector3 coordinates.\n   */\n\n  Vector3.prototype.toString = function () {\n    return \"{X: \".concat(this._x, \" Y: \").concat(this._y, \" Z: \").concat(this._z, \"}\");\n  };\n  /**\n   * Gets the class name\n   * @returns the string \"Vector3\"\n   */\n\n\n  Vector3.prototype.getClassName = function () {\n    return \"Vector3\";\n  };\n  /**\n   * Creates the Vector3 hash code\n   * @returns a number which tends to be unique between Vector3 instances\n   */\n\n\n  Vector3.prototype.getHashCode = function () {\n    var x = _ExtractAsInt(this._x);\n\n    var y = _ExtractAsInt(this._y);\n\n    var z = _ExtractAsInt(this._z);\n\n    var hash = x;\n    hash = hash * 397 ^ y;\n    hash = hash * 397 ^ z;\n    return hash;\n  }; // Operators\n\n  /**\n   * Creates an array containing three elements : the coordinates of the Vector3\n   * @returns a new array of numbers\n   */\n\n\n  Vector3.prototype.asArray = function () {\n    var result = [];\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\n   * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\n   * @param array defines the destination array\n   * @param index defines the offset in the destination array\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this._x;\n    array[index + 1] = this._y;\n    array[index + 2] = this._z;\n    return this;\n  };\n  /**\n   * Update the current vector from an array\n   * @param array defines the destination array\n   * @param index defines the offset in the destination array\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector3.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\n   * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\n   * @returns a new Quaternion object, computed from the Vector3 coordinates\n   */\n\n\n  Vector3.prototype.toQuaternion = function () {\n    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\n  };\n  /**\n   * Adds the given vector to the current Vector3\n   * @param otherVector defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.addInPlace = function (otherVector) {\n    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\n  };\n  /**\n   * Adds the given coordinates to the current Vector3\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.addInPlaceFromFloats = function (x, y, z) {\n    this.x += x;\n    this.y += y;\n    this.z += z;\n    return this;\n  };\n  /**\n   * Gets a new Vector3, result of the addition the current Vector3 and the given vector\n   * @param otherVector defines the second operand\n   * @returns the resulting Vector3\n   */\n\n\n  Vector3.prototype.add = function (otherVector) {\n    return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n  };\n  /**\n   * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\n   * @param otherVector defines the second operand\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.addToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n  };\n  /**\n   * Subtract the given vector from the current Vector3\n   * @param otherVector defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector._x;\n    this.y -= otherVector._y;\n    this.z -= otherVector._z;\n    return this;\n  };\n  /**\n   * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\n   * @param otherVector defines the second operand\n   * @returns the resulting Vector3\n   */\n\n\n  Vector3.prototype.subtract = function (otherVector) {\n    return new Vector3(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\n  };\n  /**\n   * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\n   * @param otherVector defines the second operand\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.subtractToRef = function (otherVector, result) {\n    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\n  };\n  /**\n   * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the resulting Vector3\n   */\n\n\n  Vector3.prototype.subtractFromFloats = function (x, y, z) {\n    return new Vector3(this._x - x, this._y - y, this._z - z);\n  };\n  /**\n   * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.subtractFromFloatsToRef = function (x, y, z, result) {\n    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\n  };\n  /**\n   * Gets a new Vector3 set with the current Vector3 negated coordinates\n   * @returns a new Vector3\n   */\n\n\n  Vector3.prototype.negate = function () {\n    return new Vector3(-this._x, -this._y, -this._z);\n  };\n  /**\n   * Negate this vector in place\n   * @returns this\n   */\n\n\n  Vector3.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  };\n  /**\n   * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\n  };\n  /**\n   * Multiplies the Vector3 coordinates by the float \"scale\"\n   * @param scale defines the multiplier factor\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    this.z *= scale;\n    return this;\n  };\n  /**\n   * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\n   * @param scale defines the multiplier factor\n   * @returns a new Vector3\n   */\n\n\n  Vector3.prototype.scale = function (scale) {\n    return new Vector3(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\n   * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\n   * @param scale defines the multiplier factor\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.scaleToRef = function (scale, result) {\n    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\n   * Scale the current Vector3 values by a factor and add the result to a given Vector3\n   * @param scale defines the scale factor\n   * @param result defines the Vector3 object where to store the result\n   * @returns the unmodified current Vector3\n   */\n\n\n  Vector3.prototype.scaleAndAddToRef = function (scale, result) {\n    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\n   * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\n   * @param plane defines the plane to project to\n   * @param origin defines the origin of the projection ray\n   * @returns the projected vector3\n   */\n\n\n  Vector3.prototype.projectOnPlane = function (plane, origin) {\n    var result = Vector3.Zero();\n    this.projectOnPlaneToRef(plane, origin, result);\n    return result;\n  };\n  /**\n   * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\n   * @param plane defines the plane to project to\n   * @param origin defines the origin of the projection ray\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.prototype.projectOnPlaneToRef = function (plane, origin, result) {\n    var n = plane.normal;\n    var d = plane.d;\n    var V = MathTmp.Vector3[0]; // ray direction\n\n    this.subtractToRef(origin, V);\n    V.normalize();\n    var denom = Vector3.Dot(V, n);\n    var t = -(Vector3.Dot(origin, n) + d) / denom; // P = P0 + t*V\n\n    var scaledV = V.scaleInPlace(t);\n    origin.addToRef(scaledV, result);\n  };\n  /**\n   * Returns true if the current Vector3 and the given vector coordinates are strictly equal\n   * @param otherVector defines the second operand\n   * @returns true if both vectors are equals\n   */\n\n\n  Vector3.prototype.equals = function (otherVector) {\n    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\n  };\n  /**\n   * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\n   * @param otherVector defines the second operand\n   * @param epsilon defines the minimal distance to define values as equals\n   * @returns true if both vectors are distant less than epsilon\n   */\n\n\n  Vector3.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);\n  };\n  /**\n   * Returns true if the current Vector3 coordinates equals the given floats\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns true if both vectors are equals\n   */\n\n\n  Vector3.prototype.equalsToFloats = function (x, y, z) {\n    return this._x === x && this._y === y && this._z === z;\n  };\n  /**\n   * Multiplies the current Vector3 coordinates by the given ones\n   * @param otherVector defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector._x;\n    this.y *= otherVector._y;\n    this.z *= otherVector._z;\n    return this;\n  };\n  /**\n   * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\n   * @param otherVector defines the second operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.prototype.multiply = function (otherVector) {\n    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\n  };\n  /**\n   * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\n   * @param otherVector defines the second operand\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.multiplyToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\n  };\n  /**\n   * Returns a new Vector3 set with the result of the multiplication of the current Vector3 coordinates by the given floats\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.prototype.multiplyByFloats = function (x, y, z) {\n    return new Vector3(this._x * x, this._y * y, this._z * z);\n  };\n  /**\n   * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\n   * @param otherVector defines the second operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.prototype.divide = function (otherVector) {\n    return new Vector3(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n  };\n  /**\n   * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\n   * @param otherVector defines the second operand\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector3\n   */\n\n\n  Vector3.prototype.divideToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n  };\n  /**\n   * Divides the current Vector3 coordinates by the given ones.\n   * @param otherVector defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\n   * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\n   * @param other defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.minimizeInPlace = function (other) {\n    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\n  };\n  /**\n   * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\n   * @param other defines the second operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.maximizeInPlace = function (other) {\n    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\n  };\n  /**\n   * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.minimizeInPlaceFromFloats = function (x, y, z) {\n    if (x < this._x) {\n      this.x = x;\n    }\n\n    if (y < this._y) {\n      this.y = y;\n    }\n\n    if (z < this._z) {\n      this.z = z;\n    }\n\n    return this;\n  };\n  /**\n   * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.maximizeInPlaceFromFloats = function (x, y, z) {\n    if (x > this._x) {\n      this.x = x;\n    }\n\n    if (y > this._y) {\n      this.y = y;\n    }\n\n    if (z > this._z) {\n      this.z = z;\n    }\n\n    return this;\n  };\n  /**\n   * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\n   * Check if is non uniform within a certain amount of decimal places to account for this\n   * @param epsilon the amount the values can differ\n   * @returns if the the vector is non uniform to a certain number of decimal places\n   */\n\n\n  Vector3.prototype.isNonUniformWithinEpsilon = function (epsilon) {\n    var absX = Math.abs(this._x);\n    var absY = Math.abs(this._y);\n\n    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\n      return true;\n    }\n\n    var absZ = Math.abs(this._z);\n\n    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\n      return true;\n    }\n\n    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(Vector3.prototype, \"isNonUniform\", {\n    /**\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\n     */\n    get: function get() {\n      var absX = Math.abs(this._x);\n      var absY = Math.abs(this._y);\n\n      if (absX !== absY) {\n        return true;\n      }\n\n      var absZ = Math.abs(this._z);\n\n      if (absX !== absZ) {\n        return true;\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a new Vector3 from current Vector3 floored values\n   * @returns a new Vector3\n   */\n\n  Vector3.prototype.floor = function () {\n    return new Vector3(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\n  };\n  /**\n   * Gets a new Vector3 from current Vector3 floored values\n   * @returns a new Vector3\n   */\n\n\n  Vector3.prototype.fract = function () {\n    return new Vector3(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\n  }; // Properties\n\n  /**\n   * Gets the length of the Vector3\n   * @returns the length of the Vector3\n   */\n\n\n  Vector3.prototype.length = function () {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\n  };\n  /**\n   * Gets the squared length of the Vector3\n   * @returns squared length of the Vector3\n   */\n\n\n  Vector3.prototype.lengthSquared = function () {\n    return this._x * this._x + this._y * this._y + this._z * this._z;\n  };\n  /**\n   * Normalize the current Vector3.\n   * Please note that this is an in place operation.\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.normalize = function () {\n    return this.normalizeFromLength(this.length());\n  };\n  /**\n   * Reorders the x y z properties of the vector in place\n   * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\n   * @returns the current updated vector\n   */\n\n\n  Vector3.prototype.reorderInPlace = function (order) {\n    var _this = this;\n\n    order = order.toLowerCase();\n\n    if (order === \"xyz\") {\n      return this;\n    }\n\n    MathTmp.Vector3[0].copyFrom(this);\n    [\"x\", \"y\", \"z\"].forEach(function (val, i) {\n      _this[val] = MathTmp.Vector3[0][order[i]];\n    });\n    return this;\n  };\n  /**\n   * Rotates the vector around 0,0,0 by a quaternion\n   * @param quaternion the rotation quaternion\n   * @param result vector to store the result\n   * @returns the resulting vector\n   */\n\n\n  Vector3.prototype.rotateByQuaternionToRef = function (quaternion, result) {\n    quaternion.toRotationMatrix(MathTmp.Matrix[0]);\n    Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\n    return result;\n  };\n  /**\n   * Rotates a vector around a given point\n   * @param quaternion the rotation quaternion\n   * @param point the point to rotate around\n   * @param result vector to store the result\n   * @returns the resulting vector\n   */\n\n\n  Vector3.prototype.rotateByQuaternionAroundPointToRef = function (quaternion, point, result) {\n    this.subtractToRef(point, MathTmp.Vector3[0]);\n    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\n    point.addToRef(MathTmp.Vector3[0], result);\n    return result;\n  };\n  /**\n   * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\n   * The cross product is then orthogonal to both current and \"other\"\n   * @param other defines the right operand\n   * @returns the cross product\n   */\n\n\n  Vector3.prototype.cross = function (other) {\n    return Vector3.Cross(this, other);\n  };\n  /**\n   * Normalize the current Vector3 with the given input length.\n   * Please note that this is an in place operation.\n   * @param len the length of the vector\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.normalizeFromLength = function (len) {\n    if (len === 0 || len === 1.0) {\n      return this;\n    }\n\n    return this.scaleInPlace(1.0 / len);\n  };\n  /**\n   * Normalize the current Vector3 to a new vector\n   * @returns the new Vector3\n   */\n\n\n  Vector3.prototype.normalizeToNew = function () {\n    var normalized = new Vector3(0, 0, 0);\n    this.normalizeToRef(normalized);\n    return normalized;\n  };\n  /**\n   * Normalize the current Vector3 to the reference\n   * @param reference define the Vector3 to update\n   * @returns the updated Vector3\n   */\n\n\n  Vector3.prototype.normalizeToRef = function (reference) {\n    var len = this.length();\n\n    if (len === 0 || len === 1.0) {\n      return reference.copyFromFloats(this._x, this._y, this._z);\n    }\n\n    return this.scaleToRef(1.0 / len, reference);\n  };\n  /**\n   * Creates a new Vector3 copied from the current Vector3\n   * @returns the new Vector3\n   */\n\n\n  Vector3.prototype.clone = function () {\n    return new Vector3(this._x, this._y, this._z);\n  };\n  /**\n   * Copies the given vector coordinates to the current Vector3 ones\n   * @param source defines the source Vector3\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.copyFrom = function (source) {\n    return this.copyFromFloats(source._x, source._y, source._z);\n  };\n  /**\n   * Copies the given floats to the current Vector3 coordinates\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.copyFromFloats = function (x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  };\n  /**\n   * Copies the given floats to the current Vector3 coordinates\n   * @param x defines the x coordinate of the operand\n   * @param y defines the y coordinate of the operand\n   * @param z defines the z coordinate of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.set = function (x, y, z) {\n    return this.copyFromFloats(x, y, z);\n  };\n  /**\n   * Copies the given float to the current Vector3 coordinates\n   * @param v defines the x, y and z coordinates of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector3.prototype.setAll = function (v) {\n    this.x = this.y = this.z = v;\n    return this;\n  }; // Statics\n\n  /**\n   * Get the clip factor between two vectors\n   * @param vector0 defines the first operand\n   * @param vector1 defines the second operand\n   * @param axis defines the axis to use\n   * @param size defines the size along the axis\n   * @returns the clip factor\n   */\n\n\n  Vector3.GetClipFactor = function (vector0, vector1, axis, size) {\n    var d0 = Vector3.Dot(vector0, axis) - size;\n    var d1 = Vector3.Dot(vector1, axis) - size;\n    var s = d0 / (d0 - d1);\n    return s;\n  };\n  /**\n   * Get angle between two vectors\n   * @param vector0 angle between vector0 and vector1\n   * @param vector1 angle between vector0 and vector1\n   * @param normal direction of the normal\n   * @return the angle between vector0 and vector1\n   */\n\n\n  Vector3.GetAngleBetweenVectors = function (vector0, vector1, normal) {\n    var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);\n    var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);\n    var dot = Vector3.Dot(v0, v1);\n    var angle = Math.acos(dot);\n    var n = MathTmp.Vector3[3];\n    Vector3.CrossToRef(v0, v1, n);\n\n    if (Vector3.Dot(n, normal) > 0) {\n      return isNaN(angle) ? 0 : angle;\n    }\n\n    return isNaN(angle) ? -Math.PI : -Math.acos(dot);\n  };\n  /**\n   * Get angle between two vectors projected on a plane\n   * @param vector0 angle between vector0 and vector1\n   * @param vector1 angle between vector0 and vector1\n   * @param normal Normal of the projection plane\n   * @returns the angle between vector0 and vector1 projected on the plane with the specified normal\n   */\n\n\n  Vector3.GetAngleBetweenVectorsOnPlane = function (vector0, vector1, normal) {\n    MathTmp.Vector3[0].copyFrom(vector0);\n    var v0 = MathTmp.Vector3[0];\n    MathTmp.Vector3[1].copyFrom(vector1);\n    var v1 = MathTmp.Vector3[1];\n    MathTmp.Vector3[2].copyFrom(normal);\n    var vNormal = MathTmp.Vector3[2];\n    var right = MathTmp.Vector3[3];\n    var forward = MathTmp.Vector3[4];\n    v0.normalize();\n    v1.normalize();\n    vNormal.normalize();\n    Vector3.CrossToRef(vNormal, v0, right);\n    Vector3.CrossToRef(right, vNormal, forward);\n    var angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));\n    return Scalar.NormalizeRadians(angle);\n  };\n  /**\n   * Slerp between two vectors. See also `SmoothToRef`\n   * @param vector0 Start vector\n   * @param vector1 End vector\n   * @param slerp amount (will be clamped between 0 and 1)\n   * @param result The slerped vector\n   */\n\n\n  Vector3.SlerpToRef = function (vector0, vector1, slerp, result) {\n    slerp = Scalar.Clamp(slerp, 0, 1);\n    var vector0Dir = MathTmp.Vector3[0];\n    var vector1Dir = MathTmp.Vector3[1];\n    vector0Dir.copyFrom(vector0);\n    var vector0Length = vector0Dir.length();\n    vector0Dir.normalizeFromLength(vector0Length);\n    vector1Dir.copyFrom(vector1);\n    var vector1Length = vector1Dir.length();\n    vector1Dir.normalizeFromLength(vector1Length);\n    var dot = Vector3.Dot(vector0Dir, vector1Dir);\n    var scale0;\n    var scale1;\n\n    if (dot < 1 - Epsilon) {\n      var omega = Math.acos(dot);\n      var invSin = 1 / Math.sin(omega);\n      scale0 = Math.sin((1 - slerp) * omega) * invSin;\n      scale1 = Math.sin(slerp * omega) * invSin;\n    } else {\n      // Use linear interpolation\n      scale0 = 1 - slerp;\n      scale1 = slerp;\n    }\n\n    vector0Dir.scaleInPlace(scale0);\n    vector1Dir.scaleInPlace(scale1);\n    result.copyFrom(vector0Dir).addInPlace(vector1Dir);\n    result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));\n  };\n  /**\n   * Smooth interpolation between two vectors using Slerp\n   * @param source source vector\n   * @param goal goal vector\n   * @param deltaTime current interpolation frame\n   * @param lerpTime total interpolation time\n   * @param result the smoothed vector\n   */\n\n\n  Vector3.SmoothToRef = function (source, goal, deltaTime, lerpTime, result) {\n    Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);\n  };\n  /**\n   * Returns a new Vector3 set from the index \"offset\" of the given array\n   * @param array defines the source array\n   * @param offset defines the offset in the source array\n   * @returns the new Vector3\n   */\n\n\n  Vector3.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n  };\n  /**\n   * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\n   * @param array defines the source array\n   * @param offset defines the offset in the source array\n   * @returns the new Vector3\n   * @deprecated Please use FromArray instead.\n   */\n\n\n  Vector3.FromFloatArray = function (array, offset) {\n    return Vector3.FromArray(array, offset);\n  };\n  /**\n   * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\n   * @param array defines the source array\n   * @param offset defines the offset in the source array\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n  };\n  /**\n   * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\n   * @param array defines the source array\n   * @param offset defines the offset in the source array\n   * @param result defines the Vector3 where to store the result\n   * @deprecated Please use FromArrayToRef instead.\n   */\n\n\n  Vector3.FromFloatArrayToRef = function (array, offset, result) {\n    return Vector3.FromArrayToRef(array, offset, result);\n  };\n  /**\n   * Sets the given vector \"result\" with the given floats.\n   * @param x defines the x coordinate of the source\n   * @param y defines the y coordinate of the source\n   * @param z defines the z coordinate of the source\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.FromFloatsToRef = function (x, y, z, result) {\n    result.copyFromFloats(x, y, z);\n  };\n  /**\n   * Returns a new Vector3 set to (0.0, 0.0, 0.0)\n   * @returns a new empty Vector3\n   */\n\n\n  Vector3.Zero = function () {\n    return new Vector3(0.0, 0.0, 0.0);\n  };\n  /**\n   * Returns a new Vector3 set to (1.0, 1.0, 1.0)\n   * @returns a new unit Vector3\n   */\n\n\n  Vector3.One = function () {\n    return new Vector3(1.0, 1.0, 1.0);\n  };\n  /**\n   * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n   * @returns a new up Vector3\n   */\n\n\n  Vector3.Up = function () {\n    return new Vector3(0.0, 1.0, 0.0);\n  };\n\n  Object.defineProperty(Vector3, \"UpReadOnly\", {\n    /**\n     * Gets a up Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._UpReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"RightReadOnly\", {\n    /**\n     * Gets a right Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._RightReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"LeftReadOnly\", {\n    /**\n     * Gets a left Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._LeftReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"LeftHandedForwardReadOnly\", {\n    /**\n     * Gets a forward Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._LeftHandedForwardReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"RightHandedForwardReadOnly\", {\n    /**\n     * Gets a forward Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._RightHandedForwardReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"ZeroReadOnly\", {\n    /**\n     * Gets a zero Vector3 that must not be updated\n     */\n    get: function get() {\n      return Vector3._ZeroReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns a new Vector3 set to (0.0, -1.0, 0.0)\n   * @returns a new down Vector3\n   */\n\n  Vector3.Down = function () {\n    return new Vector3(0.0, -1.0, 0.0);\n  };\n  /**\n   * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n   * @param rightHandedSystem is the scene right-handed (negative z)\n   * @returns a new forward Vector3\n   */\n\n\n  Vector3.Forward = function (rightHandedSystem) {\n    if (rightHandedSystem === void 0) {\n      rightHandedSystem = false;\n    }\n\n    return new Vector3(0.0, 0.0, rightHandedSystem ? -1.0 : 1.0);\n  };\n  /**\n   * Returns a new Vector3 set to (0.0, 0.0, -1.0)\n   * @param rightHandedSystem is the scene right-handed (negative-z)\n   * @returns a new forward Vector3\n   */\n\n\n  Vector3.Backward = function (rightHandedSystem) {\n    if (rightHandedSystem === void 0) {\n      rightHandedSystem = false;\n    }\n\n    return new Vector3(0.0, 0.0, rightHandedSystem ? 1.0 : -1.0);\n  };\n  /**\n   * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n   * @returns a new right Vector3\n   */\n\n\n  Vector3.Right = function () {\n    return new Vector3(1.0, 0.0, 0.0);\n  };\n  /**\n   * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n   * @returns a new left Vector3\n   */\n\n\n  Vector3.Left = function () {\n    return new Vector3(-1.0, 0.0, 0.0);\n  };\n  /**\n   * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\n   * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @returns the transformed Vector3\n   */\n\n\n  Vector3.TransformCoordinates = function (vector, transformation) {\n    var result = Vector3.Zero();\n    Vector3.TransformCoordinatesToRef(vector, transformation, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n   * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.TransformCoordinatesToRef = function (vector, transformation, result) {\n    Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n  };\n  /**\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n   * This method computes transformed coordinates only, not transformed direction vectors\n   * @param x define the x coordinate of the source vector\n   * @param y define the y coordinate of the source vector\n   * @param z define the z coordinate of the source vector\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n    var m = transformation.m;\n    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n    var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n    result.x = rx * rw;\n    result.y = ry * rw;\n    result.z = rz * rw;\n  };\n  /**\n   * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @returns the new Vector3\n   */\n\n\n  Vector3.TransformNormal = function (vector, transformation) {\n    var result = Vector3.Zero();\n    Vector3.TransformNormalToRef(vector, transformation, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.TransformNormalToRef = function (vector, transformation, result) {\n    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n   * @param x define the x coordinate of the source vector\n   * @param y define the y coordinate of the source vector\n   * @param z define the z coordinate of the source vector\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.TransformNormalFromFloatsToRef = function (x, y, z, transformation, result) {\n    var m = transformation.m;\n    result.x = x * m[0] + y * m[4] + z * m[8];\n    result.y = x * m[1] + y * m[5] + z * m[9];\n    result.z = x * m[2] + y * m[6] + z * m[10];\n  };\n  /**\n   * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\n   * @param value1 defines the first control point\n   * @param value2 defines the second control point\n   * @param value3 defines the third control point\n   * @param value4 defines the fourth control point\n   * @param amount defines the amount on the spline to use\n   * @returns the new Vector3\n   */\n\n\n  Vector3.CatmullRom = function (value1, value2, value3, value4, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var x = 0.5 * (2.0 * value2._x + (-value1._x + value3._x) * amount + (2.0 * value1._x - 5.0 * value2._x + 4.0 * value3._x - value4._x) * squared + (-value1._x + 3.0 * value2._x - 3.0 * value3._x + value4._x) * cubed);\n    var y = 0.5 * (2.0 * value2._y + (-value1._y + value3._y) * amount + (2.0 * value1._y - 5.0 * value2._y + 4.0 * value3._y - value4._y) * squared + (-value1._y + 3.0 * value2._y - 3.0 * value3._y + value4._y) * cubed);\n    var z = 0.5 * (2.0 * value2._z + (-value1._z + value3._z) * amount + (2.0 * value1._z - 5.0 * value2._z + 4.0 * value3._z - value4._z) * squared + (-value1._z + 3.0 * value2._z - 3.0 * value3._z + value4._z) * cubed);\n    return new Vector3(x, y, z);\n  };\n  /**\n   * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n   * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n   * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n   * @param value defines the current value\n   * @param min defines the lower range value\n   * @param max defines the upper range value\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Clamp = function (value, min, max) {\n    var v = new Vector3();\n    Vector3.ClampToRef(value, min, max, v);\n    return v;\n  };\n  /**\n   * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n   * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n   * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n   * @param value defines the current value\n   * @param min defines the lower range value\n   * @param max defines the upper range value\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.ClampToRef = function (value, min, max, result) {\n    var x = value._x;\n    x = x > max._x ? max._x : x;\n    x = x < min._x ? min._x : x;\n    var y = value._y;\n    y = y > max._y ? max._y : y;\n    y = y < min._y ? min._y : y;\n    var z = value._z;\n    z = z > max._z ? max._z : z;\n    z = z < min._z ? min._z : z;\n    result.copyFromFloats(x, y, z);\n  };\n  /**\n   * Checks if a given vector is inside a specific range\n   * @param v defines the vector to test\n   * @param min defines the minimum range\n   * @param max defines the maximum range\n   */\n\n\n  Vector3.CheckExtends = function (v, min, max) {\n    min.minimizeInPlace(v);\n    max.maximizeInPlace(v);\n  };\n  /**\n   * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent vector\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent vector\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n    return new Vector3(x, y, z);\n  };\n  /**\n   * Returns a new Vector3 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n\n\n  Vector3.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n    var result = Vector3.Zero();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  };\n  /**\n   * Update a Vector3 with the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n\n\n  Vector3.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n    var t2 = time * time;\n    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\n  };\n  /**\n   * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\n   * @param start defines the start value\n   * @param end defines the end value\n   * @param amount max defines amount between both (between 0 and 1)\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Lerp = function (start, end, amount) {\n    var result = new Vector3(0, 0, 0);\n    Vector3.LerpToRef(start, end, amount, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\n   * @param start defines the start value\n   * @param end defines the end value\n   * @param amount max defines amount between both (between 0 and 1)\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.LerpToRef = function (start, end, amount, result) {\n    result.x = start._x + (end._x - start._x) * amount;\n    result.y = start._y + (end._y - start._y) * amount;\n    result.z = start._z + (end._z - start._z) * amount;\n  };\n  /**\n   * Returns the dot product (float) between the vectors \"left\" and \"right\"\n   * @param left defines the left operand\n   * @param right defines the right operand\n   * @returns the dot product\n   */\n\n\n  Vector3.Dot = function (left, right) {\n    return left._x * right._x + left._y * right._y + left._z * right._z;\n  };\n  /**\n   * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\n   * The cross product is then orthogonal to both \"left\" and \"right\"\n   * @param left defines the left operand\n   * @param right defines the right operand\n   * @returns the cross product\n   */\n\n\n  Vector3.Cross = function (left, right) {\n    var result = Vector3.Zero();\n    Vector3.CrossToRef(left, right, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\n   * The cross product is then orthogonal to both \"left\" and \"right\"\n   * @param left defines the left operand\n   * @param right defines the right operand\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.CrossToRef = function (left, right, result) {\n    var x = left._y * right._z - left._z * right._y;\n    var y = left._z * right._x - left._x * right._z;\n    var z = left._x * right._y - left._y * right._x;\n    result.copyFromFloats(x, y, z);\n  };\n  /**\n   * Returns a new Vector3 as the normalization of the given vector\n   * @param vector defines the Vector3 to normalize\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Normalize = function (vector) {\n    var result = Vector3.Zero();\n    Vector3.NormalizeToRef(vector, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" with the normalization of the given first vector\n   * @param vector defines the Vector3 to normalize\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.NormalizeToRef = function (vector, result) {\n    vector.normalizeToRef(result);\n  };\n  /**\n   * Project a Vector3 onto screen space\n   * @param vector defines the Vector3 to project\n   * @param world defines the world matrix to use\n   * @param transform defines the transform (view x projection) matrix to use\n   * @param viewport defines the screen viewport to use\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Project = function (vector, world, transform, viewport) {\n    var result = new Vector3();\n    Vector3.ProjectToRef(vector, world, transform, viewport, result);\n    return result;\n  };\n  /**\n   * Project a Vector3 onto screen space to reference\n   * @param vector defines the Vector3 to project\n   * @param world defines the world matrix to use\n   * @param transform defines the transform (view x projection) matrix to use\n   * @param viewport defines the screen viewport to use\n   * @param result the vector in which the screen space will be stored\n   * @returns the new Vector3\n   */\n\n\n  Vector3.ProjectToRef = function (vector, world, transform, viewport, result) {\n    var cw = viewport.width;\n    var ch = viewport.height;\n    var cx = viewport.x;\n    var cy = viewport.y;\n    var viewportMatrix = MathTmp.Matrix[1];\n    Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(transform, matrix);\n    matrix.multiplyToRef(viewportMatrix, matrix);\n    Vector3.TransformCoordinatesToRef(vector, matrix, result);\n    return result;\n  };\n  /**\n   * @param source\n   * @param matrix\n   * @param result\n   * @hidden\n   */\n\n\n  Vector3._UnprojectFromInvertedMatrixToRef = function (source, matrix, result) {\n    Vector3.TransformCoordinatesToRef(source, matrix, result);\n    var m = matrix.m;\n    var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\n\n    if (Scalar.WithinEpsilon(num, 1.0)) {\n      result.scaleInPlace(1.0 / num);\n    }\n  };\n  /**\n   * Unproject from screen space to object space\n   * @param source defines the screen space Vector3 to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param transform defines the transform (view x projection) matrix to use\n   * @returns the new Vector3\n   */\n\n\n  Vector3.UnprojectFromTransform = function (source, viewportWidth, viewportHeight, world, transform) {\n    return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);\n  };\n  /**\n   * Unproject from screen space to object space\n   * @param source defines the screen space Vector3 to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Unproject = function (source, viewportWidth, viewportHeight, world, view, projection) {\n    var result = Vector3.Zero();\n    Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\n    return result;\n  };\n  /**\n   * Unproject from screen space to object space\n   * @param source defines the screen space Vector3 to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.UnprojectToRef = function (source, viewportWidth, viewportHeight, world, view, projection, result) {\n    Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\n  };\n  /**\n   * Unproject from screen space to object space\n   * @param sourceX defines the screen space x coordinate to use\n   * @param sourceY defines the screen space y coordinate to use\n   * @param sourceZ defines the screen space z coordinate to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   * @param result defines the Vector3 where to store the result\n   */\n\n\n  Vector3.UnprojectFloatsToRef = function (sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {\n    var _a;\n\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    var screenSource = MathTmp.Vector3[0];\n    screenSource.x = sourceX / viewportWidth * 2 - 1;\n    screenSource.y = -(sourceY / viewportHeight * 2 - 1);\n\n    if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {\n      screenSource.z = sourceZ;\n    } else {\n      screenSource.z = 2 * sourceZ - 1.0;\n    }\n\n    Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\n  };\n  /**\n   * Gets the minimal coordinate values between two Vector3\n   * @param left defines the first operand\n   * @param right defines the second operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Minimize = function (left, right) {\n    var min = left.clone();\n    min.minimizeInPlace(right);\n    return min;\n  };\n  /**\n   * Gets the maximal coordinate values between two Vector3\n   * @param left defines the first operand\n   * @param right defines the second operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Maximize = function (left, right) {\n    var max = left.clone();\n    max.maximizeInPlace(right);\n    return max;\n  };\n  /**\n   * Returns the distance between the vectors \"value1\" and \"value2\"\n   * @param value1 defines the first operand\n   * @param value2 defines the second operand\n   * @returns the distance\n   */\n\n\n  Vector3.Distance = function (value1, value2) {\n    return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n  };\n  /**\n   * Returns the squared distance between the vectors \"value1\" and \"value2\"\n   * @param value1 defines the first operand\n   * @param value2 defines the second operand\n   * @returns the squared distance\n   */\n\n\n  Vector3.DistanceSquared = function (value1, value2) {\n    var x = value1._x - value2._x;\n    var y = value1._y - value2._y;\n    var z = value1._z - value2._z;\n    return x * x + y * y + z * z;\n  };\n  /**\n   * Projects \"vector\" on the triangle determined by its extremities \"p0\", \"p1\" and \"p2\", stores the result in \"ref\"\n   * and returns the distance to the projected point.\n   * From http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf\n   *\n   * @param vector the vector to get distance from\n   * @param p0 extremity of the triangle\n   * @param p1 extremity of the triangle\n   * @param p2 extremity of the triangle\n   * @param ref variable to store the result to\n   * @returns The distance between \"ref\" and \"vector\"\n   */\n\n\n  Vector3.ProjectOnTriangleToRef = function (vector, p0, p1, p2, ref) {\n    var p1p0 = MathTmp.Vector3[0];\n    var p2p0 = MathTmp.Vector3[1];\n    var p2p1 = MathTmp.Vector3[2];\n    var normal = MathTmp.Vector3[3];\n    var vectorp0 = MathTmp.Vector3[4]; // Triangle vectors\n\n    p1.subtractToRef(p0, p1p0);\n    p2.subtractToRef(p0, p2p0);\n    p2.subtractToRef(p1, p2p1);\n    var p1p0L = p1p0.length();\n    var p2p0L = p2p0.length();\n    var p2p1L = p2p1.length();\n\n    if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {\n      // This is a degenerate triangle. As we assume this is part of a non-degenerate mesh,\n      // we will find a better intersection later.\n      // Let's just return one of the extremities\n      ref.copyFrom(p0);\n      return Vector3.Distance(vector, p0);\n    } // Compute normal and vector to p0\n\n\n    vector.subtractToRef(p0, vectorp0);\n    Vector3.CrossToRef(p1p0, p2p0, normal);\n    var nl = normal.length();\n\n    if (nl < Epsilon) {\n      // Extremities are aligned, we are back on the case of a degenerate triangle\n      ref.copyFrom(p0);\n      return Vector3.Distance(vector, p0);\n    }\n\n    normal.normalizeFromLength(nl);\n    var l = vectorp0.length();\n\n    if (l < Epsilon) {\n      // Vector is p0\n      ref.copyFrom(p0);\n      return 0;\n    }\n\n    vectorp0.normalizeFromLength(l); // Project to \"proj\" that lies on the triangle plane\n\n    var cosA = Vector3.Dot(normal, vectorp0);\n    var projVector = MathTmp.Vector3[5];\n    var proj = MathTmp.Vector3[6];\n    projVector.copyFrom(normal).scaleInPlace(-l * cosA);\n    proj.copyFrom(vector).addInPlace(projVector); // Compute barycentric coordinates (v0, v1 and v2 are axis from barycenter to extremities)\n\n    var v0 = MathTmp.Vector3[4];\n    var v1 = MathTmp.Vector3[5];\n    var v2 = MathTmp.Vector3[7];\n    var tmp = MathTmp.Vector3[8];\n    v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);\n    tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);\n    v0.addInPlace(tmp).scaleInPlace(-1);\n    v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);\n    tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);\n    v1.addInPlace(tmp).scaleInPlace(-1);\n    v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);\n    tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);\n    v2.addInPlace(tmp).scaleInPlace(-1); // Determines which edge of the triangle is closest to \"proj\"\n\n    var projP = MathTmp.Vector3[9];\n    var dot;\n    projP.copyFrom(proj).subtractInPlace(p0);\n    Vector3.CrossToRef(v0, projP, tmp);\n    dot = Vector3.Dot(tmp, normal);\n    var s0 = dot;\n    projP.copyFrom(proj).subtractInPlace(p1);\n    Vector3.CrossToRef(v1, projP, tmp);\n    dot = Vector3.Dot(tmp, normal);\n    var s1 = dot;\n    projP.copyFrom(proj).subtractInPlace(p2);\n    Vector3.CrossToRef(v2, projP, tmp);\n    dot = Vector3.Dot(tmp, normal);\n    var s2 = dot;\n    var edge = MathTmp.Vector3[10];\n    var e0, e1;\n\n    if (s0 > 0 && s1 < 0) {\n      edge.copyFrom(p1p0);\n      e0 = p0;\n      e1 = p1;\n    } else if (s1 > 0 && s2 < 0) {\n      edge.copyFrom(p2p1);\n      e0 = p1;\n      e1 = p2;\n    } else {\n      edge.copyFrom(p2p0).scaleInPlace(-1);\n      e0 = p2;\n      e1 = p0;\n    } // Determines if \"proj\" lies inside the triangle\n\n\n    var tmp2 = MathTmp.Vector3[9];\n    var tmp3 = MathTmp.Vector3[4];\n    e0.subtractToRef(proj, tmp);\n    e1.subtractToRef(proj, tmp2);\n    Vector3.CrossToRef(tmp, tmp2, tmp3);\n    var isOutside = Vector3.Dot(tmp3, normal) < 0; // If inside, we already found the projected point, \"proj\"\n\n    if (!isOutside) {\n      ref.copyFrom(proj);\n      return Math.abs(l * cosA);\n    } // If outside, we find \"triProj\", the closest point from \"proj\" on the closest edge\n\n\n    var r = MathTmp.Vector3[5];\n    Vector3.CrossToRef(edge, tmp3, r);\n    r.normalize();\n    var e0proj = MathTmp.Vector3[9];\n    e0proj.copyFrom(e0).subtractInPlace(proj);\n    var e0projL = e0proj.length();\n\n    if (e0projL < Epsilon) {\n      // Proj is e0\n      ref.copyFrom(e0);\n      return Vector3.Distance(vector, e0);\n    }\n\n    e0proj.normalizeFromLength(e0projL);\n    var cosG = Vector3.Dot(r, e0proj);\n    var triProj = MathTmp.Vector3[7];\n    triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG)); // Now we clamp \"triProj\" so it lies between e0 and e1\n\n    tmp.copyFrom(triProj).subtractInPlace(e0);\n    l = edge.length();\n    edge.normalizeFromLength(l);\n    var t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);\n    t = Scalar.Clamp(t, 0, 1);\n    triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));\n    ref.copyFrom(triProj);\n    return Vector3.Distance(vector, triProj);\n  };\n  /**\n   * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\n   * @param value1 defines the first operand\n   * @param value2 defines the second operand\n   * @returns the new Vector3\n   */\n\n\n  Vector3.Center = function (value1, value2) {\n    return Vector3.CenterToRef(value1, value2, Vector3.Zero());\n  };\n  /**\n   * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @param ref defines third vector\n   * @returns ref\n   */\n\n\n  Vector3.CenterToRef = function (value1, value2, ref) {\n    return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);\n  };\n  /**\n   * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n   * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n   * to something in order to rotate it from its local system to the given target system\n   * Note: axis1, axis2 and axis3 are normalized during this operation\n   * @param axis1 defines the first axis\n   * @param axis2 defines the second axis\n   * @param axis3 defines the third axis\n   * @returns a new Vector3\n   * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/target_align\n   */\n\n\n  Vector3.RotationFromAxis = function (axis1, axis2, axis3) {\n    var rotation = Vector3.Zero();\n    Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n    return rotation;\n  };\n  /**\n   * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\n   * @param axis1 defines the first axis\n   * @param axis2 defines the second axis\n   * @param axis3 defines the third axis\n   * @param ref defines the Vector3 where to store the result\n   */\n\n\n  Vector3.RotationFromAxisToRef = function (axis1, axis2, axis3, ref) {\n    var quat = MathTmp.Quaternion[0];\n    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n    quat.toEulerAnglesToRef(ref);\n  };\n\n  Vector3._UpReadOnly = Vector3.Up();\n  Vector3._LeftHandedForwardReadOnly = Vector3.Forward(false);\n  Vector3._RightHandedForwardReadOnly = Vector3.Forward(true);\n  Vector3._RightReadOnly = Vector3.Right();\n  Vector3._LeftReadOnly = Vector3.Left();\n  Vector3._ZeroReadOnly = Vector3.Zero();\n  return Vector3;\n}();\n\nexport { Vector3 };\n/**\n * Vector4 class created for EulerAngle class conversion to Quaternion\n */\n\nvar Vector4 =\n/** @class */\nfunction () {\n  /**\n   * Creates a Vector4 object from the given floats.\n   * @param x x value of the vector\n   * @param y y value of the vector\n   * @param z z value of the vector\n   * @param w w value of the vector\n   */\n  function Vector4(\n  /** x value of the vector */\n  x,\n  /** y value of the vector */\n  y,\n  /** z value of the vector */\n  z,\n  /** w value of the vector */\n  w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  /**\n   * Returns the string with the Vector4 coordinates.\n   * @returns a string containing all the vector values\n   */\n\n\n  Vector4.prototype.toString = function () {\n    return \"{X: \".concat(this.x, \" Y: \").concat(this.y, \" Z: \").concat(this.z, \" W: \").concat(this.w, \"}\");\n  };\n  /**\n   * Returns the string \"Vector4\".\n   * @returns \"Vector4\"\n   */\n\n\n  Vector4.prototype.getClassName = function () {\n    return \"Vector4\";\n  };\n  /**\n   * Returns the Vector4 hash code.\n   * @returns a unique hash code\n   */\n\n\n  Vector4.prototype.getHashCode = function () {\n    var x = _ExtractAsInt(this.x);\n\n    var y = _ExtractAsInt(this.y);\n\n    var z = _ExtractAsInt(this.z);\n\n    var w = _ExtractAsInt(this.w);\n\n    var hash = x;\n    hash = hash * 397 ^ y;\n    hash = hash * 397 ^ z;\n    hash = hash * 397 ^ w;\n    return hash;\n  }; // Operators\n\n  /**\n   * Returns a new array populated with 4 elements : the Vector4 coordinates.\n   * @returns the resulting array\n   */\n\n\n  Vector4.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\n   * Populates the given array from the given index with the Vector4 coordinates.\n   * @param array array to populate\n   * @param index index of the array to start at (default: 0)\n   * @returns the Vector4.\n   */\n\n\n  Vector4.prototype.toArray = function (array, index) {\n    if (index === undefined) {\n      index = 0;\n    }\n\n    array[index] = this.x;\n    array[index + 1] = this.y;\n    array[index + 2] = this.z;\n    array[index + 3] = this.w;\n    return this;\n  };\n  /**\n   * Update the current vector from an array\n   * @param array defines the destination array\n   * @param index defines the offset in the destination array\n   * @returns the current Vector3\n   */\n\n\n  Vector4.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector4.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\n   * Adds the given vector to the current Vector4.\n   * @param otherVector the vector to add\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.addInPlace = function (otherVector) {\n    this.x += otherVector.x;\n    this.y += otherVector.y;\n    this.z += otherVector.z;\n    this.w += otherVector.w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\n   * @param otherVector the vector to add\n   * @returns the resulting vector\n   */\n\n\n  Vector4.prototype.add = function (otherVector) {\n    return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n  };\n  /**\n   * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\n   * @param otherVector the vector to add\n   * @param result the vector to store the result\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.addToRef = function (otherVector, result) {\n    result.x = this.x + otherVector.x;\n    result.y = this.y + otherVector.y;\n    result.z = this.z + otherVector.z;\n    result.w = this.w + otherVector.w;\n    return this;\n  };\n  /**\n   * Subtract in place the given vector from the current Vector4.\n   * @param otherVector the vector to subtract\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector.x;\n    this.y -= otherVector.y;\n    this.z -= otherVector.z;\n    this.w -= otherVector.w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\n   * @param otherVector the vector to add\n   * @returns the new vector with the result\n   */\n\n\n  Vector4.prototype.subtract = function (otherVector) {\n    return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\n   * @param otherVector the vector to subtract\n   * @param result the vector to store the result\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.subtractToRef = function (otherVector, result) {\n    result.x = this.x - otherVector.x;\n    result.y = this.y - otherVector.y;\n    result.z = this.z - otherVector.z;\n    result.w = this.w - otherVector.w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n   */\n\n  /**\n   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n   * @param x value to subtract\n   * @param y value to subtract\n   * @param z value to subtract\n   * @param w value to subtract\n   * @returns new vector containing the result\n   */\n\n\n  Vector4.prototype.subtractFromFloats = function (x, y, z, w) {\n    return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n  };\n  /**\n   * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n   * @param x value to subtract\n   * @param y value to subtract\n   * @param z value to subtract\n   * @param w value to subtract\n   * @param result the vector to store the result in\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.subtractFromFloatsToRef = function (x, y, z, w, result) {\n    result.x = this.x - x;\n    result.y = this.y - y;\n    result.z = this.z - z;\n    result.w = this.w - w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 set with the current Vector4 negated coordinates.\n   * @returns a new vector with the negated values\n   */\n\n\n  Vector4.prototype.negate = function () {\n    return new Vector4(-this.x, -this.y, -this.z, -this.w);\n  };\n  /**\n   * Negate this vector in place\n   * @returns this\n   */\n\n\n  Vector4.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    this.w *= -1;\n    return this;\n  };\n  /**\n   * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\n   * @param result defines the Vector3 object where to store the result\n   * @returns the current Vector4\n   */\n\n\n  Vector4.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\n  };\n  /**\n   * Multiplies the current Vector4 coordinates by scale (float).\n   * @param scale the number to scale with\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    this.z *= scale;\n    this.w *= scale;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n   * @param scale the number to scale with\n   * @returns a new vector with the result\n   */\n\n\n  Vector4.prototype.scale = function (scale) {\n    return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n  };\n  /**\n   * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n   * @param scale the number to scale with\n   * @param result a vector to store the result in\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.scaleToRef = function (scale, result) {\n    result.x = this.x * scale;\n    result.y = this.y * scale;\n    result.z = this.z * scale;\n    result.w = this.w * scale;\n    return this;\n  };\n  /**\n   * Scale the current Vector4 values by a factor and add the result to a given Vector4\n   * @param scale defines the scale factor\n   * @param result defines the Vector4 object where to store the result\n   * @returns the unmodified current Vector4\n   */\n\n\n  Vector4.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this.x * scale;\n    result.y += this.y * scale;\n    result.z += this.z * scale;\n    result.w += this.w * scale;\n    return this;\n  };\n  /**\n   * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\n   * @param otherVector the vector to compare against\n   * @returns true if they are equal\n   */\n\n\n  Vector4.prototype.equals = function (otherVector) {\n    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n  };\n  /**\n   * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\n   * @param otherVector vector to compare against\n   * @param epsilon (Default: very small number)\n   * @returns true if they are equal\n   */\n\n\n  Vector4.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);\n  };\n  /**\n   * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\n   * @param x x value to compare against\n   * @param y y value to compare against\n   * @param z z value to compare against\n   * @param w w value to compare against\n   * @returns true if equal\n   */\n\n\n  Vector4.prototype.equalsToFloats = function (x, y, z, w) {\n    return this.x === x && this.y === y && this.z === z && this.w === w;\n  };\n  /**\n   * Multiplies in place the current Vector4 by the given one.\n   * @param otherVector vector to multiple with\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector.x;\n    this.y *= otherVector.y;\n    this.z *= otherVector.z;\n    this.w *= otherVector.w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\n   * @param otherVector vector to multiple with\n   * @returns resulting new vector\n   */\n\n\n  Vector4.prototype.multiply = function (otherVector) {\n    return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n  };\n  /**\n   * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\n   * @param otherVector vector to multiple with\n   * @param result vector to store the result\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.multiplyToRef = function (otherVector, result) {\n    result.x = this.x * otherVector.x;\n    result.y = this.y * otherVector.y;\n    result.z = this.z * otherVector.z;\n    result.w = this.w * otherVector.w;\n    return this;\n  };\n  /**\n   * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\n   * @param x x value multiply with\n   * @param y y value multiply with\n   * @param z z value multiply with\n   * @param w w value multiply with\n   * @returns resulting new vector\n   */\n\n\n  Vector4.prototype.multiplyByFloats = function (x, y, z, w) {\n    return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n  };\n  /**\n   * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\n   * @param otherVector vector to devide with\n   * @returns resulting new vector\n   */\n\n\n  Vector4.prototype.divide = function (otherVector) {\n    return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n  };\n  /**\n   * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\n   * @param otherVector vector to devide with\n   * @param result vector to store the result\n   * @returns the current Vector4.\n   */\n\n\n  Vector4.prototype.divideToRef = function (otherVector, result) {\n    result.x = this.x / otherVector.x;\n    result.y = this.y / otherVector.y;\n    result.z = this.z / otherVector.z;\n    result.w = this.w / otherVector.w;\n    return this;\n  };\n  /**\n   * Divides the current Vector3 coordinates by the given ones.\n   * @param otherVector vector to devide with\n   * @returns the updated Vector3.\n   */\n\n\n  Vector4.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\n   * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\n   * @param other defines the second operand\n   * @returns the current updated Vector4\n   */\n\n\n  Vector4.prototype.minimizeInPlace = function (other) {\n    if (other.x < this.x) {\n      this.x = other.x;\n    }\n\n    if (other.y < this.y) {\n      this.y = other.y;\n    }\n\n    if (other.z < this.z) {\n      this.z = other.z;\n    }\n\n    if (other.w < this.w) {\n      this.w = other.w;\n    }\n\n    return this;\n  };\n  /**\n   * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\n   * @param other defines the second operand\n   * @returns the current updated Vector4\n   */\n\n\n  Vector4.prototype.maximizeInPlace = function (other) {\n    if (other.x > this.x) {\n      this.x = other.x;\n    }\n\n    if (other.y > this.y) {\n      this.y = other.y;\n    }\n\n    if (other.z > this.z) {\n      this.z = other.z;\n    }\n\n    if (other.w > this.w) {\n      this.w = other.w;\n    }\n\n    return this;\n  };\n  /**\n   * Gets a new Vector4 from current Vector4 floored values\n   * @returns a new Vector4\n   */\n\n\n  Vector4.prototype.floor = function () {\n    return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n  };\n  /**\n   * Gets a new Vector4 from current Vector3 floored values\n   * @returns a new Vector4\n   */\n\n\n  Vector4.prototype.fract = function () {\n    return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n  }; // Properties\n\n  /**\n   * Returns the Vector4 length (float).\n   * @returns the length\n   */\n\n\n  Vector4.prototype.length = function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  };\n  /**\n   * Returns the Vector4 squared length (float).\n   * @returns the length squared\n   */\n\n\n  Vector4.prototype.lengthSquared = function () {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }; // Methods\n\n  /**\n   * Normalizes in place the Vector4.\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.normalize = function () {\n    var len = this.length();\n\n    if (len === 0) {\n      return this;\n    }\n\n    return this.scaleInPlace(1.0 / len);\n  };\n  /**\n   * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n   * @returns this converted to a new vector3\n   */\n\n\n  Vector4.prototype.toVector3 = function () {\n    return new Vector3(this.x, this.y, this.z);\n  };\n  /**\n   * Returns a new Vector4 copied from the current one.\n   * @returns the new cloned vector\n   */\n\n\n  Vector4.prototype.clone = function () {\n    return new Vector4(this.x, this.y, this.z, this.w);\n  };\n  /**\n   * Updates the current Vector4 with the given one coordinates.\n   * @param source the source vector to copy from\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.copyFrom = function (source) {\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    this.w = source.w;\n    return this;\n  };\n  /**\n   * Updates the current Vector4 coordinates with the given floats.\n   * @param x float to copy from\n   * @param y float to copy from\n   * @param z float to copy from\n   * @param w float to copy from\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.copyFromFloats = function (x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  };\n  /**\n   * Updates the current Vector4 coordinates with the given floats.\n   * @param x float to set from\n   * @param y float to set from\n   * @param z float to set from\n   * @param w float to set from\n   * @returns the updated Vector4.\n   */\n\n\n  Vector4.prototype.set = function (x, y, z, w) {\n    return this.copyFromFloats(x, y, z, w);\n  };\n  /**\n   * Copies the given float to the current Vector3 coordinates\n   * @param v defines the x, y, z and w coordinates of the operand\n   * @returns the current updated Vector3\n   */\n\n\n  Vector4.prototype.setAll = function (v) {\n    this.x = this.y = this.z = this.w = v;\n    return this;\n  }; // Statics\n\n  /**\n   * Returns a new Vector4 set from the starting index of the given array.\n   * @param array the array to pull values from\n   * @param offset the offset into the array to start at\n   * @returns the new vector\n   */\n\n\n  Vector4.FromArray = function (array, offset) {\n    if (!offset) {\n      offset = 0;\n    }\n\n    return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  };\n  /**\n   * Updates the given vector \"result\" from the starting index of the given array.\n   * @param array the array to pull values from\n   * @param offset the offset into the array to start at\n   * @param result the vector to store the result in\n   */\n\n\n  Vector4.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n    result.w = array[offset + 3];\n  };\n  /**\n   * Updates the given vector \"result\" from the starting index of the given Float32Array.\n   * @param array the array to pull values from\n   * @param offset the offset into the array to start at\n   * @param result the vector to store the result in\n   */\n\n\n  Vector4.FromFloatArrayToRef = function (array, offset, result) {\n    Vector4.FromArrayToRef(array, offset, result);\n  };\n  /**\n   * Updates the given vector \"result\" coordinates from the given floats.\n   * @param x float to set from\n   * @param y float to set from\n   * @param z float to set from\n   * @param w float to set from\n   * @param result the vector to the floats in\n   */\n\n\n  Vector4.FromFloatsToRef = function (x, y, z, w, result) {\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    result.w = w;\n  };\n  /**\n   * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n   * @returns the new vector\n   */\n\n\n  Vector4.Zero = function () {\n    return new Vector4(0.0, 0.0, 0.0, 0.0);\n  };\n  /**\n   * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n   * @returns the new vector\n   */\n\n\n  Vector4.One = function () {\n    return new Vector4(1.0, 1.0, 1.0, 1.0);\n  };\n  /**\n   * Returns a new normalized Vector4 from the given one.\n   * @param vector the vector to normalize\n   * @returns the vector\n   */\n\n\n  Vector4.Normalize = function (vector) {\n    var result = Vector4.Zero();\n    Vector4.NormalizeToRef(vector, result);\n    return result;\n  };\n  /**\n   * Updates the given vector \"result\" from the normalization of the given one.\n   * @param vector the vector to normalize\n   * @param result the vector to store the result in\n   */\n\n\n  Vector4.NormalizeToRef = function (vector, result) {\n    result.copyFrom(vector);\n    result.normalize();\n  };\n  /**\n   * Returns a vector with the minimum values from the left and right vectors\n   * @param left left vector to minimize\n   * @param right right vector to minimize\n   * @returns a new vector with the minimum of the left and right vector values\n   */\n\n\n  Vector4.Minimize = function (left, right) {\n    var min = left.clone();\n    min.minimizeInPlace(right);\n    return min;\n  };\n  /**\n   * Returns a vector with the maximum values from the left and right vectors\n   * @param left left vector to maximize\n   * @param right right vector to maximize\n   * @returns a new vector with the maximum of the left and right vector values\n   */\n\n\n  Vector4.Maximize = function (left, right) {\n    var max = left.clone();\n    max.maximizeInPlace(right);\n    return max;\n  };\n  /**\n   * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n   * @param value1 value to calulate the distance between\n   * @param value2 value to calulate the distance between\n   * @return the distance between the two vectors\n   */\n\n\n  Vector4.Distance = function (value1, value2) {\n    return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n  };\n  /**\n   * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n   * @param value1 value to calulate the distance between\n   * @param value2 value to calulate the distance between\n   * @return the distance between the two vectors squared\n   */\n\n\n  Vector4.DistanceSquared = function (value1, value2) {\n    var x = value1.x - value2.x;\n    var y = value1.y - value2.y;\n    var z = value1.z - value2.z;\n    var w = value1.w - value2.w;\n    return x * x + y * y + z * z + w * w;\n  };\n  /**\n   * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n   * @param value1 value to calulate the center between\n   * @param value2 value to calulate the center between\n   * @return the center between the two vectors\n   */\n\n\n  Vector4.Center = function (value1, value2) {\n    return Vector4.CenterToRef(value1, value2, Vector4.Zero());\n  };\n  /**\n   * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n   * @param value1 defines first vector\n   * @param value2 defines second vector\n   * @param ref defines third vector\n   * @returns ref\n   */\n\n\n  Vector4.CenterToRef = function (value1, value2, ref) {\n    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);\n  };\n  /**\n   * Returns a new Vector4 set with the result of the transformation by the given matrix of the given vector.\n   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n   * The difference with Vector3.TransformCoordinates is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @returns the transformed Vector4\n   */\n\n\n  Vector4.TransformCoordinates = function (vector, transformation) {\n    var result = Vector4.Zero();\n    Vector4.TransformCoordinatesToRef(vector, transformation, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n   * The difference with Vector3.TransformCoordinatesToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n   * @param vector defines the Vector3 to transform\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector4 where to store the result\n   */\n\n\n  Vector4.TransformCoordinatesToRef = function (vector, transformation, result) {\n    Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n  };\n  /**\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n   * This method computes tranformed coordinates only, not transformed direction vectors\n   * The difference with Vector3.TransformCoordinatesFromFloatsToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n   * @param x define the x coordinate of the source vector\n   * @param y define the y coordinate of the source vector\n   * @param z define the z coordinate of the source vector\n   * @param transformation defines the transformation matrix\n   * @param result defines the Vector4 where to store the result\n   */\n\n\n  Vector4.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n    var m = transformation.m;\n    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n    var rw = x * m[3] + y * m[7] + z * m[11] + m[15];\n    result.x = rx;\n    result.y = ry;\n    result.z = rz;\n    result.w = rw;\n  };\n  /**\n   * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\n   * This methods computes transformed normalized direction vectors only.\n   * @param vector the vector to transform\n   * @param transformation the transformation matrix to apply\n   * @returns the new vector\n   */\n\n\n  Vector4.TransformNormal = function (vector, transformation) {\n    var result = Vector4.Zero();\n    Vector4.TransformNormalToRef(vector, transformation, result);\n    return result;\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\n   * This methods computes transformed normalized direction vectors only.\n   * @param vector the vector to transform\n   * @param transformation the transformation matrix to apply\n   * @param result the vector to store the result in\n   */\n\n\n  Vector4.TransformNormalToRef = function (vector, transformation, result) {\n    var m = transformation.m;\n    var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n    var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n    var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    result.w = vector.w;\n  };\n  /**\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\n   * This methods computes transformed normalized direction vectors only.\n   * @param x value to transform\n   * @param y value to transform\n   * @param z value to transform\n   * @param w value to transform\n   * @param transformation the transformation matrix to apply\n   * @param result the vector to store the results in\n   */\n\n\n  Vector4.TransformNormalFromFloatsToRef = function (x, y, z, w, transformation, result) {\n    var m = transformation.m;\n    result.x = x * m[0] + y * m[4] + z * m[8];\n    result.y = x * m[1] + y * m[5] + z * m[9];\n    result.z = x * m[2] + y * m[6] + z * m[10];\n    result.w = w;\n  };\n  /**\n   * Creates a new Vector4 from a Vector3\n   * @param source defines the source data\n   * @param w defines the 4th component (default is 0)\n   * @returns a new Vector4\n   */\n\n\n  Vector4.FromVector3 = function (source, w) {\n    if (w === void 0) {\n      w = 0;\n    }\n\n    return new Vector4(source._x, source._y, source._z, w);\n  };\n\n  return Vector4;\n}();\n\nexport { Vector4 };\n/**\n * Class used to store quaternion data\n * @see https://en.wikipedia.org/wiki/Quaternion\n * @see https://doc.babylonjs.com/features/position,_rotation,_scaling\n */\n\nvar Quaternion =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Quaternion from the given floats\n   * @param x defines the first component (0 by default)\n   * @param y defines the second component (0 by default)\n   * @param z defines the third component (0 by default)\n   * @param w defines the fourth component (1.0 by default)\n   */\n  function Quaternion(x, y, z, w) {\n    if (x === void 0) {\n      x = 0.0;\n    }\n\n    if (y === void 0) {\n      y = 0.0;\n    }\n\n    if (z === void 0) {\n      z = 0.0;\n    }\n\n    if (w === void 0) {\n      w = 1.0;\n    }\n    /** @hidden */\n\n\n    this._isDirty = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  Object.defineProperty(Quaternion.prototype, \"x\", {\n    /** Gets or sets the x coordinate */\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"y\", {\n    /** Gets or sets the y coordinate */\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"z\", {\n    /** Gets or sets the z coordinate */\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      this._z = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"w\", {\n    /** Gets or sets the w coordinate */\n    get: function get() {\n      return this._w;\n    },\n    set: function set(value) {\n      this._w = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string representation for the current quaternion\n   * @returns a string with the Quaternion coordinates\n   */\n\n  Quaternion.prototype.toString = function () {\n    return \"{X: \".concat(this._x, \" Y: \").concat(this._y, \" Z: \").concat(this._z, \" W: \").concat(this._w, \"}\");\n  };\n  /**\n   * Gets the class name of the quaternion\n   * @returns the string \"Quaternion\"\n   */\n\n\n  Quaternion.prototype.getClassName = function () {\n    return \"Quaternion\";\n  };\n  /**\n   * Gets a hash code for this quaternion\n   * @returns the quaternion hash code\n   */\n\n\n  Quaternion.prototype.getHashCode = function () {\n    var x = _ExtractAsInt(this._x);\n\n    var y = _ExtractAsInt(this._y);\n\n    var z = _ExtractAsInt(this._z);\n\n    var w = _ExtractAsInt(this._w);\n\n    var hash = x;\n    hash = hash * 397 ^ y;\n    hash = hash * 397 ^ z;\n    hash = hash * 397 ^ w;\n    return hash;\n  };\n  /**\n   * Copy the quaternion to an array\n   * @returns a new array populated with 4 elements from the quaternion coordinates\n   */\n\n\n  Quaternion.prototype.asArray = function () {\n    return [this._x, this._y, this._z, this._w];\n  };\n  /**\n   * Check if two quaternions are equals\n   * @param otherQuaternion defines the second operand\n   * @return true if the current quaternion and the given one coordinates are strictly equals\n   */\n\n\n  Quaternion.prototype.equals = function (otherQuaternion) {\n    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\n  };\n  /**\n   * Gets a boolean if two quaternions are equals (using an epsilon value)\n   * @param otherQuaternion defines the other quaternion\n   * @param epsilon defines the minimal distance to consider equality\n   * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\n   */\n\n\n  Quaternion.prototype.equalsWithEpsilon = function (otherQuaternion, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);\n  };\n  /**\n   * Clone the current quaternion\n   * @returns a new quaternion copied from the current one\n   */\n\n\n  Quaternion.prototype.clone = function () {\n    return new Quaternion(this._x, this._y, this._z, this._w);\n  };\n  /**\n   * Copy a quaternion to the current one\n   * @param other defines the other quaternion\n   * @returns the updated current quaternion\n   */\n\n\n  Quaternion.prototype.copyFrom = function (other) {\n    this.x = other._x;\n    this.y = other._y;\n    this.z = other._z;\n    this.w = other._w;\n    return this;\n  };\n  /**\n   * Updates the current quaternion with the given float coordinates\n   * @param x defines the x coordinate\n   * @param y defines the y coordinate\n   * @param z defines the z coordinate\n   * @param w defines the w coordinate\n   * @returns the updated current quaternion\n   */\n\n\n  Quaternion.prototype.copyFromFloats = function (x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  };\n  /**\n   * Updates the current quaternion from the given float coordinates\n   * @param x defines the x coordinate\n   * @param y defines the y coordinate\n   * @param z defines the z coordinate\n   * @param w defines the w coordinate\n   * @returns the updated current quaternion\n   */\n\n\n  Quaternion.prototype.set = function (x, y, z, w) {\n    return this.copyFromFloats(x, y, z, w);\n  };\n  /**\n   * Adds two quaternions\n   * @param other defines the second operand\n   * @returns a new quaternion as the addition result of the given one and the current quaternion\n   */\n\n\n  Quaternion.prototype.add = function (other) {\n    return new Quaternion(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\n  };\n  /**\n   * Add a quaternion to the current one\n   * @param other defines the quaternion to add\n   * @returns the current quaternion\n   */\n\n\n  Quaternion.prototype.addInPlace = function (other) {\n    this._x += other._x;\n    this._y += other._y;\n    this._z += other._z;\n    this._w += other._w;\n    return this;\n  };\n  /**\n   * Subtract two quaternions\n   * @param other defines the second operand\n   * @returns a new quaternion as the subtraction result of the given one from the current one\n   */\n\n\n  Quaternion.prototype.subtract = function (other) {\n    return new Quaternion(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\n  };\n  /**\n   * Multiplies the current quaternion by a scale factor\n   * @param value defines the scale factor\n   * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\n   */\n\n\n  Quaternion.prototype.scale = function (value) {\n    return new Quaternion(this._x * value, this._y * value, this._z * value, this._w * value);\n  };\n  /**\n   * Scale the current quaternion values by a factor and stores the result to a given quaternion\n   * @param scale defines the scale factor\n   * @param result defines the Quaternion object where to store the result\n   * @returns the unmodified current quaternion\n   */\n\n\n  Quaternion.prototype.scaleToRef = function (scale, result) {\n    result.x = this._x * scale;\n    result.y = this._y * scale;\n    result.z = this._z * scale;\n    result.w = this._w * scale;\n    return this;\n  };\n  /**\n   * Multiplies in place the current quaternion by a scale factor\n   * @param value defines the scale factor\n   * @returns the current modified quaternion\n   */\n\n\n  Quaternion.prototype.scaleInPlace = function (value) {\n    this.x *= value;\n    this.y *= value;\n    this.z *= value;\n    this.w *= value;\n    return this;\n  };\n  /**\n   * Scale the current quaternion values by a factor and add the result to a given quaternion\n   * @param scale defines the scale factor\n   * @param result defines the Quaternion object where to store the result\n   * @returns the unmodified current quaternion\n   */\n\n\n  Quaternion.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this._x * scale;\n    result.y += this._y * scale;\n    result.z += this._z * scale;\n    result.w += this._w * scale;\n    return this;\n  };\n  /**\n   * Multiplies two quaternions\n   * @param q1 defines the second operand\n   * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\n   */\n\n\n  Quaternion.prototype.multiply = function (q1) {\n    var result = new Quaternion(0, 0, 0, 1.0);\n    this.multiplyToRef(q1, result);\n    return result;\n  };\n  /**\n   * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\n   * @param q1 defines the second operand\n   * @param result defines the target quaternion\n   * @returns the current quaternion\n   */\n\n\n  Quaternion.prototype.multiplyToRef = function (q1, result) {\n    var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\n    var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\n    var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\n    var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\n    result.copyFromFloats(x, y, z, w);\n    return this;\n  };\n  /**\n   * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\n   * @param q1 defines the second operand\n   * @returns the currentupdated quaternion\n   */\n\n\n  Quaternion.prototype.multiplyInPlace = function (q1) {\n    this.multiplyToRef(q1, this);\n    return this;\n  };\n  /**\n   * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\n   * @param ref defines the target quaternion\n   * @returns the current quaternion\n   */\n\n\n  Quaternion.prototype.conjugateToRef = function (ref) {\n    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\n    return this;\n  };\n  /**\n   * Conjugates in place (1-q) the current quaternion\n   * @returns the current updated quaternion\n   */\n\n\n  Quaternion.prototype.conjugateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  };\n  /**\n   * Conjugates in place (1-q) the current quaternion\n   * @returns a new quaternion\n   */\n\n\n  Quaternion.prototype.conjugate = function () {\n    var result = new Quaternion(-this._x, -this._y, -this._z, this._w);\n    return result;\n  };\n  /**\n   * Gets length of current quaternion\n   * @returns the quaternion length (float)\n   */\n\n\n  Quaternion.prototype.length = function () {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  };\n  /**\n   * Normalize in place the current quaternion\n   * @returns the current updated quaternion\n   */\n\n\n  Quaternion.prototype.normalize = function () {\n    var len = this.length();\n\n    if (len === 0) {\n      return this;\n    }\n\n    var inv = 1.0 / len;\n    this.x *= inv;\n    this.y *= inv;\n    this.z *= inv;\n    this.w *= inv;\n    return this;\n  };\n  /**\n   * Returns a new Vector3 set with the Euler angles translated from the current quaternion\n   * @returns a new Vector3 containing the Euler angles\n   * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\n   */\n\n\n  Quaternion.prototype.toEulerAngles = function () {\n    var result = Vector3.Zero();\n    this.toEulerAnglesToRef(result);\n    return result;\n  };\n  /**\n   * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\n   * @param result defines the vector which will be filled with the Euler angles\n   * @returns the current unchanged quaternion\n   * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\n   */\n\n\n  Quaternion.prototype.toEulerAnglesToRef = function (result) {\n    var qz = this._z;\n    var qx = this._x;\n    var qy = this._y;\n    var qw = this._w;\n    var sqw = qw * qw;\n    var sqz = qz * qz;\n    var sqx = qx * qx;\n    var sqy = qy * qy;\n    var zAxisY = qy * qz - qx * qw;\n    var limit = 0.4999999;\n\n    if (zAxisY < -limit) {\n      result.y = 2 * Math.atan2(qy, qw);\n      result.x = Math.PI / 2;\n      result.z = 0;\n    } else if (zAxisY > limit) {\n      result.y = 2 * Math.atan2(qy, qw);\n      result.x = -Math.PI / 2;\n      result.z = 0;\n    } else {\n      result.z = Math.atan2(2.0 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);\n      result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\n      result.y = Math.atan2(2.0 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);\n    }\n\n    return this;\n  };\n  /**\n   * Updates the given rotation matrix with the current quaternion values\n   * @param result defines the target matrix\n   * @returns the current unchanged quaternion\n   */\n\n\n  Quaternion.prototype.toRotationMatrix = function (result) {\n    Matrix.FromQuaternionToRef(this, result);\n    return this;\n  };\n  /**\n   * Updates the current quaternion from the given rotation matrix values\n   * @param matrix defines the source matrix\n   * @returns the current updated quaternion\n   */\n\n\n  Quaternion.prototype.fromRotationMatrix = function (matrix) {\n    Quaternion.FromRotationMatrixToRef(matrix, this);\n    return this;\n  }; // Statics\n\n  /**\n   * Creates a new quaternion from a rotation matrix\n   * @param matrix defines the source matrix\n   * @returns a new quaternion created from the given rotation matrix values\n   */\n\n\n  Quaternion.FromRotationMatrix = function (matrix) {\n    var result = new Quaternion();\n    Quaternion.FromRotationMatrixToRef(matrix, result);\n    return result;\n  };\n  /**\n   * Updates the given quaternion with the given rotation matrix values\n   * @param matrix defines the source matrix\n   * @param result defines the target quaternion\n   */\n\n\n  Quaternion.FromRotationMatrixToRef = function (matrix, result) {\n    var data = matrix.m;\n    var m11 = data[0],\n        m12 = data[4],\n        m13 = data[8];\n    var m21 = data[1],\n        m22 = data[5],\n        m23 = data[9];\n    var m31 = data[2],\n        m32 = data[6],\n        m33 = data[10];\n    var trace = m11 + m22 + m33;\n    var s;\n\n    if (trace > 0) {\n      s = 0.5 / Math.sqrt(trace + 1.0);\n      result.w = 0.25 / s;\n      result.x = (m32 - m23) * s;\n      result.y = (m13 - m31) * s;\n      result.z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      result.w = (m32 - m23) / s;\n      result.x = 0.25 * s;\n      result.y = (m12 + m21) / s;\n      result.z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      result.w = (m13 - m31) / s;\n      result.x = (m12 + m21) / s;\n      result.y = 0.25 * s;\n      result.z = (m23 + m32) / s;\n    } else {\n      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      result.w = (m21 - m12) / s;\n      result.x = (m13 + m31) / s;\n      result.y = (m23 + m32) / s;\n      result.z = 0.25 * s;\n    }\n  };\n  /**\n   * Returns the dot product (float) between the quaternions \"left\" and \"right\"\n   * @param left defines the left operand\n   * @param right defines the right operand\n   * @returns the dot product\n   */\n\n\n  Quaternion.Dot = function (left, right) {\n    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n  };\n  /**\n   * Checks if the two quaternions are close to each other\n   * @param quat0 defines the first quaternion to check\n   * @param quat1 defines the second quaternion to check\n   * @returns true if the two quaternions are close to each other\n   */\n\n\n  Quaternion.AreClose = function (quat0, quat1) {\n    var dot = Quaternion.Dot(quat0, quat1);\n    return dot >= 0;\n  };\n  /**\n   * Smooth interpolation between two quaternions using Slerp\n   *\n   * @param source source quaternion\n   * @param goal goal quaternion\n   * @param deltaTime current interpolation frame\n   * @param lerpTime total interpolation time\n   * @param result the smoothed quaternion\n   */\n\n\n  Quaternion.SmoothToRef = function (source, goal, deltaTime, lerpTime, result) {\n    var slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;\n    slerp = Scalar.Clamp(slerp, 0, 1);\n    Quaternion.SlerpToRef(source, goal, slerp, result);\n  };\n  /**\n   * Creates an empty quaternion\n   * @returns a new quaternion set to (0.0, 0.0, 0.0)\n   */\n\n\n  Quaternion.Zero = function () {\n    return new Quaternion(0.0, 0.0, 0.0, 0.0);\n  };\n  /**\n   * Inverse a given quaternion\n   * @param q defines the source quaternion\n   * @returns a new quaternion as the inverted current quaternion\n   */\n\n\n  Quaternion.Inverse = function (q) {\n    return new Quaternion(-q._x, -q._y, -q._z, q._w);\n  };\n  /**\n   * Inverse a given quaternion\n   * @param q defines the source quaternion\n   * @param result the quaternion the result will be stored in\n   * @returns the result quaternion\n   */\n\n\n  Quaternion.InverseToRef = function (q, result) {\n    result.set(-q._x, -q._y, -q._z, q._w);\n    return result;\n  };\n  /**\n   * Creates an identity quaternion\n   * @returns the identity quaternion\n   */\n\n\n  Quaternion.Identity = function () {\n    return new Quaternion(0.0, 0.0, 0.0, 1.0);\n  };\n  /**\n   * Gets a boolean indicating if the given quaternion is identity\n   * @param quaternion defines the quaternion to check\n   * @returns true if the quaternion is identity\n   */\n\n\n  Quaternion.IsIdentity = function (quaternion) {\n    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\n  };\n  /**\n   * Creates a quaternion from a rotation around an axis\n   * @param axis defines the axis to use\n   * @param angle defines the angle to use\n   * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\n   */\n\n\n  Quaternion.RotationAxis = function (axis, angle) {\n    return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\n  };\n  /**\n   * Creates a rotation around an axis and stores it into the given quaternion\n   * @param axis defines the axis to use\n   * @param angle defines the angle to use\n   * @param result defines the target quaternion\n   * @returns the target quaternion\n   */\n\n\n  Quaternion.RotationAxisToRef = function (axis, angle, result) {\n    var sin = Math.sin(angle / 2);\n    axis.normalize();\n    result.w = Math.cos(angle / 2);\n    result.x = axis._x * sin;\n    result.y = axis._y * sin;\n    result.z = axis._z * sin;\n    return result;\n  };\n  /**\n   * Creates a new quaternion from data stored into an array\n   * @param array defines the data source\n   * @param offset defines the offset in the source array where the data starts\n   * @returns a new quaternion\n   */\n\n\n  Quaternion.FromArray = function (array, offset) {\n    if (!offset) {\n      offset = 0;\n    }\n\n    return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  };\n  /**\n   * Updates the given quaternion \"result\" from the starting index of the given array.\n   * @param array the array to pull values from\n   * @param offset the offset into the array to start at\n   * @param result the quaternion to store the result in\n   */\n\n\n  Quaternion.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n    result.w = array[offset + 3];\n  };\n  /**\n   * Create a quaternion from Euler rotation angles\n   * @param x Pitch\n   * @param y Yaw\n   * @param z Roll\n   * @returns the new Quaternion\n   */\n\n\n  Quaternion.FromEulerAngles = function (x, y, z) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(y, x, z, q);\n    return q;\n  };\n  /**\n   * Updates a quaternion from Euler rotation angles\n   * @param x Pitch\n   * @param y Yaw\n   * @param z Roll\n   * @param result the quaternion to store the result\n   * @returns the updated quaternion\n   */\n\n\n  Quaternion.FromEulerAnglesToRef = function (x, y, z, result) {\n    Quaternion.RotationYawPitchRollToRef(y, x, z, result);\n    return result;\n  };\n  /**\n   * Create a quaternion from Euler rotation vector\n   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n   * @returns the new Quaternion\n   */\n\n\n  Quaternion.FromEulerVector = function (vec) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\n    return q;\n  };\n  /**\n   * Updates a quaternion from Euler rotation vector\n   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n   * @param result the quaternion to store the result\n   * @returns the updated quaternion\n   */\n\n\n  Quaternion.FromEulerVectorToRef = function (vec, result) {\n    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\n    return result;\n  };\n  /**\n   * Updates a quaternion so that it rotates vector vecFrom to vector vecTo\n   * @param vecFrom defines the direction vector from which to rotate\n   * @param vecTo defines the direction vector to which to rotate\n   * @param result the quaternion to store the result\n   * @returns the updated quaternion\n   */\n\n\n  Quaternion.FromUnitVectorsToRef = function (vecFrom, vecTo, result) {\n    var r = Vector3.Dot(vecFrom, vecTo) + 1;\n\n    if (r < Epsilon) {\n      if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {\n        result.set(-vecFrom.y, vecFrom.x, 0, 0);\n      } else {\n        result.set(0, -vecFrom.z, vecFrom.y, 0);\n      }\n    } else {\n      Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);\n      result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);\n    }\n\n    return result.normalize();\n  };\n  /**\n   * Creates a new quaternion from the given Euler float angles (y, x, z)\n   * @param yaw defines the rotation around Y axis\n   * @param pitch defines the rotation around X axis\n   * @param roll defines the rotation around Z axis\n   * @returns the new quaternion\n   */\n\n\n  Quaternion.RotationYawPitchRoll = function (yaw, pitch, roll) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n    return q;\n  };\n  /**\n   * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\n   * @param yaw defines the rotation around Y axis\n   * @param pitch defines the rotation around X axis\n   * @param roll defines the rotation around Z axis\n   * @param result defines the target quaternion\n   */\n\n\n  Quaternion.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n    // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n    var halfRoll = roll * 0.5;\n    var halfPitch = pitch * 0.5;\n    var halfYaw = yaw * 0.5;\n    var sinRoll = Math.sin(halfRoll);\n    var cosRoll = Math.cos(halfRoll);\n    var sinPitch = Math.sin(halfPitch);\n    var cosPitch = Math.cos(halfPitch);\n    var sinYaw = Math.sin(halfYaw);\n    var cosYaw = Math.cos(halfYaw);\n    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;\n    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;\n  };\n  /**\n   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\n   * @param alpha defines the rotation around first axis\n   * @param beta defines the rotation around second axis\n   * @param gamma defines the rotation around third axis\n   * @returns the new quaternion\n   */\n\n\n  Quaternion.RotationAlphaBetaGamma = function (alpha, beta, gamma) {\n    var result = new Quaternion();\n    Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n    return result;\n  };\n  /**\n   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\n   * @param alpha defines the rotation around first axis\n   * @param beta defines the rotation around second axis\n   * @param gamma defines the rotation around third axis\n   * @param result defines the target quaternion\n   */\n\n\n  Quaternion.RotationAlphaBetaGammaToRef = function (alpha, beta, gamma, result) {\n    // Produces a quaternion from Euler angles in the z-x-z orientation\n    var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n    var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n    var halfBeta = beta * 0.5;\n    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n  };\n  /**\n   * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\n   * @param axis1 defines the first axis\n   * @param axis2 defines the second axis\n   * @param axis3 defines the third axis\n   * @returns the new quaternion\n   */\n\n\n  Quaternion.RotationQuaternionFromAxis = function (axis1, axis2, axis3) {\n    var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n    return quat;\n  };\n  /**\n   * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\n   * @param axis1 defines the first axis\n   * @param axis2 defines the second axis\n   * @param axis3 defines the third axis\n   * @param ref defines the target quaternion\n   */\n\n\n  Quaternion.RotationQuaternionFromAxisToRef = function (axis1, axis2, axis3, ref) {\n    var rotMat = MathTmp.Matrix[0];\n    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n    Quaternion.FromRotationMatrixToRef(rotMat, ref);\n  };\n  /**\n   * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n   * This function works in left handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @returns A new quaternion oriented toward the specified forward and up.\n   */\n\n\n  Quaternion.FromLookDirectionLH = function (forward, up) {\n    var quat = new Quaternion();\n    Quaternion.FromLookDirectionLHToRef(forward, up, quat);\n    return quat;\n  };\n  /**\n   * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n   * This function works in left handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @param ref defines the target quaternion.\n   */\n\n\n  Quaternion.FromLookDirectionLHToRef = function (forward, up, ref) {\n    var rotMat = MathTmp.Matrix[0];\n    Matrix.LookDirectionLHToRef(forward, up, rotMat);\n    Quaternion.FromRotationMatrixToRef(rotMat, ref);\n  };\n  /**\n   * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n   * This function works in right handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @returns A new quaternion oriented toward the specified forward and up.\n   */\n\n\n  Quaternion.FromLookDirectionRH = function (forward, up) {\n    var quat = new Quaternion();\n    Quaternion.FromLookDirectionRHToRef(forward, up, quat);\n    return quat;\n  };\n  /**\n   * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n   * This function works in right handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @param ref defines the target quaternion.\n   */\n\n\n  Quaternion.FromLookDirectionRHToRef = function (forward, up, ref) {\n    var rotMat = MathTmp.Matrix[0];\n    Matrix.LookDirectionRHToRef(forward, up, rotMat);\n    return Quaternion.FromRotationMatrixToRef(rotMat, ref);\n  };\n  /**\n   * Interpolates between two quaternions\n   * @param left defines first quaternion\n   * @param right defines second quaternion\n   * @param amount defines the gradient to use\n   * @returns the new interpolated quaternion\n   */\n\n\n  Quaternion.Slerp = function (left, right, amount) {\n    var result = Quaternion.Identity();\n    Quaternion.SlerpToRef(left, right, amount, result);\n    return result;\n  };\n  /**\n   * Interpolates between two quaternions and stores it into a target quaternion\n   * @param left defines first quaternion\n   * @param right defines second quaternion\n   * @param amount defines the gradient to use\n   * @param result defines the target quaternion\n   */\n\n\n  Quaternion.SlerpToRef = function (left, right, amount, result) {\n    var num2;\n    var num3;\n    var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n    var flag = false;\n\n    if (num4 < 0) {\n      flag = true;\n      num4 = -num4;\n    }\n\n    if (num4 > 0.999999) {\n      num3 = 1 - amount;\n      num2 = flag ? -amount : amount;\n    } else {\n      var num5 = Math.acos(num4);\n      var num6 = 1.0 / Math.sin(num5);\n      num3 = Math.sin((1.0 - amount) * num5) * num6;\n      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;\n    }\n\n    result.x = num3 * left._x + num2 * right._x;\n    result.y = num3 * left._y + num2 * right._y;\n    result.z = num3 * left._z + num2 * right._z;\n    result.w = num3 * left._w + num2 * right._w;\n  };\n  /**\n   * Interpolate between two quaternions using Hermite interpolation\n   * @param value1 defines first quaternion\n   * @param tangent1 defines the incoming tangent\n   * @param value2 defines second quaternion\n   * @param tangent2 defines the outgoing tangent\n   * @param amount defines the target quaternion\n   * @returns the new interpolated quaternion\n   */\n\n\n  Quaternion.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n    var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;\n    return new Quaternion(x, y, z, w);\n  };\n  /**\n   * Returns a new Quaternion which is the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n\n\n  Quaternion.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n    var result = Quaternion.Zero();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  };\n  /**\n   * Update a Quaternion with the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n\n\n  Quaternion.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n    var t2 = time * time;\n    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\n    result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;\n  };\n\n  return Quaternion;\n}();\n\nexport { Quaternion };\n/**\n * Class used to store matrix data (4x4)\n */\n\nvar Matrix =\n/** @class */\nfunction () {\n  /**\n   * Creates an empty matrix (filled with zeros)\n   */\n  function Matrix() {\n    this._isIdentity = false;\n    this._isIdentityDirty = true;\n    this._isIdentity3x2 = true;\n    this._isIdentity3x2Dirty = true;\n    /**\n     * Gets the update flag of the matrix which is an unique number for the matrix.\n     * It will be incremented every time the matrix data change.\n     * You can use it to speed the comparison between two versions of the same matrix.\n     */\n\n    this.updateFlag = -1;\n\n    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\n      PerformanceConfigurator.MatrixTrackedMatrices.push(this);\n    }\n\n    this._m = new PerformanceConfigurator.MatrixCurrentType(16);\n    this.markAsUpdated();\n  }\n\n  Object.defineProperty(Matrix, \"Use64Bits\", {\n    /**\n     * Gets the precision of matrix computations\n     */\n    get: function get() {\n      return PerformanceConfigurator.MatrixUse64Bits;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"m\", {\n    /**\n     * Gets the internal data of the matrix\n     */\n    get: function get() {\n      return this._m;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Update the updateFlag to indicate that the matrix has been updated\n   */\n\n  Matrix.prototype.markAsUpdated = function () {\n    this.updateFlag = Matrix._UpdateFlagSeed++;\n    this._isIdentity = false;\n    this._isIdentity3x2 = false;\n    this._isIdentityDirty = true;\n    this._isIdentity3x2Dirty = true;\n  };\n\n  Matrix.prototype._updateIdentityStatus = function (isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {\n    if (isIdentityDirty === void 0) {\n      isIdentityDirty = false;\n    }\n\n    if (isIdentity3x2 === void 0) {\n      isIdentity3x2 = false;\n    }\n\n    if (isIdentity3x2Dirty === void 0) {\n      isIdentity3x2Dirty = true;\n    }\n\n    this._isIdentity = isIdentity;\n    this._isIdentity3x2 = isIdentity || isIdentity3x2;\n    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n  }; // Properties\n\n  /**\n   * Check if the current matrix is identity\n   * @returns true is the matrix is the identity matrix\n   */\n\n\n  Matrix.prototype.isIdentity = function () {\n    if (this._isIdentityDirty) {\n      this._isIdentityDirty = false;\n      var m = this._m;\n      this._isIdentity = m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 && m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 && m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 && m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0;\n    }\n\n    return this._isIdentity;\n  };\n  /**\n   * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\n   * @returns true is the matrix is the identity matrix\n   */\n\n\n  Matrix.prototype.isIdentityAs3x2 = function () {\n    if (this._isIdentity3x2Dirty) {\n      this._isIdentity3x2Dirty = false;\n\n      if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n        this._isIdentity3x2 = false;\n      } else if (this._m[1] !== 0.0 || this._m[2] !== 0.0 || this._m[3] !== 0.0 || this._m[4] !== 0.0 || this._m[6] !== 0.0 || this._m[7] !== 0.0 || this._m[8] !== 0.0 || this._m[9] !== 0.0 || this._m[10] !== 0.0 || this._m[11] !== 0.0 || this._m[12] !== 0.0 || this._m[13] !== 0.0 || this._m[14] !== 0.0) {\n        this._isIdentity3x2 = false;\n      } else {\n        this._isIdentity3x2 = true;\n      }\n    }\n\n    return this._isIdentity3x2;\n  };\n  /**\n   * Gets the determinant of the matrix\n   * @returns the matrix determinant\n   */\n\n\n  Matrix.prototype.determinant = function () {\n    if (this._isIdentity === true) {\n      return 1;\n    }\n\n    var m = this._m;\n    var m00 = m[0],\n        m01 = m[1],\n        m02 = m[2],\n        m03 = m[3];\n    var m10 = m[4],\n        m11 = m[5],\n        m12 = m[6],\n        m13 = m[7];\n    var m20 = m[8],\n        m21 = m[9],\n        m22 = m[10],\n        m23 = m[11];\n    var m30 = m[12],\n        m31 = m[13],\n        m32 = m[14],\n        m33 = m[15]; // https://en.wikipedia.org/wiki/Laplace_expansion\n    // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n    // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n    // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n    // where\n    //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n    //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n    //\n    // Here we do that for the 1st row.\n\n    var det_22_33 = m22 * m33 - m32 * m23;\n    var det_21_33 = m21 * m33 - m31 * m23;\n    var det_21_32 = m21 * m32 - m31 * m22;\n    var det_20_33 = m20 * m33 - m30 * m23;\n    var det_20_32 = m20 * m32 - m22 * m30;\n    var det_20_31 = m20 * m31 - m30 * m21;\n    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n  }; // Methods\n\n  /**\n   * Returns the matrix as a Float32Array or Array<number>\n   * @returns the matrix underlying array\n   */\n\n\n  Matrix.prototype.toArray = function () {\n    return this._m;\n  };\n  /**\n   * Returns the matrix as a Float32Array or Array<number>\n   * @returns the matrix underlying array.\n   */\n\n\n  Matrix.prototype.asArray = function () {\n    return this._m;\n  };\n  /**\n   * Inverts the current matrix in place\n   * @returns the current inverted matrix\n   */\n\n\n  Matrix.prototype.invert = function () {\n    this.invertToRef(this);\n    return this;\n  };\n  /**\n   * Sets all the matrix elements to zero\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.reset = function () {\n    Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n\n    this._updateIdentityStatus(false);\n\n    return this;\n  };\n  /**\n   * Adds the current matrix with a second one\n   * @param other defines the matrix to add\n   * @returns a new matrix as the addition of the current matrix and the given one\n   */\n\n\n  Matrix.prototype.add = function (other) {\n    var result = new Matrix();\n    this.addToRef(other, result);\n    return result;\n  };\n  /**\n   * Sets the given matrix \"result\" to the addition of the current matrix and the given one\n   * @param other defines the matrix to add\n   * @param result defines the target matrix\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.addToRef = function (other, result) {\n    var m = this._m;\n    var resultM = result._m;\n    var otherM = other.m;\n\n    for (var index = 0; index < 16; index++) {\n      resultM[index] = m[index] + otherM[index];\n    }\n\n    result.markAsUpdated();\n    return this;\n  };\n  /**\n   * Adds in place the given matrix to the current matrix\n   * @param other defines the second operand\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.addToSelf = function (other) {\n    var m = this._m;\n    var otherM = other.m;\n\n    for (var index = 0; index < 16; index++) {\n      m[index] += otherM[index];\n    }\n\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * Sets the given matrix to the current inverted Matrix\n   * @param other defines the target matrix\n   * @returns the unmodified current matrix\n   */\n\n\n  Matrix.prototype.invertToRef = function (other) {\n    if (this._isIdentity === true) {\n      Matrix.IdentityToRef(other);\n      return this;\n    } // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n\n\n    var m = this._m;\n    var m00 = m[0],\n        m01 = m[1],\n        m02 = m[2],\n        m03 = m[3];\n    var m10 = m[4],\n        m11 = m[5],\n        m12 = m[6],\n        m13 = m[7];\n    var m20 = m[8],\n        m21 = m[9],\n        m22 = m[10],\n        m23 = m[11];\n    var m30 = m[12],\n        m31 = m[13],\n        m32 = m[14],\n        m33 = m[15];\n    var det_22_33 = m22 * m33 - m32 * m23;\n    var det_21_33 = m21 * m33 - m31 * m23;\n    var det_21_32 = m21 * m32 - m31 * m22;\n    var det_20_33 = m20 * m33 - m30 * m23;\n    var det_20_32 = m20 * m32 - m22 * m30;\n    var det_20_31 = m20 * m31 - m30 * m21;\n    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n    var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n\n    if (det === 0) {\n      // not invertible\n      other.copyFrom(this);\n      return this;\n    }\n\n    var detInv = 1 / det;\n    var det_12_33 = m12 * m33 - m32 * m13;\n    var det_11_33 = m11 * m33 - m31 * m13;\n    var det_11_32 = m11 * m32 - m31 * m12;\n    var det_10_33 = m10 * m33 - m30 * m13;\n    var det_10_32 = m10 * m32 - m30 * m12;\n    var det_10_31 = m10 * m31 - m30 * m11;\n    var det_12_23 = m12 * m23 - m22 * m13;\n    var det_11_23 = m11 * m23 - m21 * m13;\n    var det_11_22 = m11 * m22 - m21 * m12;\n    var det_10_23 = m10 * m23 - m20 * m13;\n    var det_10_22 = m10 * m22 - m20 * m12;\n    var det_10_21 = m10 * m21 - m20 * m11;\n    var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n    var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n    var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n    var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n    var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n    var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n    var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n    var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n    var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n    var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n    var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n    var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n    Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n    return this;\n  };\n  /**\n   * add a value at the specified position in the current Matrix\n   * @param index the index of the value within the matrix. between 0 and 15.\n   * @param value the value to be added\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.addAtIndex = function (index, value) {\n    this._m[index] += value;\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * mutiply the specified position in the current Matrix by a value\n   * @param index the index of the value within the matrix. between 0 and 15.\n   * @param value the value to be added\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.multiplyAtIndex = function (index, value) {\n    this._m[index] *= value;\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * Inserts the translation vector (using 3 floats) in the current matrix\n   * @param x defines the 1st component of the translation\n   * @param y defines the 2nd component of the translation\n   * @param z defines the 3rd component of the translation\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.setTranslationFromFloats = function (x, y, z) {\n    this._m[12] = x;\n    this._m[13] = y;\n    this._m[14] = z;\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * Adds the translation vector (using 3 floats) in the current matrix\n   * @param x defines the 1st component of the translation\n   * @param y defines the 2nd component of the translation\n   * @param z defines the 3rd component of the translation\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.addTranslationFromFloats = function (x, y, z) {\n    this._m[12] += x;\n    this._m[13] += y;\n    this._m[14] += z;\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * Inserts the translation vector in the current matrix\n   * @param vector3 defines the translation to insert\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.setTranslation = function (vector3) {\n    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\n  };\n  /**\n   * Gets the translation value of the current matrix\n   * @returns a new Vector3 as the extracted translation from the matrix\n   */\n\n\n  Matrix.prototype.getTranslation = function () {\n    return new Vector3(this._m[12], this._m[13], this._m[14]);\n  };\n  /**\n   * Fill a Vector3 with the extracted translation from the matrix\n   * @param result defines the Vector3 where to store the translation\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.getTranslationToRef = function (result) {\n    result.x = this._m[12];\n    result.y = this._m[13];\n    result.z = this._m[14];\n    return this;\n  };\n  /**\n   * Remove rotation and scaling part from the matrix\n   * @returns the updated matrix\n   */\n\n\n  Matrix.prototype.removeRotationAndScaling = function () {\n    var m = this.m;\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n\n    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n\n    return this;\n  };\n  /**\n   * Multiply two matrices\n   * @param other defines the second operand\n   * @returns a new matrix set with the multiplication result of the current Matrix and the given one\n   */\n\n\n  Matrix.prototype.multiply = function (other) {\n    var result = new Matrix();\n    this.multiplyToRef(other, result);\n    return result;\n  };\n  /**\n   * Copy the current matrix from the given one\n   * @param other defines the source matrix\n   * @returns the current updated matrix\n   */\n\n\n  Matrix.prototype.copyFrom = function (other) {\n    other.copyToArray(this._m);\n    var o = other;\n    this.updateFlag = o.updateFlag;\n\n    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n\n    return this;\n  };\n  /**\n   * Populates the given array from the starting index with the current matrix values\n   * @param array defines the target array\n   * @param offset defines the offset in the target array where to start storing values\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.copyToArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var source = this._m;\n    array[offset] = source[0];\n    array[offset + 1] = source[1];\n    array[offset + 2] = source[2];\n    array[offset + 3] = source[3];\n    array[offset + 4] = source[4];\n    array[offset + 5] = source[5];\n    array[offset + 6] = source[6];\n    array[offset + 7] = source[7];\n    array[offset + 8] = source[8];\n    array[offset + 9] = source[9];\n    array[offset + 10] = source[10];\n    array[offset + 11] = source[11];\n    array[offset + 12] = source[12];\n    array[offset + 13] = source[13];\n    array[offset + 14] = source[14];\n    array[offset + 15] = source[15];\n    return this;\n  };\n  /**\n   * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\n   * @param other defines the second operand\n   * @param result defines the matrix where to store the multiplication\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.multiplyToRef = function (other, result) {\n    if (this._isIdentity) {\n      result.copyFrom(other);\n      return this;\n    }\n\n    if (other._isIdentity) {\n      result.copyFrom(this);\n      return this;\n    }\n\n    this.multiplyToArray(other, result._m, 0);\n    result.markAsUpdated();\n    return this;\n  };\n  /**\n   * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\n   * @param other defines the second operand\n   * @param result defines the array where to store the multiplication\n   * @param offset defines the offset in the target array where to start storing values\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.multiplyToArray = function (other, result, offset) {\n    var m = this._m;\n    var otherM = other.m;\n    var tm0 = m[0],\n        tm1 = m[1],\n        tm2 = m[2],\n        tm3 = m[3];\n    var tm4 = m[4],\n        tm5 = m[5],\n        tm6 = m[6],\n        tm7 = m[7];\n    var tm8 = m[8],\n        tm9 = m[9],\n        tm10 = m[10],\n        tm11 = m[11];\n    var tm12 = m[12],\n        tm13 = m[13],\n        tm14 = m[14],\n        tm15 = m[15];\n    var om0 = otherM[0],\n        om1 = otherM[1],\n        om2 = otherM[2],\n        om3 = otherM[3];\n    var om4 = otherM[4],\n        om5 = otherM[5],\n        om6 = otherM[6],\n        om7 = otherM[7];\n    var om8 = otherM[8],\n        om9 = otherM[9],\n        om10 = otherM[10],\n        om11 = otherM[11];\n    var om12 = otherM[12],\n        om13 = otherM[13],\n        om14 = otherM[14],\n        om15 = otherM[15];\n    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n    return this;\n  };\n  /**\n   * Check equality between this matrix and a second one\n   * @param value defines the second matrix to compare\n   * @returns true is the current matrix and the given one values are strictly equal\n   */\n\n\n  Matrix.prototype.equals = function (value) {\n    var other = value;\n\n    if (!other) {\n      return false;\n    }\n\n    if (this._isIdentity || other._isIdentity) {\n      if (!this._isIdentityDirty && !other._isIdentityDirty) {\n        return this._isIdentity && other._isIdentity;\n      }\n    }\n\n    var m = this.m;\n    var om = other.m;\n    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];\n  };\n  /**\n   * Clone the current matrix\n   * @returns a new matrix from the current matrix\n   */\n\n\n  Matrix.prototype.clone = function () {\n    var matrix = new Matrix();\n    matrix.copyFrom(this);\n    return matrix;\n  };\n  /**\n   * Returns the name of the current matrix class\n   * @returns the string \"Matrix\"\n   */\n\n\n  Matrix.prototype.getClassName = function () {\n    return \"Matrix\";\n  };\n  /**\n   * Gets the hash code of the current matrix\n   * @returns the hash code\n   */\n\n\n  Matrix.prototype.getHashCode = function () {\n    var hash = _ExtractAsInt(this._m[0]);\n\n    for (var i = 1; i < 16; i++) {\n      hash = hash * 397 ^ _ExtractAsInt(this._m[i]);\n    }\n\n    return hash;\n  };\n  /**\n   * Decomposes the current Matrix into a translation, rotation and scaling components of the provided node\n   * @param node the node to decompose the matrix to\n   * @returns true if operation was successful\n   */\n\n\n  Matrix.prototype.decomposeToTransformNode = function (node) {\n    node.rotationQuaternion = node.rotationQuaternion || new Quaternion();\n    return this.decompose(node.scaling, node.rotationQuaternion, node.position);\n  };\n  /**\n   * Decomposes the current Matrix into a translation, rotation and scaling components\n   * @param scale defines the scale vector3 given as a reference to update\n   * @param rotation defines the rotation quaternion given as a reference to update\n   * @param translation defines the translation vector3 given as a reference to update\n   * @param preserveScalingNode Use scaling sign coming from this node. Otherwise scaling sign might change.\n   * @returns true if operation was successful\n   */\n\n\n  Matrix.prototype.decompose = function (scale, rotation, translation, preserveScalingNode) {\n    if (this._isIdentity) {\n      if (translation) {\n        translation.setAll(0);\n      }\n\n      if (scale) {\n        scale.setAll(1);\n      }\n\n      if (rotation) {\n        rotation.copyFromFloats(0, 0, 0, 1);\n      }\n\n      return true;\n    }\n\n    var m = this._m;\n\n    if (translation) {\n      translation.copyFromFloats(m[12], m[13], m[14]);\n    }\n\n    scale = scale || MathTmp.Vector3[0];\n    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n\n    if (preserveScalingNode) {\n      var signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;\n      var signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;\n      var signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;\n      scale.x *= signX;\n      scale.y *= signY;\n      scale.z *= signZ;\n    } else {\n      if (this.determinant() <= 0) {\n        scale.y *= -1;\n      }\n    }\n\n    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\n      if (rotation) {\n        rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n      }\n\n      return false;\n    }\n\n    if (rotation) {\n      var sx = 1 / scale._x,\n          sy = 1 / scale._y,\n          sz = 1 / scale._z;\n      Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, MathTmp.Matrix[0]);\n      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\n    }\n\n    return true;\n  };\n  /**\n   * Gets specific row of the matrix\n   * @param index defines the number of the row to get\n   * @returns the index-th row of the current matrix as a new Vector4\n   */\n\n\n  Matrix.prototype.getRow = function (index) {\n    if (index < 0 || index > 3) {\n      return null;\n    }\n\n    var i = index * 4;\n    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n  };\n  /**\n   * Sets the index-th row of the current matrix to the vector4 values\n   * @param index defines the number of the row to set\n   * @param row defines the target vector4\n   * @returns the updated current matrix\n   */\n\n\n  Matrix.prototype.setRow = function (index, row) {\n    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n  };\n  /**\n   * Compute the transpose of the matrix\n   * @returns the new transposed matrix\n   */\n\n\n  Matrix.prototype.transpose = function () {\n    return Matrix.Transpose(this);\n  };\n  /**\n   * Compute the transpose of the matrix and store it in a given matrix\n   * @param result defines the target matrix\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.transposeToRef = function (result) {\n    Matrix.TransposeToRef(this, result);\n    return this;\n  };\n  /**\n   * Sets the index-th row of the current matrix with the given 4 x float values\n   * @param index defines the row index\n   * @param x defines the x component to set\n   * @param y defines the y component to set\n   * @param z defines the z component to set\n   * @param w defines the w component to set\n   * @returns the updated current matrix\n   */\n\n\n  Matrix.prototype.setRowFromFloats = function (index, x, y, z, w) {\n    if (index < 0 || index > 3) {\n      return this;\n    }\n\n    var i = index * 4;\n    this._m[i + 0] = x;\n    this._m[i + 1] = y;\n    this._m[i + 2] = z;\n    this._m[i + 3] = w;\n    this.markAsUpdated();\n    return this;\n  };\n  /**\n   * Compute a new matrix set with the current matrix values multiplied by scale (float)\n   * @param scale defines the scale factor\n   * @returns a new matrix\n   */\n\n\n  Matrix.prototype.scale = function (scale) {\n    var result = new Matrix();\n    this.scaleToRef(scale, result);\n    return result;\n  };\n  /**\n   * Scale the current matrix values by a factor to a given result matrix\n   * @param scale defines the scale factor\n   * @param result defines the matrix to store the result\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.scaleToRef = function (scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = this._m[index] * scale;\n    }\n\n    result.markAsUpdated();\n    return this;\n  };\n  /**\n   * Scale the current matrix values by a factor and add the result to a given matrix\n   * @param scale defines the scale factor\n   * @param result defines the Matrix to store the result\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.scaleAndAddToRef = function (scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] += this._m[index] * scale;\n    }\n\n    result.markAsUpdated();\n    return this;\n  };\n  /**\n   * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\n   * @param ref matrix to store the result\n   */\n\n\n  Matrix.prototype.toNormalMatrix = function (ref) {\n    var tmp = MathTmp.Matrix[0];\n    this.invertToRef(tmp);\n    tmp.transposeToRef(ref);\n    var m = ref._m;\n    Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n  };\n  /**\n   * Gets only rotation part of the current matrix\n   * @returns a new matrix sets to the extracted rotation matrix from the current one\n   */\n\n\n  Matrix.prototype.getRotationMatrix = function () {\n    var result = new Matrix();\n    this.getRotationMatrixToRef(result);\n    return result;\n  };\n  /**\n   * Extracts the rotation matrix from the current one and sets it as the given \"result\"\n   * @param result defines the target matrix to store data to\n   * @returns the current matrix\n   */\n\n\n  Matrix.prototype.getRotationMatrixToRef = function (result) {\n    var scale = MathTmp.Vector3[0];\n\n    if (!this.decompose(scale)) {\n      Matrix.IdentityToRef(result);\n      return this;\n    }\n\n    var m = this._m;\n    var sx = 1 / scale._x,\n        sy = 1 / scale._y,\n        sz = 1 / scale._z;\n    Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n    return this;\n  };\n  /**\n   * Toggles model matrix from being right handed to left handed in place and vice versa\n   */\n\n\n  Matrix.prototype.toggleModelMatrixHandInPlace = function () {\n    var m = this._m;\n    m[2] *= -1;\n    m[6] *= -1;\n    m[8] *= -1;\n    m[9] *= -1;\n    m[14] *= -1;\n    this.markAsUpdated();\n  };\n  /**\n   * Toggles projection matrix from being right handed to left handed in place and vice versa\n   */\n\n\n  Matrix.prototype.toggleProjectionMatrixHandInPlace = function () {\n    var m = this._m;\n    m[8] *= -1;\n    m[9] *= -1;\n    m[10] *= -1;\n    m[11] *= -1;\n    this.markAsUpdated();\n  }; // Statics\n\n  /**\n   * Creates a matrix from an array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns a new Matrix set from the starting index of the given array\n   */\n\n\n  Matrix.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var result = new Matrix();\n    Matrix.FromArrayToRef(array, offset, result);\n    return result;\n  };\n  /**\n   * Copy the content of an array into a given matrix\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.FromArrayToRef = function (array, offset, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = array[index + offset];\n    }\n\n    result.markAsUpdated();\n  };\n  /**\n   * Stores an array into a matrix after having multiplied each component by a given factor\n   * @param array defines the source array\n   * @param offset defines the offset in the source array\n   * @param scale defines the scaling factor\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.FromFloat32ArrayToRefScaled = function (array, offset, scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = array[index + offset] * scale;\n    }\n\n    result.markAsUpdated();\n  };\n\n  Object.defineProperty(Matrix, \"IdentityReadOnly\", {\n    /**\n     * Gets an identity matrix that must not be updated\n     */\n    get: function get() {\n      return Matrix._IdentityReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Stores a list of values (16) inside a given matrix\n   * @param initialM11 defines 1st value of 1st row\n   * @param initialM12 defines 2nd value of 1st row\n   * @param initialM13 defines 3rd value of 1st row\n   * @param initialM14 defines 4th value of 1st row\n   * @param initialM21 defines 1st value of 2nd row\n   * @param initialM22 defines 2nd value of 2nd row\n   * @param initialM23 defines 3rd value of 2nd row\n   * @param initialM24 defines 4th value of 2nd row\n   * @param initialM31 defines 1st value of 3rd row\n   * @param initialM32 defines 2nd value of 3rd row\n   * @param initialM33 defines 3rd value of 3rd row\n   * @param initialM34 defines 4th value of 3rd row\n   * @param initialM41 defines 1st value of 4th row\n   * @param initialM42 defines 2nd value of 4th row\n   * @param initialM43 defines 3rd value of 4th row\n   * @param initialM44 defines 4th value of 4th row\n   * @param result defines the target matrix\n   */\n\n  Matrix.FromValuesToRef = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n    var m = result._m;\n    m[0] = initialM11;\n    m[1] = initialM12;\n    m[2] = initialM13;\n    m[3] = initialM14;\n    m[4] = initialM21;\n    m[5] = initialM22;\n    m[6] = initialM23;\n    m[7] = initialM24;\n    m[8] = initialM31;\n    m[9] = initialM32;\n    m[10] = initialM33;\n    m[11] = initialM34;\n    m[12] = initialM41;\n    m[13] = initialM42;\n    m[14] = initialM43;\n    m[15] = initialM44;\n    result.markAsUpdated();\n  };\n  /**\n   * Creates new matrix from a list of values (16)\n   * @param initialM11 defines 1st value of 1st row\n   * @param initialM12 defines 2nd value of 1st row\n   * @param initialM13 defines 3rd value of 1st row\n   * @param initialM14 defines 4th value of 1st row\n   * @param initialM21 defines 1st value of 2nd row\n   * @param initialM22 defines 2nd value of 2nd row\n   * @param initialM23 defines 3rd value of 2nd row\n   * @param initialM24 defines 4th value of 2nd row\n   * @param initialM31 defines 1st value of 3rd row\n   * @param initialM32 defines 2nd value of 3rd row\n   * @param initialM33 defines 3rd value of 3rd row\n   * @param initialM34 defines 4th value of 3rd row\n   * @param initialM41 defines 1st value of 4th row\n   * @param initialM42 defines 2nd value of 4th row\n   * @param initialM43 defines 3rd value of 4th row\n   * @param initialM44 defines 4th value of 4th row\n   * @returns the new matrix\n   */\n\n\n  Matrix.FromValues = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n    var result = new Matrix();\n    var m = result._m;\n    m[0] = initialM11;\n    m[1] = initialM12;\n    m[2] = initialM13;\n    m[3] = initialM14;\n    m[4] = initialM21;\n    m[5] = initialM22;\n    m[6] = initialM23;\n    m[7] = initialM24;\n    m[8] = initialM31;\n    m[9] = initialM32;\n    m[10] = initialM33;\n    m[11] = initialM34;\n    m[12] = initialM41;\n    m[13] = initialM42;\n    m[14] = initialM43;\n    m[15] = initialM44;\n    result.markAsUpdated();\n    return result;\n  };\n  /**\n   * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n   * @param scale defines the scale vector3\n   * @param rotation defines the rotation quaternion\n   * @param translation defines the translation vector3\n   * @returns a new matrix\n   */\n\n\n  Matrix.Compose = function (scale, rotation, translation) {\n    var result = new Matrix();\n    Matrix.ComposeToRef(scale, rotation, translation, result);\n    return result;\n  };\n  /**\n   * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n   * @param scale defines the scale vector3\n   * @param rotation defines the rotation quaternion\n   * @param translation defines the translation vector3\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.ComposeToRef = function (scale, rotation, translation, result) {\n    var m = result._m;\n    var x = rotation._x,\n        y = rotation._y,\n        z = rotation._z,\n        w = rotation._w;\n    var x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    var xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    var yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    var wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n    var sx = scale._x,\n        sy = scale._y,\n        sz = scale._z;\n    m[0] = (1 - (yy + zz)) * sx;\n    m[1] = (xy + wz) * sx;\n    m[2] = (xz - wy) * sx;\n    m[3] = 0;\n    m[4] = (xy - wz) * sy;\n    m[5] = (1 - (xx + zz)) * sy;\n    m[6] = (yz + wx) * sy;\n    m[7] = 0;\n    m[8] = (xz + wy) * sz;\n    m[9] = (yz - wx) * sz;\n    m[10] = (1 - (xx + yy)) * sz;\n    m[11] = 0;\n    m[12] = translation._x;\n    m[13] = translation._y;\n    m[14] = translation._z;\n    m[15] = 1;\n    result.markAsUpdated();\n  };\n  /**\n   * Creates a new identity matrix\n   * @returns a new identity matrix\n   */\n\n\n  Matrix.Identity = function () {\n    var identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    identity._updateIdentityStatus(true);\n\n    return identity;\n  };\n  /**\n   * Creates a new identity matrix and stores the result in a given matrix\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.IdentityToRef = function (result) {\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(true);\n  };\n  /**\n   * Creates a new zero matrix\n   * @returns a new zero matrix\n   */\n\n\n  Matrix.Zero = function () {\n    var zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\n    zero._updateIdentityStatus(false);\n\n    return zero;\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the X axis\n   * @param angle defines the angle (in radians) to use\n   * @return the new matrix\n   */\n\n\n  Matrix.RotationX = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationXToRef(angle, result);\n    return result;\n  };\n  /**\n   * Creates a new matrix as the invert of a given matrix\n   * @param source defines the source matrix\n   * @returns the new matrix\n   */\n\n\n  Matrix.Invert = function (source) {\n    var result = new Matrix();\n    source.invertToRef(result);\n    return result;\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\n   * @param angle defines the angle (in radians) to use\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationXToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the Y axis\n   * @param angle defines the angle (in radians) to use\n   * @return the new matrix\n   */\n\n\n  Matrix.RotationY = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationYToRef(angle, result);\n    return result;\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\n   * @param angle defines the angle (in radians) to use\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationYToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the Z axis\n   * @param angle defines the angle (in radians) to use\n   * @return the new matrix\n   */\n\n\n  Matrix.RotationZ = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationZToRef(angle, result);\n    return result;\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\n   * @param angle defines the angle (in radians) to use\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationZToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the given axis\n   * @param axis defines the axis to use\n   * @param angle defines the angle (in radians) to use\n   * @return the new matrix\n   */\n\n\n  Matrix.RotationAxis = function (axis, angle) {\n    var result = new Matrix();\n    Matrix.RotationAxisToRef(axis, angle, result);\n    return result;\n  };\n  /**\n   * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\n   * @param axis defines the axis to use\n   * @param angle defines the angle (in radians) to use\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationAxisToRef = function (axis, angle, result) {\n    var s = Math.sin(-angle);\n    var c = Math.cos(-angle);\n    var c1 = 1 - c;\n    axis.normalize();\n    var m = result._m;\n    m[0] = axis._x * axis._x * c1 + c;\n    m[1] = axis._x * axis._y * c1 - axis._z * s;\n    m[2] = axis._x * axis._z * c1 + axis._y * s;\n    m[3] = 0.0;\n    m[4] = axis._y * axis._x * c1 + axis._z * s;\n    m[5] = axis._y * axis._y * c1 + c;\n    m[6] = axis._y * axis._z * c1 - axis._x * s;\n    m[7] = 0.0;\n    m[8] = axis._z * axis._x * c1 - axis._y * s;\n    m[9] = axis._z * axis._y * c1 + axis._x * s;\n    m[10] = axis._z * axis._z * c1 + c;\n    m[11] = 0.0;\n    m[12] = 0.0;\n    m[13] = 0.0;\n    m[14] = 0.0;\n    m[15] = 1.0;\n    result.markAsUpdated();\n  };\n  /**\n   * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\n   * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\n   * @param from defines the vector to align\n   * @param to defines the vector to align to\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationAlignToRef = function (from, to, result) {\n    var c = Vector3.Dot(to, from);\n    var m = result._m;\n\n    if (c < -1 + Epsilon) {\n      // from and to are colinear and opposite direction.\n      // compute a PI rotation on Z axis\n      m[0] = -1;\n      m[1] = 0;\n      m[2] = 0;\n      m[3] = 0;\n      m[4] = 0;\n      m[5] = -1;\n      m[6] = 0;\n      m[7] = 0;\n      m[8] = 0;\n      m[9] = 0;\n      m[10] = 1;\n      m[11] = 0;\n    } else {\n      var v = Vector3.Cross(to, from);\n      var k = 1 / (1 + c);\n      m[0] = v._x * v._x * k + c;\n      m[1] = v._y * v._x * k - v._z;\n      m[2] = v._z * v._x * k + v._y;\n      m[3] = 0;\n      m[4] = v._x * v._y * k + v._z;\n      m[5] = v._y * v._y * k + c;\n      m[6] = v._z * v._y * k - v._x;\n      m[7] = 0;\n      m[8] = v._x * v._z * k - v._y;\n      m[9] = v._y * v._z * k + v._x;\n      m[10] = v._z * v._z * k + c;\n      m[11] = 0;\n    }\n\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n    result.markAsUpdated();\n  };\n  /**\n   * Creates a rotation matrix\n   * @param yaw defines the yaw angle in radians (Y axis)\n   * @param pitch defines the pitch angle in radians (X axis)\n   * @param roll defines the roll angle in radians (Z axis)\n   * @returns the new rotation matrix\n   */\n\n\n  Matrix.RotationYawPitchRoll = function (yaw, pitch, roll) {\n    var result = new Matrix();\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n    return result;\n  };\n  /**\n   * Creates a rotation matrix and stores it in a given matrix\n   * @param yaw defines the yaw angle in radians (Y axis)\n   * @param pitch defines the pitch angle in radians (X axis)\n   * @param roll defines the roll angle in radians (Z axis)\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\n    MathTmp.Quaternion[0].toRotationMatrix(result);\n  };\n  /**\n   * Creates a scaling matrix\n   * @param x defines the scale factor on X axis\n   * @param y defines the scale factor on Y axis\n   * @param z defines the scale factor on Z axis\n   * @returns the new matrix\n   */\n\n\n  Matrix.Scaling = function (x, y, z) {\n    var result = new Matrix();\n    Matrix.ScalingToRef(x, y, z, result);\n    return result;\n  };\n  /**\n   * Creates a scaling matrix and stores it in a given matrix\n   * @param x defines the scale factor on X axis\n   * @param y defines the scale factor on Y axis\n   * @param z defines the scale factor on Z axis\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.ScalingToRef = function (x, y, z, result) {\n    Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n  };\n  /**\n   * Creates a translation matrix\n   * @param x defines the translation on X axis\n   * @param y defines the translation on Y axis\n   * @param z defines the translationon Z axis\n   * @returns the new matrix\n   */\n\n\n  Matrix.Translation = function (x, y, z) {\n    var result = new Matrix();\n    Matrix.TranslationToRef(x, y, z, result);\n    return result;\n  };\n  /**\n   * Creates a translation matrix and stores it in a given matrix\n   * @param x defines the translation on X axis\n   * @param y defines the translation on Y axis\n   * @param z defines the translationon Z axis\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.TranslationToRef = function (x, y, z, result) {\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n\n    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n  };\n  /**\n   * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n   * @param startValue defines the start value\n   * @param endValue defines the end value\n   * @param gradient defines the gradient factor\n   * @returns the new matrix\n   */\n\n\n  Matrix.Lerp = function (startValue, endValue, gradient) {\n    var result = new Matrix();\n    Matrix.LerpToRef(startValue, endValue, gradient, result);\n    return result;\n  };\n  /**\n   * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n   * @param startValue defines the start value\n   * @param endValue defines the end value\n   * @param gradient defines the gradient factor\n   * @param result defines the Matrix object where to store data\n   */\n\n\n  Matrix.LerpToRef = function (startValue, endValue, gradient, result) {\n    var resultM = result._m;\n    var startM = startValue.m;\n    var endM = endValue.m;\n\n    for (var index = 0; index < 16; index++) {\n      resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\n    }\n\n    result.markAsUpdated();\n  };\n  /**\n   * Builds a new matrix whose values are computed by:\n   * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n   * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n   * @param startValue defines the first matrix\n   * @param endValue defines the second matrix\n   * @param gradient defines the gradient between the two matrices\n   * @returns the new matrix\n   */\n\n\n  Matrix.DecomposeLerp = function (startValue, endValue, gradient) {\n    var result = new Matrix();\n    Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n    return result;\n  };\n  /**\n   * Update a matrix to values which are computed by:\n   * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n   * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n   * @param startValue defines the first matrix\n   * @param endValue defines the second matrix\n   * @param gradient defines the gradient between the two matrices\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.DecomposeLerpToRef = function (startValue, endValue, gradient, result) {\n    var startScale = MathTmp.Vector3[0];\n    var startRotation = MathTmp.Quaternion[0];\n    var startTranslation = MathTmp.Vector3[1];\n    startValue.decompose(startScale, startRotation, startTranslation);\n    var endScale = MathTmp.Vector3[2];\n    var endRotation = MathTmp.Quaternion[1];\n    var endTranslation = MathTmp.Vector3[3];\n    endValue.decompose(endScale, endRotation, endTranslation);\n    var resultScale = MathTmp.Vector3[4];\n    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n    var resultRotation = MathTmp.Quaternion[2];\n    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n    var resultTranslation = MathTmp.Vector3[5];\n    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n    Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n  };\n  /**\n   * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n   * This function works in left handed mode\n   * @param eye defines the final position of the entity\n   * @param target defines where the entity should look at\n   * @param up defines the up vector for the entity\n   * @returns the new matrix\n   */\n\n\n  Matrix.LookAtLH = function (eye, target, up) {\n    var result = new Matrix();\n    Matrix.LookAtLHToRef(eye, target, up, result);\n    return result;\n  };\n  /**\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n   * This function works in left handed mode\n   * @param eye defines the final position of the entity\n   * @param target defines where the entity should look at\n   * @param up defines the up vector for the entity\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.LookAtLHToRef = function (eye, target, up, result) {\n    var xAxis = MathTmp.Vector3[0];\n    var yAxis = MathTmp.Vector3[1];\n    var zAxis = MathTmp.Vector3[2]; // Z axis\n\n    target.subtractToRef(eye, zAxis);\n    zAxis.normalize(); // X axis\n\n    Vector3.CrossToRef(up, zAxis, xAxis);\n    var xSquareLength = xAxis.lengthSquared();\n\n    if (xSquareLength === 0) {\n      xAxis.x = 1.0;\n    } else {\n      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n    } // Y axis\n\n\n    Vector3.CrossToRef(zAxis, xAxis, yAxis);\n    yAxis.normalize(); // Eye angles\n\n    var ex = -Vector3.Dot(xAxis, eye);\n    var ey = -Vector3.Dot(yAxis, eye);\n    var ez = -Vector3.Dot(zAxis, eye);\n    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n  };\n  /**\n   * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n   * This function works in right handed mode\n   * @param eye defines the final position of the entity\n   * @param target defines where the entity should look at\n   * @param up defines the up vector for the entity\n   * @returns the new matrix\n   */\n\n\n  Matrix.LookAtRH = function (eye, target, up) {\n    var result = new Matrix();\n    Matrix.LookAtRHToRef(eye, target, up, result);\n    return result;\n  };\n  /**\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n   * This function works in right handed mode\n   * @param eye defines the final position of the entity\n   * @param target defines where the entity should look at\n   * @param up defines the up vector for the entity\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.LookAtRHToRef = function (eye, target, up, result) {\n    var xAxis = MathTmp.Vector3[0];\n    var yAxis = MathTmp.Vector3[1];\n    var zAxis = MathTmp.Vector3[2]; // Z axis\n\n    eye.subtractToRef(target, zAxis);\n    zAxis.normalize(); // X axis\n\n    Vector3.CrossToRef(up, zAxis, xAxis);\n    var xSquareLength = xAxis.lengthSquared();\n\n    if (xSquareLength === 0) {\n      xAxis.x = 1.0;\n    } else {\n      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n    } // Y axis\n\n\n    Vector3.CrossToRef(zAxis, xAxis, yAxis);\n    yAxis.normalize(); // Eye angles\n\n    var ex = -Vector3.Dot(xAxis, eye);\n    var ey = -Vector3.Dot(yAxis, eye);\n    var ez = -Vector3.Dot(zAxis, eye);\n    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n  };\n  /**\n   * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up direction being oriented like \"up\".\n   * This function works in left handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @returns the new matrix\n   */\n\n\n  Matrix.LookDirectionLH = function (forward, up) {\n    var result = new Matrix();\n    Matrix.LookDirectionLHToRef(forward, up, result);\n    return result;\n  };\n  /**\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up direction being oriented like \"up\".\n   * This function works in left handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.LookDirectionLHToRef = function (forward, up, result) {\n    var back = MathTmp.Vector3[0];\n    back.copyFrom(forward);\n    back.scaleInPlace(-1);\n    var left = MathTmp.Vector3[1];\n    Vector3.CrossToRef(up, back, left); // Generate the rotation matrix.\n\n    Matrix.FromValuesToRef(left._x, left._y, left._z, 0.0, up._x, up._y, up._z, 0.0, back._x, back._y, back._z, 0.0, 0, 0, 0, 1.0, result);\n  };\n  /**\n   * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up Vector3 being oriented like \"up\".\n   * This function works in right handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @returns the new matrix\n   */\n\n\n  Matrix.LookDirectionRH = function (forward, up) {\n    var result = new Matrix();\n    Matrix.LookDirectionRHToRef(forward, up, result);\n    return result;\n  };\n  /**\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up vector3 being oriented like \"up\".\n   * This function works in right handed mode\n   * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.LookDirectionRHToRef = function (forward, up, result) {\n    var right = MathTmp.Vector3[2];\n    Vector3.CrossToRef(up, forward, right); // Generate the rotation matrix.\n\n    Matrix.FromValuesToRef(right._x, right._y, right._z, 0.0, up._x, up._y, up._z, 0.0, forward._x, forward._y, forward._z, 0.0, 0, 0, 0, 1.0, result);\n  };\n  /**\n   * Create a left-handed orthographic projection matrix\n   * @param width defines the viewport width\n   * @param height defines the viewport height\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @returns a new matrix as a left-handed orthographic projection matrix\n   */\n\n\n  Matrix.OrthoLH = function (width, height, znear, zfar, halfZRange) {\n    var matrix = new Matrix();\n    Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);\n    return matrix;\n  };\n  /**\n   * Store a left-handed orthographic projection to a given matrix\n   * @param width defines the viewport width\n   * @param height defines the viewport height\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param result defines the target matrix\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   */\n\n\n  Matrix.OrthoLHToRef = function (width, height, znear, zfar, result, halfZRange) {\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 / width;\n    var b = 2.0 / height;\n    var c = 2.0 / (f - n);\n    var d = -(f + n) / (f - n);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n  };\n  /**\n   * Create a left-handed orthographic projection matrix\n   * @param left defines the viewport left coordinate\n   * @param right defines the viewport right coordinate\n   * @param bottom defines the viewport bottom coordinate\n   * @param top defines the viewport top coordinate\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @returns a new matrix as a left-handed orthographic projection matrix\n   */\n\n\n  Matrix.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar, halfZRange) {\n    var matrix = new Matrix();\n    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n    return matrix;\n  };\n  /**\n   * Stores a left-handed orthographic projection into a given matrix\n   * @param left defines the viewport left coordinate\n   * @param right defines the viewport right coordinate\n   * @param bottom defines the viewport bottom coordinate\n   * @param top defines the viewport top coordinate\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param result defines the target matrix\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   */\n\n\n  Matrix.OrthoOffCenterLHToRef = function (left, right, bottom, top, znear, zfar, result, halfZRange) {\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 / (right - left);\n    var b = 2.0 / (top - bottom);\n    var c = 2.0 / (f - n);\n    var d = -(f + n) / (f - n);\n    var i0 = (left + right) / (left - right);\n    var i1 = (top + bottom) / (bottom - top);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result.markAsUpdated();\n  };\n  /**\n   * Creates a right-handed orthographic projection matrix\n   * @param left defines the viewport left coordinate\n   * @param right defines the viewport right coordinate\n   * @param bottom defines the viewport bottom coordinate\n   * @param top defines the viewport top coordinate\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @returns a new matrix as a right-handed orthographic projection matrix\n   */\n\n\n  Matrix.OrthoOffCenterRH = function (left, right, bottom, top, znear, zfar, halfZRange) {\n    var matrix = new Matrix();\n    Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n    return matrix;\n  };\n  /**\n   * Stores a right-handed orthographic projection into a given matrix\n   * @param left defines the viewport left coordinate\n   * @param right defines the viewport right coordinate\n   * @param bottom defines the viewport bottom coordinate\n   * @param top defines the viewport top coordinate\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param result defines the target matrix\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   */\n\n\n  Matrix.OrthoOffCenterRHToRef = function (left, right, bottom, top, znear, zfar, result, halfZRange) {\n    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);\n    result._m[10] *= -1; // No need to call markAsUpdated as previous function already called it and let _isIdentityDirty to true\n  };\n  /**\n   * Creates a left-handed perspective projection matrix\n   * @param width defines the viewport width\n   * @param height defines the viewport height\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   * @returns a new matrix as a left-handed perspective projection matrix\n   */\n\n\n  Matrix.PerspectiveLH = function (width, height, znear, zfar, halfZRange, projectionPlaneTilt) {\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    var matrix = new Matrix();\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 * n / width;\n    var b = 2.0 * n / height;\n    var c = (f + n) / (f - n);\n    var d = -2.0 * f * n / (f - n);\n    var rot = Math.tan(projectionPlaneTilt);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n\n    if (halfZRange) {\n      matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);\n    }\n\n    matrix._updateIdentityStatus(false);\n\n    return matrix;\n  };\n  /**\n   * Creates a left-handed perspective projection matrix\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n   * @returns a new matrix as a left-handed perspective projection matrix\n   */\n\n\n  Matrix.PerspectiveFovLH = function (fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    if (reverseDepthBufferMode === void 0) {\n      reverseDepthBufferMode = false;\n    }\n\n    var matrix = new Matrix();\n    Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n    return matrix;\n  };\n  /**\n   * Stores a left-handed perspective projection into a given matrix\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n   * @param result defines the target matrix\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n   */\n\n\n  Matrix.PerspectiveFovLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    if (reverseDepthBufferMode === void 0) {\n      reverseDepthBufferMode = false;\n    }\n\n    var n = znear;\n    var f = zfar;\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;\n    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2.0 * f * n / (f - n) : -2 * n;\n    var rot = Math.tan(projectionPlaneTilt);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result._updateIdentityStatus(false);\n  };\n  /**\n   * Stores a left-handed perspective projection into a given matrix with depth reversed\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar not used as infinity is used as far clip\n   * @param result defines the target matrix\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   */\n\n\n  Matrix.PerspectiveFovReverseLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var rot = Math.tan(projectionPlaneTilt);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, 1.0, 0.0, 0.0, 1.0, 0.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result._updateIdentityStatus(false);\n  };\n  /**\n   * Creates a right-handed perspective projection matrix\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n   * @returns a new matrix as a right-handed perspective projection matrix\n   */\n\n\n  Matrix.PerspectiveFovRH = function (fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    if (reverseDepthBufferMode === void 0) {\n      reverseDepthBufferMode = false;\n    }\n\n    var matrix = new Matrix();\n    Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n    return matrix;\n  };\n  /**\n   * Stores a right-handed perspective projection into a given matrix\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n   * @param result defines the target matrix\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n   */\n\n\n  Matrix.PerspectiveFovRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n    //alternatively this could be expressed as:\n    //    m = PerspectiveFovLHToRef\n    //    m[10] *= -1.0;\n    //    m[11] *= -1.0;\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    if (reverseDepthBufferMode === void 0) {\n      reverseDepthBufferMode = false;\n    }\n\n    var n = znear;\n    var f = zfar;\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;\n    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;\n    var rot = Math.tan(projectionPlaneTilt);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result._updateIdentityStatus(false);\n  };\n  /**\n   * Stores a right-handed perspective projection into a given matrix\n   * @param fov defines the horizontal field of view\n   * @param aspect defines the aspect ratio\n   * @param znear defines the near clip plane\n   * @param zfar not used as infinity is used as far clip\n   * @param result defines the target matrix\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   */\n\n\n  Matrix.PerspectiveFovReverseRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var rot = Math.tan(projectionPlaneTilt);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, -1.0, 0.0, 0.0, -1.0, 0.0, result);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result._updateIdentityStatus(false);\n  };\n  /**\n   * Stores a perspective projection for WebVR info a given matrix\n   * @param fov defines the field of view\n   * @param fov.upDegrees\n   * @param fov.downDegrees\n   * @param fov.leftDegrees\n   * @param fov.rightDegrees\n   * @param znear defines the near clip plane\n   * @param zfar defines the far clip plane\n   * @param result defines the target matrix\n   * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\n   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n   */\n\n\n  Matrix.PerspectiveFovWebVRToRef = function (fov, znear, zfar, result, rightHanded, halfZRange, projectionPlaneTilt) {\n    if (rightHanded === void 0) {\n      rightHanded = false;\n    }\n\n    if (projectionPlaneTilt === void 0) {\n      projectionPlaneTilt = 0;\n    }\n\n    var rightHandedFactor = rightHanded ? -1 : 1;\n    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n    var xScale = 2.0 / (leftTan + rightTan);\n    var yScale = 2.0 / (upTan + downTan);\n    var rot = Math.tan(projectionPlaneTilt);\n    var m = result._m;\n    m[0] = xScale;\n    m[1] = m[2] = m[3] = m[4] = 0.0;\n    m[5] = yScale;\n    m[6] = 0.0;\n    m[7] = rot;\n    m[8] = (leftTan - rightTan) * xScale * 0.5;\n    m[9] = -((upTan - downTan) * yScale * 0.5);\n    m[10] = -zfar / (znear - zfar);\n    m[11] = 1.0 * rightHandedFactor;\n    m[12] = m[13] = m[15] = 0.0;\n    m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n\n    if (halfZRange) {\n      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n    }\n\n    result.markAsUpdated();\n  };\n  /**\n   * Computes a complete transformation matrix\n   * @param viewport defines the viewport to use\n   * @param world defines the world matrix\n   * @param view defines the view matrix\n   * @param projection defines the projection matrix\n   * @param zmin defines the near clip plane\n   * @param zmax defines the far clip plane\n   * @returns the transformation matrix\n   */\n\n\n  Matrix.GetFinalMatrix = function (viewport, world, view, projection, zmin, zmax) {\n    var cw = viewport.width;\n    var ch = viewport.height;\n    var cx = viewport.x;\n    var cy = viewport.y;\n    var viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    return matrix.multiply(viewportMatrix);\n  };\n  /**\n   * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\n   * @param matrix defines the matrix to use\n   * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\n   */\n\n\n  Matrix.GetAsMatrix2x2 = function (matrix) {\n    var m = matrix.m;\n    var arr = [m[0], m[1], m[4], m[5]];\n    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n  };\n  /**\n   * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\n   * @param matrix defines the matrix to use\n   * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\n   */\n\n\n  Matrix.GetAsMatrix3x3 = function (matrix) {\n    var m = matrix.m;\n    var arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\n    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n  };\n  /**\n   * Compute the transpose of a given matrix\n   * @param matrix defines the matrix to transpose\n   * @returns the new matrix\n   */\n\n\n  Matrix.Transpose = function (matrix) {\n    var result = new Matrix();\n    Matrix.TransposeToRef(matrix, result);\n    return result;\n  };\n  /**\n   * Compute the transpose of a matrix and store it in a target matrix\n   * @param matrix defines the matrix to transpose\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.TransposeToRef = function (matrix, result) {\n    var rm = result._m;\n    var mm = matrix.m;\n    rm[0] = mm[0];\n    rm[1] = mm[4];\n    rm[2] = mm[8];\n    rm[3] = mm[12];\n    rm[4] = mm[1];\n    rm[5] = mm[5];\n    rm[6] = mm[9];\n    rm[7] = mm[13];\n    rm[8] = mm[2];\n    rm[9] = mm[6];\n    rm[10] = mm[10];\n    rm[11] = mm[14];\n    rm[12] = mm[3];\n    rm[13] = mm[7];\n    rm[14] = mm[11];\n    rm[15] = mm[15];\n    result.markAsUpdated(); // identity-ness does not change when transposing\n\n    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n  };\n  /**\n   * Computes a reflection matrix from a plane\n   * @param plane defines the reflection plane\n   * @returns a new matrix\n   */\n\n\n  Matrix.Reflection = function (plane) {\n    var matrix = new Matrix();\n    Matrix.ReflectionToRef(plane, matrix);\n    return matrix;\n  };\n  /**\n   * Computes a reflection matrix from a plane\n   * @param plane defines the reflection plane\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.ReflectionToRef = function (plane, result) {\n    plane.normalize();\n    var x = plane.normal.x;\n    var y = plane.normal.y;\n    var z = plane.normal.z;\n    var temp = -2 * x;\n    var temp2 = -2 * y;\n    var temp3 = -2 * z;\n    Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n  };\n  /**\n   * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\n   * @param xaxis defines the value of the 1st axis\n   * @param yaxis defines the value of the 2nd axis\n   * @param zaxis defines the value of the 3rd axis\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.FromXYZAxesToRef = function (xaxis, yaxis, zaxis, result) {\n    Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0.0, yaxis._x, yaxis._y, yaxis._z, 0.0, zaxis._x, zaxis._y, zaxis._z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n  };\n  /**\n   * Creates a rotation matrix from a quaternion and stores it in a target matrix\n   * @param quat defines the quaternion to use\n   * @param result defines the target matrix\n   */\n\n\n  Matrix.FromQuaternionToRef = function (quat, result) {\n    var xx = quat._x * quat._x;\n    var yy = quat._y * quat._y;\n    var zz = quat._z * quat._z;\n    var xy = quat._x * quat._y;\n    var zw = quat._z * quat._w;\n    var zx = quat._z * quat._x;\n    var yw = quat._y * quat._w;\n    var yz = quat._y * quat._z;\n    var xw = quat._x * quat._w;\n    result._m[0] = 1.0 - 2.0 * (yy + zz);\n    result._m[1] = 2.0 * (xy + zw);\n    result._m[2] = 2.0 * (zx - yw);\n    result._m[3] = 0.0;\n    result._m[4] = 2.0 * (xy - zw);\n    result._m[5] = 1.0 - 2.0 * (zz + xx);\n    result._m[6] = 2.0 * (yz + xw);\n    result._m[7] = 0.0;\n    result._m[8] = 2.0 * (zx + yw);\n    result._m[9] = 2.0 * (yz - xw);\n    result._m[10] = 1.0 - 2.0 * (yy + xx);\n    result._m[11] = 0.0;\n    result._m[12] = 0.0;\n    result._m[13] = 0.0;\n    result._m[14] = 0.0;\n    result._m[15] = 1.0;\n    result.markAsUpdated();\n  };\n\n  Matrix._UpdateFlagSeed = 0;\n  Matrix._IdentityReadOnly = Matrix.Identity();\n  return Matrix;\n}();\n\nexport { Matrix };\n/**\n * @hidden\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\n */\n\nvar MathTmp =\n/** @class */\nfunction () {\n  function MathTmp() {}\n\n  MathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);\n  MathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);\n  MathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);\n  return MathTmp;\n}();\n/**\n * @hidden\n */\n\n\nvar TmpVectors =\n/** @class */\nfunction () {\n  function TmpVectors() {}\n\n  TmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\n\n  TmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\n\n  TmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\n\n  TmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\n\n  TmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity); // 8 temp Matrices at once should be enough\n\n  return TmpVectors;\n}();\n\nexport { TmpVectors };\nRegisterClass(\"BABYLON.Vector2\", Vector2);\nRegisterClass(\"BABYLON.Vector3\", Vector3);\nRegisterClass(\"BABYLON.Vector4\", Vector4);\nRegisterClass(\"BABYLON.Matrix\", Matrix);\nvar mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,SAASA,MAAT,QAAuB,kBAAvB;AACA,SAASC,OAAT,QAAwB,qBAAxB;AAGA,SAASC,UAAT,QAA2B,uBAA3B;AAEA,SAASC,aAAT,QAA8B,sBAA9B;AAEA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,SAASC,WAAT,QAA4B,2BAA5B,C,CAIA;;AACA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,KAAD,EAAc;AAChC,SAAOC,QAAQ,CAACD,KAAK,CAACE,QAAN,GAAiBC,OAAjB,CAAyB,KAAzB,EAAgC,EAAhC,CAAD,CAAf;AACH,CAFD;AAIA;;;;;AAGA;AAAA;AAAA;AACI;;;;;AAKA;AACI;AACOC,GAFX;AAGI;AACOC,GAJX,EAIwB;AAFb;AAAAD;AAAa;;AAEb;AAAAC;AAAa;;AAFb;AAEA;AACP;AAEJ;;;;;;AAIOC,+BAAP;AACI,WAAO,cAAO,KAAKF,CAAZ,EAAa,MAAb,EAAaG,MAAb,CAAoB,KAAKF,CAAzB,EAA0B,GAA1B,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,mCAAP;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIOA,kCAAP;AACI,QAAMF,CAAC,GAAGL,aAAa,CAAC,KAAKK,CAAN,CAAvB;;AACA,QAAMC,CAAC,GAAGN,aAAa,CAAC,KAAKM,CAAN,CAAvB;;AACA,QAAIG,IAAI,GAAGJ,CAAX;AACAI,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAeH,CAAtB;AACA,WAAOG,IAAP;AACH,GANM,CAjCX,CAyCI;;AAEA;;;;;;;;AAMOF,8BAAP,UAAeG,KAAf,EAAkCC,KAAlC,EAAmD;AAAjB;AAAAA;AAAiB;;AAC/CD,SAAK,CAACC,KAAD,CAAL,GAAe,KAAKN,CAApB;AACAK,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAKL,CAAxB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOC,gCAAP,UAAiBG,KAAjB,EAAoCC,KAApC,EAAqD;AAAjB;AAAAA;AAAiB;;AACjDJ,WAAO,CAACK,cAAR,CAAuBF,KAAvB,EAA8BC,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIOJ,8BAAP;AACI,QAAMM,MAAM,GAAG,IAAIC,KAAJ,EAAf;AACA,SAAKC,OAAL,CAAaF,MAAb,EAAqB,CAArB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;AAKON,+BAAP,UAAgBS,MAAhB,EAA8C;AAC1C,SAAKX,CAAL,GAASW,MAAM,CAACX,CAAhB;AACA,SAAKC,CAAL,GAASU,MAAM,CAACV,CAAhB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOC,qCAAP,UAAsBF,CAAtB,EAAiCC,CAAjC,EAA0C;AACtC,SAAKD,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOC,0BAAP,UAAWF,CAAX,EAAsBC,CAAtB,EAA+B;AAC3B,WAAO,KAAKW,cAAL,CAAoBZ,CAApB,EAAuBC,CAAvB,CAAP;AACH,GAFM;AAGP;;;;;;;AAKOC,0BAAP,UAAWW,WAAX,EAA8C;AAC1C,WAAO,IAAIX,OAAJ,CAAY,KAAKF,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,+BAAP,UAAgBW,WAAhB,EAAqDL,MAArD,EAAoE;AAChEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,iCAAP,UAAkBW,WAAlB,EAAqD;AACjD,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,iCAAP,UAAkBW,WAAlB,EAAsC;AAClC,WAAO,IAAIX,OAAJ,CAAY,KAAKF,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,+BAAP,UAAgBW,WAAhB,EAAoC;AAChC,WAAO,IAAIX,OAAJ,CAAY,KAAKF,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,oCAAP,UAAqBW,WAArB,EAA0DL,MAA1D,EAAyE;AACrEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAKP;;;;;;;AAKOC,sCAAP,UAAuBW,WAAvB,EAA0D;AACtD,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,sCAAP,UAAuBW,WAAvB,EAA0D;AACtD,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,+BAAP,UAAgBW,WAAhB,EAAmD;AAC/C,WAAO,IAAIX,OAAJ,CAAY,KAAKF,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,oCAAP,UAAqBW,WAArB,EAA0DL,MAA1D,EAAyE;AACrEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOC,uCAAP,UAAwBF,CAAxB,EAAmCC,CAAnC,EAA4C;AACxC,WAAO,IAAIC,OAAJ,CAAY,KAAKF,CAAL,GAASA,CAArB,EAAwB,KAAKC,CAAL,GAASA,CAAjC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,6BAAP,UAAcW,WAAd,EAAkC;AAC9B,WAAO,IAAIX,OAAJ,CAAY,KAAKF,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,kCAAP,UAAmBW,WAAnB,EAAwDL,MAAxD,EAAuE;AACnEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,oCAAP,UAAqBW,WAArB,EAAwD;AACpD,WAAO,KAAKC,WAAL,CAAiBD,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;AAIOX,6BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAC,KAAKF,CAAlB,EAAqB,CAAC,KAAKC,CAA3B,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,oCAAP;AACI,SAAKF,CAAL,IAAU,CAAC,CAAX;AACA,SAAKC,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOC,kCAAP,UAAmBM,MAAnB,EAAkC;AAC9B,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKZ,CAAL,GAAS,CAAC,CAAhC,EAAmC,KAAKC,CAAL,GAAS,CAAC,CAA7C,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,mCAAP,UAAoBa,KAApB,EAAiC;AAC7B,SAAKf,CAAL,IAAUe,KAAV;AACA,SAAKd,CAAL,IAAUc,KAAV;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOb,4BAAP,UAAaa,KAAb,EAA0B;AACtB,QAAMP,MAAM,GAAG,IAAIN,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAf;AACA,SAAKc,UAAL,CAAgBD,KAAhB,EAAuBP,MAAvB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMON,iCAAP,UAAkBa,KAAlB,EAAiCP,MAAjC,EAAgD;AAC5CA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASe,KAApB;AACAP,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASc,KAApB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOb,uCAAP,UAAwBa,KAAxB,EAAuCP,MAAvC,EAAsD;AAClDA,UAAM,CAACR,CAAP,IAAY,KAAKA,CAAL,GAASe,KAArB;AACAP,UAAM,CAACP,CAAP,IAAY,KAAKA,CAAL,GAASc,KAArB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOb,6BAAP,UAAcW,WAAd,EAAiD;AAC7C,WAAOA,WAAW,IAAI,KAAKb,CAAL,KAAWa,WAAW,CAACb,CAAtC,IAA2C,KAAKC,CAAL,KAAWY,WAAW,CAACZ,CAAzE;AACH,GAFM;AAIP;;;;;;;;AAMOC,wCAAP,UAAyBW,WAAzB,EAA8DI,OAA9D,EAAuF;AAAzB;AAAAA;AAAyB;;AACnF,WAAOJ,WAAW,IAAIxB,MAAM,CAAC6B,aAAP,CAAqB,KAAKlB,CAA1B,EAA6Ba,WAAW,CAACb,CAAzC,EAA4CiB,OAA5C,CAAf,IAAuE5B,MAAM,CAAC6B,aAAP,CAAqB,KAAKjB,CAA1B,EAA6BY,WAAW,CAACZ,CAAzC,EAA4CgB,OAA5C,CAA9E;AACH,GAFM;AAIP;;;;;;;AAKOf,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAYiB,IAAI,CAACC,KAAL,CAAW,KAAKpB,CAAhB,CAAZ,EAAgCmB,IAAI,CAACC,KAAL,CAAW,KAAKnB,CAAhB,CAAhC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAKF,CAAL,GAASmB,IAAI,CAACC,KAAL,CAAW,KAAKpB,CAAhB,CAArB,EAAyC,KAAKC,CAAL,GAASkB,IAAI,CAACC,KAAL,CAAW,KAAKnB,CAAhB,CAAlD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,kCAAP,UAAmBmB,KAAnB,EAAkCb,MAAlC,EAAiD;AAC7C,QAAMc,GAAG,GAAGH,IAAI,CAACG,GAAL,CAASD,KAAT,CAAZ;AACA,QAAME,GAAG,GAAGJ,IAAI,CAACI,GAAL,CAASF,KAAT,CAAZ;AACAb,UAAM,CAACR,CAAP,GAAWsB,GAAG,GAAG,KAAKtB,CAAX,GAAeuB,GAAG,GAAG,KAAKtB,CAArC;AACAO,UAAM,CAACP,CAAP,GAAWsB,GAAG,GAAG,KAAKvB,CAAX,GAAesB,GAAG,GAAG,KAAKrB,CAArC;AAEA,WAAO,IAAP;AACH,GAPM,CAhXX,CAyXI;;AAEA;;;;;;AAIOC,6BAAP;AACI,WAAOiB,IAAI,CAACK,IAAL,CAAU,KAAKxB,CAAL,GAAS,KAAKA,CAAd,GAAkB,KAAKC,CAAL,GAAS,KAAKA,CAA1C,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,oCAAP;AACI,WAAO,KAAKF,CAAL,GAAS,KAAKA,CAAd,GAAkB,KAAKC,CAAL,GAAS,KAAKA,CAAvC;AACH,GAFM,CAvYX,CA2YI;;AAEA;;;;;;AAIOC,gCAAP;AACIA,WAAO,CAACuB,cAAR,CAAuB,IAAvB,EAA6B,IAA7B;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIOvB,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAKF,CAAjB,EAAoB,KAAKC,CAAzB,CAAP;AACH,GAFM,CA1ZX,CA8ZI;;AAEA;;;;;;AAIcC,iBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAFa;AAId;;;;;;AAIcA,gBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAFa;AAId;;;;;;;;AAMcA,sBAAd,UAAwBG,KAAxB,EAAiEqB,MAAjE,EAAmF;AAAlB;AAAAA;AAAkB;;AAC/E,WAAO,IAAIxB,OAAJ,CAAYG,KAAK,CAACqB,MAAD,CAAjB,EAA2BrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhC,CAAP;AACH,GAFa;AAId;;;;;;;;AAMcxB,2BAAd,UAA6BG,KAA7B,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAqG;AACjGA,UAAM,CAACR,CAAP,GAAWK,KAAK,CAACqB,MAAD,CAAhB;AACAlB,UAAM,CAACP,CAAP,GAAWI,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACH,GAHa;AAKd;;;;;;;;;;;AAScxB,uBAAd,UACIyB,MADJ,EAEIC,MAFJ,EAGIC,MAHJ,EAIIC,MAJJ,EAKIC,MALJ,EAKkB;AAEd,QAAMC,OAAO,GAAGD,MAAM,GAAGA,MAAzB;AACA,QAAME,KAAK,GAAGF,MAAM,GAAGC,OAAvB;AAEA,QAAMhC,CAAC,GACH,OACC,MAAM4B,MAAM,CAAC5B,CAAb,GACG,CAAC,CAAC2B,MAAM,CAAC3B,CAAR,GAAY6B,MAAM,CAAC7B,CAApB,IAAyB+B,MAD5B,GAEG,CAAC,MAAMJ,MAAM,CAAC3B,CAAb,GAAiB,MAAM4B,MAAM,CAAC5B,CAA9B,GAAkC,MAAM6B,MAAM,CAAC7B,CAA/C,GAAmD8B,MAAM,CAAC9B,CAA3D,IAAgEgC,OAFnE,GAGG,CAAC,CAACL,MAAM,CAAC3B,CAAR,GAAY,MAAM4B,MAAM,CAAC5B,CAAzB,GAA6B,MAAM6B,MAAM,CAAC7B,CAA1C,GAA8C8B,MAAM,CAAC9B,CAAtD,IAA2DiC,KAJ/D,CADJ;AAOA,QAAMhC,CAAC,GACH,OACC,MAAM2B,MAAM,CAAC3B,CAAb,GACG,CAAC,CAAC0B,MAAM,CAAC1B,CAAR,GAAY4B,MAAM,CAAC5B,CAApB,IAAyB8B,MAD5B,GAEG,CAAC,MAAMJ,MAAM,CAAC1B,CAAb,GAAiB,MAAM2B,MAAM,CAAC3B,CAA9B,GAAkC,MAAM4B,MAAM,CAAC5B,CAA/C,GAAmD6B,MAAM,CAAC7B,CAA3D,IAAgE+B,OAFnE,GAGG,CAAC,CAACL,MAAM,CAAC1B,CAAR,GAAY,MAAM2B,MAAM,CAAC3B,CAAzB,GAA6B,MAAM4B,MAAM,CAAC5B,CAA1C,GAA8C6B,MAAM,CAAC7B,CAAtD,IAA2DgC,KAJ/D,CADJ;AAOA,WAAO,IAAI/B,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAzBa;AA2Bd;;;;;;;;;;;AAScC,kBAAd,UAAoBN,KAApB,EAAmDsC,GAAnD,EAAgFC,GAAhF,EAA2G;AACvG,QAAInC,CAAC,GAAGJ,KAAK,CAACI,CAAd;AACAA,KAAC,GAAGA,CAAC,GAAGmC,GAAG,CAACnC,CAAR,GAAYmC,GAAG,CAACnC,CAAhB,GAAoBA,CAAxB;AACAA,KAAC,GAAGA,CAAC,GAAGkC,GAAG,CAAClC,CAAR,GAAYkC,GAAG,CAAClC,CAAhB,GAAoBA,CAAxB;AAEA,QAAIC,CAAC,GAAGL,KAAK,CAACK,CAAd;AACAA,KAAC,GAAGA,CAAC,GAAGkC,GAAG,CAAClC,CAAR,GAAYkC,GAAG,CAAClC,CAAhB,GAAoBA,CAAxB;AACAA,KAAC,GAAGA,CAAC,GAAGiC,GAAG,CAACjC,CAAR,GAAYiC,GAAG,CAACjC,CAAhB,GAAoBA,CAAxB;AAEA,WAAO,IAAIC,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAVa;AAYd;;;;;;;;;;;AAScC,oBAAd,UACIyB,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIN,MALJ,EAKkB;AAEd,QAAMC,OAAO,GAAGD,MAAM,GAAGA,MAAzB;AACA,QAAME,KAAK,GAAGF,MAAM,GAAGC,OAAvB;AACA,QAAMM,KAAK,GAAG,MAAML,KAAN,GAAc,MAAMD,OAApB,GAA8B,GAA5C;AACA,QAAMO,KAAK,GAAG,CAAC,GAAD,GAAON,KAAP,GAAe,MAAMD,OAAnC;AACA,QAAMQ,KAAK,GAAGP,KAAK,GAAG,MAAMD,OAAd,GAAwBD,MAAtC;AACA,QAAMU,KAAK,GAAGR,KAAK,GAAGD,OAAtB;AAEA,QAAMhC,CAAC,GAAG2B,MAAM,CAAC3B,CAAP,GAAWsC,KAAX,GAAmBV,MAAM,CAAC5B,CAAP,GAAWuC,KAA9B,GAAsCH,QAAQ,CAACpC,CAAT,GAAawC,KAAnD,GAA2DH,QAAQ,CAACrC,CAAT,GAAayC,KAAlF;AACA,QAAMxC,CAAC,GAAG0B,MAAM,CAAC1B,CAAP,GAAWqC,KAAX,GAAmBV,MAAM,CAAC3B,CAAP,GAAWsC,KAA9B,GAAsCH,QAAQ,CAACnC,CAAT,GAAauC,KAAnD,GAA2DH,QAAQ,CAACpC,CAAT,GAAawC,KAAlF;AAEA,WAAO,IAAIvC,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAlBa;AAoBd;;;;;;;;;;;AAScC,iCAAd,UACIyB,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAKgB;AAEZ,QAAMlC,MAAM,GAAGN,OAAO,CAACyC,IAAR,EAAf;AAEA,SAAKC,yBAAL,CAA+BjB,MAA/B,EAAuCS,QAAvC,EAAiDR,MAAjD,EAAyDS,QAAzD,EAAmEK,IAAnE,EAAyElC,MAAzE;AAEA,WAAOA,MAAP;AACH,GAZa;AAcd;;;;;;;;;;;AAScN,sCAAd,UACIyB,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAMIlC,MANJ,EAMmB;AAEf,QAAMqC,EAAE,GAAGH,IAAI,GAAGA,IAAlB;AAEAlC,UAAM,CAACR,CAAP,GAAW,CAAC6C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC3B,CAAzB,GAA6B,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACpC,CAAhE,GAAoE,CAAC,CAAC6C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC5B,CAA9F,GAAkG,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACrC,CAA5I;AACAQ,UAAM,CAACP,CAAP,GAAW,CAAC4C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC1B,CAAzB,GAA6B,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACnC,CAAhE,GAAoE,CAAC,CAAC4C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC3B,CAA9F,GAAkG,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACpC,CAA5I;AACH,GAZa;AAcd;;;;;;;;;AAOcC,iBAAd,UAAmB4C,KAAnB,EAAkDC,GAAlD,EAA+EhB,MAA/E,EAA6F;AACzF,QAAM/B,CAAC,GAAG8C,KAAK,CAAC9C,CAAN,GAAU,CAAC+C,GAAG,CAAC/C,CAAJ,GAAQ8C,KAAK,CAAC9C,CAAf,IAAoB+B,MAAxC;AACA,QAAM9B,CAAC,GAAG6C,KAAK,CAAC7C,CAAN,GAAU,CAAC8C,GAAG,CAAC9C,CAAJ,GAAQ6C,KAAK,CAAC7C,CAAf,IAAoB8B,MAAxC;AACA,WAAO,IAAI7B,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMcC,gBAAd,UAAkB8C,IAAlB,EAAgDC,KAAhD,EAA6E;AACzE,WAAOD,IAAI,CAAChD,CAAL,GAASiD,KAAK,CAACjD,CAAf,GAAmBgD,IAAI,CAAC/C,CAAL,GAASgD,KAAK,CAAChD,CAAzC;AACH,GAFa;AAId;;;;;;;AAKcC,sBAAd,UAAwBgD,MAAxB,EAAsD;AAClD,QAAMC,SAAS,GAAGjD,OAAO,CAACyC,IAAR,EAAlB;AACA,SAAKlB,cAAL,CAAoByB,MAApB,EAA4BC,SAA5B;AACA,WAAOA,SAAP;AACH,GAJa;AAMd;;;;;;;AAKcjD,2BAAd,UAA6BgD,MAA7B,EAA6D1C,MAA7D,EAA4E;AACxE,QAAM4C,GAAG,GAAGF,MAAM,CAACG,MAAP,EAAZ;;AAEA,QAAID,GAAG,KAAK,CAAZ,EAAe;AACX;AACH;;AAED5C,UAAM,CAACR,CAAP,GAAWkD,MAAM,CAAClD,CAAP,GAAWoD,GAAtB;AACA5C,UAAM,CAACP,CAAP,GAAWiD,MAAM,CAACjD,CAAP,GAAWmD,GAAtB;AACH,GATa;AAWd;;;;;;;;AAMclD,qBAAd,UAAuB8C,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMjD,CAAC,GAAGgD,IAAI,CAAChD,CAAL,GAASiD,KAAK,CAACjD,CAAf,GAAmBgD,IAAI,CAAChD,CAAxB,GAA4BiD,KAAK,CAACjD,CAA5C;AACA,QAAMC,CAAC,GAAG+C,IAAI,CAAC/C,CAAL,GAASgD,KAAK,CAAChD,CAAf,GAAmB+C,IAAI,CAAC/C,CAAxB,GAA4BgD,KAAK,CAAChD,CAA5C;AACA,WAAO,IAAIC,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMcC,qBAAd,UAAuB8C,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMjD,CAAC,GAAGgD,IAAI,CAAChD,CAAL,GAASiD,KAAK,CAACjD,CAAf,GAAmBgD,IAAI,CAAChD,CAAxB,GAA4BiD,KAAK,CAACjD,CAA5C;AACA,QAAMC,CAAC,GAAG+C,IAAI,CAAC/C,CAAL,GAASgD,KAAK,CAAChD,CAAf,GAAmB+C,IAAI,CAAC/C,CAAxB,GAA4BgD,KAAK,CAAChD,CAA5C;AACA,WAAO,IAAIC,OAAJ,CAAYF,CAAZ,EAAeC,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMcC,sBAAd,UAAwBgD,MAAxB,EAAwDI,cAAxD,EAA6F;AACzF,QAAMC,CAAC,GAAGrD,OAAO,CAACyC,IAAR,EAAV;AACAzC,WAAO,CAACsD,cAAR,CAAuBN,MAAvB,EAA+BI,cAA/B,EAA+CC,CAA/C;AACA,WAAOA,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMcrD,2BAAd,UAA6BgD,MAA7B,EAA6DI,cAA7D,EAAoG9C,MAApG,EAAmH;AAC/G,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACA,QAAMzD,CAAC,GAAGkD,MAAM,CAAClD,CAAP,GAAWyD,CAAC,CAAC,CAAD,CAAZ,GAAkBP,MAAM,CAACjD,CAAP,GAAWwD,CAAC,CAAC,CAAD,CAA9B,GAAoCA,CAAC,CAAC,EAAD,CAA/C;AACA,QAAMxD,CAAC,GAAGiD,MAAM,CAAClD,CAAP,GAAWyD,CAAC,CAAC,CAAD,CAAZ,GAAkBP,MAAM,CAACjD,CAAP,GAAWwD,CAAC,CAAC,CAAD,CAA9B,GAAoCA,CAAC,CAAC,EAAD,CAA/C;AACAjD,UAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,UAAM,CAACP,CAAP,GAAWA,CAAX;AACH,GANa;AAQd;;;;;;;;;;AAQcC,4BAAd,UAA8BwD,CAA9B,EAAyDC,EAAzD,EAAqFC,EAArF,EAAiHC,EAAjH,EAA2I;AACvI,QAAMC,CAAC,GAAI,IAAI,CAAL,IAAW,CAACF,EAAE,CAAC3D,CAAJ,GAAQ4D,EAAE,CAAC7D,CAAX,GAAe2D,EAAE,CAAC1D,CAAH,IAAQ,CAAC2D,EAAE,CAAC5D,CAAJ,GAAQ6D,EAAE,CAAC7D,CAAnB,CAAf,GAAuC2D,EAAE,CAAC3D,CAAH,IAAQ4D,EAAE,CAAC3D,CAAH,GAAO4D,EAAE,CAAC5D,CAAlB,CAAvC,GAA8D2D,EAAE,CAAC5D,CAAH,GAAO6D,EAAE,CAAC5D,CAAnF,CAAV;AACA,QAAM8D,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAA1B;AACA,QAAME,CAAC,GAAG,CAACL,EAAE,CAAC1D,CAAH,GAAO4D,EAAE,CAAC7D,CAAV,GAAc2D,EAAE,CAAC3D,CAAH,GAAO6D,EAAE,CAAC5D,CAAxB,GAA4B,CAAC4D,EAAE,CAAC5D,CAAH,GAAO0D,EAAE,CAAC1D,CAAX,IAAgByD,CAAC,CAAC1D,CAA9C,GAAkD,CAAC2D,EAAE,CAAC3D,CAAH,GAAO6D,EAAE,CAAC7D,CAAX,IAAgB0D,CAAC,CAACzD,CAArE,IAA0E8D,IAApF;AACA,QAAME,CAAC,GAAG,CAACN,EAAE,CAAC3D,CAAH,GAAO4D,EAAE,CAAC3D,CAAV,GAAc0D,EAAE,CAAC1D,CAAH,GAAO2D,EAAE,CAAC5D,CAAxB,GAA4B,CAAC2D,EAAE,CAAC1D,CAAH,GAAO2D,EAAE,CAAC3D,CAAX,IAAgByD,CAAC,CAAC1D,CAA9C,GAAkD,CAAC4D,EAAE,CAAC5D,CAAH,GAAO2D,EAAE,CAAC3D,CAAX,IAAgB0D,CAAC,CAACzD,CAArE,IAA0E8D,IAApF;AAEA,WAAOC,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBD,CAAC,GAAGC,CAAJ,GAAQ,IAAIH,CAAJ,GAAQC,IAAzC;AACH,GAPa;AASd;;;;;;;;AAMc7D,qBAAd,UAAuByB,MAAvB,EAAuDC,MAAvD,EAAqF;AACjF,WAAOT,IAAI,CAACK,IAAL,CAAUtB,OAAO,CAACgE,eAAR,CAAwBvC,MAAxB,EAAgCC,MAAhC,CAAV,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc1B,4BAAd,UAA8ByB,MAA9B,EAA8DC,MAA9D,EAA4F;AACxF,QAAM5B,CAAC,GAAG2B,MAAM,CAAC3B,CAAP,GAAW4B,MAAM,CAAC5B,CAA5B;AACA,QAAMC,CAAC,GAAG0B,MAAM,CAAC1B,CAAP,GAAW2B,MAAM,CAAC3B,CAA5B;AACA,WAAOD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAnB;AACH,GAJa;AAMd;;;;;;;;AAMcC,mBAAd,UAAqByB,MAArB,EAAqDC,MAArD,EAAmF;AAC/E,WAAO1B,OAAO,CAACiE,WAAR,CAAoBxC,MAApB,EAA4BC,MAA5B,EAAoC1B,OAAO,CAACyC,IAAR,EAApC,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOczC,wBAAd,UAA0ByB,MAA1B,EAA0DC,MAA1D,EAA0FwC,GAA1F,EAAqH;AACjH,WAAOA,GAAG,CAACxD,cAAJ,CAAmB,CAACe,MAAM,CAAC3B,CAAP,GAAW4B,MAAM,CAAC5B,CAAnB,IAAwB,CAA3C,EAA8C,CAAC2B,MAAM,CAAC1B,CAAP,GAAW2B,MAAM,CAAC3B,CAAnB,IAAwB,CAAtE,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOcC,uCAAd,UAAyCwD,CAAzC,EAAoEW,IAApE,EAAkGC,IAAlG,EAA8H;AAC1H,QAAMC,EAAE,GAAGrE,OAAO,CAACgE,eAAR,CAAwBG,IAAxB,EAA8BC,IAA9B,CAAX;;AACA,QAAIC,EAAE,KAAK,GAAX,EAAgB;AACZ,aAAOrE,OAAO,CAACsE,QAAR,CAAiBd,CAAjB,EAAoBW,IAApB,CAAP;AACH;;AACD,QAAMI,CAAC,GAAGH,IAAI,CAACI,QAAL,CAAcL,IAAd,CAAV;AACA,QAAMJ,CAAC,GAAG9C,IAAI,CAACgB,GAAL,CAAS,CAAT,EAAYhB,IAAI,CAACe,GAAL,CAAS,CAAT,EAAYhC,OAAO,CAACyE,GAAR,CAAYjB,CAAC,CAACgB,QAAF,CAAWL,IAAX,CAAZ,EAA8BI,CAA9B,IAAmCF,EAA/C,CAAZ,CAAV;AACA,QAAMK,IAAI,GAAGP,IAAI,CAACQ,GAAL,CAASJ,CAAC,CAACK,gBAAF,CAAmBb,CAAnB,EAAsBA,CAAtB,CAAT,CAAb;AACA,WAAO/D,OAAO,CAACsE,QAAR,CAAiBd,CAAjB,EAAoBkB,IAApB,CAAP;AACH,GATa;;AAUlB;AAAC,CA1vBD;;;AA4vBA;;;;;;;AAMA;AAAA;AAAA;AAkDI;;;;;;AAMA,mBAAY5E,CAAZ,EAA2BC,CAA3B,EAA0C8E,CAA1C,EAAuD;AAA3C;AAAA/E;AAAa;;AAAE;AAAAC;AAAa;;AAAE;AAAA8E;AAAa;AAvCvD;;;AACO,oBAAW,IAAX;AAuCH,SAAKC,EAAL,GAAUhF,CAAV;AACA,SAAKiF,EAAL,GAAUhF,CAAV;AACA,SAAKiF,EAAL,GAAUH,CAAV;AACH;;AAvCDI,wBAAWC,iBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKJ,EAAZ;AACH,KAFW;SAIZ,aAAapF,KAAb,EAA0B;AACtB,WAAKoF,EAAL,GAAUpF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUAF,wBAAWC,iBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKH,EAAZ;AACH,KAFW;SAIZ,aAAarF,KAAb,EAA0B;AACtB,WAAKqF,EAAL,GAAUrF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUAF,wBAAWC,iBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKF,EAAZ;AACH,KAFW;SAIZ,aAAatF,KAAb,EAA0B;AACtB,WAAKsF,EAAL,GAAUtF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAqBA;;;;;AAIOD,+BAAP;AACI,WAAO,cAAO,KAAKJ,EAAZ,EAAc,MAAd,EAAc7E,MAAd,CAAqB,KAAK8E,EAA1B,EAA4B,MAA5B,EAA4B9E,MAA5B,CAAmC,KAAK+E,EAAxC,EAA0C,GAA1C,CAAP;AACH,GAFM;AAIP;;;;;;AAIOE,mCAAP;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIOA,kCAAP;AACI,QAAMpF,CAAC,GAAGL,aAAa,CAAC,KAAKqF,EAAN,CAAvB;;AACA,QAAM/E,CAAC,GAAGN,aAAa,CAAC,KAAKsF,EAAN,CAAvB;;AACA,QAAMF,CAAC,GAAGpF,aAAa,CAAC,KAAKuF,EAAN,CAAvB;;AAEA,QAAI9E,IAAI,GAAGJ,CAAX;AACAI,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAeH,CAAtB;AACAG,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAe2E,CAAtB;AACA,WAAO3E,IAAP;AACH,GATM,CAlFX,CA6FI;;AAEA;;;;;;AAIOgF,8BAAP;AACI,QAAM5E,MAAM,GAAa,EAAzB;AACA,SAAKE,OAAL,CAAaF,MAAb,EAAqB,CAArB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO4E,8BAAP,UAAe/E,KAAf,EAAkCC,KAAlC,EAAmD;AAAjB;AAAAA;AAAiB;;AAC/CD,SAAK,CAACC,KAAD,CAAL,GAAe,KAAK0E,EAApB;AACA3E,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK2E,EAAxB;AACA5E,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK4E,EAAxB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;AAMOE,gCAAP,UAAiB/E,KAAjB,EAAoCC,KAApC,EAAqD;AAAjB;AAAAA;AAAiB;;AACjD8E,WAAO,CAAC7E,cAAR,CAAuBF,KAAvB,EAA8BC,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIO8E,mCAAP;AACI,WAAOE,UAAU,CAACC,oBAAX,CAAgC,KAAKN,EAArC,EAAyC,KAAKD,EAA9C,EAAkD,KAAKE,EAAvD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,iCAAP,UAAkBvE,WAAlB,EAAqD;AACjD,WAAO,KAAK2E,oBAAL,CAA0B3E,WAAW,CAACmE,EAAtC,EAA0CnE,WAAW,CAACoE,EAAtD,EAA0DpE,WAAW,CAACqE,EAAtE,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOOE,2CAAP,UAA4BpF,CAA5B,EAAuCC,CAAvC,EAAkD8E,CAAlD,EAA2D;AACvD,SAAK/E,CAAL,IAAUA,CAAV;AACA,SAAKC,CAAL,IAAUA,CAAV;AACA,SAAK8E,CAAL,IAAUA,CAAV;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOK,0BAAP,UAAWvE,WAAX,EAA8C;AAC1C,WAAO,IAAIuE,OAAJ,CAAY,KAAKJ,EAAL,GAAUnE,WAAW,CAACmE,EAAlC,EAAsC,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAA5D,EAAgE,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOE,+BAAP,UAAgBvE,WAAhB,EAAqDL,MAArD,EAAoE;AAChE,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAUnE,WAAW,CAACmE,EAA5C,EAAgD,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAAtE,EAA0E,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,sCAAP,UAAuBvE,WAAvB,EAA0D;AACtD,SAAKb,CAAL,IAAUa,WAAW,CAACmE,EAAtB;AACA,SAAK/E,CAAL,IAAUY,WAAW,CAACoE,EAAtB;AACA,SAAKF,CAAL,IAAUlE,WAAW,CAACqE,EAAtB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOE,+BAAP,UAAgBvE,WAAhB,EAAmD;AAC/C,WAAO,IAAIuE,OAAJ,CAAY,KAAKJ,EAAL,GAAUnE,WAAW,CAACmE,EAAlC,EAAsC,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAA5D,EAAgE,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOE,oCAAP,UAAqBvE,WAArB,EAA0DL,MAA1D,EAAyE;AACrE,WAAO,KAAKiF,uBAAL,CAA6B5E,WAAW,CAACmE,EAAzC,EAA6CnE,WAAW,CAACoE,EAAzD,EAA6DpE,WAAW,CAACqE,EAAzE,EAA6E1E,MAA7E,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO4E,yCAAP,UAA0BpF,CAA1B,EAAqCC,CAArC,EAAgD8E,CAAhD,EAAyD;AACrD,WAAO,IAAIK,OAAJ,CAAY,KAAKJ,EAAL,GAAUhF,CAAtB,EAAyB,KAAKiF,EAAL,GAAUhF,CAAnC,EAAsC,KAAKiF,EAAL,GAAUH,CAAhD,CAAP;AACH,GAFM;AAIP;;;;;;;;;;AAQOK,8CAAP,UAA+BpF,CAA/B,EAA0CC,CAA1C,EAAqD8E,CAArD,EAAgEvE,MAAhE,EAA+E;AAC3E,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAUhF,CAAhC,EAAmC,KAAKiF,EAAL,GAAUhF,CAA7C,EAAgD,KAAKiF,EAAL,GAAUH,CAA1D,CAAP;AACH,GAFM;AAIP;;;;;;AAIOK,6BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAC,KAAKJ,EAAlB,EAAsB,CAAC,KAAKC,EAA5B,EAAgC,CAAC,KAAKC,EAAtC,CAAP;AACH,GAFM;AAIP;;;;;;AAIOE,oCAAP;AACI,SAAKpF,CAAL,IAAU,CAAC,CAAX;AACA,SAAKC,CAAL,IAAU,CAAC,CAAX;AACA,SAAK8E,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOK,kCAAP,UAAmB5E,MAAnB,EAAkC;AAC9B,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAU,CAAC,CAAjC,EAAoC,KAAKC,EAAL,GAAU,CAAC,CAA/C,EAAkD,KAAKC,EAAL,GAAU,CAAC,CAA7D,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,mCAAP,UAAoBrE,KAApB,EAAiC;AAC7B,SAAKf,CAAL,IAAUe,KAAV;AACA,SAAKd,CAAL,IAAUc,KAAV;AACA,SAAKgE,CAAL,IAAUhE,KAAV;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOqE,4BAAP,UAAarE,KAAb,EAA0B;AACtB,WAAO,IAAIqE,OAAJ,CAAY,KAAKJ,EAAL,GAAUjE,KAAtB,EAA6B,KAAKkE,EAAL,GAAUlE,KAAvC,EAA8C,KAAKmE,EAAL,GAAUnE,KAAxD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOqE,iCAAP,UAAkBrE,KAAlB,EAAiCP,MAAjC,EAAgD;AAC5C,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAUjE,KAAhC,EAAuC,KAAKkE,EAAL,GAAUlE,KAAjD,EAAwD,KAAKmE,EAAL,GAAUnE,KAAlE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOqE,uCAAP,UAAwBrE,KAAxB,EAAuCP,MAAvC,EAAsD;AAClD,WAAOA,MAAM,CAACgF,oBAAP,CAA4B,KAAKR,EAAL,GAAUjE,KAAtC,EAA6C,KAAKkE,EAAL,GAAUlE,KAAvD,EAA8D,KAAKmE,EAAL,GAAUnE,KAAxE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOqE,qCAAP,UAAsBM,KAAtB,EAAoCC,MAApC,EAAmD;AAC/C,QAAMnF,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AAEA,SAAKiD,mBAAL,CAAyBF,KAAzB,EAAgCC,MAAhC,EAAwCnF,MAAxC;AAEA,WAAOA,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO4E,0CAAP,UAA2BM,KAA3B,EAAyCC,MAAzC,EAA0DnF,MAA1D,EAAyE;AACrE,QAAMqF,CAAC,GAAGH,KAAK,CAACI,MAAhB;AACA,QAAMC,CAAC,GAAGL,KAAK,CAACK,CAAhB;AAEA,QAAMC,CAAC,GAAGC,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAV,CAJqE,CAMrE;;AACA,SAAKc,aAAL,CAAmBP,MAAnB,EAA2BK,CAA3B;AAEAA,KAAC,CAACG,SAAF;AAEA,QAAMC,KAAK,GAAGhB,OAAO,CAACT,GAAR,CAAYqB,CAAZ,EAAeH,CAAf,CAAd;AACA,QAAM5B,CAAC,GAAG,EAAEmB,OAAO,CAACT,GAAR,CAAYgB,MAAZ,EAAoBE,CAApB,IAAyBE,CAA3B,IAAgCK,KAA1C,CAZqE,CAcrE;;AACA,QAAMC,OAAO,GAAGL,CAAC,CAACM,YAAF,CAAerC,CAAf,CAAhB;AACA0B,UAAM,CAACY,QAAP,CAAgBF,OAAhB,EAAyB7F,MAAzB;AACH,GAjBM;AAmBP;;;;;;;AAKO4E,6BAAP,UAAcvE,WAAd,EAAiD;AAC7C,WAAOA,WAAW,IAAI,KAAKmE,EAAL,KAAYnE,WAAW,CAACmE,EAAvC,IAA6C,KAAKC,EAAL,KAAYpE,WAAW,CAACoE,EAArE,IAA2E,KAAKC,EAAL,KAAYrE,WAAW,CAACqE,EAA1G;AACH,GAFM;AAIP;;;;;;;;AAMOE,wCAAP,UAAyBvE,WAAzB,EAA8DI,OAA9D,EAAuF;AAAzB;AAAAA;AAAyB;;AACnF,WACIJ,WAAW,IACXxB,MAAM,CAAC6B,aAAP,CAAqB,KAAK8D,EAA1B,EAA8BnE,WAAW,CAACmE,EAA1C,EAA8C/D,OAA9C,CADA,IAEA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAK+D,EAA1B,EAA8BpE,WAAW,CAACoE,EAA1C,EAA8ChE,OAA9C,CAFA,IAGA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAKgE,EAA1B,EAA8BrE,WAAW,CAACqE,EAA1C,EAA8CjE,OAA9C,CAJJ;AAMH,GAPM;AASP;;;;;;;;;AAOOmE,qCAAP,UAAsBpF,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAqD;AACjD,WAAO,KAAKC,EAAL,KAAYhF,CAAZ,IAAiB,KAAKiF,EAAL,KAAYhF,CAA7B,IAAkC,KAAKiF,EAAL,KAAYH,CAArD;AACH,GAFM;AAIP;;;;;;;AAKOK,sCAAP,UAAuBvE,WAAvB,EAA0D;AACtD,SAAKb,CAAL,IAAUa,WAAW,CAACmE,EAAtB;AACA,SAAK/E,CAAL,IAAUY,WAAW,CAACoE,EAAtB;AACA,SAAKF,CAAL,IAAUlE,WAAW,CAACqE,EAAtB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOE,+BAAP,UAAgBvE,WAAhB,EAAmD;AAC/C,WAAO,KAAKiE,gBAAL,CAAsBjE,WAAW,CAACmE,EAAlC,EAAsCnE,WAAW,CAACoE,EAAlD,EAAsDpE,WAAW,CAACqE,EAAlE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOE,oCAAP,UAAqBvE,WAArB,EAA0DL,MAA1D,EAAyE;AACrE,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAUnE,WAAW,CAACmE,EAA5C,EAAgD,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAAtE,EAA0E,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOOE,uCAAP,UAAwBpF,CAAxB,EAAmCC,CAAnC,EAA8C8E,CAA9C,EAAuD;AACnD,WAAO,IAAIK,OAAJ,CAAY,KAAKJ,EAAL,GAAUhF,CAAtB,EAAyB,KAAKiF,EAAL,GAAUhF,CAAnC,EAAsC,KAAKiF,EAAL,GAAUH,CAAhD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOK,6BAAP,UAAcvE,WAAd,EAAiD;AAC7C,WAAO,IAAIuE,OAAJ,CAAY,KAAKJ,EAAL,GAAUnE,WAAW,CAACmE,EAAlC,EAAsC,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAA5D,EAAgE,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOE,kCAAP,UAAmBvE,WAAnB,EAAwDL,MAAxD,EAAuE;AACnE,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKoE,EAAL,GAAUnE,WAAW,CAACmE,EAA5C,EAAgD,KAAKC,EAAL,GAAUpE,WAAW,CAACoE,EAAtE,EAA0E,KAAKC,EAAL,GAAUrE,WAAW,CAACqE,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,oCAAP,UAAqBvE,WAArB,EAAyC;AACrC,WAAO,KAAKC,WAAL,CAAiBD,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOuE,sCAAP,UAAuBoB,KAAvB,EAAoD;AAChD,WAAO,KAAKC,yBAAL,CAA+BD,KAAK,CAACxB,EAArC,EAAyCwB,KAAK,CAACvB,EAA/C,EAAmDuB,KAAK,CAACtB,EAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,sCAAP,UAAuBoB,KAAvB,EAAoD;AAChD,WAAO,KAAKE,yBAAL,CAA+BF,KAAK,CAACxB,EAArC,EAAyCwB,KAAK,CAACvB,EAA/C,EAAmDuB,KAAK,CAACtB,EAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOOE,gDAAP,UAAiCpF,CAAjC,EAA4CC,CAA5C,EAAuD8E,CAAvD,EAAgE;AAC5D,QAAI/E,CAAC,GAAG,KAAKgF,EAAb,EAAiB;AACb,WAAKhF,CAAL,GAASA,CAAT;AACH;;AACD,QAAIC,CAAC,GAAG,KAAKgF,EAAb,EAAiB;AACb,WAAKhF,CAAL,GAASA,CAAT;AACH;;AACD,QAAI8E,CAAC,GAAG,KAAKG,EAAb,EAAiB;AACb,WAAKH,CAAL,GAASA,CAAT;AACH;;AACD,WAAO,IAAP;AACH,GAXM;AAaP;;;;;;;;;AAOOK,gDAAP,UAAiCpF,CAAjC,EAA4CC,CAA5C,EAAuD8E,CAAvD,EAAgE;AAC5D,QAAI/E,CAAC,GAAG,KAAKgF,EAAb,EAAiB;AACb,WAAKhF,CAAL,GAASA,CAAT;AACH;;AACD,QAAIC,CAAC,GAAG,KAAKgF,EAAb,EAAiB;AACb,WAAKhF,CAAL,GAASA,CAAT;AACH;;AACD,QAAI8E,CAAC,GAAG,KAAKG,EAAb,EAAiB;AACb,WAAKH,CAAL,GAASA,CAAT;AACH;;AACD,WAAO,IAAP;AACH,GAXM;AAaP;;;;;;;;AAMOK,gDAAP,UAAiCnE,OAAjC,EAAgD;AAC5C,QAAM0F,IAAI,GAAGxF,IAAI,CAACyF,GAAL,CAAS,KAAK5B,EAAd,CAAb;AACA,QAAM6B,IAAI,GAAG1F,IAAI,CAACyF,GAAL,CAAS,KAAK3B,EAAd,CAAb;;AACA,QAAI,CAAC5F,MAAM,CAAC6B,aAAP,CAAqByF,IAArB,EAA2BE,IAA3B,EAAiC5F,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,QAAM6F,IAAI,GAAG3F,IAAI,CAACyF,GAAL,CAAS,KAAK1B,EAAd,CAAb;;AACA,QAAI,CAAC7F,MAAM,CAAC6B,aAAP,CAAqByF,IAArB,EAA2BG,IAA3B,EAAiC7F,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,QAAI,CAAC5B,MAAM,CAAC6B,aAAP,CAAqB2F,IAArB,EAA2BC,IAA3B,EAAiC7F,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH,GAjBM;;AAsBPkE,wBAAWC,iBAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA;AACI,UAAMuB,IAAI,GAAGxF,IAAI,CAACyF,GAAL,CAAS,KAAK5B,EAAd,CAAb;AACA,UAAM6B,IAAI,GAAG1F,IAAI,CAACyF,GAAL,CAAS,KAAK3B,EAAd,CAAb;;AACA,UAAI0B,IAAI,KAAKE,IAAb,EAAmB;AACf,eAAO,IAAP;AACH;;AAED,UAAMC,IAAI,GAAG3F,IAAI,CAACyF,GAAL,CAAS,KAAK1B,EAAd,CAAb;;AACA,UAAIyB,IAAI,KAAKG,IAAb,EAAmB;AACf,eAAO,IAAP;AACH;;AAED,aAAO,KAAP;AACH,KAbsB;qBAAA;;AAAA,GAAvB;AAeA;;;;;AAIO1B,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAYjE,IAAI,CAACC,KAAL,CAAW,KAAK4D,EAAhB,CAAZ,EAAiC7D,IAAI,CAACC,KAAL,CAAW,KAAK6D,EAAhB,CAAjC,EAAsD9D,IAAI,CAACC,KAAL,CAAW,KAAK8D,EAAhB,CAAtD,CAAP;AACH,GAFM;AAIP;;;;;;AAIOE,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAKJ,EAAL,GAAU7D,IAAI,CAACC,KAAL,CAAW,KAAK4D,EAAhB,CAAtB,EAA2C,KAAKC,EAAL,GAAU9D,IAAI,CAACC,KAAL,CAAW,KAAK6D,EAAhB,CAArD,EAA0E,KAAKC,EAAL,GAAU/D,IAAI,CAACC,KAAL,CAAW,KAAK8D,EAAhB,CAApF,CAAP;AACH,GAFM,CA/iBX,CAmjBI;;AACA;;;;;;AAIOE,6BAAP;AACI,WAAOjE,IAAI,CAACK,IAAL,CAAU,KAAKwD,EAAL,GAAU,KAAKA,EAAf,GAAoB,KAAKC,EAAL,GAAU,KAAKA,EAAnC,GAAwC,KAAKC,EAAL,GAAU,KAAKA,EAAjE,CAAP;AACH,GAFM;AAIP;;;;;;AAIOE,oCAAP;AACI,WAAO,KAAKJ,EAAL,GAAU,KAAKA,EAAf,GAAoB,KAAKC,EAAL,GAAU,KAAKA,EAAnC,GAAwC,KAAKC,EAAL,GAAU,KAAKA,EAA9D;AACH,GAFM;AAIP;;;;;;;AAKOE,gCAAP;AACI,WAAO,KAAK2B,mBAAL,CAAyB,KAAK1D,MAAL,EAAzB,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO+B,qCAAP,UAAsB4B,KAAtB,EAAmC;AAAnC;;AACIA,SAAK,GAAGA,KAAK,CAACC,WAAN,EAAR;;AACA,QAAID,KAAK,KAAK,KAAd,EAAqB;AACjB,aAAO,IAAP;AACH;;AACDf,WAAO,CAACb,OAAR,CAAgB,CAAhB,EAAmB8B,QAAnB,CAA4B,IAA5B;AACA,KAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBC,OAAhB,CAAwB,UAACC,GAAD,EAAMC,CAAN,EAAO;AACrBC,WAAK,CAACF,GAAD,CAAL,GAAmBnB,OAAO,CAACb,OAAR,CAAgB,CAAhB,EAAoB4B,KAAK,CAACK,CAAD,CAAzB,CAAnB;AACT,KAFD;AAGA,WAAO,IAAP;AACH,GAVM;AAYP;;;;;;;;AAMOjC,8CAAP,UAA+BmC,UAA/B,EAAuD/G,MAAvD,EAAsE;AAClE+G,cAAU,CAACC,gBAAX,CAA4BvB,OAAO,CAACwB,MAAR,CAAe,CAAf,CAA5B;AACArC,WAAO,CAACsC,yBAAR,CAAkC,IAAlC,EAAwCzB,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAxC,EAA2DjH,MAA3D;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;;AAOO4E,yDAAP,UAA0CmC,UAA1C,EAAkEI,KAAlE,EAAkFnH,MAAlF,EAAiG;AAC7F,SAAK0F,aAAL,CAAmByB,KAAnB,EAA0B1B,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAA1B;AACAa,WAAO,CAACb,OAAR,CAAgB,CAAhB,EAAmBwC,uBAAnB,CAA2CL,UAA3C,EAAuDtB,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAvD;AACAuC,SAAK,CAACpB,QAAN,CAAeN,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAf,EAAmC5E,MAAnC;AACA,WAAOA,MAAP;AACH,GALM;AAOP;;;;;;;;AAMO4E,4BAAP,UAAaoB,KAAb,EAA2B;AACvB,WAAOpB,OAAO,CAACyC,KAAR,CAAc,IAAd,EAAoBrB,KAApB,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOpB,0CAAP,UAA2BhC,GAA3B,EAAsC;AAClC,QAAIA,GAAG,KAAK,CAAR,IAAaA,GAAG,KAAK,GAAzB,EAA8B;AAC1B,aAAO,IAAP;AACH;;AAED,WAAO,KAAKkD,YAAL,CAAkB,MAAMlD,GAAxB,CAAP;AACH,GANM;AAQP;;;;;;AAIOgC,qCAAP;AACI,QAAM0C,UAAU,GAAG,IAAI1C,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAnB;AACA,SAAK2C,cAAL,CAAoBD,UAApB;AACA,WAAOA,UAAP;AACH,GAJM;AAMP;;;;;;;AAKO1C,qCAAP,UAAsB4C,SAAtB,EAAwC;AACpC,QAAM5E,GAAG,GAAG,KAAKC,MAAL,EAAZ;;AACA,QAAID,GAAG,KAAK,CAAR,IAAaA,GAAG,KAAK,GAAzB,EAA8B;AAC1B,aAAO4E,SAAS,CAACpH,cAAV,CAAyB,KAAKoE,EAA9B,EAAkC,KAAKC,EAAvC,EAA2C,KAAKC,EAAhD,CAAP;AACH;;AAED,WAAO,KAAKlE,UAAL,CAAgB,MAAMoC,GAAtB,EAA2B4E,SAA3B,CAAP;AACH,GAPM;AASP;;;;;;AAIO5C,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAKJ,EAAjB,EAAqB,KAAKC,EAA1B,EAA8B,KAAKC,EAAnC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOE,+BAAP,UAAgBzE,MAAhB,EAA8C;AAC1C,WAAO,KAAKC,cAAL,CAAoBD,MAAM,CAACqE,EAA3B,EAA+BrE,MAAM,CAACsE,EAAtC,EAA0CtE,MAAM,CAACuE,EAAjD,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOOE,qCAAP,UAAsBpF,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAqD;AACjD,SAAK/E,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAK8E,CAAL,GAASA,CAAT;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;;AAOOK,0BAAP,UAAWpF,CAAX,EAAsBC,CAAtB,EAAiC8E,CAAjC,EAA0C;AACtC,WAAO,KAAKnE,cAAL,CAAoBZ,CAApB,EAAuBC,CAAvB,EAA0B8E,CAA1B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOK,6BAAP,UAAcX,CAAd,EAAuB;AACnB,SAAKzE,CAAL,GAAS,KAAKC,CAAL,GAAS,KAAK8E,CAAL,GAASN,CAA3B;AACA,WAAO,IAAP;AACH,GAHM,CAvtBX,CA4tBI;;AAEA;;;;;;;;;;AAQcW,0BAAd,UAA4B6C,OAA5B,EAA6DC,OAA7D,EAA8FC,IAA9F,EAA4HC,IAA5H,EAAwI;AACpI,QAAMC,EAAE,GAAGjD,OAAO,CAACT,GAAR,CAAYsD,OAAZ,EAAqBE,IAArB,IAA6BC,IAAxC;AACA,QAAME,EAAE,GAAGlD,OAAO,CAACT,GAAR,CAAYuD,OAAZ,EAAqBC,IAArB,IAA6BC,IAAxC;AAEA,QAAMpE,CAAC,GAAGqE,EAAE,IAAIA,EAAE,GAAGC,EAAT,CAAZ;AAEA,WAAOtE,CAAP;AACH,GAPa;AASd;;;;;;;;;AAOcoB,mCAAd,UAAqC6C,OAArC,EAAsEC,OAAtE,EAAuGpC,MAAvG,EAAqI;AACjI,QAAMyC,EAAE,GAAYN,OAAO,CAACF,cAAR,CAAuB9B,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAvB,CAApB;AACA,QAAMoD,EAAE,GAAYN,OAAO,CAACH,cAAR,CAAuB9B,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAvB,CAApB;AACA,QAAMqD,GAAG,GAAWrD,OAAO,CAACT,GAAR,CAAY4D,EAAZ,EAAgBC,EAAhB,CAApB;AACA,QAAMnH,KAAK,GAAGF,IAAI,CAACuH,IAAL,CAAUD,GAAV,CAAd;AACA,QAAM5C,CAAC,GAAGI,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAV;AACAA,WAAO,CAACuD,UAAR,CAAmBJ,EAAnB,EAAuBC,EAAvB,EAA2B3C,CAA3B;;AACA,QAAIT,OAAO,CAACT,GAAR,CAAYkB,CAAZ,EAAeC,MAAf,IAAyB,CAA7B,EAAgC;AAC5B,aAAO8C,KAAK,CAACvH,KAAD,CAAL,GAAe,CAAf,GAAmBA,KAA1B;AACH;;AACD,WAAOuH,KAAK,CAACvH,KAAD,CAAL,GAAe,CAACF,IAAI,CAAC0H,EAArB,GAA0B,CAAC1H,IAAI,CAACuH,IAAL,CAAUD,GAAV,CAAlC;AACH,GAXa;AAad;;;;;;;;;AAOcrD,0CAAd,UAA4C6C,OAA5C,EAA8DC,OAA9D,EAAgFpC,MAAhF,EAA+F;AAC3FG,WAAO,CAACb,OAAR,CAAgB,CAAhB,EAAmB8B,QAAnB,CAA4Be,OAA5B;AACA,QAAMM,EAAE,GAAGtC,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAX;AACAa,WAAO,CAACb,OAAR,CAAgB,CAAhB,EAAmB8B,QAAnB,CAA4BgB,OAA5B;AACA,QAAMM,EAAE,GAAGvC,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAX;AACAa,WAAO,CAACb,OAAR,CAAgB,CAAhB,EAAmB8B,QAAnB,CAA4BpB,MAA5B;AACA,QAAMgD,OAAO,GAAG7C,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAhB;AACA,QAAMnC,KAAK,GAAGgD,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM2D,OAAO,GAAG9C,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAhB;AAEAmD,MAAE,CAACpC,SAAH;AACAqC,MAAE,CAACrC,SAAH;AACA2C,WAAO,CAAC3C,SAAR;AAEAf,WAAO,CAACuD,UAAR,CAAmBG,OAAnB,EAA4BP,EAA5B,EAAgCtF,KAAhC;AACAmC,WAAO,CAACuD,UAAR,CAAmB1F,KAAnB,EAA0B6F,OAA1B,EAAmCC,OAAnC;AAEA,QAAM1H,KAAK,GAAGF,IAAI,CAAC6H,KAAL,CAAW5D,OAAO,CAACT,GAAR,CAAY6D,EAAZ,EAAgBvF,KAAhB,CAAX,EAAmCmC,OAAO,CAACT,GAAR,CAAY6D,EAAZ,EAAgBO,OAAhB,CAAnC,CAAd;AAEA,WAAO1J,MAAM,CAAC4J,gBAAP,CAAwB5H,KAAxB,CAAP;AACH,GApBa;AAsBd;;;;;;;;;AAOc+D,uBAAd,UAAyB6C,OAAzB,EAA2CC,OAA3C,EAA6DgB,KAA7D,EAA4E1I,MAA5E,EAA2F;AACvF0I,SAAK,GAAG7J,MAAM,CAAC8J,KAAP,CAAaD,KAAb,EAAoB,CAApB,EAAuB,CAAvB,CAAR;AACA,QAAME,UAAU,GAAGnD,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAnB;AACA,QAAMiE,UAAU,GAAGpD,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAnB;AAEAgE,cAAU,CAAClC,QAAX,CAAoBe,OAApB;AACA,QAAMqB,aAAa,GAAGF,UAAU,CAAC/F,MAAX,EAAtB;AACA+F,cAAU,CAACrC,mBAAX,CAA+BuC,aAA/B;AAEAD,cAAU,CAACnC,QAAX,CAAoBgB,OAApB;AACA,QAAMqB,aAAa,GAAGF,UAAU,CAAChG,MAAX,EAAtB;AACAgG,cAAU,CAACtC,mBAAX,CAA+BwC,aAA/B;AAEA,QAAMd,GAAG,GAAGrD,OAAO,CAACT,GAAR,CAAYyE,UAAZ,EAAwBC,UAAxB,CAAZ;AAEA,QAAIG,MAAJ;AACA,QAAIC,MAAJ;;AAEA,QAAIhB,GAAG,GAAG,IAAInJ,OAAd,EAAuB;AACnB,UAAMoK,KAAK,GAAGvI,IAAI,CAACuH,IAAL,CAAUD,GAAV,CAAd;AACA,UAAMkB,MAAM,GAAG,IAAIxI,IAAI,CAACI,GAAL,CAASmI,KAAT,CAAnB;AACAF,YAAM,GAAGrI,IAAI,CAACI,GAAL,CAAS,CAAC,IAAI2H,KAAL,IAAcQ,KAAvB,IAAgCC,MAAzC;AACAF,YAAM,GAAGtI,IAAI,CAACI,GAAL,CAAS2H,KAAK,GAAGQ,KAAjB,IAA0BC,MAAnC;AACH,KALD,MAKO;AACH;AACAH,YAAM,GAAG,IAAIN,KAAb;AACAO,YAAM,GAAGP,KAAT;AACH;;AAEDE,cAAU,CAAC9C,YAAX,CAAwBkD,MAAxB;AACAH,cAAU,CAAC/C,YAAX,CAAwBmD,MAAxB;AACAjJ,UAAM,CAAC0G,QAAP,CAAgBkC,UAAhB,EAA4BQ,UAA5B,CAAuCP,UAAvC;AACA7I,UAAM,CAAC8F,YAAP,CAAoBjH,MAAM,CAACwK,IAAP,CAAYP,aAAZ,EAA2BC,aAA3B,EAA0CL,KAA1C,CAApB;AACH,GAjCa;AAmCd;;;;;;;;;;AAQc9D,wBAAd,UAA0BzE,MAA1B,EAA2CmJ,IAA3C,EAA0DC,SAA1D,EAA6EC,QAA7E,EAA+FxJ,MAA/F,EAA8G;AAC1G4E,WAAO,CAAC6E,UAAR,CAAmBtJ,MAAnB,EAA2BmJ,IAA3B,EAAiCE,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqBD,SAAS,GAAGC,QAAlE,EAA4ExJ,MAA5E;AACH,GAFa;AAId;;;;;;;;AAMc4E,sBAAd,UAAwB/E,KAAxB,EAAiEqB,MAAjE,EAAmF;AAAlB;AAAAA;AAAkB;;AAC/E,WAAO,IAAI0D,OAAJ,CAAY/E,KAAK,CAACqB,MAAD,CAAjB,EAA2BrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhC,EAA8CrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAnD,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc0D,2BAAd,UAA6B/E,KAA7B,EAAiEqB,MAAjE,EAAgF;AAC5E,WAAO0D,OAAO,CAAC8E,SAAR,CAAkB7J,KAAlB,EAAyBqB,MAAzB,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc0D,2BAAd,UAA6B/E,KAA7B,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAqG;AACjGA,UAAM,CAACR,CAAP,GAAWK,KAAK,CAACqB,MAAD,CAAhB;AACAlB,UAAM,CAACP,CAAP,GAAWI,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACAlB,UAAM,CAACuE,CAAP,GAAW1E,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACH,GAJa;AAMd;;;;;;;;;AAOc0D,gCAAd,UAAkC/E,KAAlC,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAqG;AACjG,WAAO4E,OAAO,CAAC7E,cAAR,CAAuBF,KAAvB,EAA8BqB,MAA9B,EAAsClB,MAAtC,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc4E,4BAAd,UAA8BpF,CAA9B,EAAyCC,CAAzC,EAAoD8E,CAApD,EAA+DvE,MAA/D,EAA8E;AAC1EA,UAAM,CAACI,cAAP,CAAsBZ,CAAtB,EAAyBC,CAAzB,EAA4B8E,CAA5B;AACH,GAFa;AAId;;;;;;AAIcK,iBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIcA,gBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIcA,eAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;;AAOdD,wBAAkBC,OAAlB,EAAkB,YAAlB,EAA4B;AAH5B;;;SAGA;AACI,aAAOA,OAAO,CAAC+E,WAAf;AACH,KAF2B;qBAAA;;AAAA,GAA5B;AAOAhF,wBAAkBC,OAAlB,EAAkB,eAAlB,EAA+B;AAH/B;;;SAGA;AACI,aAAOA,OAAO,CAACgF,cAAf;AACH,KAF8B;qBAAA;;AAAA,GAA/B;AAOAjF,wBAAkBC,OAAlB,EAAkB,cAAlB,EAA8B;AAH9B;;;SAGA;AACI,aAAOA,OAAO,CAACiF,aAAf;AACH,KAF6B;qBAAA;;AAAA,GAA9B;AAOAlF,wBAAkBC,OAAlB,EAAkB,2BAAlB,EAA2C;AAH3C;;;SAGA;AACI,aAAOA,OAAO,CAACkF,0BAAf;AACH,KAF0C;qBAAA;;AAAA,GAA3C;AAOAnF,wBAAkBC,OAAlB,EAAkB,4BAAlB,EAA4C;AAH5C;;;SAGA;AACI,aAAOA,OAAO,CAACmF,2BAAf;AACH,KAF2C;qBAAA;;AAAA,GAA5C;AAOApF,wBAAkBC,OAAlB,EAAkB,cAAlB,EAA8B;AAH9B;;;SAGA;AACI,aAAOA,OAAO,CAACoF,aAAf;AACH,KAF6B;qBAAA;;AAAA,GAA9B;AAIA;;;;;AAIcpF,iBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,CAAC,GAAlB,EAAuB,GAAvB,CAAP;AACH,GAFa;AAGd;;;;;;;AAKcA,oBAAd,UAAsBqF,iBAAtB,EAAwD;AAAlC;AAAAA;AAAkC;;AACpD,WAAO,IAAIrF,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsBqF,iBAAiB,GAAG,CAAC,GAAJ,GAAU,GAAjD,CAAP;AACH,GAFa;AAGd;;;;;;;AAKcrF,qBAAd,UAAuBqF,iBAAvB,EAAyD;AAAlC;AAAAA;AAAkC;;AACrD,WAAO,IAAIrF,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsBqF,iBAAiB,GAAG,GAAH,GAAS,CAAC,GAAjD,CAAP;AACH,GAFa;AAGd;;;;;;AAIcrF,kBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIcA,iBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAC,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOcA,iCAAd,UAAmClC,MAAnC,EAAmEI,cAAnE,EAAwG;AACpG,QAAM9C,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AACAyC,WAAO,CAACsC,yBAAR,CAAkCxE,MAAlC,EAA0CI,cAA1C,EAA0D9C,MAA1D;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc4E,sCAAd,UAAwClC,MAAxC,EAAwEI,cAAxE,EAA+G9C,MAA/G,EAA8H;AAC1H4E,WAAO,CAACsF,mCAAR,CAA4CxH,MAAM,CAAC8B,EAAnD,EAAuD9B,MAAM,CAAC+B,EAA9D,EAAkE/B,MAAM,CAACgC,EAAzE,EAA6E5B,cAA7E,EAA6F9C,MAA7F;AACH,GAFa;AAId;;;;;;;;;;;AASc4E,gDAAd,UAAkDpF,CAAlD,EAA6DC,CAA7D,EAAwE8E,CAAxE,EAAmFzB,cAAnF,EAA0H9C,MAA1H,EAAyI;AACrI,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACA,QAAMkH,EAAE,GAAG3K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAA3B,GAAiCA,CAAC,CAAC,EAAD,CAA7C;AACA,QAAMmH,EAAE,GAAG5K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAA3B,GAAiCA,CAAC,CAAC,EAAD,CAA7C;AACA,QAAMoH,EAAE,GAAG7K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAA3B,GAAkCA,CAAC,CAAC,EAAD,CAA9C;AACA,QAAMqH,EAAE,GAAG,KAAK9K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAA3B,GAAkCA,CAAC,CAAC,EAAD,CAAxC,CAAX;AAEAjD,UAAM,CAACR,CAAP,GAAW2K,EAAE,GAAGG,EAAhB;AACAtK,UAAM,CAACP,CAAP,GAAW2K,EAAE,GAAGE,EAAhB;AACAtK,UAAM,CAACuE,CAAP,GAAW8F,EAAE,GAAGC,EAAhB;AACH,GAVa;AAYd;;;;;;;;;AAOc1F,4BAAd,UAA8BlC,MAA9B,EAA8DI,cAA9D,EAAmG;AAC/F,QAAM9C,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AACAyC,WAAO,CAAC2F,oBAAR,CAA6B7H,MAA7B,EAAqCI,cAArC,EAAqD9C,MAArD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc4E,iCAAd,UAAmClC,MAAnC,EAAmEI,cAAnE,EAA0G9C,MAA1G,EAAyH;AACrH,SAAKwK,8BAAL,CAAoC9H,MAAM,CAAC8B,EAA3C,EAA+C9B,MAAM,CAAC+B,EAAtD,EAA0D/B,MAAM,CAACgC,EAAjE,EAAqE5B,cAArE,EAAqF9C,MAArF;AACH,GAFa;AAId;;;;;;;;;;;AASc4E,2CAAd,UAA6CpF,CAA7C,EAAwDC,CAAxD,EAAmE8E,CAAnE,EAA8EzB,cAA9E,EAAqH9C,MAArH,EAAoI;AAChI,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACAjD,UAAM,CAACR,CAAP,GAAWA,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAAtC;AACAjD,UAAM,CAACP,CAAP,GAAWD,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAAtC;AACAjD,UAAM,CAACuE,CAAP,GAAW/E,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAAtC;AACH,GALa;AAOd;;;;;;;;;;;AASc2B,uBAAd,UACIzD,MADJ,EAEIC,MAFJ,EAGIC,MAHJ,EAIIC,MAJJ,EAKIC,MALJ,EAKkB;AAEd,QAAMC,OAAO,GAAGD,MAAM,GAAGA,MAAzB;AACA,QAAME,KAAK,GAAGF,MAAM,GAAGC,OAAvB;AAEA,QAAMhC,CAAC,GACH,OACC,MAAM4B,MAAM,CAACoD,EAAb,GACG,CAAC,CAACrD,MAAM,CAACqD,EAAR,GAAanD,MAAM,CAACmD,EAArB,IAA2BjD,MAD9B,GAEG,CAAC,MAAMJ,MAAM,CAACqD,EAAb,GAAkB,MAAMpD,MAAM,CAACoD,EAA/B,GAAoC,MAAMnD,MAAM,CAACmD,EAAjD,GAAsDlD,MAAM,CAACkD,EAA9D,IAAoEhD,OAFvE,GAGG,CAAC,CAACL,MAAM,CAACqD,EAAR,GAAa,MAAMpD,MAAM,CAACoD,EAA1B,GAA+B,MAAMnD,MAAM,CAACmD,EAA5C,GAAiDlD,MAAM,CAACkD,EAAzD,IAA+D/C,KAJnE,CADJ;AAOA,QAAMhC,CAAC,GACH,OACC,MAAM2B,MAAM,CAACqD,EAAb,GACG,CAAC,CAACtD,MAAM,CAACsD,EAAR,GAAapD,MAAM,CAACoD,EAArB,IAA2BlD,MAD9B,GAEG,CAAC,MAAMJ,MAAM,CAACsD,EAAb,GAAkB,MAAMrD,MAAM,CAACqD,EAA/B,GAAoC,MAAMpD,MAAM,CAACoD,EAAjD,GAAsDnD,MAAM,CAACmD,EAA9D,IAAoEjD,OAFvE,GAGG,CAAC,CAACL,MAAM,CAACsD,EAAR,GAAa,MAAMrD,MAAM,CAACqD,EAA1B,GAA+B,MAAMpD,MAAM,CAACoD,EAA5C,GAAiDnD,MAAM,CAACmD,EAAzD,IAA+DhD,KAJnE,CADJ;AAOA,QAAM8C,CAAC,GACH,OACC,MAAMnD,MAAM,CAACsD,EAAb,GACG,CAAC,CAACvD,MAAM,CAACuD,EAAR,GAAarD,MAAM,CAACqD,EAArB,IAA2BnD,MAD9B,GAEG,CAAC,MAAMJ,MAAM,CAACuD,EAAb,GAAkB,MAAMtD,MAAM,CAACsD,EAA/B,GAAoC,MAAMrD,MAAM,CAACqD,EAAjD,GAAsDpD,MAAM,CAACoD,EAA9D,IAAoElD,OAFvE,GAGG,CAAC,CAACL,MAAM,CAACuD,EAAR,GAAa,MAAMtD,MAAM,CAACsD,EAA1B,GAA+B,MAAMrD,MAAM,CAACqD,EAA5C,GAAiDpD,MAAM,CAACoD,EAAzD,IAA+DjD,KAJnE,CADJ;AAOA,WAAO,IAAImD,OAAJ,CAAYpF,CAAZ,EAAeC,CAAf,EAAkB8E,CAAlB,CAAP;AACH,GAhCa;AAkCd;;;;;;;;;;;AAScK,kBAAd,UAAoBxF,KAApB,EAAmDsC,GAAnD,EAAgFC,GAAhF,EAA2G;AACvG,QAAMsC,CAAC,GAAG,IAAIW,OAAJ,EAAV;AACAA,WAAO,CAAC6F,UAAR,CAAmBrL,KAAnB,EAA0BsC,GAA1B,EAA+BC,GAA/B,EAAoCsC,CAApC;AACA,WAAOA,CAAP;AACH,GAJa;AAKd;;;;;;;;;;;AAScW,uBAAd,UAAyBxF,KAAzB,EAAwDsC,GAAxD,EAAqFC,GAArF,EAAkH3B,MAAlH,EAAiI;AAC7H,QAAIR,CAAC,GAAGJ,KAAK,CAACoF,EAAd;AACAhF,KAAC,GAAGA,CAAC,GAAGmC,GAAG,CAAC6C,EAAR,GAAa7C,GAAG,CAAC6C,EAAjB,GAAsBhF,CAA1B;AACAA,KAAC,GAAGA,CAAC,GAAGkC,GAAG,CAAC8C,EAAR,GAAa9C,GAAG,CAAC8C,EAAjB,GAAsBhF,CAA1B;AAEA,QAAIC,CAAC,GAAGL,KAAK,CAACqF,EAAd;AACAhF,KAAC,GAAGA,CAAC,GAAGkC,GAAG,CAAC8C,EAAR,GAAa9C,GAAG,CAAC8C,EAAjB,GAAsBhF,CAA1B;AACAA,KAAC,GAAGA,CAAC,GAAGiC,GAAG,CAAC+C,EAAR,GAAa/C,GAAG,CAAC+C,EAAjB,GAAsBhF,CAA1B;AAEA,QAAI8E,CAAC,GAAGnF,KAAK,CAACsF,EAAd;AACAH,KAAC,GAAGA,CAAC,GAAG5C,GAAG,CAAC+C,EAAR,GAAa/C,GAAG,CAAC+C,EAAjB,GAAsBH,CAA1B;AACAA,KAAC,GAAGA,CAAC,GAAG7C,GAAG,CAACgD,EAAR,GAAahD,GAAG,CAACgD,EAAjB,GAAsBH,CAA1B;AAEAvE,UAAM,CAACI,cAAP,CAAsBZ,CAAtB,EAAyBC,CAAzB,EAA4B8E,CAA5B;AACH,GAda;AAgBd;;;;;;;;AAMcK,yBAAd,UAA2BX,CAA3B,EAAuCvC,GAAvC,EAAqDC,GAArD,EAAiE;AAC7DD,OAAG,CAACgJ,eAAJ,CAAoBzG,CAApB;AACAtC,OAAG,CAACgJ,eAAJ,CAAoB1G,CAApB;AACH,GAHa;AAKd;;;;;;;;;;;AAScW,oBAAd,UACIzD,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIN,MALJ,EAKkB;AAEd,QAAMC,OAAO,GAAGD,MAAM,GAAGA,MAAzB;AACA,QAAME,KAAK,GAAGF,MAAM,GAAGC,OAAvB;AACA,QAAMM,KAAK,GAAG,MAAML,KAAN,GAAc,MAAMD,OAApB,GAA8B,GAA5C;AACA,QAAMO,KAAK,GAAG,CAAC,GAAD,GAAON,KAAP,GAAe,MAAMD,OAAnC;AACA,QAAMQ,KAAK,GAAGP,KAAK,GAAG,MAAMD,OAAd,GAAwBD,MAAtC;AACA,QAAMU,KAAK,GAAGR,KAAK,GAAGD,OAAtB;AAEA,QAAMhC,CAAC,GAAG2B,MAAM,CAACqD,EAAP,GAAY1C,KAAZ,GAAoBV,MAAM,CAACoD,EAAP,GAAYzC,KAAhC,GAAwCH,QAAQ,CAAC4C,EAAT,GAAcxC,KAAtD,GAA8DH,QAAQ,CAAC2C,EAAT,GAAcvC,KAAtF;AACA,QAAMxC,CAAC,GAAG0B,MAAM,CAACsD,EAAP,GAAY3C,KAAZ,GAAoBV,MAAM,CAACqD,EAAP,GAAY1C,KAAhC,GAAwCH,QAAQ,CAAC6C,EAAT,GAAczC,KAAtD,GAA8DH,QAAQ,CAAC4C,EAAT,GAAcxC,KAAtF;AACA,QAAMsC,CAAC,GAAGpD,MAAM,CAACuD,EAAP,GAAY5C,KAAZ,GAAoBV,MAAM,CAACsD,EAAP,GAAY3C,KAAhC,GAAwCH,QAAQ,CAAC8C,EAAT,GAAc1C,KAAtD,GAA8DH,QAAQ,CAAC6C,EAAT,GAAczC,KAAtF;AACA,WAAO,IAAI2C,OAAJ,CAAYpF,CAAZ,EAAeC,CAAf,EAAkB8E,CAAlB,CAAP;AACH,GAlBa;AAoBd;;;;;;;;;;;AAScK,iCAAd,UACIzD,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAKgB;AAEZ,QAAMlC,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AAEA,SAAKC,yBAAL,CAA+BjB,MAA/B,EAAuCS,QAAvC,EAAiDR,MAAjD,EAAyDS,QAAzD,EAAmEK,IAAnE,EAAyElC,MAAzE;AAEA,WAAOA,MAAP;AACH,GAZa;AAcd;;;;;;;;;;;AASc4E,sCAAd,UACIzD,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAMIlC,MANJ,EAMmB;AAEf,QAAMqC,EAAE,GAAGH,IAAI,GAAGA,IAAlB;AAEAlC,UAAM,CAACR,CAAP,GAAW,CAAC6C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC3B,CAAzB,GAA6B,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACpC,CAAhE,GAAoE,CAAC,CAAC6C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC5B,CAA9F,GAAkG,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACrC,CAA5I;AACAQ,UAAM,CAACP,CAAP,GAAW,CAAC4C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC1B,CAAzB,GAA6B,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACnC,CAAhE,GAAoE,CAAC,CAAC4C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC3B,CAA9F,GAAkG,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACpC,CAA5I;AACAO,UAAM,CAACuE,CAAP,GAAW,CAAClC,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAACoD,CAAzB,GAA6B,CAAC,IAAIlC,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAAC2C,CAAhE,GAAoE,CAAC,CAAClC,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAACmD,CAA9F,GAAkG,CAAC,IAAIlC,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAAC0C,CAA5I;AACH,GAba;AAed;;;;;;;;;AAOcK,iBAAd,UAAmBtC,KAAnB,EAAkDC,GAAlD,EAA+EhB,MAA/E,EAA6F;AACzF,QAAMvB,MAAM,GAAG,IAAI4E,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAf;AACAA,WAAO,CAACgG,SAAR,CAAkBtI,KAAlB,EAAyBC,GAAzB,EAA8BhB,MAA9B,EAAsCvB,MAAtC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc4E,sBAAd,UAAwBtC,KAAxB,EAAuDC,GAAvD,EAAoFhB,MAApF,EAAoGvB,MAApG,EAAmH;AAC/GA,UAAM,CAACR,CAAP,GAAW8C,KAAK,CAACkC,EAAN,GAAW,CAACjC,GAAG,CAACiC,EAAJ,GAASlC,KAAK,CAACkC,EAAhB,IAAsBjD,MAA5C;AACAvB,UAAM,CAACP,CAAP,GAAW6C,KAAK,CAACmC,EAAN,GAAW,CAAClC,GAAG,CAACkC,EAAJ,GAASnC,KAAK,CAACmC,EAAhB,IAAsBlD,MAA5C;AACAvB,UAAM,CAACuE,CAAP,GAAWjC,KAAK,CAACoC,EAAN,GAAW,CAACnC,GAAG,CAACmC,EAAJ,GAASpC,KAAK,CAACoC,EAAhB,IAAsBnD,MAA5C;AACH,GAJa;AAMd;;;;;;;;AAMcqD,gBAAd,UAAkBpC,IAAlB,EAAgDC,KAAhD,EAA6E;AACzE,WAAOD,IAAI,CAACgC,EAAL,GAAU/B,KAAK,CAAC+B,EAAhB,GAAqBhC,IAAI,CAACiC,EAAL,GAAUhC,KAAK,CAACgC,EAArC,GAA0CjC,IAAI,CAACkC,EAAL,GAAUjC,KAAK,CAACiC,EAAjE;AACH,GAFa;AAId;;;;;;;;;AAOcE,kBAAd,UAAoBpC,IAApB,EAAkDC,KAAlD,EAA+E;AAC3E,QAAMzC,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AACAyC,WAAO,CAACuD,UAAR,CAAmB3F,IAAnB,EAAyBC,KAAzB,EAAgCzC,MAAhC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc4E,uBAAd,UAAyBpC,IAAzB,EAAuDC,KAAvD,EAAsFzC,MAAtF,EAAqG;AACjG,QAAMR,CAAC,GAAGgD,IAAI,CAACiC,EAAL,GAAUhC,KAAK,CAACiC,EAAhB,GAAqBlC,IAAI,CAACkC,EAAL,GAAUjC,KAAK,CAACgC,EAA/C;AACA,QAAMhF,CAAC,GAAG+C,IAAI,CAACkC,EAAL,GAAUjC,KAAK,CAAC+B,EAAhB,GAAqBhC,IAAI,CAACgC,EAAL,GAAU/B,KAAK,CAACiC,EAA/C;AACA,QAAMH,CAAC,GAAG/B,IAAI,CAACgC,EAAL,GAAU/B,KAAK,CAACgC,EAAhB,GAAqBjC,IAAI,CAACiC,EAAL,GAAUhC,KAAK,CAAC+B,EAA/C;AACAxE,UAAM,CAACI,cAAP,CAAsBZ,CAAtB,EAAyBC,CAAzB,EAA4B8E,CAA5B;AACH,GALa;AAOd;;;;;;;AAKcK,sBAAd,UAAwBlC,MAAxB,EAAsD;AAClD,QAAM1C,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AACAyC,WAAO,CAAC3D,cAAR,CAAuByB,MAAvB,EAA+B1C,MAA/B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc4E,2BAAd,UAA6BlC,MAA7B,EAA6D1C,MAA7D,EAA4E;AACxE0C,UAAM,CAAC6E,cAAP,CAAsBvH,MAAtB;AACH,GAFa;AAId;;;;;;;;;;AAQc4E,oBAAd,UAAsBlC,MAAtB,EAAsDmI,KAAtD,EAAoFC,SAApF,EAAsHC,QAAtH,EAAuJ;AACnJ,QAAM/K,MAAM,GAAG,IAAI4E,OAAJ,EAAf;AACAA,WAAO,CAACoG,YAAR,CAAqBtI,MAArB,EAA6BmI,KAA7B,EAAoCC,SAApC,EAA+CC,QAA/C,EAAyD/K,MAAzD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;AASc4E,yBAAd,UACIlC,MADJ,EAEImI,KAFJ,EAGIC,SAHJ,EAIIC,QAJJ,EAKI/K,MALJ,EAKkC;AAE9B,QAAMiL,EAAE,GAAGF,QAAQ,CAACG,KAApB;AACA,QAAMC,EAAE,GAAGJ,QAAQ,CAACK,MAApB;AACA,QAAMC,EAAE,GAAGN,QAAQ,CAACvL,CAApB;AACA,QAAM8L,EAAE,GAAGP,QAAQ,CAACtL,CAApB;AAEA,QAAM8L,cAAc,GAAG9F,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAvB;AAEAA,UAAM,CAACuE,eAAP,CAAuBP,EAAE,GAAG,GAA5B,EAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAvC,EAA0C,CAA1C,EAA6C,CAACE,EAAD,GAAM,GAAnD,EAAwD,CAAxD,EAA2D,CAA3D,EAA8D,CAA9D,EAAiE,CAAjE,EAAoE,GAApE,EAAyE,CAAzE,EAA4EE,EAAE,GAAGJ,EAAE,GAAG,GAAtF,EAA2FE,EAAE,GAAG,GAAL,GAAWG,EAAtG,EAA0G,GAA1G,EAA+G,CAA/G,EAAkHC,cAAlH;AAEA,QAAME,MAAM,GAAGhG,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACA4D,SAAK,CAACa,aAAN,CAAoBZ,SAApB,EAA+BW,MAA/B;AACAA,UAAM,CAACC,aAAP,CAAqBH,cAArB,EAAqCE,MAArC;AAEA7G,WAAO,CAACsC,yBAAR,CAAkCxE,MAAlC,EAA0C+I,MAA1C,EAAkDzL,MAAlD;AACA,WAAOA,MAAP;AACH,GAtBa;AAwBd;;;;;;;;AAMc4E,8CAAd,UAAgDzE,MAAhD,EAAgFsL,MAAhF,EAA+GzL,MAA/G,EAA8H;AAC1H4E,WAAO,CAACsC,yBAAR,CAAkC/G,MAAlC,EAA0CsL,MAA1C,EAAkDzL,MAAlD;AACA,QAAMiD,CAAC,GAAGwI,MAAM,CAACxI,CAAjB;AACA,QAAM0I,GAAG,GAAGxL,MAAM,CAACqE,EAAP,GAAYvB,CAAC,CAAC,CAAD,CAAb,GAAmB9C,MAAM,CAACsE,EAAP,GAAYxB,CAAC,CAAC,CAAD,CAAhC,GAAsC9C,MAAM,CAACuE,EAAP,GAAYzB,CAAC,CAAC,EAAD,CAAnD,GAA0DA,CAAC,CAAC,EAAD,CAAvE;;AACA,QAAIpE,MAAM,CAAC6B,aAAP,CAAqBiL,GAArB,EAA0B,GAA1B,CAAJ,EAAoC;AAChC3L,YAAM,CAAC8F,YAAP,CAAoB,MAAM6F,GAA1B;AACH;AACJ,GAPa;AASd;;;;;;;;;;;AASc/G,mCAAd,UAAqCzE,MAArC,EAAsDyL,aAAtD,EAA6EC,cAA7E,EAAqGhB,KAArG,EAAmIC,SAAnI,EAAmK;AAC/J,WAAO,KAAKgB,SAAL,CAAe3L,MAAf,EAAuByL,aAAvB,EAAsCC,cAAtC,EAAsDhB,KAAtD,EAA6DC,SAA7D,EAAwE7D,MAAM,CAAC8E,gBAA/E,CAAP;AACH,GAFa;AAId;;;;;;;;;;;;AAUcnH,sBAAd,UACIzE,MADJ,EAEIyL,aAFJ,EAGIC,cAHJ,EAIIhB,KAJJ,EAKImB,IALJ,EAMIC,UANJ,EAMqC;AAEjC,QAAMjM,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AAEAyC,WAAO,CAACsH,cAAR,CAAuB/L,MAAvB,EAA+ByL,aAA/B,EAA8CC,cAA9C,EAA8DhB,KAA9D,EAAqEmB,IAArE,EAA2EC,UAA3E,EAAuFjM,MAAvF;AAEA,WAAOA,MAAP;AACH,GAba;AAed;;;;;;;;;;;;AAUc4E,2BAAd,UACIzE,MADJ,EAEIyL,aAFJ,EAGIC,cAHJ,EAIIhB,KAJJ,EAKImB,IALJ,EAMIC,UANJ,EAOIjM,MAPJ,EAOmB;AAEf4E,WAAO,CAACuH,oBAAR,CAA6BhM,MAAM,CAACqE,EAApC,EAAwCrE,MAAM,CAACsE,EAA/C,EAAmDtE,MAAM,CAACuE,EAA1D,EAA8DkH,aAA9D,EAA6EC,cAA7E,EAA6FhB,KAA7F,EAAoGmB,IAApG,EAA0GC,UAA1G,EAAsHjM,MAAtH;AACH,GAVa;AAYd;;;;;;;;;;;;;;AAYc4E,iCAAd,UACIwH,OADJ,EAEIC,OAFJ,EAGIC,OAHJ,EAIIV,aAJJ,EAKIC,cALJ,EAMIhB,KANJ,EAOImB,IAPJ,EAQIC,UARJ,EASIjM,MATJ,EASmB;;;AAEf,QAAMyL,MAAM,GAAGhG,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACA4D,SAAK,CAACa,aAAN,CAAoBM,IAApB,EAA0BP,MAA1B;AACAA,UAAM,CAACC,aAAP,CAAqBO,UAArB,EAAiCR,MAAjC;AACAA,UAAM,CAACc,MAAP;AAEA,QAAMC,YAAY,GAAG/G,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAArB;AACA4H,gBAAY,CAAChN,CAAb,GAAkB4M,OAAO,GAAGR,aAAX,GAA4B,CAA5B,GAAgC,CAAjD;AACAY,gBAAY,CAAC/M,CAAb,GAAiB,EAAG4M,OAAO,GAAGR,cAAX,GAA6B,CAA7B,GAAiC,CAAnC,CAAjB;;AACA,QAAI,iBAAW,CAACY,iBAAZ,MAA6B,IAA7B,IAA6BC,aAA7B,GAA6B,MAA7B,GAA6BA,GAAEC,eAAnC,EAAoD;AAChDH,kBAAY,CAACjI,CAAb,GAAiB+H,OAAjB;AACH,KAFD,MAEO;AACHE,kBAAY,CAACjI,CAAb,GAAiB,IAAI+H,OAAJ,GAAc,GAA/B;AACH;;AAED1H,WAAO,CAACgI,iCAAR,CAA0CJ,YAA1C,EAAwDf,MAAxD,EAAgEzL,MAAhE;AACH,GA1Ba;AA4Bd;;;;;;;;AAMc4E,qBAAd,UAAuBpC,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMf,GAAG,GAAGc,IAAI,CAACqK,KAAL,EAAZ;AACAnL,OAAG,CAACgJ,eAAJ,CAAoBjI,KAApB;AACA,WAAOf,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMckD,qBAAd,UAAuBpC,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMd,GAAG,GAAGa,IAAI,CAACqK,KAAL,EAAZ;AACAlL,OAAG,CAACgJ,eAAJ,CAAoBlI,KAApB;AACA,WAAOd,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMciD,qBAAd,UAAuBzD,MAAvB,EAAuDC,MAAvD,EAAqF;AACjF,WAAOT,IAAI,CAACK,IAAL,CAAU4D,OAAO,CAAClB,eAAR,CAAwBvC,MAAxB,EAAgCC,MAAhC,CAAV,CAAP;AACH,GAFa;AAId;;;;;;;;AAMcwD,4BAAd,UAA8BzD,MAA9B,EAA8DC,MAA9D,EAA4F;AACxF,QAAM5B,CAAC,GAAG2B,MAAM,CAACqD,EAAP,GAAYpD,MAAM,CAACoD,EAA7B;AACA,QAAM/E,CAAC,GAAG0B,MAAM,CAACsD,EAAP,GAAYrD,MAAM,CAACqD,EAA7B;AACA,QAAMF,CAAC,GAAGpD,MAAM,CAACuD,EAAP,GAAYtD,MAAM,CAACsD,EAA7B;AAEA,WAAOlF,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAZ,GAAgB8E,CAAC,GAAGA,CAA3B;AACH,GANa;AAQd;;;;;;;;;;;;;;AAYcK,mCAAd,UAAqClC,MAArC,EAAqES,EAArE,EAAiGC,EAAjG,EAA6HC,EAA7H,EAAyJO,GAAzJ,EAAqK;AACjK,QAAMkJ,IAAI,GAAGrH,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACA,QAAMmI,IAAI,GAAGtH,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACA,QAAMoI,IAAI,GAAGvH,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACA,QAAMU,MAAM,GAAGG,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAf;AACA,QAAMqI,QAAQ,GAAGxH,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAjB,CALiK,CAOjK;;AACAxB,MAAE,CAACsC,aAAH,CAAiBvC,EAAjB,EAAqB2J,IAArB;AACAzJ,MAAE,CAACqC,aAAH,CAAiBvC,EAAjB,EAAqB4J,IAArB;AACA1J,MAAE,CAACqC,aAAH,CAAiBtC,EAAjB,EAAqB4J,IAArB;AAEA,QAAME,KAAK,GAAGJ,IAAI,CAACjK,MAAL,EAAd;AACA,QAAMsK,KAAK,GAAGJ,IAAI,CAAClK,MAAL,EAAd;AACA,QAAMuK,KAAK,GAAGJ,IAAI,CAACnK,MAAL,EAAd;;AAEA,QAAIqK,KAAK,GAAGpO,OAAR,IAAmBqO,KAAK,GAAGrO,OAA3B,IAAsCsO,KAAK,GAAGtO,OAAlD,EAA2D;AACvD;AACA;AACA;AACA8E,SAAG,CAAC8C,QAAJ,CAAavD,EAAb;AACA,aAAOyB,OAAO,CAACZ,QAAR,CAAiBtB,MAAjB,EAAyBS,EAAzB,CAAP;AACH,KAtBgK,CAwBjK;;;AACAT,UAAM,CAACgD,aAAP,CAAqBvC,EAArB,EAAyB8J,QAAzB;AACArI,WAAO,CAACuD,UAAR,CAAmB2E,IAAnB,EAAyBC,IAAzB,EAA+BzH,MAA/B;AACA,QAAM+H,EAAE,GAAG/H,MAAM,CAACzC,MAAP,EAAX;;AACA,QAAIwK,EAAE,GAAGvO,OAAT,EAAkB;AACd;AACA8E,SAAG,CAAC8C,QAAJ,CAAavD,EAAb;AACA,aAAOyB,OAAO,CAACZ,QAAR,CAAiBtB,MAAjB,EAAyBS,EAAzB,CAAP;AACH;;AACDmC,UAAM,CAACiB,mBAAP,CAA2B8G,EAA3B;AACA,QAAIC,CAAC,GAAGL,QAAQ,CAACpK,MAAT,EAAR;;AACA,QAAIyK,CAAC,GAAGxO,OAAR,EAAiB;AACb;AACA8E,SAAG,CAAC8C,QAAJ,CAAavD,EAAb;AACA,aAAO,CAAP;AACH;;AACD8J,YAAQ,CAAC1G,mBAAT,CAA6B+G,CAA7B,EAxCiK,CA0CjK;;AACA,QAAMC,IAAI,GAAG3I,OAAO,CAACT,GAAR,CAAYmB,MAAZ,EAAoB2H,QAApB,CAAb;AACA,QAAMO,UAAU,GAAG/H,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAnB;AACA,QAAMR,IAAI,GAAGqB,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACA4I,cAAU,CAAC9G,QAAX,CAAoBpB,MAApB,EAA4BQ,YAA5B,CAAyC,CAACwH,CAAD,GAAKC,IAA9C;AACAnJ,QAAI,CAACsC,QAAL,CAAchE,MAAd,EAAsB0G,UAAtB,CAAiCoE,UAAjC,EA/CiK,CAiDjK;;AACA,QAAMzF,EAAE,GAAGtC,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAX;AACA,QAAMoD,EAAE,GAAGvC,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAX;AACA,QAAM6I,EAAE,GAAGhI,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAX;AACA,QAAM8I,GAAG,GAAGjI,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAZ;AAEAmD,MAAE,CAACrB,QAAH,CAAYoG,IAAZ,EAAkBhH,YAAlB,CAA+B,IAAIoH,KAAnC;AACAQ,OAAG,CAAChH,QAAJ,CAAaqG,IAAb,EAAmBjH,YAAnB,CAAgC,IAAIqH,KAApC;AACApF,MAAE,CAACqB,UAAH,CAAcsE,GAAd,EAAmB5H,YAAnB,CAAgC,CAAC,CAAjC;AAEAkC,MAAE,CAACtB,QAAH,CAAYoG,IAAZ,EAAkBhH,YAAlB,CAA+B,CAAC,CAAD,GAAKoH,KAApC;AACAQ,OAAG,CAAChH,QAAJ,CAAasG,IAAb,EAAmBlH,YAAnB,CAAgC,IAAIsH,KAApC;AACApF,MAAE,CAACoB,UAAH,CAAcsE,GAAd,EAAmB5H,YAAnB,CAAgC,CAAC,CAAjC;AAEA2H,MAAE,CAAC/G,QAAH,CAAYsG,IAAZ,EAAkBlH,YAAlB,CAA+B,CAAC,CAAD,GAAKsH,KAApC;AACAM,OAAG,CAAChH,QAAJ,CAAaqG,IAAb,EAAmBjH,YAAnB,CAAgC,CAAC,CAAD,GAAKqH,KAArC;AACAM,MAAE,CAACrE,UAAH,CAAcsE,GAAd,EAAmB5H,YAAnB,CAAgC,CAAC,CAAjC,EAjEiK,CAmEjK;;AACA,QAAM6H,KAAK,GAAGlI,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAIqD,GAAJ;AACA0F,SAAK,CAACjH,QAAN,CAAetC,IAAf,EAAqBwJ,eAArB,CAAqCzK,EAArC;AACAyB,WAAO,CAACuD,UAAR,CAAmBJ,EAAnB,EAAuB4F,KAAvB,EAA8BD,GAA9B;AACAzF,OAAG,GAAGrD,OAAO,CAACT,GAAR,CAAYuJ,GAAZ,EAAiBpI,MAAjB,CAAN;AACA,QAAMuI,EAAE,GAAG5F,GAAX;AAEA0F,SAAK,CAACjH,QAAN,CAAetC,IAAf,EAAqBwJ,eAArB,CAAqCxK,EAArC;AACAwB,WAAO,CAACuD,UAAR,CAAmBH,EAAnB,EAAuB2F,KAAvB,EAA8BD,GAA9B;AACAzF,OAAG,GAAGrD,OAAO,CAACT,GAAR,CAAYuJ,GAAZ,EAAiBpI,MAAjB,CAAN;AACA,QAAMwI,EAAE,GAAG7F,GAAX;AAEA0F,SAAK,CAACjH,QAAN,CAAetC,IAAf,EAAqBwJ,eAArB,CAAqCvK,EAArC;AACAuB,WAAO,CAACuD,UAAR,CAAmBsF,EAAnB,EAAuBE,KAAvB,EAA8BD,GAA9B;AACAzF,OAAG,GAAGrD,OAAO,CAACT,GAAR,CAAYuJ,GAAZ,EAAiBpI,MAAjB,CAAN;AACA,QAAMyI,EAAE,GAAG9F,GAAX;AAEA,QAAM+F,IAAI,GAAGvI,OAAO,CAACb,OAAR,CAAgB,EAAhB,CAAb;AACA,QAAIqJ,EAAJ,EAAQC,EAAR;;AACA,QAAIL,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAAnB,EAAsB;AAClBE,UAAI,CAACtH,QAAL,CAAcoG,IAAd;AACAmB,QAAE,GAAG9K,EAAL;AACA+K,QAAE,GAAG9K,EAAL;AACH,KAJD,MAIO,IAAI0K,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAAnB,EAAsB;AACzBC,UAAI,CAACtH,QAAL,CAAcsG,IAAd;AACAiB,QAAE,GAAG7K,EAAL;AACA8K,QAAE,GAAG7K,EAAL;AACH,KAJM,MAIA;AACH2K,UAAI,CAACtH,QAAL,CAAcqG,IAAd,EAAoBjH,YAApB,CAAiC,CAAC,CAAlC;AACAmI,QAAE,GAAG5K,EAAL;AACA6K,QAAE,GAAG/K,EAAL;AACH,KAnGgK,CAqGjK;;;AACA,QAAMgL,IAAI,GAAG1I,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACA,QAAMwJ,IAAI,GAAG3I,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACAqJ,MAAE,CAACvI,aAAH,CAAiBtB,IAAjB,EAAuBsJ,GAAvB;AACAQ,MAAE,CAACxI,aAAH,CAAiBtB,IAAjB,EAAuB+J,IAAvB;AACAvJ,WAAO,CAACuD,UAAR,CAAmBuF,GAAnB,EAAwBS,IAAxB,EAA8BC,IAA9B;AACA,QAAMC,SAAS,GAAGzJ,OAAO,CAACT,GAAR,CAAYiK,IAAZ,EAAkB9I,MAAlB,IAA4B,CAA9C,CA3GiK,CA6GjK;;AACA,QAAI,CAAC+I,SAAL,EAAgB;AACZzK,SAAG,CAAC8C,QAAJ,CAAatC,IAAb;AACA,aAAOzD,IAAI,CAACyF,GAAL,CAASkH,CAAC,GAAGC,IAAb,CAAP;AACH,KAjHgK,CAmHjK;;;AACA,QAAMxK,CAAC,GAAG0C,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAV;AACAA,WAAO,CAACuD,UAAR,CAAmB6F,IAAnB,EAAyBI,IAAzB,EAA+BrL,CAA/B;AACAA,KAAC,CAAC4C,SAAF;AACA,QAAM2I,MAAM,GAAG7I,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAf;AACA0J,UAAM,CAAC5H,QAAP,CAAgBuH,EAAhB,EAAoBL,eAApB,CAAoCxJ,IAApC;AACA,QAAMmK,OAAO,GAAGD,MAAM,CAACzL,MAAP,EAAhB;;AACA,QAAI0L,OAAO,GAAGzP,OAAd,EAAuB;AACnB;AACA8E,SAAG,CAAC8C,QAAJ,CAAauH,EAAb;AACA,aAAOrJ,OAAO,CAACZ,QAAR,CAAiBtB,MAAjB,EAAyBuL,EAAzB,CAAP;AACH;;AACDK,UAAM,CAAC/H,mBAAP,CAA2BgI,OAA3B;AACA,QAAMC,IAAI,GAAG5J,OAAO,CAACT,GAAR,CAAYpB,CAAZ,EAAeuL,MAAf,CAAb;AACA,QAAMG,OAAO,GAAGhJ,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAhB;AACA6J,WAAO,CAAC/H,QAAR,CAAiBtC,IAAjB,EAAuBgF,UAAvB,CAAkCrG,CAAC,CAAC+C,YAAF,CAAeyI,OAAO,GAAGC,IAAzB,CAAlC,EAlIiK,CAoIjK;;AACAd,OAAG,CAAChH,QAAJ,CAAa+H,OAAb,EAAsBb,eAAtB,CAAsCK,EAAtC;AACAX,KAAC,GAAGU,IAAI,CAACnL,MAAL,EAAJ;AACAmL,QAAI,CAACzH,mBAAL,CAAyB+G,CAAzB;AACA,QAAI7J,CAAC,GAAGmB,OAAO,CAACT,GAAR,CAAYuJ,GAAZ,EAAiBM,IAAjB,IAAyBrN,IAAI,CAACgB,GAAL,CAAS2L,CAAT,EAAYxO,OAAZ,CAAjC;AACA2E,KAAC,GAAG5E,MAAM,CAAC8J,KAAP,CAAalF,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAAJ;AACAgL,WAAO,CAAC/H,QAAR,CAAiBuH,EAAjB,EAAqB7E,UAArB,CAAgC4E,IAAI,CAAClI,YAAL,CAAkBrC,CAAC,GAAG6J,CAAtB,CAAhC;AACA1J,OAAG,CAAC8C,QAAJ,CAAa+H,OAAb;AAEA,WAAO7J,OAAO,CAACZ,QAAR,CAAiBtB,MAAjB,EAAyB+L,OAAzB,CAAP;AACH,GA9Ia;AAgJd;;;;;;;;AAMc7J,mBAAd,UAAqBzD,MAArB,EAAqDC,MAArD,EAAmF;AAC/E,WAAOwD,OAAO,CAACjB,WAAR,CAAoBxC,MAApB,EAA4BC,MAA5B,EAAoCwD,OAAO,CAACzC,IAAR,EAApC,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOcyC,wBAAd,UAA0BzD,MAA1B,EAA0DC,MAA1D,EAA0FwC,GAA1F,EAAqH;AACjH,WAAOA,GAAG,CAACxD,cAAJ,CAAmB,CAACe,MAAM,CAACqD,EAAP,GAAYpD,MAAM,CAACoD,EAApB,IAA0B,CAA7C,EAAgD,CAACrD,MAAM,CAACsD,EAAP,GAAYrD,MAAM,CAACqD,EAApB,IAA0B,CAA1E,EAA6E,CAACtD,MAAM,CAACuD,EAAP,GAAYtD,MAAM,CAACsD,EAApB,IAA0B,CAAvG,CAAP;AACH,GAFa;AAId;;;;;;;;;;;;;AAWcE,6BAAd,UAA+B8J,KAA/B,EAA8DC,KAA9D,EAA6FC,KAA7F,EAA0H;AACtH,QAAMC,QAAQ,GAAGjK,OAAO,CAACzC,IAAR,EAAjB;AACAyC,WAAO,CAACkK,qBAAR,CAA8BJ,KAA9B,EAAqCC,KAArC,EAA4CC,KAA5C,EAAmDC,QAAnD;AACA,WAAOA,QAAP;AACH,GAJa;AAMd;;;;;;;;;AAOcjK,kCAAd,UAAoC8J,KAApC,EAAmEC,KAAnE,EAAkGC,KAAlG,EAAiIhL,GAAjI,EAA6I;AACzI,QAAMmL,IAAI,GAAGtJ,OAAO,CAACX,UAAR,CAAmB,CAAnB,CAAb;AACAA,cAAU,CAACkK,+BAAX,CAA2CN,KAA3C,EAAkDC,KAAlD,EAAyDC,KAAzD,EAAgEG,IAAhE;AACAA,QAAI,CAACE,kBAAL,CAAwBrL,GAAxB;AACH,GAJa;;AA9tDCgB,wBAAcA,OAAO,CAACsK,EAAR,EAAd;AACAtK,uCAA6BA,OAAO,CAACuK,OAAR,CAAgB,KAAhB,CAA7B;AACAvK,wCAA8BA,OAAO,CAACuK,OAAR,CAAgB,IAAhB,CAA9B;AACAvK,2BAAiBA,OAAO,CAACwK,KAAR,EAAjB;AACAxK,0BAAgBA,OAAO,CAACyK,IAAR,EAAhB;AACAzK,0BAAgBA,OAAO,CAACzC,IAAR,EAAhB;AA8tDnB;AAAC,CApuDD;;SAAayC;AAsuDb;;;;AAGA;AAAA;AAAA;AACI;;;;;;;AAOA;AACI;AACOpF,GAFX;AAGI;AACOC,GAJX;AAKI;AACO8E,GANX;AAOI;AACO+K,GARX,EAQoB;AANT;AAEA;AAEA;AAEA;AACP;AAEJ;;;;;;AAIOC,+BAAP;AACI,WAAO,cAAO,KAAK/P,CAAZ,EAAa,MAAb,EAAaG,MAAb,CAAoB,KAAKF,CAAzB,EAA0B,MAA1B,EAA0BE,MAA1B,CAAiC,KAAK4E,CAAtC,EAAuC,MAAvC,EAAuC5E,MAAvC,CAA8C,KAAK2P,CAAnD,EAAoD,GAApD,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,mCAAP;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIOA,kCAAP;AACI,QAAM/P,CAAC,GAAGL,aAAa,CAAC,KAAKK,CAAN,CAAvB;;AACA,QAAMC,CAAC,GAAGN,aAAa,CAAC,KAAKM,CAAN,CAAvB;;AACA,QAAM8E,CAAC,GAAGpF,aAAa,CAAC,KAAKoF,CAAN,CAAvB;;AACA,QAAM+K,CAAC,GAAGnQ,aAAa,CAAC,KAAKmQ,CAAN,CAAvB;;AAEA,QAAI1P,IAAI,GAAGJ,CAAX;AACAI,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAeH,CAAtB;AACAG,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAe2E,CAAtB;AACA3E,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAe0P,CAAtB;AACA,WAAO1P,IAAP;AACH,GAXM,CAvCX,CAoDI;;AACA;;;;;;AAIO2P,8BAAP;AACI,QAAMvP,MAAM,GAAG,IAAIC,KAAJ,EAAf;AAEA,SAAKC,OAAL,CAAaF,MAAb,EAAqB,CAArB;AAEA,WAAOA,MAAP;AACH,GANM;AAQP;;;;;;;;AAMOuP,8BAAP,UAAe1P,KAAf,EAAkCC,KAAlC,EAAgD;AAC5C,QAAIA,KAAK,KAAK0P,SAAd,EAAyB;AACrB1P,WAAK,GAAG,CAAR;AACH;;AACDD,SAAK,CAACC,KAAD,CAAL,GAAe,KAAKN,CAApB;AACAK,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAKL,CAAxB;AACAI,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAKyE,CAAxB;AACA1E,SAAK,CAACC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAKwP,CAAxB;AACA,WAAO,IAAP;AACH,GATM;AAWP;;;;;;;;AAMOC,gCAAP,UAAiB1P,KAAjB,EAAoCC,KAApC,EAAqD;AAAjB;AAAAA;AAAiB;;AACjDyP,WAAO,CAACxP,cAAR,CAAuBF,KAAvB,EAA8BC,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKOyP,iCAAP,UAAkBlP,WAAlB,EAAqD;AACjD,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,SAAK8E,CAAL,IAAUlE,WAAW,CAACkE,CAAtB;AACA,SAAK+K,CAAL,IAAUjP,WAAW,CAACiP,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,0BAAP,UAAWlP,WAAX,EAA8C;AAC1C,WAAO,IAAIkP,OAAJ,CAAY,KAAK/P,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,EAA4D,KAAK8E,CAAL,GAASlE,WAAW,CAACkE,CAAjF,EAAoF,KAAK+K,CAAL,GAASjP,WAAW,CAACiP,CAAzG,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,+BAAP,UAAgBlP,WAAhB,EAAqDL,MAArD,EAAoE;AAChEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACAO,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAASlE,WAAW,CAACkE,CAAhC;AACAvE,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAASjP,WAAW,CAACiP,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,sCAAP,UAAuBlP,WAAvB,EAA0D;AACtD,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,SAAK8E,CAAL,IAAUlE,WAAW,CAACkE,CAAtB;AACA,SAAK+K,CAAL,IAAUjP,WAAW,CAACiP,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,+BAAP,UAAgBlP,WAAhB,EAAmD;AAC/C,WAAO,IAAIkP,OAAJ,CAAY,KAAK/P,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,EAA4D,KAAK8E,CAAL,GAASlE,WAAW,CAACkE,CAAjF,EAAoF,KAAK+K,CAAL,GAASjP,WAAW,CAACiP,CAAzG,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOC,oCAAP,UAAqBlP,WAArB,EAA0DL,MAA1D,EAAyE;AACrEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACAO,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAASlE,WAAW,CAACkE,CAAhC;AACAvE,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAASjP,WAAW,CAACiP,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;AAGA;;;;;;;;;;AAQOC,yCAAP,UAA0B/P,CAA1B,EAAqCC,CAArC,EAAgD8E,CAAhD,EAA2D+K,CAA3D,EAAoE;AAChE,WAAO,IAAIC,OAAJ,CAAY,KAAK/P,CAAL,GAASA,CAArB,EAAwB,KAAKC,CAAL,GAASA,CAAjC,EAAoC,KAAK8E,CAAL,GAASA,CAA7C,EAAgD,KAAK+K,CAAL,GAASA,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;;;;AASOC,8CAAP,UAA+B/P,CAA/B,EAA0CC,CAA1C,EAAqD8E,CAArD,EAAgE+K,CAAhE,EAA2EtP,MAA3E,EAA0F;AACtFA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASA,CAApB;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASA,CAApB;AACAO,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAASA,CAApB;AACAvE,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAASA,CAApB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIOC,6BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,CAAC,KAAK/P,CAAlB,EAAqB,CAAC,KAAKC,CAA3B,EAA8B,CAAC,KAAK8E,CAApC,EAAuC,CAAC,KAAK+K,CAA7C,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,oCAAP;AACI,SAAK/P,CAAL,IAAU,CAAC,CAAX;AACA,SAAKC,CAAL,IAAU,CAAC,CAAX;AACA,SAAK8E,CAAL,IAAU,CAAC,CAAX;AACA,SAAK+K,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,kCAAP,UAAmBvP,MAAnB,EAAkC;AAC9B,WAAOA,MAAM,CAACI,cAAP,CAAsB,KAAKZ,CAAL,GAAS,CAAC,CAAhC,EAAmC,KAAKC,CAAL,GAAS,CAAC,CAA7C,EAAgD,KAAK8E,CAAL,GAAS,CAAC,CAA1D,EAA6D,KAAK+K,CAAL,GAAS,CAAC,CAAvE,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,mCAAP,UAAoBhP,KAApB,EAAiC;AAC7B,SAAKf,CAAL,IAAUe,KAAV;AACA,SAAKd,CAAL,IAAUc,KAAV;AACA,SAAKgE,CAAL,IAAUhE,KAAV;AACA,SAAK+O,CAAL,IAAU/O,KAAV;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOgP,4BAAP,UAAahP,KAAb,EAA0B;AACtB,WAAO,IAAIgP,OAAJ,CAAY,KAAK/P,CAAL,GAASe,KAArB,EAA4B,KAAKd,CAAL,GAASc,KAArC,EAA4C,KAAKgE,CAAL,GAAShE,KAArD,EAA4D,KAAK+O,CAAL,GAAS/O,KAArE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMOgP,iCAAP,UAAkBhP,KAAlB,EAAiCP,MAAjC,EAAgD;AAC5CA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASe,KAApB;AACAP,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASc,KAApB;AACAP,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAAShE,KAApB;AACAP,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAAS/O,KAApB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;AAMOgP,uCAAP,UAAwBhP,KAAxB,EAAuCP,MAAvC,EAAsD;AAClDA,UAAM,CAACR,CAAP,IAAY,KAAKA,CAAL,GAASe,KAArB;AACAP,UAAM,CAACP,CAAP,IAAY,KAAKA,CAAL,GAASc,KAArB;AACAP,UAAM,CAACuE,CAAP,IAAY,KAAKA,CAAL,GAAShE,KAArB;AACAP,UAAM,CAACsP,CAAP,IAAY,KAAKA,CAAL,GAAS/O,KAArB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOgP,6BAAP,UAAclP,WAAd,EAAiD;AAC7C,WAAOA,WAAW,IAAI,KAAKb,CAAL,KAAWa,WAAW,CAACb,CAAtC,IAA2C,KAAKC,CAAL,KAAWY,WAAW,CAACZ,CAAlE,IAAuE,KAAK8E,CAAL,KAAWlE,WAAW,CAACkE,CAA9F,IAAmG,KAAK+K,CAAL,KAAWjP,WAAW,CAACiP,CAAjI;AACH,GAFM;AAIP;;;;;;;;AAMOC,wCAAP,UAAyBlP,WAAzB,EAA8DI,OAA9D,EAAuF;AAAzB;AAAAA;AAAyB;;AACnF,WACIJ,WAAW,IACXxB,MAAM,CAAC6B,aAAP,CAAqB,KAAKlB,CAA1B,EAA6Ba,WAAW,CAACb,CAAzC,EAA4CiB,OAA5C,CADA,IAEA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAKjB,CAA1B,EAA6BY,WAAW,CAACZ,CAAzC,EAA4CgB,OAA5C,CAFA,IAGA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAK6D,CAA1B,EAA6BlE,WAAW,CAACkE,CAAzC,EAA4C9D,OAA5C,CAHA,IAIA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAK4O,CAA1B,EAA6BjP,WAAW,CAACiP,CAAzC,EAA4C7O,OAA5C,CALJ;AAOH,GARM;AAUP;;;;;;;;;;AAQO8O,qCAAP,UAAsB/P,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAuD+K,CAAvD,EAAgE;AAC5D,WAAO,KAAK9P,CAAL,KAAWA,CAAX,IAAgB,KAAKC,CAAL,KAAWA,CAA3B,IAAgC,KAAK8E,CAAL,KAAWA,CAA3C,IAAgD,KAAK+K,CAAL,KAAWA,CAAlE;AACH,GAFM;AAIP;;;;;;;AAKOC,sCAAP,UAAuBlP,WAAvB,EAA2C;AACvC,SAAKb,CAAL,IAAUa,WAAW,CAACb,CAAtB;AACA,SAAKC,CAAL,IAAUY,WAAW,CAACZ,CAAtB;AACA,SAAK8E,CAAL,IAAUlE,WAAW,CAACkE,CAAtB;AACA,SAAK+K,CAAL,IAAUjP,WAAW,CAACiP,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,+BAAP,UAAgBlP,WAAhB,EAAmD;AAC/C,WAAO,IAAIkP,OAAJ,CAAY,KAAK/P,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,EAA4D,KAAK8E,CAAL,GAASlE,WAAW,CAACkE,CAAjF,EAAoF,KAAK+K,CAAL,GAASjP,WAAW,CAACiP,CAAzG,CAAP;AACH,GAFM;AAGP;;;;;;;;AAMOC,oCAAP,UAAqBlP,WAArB,EAA0DL,MAA1D,EAAyE;AACrEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACAO,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAASlE,WAAW,CAACkE,CAAhC;AACAvE,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAASjP,WAAW,CAACiP,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQOC,uCAAP,UAAwB/P,CAAxB,EAAmCC,CAAnC,EAA8C8E,CAA9C,EAAyD+K,CAAzD,EAAkE;AAC9D,WAAO,IAAIC,OAAJ,CAAY,KAAK/P,CAAL,GAASA,CAArB,EAAwB,KAAKC,CAAL,GAASA,CAAjC,EAAoC,KAAK8E,CAAL,GAASA,CAA7C,EAAgD,KAAK+K,CAAL,GAASA,CAAzD,CAAP;AACH,GAFM;AAGP;;;;;;;AAKOC,6BAAP,UAAclP,WAAd,EAAiD;AAC7C,WAAO,IAAIkP,OAAJ,CAAY,KAAK/P,CAAL,GAASa,WAAW,CAACb,CAAjC,EAAoC,KAAKC,CAAL,GAASY,WAAW,CAACZ,CAAzD,EAA4D,KAAK8E,CAAL,GAASlE,WAAW,CAACkE,CAAjF,EAAoF,KAAK+K,CAAL,GAASjP,WAAW,CAACiP,CAAzG,CAAP;AACH,GAFM;AAGP;;;;;;;;AAMOC,kCAAP,UAAmBlP,WAAnB,EAAwDL,MAAxD,EAAuE;AACnEA,UAAM,CAACR,CAAP,GAAW,KAAKA,CAAL,GAASa,WAAW,CAACb,CAAhC;AACAQ,UAAM,CAACP,CAAP,GAAW,KAAKA,CAAL,GAASY,WAAW,CAACZ,CAAhC;AACAO,UAAM,CAACuE,CAAP,GAAW,KAAKA,CAAL,GAASlE,WAAW,CAACkE,CAAhC;AACAvE,UAAM,CAACsP,CAAP,GAAW,KAAKA,CAAL,GAASjP,WAAW,CAACiP,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOC,oCAAP,UAAqBlP,WAArB,EAAwD;AACpD,WAAO,KAAKC,WAAL,CAAiBD,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOkP,sCAAP,UAAuBvJ,KAAvB,EAAoD;AAChD,QAAIA,KAAK,CAACxG,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASwG,KAAK,CAACxG,CAAf;AACH;;AACD,QAAIwG,KAAK,CAACvG,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASuG,KAAK,CAACvG,CAAf;AACH;;AACD,QAAIuG,KAAK,CAACzB,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASyB,KAAK,CAACzB,CAAf;AACH;;AACD,QAAIyB,KAAK,CAACsJ,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAAStJ,KAAK,CAACsJ,CAAf;AACH;;AACD,WAAO,IAAP;AACH,GAdM;AAeP;;;;;;;AAKOC,sCAAP,UAAuBvJ,KAAvB,EAAoD;AAChD,QAAIA,KAAK,CAACxG,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASwG,KAAK,CAACxG,CAAf;AACH;;AACD,QAAIwG,KAAK,CAACvG,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASuG,KAAK,CAACvG,CAAf;AACH;;AACD,QAAIuG,KAAK,CAACzB,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAASyB,KAAK,CAACzB,CAAf;AACH;;AACD,QAAIyB,KAAK,CAACsJ,CAAN,GAAU,KAAKA,CAAnB,EAAsB;AAClB,WAAKA,CAAL,GAAStJ,KAAK,CAACsJ,CAAf;AACH;;AACD,WAAO,IAAP;AACH,GAdM;AAgBP;;;;;;AAIOC,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY5O,IAAI,CAACC,KAAL,CAAW,KAAKpB,CAAhB,CAAZ,EAAgCmB,IAAI,CAACC,KAAL,CAAW,KAAKnB,CAAhB,CAAhC,EAAoDkB,IAAI,CAACC,KAAL,CAAW,KAAK2D,CAAhB,CAApD,EAAwE5D,IAAI,CAACC,KAAL,CAAW,KAAK0O,CAAhB,CAAxE,CAAP;AACH,GAFM;AAIP;;;;;;AAIOC,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAK/P,CAAL,GAASmB,IAAI,CAACC,KAAL,CAAW,KAAKpB,CAAhB,CAArB,EAAyC,KAAKC,CAAL,GAASkB,IAAI,CAACC,KAAL,CAAW,KAAKnB,CAAhB,CAAlD,EAAsE,KAAK8E,CAAL,GAAS5D,IAAI,CAACC,KAAL,CAAW,KAAK2D,CAAhB,CAA/E,EAAmG,KAAK+K,CAAL,GAAS3O,IAAI,CAACC,KAAL,CAAW,KAAK0O,CAAhB,CAA5G,CAAP;AACH,GAFM,CA1bX,CA8bI;;AACA;;;;;;AAIOC,6BAAP;AACI,WAAO5O,IAAI,CAACK,IAAL,CAAU,KAAKxB,CAAL,GAAS,KAAKA,CAAd,GAAkB,KAAKC,CAAL,GAAS,KAAKA,CAAhC,GAAoC,KAAK8E,CAAL,GAAS,KAAKA,CAAlD,GAAsD,KAAK+K,CAAL,GAAS,KAAKA,CAA9E,CAAP;AACH,GAFM;AAGP;;;;;;AAIOC,oCAAP;AACI,WAAO,KAAK/P,CAAL,GAAS,KAAKA,CAAd,GAAkB,KAAKC,CAAL,GAAS,KAAKA,CAAhC,GAAoC,KAAK8E,CAAL,GAAS,KAAKA,CAAlD,GAAsD,KAAK+K,CAAL,GAAS,KAAKA,CAA3E;AACH,GAFM,CA1cX,CA8cI;;AACA;;;;;;AAIOC,gCAAP;AACI,QAAM3M,GAAG,GAAG,KAAKC,MAAL,EAAZ;;AAEA,QAAID,GAAG,KAAK,CAAZ,EAAe;AACX,aAAO,IAAP;AACH;;AAED,WAAO,KAAKkD,YAAL,CAAkB,MAAMlD,GAAxB,CAAP;AACH,GARM;AAUP;;;;;;AAIO2M,gCAAP;AACI,WAAO,IAAI3K,OAAJ,CAAY,KAAKpF,CAAjB,EAAoB,KAAKC,CAAzB,EAA4B,KAAK8E,CAAjC,CAAP;AACH,GAFM;AAGP;;;;;;AAIOgL,4BAAP;AACI,WAAO,IAAIA,OAAJ,CAAY,KAAK/P,CAAjB,EAAoB,KAAKC,CAAzB,EAA4B,KAAK8E,CAAjC,EAAoC,KAAK+K,CAAzC,CAAP;AACH,GAFM;AAGP;;;;;;;AAKOC,+BAAP,UAAgBpP,MAAhB,EAA8C;AAC1C,SAAKX,CAAL,GAASW,MAAM,CAACX,CAAhB;AACA,SAAKC,CAAL,GAASU,MAAM,CAACV,CAAhB;AACA,SAAK8E,CAAL,GAASpE,MAAM,CAACoE,CAAhB;AACA,SAAK+K,CAAL,GAASnP,MAAM,CAACmP,CAAhB;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQOC,qCAAP,UAAsB/P,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAuD+K,CAAvD,EAAgE;AAC5D,SAAK9P,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAK8E,CAAL,GAASA,CAAT;AACA,SAAK+K,CAAL,GAASA,CAAT;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQOC,0BAAP,UAAW/P,CAAX,EAAsBC,CAAtB,EAAiC8E,CAAjC,EAA4C+K,CAA5C,EAAqD;AACjD,WAAO,KAAKlP,cAAL,CAAoBZ,CAApB,EAAuBC,CAAvB,EAA0B8E,CAA1B,EAA6B+K,CAA7B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOC,6BAAP,UAActL,CAAd,EAAuB;AACnB,SAAKzE,CAAL,GAAS,KAAKC,CAAL,GAAS,KAAK8E,CAAL,GAAS,KAAK+K,CAAL,GAASrL,CAApC;AACA,WAAO,IAAP;AACH,GAHM,CAvhBX,CA4hBI;;AACA;;;;;;;;AAMcsL,sBAAd,UAAwB1P,KAAxB,EAAiEqB,MAAjE,EAAgF;AAC5E,QAAI,CAACA,MAAL,EAAa;AACTA,YAAM,GAAG,CAAT;AACH;;AACD,WAAO,IAAIqO,OAAJ,CAAY1P,KAAK,CAACqB,MAAD,CAAjB,EAA2BrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhC,EAA8CrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAnD,EAAiErB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAtE,CAAP;AACH,GALa;AAMd;;;;;;;;AAMcqO,2BAAd,UAA6B1P,KAA7B,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAqG;AACjGA,UAAM,CAACR,CAAP,GAAWK,KAAK,CAACqB,MAAD,CAAhB;AACAlB,UAAM,CAACP,CAAP,GAAWI,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACAlB,UAAM,CAACuE,CAAP,GAAW1E,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACAlB,UAAM,CAACsP,CAAP,GAAWzP,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACH,GALa;AAMd;;;;;;;;AAMcqO,gCAAd,UAAkC1P,KAAlC,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAqG;AACjGuP,WAAO,CAACxP,cAAR,CAAuBF,KAAvB,EAA8BqB,MAA9B,EAAsClB,MAAtC;AACH,GAFa;AAGd;;;;;;;;;;AAQcuP,4BAAd,UAA8B/P,CAA9B,EAAyCC,CAAzC,EAAoD8E,CAApD,EAA+D+K,CAA/D,EAA0EtP,MAA1E,EAAyF;AACrFA,UAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,UAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,UAAM,CAACuE,CAAP,GAAWA,CAAX;AACAvE,UAAM,CAACsP,CAAP,GAAWA,CAAX;AACH,GALa;AAMd;;;;;;AAIcC,iBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAP;AACH,GAFa;AAGd;;;;;;AAIcA,gBAAd;AACI,WAAO,IAAIA,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAP;AACH,GAFa;AAGd;;;;;;;AAKcA,sBAAd,UAAwB7M,MAAxB,EAAsD;AAClD,QAAM1C,MAAM,GAAGuP,OAAO,CAACpN,IAAR,EAAf;AACAoN,WAAO,CAACtO,cAAR,CAAuByB,MAAvB,EAA+B1C,MAA/B;AACA,WAAOA,MAAP;AACH,GAJa;AAKd;;;;;;;AAKcuP,2BAAd,UAA6B7M,MAA7B,EAA6D1C,MAA7D,EAA4E;AACxEA,UAAM,CAAC0G,QAAP,CAAgBhE,MAAhB;AACA1C,UAAM,CAAC2F,SAAP;AACH,GAHa;AAKd;;;;;;;;AAMc4J,qBAAd,UAAuB/M,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMf,GAAG,GAAGc,IAAI,CAACqK,KAAL,EAAZ;AACAnL,OAAG,CAACgJ,eAAJ,CAAoBjI,KAApB;AACA,WAAOf,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMc6N,qBAAd,UAAuB/M,IAAvB,EAAqDC,KAArD,EAAkF;AAC9E,QAAMd,GAAG,GAAGa,IAAI,CAACqK,KAAL,EAAZ;AACAlL,OAAG,CAACgJ,eAAJ,CAAoBlI,KAApB;AACA,WAAOd,GAAP;AACH,GAJa;AAKd;;;;;;;;AAMc4N,qBAAd,UAAuBpO,MAAvB,EAAuDC,MAAvD,EAAqF;AACjF,WAAOT,IAAI,CAACK,IAAL,CAAUuO,OAAO,CAAC7L,eAAR,CAAwBvC,MAAxB,EAAgCC,MAAhC,CAAV,CAAP;AACH,GAFa;AAGd;;;;;;;;AAMcmO,4BAAd,UAA8BpO,MAA9B,EAA8DC,MAA9D,EAA4F;AACxF,QAAM5B,CAAC,GAAG2B,MAAM,CAAC3B,CAAP,GAAW4B,MAAM,CAAC5B,CAA5B;AACA,QAAMC,CAAC,GAAG0B,MAAM,CAAC1B,CAAP,GAAW2B,MAAM,CAAC3B,CAA5B;AACA,QAAM8E,CAAC,GAAGpD,MAAM,CAACoD,CAAP,GAAWnD,MAAM,CAACmD,CAA5B;AACA,QAAM+K,CAAC,GAAGnO,MAAM,CAACmO,CAAP,GAAWlO,MAAM,CAACkO,CAA5B;AAEA,WAAO9P,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAZ,GAAgB8E,CAAC,GAAGA,CAApB,GAAwB+K,CAAC,GAAGA,CAAnC;AACH,GAPa;AAQd;;;;;;;;AAMcC,mBAAd,UAAqBpO,MAArB,EAAqDC,MAArD,EAAmF;AAC/E,WAAOmO,OAAO,CAAC5L,WAAR,CAAoBxC,MAApB,EAA4BC,MAA5B,EAAoCmO,OAAO,CAACpN,IAAR,EAApC,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOcoN,wBAAd,UAA0BpO,MAA1B,EAA0DC,MAA1D,EAA0FwC,GAA1F,EAAqH;AACjH,WAAOA,GAAG,CAACxD,cAAJ,CAAmB,CAACe,MAAM,CAAC3B,CAAP,GAAW4B,MAAM,CAAC5B,CAAnB,IAAwB,CAA3C,EAA8C,CAAC2B,MAAM,CAAC1B,CAAP,GAAW2B,MAAM,CAAC3B,CAAnB,IAAwB,CAAtE,EAAyE,CAAC0B,MAAM,CAACoD,CAAP,GAAWnD,MAAM,CAACmD,CAAnB,IAAwB,CAAjG,EAAoG,CAACpD,MAAM,CAACmO,CAAP,GAAWlO,MAAM,CAACkO,CAAnB,IAAwB,CAA5H,CAAP;AACH,GAFa;AAId;;;;;;;;;;AAQcC,iCAAd,UAAmC7M,MAAnC,EAAmEI,cAAnE,EAAwG;AACpG,QAAM9C,MAAM,GAAGuP,OAAO,CAACpN,IAAR,EAAf;AACAoN,WAAO,CAACrI,yBAAR,CAAkCxE,MAAlC,EAA0CI,cAA1C,EAA0D9C,MAA1D;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQcuP,sCAAd,UAAwC7M,MAAxC,EAAwEI,cAAxE,EAA+G9C,MAA/G,EAA8H;AAC1HuP,WAAO,CAACrF,mCAAR,CAA4CxH,MAAM,CAAC8B,EAAnD,EAAuD9B,MAAM,CAAC+B,EAA9D,EAAkE/B,MAAM,CAACgC,EAAzE,EAA6E5B,cAA7E,EAA6F9C,MAA7F;AACH,GAFa;AAId;;;;;;;;;;;;AAUcuP,gDAAd,UAAkD/P,CAAlD,EAA6DC,CAA7D,EAAwE8E,CAAxE,EAAmFzB,cAAnF,EAA0H9C,MAA1H,EAAyI;AACrI,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACA,QAAMkH,EAAE,GAAG3K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAA3B,GAAiCA,CAAC,CAAC,EAAD,CAA7C;AACA,QAAMmH,EAAE,GAAG5K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAA3B,GAAiCA,CAAC,CAAC,EAAD,CAA7C;AACA,QAAMoH,EAAE,GAAG7K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAA3B,GAAkCA,CAAC,CAAC,EAAD,CAA9C;AACA,QAAMqH,EAAE,GAAG9K,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAA3B,GAAkCA,CAAC,CAAC,EAAD,CAA9C;AAEAjD,UAAM,CAACR,CAAP,GAAW2K,EAAX;AACAnK,UAAM,CAACP,CAAP,GAAW2K,EAAX;AACApK,UAAM,CAACuE,CAAP,GAAW8F,EAAX;AACArK,UAAM,CAACsP,CAAP,GAAWhF,EAAX;AACH,GAXa;AAad;;;;;;;;;AAOciF,4BAAd,UAA8B7M,MAA9B,EAA8DI,cAA9D,EAAmG;AAC/F,QAAM9C,MAAM,GAAGuP,OAAO,CAACpN,IAAR,EAAf;AACAoN,WAAO,CAAChF,oBAAR,CAA6B7H,MAA7B,EAAqCI,cAArC,EAAqD9C,MAArD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOcuP,iCAAd,UAAmC7M,MAAnC,EAAmEI,cAAnE,EAA0G9C,MAA1G,EAAyH;AACrH,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACA,QAAMzD,CAAC,GAAGkD,MAAM,CAAClD,CAAP,GAAWyD,CAAC,CAAC,CAAD,CAAZ,GAAkBP,MAAM,CAACjD,CAAP,GAAWwD,CAAC,CAAC,CAAD,CAA9B,GAAoCP,MAAM,CAAC6B,CAAP,GAAWtB,CAAC,CAAC,CAAD,CAA1D;AACA,QAAMxD,CAAC,GAAGiD,MAAM,CAAClD,CAAP,GAAWyD,CAAC,CAAC,CAAD,CAAZ,GAAkBP,MAAM,CAACjD,CAAP,GAAWwD,CAAC,CAAC,CAAD,CAA9B,GAAoCP,MAAM,CAAC6B,CAAP,GAAWtB,CAAC,CAAC,CAAD,CAA1D;AACA,QAAMsB,CAAC,GAAG7B,MAAM,CAAClD,CAAP,GAAWyD,CAAC,CAAC,CAAD,CAAZ,GAAkBP,MAAM,CAACjD,CAAP,GAAWwD,CAAC,CAAC,CAAD,CAA9B,GAAoCP,MAAM,CAAC6B,CAAP,GAAWtB,CAAC,CAAC,EAAD,CAA1D;AACAjD,UAAM,CAACR,CAAP,GAAWA,CAAX;AACAQ,UAAM,CAACP,CAAP,GAAWA,CAAX;AACAO,UAAM,CAACuE,CAAP,GAAWA,CAAX;AACAvE,UAAM,CAACsP,CAAP,GAAW5M,MAAM,CAAC4M,CAAlB;AACH,GATa;AAWd;;;;;;;;;;;;AAUcC,2CAAd,UAA6C/P,CAA7C,EAAwDC,CAAxD,EAAmE8E,CAAnE,EAA8E+K,CAA9E,EAAyFxM,cAAzF,EAAgI9C,MAAhI,EAA+I;AAC3I,QAAMiD,CAAC,GAAGH,cAAc,CAACG,CAAzB;AACAjD,UAAM,CAACR,CAAP,GAAWA,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAAtC;AACAjD,UAAM,CAACP,CAAP,GAAWD,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,CAAD,CAAtC;AACAjD,UAAM,CAACuE,CAAP,GAAW/E,CAAC,GAAGyD,CAAC,CAAC,CAAD,CAAL,GAAWxD,CAAC,GAAGwD,CAAC,CAAC,CAAD,CAAhB,GAAsBsB,CAAC,GAAGtB,CAAC,CAAC,EAAD,CAAtC;AACAjD,UAAM,CAACsP,CAAP,GAAWA,CAAX;AACH,GANa;AAQd;;;;;;;;AAMcC,wBAAd,UAA0BpP,MAA1B,EAA2CmP,CAA3C,EAAwD;AAAb;AAAAA;AAAa;;AACpD,WAAO,IAAIC,OAAJ,CAAYpP,MAAM,CAACqE,EAAnB,EAAuBrE,MAAM,CAACsE,EAA9B,EAAkCtE,MAAM,CAACuE,EAAzC,EAA6C4K,CAA7C,CAAP;AACH,GAFa;;AAGlB;AAAC,CA5xBD;;;AA8xBA;;;;;;AAKA;AAAA;AAAA;AAuDI;;;;;;;AAOA,sBAAY9P,CAAZ,EAA6BC,CAA7B,EAA8C8E,CAA9C,EAA+D+K,CAA/D,EAA8E;AAAlE;AAAA9P;AAAe;;AAAE;AAAAC;AAAe;;AAAE;AAAA8E;AAAe;;AAAE;AAAA+K;AAAe;AAjD9E;;;AACO,oBAAW,IAAX;AAiDH,SAAK9K,EAAL,GAAUhF,CAAV;AACA,SAAKiF,EAAL,GAAUhF,CAAV;AACA,SAAKiF,EAAL,GAAUH,CAAV;AACA,SAAKkL,EAAL,GAAUH,CAAV;AACH;;AAlDD3K,wBAAWG,oBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKN,EAAZ;AACH,KAFW;SAIZ,aAAapF,KAAb,EAA0B;AACtB,WAAKoF,EAAL,GAAUpF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUAF,wBAAWG,oBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKL,EAAZ;AACH,KAFW;SAIZ,aAAarF,KAAb,EAA0B;AACtB,WAAKqF,EAAL,GAAUrF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUAF,wBAAWG,oBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAKJ,EAAZ;AACH,KAFW;SAIZ,aAAatF,KAAb,EAA0B;AACtB,WAAKsF,EAAL,GAAUtF,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUAF,wBAAWG,oBAAX,EAAW,GAAX,EAAY;AADZ;SACA;AACI,aAAO,KAAK2K,EAAZ;AACH,KAFW;SAIZ,aAAarQ,KAAb,EAA0B;AACtB,WAAKqQ,EAAL,GAAUrQ,KAAV;AACA,WAAKyF,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAsBA;;;;;AAIOC,kCAAP;AACI,WAAO,cAAO,KAAKN,EAAZ,EAAc,MAAd,EAAc7E,MAAd,CAAqB,KAAK8E,EAA1B,EAA4B,MAA5B,EAA4B9E,MAA5B,CAAmC,KAAK+E,EAAxC,EAA0C,MAA1C,EAA0C/E,MAA1C,CAAiD,KAAK8P,EAAtD,EAAwD,GAAxD,CAAP;AACH,GAFM;AAIP;;;;;;AAIO3K,sCAAP;AACI,WAAO,YAAP;AACH,GAFM;AAIP;;;;;;AAIOA,qCAAP;AACI,QAAMtF,CAAC,GAAGL,aAAa,CAAC,KAAKqF,EAAN,CAAvB;;AACA,QAAM/E,CAAC,GAAGN,aAAa,CAAC,KAAKsF,EAAN,CAAvB;;AACA,QAAMF,CAAC,GAAGpF,aAAa,CAAC,KAAKuF,EAAN,CAAvB;;AACA,QAAM4K,CAAC,GAAGnQ,aAAa,CAAC,KAAKsQ,EAAN,CAAvB;;AAEA,QAAI7P,IAAI,GAAGJ,CAAX;AACAI,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAeH,CAAtB;AACAG,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAe2E,CAAtB;AACA3E,QAAI,GAAIA,IAAI,GAAG,GAAR,GAAe0P,CAAtB;AACA,WAAO1P,IAAP;AACH,GAXM;AAaP;;;;;;AAIOkF,iCAAP;AACI,WAAO,CAAC,KAAKN,EAAN,EAAU,KAAKC,EAAf,EAAmB,KAAKC,EAAxB,EAA4B,KAAK+K,EAAjC,CAAP;AACH,GAFM;AAGP;;;;;;;AAKO3K,gCAAP,UAAc4K,eAAd,EAAwD;AACpD,WAAOA,eAAe,IAAI,KAAKlL,EAAL,KAAYkL,eAAe,CAAClL,EAA/C,IAAqD,KAAKC,EAAL,KAAYiL,eAAe,CAACjL,EAAjF,IAAuF,KAAKC,EAAL,KAAYgL,eAAe,CAAChL,EAAnH,IAAyH,KAAK+K,EAAL,KAAYC,eAAe,CAACD,EAA5J;AACH,GAFM;AAIP;;;;;;;;AAMO3K,2CAAP,UAAyB4K,eAAzB,EAAqEjP,OAArE,EAA8F;AAAzB;AAAAA;AAAyB;;AAC1F,WACIiP,eAAe,IACf7Q,MAAM,CAAC6B,aAAP,CAAqB,KAAK8D,EAA1B,EAA8BkL,eAAe,CAAClL,EAA9C,EAAkD/D,OAAlD,CADA,IAEA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAK+D,EAA1B,EAA8BiL,eAAe,CAACjL,EAA9C,EAAkDhE,OAAlD,CAFA,IAGA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAKgE,EAA1B,EAA8BgL,eAAe,CAAChL,EAA9C,EAAkDjE,OAAlD,CAHA,IAIA5B,MAAM,CAAC6B,aAAP,CAAqB,KAAK+O,EAA1B,EAA8BC,eAAe,CAACD,EAA9C,EAAkDhP,OAAlD,CALJ;AAOH,GARM;AAUP;;;;;;AAIOqE,+BAAP;AACI,WAAO,IAAIA,UAAJ,CAAe,KAAKN,EAApB,EAAwB,KAAKC,EAA7B,EAAiC,KAAKC,EAAtC,EAA0C,KAAK+K,EAA/C,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO3K,kCAAP,UAAgBkB,KAAhB,EAAgD;AAC5C,SAAKxG,CAAL,GAASwG,KAAK,CAACxB,EAAf;AACA,SAAK/E,CAAL,GAASuG,KAAK,CAACvB,EAAf;AACA,SAAKF,CAAL,GAASyB,KAAK,CAACtB,EAAf;AACA,SAAK4K,CAAL,GAAStJ,KAAK,CAACyJ,EAAf;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;;AAQO3K,wCAAP,UAAsBtF,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAuD+K,CAAvD,EAAgE;AAC5D,SAAK9P,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAK8E,CAAL,GAASA,CAAT;AACA,SAAK+K,CAAL,GAASA,CAAT;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;;AAQOxK,6BAAP,UAAWtF,CAAX,EAAsBC,CAAtB,EAAiC8E,CAAjC,EAA4C+K,CAA5C,EAAqD;AACjD,WAAO,KAAKlP,cAAL,CAAoBZ,CAApB,EAAuBC,CAAvB,EAA0B8E,CAA1B,EAA6B+K,CAA7B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOxK,6BAAP,UAAWkB,KAAX,EAA2C;AACvC,WAAO,IAAIlB,UAAJ,CAAe,KAAKN,EAAL,GAAUwB,KAAK,CAACxB,EAA/B,EAAmC,KAAKC,EAAL,GAAUuB,KAAK,CAACvB,EAAnD,EAAuD,KAAKC,EAAL,GAAUsB,KAAK,CAACtB,EAAvE,EAA2E,KAAK+K,EAAL,GAAUzJ,KAAK,CAACyJ,EAA3F,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO3K,oCAAP,UAAkBkB,KAAlB,EAAkD;AAC9C,SAAKxB,EAAL,IAAWwB,KAAK,CAACxB,EAAjB;AACA,SAAKC,EAAL,IAAWuB,KAAK,CAACvB,EAAjB;AACA,SAAKC,EAAL,IAAWsB,KAAK,CAACtB,EAAjB;AACA,SAAK+K,EAAL,IAAWzJ,KAAK,CAACyJ,EAAjB;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;AAKO3K,kCAAP,UAAgBkB,KAAhB,EAAiC;AAC7B,WAAO,IAAIlB,UAAJ,CAAe,KAAKN,EAAL,GAAUwB,KAAK,CAACxB,EAA/B,EAAmC,KAAKC,EAAL,GAAUuB,KAAK,CAACvB,EAAnD,EAAuD,KAAKC,EAAL,GAAUsB,KAAK,CAACtB,EAAvE,EAA2E,KAAK+K,EAAL,GAAUzJ,KAAK,CAACyJ,EAA3F,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO3K,+BAAP,UAAa1F,KAAb,EAA0B;AACtB,WAAO,IAAI0F,UAAJ,CAAe,KAAKN,EAAL,GAAUpF,KAAzB,EAAgC,KAAKqF,EAAL,GAAUrF,KAA1C,EAAiD,KAAKsF,EAAL,GAAUtF,KAA3D,EAAkE,KAAKqQ,EAAL,GAAUrQ,KAA5E,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO0F,oCAAP,UAAkBvE,KAAlB,EAAiCP,MAAjC,EAAmD;AAC/CA,UAAM,CAACR,CAAP,GAAW,KAAKgF,EAAL,GAAUjE,KAArB;AACAP,UAAM,CAACP,CAAP,GAAW,KAAKgF,EAAL,GAAUlE,KAArB;AACAP,UAAM,CAACuE,CAAP,GAAW,KAAKG,EAAL,GAAUnE,KAArB;AACAP,UAAM,CAACsP,CAAP,GAAW,KAAKG,EAAL,GAAUlP,KAArB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOuE,sCAAP,UAAoB1F,KAApB,EAAiC;AAC7B,SAAKI,CAAL,IAAUJ,KAAV;AACA,SAAKK,CAAL,IAAUL,KAAV;AACA,SAAKmF,CAAL,IAAUnF,KAAV;AACA,SAAKkQ,CAAL,IAAUlQ,KAAV;AAEA,WAAO,IAAP;AACH,GAPM;AASP;;;;;;;;AAMO0F,0CAAP,UAAwBvE,KAAxB,EAAuCP,MAAvC,EAAyD;AACrDA,UAAM,CAACR,CAAP,IAAY,KAAKgF,EAAL,GAAUjE,KAAtB;AACAP,UAAM,CAACP,CAAP,IAAY,KAAKgF,EAAL,GAAUlE,KAAtB;AACAP,UAAM,CAACuE,CAAP,IAAY,KAAKG,EAAL,GAAUnE,KAAtB;AACAP,UAAM,CAACsP,CAAP,IAAY,KAAKG,EAAL,GAAUlP,KAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOuE,kCAAP,UAAgB6K,EAAhB,EAA6C;AACzC,QAAM3P,MAAM,GAAG,IAAI8E,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,GAAxB,CAAf;AACA,SAAK4G,aAAL,CAAmBiE,EAAnB,EAAuB3P,MAAvB;AACA,WAAOA,MAAP;AACH,GAJM;AAKP;;;;;;;;AAMO8E,uCAAP,UAAqB6K,EAArB,EAAoD3P,MAApD,EAAsE;AAClE,QAAMR,CAAC,GAAG,KAAKgF,EAAL,GAAUmL,EAAE,CAACF,EAAb,GAAkB,KAAKhL,EAAL,GAAUkL,EAAE,CAACjL,EAA/B,GAAoC,KAAKA,EAAL,GAAUiL,EAAE,CAAClL,EAAjD,GAAsD,KAAKgL,EAAL,GAAUE,EAAE,CAACnL,EAA7E;AACA,QAAM/E,CAAC,GAAG,CAAC,KAAK+E,EAAN,GAAWmL,EAAE,CAACjL,EAAd,GAAmB,KAAKD,EAAL,GAAUkL,EAAE,CAACF,EAAhC,GAAqC,KAAK/K,EAAL,GAAUiL,EAAE,CAACnL,EAAlD,GAAuD,KAAKiL,EAAL,GAAUE,EAAE,CAAClL,EAA9E;AACA,QAAMF,CAAC,GAAG,KAAKC,EAAL,GAAUmL,EAAE,CAAClL,EAAb,GAAkB,KAAKA,EAAL,GAAUkL,EAAE,CAACnL,EAA/B,GAAoC,KAAKE,EAAL,GAAUiL,EAAE,CAACF,EAAjD,GAAsD,KAAKA,EAAL,GAAUE,EAAE,CAACjL,EAA7E;AACA,QAAM4K,CAAC,GAAG,CAAC,KAAK9K,EAAN,GAAWmL,EAAE,CAACnL,EAAd,GAAmB,KAAKC,EAAL,GAAUkL,EAAE,CAAClL,EAAhC,GAAqC,KAAKC,EAAL,GAAUiL,EAAE,CAACjL,EAAlD,GAAuD,KAAK+K,EAAL,GAAUE,EAAE,CAACF,EAA9E;AACAzP,UAAM,CAACI,cAAP,CAAsBZ,CAAtB,EAAyBC,CAAzB,EAA4B8E,CAA5B,EAA+B+K,CAA/B;AACA,WAAO,IAAP;AACH,GAPM;AASP;;;;;;;AAKOxK,yCAAP,UAAuB6K,EAAvB,EAAoD;AAChD,SAAKjE,aAAL,CAAmBiE,EAAnB,EAAuB,IAAvB;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKO7K,wCAAP,UAAsBlB,GAAtB,EAAqC;AACjCA,OAAG,CAACxD,cAAJ,CAAmB,CAAC,KAAKoE,EAAzB,EAA6B,CAAC,KAAKC,EAAnC,EAAuC,CAAC,KAAKC,EAA7C,EAAiD,KAAK+K,EAAtD;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIO3K,0CAAP;AACI,SAAKtF,CAAL,IAAU,CAAC,CAAX;AACA,SAAKC,CAAL,IAAU,CAAC,CAAX;AACA,SAAK8E,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;AAIOO,mCAAP;AACI,QAAM9E,MAAM,GAAG,IAAI8E,UAAJ,CAAe,CAAC,KAAKN,EAArB,EAAyB,CAAC,KAAKC,EAA/B,EAAmC,CAAC,KAAKC,EAAzC,EAA6C,KAAK+K,EAAlD,CAAf;AACA,WAAOzP,MAAP;AACH,GAHM;AAKP;;;;;;AAIO8E,gCAAP;AACI,WAAOnE,IAAI,CAACK,IAAL,CAAU,KAAKwD,EAAL,GAAU,KAAKA,EAAf,GAAoB,KAAKC,EAAL,GAAU,KAAKA,EAAnC,GAAwC,KAAKC,EAAL,GAAU,KAAKA,EAAvD,GAA4D,KAAK+K,EAAL,GAAU,KAAKA,EAArF,CAAP;AACH,GAFM;AAIP;;;;;;AAIO3K,mCAAP;AACI,QAAMlC,GAAG,GAAG,KAAKC,MAAL,EAAZ;;AAEA,QAAID,GAAG,KAAK,CAAZ,EAAe;AACX,aAAO,IAAP;AACH;;AAED,QAAMgN,GAAG,GAAG,MAAMhN,GAAlB;AACA,SAAKpD,CAAL,IAAUoQ,GAAV;AACA,SAAKnQ,CAAL,IAAUmQ,GAAV;AACA,SAAKrL,CAAL,IAAUqL,GAAV;AACA,SAAKN,CAAL,IAAUM,GAAV;AACA,WAAO,IAAP;AACH,GAbM;AAeP;;;;;;;AAKO9K,uCAAP;AACI,QAAM9E,MAAM,GAAG4E,OAAO,CAACzC,IAAR,EAAf;AACA,SAAK8M,kBAAL,CAAwBjP,MAAxB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO8E,4CAAP,UAA0B9E,MAA1B,EAAyC;AACrC,QAAM6P,EAAE,GAAG,KAAKnL,EAAhB;AACA,QAAMoL,EAAE,GAAG,KAAKtL,EAAhB;AACA,QAAMuL,EAAE,GAAG,KAAKtL,EAAhB;AACA,QAAMuL,EAAE,GAAG,KAAKP,EAAhB;AAEA,QAAMQ,GAAG,GAAGD,EAAE,GAAGA,EAAjB;AACA,QAAME,GAAG,GAAGL,EAAE,GAAGA,EAAjB;AACA,QAAMM,GAAG,GAAGL,EAAE,GAAGA,EAAjB;AACA,QAAMM,GAAG,GAAGL,EAAE,GAAGA,EAAjB;AAEA,QAAMM,MAAM,GAAGN,EAAE,GAAGF,EAAL,GAAUC,EAAE,GAAGE,EAA9B;AACA,QAAMM,KAAK,GAAG,SAAd;;AAEA,QAAID,MAAM,GAAG,CAACC,KAAd,EAAqB;AACjBtQ,YAAM,CAACP,CAAP,GAAW,IAAIkB,IAAI,CAAC6H,KAAL,CAAWuH,EAAX,EAAeC,EAAf,CAAf;AACAhQ,YAAM,CAACR,CAAP,GAAWmB,IAAI,CAAC0H,EAAL,GAAU,CAArB;AACArI,YAAM,CAACuE,CAAP,GAAW,CAAX;AACH,KAJD,MAIO,IAAI8L,MAAM,GAAGC,KAAb,EAAoB;AACvBtQ,YAAM,CAACP,CAAP,GAAW,IAAIkB,IAAI,CAAC6H,KAAL,CAAWuH,EAAX,EAAeC,EAAf,CAAf;AACAhQ,YAAM,CAACR,CAAP,GAAW,CAACmB,IAAI,CAAC0H,EAAN,GAAW,CAAtB;AACArI,YAAM,CAACuE,CAAP,GAAW,CAAX;AACH,KAJM,MAIA;AACHvE,YAAM,CAACuE,CAAP,GAAW5D,IAAI,CAAC6H,KAAL,CAAW,OAAOsH,EAAE,GAAGC,EAAL,GAAUF,EAAE,GAAGG,EAAtB,CAAX,EAAsC,CAACE,GAAD,GAAOC,GAAP,GAAaC,GAAb,GAAmBH,GAAzD,CAAX;AACAjQ,YAAM,CAACR,CAAP,GAAWmB,IAAI,CAAC4P,IAAL,CAAU,CAAC,GAAD,IAAQV,EAAE,GAAGE,EAAL,GAAUD,EAAE,GAAGE,EAAvB,CAAV,CAAX;AACAhQ,YAAM,CAACP,CAAP,GAAWkB,IAAI,CAAC6H,KAAL,CAAW,OAAOqH,EAAE,GAAGC,EAAL,GAAUC,EAAE,GAAGC,EAAtB,CAAX,EAAsCE,GAAG,GAAGC,GAAN,GAAYC,GAAZ,GAAkBH,GAAxD,CAAX;AACH;;AAED,WAAO,IAAP;AACH,GA7BM;AA+BP;;;;;;;AAKOnL,0CAAP,UAAwB9E,MAAxB,EAAsC;AAClCiH,UAAM,CAACuJ,mBAAP,CAA2B,IAA3B,EAAiCxQ,MAAjC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKO8E,4CAAP,UAA0B2G,MAA1B,EAAuD;AACnD3G,cAAU,CAAC2L,uBAAX,CAAmChF,MAAnC,EAA2C,IAA3C;AACA,WAAO,IAAP;AACH,GAHM,CAnaX,CAwaI;;AAEA;;;;;;;AAKc3G,kCAAd,UAAiC2G,MAAjC,EAA8D;AAC1D,QAAMzL,MAAM,GAAG,IAAI8E,UAAJ,EAAf;AACAA,cAAU,CAAC2L,uBAAX,CAAmChF,MAAnC,EAA2CzL,MAA3C;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc8E,uCAAd,UAAsC2G,MAAtC,EAAqEzL,MAArE,EAAuF;AACnF,QAAM0Q,IAAI,GAAGjF,MAAM,CAACxI,CAApB;AACA,QAAM0N,GAAG,GAAGD,IAAI,CAAC,CAAD,CAAhB;AAAA,QACIE,GAAG,GAAGF,IAAI,CAAC,CAAD,CADd;AAAA,QAEIG,GAAG,GAAGH,IAAI,CAAC,CAAD,CAFd;AAGA,QAAMI,GAAG,GAAGJ,IAAI,CAAC,CAAD,CAAhB;AAAA,QACIK,GAAG,GAAGL,IAAI,CAAC,CAAD,CADd;AAAA,QAEIM,GAAG,GAAGN,IAAI,CAAC,CAAD,CAFd;AAGA,QAAMO,GAAG,GAAGP,IAAI,CAAC,CAAD,CAAhB;AAAA,QACIQ,GAAG,GAAGR,IAAI,CAAC,CAAD,CADd;AAAA,QAEIS,GAAG,GAAGT,IAAI,CAAC,EAAD,CAFd;AAGA,QAAMU,KAAK,GAAGT,GAAG,GAAGI,GAAN,GAAYI,GAA1B;AACA,QAAI3N,CAAJ;;AAEA,QAAI4N,KAAK,GAAG,CAAZ,EAAe;AACX5N,OAAC,GAAG,MAAM7C,IAAI,CAACK,IAAL,CAAUoQ,KAAK,GAAG,GAAlB,CAAV;AAEApR,YAAM,CAACsP,CAAP,GAAW,OAAO9L,CAAlB;AACAxD,YAAM,CAACR,CAAP,GAAW,CAAC0R,GAAG,GAAGF,GAAP,IAAcxN,CAAzB;AACAxD,YAAM,CAACP,CAAP,GAAW,CAACoR,GAAG,GAAGI,GAAP,IAAczN,CAAzB;AACAxD,YAAM,CAACuE,CAAP,GAAW,CAACuM,GAAG,GAAGF,GAAP,IAAcpN,CAAzB;AACH,KAPD,MAOO,IAAImN,GAAG,GAAGI,GAAN,IAAaJ,GAAG,GAAGQ,GAAvB,EAA4B;AAC/B3N,OAAC,GAAG,MAAM7C,IAAI,CAACK,IAAL,CAAU,MAAM2P,GAAN,GAAYI,GAAZ,GAAkBI,GAA5B,CAAV;AAEAnR,YAAM,CAACsP,CAAP,GAAW,CAAC4B,GAAG,GAAGF,GAAP,IAAcxN,CAAzB;AACAxD,YAAM,CAACR,CAAP,GAAW,OAAOgE,CAAlB;AACAxD,YAAM,CAACP,CAAP,GAAW,CAACmR,GAAG,GAAGE,GAAP,IAActN,CAAzB;AACAxD,YAAM,CAACuE,CAAP,GAAW,CAACsM,GAAG,GAAGI,GAAP,IAAczN,CAAzB;AACH,KAPM,MAOA,IAAIuN,GAAG,GAAGI,GAAV,EAAe;AAClB3N,OAAC,GAAG,MAAM7C,IAAI,CAACK,IAAL,CAAU,MAAM+P,GAAN,GAAYJ,GAAZ,GAAkBQ,GAA5B,CAAV;AAEAnR,YAAM,CAACsP,CAAP,GAAW,CAACuB,GAAG,GAAGI,GAAP,IAAczN,CAAzB;AACAxD,YAAM,CAACR,CAAP,GAAW,CAACoR,GAAG,GAAGE,GAAP,IAActN,CAAzB;AACAxD,YAAM,CAACP,CAAP,GAAW,OAAO+D,CAAlB;AACAxD,YAAM,CAACuE,CAAP,GAAW,CAACyM,GAAG,GAAGE,GAAP,IAAc1N,CAAzB;AACH,KAPM,MAOA;AACHA,OAAC,GAAG,MAAM7C,IAAI,CAACK,IAAL,CAAU,MAAMmQ,GAAN,GAAYR,GAAZ,GAAkBI,GAA5B,CAAV;AAEA/Q,YAAM,CAACsP,CAAP,GAAW,CAACwB,GAAG,GAAGF,GAAP,IAAcpN,CAAzB;AACAxD,YAAM,CAACR,CAAP,GAAW,CAACqR,GAAG,GAAGI,GAAP,IAAczN,CAAzB;AACAxD,YAAM,CAACP,CAAP,GAAW,CAACuR,GAAG,GAAGE,GAAP,IAAc1N,CAAzB;AACAxD,YAAM,CAACuE,CAAP,GAAW,OAAOf,CAAlB;AACH;AACJ,GA3Ca;AA6Cd;;;;;;;;AAMcsB,mBAAd,UAAkBtC,IAAlB,EAAmDC,KAAnD,EAAmF;AAC/E,WAAOD,IAAI,CAACgC,EAAL,GAAU/B,KAAK,CAAC+B,EAAhB,GAAqBhC,IAAI,CAACiC,EAAL,GAAUhC,KAAK,CAACgC,EAArC,GAA0CjC,IAAI,CAACkC,EAAL,GAAUjC,KAAK,CAACiC,EAA1D,GAA+DlC,IAAI,CAACiN,EAAL,GAAUhN,KAAK,CAACgN,EAAtF;AACH,GAFa;AAId;;;;;;;;AAMc3K,wBAAd,UAAuBuM,KAAvB,EAAyDC,KAAzD,EAAyF;AACrF,QAAMrJ,GAAG,GAAGnD,UAAU,CAACX,GAAX,CAAekN,KAAf,EAAsBC,KAAtB,CAAZ;AAEA,WAAOrJ,GAAG,IAAI,CAAd;AACH,GAJa;AAMd;;;;;;;;;;;AAScnD,2BAAd,UAA0B3E,MAA1B,EAA8CmJ,IAA9C,EAAgEC,SAAhE,EAAmFC,QAAnF,EAAqGxJ,MAArG,EAAuH;AACnH,QAAI0I,KAAK,GAAGc,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqBD,SAAS,GAAGC,QAA7C;AACAd,SAAK,GAAG7J,MAAM,CAAC8J,KAAP,CAAaD,KAAb,EAAoB,CAApB,EAAuB,CAAvB,CAAR;AAEA5D,cAAU,CAAC2E,UAAX,CAAsBtJ,MAAtB,EAA8BmJ,IAA9B,EAAoCZ,KAApC,EAA2C1I,MAA3C;AACH,GALa;AAOd;;;;;;AAIc8E,oBAAd;AACI,WAAO,IAAIA,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAP;AACH,GAFa;AAId;;;;;;;AAKcA,uBAAd,UAAsByM,CAAtB,EAAkD;AAC9C,WAAO,IAAIzM,UAAJ,CAAe,CAACyM,CAAC,CAAC/M,EAAlB,EAAsB,CAAC+M,CAAC,CAAC9M,EAAzB,EAA6B,CAAC8M,CAAC,CAAC7M,EAAhC,EAAoC6M,CAAC,CAAC9B,EAAtC,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc3K,4BAAd,UAA2ByM,CAA3B,EAA0CvR,MAA1C,EAA4D;AACxDA,UAAM,CAACwR,GAAP,CAAW,CAACD,CAAC,CAAC/M,EAAd,EAAkB,CAAC+M,CAAC,CAAC9M,EAArB,EAAyB,CAAC8M,CAAC,CAAC7M,EAA5B,EAAgC6M,CAAC,CAAC9B,EAAlC;AACA,WAAOzP,MAAP;AACH,GAHa;AAKd;;;;;;AAIc8E,wBAAd;AACI,WAAO,IAAIA,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAP;AACH,GAFa;AAId;;;;;;;AAKcA,0BAAd,UAAyBiC,UAAzB,EAA8D;AAC1D,WAAOA,UAAU,IAAIA,UAAU,CAACvC,EAAX,KAAkB,CAAhC,IAAqCuC,UAAU,CAACtC,EAAX,KAAkB,CAAvD,IAA4DsC,UAAU,CAACrC,EAAX,KAAkB,CAA9E,IAAmFqC,UAAU,CAAC0I,EAAX,KAAkB,CAA5G;AACH,GAFa;AAId;;;;;;;;AAMc3K,4BAAd,UAA2B6C,IAA3B,EAAyD9G,KAAzD,EAAsE;AAClE,WAAOiE,UAAU,CAAC2M,iBAAX,CAA6B9J,IAA7B,EAAmC9G,KAAnC,EAA0C,IAAIiE,UAAJ,EAA1C,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOcA,iCAAd,UAAgC6C,IAAhC,EAA8D9G,KAA9D,EAA6Eb,MAA7E,EAA+F;AAC3F,QAAMe,GAAG,GAAGJ,IAAI,CAACI,GAAL,CAASF,KAAK,GAAG,CAAjB,CAAZ;AACA8G,QAAI,CAAChC,SAAL;AACA3F,UAAM,CAACsP,CAAP,GAAW3O,IAAI,CAACG,GAAL,CAASD,KAAK,GAAG,CAAjB,CAAX;AACAb,UAAM,CAACR,CAAP,GAAWmI,IAAI,CAACnD,EAAL,GAAUzD,GAArB;AACAf,UAAM,CAACP,CAAP,GAAWkI,IAAI,CAAClD,EAAL,GAAU1D,GAArB;AACAf,UAAM,CAACuE,CAAP,GAAWoD,IAAI,CAACjD,EAAL,GAAU3D,GAArB;AACA,WAAOf,MAAP;AACH,GARa;AAUd;;;;;;;;AAMc8E,yBAAd,UAAwBjF,KAAxB,EAAiEqB,MAAjE,EAAgF;AAC5E,QAAI,CAACA,MAAL,EAAa;AACTA,YAAM,GAAG,CAAT;AACH;;AACD,WAAO,IAAI4D,UAAJ,CAAejF,KAAK,CAACqB,MAAD,CAApB,EAA8BrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAnC,EAAiDrB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAtD,EAAoErB,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAzE,CAAP;AACH,GALa;AAOd;;;;;;;;AAMc4D,8BAAd,UAA6BjF,KAA7B,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAwG;AACpGA,UAAM,CAACR,CAAP,GAAWK,KAAK,CAACqB,MAAD,CAAhB;AACAlB,UAAM,CAACP,CAAP,GAAWI,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACAlB,UAAM,CAACuE,CAAP,GAAW1E,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACAlB,UAAM,CAACsP,CAAP,GAAWzP,KAAK,CAACqB,MAAM,GAAG,CAAV,CAAhB;AACH,GALa;AAOd;;;;;;;;;AAOc4D,+BAAd,UAA8BtF,CAA9B,EAAyCC,CAAzC,EAAoD8E,CAApD,EAA6D;AACzD,QAAMgN,CAAC,GAAG,IAAIzM,UAAJ,EAAV;AACAA,cAAU,CAAC4M,yBAAX,CAAqCjS,CAArC,EAAwCD,CAAxC,EAA2C+E,CAA3C,EAA8CgN,CAA9C;AACA,WAAOA,CAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQczM,oCAAd,UAAmCtF,CAAnC,EAA8CC,CAA9C,EAAyD8E,CAAzD,EAAoEvE,MAApE,EAAsF;AAClF8E,cAAU,CAAC4M,yBAAX,CAAqCjS,CAArC,EAAwCD,CAAxC,EAA2C+E,CAA3C,EAA8CvE,MAA9C;AACA,WAAOA,MAAP;AACH,GAHa;AAKd;;;;;;;AAKc8E,+BAAd,UAA8B6M,GAA9B,EAAyD;AACrD,QAAMJ,CAAC,GAAG,IAAIzM,UAAJ,EAAV;AACAA,cAAU,CAAC4M,yBAAX,CAAqCC,GAAG,CAAClN,EAAzC,EAA6CkN,GAAG,CAACnN,EAAjD,EAAqDmN,GAAG,CAACjN,EAAzD,EAA6D6M,CAA7D;AACA,WAAOA,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMczM,oCAAd,UAAmC6M,GAAnC,EAAgE3R,MAAhE,EAAkF;AAC9E8E,cAAU,CAAC4M,yBAAX,CAAqCC,GAAG,CAAClN,EAAzC,EAA6CkN,GAAG,CAACnN,EAAjD,EAAqDmN,GAAG,CAACjN,EAAzD,EAA6D1E,MAA7D;AACA,WAAOA,MAAP;AACH,GAHa;AAKd;;;;;;;;;AAOc8E,oCAAd,UAAmC8M,OAAnC,EAAoEC,KAApE,EAAmG7R,MAAnG,EAAqH;AACjH,QAAM+C,CAAC,GAAG6B,OAAO,CAACT,GAAR,CAAYyN,OAAZ,EAAqBC,KAArB,IAA8B,CAAxC;;AAEA,QAAI9O,CAAC,GAAGjE,OAAR,EAAiB;AACb,UAAI6B,IAAI,CAACyF,GAAL,CAASwL,OAAO,CAACpS,CAAjB,IAAsBmB,IAAI,CAACyF,GAAL,CAASwL,OAAO,CAACrN,CAAjB,CAA1B,EAA+C;AAC3CvE,cAAM,CAACwR,GAAP,CAAW,CAACI,OAAO,CAACnS,CAApB,EAAuBmS,OAAO,CAACpS,CAA/B,EAAkC,CAAlC,EAAqC,CAArC;AACH,OAFD,MAEO;AACHQ,cAAM,CAACwR,GAAP,CAAW,CAAX,EAAc,CAACI,OAAO,CAACrN,CAAvB,EAA0BqN,OAAO,CAACnS,CAAlC,EAAqC,CAArC;AACH;AACJ,KAND,MAMO;AACHmF,aAAO,CAACuD,UAAR,CAAmByJ,OAAnB,EAA4BC,KAA5B,EAAmCC,UAAU,CAAClN,OAAX,CAAmB,CAAnB,CAAnC;AACA5E,YAAM,CAACwR,GAAP,CAAWM,UAAU,CAAClN,OAAX,CAAmB,CAAnB,EAAsBpF,CAAjC,EAAoCsS,UAAU,CAAClN,OAAX,CAAmB,CAAnB,EAAsBnF,CAA1D,EAA6DqS,UAAU,CAAClN,OAAX,CAAmB,CAAnB,EAAsBL,CAAnF,EAAsFxB,CAAtF;AACH;;AAED,WAAO/C,MAAM,CAAC2F,SAAP,EAAP;AACH,GAfa;AAiBd;;;;;;;;;AAOcb,oCAAd,UAAmCiN,GAAnC,EAAgDC,KAAhD,EAA+DC,IAA/D,EAA2E;AACvE,QAAMV,CAAC,GAAG,IAAIzM,UAAJ,EAAV;AACAA,cAAU,CAAC4M,yBAAX,CAAqCK,GAArC,EAA0CC,KAA1C,EAAiDC,IAAjD,EAAuDV,CAAvD;AACA,WAAOA,CAAP;AACH,GAJa;AAMd;;;;;;;;;AAOczM,yCAAd,UAAwCiN,GAAxC,EAAqDC,KAArD,EAAoEC,IAApE,EAAkFjS,MAAlF,EAAoG;AAChG;AACA,QAAMkS,QAAQ,GAAGD,IAAI,GAAG,GAAxB;AACA,QAAME,SAAS,GAAGH,KAAK,GAAG,GAA1B;AACA,QAAMI,OAAO,GAAGL,GAAG,GAAG,GAAtB;AAEA,QAAMM,OAAO,GAAG1R,IAAI,CAACI,GAAL,CAASmR,QAAT,CAAhB;AACA,QAAMI,OAAO,GAAG3R,IAAI,CAACG,GAAL,CAASoR,QAAT,CAAhB;AACA,QAAMK,QAAQ,GAAG5R,IAAI,CAACI,GAAL,CAASoR,SAAT,CAAjB;AACA,QAAMK,QAAQ,GAAG7R,IAAI,CAACG,GAAL,CAASqR,SAAT,CAAjB;AACA,QAAMM,MAAM,GAAG9R,IAAI,CAACI,GAAL,CAASqR,OAAT,CAAf;AACA,QAAMM,MAAM,GAAG/R,IAAI,CAACG,GAAL,CAASsR,OAAT,CAAf;AAEApS,UAAM,CAACR,CAAP,GAAWkT,MAAM,GAAGH,QAAT,GAAoBD,OAApB,GAA8BG,MAAM,GAAGD,QAAT,GAAoBH,OAA7D;AACArS,UAAM,CAACP,CAAP,GAAWgT,MAAM,GAAGD,QAAT,GAAoBF,OAApB,GAA8BI,MAAM,GAAGH,QAAT,GAAoBF,OAA7D;AACArS,UAAM,CAACuE,CAAP,GAAWmO,MAAM,GAAGF,QAAT,GAAoBH,OAApB,GAA8BI,MAAM,GAAGF,QAAT,GAAoBD,OAA7D;AACAtS,UAAM,CAACsP,CAAP,GAAWoD,MAAM,GAAGF,QAAT,GAAoBF,OAApB,GAA8BG,MAAM,GAAGF,QAAT,GAAoBF,OAA7D;AACH,GAjBa;AAmBd;;;;;;;;;AAOcvN,sCAAd,UAAqC6N,KAArC,EAAoDC,IAApD,EAAkEC,KAAlE,EAA+E;AAC3E,QAAM7S,MAAM,GAAG,IAAI8E,UAAJ,EAAf;AACAA,cAAU,CAACgO,2BAAX,CAAuCH,KAAvC,EAA8CC,IAA9C,EAAoDC,KAApD,EAA2D7S,MAA3D;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc8E,2CAAd,UAA0C6N,KAA1C,EAAyDC,IAAzD,EAAuEC,KAAvE,EAAsF7S,MAAtF,EAAwG;AACpG;AACA,QAAM+S,kBAAkB,GAAG,CAACF,KAAK,GAAGF,KAAT,IAAkB,GAA7C;AACA,QAAMK,mBAAmB,GAAG,CAACH,KAAK,GAAGF,KAAT,IAAkB,GAA9C;AACA,QAAMM,QAAQ,GAAGL,IAAI,GAAG,GAAxB;AAEA5S,UAAM,CAACR,CAAP,GAAWmB,IAAI,CAACG,GAAL,CAASkS,mBAAT,IAAgCrS,IAAI,CAACI,GAAL,CAASkS,QAAT,CAA3C;AACAjT,UAAM,CAACP,CAAP,GAAWkB,IAAI,CAACI,GAAL,CAASiS,mBAAT,IAAgCrS,IAAI,CAACI,GAAL,CAASkS,QAAT,CAA3C;AACAjT,UAAM,CAACuE,CAAP,GAAW5D,IAAI,CAACI,GAAL,CAASgS,kBAAT,IAA+BpS,IAAI,CAACG,GAAL,CAASmS,QAAT,CAA1C;AACAjT,UAAM,CAACsP,CAAP,GAAW3O,IAAI,CAACG,GAAL,CAASiS,kBAAT,IAA+BpS,IAAI,CAACG,GAAL,CAASmS,QAAT,CAA1C;AACH,GAVa;AAYd;;;;;;;;;AAOcnO,0CAAd,UAAyC4J,KAAzC,EAAwEC,KAAxE,EAAuGC,KAAvG,EAAoI;AAChI,QAAMG,IAAI,GAAG,IAAIjK,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAb;AACAA,cAAU,CAACkK,+BAAX,CAA2CN,KAA3C,EAAkDC,KAAlD,EAAyDC,KAAzD,EAAgEG,IAAhE;AACA,WAAOA,IAAP;AACH,GAJa;AAMd;;;;;;;;;AAOcjK,+CAAd,UAA8C4J,KAA9C,EAA6EC,KAA7E,EAA4GC,KAA5G,EAA2IhL,GAA3I,EAA0J;AACtJ,QAAMsP,MAAM,GAAGzN,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACAA,UAAM,CAACkM,gBAAP,CAAwBzE,KAAK,CAAC/I,SAAN,EAAxB,EAA2CgJ,KAAK,CAAChJ,SAAN,EAA3C,EAA8DiJ,KAAK,CAACjJ,SAAN,EAA9D,EAAiFuN,MAAjF;AACApO,cAAU,CAAC2L,uBAAX,CAAmCyC,MAAnC,EAA2CtP,GAA3C;AACH,GAJa;AAMd;;;;;;;;;AAOckB,mCAAd,UAAkCyD,OAAlC,EAAmE6K,EAAnE,EAA6F;AACzF,QAAMrE,IAAI,GAAG,IAAIjK,UAAJ,EAAb;AACAA,cAAU,CAACuO,wBAAX,CAAoC9K,OAApC,EAA6C6K,EAA7C,EAAiDrE,IAAjD;AACA,WAAOA,IAAP;AACH,GAJa;AAMd;;;;;;;;;AAOcjK,wCAAd,UAAuCyD,OAAvC,EAAwE6K,EAAxE,EAAoGxP,GAApG,EAAmH;AAC/G,QAAMsP,MAAM,GAAGzN,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACAA,UAAM,CAACqM,oBAAP,CAA4B/K,OAA5B,EAAqC6K,EAArC,EAAyCF,MAAzC;AACApO,cAAU,CAAC2L,uBAAX,CAAmCyC,MAAnC,EAA2CtP,GAA3C;AACH,GAJa;AAMd;;;;;;;;;AAOckB,mCAAd,UAAkCyD,OAAlC,EAAmE6K,EAAnE,EAA6F;AACzF,QAAMrE,IAAI,GAAG,IAAIjK,UAAJ,EAAb;AACAA,cAAU,CAACyO,wBAAX,CAAoChL,OAApC,EAA6C6K,EAA7C,EAAiDrE,IAAjD;AACA,WAAOA,IAAP;AACH,GAJa;AAMd;;;;;;;;;AAOcjK,wCAAd,UAAuCyD,OAAvC,EAAwE6K,EAAxE,EAAoGxP,GAApG,EAAmH;AAC/G,QAAMsP,MAAM,GAAGzN,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACAA,UAAM,CAACuM,oBAAP,CAA4BjL,OAA5B,EAAqC6K,EAArC,EAAyCF,MAAzC;AACA,WAAOpO,UAAU,CAAC2L,uBAAX,CAAmCyC,MAAnC,EAA2CtP,GAA3C,CAAP;AACH,GAJa;AAMd;;;;;;;;;AAOckB,qBAAd,UAAoBtC,IAApB,EAAqDC,KAArD,EAAuFlB,MAAvF,EAAqG;AACjG,QAAMvB,MAAM,GAAG8E,UAAU,CAAC2O,QAAX,EAAf;AAEA3O,cAAU,CAAC2E,UAAX,CAAsBjH,IAAtB,EAA4BC,KAA5B,EAAmClB,MAAnC,EAA2CvB,MAA3C;AAEA,WAAOA,MAAP;AACH,GANa;AAQd;;;;;;;;;AAOc8E,0BAAd,UAAyBtC,IAAzB,EAA0DC,KAA1D,EAA4FlB,MAA5F,EAA4GvB,MAA5G,EAA8H;AAC1H,QAAI0T,IAAJ;AACA,QAAIC,IAAJ;AACA,QAAIC,IAAI,GAAGpR,IAAI,CAACgC,EAAL,GAAU/B,KAAK,CAAC+B,EAAhB,GAAqBhC,IAAI,CAACiC,EAAL,GAAUhC,KAAK,CAACgC,EAArC,GAA0CjC,IAAI,CAACkC,EAAL,GAAUjC,KAAK,CAACiC,EAA1D,GAA+DlC,IAAI,CAACiN,EAAL,GAAUhN,KAAK,CAACgN,EAA1F;AACA,QAAIoE,IAAI,GAAG,KAAX;;AAEA,QAAID,IAAI,GAAG,CAAX,EAAc;AACVC,UAAI,GAAG,IAAP;AACAD,UAAI,GAAG,CAACA,IAAR;AACH;;AAED,QAAIA,IAAI,GAAG,QAAX,EAAqB;AACjBD,UAAI,GAAG,IAAIpS,MAAX;AACAmS,UAAI,GAAGG,IAAI,GAAG,CAACtS,MAAJ,GAAaA,MAAxB;AACH,KAHD,MAGO;AACH,UAAMuS,IAAI,GAAGnT,IAAI,CAACuH,IAAL,CAAU0L,IAAV,CAAb;AACA,UAAMG,IAAI,GAAG,MAAMpT,IAAI,CAACI,GAAL,CAAS+S,IAAT,CAAnB;AACAH,UAAI,GAAGhT,IAAI,CAACI,GAAL,CAAS,CAAC,MAAMQ,MAAP,IAAiBuS,IAA1B,IAAkCC,IAAzC;AACAL,UAAI,GAAGG,IAAI,GAAG,CAAClT,IAAI,CAACI,GAAL,CAASQ,MAAM,GAAGuS,IAAlB,CAAD,GAA2BC,IAA9B,GAAqCpT,IAAI,CAACI,GAAL,CAASQ,MAAM,GAAGuS,IAAlB,IAA0BC,IAA1E;AACH;;AAED/T,UAAM,CAACR,CAAP,GAAWmU,IAAI,GAAGnR,IAAI,CAACgC,EAAZ,GAAiBkP,IAAI,GAAGjR,KAAK,CAAC+B,EAAzC;AACAxE,UAAM,CAACP,CAAP,GAAWkU,IAAI,GAAGnR,IAAI,CAACiC,EAAZ,GAAiBiP,IAAI,GAAGjR,KAAK,CAACgC,EAAzC;AACAzE,UAAM,CAACuE,CAAP,GAAWoP,IAAI,GAAGnR,IAAI,CAACkC,EAAZ,GAAiBgP,IAAI,GAAGjR,KAAK,CAACiC,EAAzC;AACA1E,UAAM,CAACsP,CAAP,GAAWqE,IAAI,GAAGnR,IAAI,CAACiN,EAAZ,GAAiBiE,IAAI,GAAGjR,KAAK,CAACgN,EAAzC;AACH,GAzBa;AA2Bd;;;;;;;;;;;AASc3K,uBAAd,UACI3D,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIN,MALJ,EAKkB;AAEd,QAAMC,OAAO,GAAGD,MAAM,GAAGA,MAAzB;AACA,QAAME,KAAK,GAAGF,MAAM,GAAGC,OAAvB;AACA,QAAMM,KAAK,GAAG,MAAML,KAAN,GAAc,MAAMD,OAApB,GAA8B,GAA5C;AACA,QAAMO,KAAK,GAAG,CAAC,GAAD,GAAON,KAAP,GAAe,MAAMD,OAAnC;AACA,QAAMQ,KAAK,GAAGP,KAAK,GAAG,MAAMD,OAAd,GAAwBD,MAAtC;AACA,QAAMU,KAAK,GAAGR,KAAK,GAAGD,OAAtB;AAEA,QAAMhC,CAAC,GAAG2B,MAAM,CAACqD,EAAP,GAAY1C,KAAZ,GAAoBV,MAAM,CAACoD,EAAP,GAAYzC,KAAhC,GAAwCH,QAAQ,CAAC4C,EAAT,GAAcxC,KAAtD,GAA8DH,QAAQ,CAAC2C,EAAT,GAAcvC,KAAtF;AACA,QAAMxC,CAAC,GAAG0B,MAAM,CAACsD,EAAP,GAAY3C,KAAZ,GAAoBV,MAAM,CAACqD,EAAP,GAAY1C,KAAhC,GAAwCH,QAAQ,CAAC6C,EAAT,GAAczC,KAAtD,GAA8DH,QAAQ,CAAC4C,EAAT,GAAcxC,KAAtF;AACA,QAAMsC,CAAC,GAAGpD,MAAM,CAACuD,EAAP,GAAY5C,KAAZ,GAAoBV,MAAM,CAACsD,EAAP,GAAY3C,KAAhC,GAAwCH,QAAQ,CAAC8C,EAAT,GAAc1C,KAAtD,GAA8DH,QAAQ,CAAC6C,EAAT,GAAczC,KAAtF;AACA,QAAMqN,CAAC,GAAGnO,MAAM,CAACsO,EAAP,GAAY3N,KAAZ,GAAoBV,MAAM,CAACqO,EAAP,GAAY1N,KAAhC,GAAwCH,QAAQ,CAAC6N,EAAT,GAAczN,KAAtD,GAA8DH,QAAQ,CAAC4N,EAAT,GAAcxN,KAAtF;AACA,WAAO,IAAI6C,UAAJ,CAAetF,CAAf,EAAkBC,CAAlB,EAAqB8E,CAArB,EAAwB+K,CAAxB,CAAP;AACH,GAnBa;AAqBd;;;;;;;;;;;AAScxK,oCAAd,UACI3D,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAKgB;AAEZ,QAAMlC,MAAM,GAAG8E,UAAU,CAAC3C,IAAX,EAAf;AAEA,SAAKC,yBAAL,CAA+BjB,MAA/B,EAAuCS,QAAvC,EAAiDR,MAAjD,EAAyDS,QAAzD,EAAmEK,IAAnE,EAAyElC,MAAzE;AAEA,WAAOA,MAAP;AACH,GAZa;AAcd;;;;;;;;;;;AASc8E,yCAAd,UACI3D,MADJ,EAEIS,QAFJ,EAGIR,MAHJ,EAIIS,QAJJ,EAKIK,IALJ,EAMIlC,MANJ,EAMsB;AAElB,QAAMqC,EAAE,GAAGH,IAAI,GAAGA,IAAlB;AAEAlC,UAAM,CAACR,CAAP,GAAW,CAAC6C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC3B,CAAzB,GAA6B,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACpC,CAAhE,GAAoE,CAAC,CAAC6C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC5B,CAA9F,GAAkG,CAAC,IAAI6C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACrC,CAA5I;AACAQ,UAAM,CAACP,CAAP,GAAW,CAAC4C,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAAC1B,CAAzB,GAA6B,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAACnC,CAAhE,GAAoE,CAAC,CAAC4C,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAAC3B,CAA9F,GAAkG,CAAC,IAAI4C,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACpC,CAA5I;AACAO,UAAM,CAACuE,CAAP,GAAW,CAAClC,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAACoD,CAAzB,GAA6B,CAAC,IAAIlC,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAAC2C,CAAhE,GAAoE,CAAC,CAAClC,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAACmD,CAA9F,GAAkG,CAAC,IAAIlC,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAAC0C,CAA5I;AACAvE,UAAM,CAACsP,CAAP,GAAW,CAACjN,EAAE,GAAGH,IAAN,IAAc,CAAd,GAAkBf,MAAM,CAACmO,CAAzB,GAA6B,CAAC,IAAIjN,EAAJ,GAAS,IAAIH,IAAb,GAAoB,CAArB,IAA0BN,QAAQ,CAAC0N,CAAhE,GAAoE,CAAC,CAACjN,EAAD,GAAMH,IAAP,IAAe,CAAf,GAAmBd,MAAM,CAACkO,CAA9F,GAAkG,CAAC,IAAIjN,EAAJ,GAAS,IAAIH,IAAd,IAAsBL,QAAQ,CAACyN,CAA5I;AACH,GAda;;AAelB;AAAC,CA18BD;;;AA48BA;;;;AAGA;AAAA;AAAA;AAiDI;;;AAGA;AAzCQ,uBAAc,KAAd;AACA,4BAAmB,IAAnB;AACA,0BAAiB,IAAjB;AACA,+BAAsB,IAAtB;AACR;;;;;;AAKO,sBAAqB,CAAC,CAAtB;;AAiCH,QAAIrQ,uBAAuB,CAAC+U,0BAA5B,EAAwD;AACpD/U,6BAAuB,CAACgV,qBAAxB,CAA+CC,IAA/C,CAAoD,IAApD;AACH;;AAED,SAAKC,EAAL,GAAU,IAAIlV,uBAAuB,CAACmV,iBAA5B,CAA8C,EAA9C,CAAV;AAEA,SAAKC,aAAL;AACH;;AAxDD1P,wBAAkBsC,MAAlB,EAAkB,WAAlB,EAA2B;AAH3B;;;SAGA;AACI,aAAOhI,uBAAuB,CAACqV,eAA/B;AACH,KAF0B;qBAAA;;AAAA,GAA3B;AAuBA3P,wBAAWsC,gBAAX,EAAW,GAAX,EAAY;AAHZ;;;SAGA;AACI,aAAO,KAAKkN,EAAZ;AACH,KAFW;qBAAA;;AAAA,GAAZ;AAIA;;;;AAGOlN,mCAAP;AACI,SAAKsN,UAAL,GAAkBtN,MAAM,CAACuN,eAAP,EAAlB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,cAAL,GAAsB,KAAtB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,mBAAL,GAA2B,IAA3B;AACH,GANM;;AAQC3N,2CAAR,UAA8B4N,UAA9B,EAAmDC,eAAnD,EAAqFC,aAArF,EAAqHC,kBAArH,EAAuJ;AAApG;AAAAF;AAAgC;;AAAE;AAAAC;AAA8B;;AAAE;AAAAC;AAAkC;;AACnJ,SAAKP,WAAL,GAAmBI,UAAnB;AACA,SAAKH,cAAL,GAAsBG,UAAU,IAAIE,aAApC;AACA,SAAKJ,gBAAL,GAAwB,KAAKF,WAAL,GAAmB,KAAnB,GAA2BK,eAAnD;AACA,SAAKF,mBAAL,GAA2B,KAAKF,cAAL,GAAsB,KAAtB,GAA8BM,kBAAzD;AACH,GALO,CA1CZ,CA8DI;;AAEA;;;;;;AAIO/N,gCAAP;AACI,QAAI,KAAK0N,gBAAT,EAA2B;AACvB,WAAKA,gBAAL,GAAwB,KAAxB;AACA,UAAM1R,CAAC,GAAG,KAAKkR,EAAf;AACA,WAAKM,WAAL,GACIxR,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,IACAA,CAAC,CAAC,CAAD,CAAD,KAAS,GADT,IAEAA,CAAC,CAAC,CAAD,CAAD,KAAS,GAFT,IAGAA,CAAC,CAAC,CAAD,CAAD,KAAS,GAHT,IAIAA,CAAC,CAAC,CAAD,CAAD,KAAS,GAJT,IAKAA,CAAC,CAAC,CAAD,CAAD,KAAS,GALT,IAMAA,CAAC,CAAC,CAAD,CAAD,KAAS,GANT,IAOAA,CAAC,CAAC,CAAD,CAAD,KAAS,GAPT,IAQAA,CAAC,CAAC,CAAD,CAAD,KAAS,GART,IASAA,CAAC,CAAC,CAAD,CAAD,KAAS,GATT,IAUAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAVV,IAWAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAXV,IAYAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAZV,IAaAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAbV,IAcAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAdV,IAeAA,CAAC,CAAC,EAAD,CAAD,KAAU,GAhBd;AAiBH;;AAED,WAAO,KAAKwR,WAAZ;AACH,GAxBM;AA0BP;;;;;;AAIOxN,qCAAP;AACI,QAAI,KAAK2N,mBAAT,EAA8B;AAC1B,WAAKA,mBAAL,GAA2B,KAA3B;;AACA,UAAI,KAAKT,EAAL,CAAQ,CAAR,MAAe,GAAf,IAAsB,KAAKA,EAAL,CAAQ,CAAR,MAAe,GAArC,IAA4C,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GAAhE,EAAqE;AACjE,aAAKO,cAAL,GAAsB,KAAtB;AACH,OAFD,MAEO,IACH,KAAKP,EAAL,CAAQ,CAAR,MAAe,GAAf,IACA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GADf,IAEA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GAFf,IAGA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GAHf,IAIA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GAJf,IAKA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GALf,IAMA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GANf,IAOA,KAAKA,EAAL,CAAQ,CAAR,MAAe,GAPf,IAQA,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GARhB,IASA,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GAThB,IAUA,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GAVhB,IAWA,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GAXhB,IAYA,KAAKA,EAAL,CAAQ,EAAR,MAAgB,GAbb,EAcL;AACE,aAAKO,cAAL,GAAsB,KAAtB;AACH,OAhBM,MAgBA;AACH,aAAKA,cAAL,GAAsB,IAAtB;AACH;AACJ;;AAED,WAAO,KAAKA,cAAZ;AACH,GA3BM;AA6BP;;;;;;AAIOzN,iCAAP;AACI,QAAI,KAAKwN,WAAL,KAAqB,IAAzB,EAA+B;AAC3B,aAAO,CAAP;AACH;;AAED,QAAMxR,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMc,GAAG,GAAGhS,CAAC,CAAC,CAAD,CAAb;AAAA,QACIiS,GAAG,GAAGjS,CAAC,CAAC,CAAD,CADX;AAAA,QAEIkS,GAAG,GAAGlS,CAAC,CAAC,CAAD,CAFX;AAAA,QAGImS,GAAG,GAAGnS,CAAC,CAAC,CAAD,CAHX;AAIA,QAAMoS,GAAG,GAAGpS,CAAC,CAAC,CAAD,CAAb;AAAA,QACI0N,GAAG,GAAG1N,CAAC,CAAC,CAAD,CADX;AAAA,QAEI2N,GAAG,GAAG3N,CAAC,CAAC,CAAD,CAFX;AAAA,QAGI4N,GAAG,GAAG5N,CAAC,CAAC,CAAD,CAHX;AAIA,QAAMqS,GAAG,GAAGrS,CAAC,CAAC,CAAD,CAAb;AAAA,QACI6N,GAAG,GAAG7N,CAAC,CAAC,CAAD,CADX;AAAA,QAEI8N,GAAG,GAAG9N,CAAC,CAAC,EAAD,CAFX;AAAA,QAGI+N,GAAG,GAAG/N,CAAC,CAAC,EAAD,CAHX;AAIA,QAAMsS,GAAG,GAAGtS,CAAC,CAAC,EAAD,CAAb;AAAA,QACIgO,GAAG,GAAGhO,CAAC,CAAC,EAAD,CADX;AAAA,QAEIiO,GAAG,GAAGjO,CAAC,CAAC,EAAD,CAFX;AAAA,QAGIkO,GAAG,GAAGlO,CAAC,CAAC,EAAD,CAHX,CAlBJ,CAsBI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMuS,SAAS,GAAGzE,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAMyE,SAAS,GAAG3E,GAAG,GAAGK,GAAN,GAAYF,GAAG,GAAGD,GAApC;AACA,QAAM0E,SAAS,GAAG5E,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAM4E,SAAS,GAAGL,GAAG,GAAGnE,GAAN,GAAYoE,GAAG,GAAGvE,GAApC;AACA,QAAM4E,SAAS,GAAGN,GAAG,GAAGpE,GAAN,GAAYH,GAAG,GAAGwE,GAApC;AACA,QAAMM,SAAS,GAAGP,GAAG,GAAGrE,GAAN,GAAYsE,GAAG,GAAGzE,GAApC;AACA,QAAMgF,SAAS,GAAG,EAAEnF,GAAG,GAAG6E,SAAN,GAAkB5E,GAAG,GAAG6E,SAAxB,GAAoC5E,GAAG,GAAG6E,SAA5C,CAAlB;AACA,QAAMK,SAAS,GAAG,EAAEV,GAAG,GAAGG,SAAN,GAAkB5E,GAAG,GAAG+E,SAAxB,GAAoC9E,GAAG,GAAG+E,SAA5C,CAAlB;AACA,QAAMI,SAAS,GAAG,EAAEX,GAAG,GAAGI,SAAN,GAAkB9E,GAAG,GAAGgF,SAAxB,GAAoC9E,GAAG,GAAGgF,SAA5C,CAAlB;AACA,QAAMI,SAAS,GAAG,EAAEZ,GAAG,GAAGK,SAAN,GAAkB/E,GAAG,GAAGiF,SAAxB,GAAoChF,GAAG,GAAGiF,SAA5C,CAAlB;AACA,WAAOZ,GAAG,GAAGa,SAAN,GAAkBZ,GAAG,GAAGa,SAAxB,GAAoCZ,GAAG,GAAGa,SAA1C,GAAsDZ,GAAG,GAAGa,SAAnE;AACH,GA3CM,CAnIX,CAgLI;;AAEA;;;;;;AAIOhP,6BAAP;AACI,WAAO,KAAKkN,EAAZ;AACH,GAFM;AAGP;;;;;;AAIOlN,6BAAP;AACI,WAAO,KAAKkN,EAAZ;AACH,GAFM;AAIP;;;;;;AAIOlN,4BAAP;AACI,SAAKiP,WAAL,CAAiB,IAAjB;AACA,WAAO,IAAP;AACH,GAHM;AAIP;;;;;;AAIOjP,2BAAP;AACIA,UAAM,CAACuE,eAAP,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F,EAAkG,GAAlG,EAAuG,IAAvG;;AACA,SAAK2K,qBAAL,CAA2B,KAA3B;;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKOlP,yBAAP,UAAWjB,KAAX,EAAuC;AACnC,QAAMhG,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA,SAAKlB,QAAL,CAAcC,KAAd,EAAqBhG,MAArB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMOiH,8BAAP,UAAgBjB,KAAhB,EAA8ChG,MAA9C,EAA4D;AACxD,QAAMiD,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMiC,OAAO,GAAGpW,MAAM,CAACmU,EAAvB;AACA,QAAMkC,MAAM,GAAGrQ,KAAK,CAAC/C,CAArB;;AACA,SAAK,IAAInD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCsW,aAAO,CAACtW,KAAD,CAAP,GAAiBmD,CAAC,CAACnD,KAAD,CAAD,GAAWuW,MAAM,CAACvW,KAAD,CAAlC;AACH;;AACDE,UAAM,CAACqU,aAAP;AACA,WAAO,IAAP;AACH,GATM;AAWP;;;;;;;AAKOpN,+BAAP,UAAiBjB,KAAjB,EAA6C;AACzC,QAAM/C,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMkC,MAAM,GAAGrQ,KAAK,CAAC/C,CAArB;;AACA,SAAK,IAAInD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCmD,OAAC,CAACnD,KAAD,CAAD,IAAYuW,MAAM,CAACvW,KAAD,CAAlB;AACH;;AACD,SAAKuU,aAAL;AACA,WAAO,IAAP;AACH,GARM;AAUP;;;;;;;AAKOpN,iCAAP,UAAmBjB,KAAnB,EAAgC;AAC5B,QAAI,KAAKyO,WAAL,KAAqB,IAAzB,EAA+B;AAC3BxN,YAAM,CAACqP,aAAP,CAAqBtQ,KAArB;AACA,aAAO,IAAP;AACH,KAJ2B,CAM5B;;;AACA,QAAM/C,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMc,GAAG,GAAGhS,CAAC,CAAC,CAAD,CAAb;AAAA,QACIiS,GAAG,GAAGjS,CAAC,CAAC,CAAD,CADX;AAAA,QAEIkS,GAAG,GAAGlS,CAAC,CAAC,CAAD,CAFX;AAAA,QAGImS,GAAG,GAAGnS,CAAC,CAAC,CAAD,CAHX;AAIA,QAAMoS,GAAG,GAAGpS,CAAC,CAAC,CAAD,CAAb;AAAA,QACI0N,GAAG,GAAG1N,CAAC,CAAC,CAAD,CADX;AAAA,QAEI2N,GAAG,GAAG3N,CAAC,CAAC,CAAD,CAFX;AAAA,QAGI4N,GAAG,GAAG5N,CAAC,CAAC,CAAD,CAHX;AAIA,QAAMqS,GAAG,GAAGrS,CAAC,CAAC,CAAD,CAAb;AAAA,QACI6N,GAAG,GAAG7N,CAAC,CAAC,CAAD,CADX;AAAA,QAEI8N,GAAG,GAAG9N,CAAC,CAAC,EAAD,CAFX;AAAA,QAGI+N,GAAG,GAAG/N,CAAC,CAAC,EAAD,CAHX;AAIA,QAAMsS,GAAG,GAAGtS,CAAC,CAAC,EAAD,CAAb;AAAA,QACIgO,GAAG,GAAGhO,CAAC,CAAC,EAAD,CADX;AAAA,QAEIiO,GAAG,GAAGjO,CAAC,CAAC,EAAD,CAFX;AAAA,QAGIkO,GAAG,GAAGlO,CAAC,CAAC,EAAD,CAHX;AAKA,QAAMuS,SAAS,GAAGzE,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAMyE,SAAS,GAAG3E,GAAG,GAAGK,GAAN,GAAYF,GAAG,GAAGD,GAApC;AACA,QAAM0E,SAAS,GAAG5E,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAM4E,SAAS,GAAGL,GAAG,GAAGnE,GAAN,GAAYoE,GAAG,GAAGvE,GAApC;AACA,QAAM4E,SAAS,GAAGN,GAAG,GAAGpE,GAAN,GAAYH,GAAG,GAAGwE,GAApC;AACA,QAAMM,SAAS,GAAGP,GAAG,GAAGrE,GAAN,GAAYsE,GAAG,GAAGzE,GAApC;AAEA,QAAMgF,SAAS,GAAG,EAAEnF,GAAG,GAAG6E,SAAN,GAAkB5E,GAAG,GAAG6E,SAAxB,GAAoC5E,GAAG,GAAG6E,SAA5C,CAAlB;AACA,QAAMK,SAAS,GAAG,EAAEV,GAAG,GAAGG,SAAN,GAAkB5E,GAAG,GAAG+E,SAAxB,GAAoC9E,GAAG,GAAG+E,SAA5C,CAAlB;AACA,QAAMI,SAAS,GAAG,EAAEX,GAAG,GAAGI,SAAN,GAAkB9E,GAAG,GAAGgF,SAAxB,GAAoC9E,GAAG,GAAGgF,SAA5C,CAAlB;AACA,QAAMI,SAAS,GAAG,EAAEZ,GAAG,GAAGK,SAAN,GAAkB/E,GAAG,GAAGiF,SAAxB,GAAoChF,GAAG,GAAGiF,SAA5C,CAAlB;AAEA,QAAMU,GAAG,GAAGtB,GAAG,GAAGa,SAAN,GAAkBZ,GAAG,GAAGa,SAAxB,GAAoCZ,GAAG,GAAGa,SAA1C,GAAsDZ,GAAG,GAAGa,SAAxE;;AAEA,QAAIM,GAAG,KAAK,CAAZ,EAAe;AACX;AACAvQ,WAAK,CAACU,QAAN,CAAe,IAAf;AACA,aAAO,IAAP;AACH;;AAED,QAAM8P,MAAM,GAAG,IAAID,GAAnB;AACA,QAAME,SAAS,GAAG7F,GAAG,GAAGO,GAAN,GAAYD,GAAG,GAAGL,GAApC;AACA,QAAM6F,SAAS,GAAG/F,GAAG,GAAGQ,GAAN,GAAYF,GAAG,GAAGJ,GAApC;AACA,QAAM8F,SAAS,GAAGhG,GAAG,GAAGO,GAAN,GAAYD,GAAG,GAAGL,GAApC;AACA,QAAMgG,SAAS,GAAGvB,GAAG,GAAGlE,GAAN,GAAYoE,GAAG,GAAG1E,GAApC;AACA,QAAMgG,SAAS,GAAGxB,GAAG,GAAGnE,GAAN,GAAYqE,GAAG,GAAG3E,GAApC;AACA,QAAMkG,SAAS,GAAGzB,GAAG,GAAGpE,GAAN,GAAYsE,GAAG,GAAG5E,GAApC;AACA,QAAMoG,SAAS,GAAGnG,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAMmG,SAAS,GAAGrG,GAAG,GAAGK,GAAN,GAAYF,GAAG,GAAGD,GAApC;AACA,QAAMoG,SAAS,GAAGtG,GAAG,GAAGI,GAAN,GAAYD,GAAG,GAAGF,GAApC;AACA,QAAMsG,SAAS,GAAG7B,GAAG,GAAGrE,GAAN,GAAYsE,GAAG,GAAGzE,GAApC;AACA,QAAMsG,SAAS,GAAG9B,GAAG,GAAGtE,GAAN,GAAYuE,GAAG,GAAG1E,GAApC;AACA,QAAMwG,SAAS,GAAG/B,GAAG,GAAGvE,GAAN,GAAYwE,GAAG,GAAG3E,GAApC;AAEA,QAAM0G,SAAS,GAAG,EAAEnC,GAAG,GAAGM,SAAN,GAAkBL,GAAG,GAAGM,SAAxB,GAAoCL,GAAG,GAAGM,SAA5C,CAAlB;AACA,QAAM4B,SAAS,GAAG,EAAErC,GAAG,GAAGO,SAAN,GAAkBL,GAAG,GAAGQ,SAAxB,GAAoCP,GAAG,GAAGQ,SAA5C,CAAlB;AACA,QAAM2B,SAAS,GAAG,EAAEtC,GAAG,GAAGQ,SAAN,GAAkBP,GAAG,GAAGS,SAAxB,GAAoCP,GAAG,GAAGS,SAA5C,CAAlB;AACA,QAAM2B,SAAS,GAAG,EAAEvC,GAAG,GAAGS,SAAN,GAAkBR,GAAG,GAAGU,SAAxB,GAAoCT,GAAG,GAAGU,SAA5C,CAAlB;AAEA,QAAM4B,SAAS,GAAG,EAAEvC,GAAG,GAAGuB,SAAN,GAAkBtB,GAAG,GAAGuB,SAAxB,GAAoCtB,GAAG,GAAGuB,SAA5C,CAAlB;AACA,QAAMe,SAAS,GAAG,EAAEzC,GAAG,GAAGwB,SAAN,GAAkBtB,GAAG,GAAGyB,SAAxB,GAAoCxB,GAAG,GAAGyB,SAA5C,CAAlB;AACA,QAAMc,SAAS,GAAG,EAAE1C,GAAG,GAAGyB,SAAN,GAAkBxB,GAAG,GAAG0B,SAAxB,GAAoCxB,GAAG,GAAG0B,SAA5C,CAAlB;AACA,QAAMc,SAAS,GAAG,EAAE3C,GAAG,GAAG0B,SAAN,GAAkBzB,GAAG,GAAG2B,SAAxB,GAAoC1B,GAAG,GAAG2B,SAA5C,CAAlB;AAEA,QAAMe,SAAS,GAAG,EAAE3C,GAAG,GAAG6B,SAAN,GAAkB5B,GAAG,GAAG6B,SAAxB,GAAoC5B,GAAG,GAAG6B,SAA5C,CAAlB;AACA,QAAMa,SAAS,GAAG,EAAE7C,GAAG,GAAG8B,SAAN,GAAkB5B,GAAG,GAAG+B,SAAxB,GAAoC9B,GAAG,GAAG+B,SAA5C,CAAlB;AACA,QAAMY,SAAS,GAAG,EAAE9C,GAAG,GAAG+B,SAAN,GAAkB9B,GAAG,GAAGgC,SAAxB,GAAoC9B,GAAG,GAAGgC,SAA5C,CAAlB;AACA,QAAMY,SAAS,GAAG,EAAE/C,GAAG,GAAGgC,SAAN,GAAkB/B,GAAG,GAAGiC,SAAxB,GAAoChC,GAAG,GAAGiC,SAA5C,CAAlB;AAEAnQ,UAAM,CAACuE,eAAP,CACIsK,SAAS,GAAGU,MADhB,EAEIa,SAAS,GAAGb,MAFhB,EAGIiB,SAAS,GAAGjB,MAHhB,EAIIqB,SAAS,GAAGrB,MAJhB,EAKIT,SAAS,GAAGS,MALhB,EAMIc,SAAS,GAAGd,MANhB,EAOIkB,SAAS,GAAGlB,MAPhB,EAQIsB,SAAS,GAAGtB,MARhB,EASIR,SAAS,GAAGQ,MAThB,EAUIe,SAAS,GAAGf,MAVhB,EAWImB,SAAS,GAAGnB,MAXhB,EAYIuB,SAAS,GAAGvB,MAZhB,EAaIP,SAAS,GAAGO,MAbhB,EAcIgB,SAAS,GAAGhB,MAdhB,EAeIoB,SAAS,GAAGpB,MAfhB,EAgBIwB,SAAS,GAAGxB,MAhBhB,EAiBIxQ,KAjBJ;AAoBA,WAAO,IAAP;AACH,GA/FM;AAiGP;;;;;;;;AAMOiB,gCAAP,UAAkBnH,KAAlB,EAAiCV,KAAjC,EAA8C;AAC1C,SAAK+U,EAAL,CAAQrU,KAAR,KAAkBV,KAAlB;AACA,SAAKiV,aAAL;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMOpN,qCAAP,UAAuBnH,KAAvB,EAAsCV,KAAtC,EAAmD;AAC/C,SAAK+U,EAAL,CAAQrU,KAAR,KAAkBV,KAAlB;AACA,SAAKiV,aAAL;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;;AAOOpN,8CAAP,UAAgCzH,CAAhC,EAA2CC,CAA3C,EAAsD8E,CAAtD,EAA+D;AAC3D,SAAK4P,EAAL,CAAQ,EAAR,IAAc3U,CAAd;AACA,SAAK2U,EAAL,CAAQ,EAAR,IAAc1U,CAAd;AACA,SAAK0U,EAAL,CAAQ,EAAR,IAAc5P,CAAd;AACA,SAAK8P,aAAL;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;AAOOpN,8CAAP,UAAgCzH,CAAhC,EAA2CC,CAA3C,EAAsD8E,CAAtD,EAA+D;AAC3D,SAAK4P,EAAL,CAAQ,EAAR,KAAe3U,CAAf;AACA,SAAK2U,EAAL,CAAQ,EAAR,KAAe1U,CAAf;AACA,SAAK0U,EAAL,CAAQ,EAAR,KAAe5P,CAAf;AACA,SAAK8P,aAAL;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKOpN,oCAAP,UAAsBgR,OAAtB,EAAqD;AACjD,WAAO,KAAKC,wBAAL,CAA8BD,OAAO,CAACzT,EAAtC,EAA0CyT,OAAO,CAACxT,EAAlD,EAAsDwT,OAAO,CAACvT,EAA9D,CAAP;AACH,GAFM;AAIP;;;;;;AAIOuC,oCAAP;AACI,WAAO,IAAIrC,OAAJ,CAAY,KAAKuP,EAAL,CAAQ,EAAR,CAAZ,EAAyB,KAAKA,EAAL,CAAQ,EAAR,CAAzB,EAAsC,KAAKA,EAAL,CAAQ,EAAR,CAAtC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOlN,yCAAP,UAA2BjH,MAA3B,EAA0C;AACtCA,UAAM,CAACR,CAAP,GAAW,KAAK2U,EAAL,CAAQ,EAAR,CAAX;AACAnU,UAAM,CAACP,CAAP,GAAW,KAAK0U,EAAL,CAAQ,EAAR,CAAX;AACAnU,UAAM,CAACuE,CAAP,GAAW,KAAK4P,EAAL,CAAQ,EAAR,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;AAIOlN,8CAAP;AACI,QAAMhE,CAAC,GAAG,KAAKA,CAAf;AACAgE,UAAM,CAACuE,eAAP,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmFvI,CAAC,CAAC,EAAD,CAApF,EAA0FA,CAAC,CAAC,EAAD,CAA3F,EAAiGA,CAAC,CAAC,EAAD,CAAlG,EAAwGA,CAAC,CAAC,EAAD,CAAzG,EAA+G,IAA/G;;AACA,SAAKkT,qBAAL,CAA2BlT,CAAC,CAAC,EAAD,CAAD,KAAU,CAAV,IAAeA,CAAC,CAAC,EAAD,CAAD,KAAU,CAAzB,IAA8BA,CAAC,CAAC,EAAD,CAAD,KAAU,CAAxC,IAA6CA,CAAC,CAAC,EAAD,CAAD,KAAU,CAAlF;;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKOgE,8BAAP,UAAgBjB,KAAhB,EAA4C;AACxC,QAAMhG,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA,SAAKyE,aAAL,CAAmB1F,KAAnB,EAA0BhG,MAA1B;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;AAKOiH,8BAAP,UAAgBjB,KAAhB,EAA4C;AACxCA,SAAK,CAACmS,WAAN,CAAkB,KAAKhE,EAAvB;AACA,QAAMiE,CAAC,GAAGpS,KAAV;AACA,SAAKuO,UAAL,GAAkB6D,CAAC,CAAC7D,UAApB;;AACA,SAAK4B,qBAAL,CAA2BiC,CAAC,CAAC3D,WAA7B,EAA0C2D,CAAC,CAACzD,gBAA5C,EAA8DyD,CAAC,CAAC1D,cAAhE,EAAgF0D,CAAC,CAACxD,mBAAlF;;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;AAMO3N,iCAAP,UAAmBpH,KAAnB,EAAwDqB,MAAxD,EAA0E;AAAlB;AAAAA;AAAkB;;AACtE,QAAMf,MAAM,GAAG,KAAKgU,EAApB;AACAtU,SAAK,CAACqB,MAAD,CAAL,GAAgBf,MAAM,CAAC,CAAD,CAAtB;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,CAAV,CAAL,GAAoBf,MAAM,CAAC,CAAD,CAA1B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AACAN,SAAK,CAACqB,MAAM,GAAG,EAAV,CAAL,GAAqBf,MAAM,CAAC,EAAD,CAA3B;AAEA,WAAO,IAAP;AACH,GApBM;AAsBP;;;;;;;;AAMO8G,mCAAP,UAAqBjB,KAArB,EAAmDhG,MAAnD,EAAiE;AAC7D,QAAI,KAAKyU,WAAT,EAAsB;AAClBzU,YAAM,CAAC0G,QAAP,CAAgBV,KAAhB;AACA,aAAO,IAAP;AACH;;AACD,QAAKA,KAAgB,CAACyO,WAAtB,EAAmC;AAC/BzU,YAAM,CAAC0G,QAAP,CAAgB,IAAhB;AACA,aAAO,IAAP;AACH;;AAED,SAAK2R,eAAL,CAAqBrS,KAArB,EAA4BhG,MAAM,CAACmU,EAAnC,EAAuC,CAAvC;AACAnU,UAAM,CAACqU,aAAP;AACA,WAAO,IAAP;AACH,GAbM;AAeP;;;;;;;;;AAOOpN,qCAAP,UAAuBjB,KAAvB,EAAqDhG,MAArD,EAA2FkB,MAA3F,EAAyG;AACrG,QAAM+B,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMkC,MAAM,GAAGrQ,KAAK,CAAC/C,CAArB;AACA,QAAMqV,GAAG,GAAGrV,CAAC,CAAC,CAAD,CAAb;AAAA,QACIsV,GAAG,GAAGtV,CAAC,CAAC,CAAD,CADX;AAAA,QAEIuV,GAAG,GAAGvV,CAAC,CAAC,CAAD,CAFX;AAAA,QAGIwV,GAAG,GAAGxV,CAAC,CAAC,CAAD,CAHX;AAIA,QAAMyV,GAAG,GAAGzV,CAAC,CAAC,CAAD,CAAb;AAAA,QACI0V,GAAG,GAAG1V,CAAC,CAAC,CAAD,CADX;AAAA,QAEI2V,GAAG,GAAG3V,CAAC,CAAC,CAAD,CAFX;AAAA,QAGI4V,GAAG,GAAG5V,CAAC,CAAC,CAAD,CAHX;AAIA,QAAM6V,GAAG,GAAG7V,CAAC,CAAC,CAAD,CAAb;AAAA,QACI8V,GAAG,GAAG9V,CAAC,CAAC,CAAD,CADX;AAAA,QAEI+V,IAAI,GAAG/V,CAAC,CAAC,EAAD,CAFZ;AAAA,QAGIgW,IAAI,GAAGhW,CAAC,CAAC,EAAD,CAHZ;AAIA,QAAMiW,IAAI,GAAGjW,CAAC,CAAC,EAAD,CAAd;AAAA,QACIkW,IAAI,GAAGlW,CAAC,CAAC,EAAD,CADZ;AAAA,QAEImW,IAAI,GAAGnW,CAAC,CAAC,EAAD,CAFZ;AAAA,QAGIoW,IAAI,GAAGpW,CAAC,CAAC,EAAD,CAHZ;AAKA,QAAMqW,GAAG,GAAGjD,MAAM,CAAC,CAAD,CAAlB;AAAA,QACIkD,GAAG,GAAGlD,MAAM,CAAC,CAAD,CADhB;AAAA,QAEImD,GAAG,GAAGnD,MAAM,CAAC,CAAD,CAFhB;AAAA,QAGIoD,GAAG,GAAGpD,MAAM,CAAC,CAAD,CAHhB;AAIA,QAAMqD,GAAG,GAAGrD,MAAM,CAAC,CAAD,CAAlB;AAAA,QACIsD,GAAG,GAAGtD,MAAM,CAAC,CAAD,CADhB;AAAA,QAEIuD,GAAG,GAAGvD,MAAM,CAAC,CAAD,CAFhB;AAAA,QAGIwD,GAAG,GAAGxD,MAAM,CAAC,CAAD,CAHhB;AAIA,QAAMyD,GAAG,GAAGzD,MAAM,CAAC,CAAD,CAAlB;AAAA,QACI0D,GAAG,GAAG1D,MAAM,CAAC,CAAD,CADhB;AAAA,QAEI2D,IAAI,GAAG3D,MAAM,CAAC,EAAD,CAFjB;AAAA,QAGI4D,IAAI,GAAG5D,MAAM,CAAC,EAAD,CAHjB;AAIA,QAAM6D,IAAI,GAAG7D,MAAM,CAAC,EAAD,CAAnB;AAAA,QACI8D,IAAI,GAAG9D,MAAM,CAAC,EAAD,CADjB;AAAA,QAEI+D,IAAI,GAAG/D,MAAM,CAAC,EAAD,CAFjB;AAAA,QAGIgE,IAAI,GAAGhE,MAAM,CAAC,EAAD,CAHjB;AAKArW,UAAM,CAACkB,MAAD,CAAN,GAAiBoX,GAAG,GAAGgB,GAAN,GAAYf,GAAG,GAAGmB,GAAlB,GAAwBlB,GAAG,GAAGsB,GAA9B,GAAoCrB,GAAG,GAAGyB,IAA3D;AACAla,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBoX,GAAG,GAAGiB,GAAN,GAAYhB,GAAG,GAAGoB,GAAlB,GAAwBnB,GAAG,GAAGuB,GAA9B,GAAoCtB,GAAG,GAAG0B,IAA/D;AACAna,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBoX,GAAG,GAAGkB,GAAN,GAAYjB,GAAG,GAAGqB,GAAlB,GAAwBpB,GAAG,GAAGwB,IAA9B,GAAqCvB,GAAG,GAAG2B,IAAhE;AACApa,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBoX,GAAG,GAAGmB,GAAN,GAAYlB,GAAG,GAAGsB,GAAlB,GAAwBrB,GAAG,GAAGyB,IAA9B,GAAqCxB,GAAG,GAAG4B,IAAhE;AAEAra,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBwX,GAAG,GAAGY,GAAN,GAAYX,GAAG,GAAGe,GAAlB,GAAwBd,GAAG,GAAGkB,GAA9B,GAAoCjB,GAAG,GAAGqB,IAA/D;AACAla,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBwX,GAAG,GAAGa,GAAN,GAAYZ,GAAG,GAAGgB,GAAlB,GAAwBf,GAAG,GAAGmB,GAA9B,GAAoClB,GAAG,GAAGsB,IAA/D;AACAna,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBwX,GAAG,GAAGc,GAAN,GAAYb,GAAG,GAAGiB,GAAlB,GAAwBhB,GAAG,GAAGoB,IAA9B,GAAqCnB,GAAG,GAAGuB,IAAhE;AACApa,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqBwX,GAAG,GAAGe,GAAN,GAAYd,GAAG,GAAGkB,GAAlB,GAAwBjB,GAAG,GAAGqB,IAA9B,GAAqCpB,GAAG,GAAGwB,IAAhE;AAEAra,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqB4X,GAAG,GAAGQ,GAAN,GAAYP,GAAG,GAAGW,GAAlB,GAAwBV,IAAI,GAAGc,GAA/B,GAAqCb,IAAI,GAAGiB,IAAjE;AACAla,UAAM,CAACkB,MAAM,GAAG,CAAV,CAAN,GAAqB4X,GAAG,GAAGS,GAAN,GAAYR,GAAG,GAAGY,GAAlB,GAAwBX,IAAI,GAAGe,GAA/B,GAAqCd,IAAI,GAAGkB,IAAjE;AACAna,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsB4X,GAAG,GAAGU,GAAN,GAAYT,GAAG,GAAGa,GAAlB,GAAwBZ,IAAI,GAAGgB,IAA/B,GAAsCf,IAAI,GAAGmB,IAAnE;AACApa,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsB4X,GAAG,GAAGW,GAAN,GAAYV,GAAG,GAAGc,GAAlB,GAAwBb,IAAI,GAAGiB,IAA/B,GAAsChB,IAAI,GAAGoB,IAAnE;AAEAra,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsBgY,IAAI,GAAGI,GAAP,GAAaH,IAAI,GAAGO,GAApB,GAA0BN,IAAI,GAAGU,GAAjC,GAAuCT,IAAI,GAAGa,IAApE;AACAla,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsBgY,IAAI,GAAGK,GAAP,GAAaJ,IAAI,GAAGQ,GAApB,GAA0BP,IAAI,GAAGW,GAAjC,GAAuCV,IAAI,GAAGc,IAApE;AACAna,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsBgY,IAAI,GAAGM,GAAP,GAAaL,IAAI,GAAGS,GAApB,GAA0BR,IAAI,GAAGY,IAAjC,GAAwCX,IAAI,GAAGe,IAArE;AACApa,UAAM,CAACkB,MAAM,GAAG,EAAV,CAAN,GAAsBgY,IAAI,GAAGO,GAAP,GAAaN,IAAI,GAAGU,GAApB,GAA0BT,IAAI,GAAGa,IAAjC,GAAwCZ,IAAI,GAAGgB,IAArE;AACA,WAAO,IAAP;AACH,GAzDM;AA2DP;;;;;;;AAKOpT,4BAAP,UAAc7H,KAAd,EAA0C;AACtC,QAAM4G,KAAK,GAAG5G,KAAd;;AACA,QAAI,CAAC4G,KAAL,EAAY;AACR,aAAO,KAAP;AACH;;AAED,QAAI,KAAKyO,WAAL,IAAoBzO,KAAK,CAACyO,WAA9B,EAA2C;AACvC,UAAI,CAAC,KAAKE,gBAAN,IAA0B,CAAC3O,KAAK,CAAC2O,gBAArC,EAAuD;AACnD,eAAO,KAAKF,WAAL,IAAoBzO,KAAK,CAACyO,WAAjC;AACH;AACJ;;AAED,QAAMxR,CAAC,GAAG,KAAKA,CAAf;AACA,QAAMqX,EAAE,GAAGtU,KAAK,CAAC/C,CAAjB;AACA,WACIA,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CAAX,IACArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CADX,IAEArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CAFX,IAGArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CAHX,IAIArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CAJX,IAKArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CALX,IAMArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CANX,IAOArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CAPX,IAQArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CARX,IASArX,CAAC,CAAC,CAAD,CAAD,KAASqX,EAAE,CAAC,CAAD,CATX,IAUArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAVZ,IAWArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAXZ,IAYArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAZZ,IAaArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAbZ,IAcArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAdZ,IAeArX,CAAC,CAAC,EAAD,CAAD,KAAUqX,EAAE,CAAC,EAAD,CAhBhB;AAkBH,GAhCM;AAkCP;;;;;;AAIOrT,2BAAP;AACI,QAAMwE,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAwE,UAAM,CAAC/E,QAAP,CAAgB,IAAhB;AACA,WAAO+E,MAAP;AACH,GAJM;AAMP;;;;;;AAIOxE,kCAAP;AACI,WAAO,QAAP;AACH,GAFM;AAIP;;;;;;AAIOA,iCAAP;AACI,QAAIrH,IAAI,GAAGT,aAAa,CAAC,KAAKgV,EAAL,CAAQ,CAAR,CAAD,CAAxB;;AACA,SAAK,IAAItN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AACzBjH,UAAI,GAAIA,IAAI,GAAG,GAAR,GAAeT,aAAa,CAAC,KAAKgV,EAAL,CAAQtN,CAAR,CAAD,CAAnC;AACH;;AACD,WAAOjH,IAAP;AACH,GANM;AAQP;;;;;;;AAKOqH,8CAAP,UAAgCsT,IAAhC,EAAmD;AAC/CA,QAAI,CAACC,kBAAL,GAA0BD,IAAI,CAACC,kBAAL,IAA2B,IAAI1V,UAAJ,EAArD;AACA,WAAO,KAAK2V,SAAL,CAAeF,IAAI,CAACG,OAApB,EAA6BH,IAAI,CAACC,kBAAlC,EAAsDD,IAAI,CAACI,QAA3D,CAAP;AACH,GAHM;AAKP;;;;;;;;;;AAQO1T,+BAAP,UAAiB1G,KAAjB,EAAkCsO,QAAlC,EAAyD+L,WAAzD,EAAgFC,mBAAhF,EAAmH;AAC/G,QAAI,KAAKpG,WAAT,EAAsB;AAClB,UAAImG,WAAJ,EAAiB;AACbA,mBAAW,CAACE,MAAZ,CAAmB,CAAnB;AACH;;AACD,UAAIva,KAAJ,EAAW;AACPA,aAAK,CAACua,MAAN,CAAa,CAAb;AACH;;AACD,UAAIjM,QAAJ,EAAc;AACVA,gBAAQ,CAACzO,cAAT,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC;AACH;;AACD,aAAO,IAAP;AACH;;AAED,QAAM6C,CAAC,GAAG,KAAKkR,EAAf;;AACA,QAAIyG,WAAJ,EAAiB;AACbA,iBAAW,CAACxa,cAAZ,CAA2B6C,CAAC,CAAC,EAAD,CAA5B,EAAkCA,CAAC,CAAC,EAAD,CAAnC,EAAyCA,CAAC,CAAC,EAAD,CAA1C;AACH;;AAED1C,SAAK,GAAGA,KAAK,IAAIkF,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAjB;AAEArE,SAAK,CAACf,CAAN,GAAUmB,IAAI,CAACK,IAAL,CAAUiC,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAtB,GAA4BA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAA9C,CAAV;AACA1C,SAAK,CAACd,CAAN,GAAUkB,IAAI,CAACK,IAAL,CAAUiC,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAtB,GAA4BA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAA9C,CAAV;AACA1C,SAAK,CAACgE,CAAN,GAAU5D,IAAI,CAACK,IAAL,CAAUiC,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAtB,GAA4BA,CAAC,CAAC,EAAD,CAAD,GAAQA,CAAC,CAAC,EAAD,CAA/C,CAAV;;AAEA,QAAI4X,mBAAJ,EAAyB;AACrB,UAAME,KAAK,GAAGF,mBAAmB,CAACH,OAApB,CAA4Blb,CAA5B,GAAgC,CAAhC,GAAoC,CAAC,CAArC,GAAyC,CAAvD;AACA,UAAMwb,KAAK,GAAGH,mBAAmB,CAACH,OAApB,CAA4Bjb,CAA5B,GAAgC,CAAhC,GAAoC,CAAC,CAArC,GAAyC,CAAvD;AACA,UAAMwb,KAAK,GAAGJ,mBAAmB,CAACH,OAApB,CAA4BnW,CAA5B,GAAgC,CAAhC,GAAoC,CAAC,CAArC,GAAyC,CAAvD;AAEAhE,WAAK,CAACf,CAAN,IAAWub,KAAX;AACAxa,WAAK,CAACd,CAAN,IAAWub,KAAX;AACAza,WAAK,CAACgE,CAAN,IAAW0W,KAAX;AACH,KARD,MAQO;AACH,UAAI,KAAKC,WAAL,MAAsB,CAA1B,EAA6B;AACzB3a,aAAK,CAACd,CAAN,IAAW,CAAC,CAAZ;AACH;AACJ;;AAED,QAAIc,KAAK,CAACiE,EAAN,KAAa,CAAb,IAAkBjE,KAAK,CAACkE,EAAN,KAAa,CAA/B,IAAoClE,KAAK,CAACmE,EAAN,KAAa,CAArD,EAAwD;AACpD,UAAImK,QAAJ,EAAc;AACVA,gBAAQ,CAACzO,cAAT,CAAwB,GAAxB,EAA6B,GAA7B,EAAkC,GAAlC,EAAuC,GAAvC;AACH;;AACD,aAAO,KAAP;AACH;;AAED,QAAIyO,QAAJ,EAAc;AACV,UAAMsM,EAAE,GAAG,IAAI5a,KAAK,CAACiE,EAArB;AAAA,UACI4W,EAAE,GAAG,IAAI7a,KAAK,CAACkE,EADnB;AAAA,UAEI4W,EAAE,GAAG,IAAI9a,KAAK,CAACmE,EAFnB;AAGAuC,YAAM,CAACuE,eAAP,CACIvI,CAAC,CAAC,CAAD,CAAD,GAAOkY,EADX,EAEIlY,CAAC,CAAC,CAAD,CAAD,GAAOkY,EAFX,EAGIlY,CAAC,CAAC,CAAD,CAAD,GAAOkY,EAHX,EAII,GAJJ,EAKIlY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EALX,EAMInY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EANX,EAOInY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EAPX,EAQI,GARJ,EASInY,CAAC,CAAC,CAAD,CAAD,GAAOoY,EATX,EAUIpY,CAAC,CAAC,CAAD,CAAD,GAAOoY,EAVX,EAWIpY,CAAC,CAAC,EAAD,CAAD,GAAQoY,EAXZ,EAYI,GAZJ,EAaI,GAbJ,EAcI,GAdJ,EAeI,GAfJ,EAgBI,GAhBJ,EAiBI5V,OAAO,CAACwB,MAAR,CAAe,CAAf,CAjBJ;AAoBAnC,gBAAU,CAAC2L,uBAAX,CAAmChL,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAnC,EAAsD4H,QAAtD;AACH;;AAED,WAAO,IAAP;AACH,GA1EM;AA4EP;;;;;;;AAKO5H,4BAAP,UAAcnH,KAAd,EAA2B;AACvB,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,CAAzB,EAA4B;AACxB,aAAO,IAAP;AACH;;AACD,QAAM+G,CAAC,GAAG/G,KAAK,GAAG,CAAlB;AACA,WAAO,IAAIyP,OAAJ,CAAY,KAAK4E,EAAL,CAAQtN,CAAC,GAAG,CAAZ,CAAZ,EAA4B,KAAKsN,EAAL,CAAQtN,CAAC,GAAG,CAAZ,CAA5B,EAA4C,KAAKsN,EAAL,CAAQtN,CAAC,GAAG,CAAZ,CAA5C,EAA4D,KAAKsN,EAAL,CAAQtN,CAAC,GAAG,CAAZ,CAA5D,CAAP;AACH,GANM;AAQP;;;;;;;;AAMOI,4BAAP,UAAcnH,KAAd,EAA6Bwb,GAA7B,EAAyC;AACrC,WAAO,KAAKC,gBAAL,CAAsBzb,KAAtB,EAA6Bwb,GAAG,CAAC9b,CAAjC,EAAoC8b,GAAG,CAAC7b,CAAxC,EAA2C6b,GAAG,CAAC/W,CAA/C,EAAkD+W,GAAG,CAAChM,CAAtD,CAAP;AACH,GAFM;AAIP;;;;;;AAIOrI,+BAAP;AACI,WAAOA,MAAM,CAACuU,SAAP,CAAiB,IAAjB,CAAP;AACH,GAFM;AAIP;;;;;;;AAKOvU,oCAAP,UAAsBjH,MAAtB,EAAoC;AAChCiH,UAAM,CAACwU,cAAP,CAAsB,IAAtB,EAA4Bzb,MAA5B;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;;;;;AASOiH,sCAAP,UAAwBnH,KAAxB,EAAuCN,CAAvC,EAAkDC,CAAlD,EAA6D8E,CAA7D,EAAwE+K,CAAxE,EAAiF;AAC7E,QAAIxP,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,CAAzB,EAA4B;AACxB,aAAO,IAAP;AACH;;AACD,QAAM+G,CAAC,GAAG/G,KAAK,GAAG,CAAlB;AACA,SAAKqU,EAAL,CAAQtN,CAAC,GAAG,CAAZ,IAAiBrH,CAAjB;AACA,SAAK2U,EAAL,CAAQtN,CAAC,GAAG,CAAZ,IAAiBpH,CAAjB;AACA,SAAK0U,EAAL,CAAQtN,CAAC,GAAG,CAAZ,IAAiBtC,CAAjB;AACA,SAAK4P,EAAL,CAAQtN,CAAC,GAAG,CAAZ,IAAiByI,CAAjB;AAEA,SAAK+E,aAAL;AACA,WAAO,IAAP;AACH,GAZM;AAcP;;;;;;;AAKOpN,2BAAP,UAAa1G,KAAb,EAA0B;AACtB,QAAMP,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA,SAAKzG,UAAL,CAAgBD,KAAhB,EAAuBP,MAAvB;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMOiH,gCAAP,UAAkB1G,KAAlB,EAAiCP,MAAjC,EAA+C;AAC3C,SAAK,IAAIF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCE,YAAM,CAACmU,EAAP,CAAUrU,KAAV,IAAmB,KAAKqU,EAAL,CAAQrU,KAAR,IAAiBS,KAApC;AACH;;AACDP,UAAM,CAACqU,aAAP;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;AAMOpN,sCAAP,UAAwB1G,KAAxB,EAAuCP,MAAvC,EAAqD;AACjD,SAAK,IAAIF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCE,YAAM,CAACmU,EAAP,CAAUrU,KAAV,KAAoB,KAAKqU,EAAL,CAAQrU,KAAR,IAAiBS,KAArC;AACH;;AACDP,UAAM,CAACqU,aAAP;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIOpN,oCAAP,UAAsBrD,GAAtB,EAAiC;AAC7B,QAAM8J,GAAG,GAAGjI,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAZ;AACA,SAAKiP,WAAL,CAAiBxI,GAAjB;AACAA,OAAG,CAACgO,cAAJ,CAAmB9X,GAAnB;AACA,QAAMX,CAAC,GAAGW,GAAG,CAACuQ,EAAd;AACAlN,UAAM,CAACuE,eAAP,CAAuBvI,CAAC,CAAC,CAAD,CAAxB,EAA6BA,CAAC,CAAC,CAAD,CAA9B,EAAmCA,CAAC,CAAC,CAAD,CAApC,EAAyC,GAAzC,EAA8CA,CAAC,CAAC,CAAD,CAA/C,EAAoDA,CAAC,CAAC,CAAD,CAArD,EAA0DA,CAAC,CAAC,CAAD,CAA3D,EAAgE,GAAhE,EAAqEA,CAAC,CAAC,CAAD,CAAtE,EAA2EA,CAAC,CAAC,CAAD,CAA5E,EAAiFA,CAAC,CAAC,EAAD,CAAlF,EAAwF,GAAxF,EAA6F,GAA7F,EAAkG,GAAlG,EAAuG,GAAvG,EAA4G,GAA5G,EAAiHW,GAAjH;AACH,GANM;AAQP;;;;;;AAIOqD,uCAAP;AACI,QAAMjH,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA,SAAK0U,sBAAL,CAA4B3b,MAA5B;AACA,WAAOA,MAAP;AACH,GAJM;AAMP;;;;;;;AAKOiH,4CAAP,UAA8BjH,MAA9B,EAA4C;AACxC,QAAMO,KAAK,GAAGkF,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;;AACA,QAAI,CAAC,KAAK6V,SAAL,CAAela,KAAf,CAAL,EAA4B;AACxB0G,YAAM,CAACqP,aAAP,CAAqBtW,MAArB;AACA,aAAO,IAAP;AACH;;AAED,QAAMiD,CAAC,GAAG,KAAKkR,EAAf;AACA,QAAMgH,EAAE,GAAG,IAAI5a,KAAK,CAACiE,EAArB;AAAA,QACI4W,EAAE,GAAG,IAAI7a,KAAK,CAACkE,EADnB;AAAA,QAEI4W,EAAE,GAAG,IAAI9a,KAAK,CAACmE,EAFnB;AAGAuC,UAAM,CAACuE,eAAP,CAAuBvI,CAAC,CAAC,CAAD,CAAD,GAAOkY,EAA9B,EAAkClY,CAAC,CAAC,CAAD,CAAD,GAAOkY,EAAzC,EAA6ClY,CAAC,CAAC,CAAD,CAAD,GAAOkY,EAApD,EAAwD,GAAxD,EAA6DlY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EAApE,EAAwEnY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EAA/E,EAAmFnY,CAAC,CAAC,CAAD,CAAD,GAAOmY,EAA1F,EAA8F,GAA9F,EAAmGnY,CAAC,CAAC,CAAD,CAAD,GAAOoY,EAA1G,EAA8GpY,CAAC,CAAC,CAAD,CAAD,GAAOoY,EAArH,EAAyHpY,CAAC,CAAC,EAAD,CAAD,GAAQoY,EAAjI,EAAqI,GAArI,EAA0I,GAA1I,EAA+I,GAA/I,EAAoJ,GAApJ,EAAyJ,GAAzJ,EAA8Jrb,MAA9J;AACA,WAAO,IAAP;AACH,GAbM;AAeP;;;;;AAGOiH,kDAAP;AACI,QAAMhE,CAAC,GAAG,KAAKkR,EAAf;AACAlR,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;AACA,SAAKoR,aAAL;AACH,GARM;AAUP;;;;;AAGOpN,uDAAP;AACI,QAAMhE,CAAC,GAAG,KAAKkR,EAAf;AACAlR,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACAA,KAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;AACAA,KAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;AACA,SAAKoR,aAAL;AACH,GAPM,CAj5BX,CA05BI;;AACA;;;;;;;;AAMcpN,qBAAd,UAAwBpH,KAAxB,EAAiEqB,MAAjE,EAAmF;AAAlB;AAAAA;AAAkB;;AAC/E,QAAMlB,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAClH,cAAP,CAAsBF,KAAtB,EAA6BqB,MAA7B,EAAqClB,MAArC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;AAMciH,0BAAd,UAA6BpH,KAA7B,EAAsEqB,MAAtE,EAAsFlB,MAAtF,EAAoG;AAChG,SAAK,IAAIF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCE,YAAM,CAACmU,EAAP,CAAUrU,KAAV,IAAmBD,KAAK,CAACC,KAAK,GAAGoB,MAAT,CAAxB;AACH;;AACDlB,UAAM,CAACqU,aAAP;AACH,GALa;AAOd;;;;;;;;;AAOcpN,uCAAd,UAA0CpH,KAA1C,EAA8FqB,MAA9F,EAA8GX,KAA9G,EAA6HP,MAA7H,EAA2I;AACvI,SAAK,IAAIF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCE,YAAM,CAACmU,EAAP,CAAUrU,KAAV,IAAmBD,KAAK,CAACC,KAAK,GAAGoB,MAAT,CAAL,GAAwBX,KAA3C;AACH;;AACDP,UAAM,CAACqU,aAAP;AACH,GALa;;AAUd1P,wBAAkBsC,MAAlB,EAAkB,kBAAlB,EAAkC;AAHlC;;;SAGA;AACI,aAAOA,MAAM,CAAC2U,iBAAd;AACH,KAFiC;qBAAA;;AAAA,GAAlC;AAIA;;;;;;;;;;;;;;;;;;;;;AAoBc3U,2BAAd,UACI4U,UADJ,EAEIC,UAFJ,EAGIC,UAHJ,EAIIC,UAJJ,EAKIC,UALJ,EAMIC,UANJ,EAOIC,UAPJ,EAQIC,UARJ,EASIC,UATJ,EAUIC,UAVJ,EAWIC,UAXJ,EAYIC,UAZJ,EAaIC,UAbJ,EAcIC,UAdJ,EAeIC,UAfJ,EAgBIC,UAhBJ,EAiBI5c,MAjBJ,EAiBkB;AAEd,QAAMiD,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;AACAlR,KAAC,CAAC,CAAD,CAAD,GAAO4Y,UAAP;AACA5Y,KAAC,CAAC,CAAD,CAAD,GAAO6Y,UAAP;AACA7Y,KAAC,CAAC,CAAD,CAAD,GAAO8Y,UAAP;AACA9Y,KAAC,CAAC,CAAD,CAAD,GAAO+Y,UAAP;AACA/Y,KAAC,CAAC,CAAD,CAAD,GAAOgZ,UAAP;AACAhZ,KAAC,CAAC,CAAD,CAAD,GAAOiZ,UAAP;AACAjZ,KAAC,CAAC,CAAD,CAAD,GAAOkZ,UAAP;AACAlZ,KAAC,CAAC,CAAD,CAAD,GAAOmZ,UAAP;AACAnZ,KAAC,CAAC,CAAD,CAAD,GAAOoZ,UAAP;AACApZ,KAAC,CAAC,CAAD,CAAD,GAAOqZ,UAAP;AACArZ,KAAC,CAAC,EAAD,CAAD,GAAQsZ,UAAR;AACAtZ,KAAC,CAAC,EAAD,CAAD,GAAQuZ,UAAR;AACAvZ,KAAC,CAAC,EAAD,CAAD,GAAQwZ,UAAR;AACAxZ,KAAC,CAAC,EAAD,CAAD,GAAQyZ,UAAR;AACAzZ,KAAC,CAAC,EAAD,CAAD,GAAQ0Z,UAAR;AACA1Z,KAAC,CAAC,EAAD,CAAD,GAAQ2Z,UAAR;AAEA5c,UAAM,CAACqU,aAAP;AACH,GAtCa;AAwCd;;;;;;;;;;;;;;;;;;;;;;AAoBcpN,sBAAd,UACI4U,UADJ,EAEIC,UAFJ,EAGIC,UAHJ,EAIIC,UAJJ,EAKIC,UALJ,EAMIC,UANJ,EAOIC,UAPJ,EAQIC,UARJ,EASIC,UATJ,EAUIC,UAVJ,EAWIC,UAXJ,EAYIC,UAZJ,EAaIC,UAbJ,EAcIC,UAdJ,EAeIC,UAfJ,EAgBIC,UAhBJ,EAgBsB;AAElB,QAAM5c,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA,QAAMhE,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;AACAlR,KAAC,CAAC,CAAD,CAAD,GAAO4Y,UAAP;AACA5Y,KAAC,CAAC,CAAD,CAAD,GAAO6Y,UAAP;AACA7Y,KAAC,CAAC,CAAD,CAAD,GAAO8Y,UAAP;AACA9Y,KAAC,CAAC,CAAD,CAAD,GAAO+Y,UAAP;AACA/Y,KAAC,CAAC,CAAD,CAAD,GAAOgZ,UAAP;AACAhZ,KAAC,CAAC,CAAD,CAAD,GAAOiZ,UAAP;AACAjZ,KAAC,CAAC,CAAD,CAAD,GAAOkZ,UAAP;AACAlZ,KAAC,CAAC,CAAD,CAAD,GAAOmZ,UAAP;AACAnZ,KAAC,CAAC,CAAD,CAAD,GAAOoZ,UAAP;AACApZ,KAAC,CAAC,CAAD,CAAD,GAAOqZ,UAAP;AACArZ,KAAC,CAAC,EAAD,CAAD,GAAQsZ,UAAR;AACAtZ,KAAC,CAAC,EAAD,CAAD,GAAQuZ,UAAR;AACAvZ,KAAC,CAAC,EAAD,CAAD,GAAQwZ,UAAR;AACAxZ,KAAC,CAAC,EAAD,CAAD,GAAQyZ,UAAR;AACAzZ,KAAC,CAAC,EAAD,CAAD,GAAQ0Z,UAAR;AACA1Z,KAAC,CAAC,EAAD,CAAD,GAAQ2Z,UAAR;AACA5c,UAAM,CAACqU,aAAP;AACA,WAAOrU,MAAP;AACH,GAtCa;AAwCd;;;;;;;;;AAOciH,mBAAd,UAAsB1G,KAAtB,EAAqDsO,QAArD,EAA0F+L,WAA1F,EAA6H;AACzH,QAAM5a,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC4V,YAAP,CAAoBtc,KAApB,EAA2BsO,QAA3B,EAAqC+L,WAArC,EAAkD5a,MAAlD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,wBAAd,UAA2B1G,KAA3B,EAA0DsO,QAA1D,EAA+F+L,WAA/F,EAAoI5a,MAApI,EAAkJ;AAC9I,QAAMiD,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;AACA,QAAM3U,CAAC,GAAGqP,QAAQ,CAACrK,EAAnB;AAAA,QACI/E,CAAC,GAAGoP,QAAQ,CAACpK,EADjB;AAAA,QAEIF,CAAC,GAAGsK,QAAQ,CAACnK,EAFjB;AAAA,QAGI4K,CAAC,GAAGT,QAAQ,CAACY,EAHjB;AAIA,QAAMqN,EAAE,GAAGtd,CAAC,GAAGA,CAAf;AAAA,QACIud,EAAE,GAAGtd,CAAC,GAAGA,CADb;AAAA,QAEIud,EAAE,GAAGzY,CAAC,GAAGA,CAFb;AAGA,QAAM0Y,EAAE,GAAGzd,CAAC,GAAGsd,EAAf;AAAA,QACII,EAAE,GAAG1d,CAAC,GAAGud,EADb;AAAA,QAEII,EAAE,GAAG3d,CAAC,GAAGwd,EAFb;AAGA,QAAMI,EAAE,GAAG3d,CAAC,GAAGsd,EAAf;AAAA,QACIM,EAAE,GAAG5d,CAAC,GAAGud,EADb;AAAA,QAEIM,EAAE,GAAG/Y,CAAC,GAAGyY,EAFb;AAGA,QAAMO,EAAE,GAAGjO,CAAC,GAAGwN,EAAf;AAAA,QACIU,EAAE,GAAGlO,CAAC,GAAGyN,EADb;AAAA,QAEIU,EAAE,GAAGnO,CAAC,GAAG0N,EAFb;AAIA,QAAM7B,EAAE,GAAG5a,KAAK,CAACiE,EAAjB;AAAA,QACI4W,EAAE,GAAG7a,KAAK,CAACkE,EADf;AAAA,QAEI4W,EAAE,GAAG9a,KAAK,CAACmE,EAFf;AAIAzB,KAAC,CAAC,CAAD,CAAD,GAAO,CAAC,KAAKma,EAAE,GAAGE,EAAV,CAAD,IAAkBnC,EAAzB;AACAlY,KAAC,CAAC,CAAD,CAAD,GAAO,CAACia,EAAE,GAAGO,EAAN,IAAYtC,EAAnB;AACAlY,KAAC,CAAC,CAAD,CAAD,GAAO,CAACka,EAAE,GAAGK,EAAN,IAAYrC,EAAnB;AACAlY,KAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAEAA,KAAC,CAAC,CAAD,CAAD,GAAO,CAACia,EAAE,GAAGO,EAAN,IAAYrC,EAAnB;AACAnY,KAAC,CAAC,CAAD,CAAD,GAAO,CAAC,KAAKga,EAAE,GAAGK,EAAV,CAAD,IAAkBlC,EAAzB;AACAnY,KAAC,CAAC,CAAD,CAAD,GAAO,CAACoa,EAAE,GAAGE,EAAN,IAAYnC,EAAnB;AACAnY,KAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAEAA,KAAC,CAAC,CAAD,CAAD,GAAO,CAACka,EAAE,GAAGK,EAAN,IAAYnC,EAAnB;AACApY,KAAC,CAAC,CAAD,CAAD,GAAO,CAACoa,EAAE,GAAGE,EAAN,IAAYlC,EAAnB;AACApY,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,KAAKga,EAAE,GAAGG,EAAV,CAAD,IAAkB/B,EAA1B;AACApY,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAEAA,KAAC,CAAC,EAAD,CAAD,GAAQ2X,WAAW,CAACpW,EAApB;AACAvB,KAAC,CAAC,EAAD,CAAD,GAAQ2X,WAAW,CAACnW,EAApB;AACAxB,KAAC,CAAC,EAAD,CAAD,GAAQ2X,WAAW,CAAClW,EAApB;AACAzB,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAEAjD,UAAM,CAACqU,aAAP;AACH,GA5Ca;AA8Cd;;;;;;AAIcpN,oBAAd;AACI,QAAMyW,QAAQ,GAAGzW,MAAM,CAAC0W,UAAP,CAAkB,GAAlB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F,CAAjB;;AACAD,YAAQ,CAACvH,qBAAT,CAA+B,IAA/B;;AACA,WAAOuH,QAAP;AACH,GAJa;AAMd;;;;;;AAIczW,yBAAd,UAA4BjH,MAA5B,EAA0C;AACtCiH,UAAM,CAACuE,eAAP,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F,EAAkG,GAAlG,EAAuGxL,MAAvG;;AACAA,UAAM,CAACmW,qBAAP,CAA6B,IAA7B;AACH,GAHa;AAKd;;;;;;AAIclP,gBAAd;AACI,QAAM2W,IAAI,GAAG3W,MAAM,CAAC0W,UAAP,CAAkB,GAAlB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,GAA7F,CAAb;;AACAC,QAAI,CAACzH,qBAAL,CAA2B,KAA3B;;AACA,WAAOyH,IAAP;AACH,GAJa;AAMd;;;;;;;AAKc3W,qBAAd,UAAwBpG,KAAxB,EAAqC;AACjC,QAAMb,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC4W,cAAP,CAAsBhd,KAAtB,EAA6Bb,MAA7B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKciH,kBAAd,UAAqB9G,MAArB,EAAkD;AAC9C,QAAMH,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACA9G,UAAM,CAAC+V,WAAP,CAAmBlW,MAAnB;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKciH,0BAAd,UAA6BpG,KAA7B,EAA4Cb,MAA5C,EAA0D;AACtD,QAAMwD,CAAC,GAAG7C,IAAI,CAACI,GAAL,CAASF,KAAT,CAAV;AACA,QAAMid,CAAC,GAAGnd,IAAI,CAACG,GAAL,CAASD,KAAT,CAAV;AACAoG,UAAM,CAACuE,eAAP,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgDsS,CAAhD,EAAmDta,CAAnD,EAAsD,GAAtD,EAA2D,GAA3D,EAAgE,CAACA,CAAjE,EAAoEsa,CAApE,EAAuE,GAAvE,EAA4E,GAA5E,EAAiF,GAAjF,EAAsF,GAAtF,EAA2F,GAA3F,EAAgG9d,MAAhG;;AAEAA,UAAM,CAACmW,qBAAP,CAA6B2H,CAAC,KAAK,CAAN,IAAWta,CAAC,KAAK,CAA9C;AACH,GANa;AAQd;;;;;;;AAKcyD,qBAAd,UAAwBpG,KAAxB,EAAqC;AACjC,QAAMb,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC8W,cAAP,CAAsBld,KAAtB,EAA6Bb,MAA7B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKciH,0BAAd,UAA6BpG,KAA7B,EAA4Cb,MAA5C,EAA0D;AACtD,QAAMwD,CAAC,GAAG7C,IAAI,CAACI,GAAL,CAASF,KAAT,CAAV;AACA,QAAMid,CAAC,GAAGnd,IAAI,CAACG,GAAL,CAASD,KAAT,CAAV;AACAoG,UAAM,CAACuE,eAAP,CAAuBsS,CAAvB,EAA0B,GAA1B,EAA+B,CAACta,CAAhC,EAAmC,GAAnC,EAAwC,GAAxC,EAA6C,GAA7C,EAAkD,GAAlD,EAAuD,GAAvD,EAA4DA,CAA5D,EAA+D,GAA/D,EAAoEsa,CAApE,EAAuE,GAAvE,EAA4E,GAA5E,EAAiF,GAAjF,EAAsF,GAAtF,EAA2F,GAA3F,EAAgG9d,MAAhG;;AAEAA,UAAM,CAACmW,qBAAP,CAA6B2H,CAAC,KAAK,CAAN,IAAWta,CAAC,KAAK,CAA9C;AACH,GANa;AAQd;;;;;;;AAKcyD,qBAAd,UAAwBpG,KAAxB,EAAqC;AACjC,QAAMb,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC+W,cAAP,CAAsBnd,KAAtB,EAA6Bb,MAA7B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKciH,0BAAd,UAA6BpG,KAA7B,EAA4Cb,MAA5C,EAA0D;AACtD,QAAMwD,CAAC,GAAG7C,IAAI,CAACI,GAAL,CAASF,KAAT,CAAV;AACA,QAAMid,CAAC,GAAGnd,IAAI,CAACG,GAAL,CAASD,KAAT,CAAV;AACAoG,UAAM,CAACuE,eAAP,CAAuBsS,CAAvB,EAA0Bta,CAA1B,EAA6B,GAA7B,EAAkC,GAAlC,EAAuC,CAACA,CAAxC,EAA2Csa,CAA3C,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,GAAvE,EAA4E,GAA5E,EAAiF,GAAjF,EAAsF,GAAtF,EAA2F,GAA3F,EAAgG9d,MAAhG;;AAEAA,UAAM,CAACmW,qBAAP,CAA6B2H,CAAC,KAAK,CAAN,IAAWta,CAAC,KAAK,CAA9C;AACH,GANa;AAQd;;;;;;;;AAMcyD,wBAAd,UAA2BU,IAA3B,EAAyD9G,KAAzD,EAAsE;AAClE,QAAMb,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACwK,iBAAP,CAAyB9J,IAAzB,EAA+B9G,KAA/B,EAAsCb,MAAtC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;AAMciH,6BAAd,UAAgCU,IAAhC,EAA8D9G,KAA9D,EAA6Eb,MAA7E,EAA2F;AACvF,QAAMwD,CAAC,GAAG7C,IAAI,CAACI,GAAL,CAAS,CAACF,KAAV,CAAV;AACA,QAAMid,CAAC,GAAGnd,IAAI,CAACG,GAAL,CAAS,CAACD,KAAV,CAAV;AACA,QAAMod,EAAE,GAAG,IAAIH,CAAf;AAEAnW,QAAI,CAAChC,SAAL;AACA,QAAM1C,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;AACAlR,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAACnD,EAAL,GAAUmD,IAAI,CAACnD,EAAf,GAAoByZ,EAApB,GAAyBH,CAAhC;AACA7a,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAACnD,EAAL,GAAUmD,IAAI,CAAClD,EAAf,GAAoBwZ,EAApB,GAAyBtW,IAAI,CAACjD,EAAL,GAAUlB,CAA1C;AACAP,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAACnD,EAAL,GAAUmD,IAAI,CAACjD,EAAf,GAAoBuZ,EAApB,GAAyBtW,IAAI,CAAClD,EAAL,GAAUjB,CAA1C;AACAP,KAAC,CAAC,CAAD,CAAD,GAAO,GAAP;AAEAA,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAAClD,EAAL,GAAUkD,IAAI,CAACnD,EAAf,GAAoByZ,EAApB,GAAyBtW,IAAI,CAACjD,EAAL,GAAUlB,CAA1C;AACAP,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAAClD,EAAL,GAAUkD,IAAI,CAAClD,EAAf,GAAoBwZ,EAApB,GAAyBH,CAAhC;AACA7a,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAAClD,EAAL,GAAUkD,IAAI,CAACjD,EAAf,GAAoBuZ,EAApB,GAAyBtW,IAAI,CAACnD,EAAL,GAAUhB,CAA1C;AACAP,KAAC,CAAC,CAAD,CAAD,GAAO,GAAP;AAEAA,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAACjD,EAAL,GAAUiD,IAAI,CAACnD,EAAf,GAAoByZ,EAApB,GAAyBtW,IAAI,CAAClD,EAAL,GAAUjB,CAA1C;AACAP,KAAC,CAAC,CAAD,CAAD,GAAO0E,IAAI,CAACjD,EAAL,GAAUiD,IAAI,CAAClD,EAAf,GAAoBwZ,EAApB,GAAyBtW,IAAI,CAACnD,EAAL,GAAUhB,CAA1C;AACAP,KAAC,CAAC,EAAD,CAAD,GAAQ0E,IAAI,CAACjD,EAAL,GAAUiD,IAAI,CAACjD,EAAf,GAAoBuZ,EAApB,GAAyBH,CAAjC;AACA7a,KAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AAEAA,KAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AAEAjD,UAAM,CAACqU,aAAP;AACH,GA5Ba;AA8Bd;;;;;;;;;AAOcpN,8BAAd,UAAiCiX,IAAjC,EAA+DC,EAA/D,EAA2Fne,MAA3F,EAAyG;AACrG,QAAM8d,CAAC,GAAGlZ,OAAO,CAACT,GAAR,CAAYga,EAAZ,EAAgBD,IAAhB,CAAV;AACA,QAAMjb,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;;AACA,QAAI2J,CAAC,GAAG,CAAC,CAAD,GAAKhf,OAAb,EAAsB;AAClB;AACA;AACAmE,OAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAR;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAR;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACAA,OAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACH,KAfD,MAeO;AACH,UAAMgB,CAAC,GAAGW,OAAO,CAACyC,KAAR,CAAc8W,EAAd,EAAkBD,IAAlB,CAAV;AACA,UAAME,CAAC,GAAG,KAAK,IAAIN,CAAT,CAAV;AAEA7a,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACO,EAAF,GAAOP,CAAC,CAACO,EAAT,GAAc4Z,CAAd,GAAkBN,CAAzB;AACA7a,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACQ,EAAF,GAAOR,CAAC,CAACO,EAAT,GAAc4Z,CAAd,GAAkBna,CAAC,CAACS,EAA3B;AACAzB,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACS,EAAF,GAAOT,CAAC,CAACO,EAAT,GAAc4Z,CAAd,GAAkBna,CAAC,CAACQ,EAA3B;AACAxB,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACO,EAAF,GAAOP,CAAC,CAACQ,EAAT,GAAc2Z,CAAd,GAAkBna,CAAC,CAACS,EAA3B;AACAzB,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACQ,EAAF,GAAOR,CAAC,CAACQ,EAAT,GAAc2Z,CAAd,GAAkBN,CAAzB;AACA7a,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACS,EAAF,GAAOT,CAAC,CAACQ,EAAT,GAAc2Z,CAAd,GAAkBna,CAAC,CAACO,EAA3B;AACAvB,OAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACAA,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACO,EAAF,GAAOP,CAAC,CAACS,EAAT,GAAc0Z,CAAd,GAAkBna,CAAC,CAACQ,EAA3B;AACAxB,OAAC,CAAC,CAAD,CAAD,GAAOgB,CAAC,CAACQ,EAAF,GAAOR,CAAC,CAACS,EAAT,GAAc0Z,CAAd,GAAkBna,CAAC,CAACO,EAA3B;AACAvB,OAAC,CAAC,EAAD,CAAD,GAAQgB,CAAC,CAACS,EAAF,GAAOT,CAAC,CAACS,EAAT,GAAc0Z,CAAd,GAAkBN,CAA1B;AACA7a,OAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACH;;AACDA,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AACAjD,UAAM,CAACqU,aAAP;AACH,GAxCa;AA0Cd;;;;;;;;;AAOcpN,gCAAd,UAAmC8K,GAAnC,EAAgDC,KAAhD,EAA+DC,IAA/D,EAA2E;AACvE,QAAMjS,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACyK,yBAAP,CAAiCK,GAAjC,EAAsCC,KAAtC,EAA6CC,IAA7C,EAAmDjS,MAAnD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,qCAAd,UAAwC8K,GAAxC,EAAqDC,KAArD,EAAoEC,IAApE,EAAkFjS,MAAlF,EAAgG;AAC5F8E,cAAU,CAAC4M,yBAAX,CAAqCK,GAArC,EAA0CC,KAA1C,EAAiDC,IAAjD,EAAuDxM,OAAO,CAACX,UAAR,CAAmB,CAAnB,CAAvD;AACAW,WAAO,CAACX,UAAR,CAAmB,CAAnB,EAAsBkC,gBAAtB,CAAuChH,MAAvC;AACH,GAHa;AAKd;;;;;;;;;AAOciH,mBAAd,UAAsBzH,CAAtB,EAAiCC,CAAjC,EAA4C8E,CAA5C,EAAqD;AACjD,QAAMvE,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACoX,YAAP,CAAoB7e,CAApB,EAAuBC,CAAvB,EAA0B8E,CAA1B,EAA6BvE,MAA7B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,wBAAd,UAA2BzH,CAA3B,EAAsCC,CAAtC,EAAiD8E,CAAjD,EAA4DvE,MAA5D,EAA0E;AACtEiH,UAAM,CAACuE,eAAP,CAAuBhM,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8CC,CAA9C,EAAiD,GAAjD,EAAsD,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE8E,CAArE,EAAwE,GAAxE,EAA6E,GAA7E,EAAkF,GAAlF,EAAuF,GAAvF,EAA4F,GAA5F,EAAiGvE,MAAjG;;AAEAA,UAAM,CAACmW,qBAAP,CAA6B3W,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAAjB,IAAsB8E,CAAC,KAAK,CAAzD;AACH,GAJa;AAMd;;;;;;;;;AAOc0C,uBAAd,UAA0BzH,CAA1B,EAAqCC,CAArC,EAAgD8E,CAAhD,EAAyD;AACrD,QAAMvE,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACqX,gBAAP,CAAwB9e,CAAxB,EAA2BC,CAA3B,EAA8B8E,CAA9B,EAAiCvE,MAAjC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,4BAAd,UAA+BzH,CAA/B,EAA0CC,CAA1C,EAAqD8E,CAArD,EAAgEvE,MAAhE,EAA8E;AAC1EiH,UAAM,CAACuE,eAAP,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD,EAAqD,GAArD,EAA0D,GAA1D,EAA+D,GAA/D,EAAoE,GAApE,EAAyE,GAAzE,EAA8E,GAA9E,EAAmFhM,CAAnF,EAAsFC,CAAtF,EAAyF8E,CAAzF,EAA4F,GAA5F,EAAiGvE,MAAjG;;AACAA,UAAM,CAACmW,qBAAP,CAA6B3W,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAAjB,IAAsB8E,CAAC,KAAK,CAAzD;AACH,GAHa;AAKd;;;;;;;;;AAOc0C,gBAAd,UAAmBsX,UAAnB,EAAsDC,QAAtD,EAAuFC,QAAvF,EAAuG;AACnG,QAAMze,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC2D,SAAP,CAAiB2T,UAAjB,EAA6BC,QAA7B,EAAuCC,QAAvC,EAAiDze,MAAjD;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,qBAAd,UAAwBsX,UAAxB,EAA2DC,QAA3D,EAA4FC,QAA5F,EAA8Gze,MAA9G,EAA4H;AACxH,QAAMoW,OAAO,GAAGpW,MAAM,CAACmU,EAAvB;AACA,QAAMuK,MAAM,GAAGH,UAAU,CAACtb,CAA1B;AACA,QAAM0b,IAAI,GAAGH,QAAQ,CAACvb,CAAtB;;AACA,SAAK,IAAInD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACrCsW,aAAO,CAACtW,KAAD,CAAP,GAAiB4e,MAAM,CAAC5e,KAAD,CAAN,IAAiB,MAAM2e,QAAvB,IAAmCE,IAAI,CAAC7e,KAAD,CAAJ,GAAc2e,QAAlE;AACH;;AACDze,UAAM,CAACqU,aAAP;AACH,GARa;AAUd;;;;;;;;;;;;AAUcpN,yBAAd,UAA4BsX,UAA5B,EAA+DC,QAA/D,EAAgGC,QAAhG,EAAgH;AAC5G,QAAMze,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAAC2X,kBAAP,CAA0BL,UAA1B,EAAsCC,QAAtC,EAAgDC,QAAhD,EAA0Dze,MAA1D;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;AAUciH,8BAAd,UAAiCsX,UAAjC,EAAoEC,QAApE,EAAqGC,QAArG,EAAuHze,MAAvH,EAAqI;AACjI,QAAM6e,UAAU,GAAGpZ,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAnB;AACA,QAAMka,aAAa,GAAGrZ,OAAO,CAACX,UAAR,CAAmB,CAAnB,CAAtB;AACA,QAAMia,gBAAgB,GAAGtZ,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAzB;AACA2Z,cAAU,CAAC9D,SAAX,CAAqBoE,UAArB,EAAiCC,aAAjC,EAAgDC,gBAAhD;AAEA,QAAMC,QAAQ,GAAGvZ,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAjB;AACA,QAAMqa,WAAW,GAAGxZ,OAAO,CAACX,UAAR,CAAmB,CAAnB,CAApB;AACA,QAAMoa,cAAc,GAAGzZ,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAvB;AACA4Z,YAAQ,CAAC/D,SAAT,CAAmBuE,QAAnB,EAA6BC,WAA7B,EAA0CC,cAA1C;AAEA,QAAMC,WAAW,GAAG1Z,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAApB;AACAA,WAAO,CAACgG,SAAR,CAAkBiU,UAAlB,EAA8BG,QAA9B,EAAwCP,QAAxC,EAAkDU,WAAlD;AACA,QAAMC,cAAc,GAAG3Z,OAAO,CAACX,UAAR,CAAmB,CAAnB,CAAvB;AACAA,cAAU,CAAC2E,UAAX,CAAsBqV,aAAtB,EAAqCG,WAArC,EAAkDR,QAAlD,EAA4DW,cAA5D;AAEA,QAAMC,iBAAiB,GAAG5Z,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAA1B;AACAA,WAAO,CAACgG,SAAR,CAAkBmU,gBAAlB,EAAoCG,cAApC,EAAoDT,QAApD,EAA8DY,iBAA9D;AAEApY,UAAM,CAAC4V,YAAP,CAAoBsC,WAApB,EAAiCC,cAAjC,EAAiDC,iBAAjD,EAAoErf,MAApE;AACH,GApBa;AAsBd;;;;;;;;;;AAQciH,oBAAd,UAAuBqY,GAAvB,EAAoDC,MAApD,EAAoFnM,EAApF,EAA8G;AAC1G,QAAMpT,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACuY,aAAP,CAAqBF,GAArB,EAA0BC,MAA1B,EAAkCnM,EAAlC,EAAsCpT,MAAtC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQciH,yBAAd,UAA4BqY,GAA5B,EAAyDC,MAAzD,EAAyFnM,EAAzF,EAAqHpT,MAArH,EAAmI;AAC/H,QAAMyf,KAAK,GAAGha,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM8a,KAAK,GAAGja,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM+a,KAAK,GAAGla,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd,CAH+H,CAK/H;;AACA2a,UAAM,CAAC7Z,aAAP,CAAqB4Z,GAArB,EAA0BK,KAA1B;AACAA,SAAK,CAACha,SAAN,GAP+H,CAS/H;;AACAf,WAAO,CAACuD,UAAR,CAAmBiL,EAAnB,EAAuBuM,KAAvB,EAA8BF,KAA9B;AAEA,QAAMG,aAAa,GAAGH,KAAK,CAACI,aAAN,EAAtB;;AACA,QAAID,aAAa,KAAK,CAAtB,EAAyB;AACrBH,WAAK,CAACjgB,CAAN,GAAU,GAAV;AACH,KAFD,MAEO;AACHigB,WAAK,CAAClZ,mBAAN,CAA0B5F,IAAI,CAACK,IAAL,CAAU4e,aAAV,CAA1B;AACH,KAjB8H,CAmB/H;;;AACAhb,WAAO,CAACuD,UAAR,CAAmBwX,KAAnB,EAA0BF,KAA1B,EAAiCC,KAAjC;AACAA,SAAK,CAAC/Z,SAAN,GArB+H,CAuB/H;;AACA,QAAMma,EAAE,GAAG,CAAClb,OAAO,CAACT,GAAR,CAAYsb,KAAZ,EAAmBH,GAAnB,CAAZ;AACA,QAAMS,EAAE,GAAG,CAACnb,OAAO,CAACT,GAAR,CAAYub,KAAZ,EAAmBJ,GAAnB,CAAZ;AACA,QAAMU,EAAE,GAAG,CAACpb,OAAO,CAACT,GAAR,CAAYwb,KAAZ,EAAmBL,GAAnB,CAAZ;AAEArY,UAAM,CAACuE,eAAP,CAAuBiU,KAAK,CAACjb,EAA7B,EAAiCkb,KAAK,CAAClb,EAAvC,EAA2Cmb,KAAK,CAACnb,EAAjD,EAAqD,GAArD,EAA0Dib,KAAK,CAAChb,EAAhE,EAAoEib,KAAK,CAACjb,EAA1E,EAA8Ekb,KAAK,CAAClb,EAApF,EAAwF,GAAxF,EAA6Fgb,KAAK,CAAC/a,EAAnG,EAAuGgb,KAAK,CAAChb,EAA7G,EAAiHib,KAAK,CAACjb,EAAvH,EAA2H,GAA3H,EAAgIob,EAAhI,EAAoIC,EAApI,EAAwIC,EAAxI,EAA4I,GAA5I,EAAiJhgB,MAAjJ;AACH,GA7Ba;AA+Bd;;;;;;;;;;AAQciH,oBAAd,UAAuBqY,GAAvB,EAAoDC,MAApD,EAAoFnM,EAApF,EAA8G;AAC1G,QAAMpT,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACgZ,aAAP,CAAqBX,GAArB,EAA0BC,MAA1B,EAAkCnM,EAAlC,EAAsCpT,MAAtC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQciH,yBAAd,UAA4BqY,GAA5B,EAAyDC,MAAzD,EAAyFnM,EAAzF,EAAqHpT,MAArH,EAAmI;AAC/H,QAAMyf,KAAK,GAAGha,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM8a,KAAK,GAAGja,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM+a,KAAK,GAAGla,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd,CAH+H,CAK/H;;AACA0a,OAAG,CAAC5Z,aAAJ,CAAkB6Z,MAAlB,EAA0BI,KAA1B;AACAA,SAAK,CAACha,SAAN,GAP+H,CAS/H;;AACAf,WAAO,CAACuD,UAAR,CAAmBiL,EAAnB,EAAuBuM,KAAvB,EAA8BF,KAA9B;AAEA,QAAMG,aAAa,GAAGH,KAAK,CAACI,aAAN,EAAtB;;AACA,QAAID,aAAa,KAAK,CAAtB,EAAyB;AACrBH,WAAK,CAACjgB,CAAN,GAAU,GAAV;AACH,KAFD,MAEO;AACHigB,WAAK,CAAClZ,mBAAN,CAA0B5F,IAAI,CAACK,IAAL,CAAU4e,aAAV,CAA1B;AACH,KAjB8H,CAmB/H;;;AACAhb,WAAO,CAACuD,UAAR,CAAmBwX,KAAnB,EAA0BF,KAA1B,EAAiCC,KAAjC;AACAA,SAAK,CAAC/Z,SAAN,GArB+H,CAuB/H;;AACA,QAAMma,EAAE,GAAG,CAAClb,OAAO,CAACT,GAAR,CAAYsb,KAAZ,EAAmBH,GAAnB,CAAZ;AACA,QAAMS,EAAE,GAAG,CAACnb,OAAO,CAACT,GAAR,CAAYub,KAAZ,EAAmBJ,GAAnB,CAAZ;AACA,QAAMU,EAAE,GAAG,CAACpb,OAAO,CAACT,GAAR,CAAYwb,KAAZ,EAAmBL,GAAnB,CAAZ;AAEArY,UAAM,CAACuE,eAAP,CAAuBiU,KAAK,CAACjb,EAA7B,EAAiCkb,KAAK,CAAClb,EAAvC,EAA2Cmb,KAAK,CAACnb,EAAjD,EAAqD,GAArD,EAA0Dib,KAAK,CAAChb,EAAhE,EAAoEib,KAAK,CAACjb,EAA1E,EAA8Ekb,KAAK,CAAClb,EAApF,EAAwF,GAAxF,EAA6Fgb,KAAK,CAAC/a,EAAnG,EAAuGgb,KAAK,CAAChb,EAA7G,EAAiHib,KAAK,CAACjb,EAAvH,EAA2H,GAA3H,EAAgIob,EAAhI,EAAoIC,EAApI,EAAwIC,EAAxI,EAA4I,GAA5I,EAAiJhgB,MAAjJ;AACH,GA7Ba;AA+Bd;;;;;;;;;AAOciH,2BAAd,UAA8BsB,OAA9B,EAA+D6K,EAA/D,EAAyF;AACrF,QAAMpT,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACqM,oBAAP,CAA4B/K,OAA5B,EAAqC6K,EAArC,EAAyCpT,MAAzC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,gCAAd,UAAmCsB,OAAnC,EAAoE6K,EAApE,EAAgGpT,MAAhG,EAA8G;AAC1G,QAAMkgB,IAAI,GAAGza,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACAsb,QAAI,CAACxZ,QAAL,CAAc6B,OAAd;AACA2X,QAAI,CAACpa,YAAL,CAAkB,CAAC,CAAnB;AACA,QAAMtD,IAAI,GAAGiD,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAb;AACAA,WAAO,CAACuD,UAAR,CAAmBiL,EAAnB,EAAuB8M,IAAvB,EAA6B1d,IAA7B,EAL0G,CAO1G;;AACAyE,UAAM,CAACuE,eAAP,CAAuBhJ,IAAI,CAACgC,EAA5B,EAAgChC,IAAI,CAACiC,EAArC,EAAyCjC,IAAI,CAACkC,EAA9C,EAAkD,GAAlD,EAAuD0O,EAAE,CAAC5O,EAA1D,EAA8D4O,EAAE,CAAC3O,EAAjE,EAAqE2O,EAAE,CAAC1O,EAAxE,EAA4E,GAA5E,EAAiFwb,IAAI,CAAC1b,EAAtF,EAA0F0b,IAAI,CAACzb,EAA/F,EAAmGyb,IAAI,CAACxb,EAAxG,EAA4G,GAA5G,EAAiH,CAAjH,EAAoH,CAApH,EAAuH,CAAvH,EAA0H,GAA1H,EAA+H1E,MAA/H;AACH,GATa;AAWd;;;;;;;;;AAOciH,2BAAd,UAA8BsB,OAA9B,EAA+D6K,EAA/D,EAAyF;AACrF,QAAMpT,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACuM,oBAAP,CAA4BjL,OAA5B,EAAqC6K,EAArC,EAAyCpT,MAAzC;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOciH,gCAAd,UAAmCsB,OAAnC,EAAoE6K,EAApE,EAAgGpT,MAAhG,EAA8G;AAC1G,QAAMyC,KAAK,GAAGgD,OAAO,CAACb,OAAR,CAAgB,CAAhB,CAAd;AACAA,WAAO,CAACuD,UAAR,CAAmBiL,EAAnB,EAAuB7K,OAAvB,EAAgC9F,KAAhC,EAF0G,CAI1G;;AACAwE,UAAM,CAACuE,eAAP,CAAuB/I,KAAK,CAAC+B,EAA7B,EAAiC/B,KAAK,CAACgC,EAAvC,EAA2ChC,KAAK,CAACiC,EAAjD,EAAqD,GAArD,EAA0D0O,EAAE,CAAC5O,EAA7D,EAAiE4O,EAAE,CAAC3O,EAApE,EAAwE2O,EAAE,CAAC1O,EAA3E,EAA+E,GAA/E,EAAoF6D,OAAO,CAAC/D,EAA5F,EAAgG+D,OAAO,CAAC9D,EAAxG,EAA4G8D,OAAO,CAAC7D,EAApH,EAAwH,GAAxH,EAA6H,CAA7H,EAAgI,CAAhI,EAAmI,CAAnI,EAAsI,GAAtI,EAA2I1E,MAA3I;AACH,GANa;AAQd;;;;;;;;;;;AASciH,mBAAd,UAAsBiE,KAAtB,EAAqCE,MAArC,EAAqD+U,KAArD,EAAoEC,IAApE,EAAkFC,UAAlF,EAAsG;AAClG,QAAM5U,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAACqZ,YAAP,CAAoBpV,KAApB,EAA2BE,MAA3B,EAAmC+U,KAAnC,EAA0CC,IAA1C,EAAgD3U,MAAhD,EAAwD4U,UAAxD;AACA,WAAO5U,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;AAScxE,wBAAd,UAA2BiE,KAA3B,EAA0CE,MAA1C,EAA0D+U,KAA1D,EAAyEC,IAAzE,EAAuFpgB,MAAvF,EAAuGqgB,UAAvG,EAA2H;AACvH,QAAMhb,CAAC,GAAG8a,KAAV;AACA,QAAMI,CAAC,GAAGH,IAAV;AAEA,QAAM9c,CAAC,GAAG,MAAM4H,KAAhB;AACA,QAAMsV,CAAC,GAAG,MAAMpV,MAAhB;AACA,QAAM0S,CAAC,GAAG,OAAOyC,CAAC,GAAGlb,CAAX,CAAV;AACA,QAAME,CAAC,GAAG,EAAEgb,CAAC,GAAGlb,CAAN,KAAYkb,CAAC,GAAGlb,CAAhB,CAAV;AAEA4B,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsD,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE1C,CAArE,EAAwE,GAAxE,EAA6E,GAA7E,EAAkF,GAAlF,EAAuFvY,CAAvF,EAA0F,GAA1F,EAA+FvF,MAA/F;;AAEA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACmW,qBAAP,CAA6B7S,CAAC,KAAK,CAAN,IAAWkd,CAAC,KAAK,CAAjB,IAAsB1C,CAAC,KAAK,CAA5B,IAAiCvY,CAAC,KAAK,CAApE;AACH,GAhBa;AAkBd;;;;;;;;;;;;;AAWc0B,4BAAd,UAA+BzE,IAA/B,EAA6CC,KAA7C,EAA4Die,MAA5D,EAA4EC,GAA5E,EAAyFR,KAAzF,EAAwGC,IAAxG,EAAsHC,UAAtH,EAA0I;AACtI,QAAM5U,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAAC2Z,qBAAP,CAA6Bpe,IAA7B,EAAmCC,KAAnC,EAA0Cie,MAA1C,EAAkDC,GAAlD,EAAuDR,KAAvD,EAA8DC,IAA9D,EAAoE3U,MAApE,EAA4E4U,UAA5E;AACA,WAAO5U,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;;AAWcxE,iCAAd,UAAoCzE,IAApC,EAAkDC,KAAlD,EAAiEie,MAAjE,EAAiFC,GAAjF,EAA8FR,KAA9F,EAA6GC,IAA7G,EAA2HpgB,MAA3H,EAA2IqgB,UAA3I,EAA+J;AAC3J,QAAMhb,CAAC,GAAG8a,KAAV;AACA,QAAMI,CAAC,GAAGH,IAAV;AAEA,QAAM9c,CAAC,GAAG,OAAOb,KAAK,GAAGD,IAAf,CAAV;AACA,QAAMge,CAAC,GAAG,OAAOG,GAAG,GAAGD,MAAb,CAAV;AACA,QAAM5C,CAAC,GAAG,OAAOyC,CAAC,GAAGlb,CAAX,CAAV;AACA,QAAME,CAAC,GAAG,EAAEgb,CAAC,GAAGlb,CAAN,KAAYkb,CAAC,GAAGlb,CAAhB,CAAV;AACA,QAAMwb,EAAE,GAAG,CAACre,IAAI,GAAGC,KAAR,KAAkBD,IAAI,GAAGC,KAAzB,CAAX;AACA,QAAMqe,EAAE,GAAG,CAACH,GAAG,GAAGD,MAAP,KAAkBA,MAAM,GAAGC,GAA3B,CAAX;AAEA1Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsD,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE1C,CAArE,EAAwE,GAAxE,EAA6E+C,EAA7E,EAAiFC,EAAjF,EAAqFvb,CAArF,EAAwF,GAAxF,EAA6FvF,MAA7F;;AAEA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACqU,aAAP;AACH,GAlBa;AAoBd;;;;;;;;;;;;;AAWcpN,4BAAd,UAA+BzE,IAA/B,EAA6CC,KAA7C,EAA4Die,MAA5D,EAA4EC,GAA5E,EAAyFR,KAAzF,EAAwGC,IAAxG,EAAsHC,UAAtH,EAA0I;AACtI,QAAM5U,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAAC8Z,qBAAP,CAA6Bve,IAA7B,EAAmCC,KAAnC,EAA0Cie,MAA1C,EAAkDC,GAAlD,EAAuDR,KAAvD,EAA8DC,IAA9D,EAAoE3U,MAApE,EAA4E4U,UAA5E;AACA,WAAO5U,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;;AAWcxE,iCAAd,UAAoCzE,IAApC,EAAkDC,KAAlD,EAAiEie,MAAjE,EAAiFC,GAAjF,EAA8FR,KAA9F,EAA6GC,IAA7G,EAA2HpgB,MAA3H,EAA2IqgB,UAA3I,EAA+J;AAC3JpZ,UAAM,CAAC2Z,qBAAP,CAA6Bpe,IAA7B,EAAmCC,KAAnC,EAA0Cie,MAA1C,EAAkDC,GAAlD,EAAuDR,KAAvD,EAA8DC,IAA9D,EAAoEpgB,MAApE,EAA4EqgB,UAA5E;AACArgB,UAAM,CAACmU,EAAP,CAAU,EAAV,KAAiB,CAAC,CAAlB,CAF2J,CAEtI;AACxB,GAHa;AAKd;;;;;;;;;;;;AAUclN,yBAAd,UAA4BiE,KAA5B,EAA2CE,MAA3C,EAA2D+U,KAA3D,EAA0EC,IAA1E,EAAwFC,UAAxF,EAA8GW,mBAA9G,EAA6I;AAA/B;AAAAA;AAA+B;;AACzI,QAAMvV,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AAEA,QAAM5B,CAAC,GAAG8a,KAAV;AACA,QAAMI,CAAC,GAAGH,IAAV;AAEA,QAAM9c,CAAC,GAAI,MAAM+B,CAAP,GAAY6F,KAAtB;AACA,QAAMsV,CAAC,GAAI,MAAMnb,CAAP,GAAY+F,MAAtB;AACA,QAAM0S,CAAC,GAAG,CAACyC,CAAC,GAAGlb,CAAL,KAAWkb,CAAC,GAAGlb,CAAf,CAAV;AACA,QAAME,CAAC,GAAI,CAAC,GAAD,GAAOgb,CAAP,GAAWlb,CAAZ,IAAkBkb,CAAC,GAAGlb,CAAtB,CAAV;AACA,QAAM4b,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA/Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsDS,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqEnD,CAArE,EAAwE,GAAxE,EAA6E,GAA7E,EAAkF,GAAlF,EAAuFvY,CAAvF,EAA0F,GAA1F,EAA+FkG,MAA/F;;AAEA,QAAI4U,UAAJ,EAAgB;AACZ5U,YAAM,CAACC,aAAP,CAAqB+U,yBAArB,EAAgDhV,MAAhD;AACH;;AAEDA,UAAM,CAAC0K,qBAAP,CAA6B,KAA7B;;AACA,WAAO1K,MAAP;AACH,GApBa;AAsBd;;;;;;;;;;;;;AAWcxE,4BAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIC,UALJ,EAMIW,mBANJ,EAOIK,sBAPJ,EAO2C;AADvC;AAAAL;AAA+B;;AAC/B;AAAAK;AAAuC;;AAEvC,QAAM5V,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAACqa,qBAAP,CAA6BH,GAA7B,EAAkCC,MAAlC,EAA0CjB,KAA1C,EAAiDC,IAAjD,EAAuD3U,MAAvD,EAA+D,IAA/D,EAAqE4U,UAArE,EAAiFW,mBAAjF,EAAsGK,sBAAtG;AACA,WAAO5V,MAAP;AACH,GAZa;AAcd;;;;;;;;;;;;;;AAYcxE,iCAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIpgB,MALJ,EAMIuhB,kBANJ,EAOIlB,UAPJ,EAQIW,mBARJ,EASIK,sBATJ,EAS2C;AAHvC;AAAAE;AAAyB;;AAEzB;AAAAP;AAA+B;;AAC/B;AAAAK;AAAuC;;AAEvC,QAAMhc,CAAC,GAAG8a,KAAV;AACA,QAAMI,CAAC,GAAGH,IAAV;AAEA,QAAM3c,CAAC,GAAG,MAAM9C,IAAI,CAACugB,GAAL,CAASC,GAAG,GAAG,GAAf,CAAhB;AACA,QAAM7d,CAAC,GAAGie,kBAAkB,GAAG9d,CAAC,GAAG2d,MAAP,GAAgB3d,CAA5C;AACA,QAAM+c,CAAC,GAAGe,kBAAkB,GAAG9d,CAAH,GAAOA,CAAC,GAAG2d,MAAvC;AACA,QAAMtD,CAAC,GAAGuD,sBAAsB,IAAIhc,CAAC,KAAK,CAAhC,GAAoC,CAAC,CAArC,GAAyCkb,CAAC,KAAK,CAAN,GAAU,CAACA,CAAC,GAAGlb,CAAL,KAAWkb,CAAC,GAAGlb,CAAf,CAAV,GAA8B,CAAjF;AACA,QAAME,CAAC,GAAG8b,sBAAsB,IAAIhc,CAAC,KAAK,CAAhC,GAAoC,IAAIkb,CAAxC,GAA4CA,CAAC,KAAK,CAAN,GAAW,CAAC,GAAD,GAAOA,CAAP,GAAWlb,CAAZ,IAAkBkb,CAAC,GAAGlb,CAAtB,CAAV,GAAqC,CAAC,CAAD,GAAKA,CAAhG;AACA,QAAM4b,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA/Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsDS,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqEnD,CAArE,EAAwE,GAAxE,EAA6E,GAA7E,EAAkF,GAAlF,EAAuFvY,CAAvF,EAA0F,GAA1F,EAA+FvF,MAA/F;;AAEA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACmW,qBAAP,CAA6B,KAA7B;AACH,GA5Ba;AA8Bd;;;;;;;;;;;;;AAWclP,wCAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIpgB,MALJ,EAMIuhB,kBANJ,EAOIlB,UAPJ,EAQIW,mBARJ,EAQmC;AAF/B;AAAAO;AAAyB;;AAEzB;AAAAP;AAA+B;;AAE/B,QAAMvd,CAAC,GAAG,MAAM9C,IAAI,CAACugB,GAAL,CAASC,GAAG,GAAG,GAAf,CAAhB;AACA,QAAM7d,CAAC,GAAGie,kBAAkB,GAAG9d,CAAC,GAAG2d,MAAP,GAAgB3d,CAA5C;AACA,QAAM+c,CAAC,GAAGe,kBAAkB,GAAG9d,CAAH,GAAOA,CAAC,GAAG2d,MAAvC;AACA,QAAMH,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA/Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsDS,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE,CAACd,KAAtE,EAA6E,GAA7E,EAAkF,GAAlF,EAAuF,GAAvF,EAA4F,GAA5F,EAAiG,GAAjG,EAAsGngB,MAAtG;;AACA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AACDA,UAAM,CAACmW,qBAAP,CAA6B,KAA7B;AACH,GApBa;AAsBd;;;;;;;;;;;;;AAWclP,4BAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIC,UALJ,EAMIW,mBANJ,EAOIK,sBAPJ,EAO2C;AADvC;AAAAL;AAA+B;;AAC/B;AAAAK;AAAuC;;AAEvC,QAAM5V,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAACua,qBAAP,CAA6BL,GAA7B,EAAkCC,MAAlC,EAA0CjB,KAA1C,EAAiDC,IAAjD,EAAuD3U,MAAvD,EAA+D,IAA/D,EAAqE4U,UAArE,EAAiFW,mBAAjF,EAAsGK,sBAAtG;AACA,WAAO5V,MAAP;AACH,GAZa;AAcd;;;;;;;;;;;;;;AAYcxE,iCAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIpgB,MALJ,EAMIuhB,kBANJ,EAOIlB,UAPJ,EAQIW,mBARJ,EASIK,sBATJ,EAS2C;AAEvC;AACA;AACA;AACA;AARA;AAAAE;AAAyB;;AAEzB;AAAAP;AAA+B;;AAC/B;AAAAK;AAAuC;;AAOvC,QAAMhc,CAAC,GAAG8a,KAAV;AACA,QAAMI,CAAC,GAAGH,IAAV;AAEA,QAAM3c,CAAC,GAAG,MAAM9C,IAAI,CAACugB,GAAL,CAASC,GAAG,GAAG,GAAf,CAAhB;AACA,QAAM7d,CAAC,GAAGie,kBAAkB,GAAG9d,CAAC,GAAG2d,MAAP,GAAgB3d,CAA5C;AACA,QAAM+c,CAAC,GAAGe,kBAAkB,GAAG9d,CAAH,GAAOA,CAAC,GAAG2d,MAAvC;AACA,QAAMtD,CAAC,GAAGuD,sBAAsB,IAAIhc,CAAC,KAAK,CAAhC,GAAoC,CAApC,GAAwCkb,CAAC,KAAK,CAAN,GAAU,EAAEA,CAAC,GAAGlb,CAAN,KAAYkb,CAAC,GAAGlb,CAAhB,CAAV,GAA+B,CAAC,CAAlF;AACA,QAAME,CAAC,GAAG8b,sBAAsB,IAAIhc,CAAC,KAAK,CAAhC,GAAoC,IAAIkb,CAAxC,GAA4CA,CAAC,KAAK,CAAN,GAAW,CAAC,CAAD,GAAKA,CAAL,GAASlb,CAAV,IAAgBkb,CAAC,GAAGlb,CAApB,CAAV,GAAmC,CAAC,CAAD,GAAKA,CAA9F;AACA,QAAM4b,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA/Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsDS,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqEnD,CAArE,EAAwE,CAAC,GAAzE,EAA8E,GAA9E,EAAmF,GAAnF,EAAwFvY,CAAxF,EAA2F,GAA3F,EAAgGvF,MAAhG;;AAEA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACmW,qBAAP,CAA6B,KAA7B;AACH,GAjCa;AAmCd;;;;;;;;;;;;;AAWclP,wCAAd,UACIka,GADJ,EAEIC,MAFJ,EAGIjB,KAHJ,EAIIC,IAJJ,EAKIpgB,MALJ,EAMIuhB,kBANJ,EAOIlB,UAPJ,EAQIW,mBARJ,EAQmC;AAF/B;AAAAO;AAAyB;;AAEzB;AAAAP;AAA+B;;AAE/B,QAAMvd,CAAC,GAAG,MAAM9C,IAAI,CAACugB,GAAL,CAASC,GAAG,GAAG,GAAf,CAAhB;AACA,QAAM7d,CAAC,GAAGie,kBAAkB,GAAG9d,CAAC,GAAG2d,MAAP,GAAgB3d,CAA5C;AACA,QAAM+c,CAAC,GAAGe,kBAAkB,GAAG9d,CAAH,GAAOA,CAAC,GAAG2d,MAAvC;AACA,QAAMH,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA/Z,UAAM,CAACuE,eAAP,CAAuBlI,CAAvB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8Ckd,CAA9C,EAAiD,GAAjD,EAAsDS,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE,CAACd,KAAtE,EAA6E,CAAC,GAA9E,EAAmF,GAAnF,EAAwF,GAAxF,EAA6F,CAAC,GAA9F,EAAmG,GAAnG,EAAwGngB,MAAxG;;AAEA,QAAIqgB,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACmW,qBAAP,CAA6B,KAA7B;AACH,GAtBa;AAwBd;;;;;;;;;;;;;;;;AAcclP,oCAAd,UACIka,GADJ,EAEIhB,KAFJ,EAGIC,IAHJ,EAIIpgB,MAJJ,EAKIyhB,WALJ,EAMIpB,UANJ,EAOIW,mBAPJ,EAOmC;AAF/B;AAAAS;AAAmB;;AAEnB;AAAAT;AAA+B;;AAE/B,QAAMU,iBAAiB,GAAGD,WAAW,GAAG,CAAC,CAAJ,GAAQ,CAA7C;AAEA,QAAME,KAAK,GAAGhhB,IAAI,CAACugB,GAAL,CAAUC,GAAG,CAACS,SAAJ,GAAgBjhB,IAAI,CAAC0H,EAAtB,GAA4B,KAArC,CAAd;AACA,QAAMwZ,OAAO,GAAGlhB,IAAI,CAACugB,GAAL,CAAUC,GAAG,CAACW,WAAJ,GAAkBnhB,IAAI,CAAC0H,EAAxB,GAA8B,KAAvC,CAAhB;AACA,QAAM0Z,OAAO,GAAGphB,IAAI,CAACugB,GAAL,CAAUC,GAAG,CAACa,WAAJ,GAAkBrhB,IAAI,CAAC0H,EAAxB,GAA8B,KAAvC,CAAhB;AACA,QAAM4Z,QAAQ,GAAGthB,IAAI,CAACugB,GAAL,CAAUC,GAAG,CAACe,YAAJ,GAAmBvhB,IAAI,CAAC0H,EAAzB,GAA+B,KAAxC,CAAjB;AACA,QAAM8Z,MAAM,GAAG,OAAOJ,OAAO,GAAGE,QAAjB,CAAf;AACA,QAAMG,MAAM,GAAG,OAAOT,KAAK,GAAGE,OAAf,CAAf;AACA,QAAMZ,GAAG,GAAGtgB,IAAI,CAACugB,GAAL,CAASF,mBAAT,CAAZ;AAEA,QAAM/d,CAAC,GAAGjD,MAAM,CAACmU,EAAjB;AACAlR,KAAC,CAAC,CAAD,CAAD,GAAOkf,MAAP;AACAlf,KAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAD,GAAO,GAA5B;AACAA,KAAC,CAAC,CAAD,CAAD,GAAOmf,MAAP;AACAnf,KAAC,CAAC,CAAD,CAAD,GAAO,GAAP;AACAA,KAAC,CAAC,CAAD,CAAD,GAAOge,GAAP;AACAhe,KAAC,CAAC,CAAD,CAAD,GAAO,CAAC8e,OAAO,GAAGE,QAAX,IAAuBE,MAAvB,GAAgC,GAAvC;AACAlf,KAAC,CAAC,CAAD,CAAD,GAAO,EAAE,CAAC0e,KAAK,GAAGE,OAAT,IAAoBO,MAApB,GAA6B,GAA/B,CAAP;AACAnf,KAAC,CAAC,EAAD,CAAD,GAAQ,CAACmd,IAAD,IAASD,KAAK,GAAGC,IAAjB,CAAR;AACAnd,KAAC,CAAC,EAAD,CAAD,GAAQ,MAAMye,iBAAd;AACAze,KAAC,CAAC,EAAD,CAAD,GAAQA,CAAC,CAAC,EAAD,CAAD,GAAQA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAxB;AACAA,KAAC,CAAC,EAAD,CAAD,GAAQ,EAAE,MAAMmd,IAAN,GAAaD,KAAf,KAAyBC,IAAI,GAAGD,KAAhC,CAAR;;AAEA,QAAIE,UAAJ,EAAgB;AACZrgB,YAAM,CAAC0L,aAAP,CAAqB+U,yBAArB,EAAgDzgB,MAAhD;AACH;;AAEDA,UAAM,CAACqU,aAAP;AACH,GArCa;AAuCd;;;;;;;;;;;;AAUcpN,0BAAd,UACI8D,QADJ,EAEIF,KAFJ,EAGImB,IAHJ,EAIIC,UAJJ,EAKIoW,IALJ,EAMIC,IANJ,EAMgB;AAEZ,QAAMrX,EAAE,GAAGF,QAAQ,CAACG,KAApB;AACA,QAAMC,EAAE,GAAGJ,QAAQ,CAACK,MAApB;AACA,QAAMC,EAAE,GAAGN,QAAQ,CAACvL,CAApB;AACA,QAAM8L,EAAE,GAAGP,QAAQ,CAACtL,CAApB;AAEA,QAAM8L,cAAc,GAAGtE,MAAM,CAAC0W,UAAP,CAAkB1S,EAAE,GAAG,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,CAACE,EAAD,GAAM,GAAtD,EAA2D,GAA3D,EAAgE,GAAhE,EAAqE,GAArE,EAA0E,GAA1E,EAA+EmX,IAAI,GAAGD,IAAtF,EAA4F,GAA5F,EAAiGhX,EAAE,GAAGJ,EAAE,GAAG,GAA3G,EAAgHE,EAAE,GAAG,GAAL,GAAWG,EAA3H,EAA+H+W,IAA/H,EAAqI,GAArI,CAAvB;AAEA,QAAM5W,MAAM,GAAGhG,OAAO,CAACwB,MAAR,CAAe,CAAf,CAAf;AACA4D,SAAK,CAACa,aAAN,CAAoBM,IAApB,EAA0BP,MAA1B;AACAA,UAAM,CAACC,aAAP,CAAqBO,UAArB,EAAiCR,MAAjC;AACA,WAAOA,MAAM,CAAC8W,QAAP,CAAgBhX,cAAhB,CAAP;AACH,GAnBa;AAqBd;;;;;;;AAKctE,0BAAd,UAA6BwE,MAA7B,EAA0D;AACtD,QAAMxI,CAAC,GAAGwI,MAAM,CAACxI,CAAjB;AACA,QAAMuf,GAAG,GAAG,CAACvf,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,EAAaA,CAAC,CAAC,CAAD,CAAd,EAAmBA,CAAC,CAAC,CAAD,CAApB,CAAZ;AACA,WAAOhE,uBAAuB,CAACqV,eAAxB,GAA0CkO,GAA1C,GAAgD,IAAIC,YAAJ,CAAiBD,GAAjB,CAAvD;AACH,GAJa;AAKd;;;;;;;AAKcvb,0BAAd,UAA6BwE,MAA7B,EAA0D;AACtD,QAAMxI,CAAC,GAAGwI,MAAM,CAACxI,CAAjB;AACA,QAAMuf,GAAG,GAAG,CAACvf,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,EAAaA,CAAC,CAAC,CAAD,CAAd,EAAmBA,CAAC,CAAC,CAAD,CAApB,EAAyBA,CAAC,CAAC,CAAD,CAA1B,EAA+BA,CAAC,CAAC,CAAD,CAAhC,EAAqCA,CAAC,CAAC,CAAD,CAAtC,EAA2CA,CAAC,CAAC,CAAD,CAA5C,EAAiDA,CAAC,CAAC,EAAD,CAAlD,CAAZ;AACA,WAAOhE,uBAAuB,CAACqV,eAAxB,GAA0CkO,GAA1C,GAAgD,IAAIC,YAAJ,CAAiBD,GAAjB,CAAvD;AACH,GAJa;AAMd;;;;;;;AAKcvb,qBAAd,UAAwBwE,MAAxB,EAAqD;AACjD,QAAMzL,MAAM,GAAG,IAAIiH,MAAJ,EAAf;AACAA,UAAM,CAACwU,cAAP,CAAsBhQ,MAAtB,EAA8BzL,MAA9B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKciH,0BAAd,UAA6BwE,MAA7B,EAA4DzL,MAA5D,EAA0E;AACtE,QAAM0iB,EAAE,GAAG1iB,MAAM,CAACmU,EAAlB;AACA,QAAMwO,EAAE,GAAGlX,MAAM,CAACxI,CAAlB;AACAyf,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,EAAD,CAAV;AAEAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,EAAD,CAAV;AAEAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV;AACAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,EAAD,CAAX;AACAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,EAAD,CAAX;AAEAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,CAAD,CAAX;AACAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,CAAD,CAAX;AACAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,EAAD,CAAX;AACAD,MAAE,CAAC,EAAD,CAAF,GAASC,EAAE,CAAC,EAAD,CAAX;AAEA3iB,UAAM,CAACqU,aAAP,GAvBsE,CAyBtE;;AACArU,UAAM,CAACmW,qBAAP,CAA8B1K,MAAiB,CAACgJ,WAAhD,EAA8DhJ,MAAiB,CAACkJ,gBAAhF;AACH,GA3Ba;AA6Bd;;;;;;;AAKc1N,sBAAd,UAAyB/B,KAAzB,EAAyD;AACrD,QAAMuG,MAAM,GAAG,IAAIxE,MAAJ,EAAf;AACAA,UAAM,CAAC2b,eAAP,CAAuB1d,KAAvB,EAA8BuG,MAA9B;AACA,WAAOA,MAAP;AACH,GAJa;AAMd;;;;;;;AAKcxE,2BAAd,UAA8B/B,KAA9B,EAAgElF,MAAhE,EAA8E;AAC1EkF,SAAK,CAACS,SAAN;AACA,QAAMnG,CAAC,GAAG0F,KAAK,CAACI,MAAN,CAAa9F,CAAvB;AACA,QAAMC,CAAC,GAAGyF,KAAK,CAACI,MAAN,CAAa7F,CAAvB;AACA,QAAM8E,CAAC,GAAGW,KAAK,CAACI,MAAN,CAAaf,CAAvB;AACA,QAAMse,IAAI,GAAG,CAAC,CAAD,GAAKrjB,CAAlB;AACA,QAAMsjB,KAAK,GAAG,CAAC,CAAD,GAAKrjB,CAAnB;AACA,QAAMsjB,KAAK,GAAG,CAAC,CAAD,GAAKxe,CAAnB;AACA0C,UAAM,CAACuE,eAAP,CACIqX,IAAI,GAAGrjB,CAAP,GAAW,CADf,EAEIsjB,KAAK,GAAGtjB,CAFZ,EAGIujB,KAAK,GAAGvjB,CAHZ,EAII,GAJJ,EAKIqjB,IAAI,GAAGpjB,CALX,EAMIqjB,KAAK,GAAGrjB,CAAR,GAAY,CANhB,EAOIsjB,KAAK,GAAGtjB,CAPZ,EAQI,GARJ,EASIojB,IAAI,GAAGte,CATX,EAUIue,KAAK,GAAGve,CAVZ,EAWIwe,KAAK,GAAGxe,CAAR,GAAY,CAXhB,EAYI,GAZJ,EAaIse,IAAI,GAAG3d,KAAK,CAACK,CAbjB,EAcIud,KAAK,GAAG5d,KAAK,CAACK,CAdlB,EAeIwd,KAAK,GAAG7d,KAAK,CAACK,CAflB,EAgBI,GAhBJ,EAiBIvF,MAjBJ;AAmBH,GA3Ba;AA6Bd;;;;;;;;;AAOciH,4BAAd,UAA+B+b,KAA/B,EAA8DC,KAA9D,EAA6FC,KAA7F,EAA4HljB,MAA5H,EAA0I;AACtIiH,UAAM,CAACuE,eAAP,CAAuBwX,KAAK,CAACxe,EAA7B,EAAiCwe,KAAK,CAACve,EAAvC,EAA2Cue,KAAK,CAACte,EAAjD,EAAqD,GAArD,EAA0Due,KAAK,CAACze,EAAhE,EAAoEye,KAAK,CAACxe,EAA1E,EAA8Ewe,KAAK,CAACve,EAApF,EAAwF,GAAxF,EAA6Fwe,KAAK,CAAC1e,EAAnG,EAAuG0e,KAAK,CAACze,EAA7G,EAAiHye,KAAK,CAACxe,EAAvH,EAA2H,GAA3H,EAAgI,GAAhI,EAAqI,GAArI,EAA0I,GAA1I,EAA+I,GAA/I,EAAoJ1E,MAApJ;AACH,GAFa;AAId;;;;;;;AAKciH,+BAAd,UAAkC8H,IAAlC,EAAmE/O,MAAnE,EAAiF;AAC7E,QAAMid,EAAE,GAAGlO,IAAI,CAACvK,EAAL,GAAUuK,IAAI,CAACvK,EAA1B;AACA,QAAM4Y,EAAE,GAAGrO,IAAI,CAACtK,EAAL,GAAUsK,IAAI,CAACtK,EAA1B;AACA,QAAM6Y,EAAE,GAAGvO,IAAI,CAACrK,EAAL,GAAUqK,IAAI,CAACrK,EAA1B;AACA,QAAMwY,EAAE,GAAGnO,IAAI,CAACvK,EAAL,GAAUuK,IAAI,CAACtK,EAA1B;AACA,QAAM0e,EAAE,GAAGpU,IAAI,CAACrK,EAAL,GAAUqK,IAAI,CAACU,EAA1B;AACA,QAAM2T,EAAE,GAAGrU,IAAI,CAACrK,EAAL,GAAUqK,IAAI,CAACvK,EAA1B;AACA,QAAM6e,EAAE,GAAGtU,IAAI,CAACtK,EAAL,GAAUsK,IAAI,CAACU,EAA1B;AACA,QAAM4N,EAAE,GAAGtO,IAAI,CAACtK,EAAL,GAAUsK,IAAI,CAACrK,EAA1B;AACA,QAAM4e,EAAE,GAAGvU,IAAI,CAACvK,EAAL,GAAUuK,IAAI,CAACU,EAA1B;AAEAzP,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,MAAM,OAAOiJ,EAAE,GAAGE,EAAZ,CAArB;AACAtd,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAO+I,EAAE,GAAGiG,EAAZ,CAAf;AACAnjB,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAOiP,EAAE,GAAGC,EAAZ,CAAf;AACArjB,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,GAAf;AAEAnU,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAO+I,EAAE,GAAGiG,EAAZ,CAAf;AACAnjB,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,MAAM,OAAOmJ,EAAE,GAAGL,EAAZ,CAArB;AACAjd,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAOkJ,EAAE,GAAGiG,EAAZ,CAAf;AACAtjB,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,GAAf;AAEAnU,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAOiP,EAAE,GAAGC,EAAZ,CAAf;AACArjB,UAAM,CAACmU,EAAP,CAAU,CAAV,IAAe,OAAOkJ,EAAE,GAAGiG,EAAZ,CAAf;AACAtjB,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,MAAM,OAAOiJ,EAAE,GAAGH,EAAZ,CAAtB;AACAjd,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,GAAhB;AAEAnU,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACAnU,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACAnU,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACAnU,UAAM,CAACmU,EAAP,CAAU,EAAV,IAAgB,GAAhB;AAEAnU,UAAM,CAACqU,aAAP;AACH,GAhCa;;AAxsECpN,2BAAkB,CAAlB;AACAA,6BAAoBA,MAAM,CAACwM,QAAP,EAApB;AAwuEnB;AAAC,CAjvED;;SAAaxM;AAmvEb;;;;;AAIA;AAAA;AAAA;AAAA,sBAIC;;AAHiBxB,oBAAU1G,UAAU,CAACwkB,UAAX,CAAsB,EAAtB,EAA0B3e,OAAO,CAACzC,IAAlC,CAAV;AACAsD,mBAAS1G,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyBtc,MAAM,CAACwM,QAAhC,CAAT;AACAhO,uBAAa1G,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyBze,UAAU,CAAC3C,IAApC,CAAb;AAClB;AAAC,CAJD;AAMA;;;;;AAGA;AAAA;AAAA;AAAA,yBAMC;;AALiB2P,uBAAU/S,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyB7jB,OAAO,CAACyC,IAAjC,CAAV,CADlB,CACoE;;AAClD2P,uBAAU/S,UAAU,CAACwkB,UAAX,CAAsB,EAAtB,EAA0B3e,OAAO,CAACzC,IAAlC,CAAV,CAFlB,CAEqE;;AACnD2P,uBAAU/S,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyBhU,OAAO,CAACpN,IAAjC,CAAV,CAHlB,CAGoE;;AAClD2P,0BAAa/S,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyBze,UAAU,CAAC3C,IAApC,CAAb,CAJlB,CAI0E;;AACxD2P,sBAAS/S,UAAU,CAACwkB,UAAX,CAAsB,CAAtB,EAAyBtc,MAAM,CAACwM,QAAhC,CAAT,CALlB,CAKsE;;AACtE;AAAC,CAND;;SAAa3B;AAQb9S,aAAa,CAAC,iBAAD,EAAoBU,OAApB,CAAb;AACAV,aAAa,CAAC,iBAAD,EAAoB4F,OAApB,CAAb;AACA5F,aAAa,CAAC,iBAAD,EAAoBuQ,OAApB,CAAb;AACAvQ,aAAa,CAAC,gBAAD,EAAmBiI,MAAnB,CAAb;AAEA,IAAMwZ,yBAAyB,GAAGxZ,MAAM,CAAC0W,UAAP,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAvC,EAA0C,CAA1C,EAA6C,CAA7C,EAAgD,GAAhD,EAAqD,CAArD,EAAwD,CAAxD,EAA2D,CAA3D,EAA8D,GAA9D,EAAmE,CAAnE,CAAlC","names":["Scalar","Epsilon","ArrayTools","RegisterClass","PerformanceConfigurator","EngineStore","_ExtractAsInt","value","parseInt","toString","replace","x","y","Vector2","concat","hash","array","index","FromArrayToRef","result","Array","toArray","source","copyFromFloats","otherVector","divideToRef","scale","scaleToRef","epsilon","WithinEpsilon","Math","floor","angle","cos","sin","sqrt","NormalizeToRef","offset","value1","value2","value3","value4","amount","squared","cubed","min","max","tangent1","tangent2","part1","part2","part3","part4","time","Zero","Hermite1stDerivativeToRef","t2","start","end","left","right","vector","newVector","len","length","transformation","r","TransformToRef","m","p","p0","p1","p2","a","sign","s","t","DistanceSquared","CenterToRef","ref","segA","segB","l2","Distance","v","subtract","Dot","proj","add","multiplyByFloats","z","_x","_y","_z","Object","Vector3","_isDirty","Quaternion","RotationYawPitchRoll","addInPlaceFromFloats","subtractFromFloatsToRef","plane","origin","projectOnPlaneToRef","n","normal","d","V","MathTmp","subtractToRef","normalize","denom","scaledV","scaleInPlace","addToRef","other","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","absX","abs","absY","absZ","normalizeFromLength","order","toLowerCase","copyFrom","forEach","val","i","_this","quaternion","toRotationMatrix","Matrix","TransformCoordinatesToRef","point","rotateByQuaternionToRef","Cross","normalized","normalizeToRef","reference","vector0","vector1","axis","size","d0","d1","v0","v1","dot","acos","CrossToRef","isNaN","PI","vNormal","forward","atan2","NormalizeRadians","slerp","Clamp","vector0Dir","vector1Dir","vector0Length","vector1Length","scale0","scale1","omega","invSin","addInPlace","Lerp","goal","deltaTime","lerpTime","SlerpToRef","FromArray","_UpReadOnly","_RightReadOnly","_LeftReadOnly","_LeftHandedForwardReadOnly","_RightHandedForwardReadOnly","_ZeroReadOnly","rightHandedSystem","TransformCoordinatesFromFloatsToRef","rx","ry","rz","rw","TransformNormalToRef","TransformNormalFromFloatsToRef","ClampToRef","minimizeInPlace","maximizeInPlace","LerpToRef","world","transform","viewport","ProjectToRef","cw","width","ch","height","cx","cy","viewportMatrix","FromValuesToRef","matrix","multiplyToRef","num","viewportWidth","viewportHeight","Unproject","IdentityReadOnly","view","projection","UnprojectToRef","UnprojectFloatsToRef","sourceX","sourceY","sourceZ","invert","screenSource","LastCreatedEngine","_a","isNDCHalfZRange","_UnprojectFromInvertedMatrixToRef","clone","p1p0","p2p0","p2p1","vectorp0","p1p0L","p2p0L","p2p1L","nl","l","cosA","projVector","v2","tmp","projP","subtractInPlace","s0","s1","s2","edge","e0","e1","tmp2","tmp3","isOutside","e0proj","e0projL","cosG","triProj","axis1","axis2","axis3","rotation","RotationFromAxisToRef","quat","RotationQuaternionFromAxisToRef","toEulerAnglesToRef","Up","Forward","Right","Left","w","Vector4","undefined","_w","otherQuaternion","q1","inv","qz","qx","qy","qw","sqw","sqz","sqx","sqy","zAxisY","limit","asin","FromQuaternionToRef","FromRotationMatrixToRef","data","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","quat0","quat1","q","set","RotationAxisToRef","RotationYawPitchRollToRef","vec","vecFrom","vecTo","TmpVectors","yaw","pitch","roll","halfRoll","halfPitch","halfYaw","sinRoll","cosRoll","sinPitch","cosPitch","sinYaw","cosYaw","alpha","beta","gamma","RotationAlphaBetaGammaToRef","halfGammaPlusAlpha","halfGammaMinusAlpha","halfBeta","rotMat","FromXYZAxesToRef","up","FromLookDirectionLHToRef","LookDirectionLHToRef","FromLookDirectionRHToRef","LookDirectionRHToRef","Identity","num2","num3","num4","flag","num5","num6","MatrixTrackPrecisionChange","MatrixTrackedMatrices","push","_m","MatrixCurrentType","markAsUpdated","MatrixUse64Bits","updateFlag","_UpdateFlagSeed","_isIdentity","_isIdentity3x2","_isIdentityDirty","_isIdentity3x2Dirty","isIdentity","isIdentityDirty","isIdentity3x2","isIdentity3x2Dirty","m00","m01","m02","m03","m10","m20","m30","det_22_33","det_21_33","det_21_32","det_20_33","det_20_32","det_20_31","cofact_00","cofact_01","cofact_02","cofact_03","invertToRef","_updateIdentityStatus","resultM","otherM","IdentityToRef","det","detInv","det_12_33","det_11_33","det_11_32","det_10_33","det_10_32","det_10_31","det_12_23","det_11_23","det_11_22","det_10_23","det_10_22","det_10_21","cofact_10","cofact_11","cofact_12","cofact_13","cofact_20","cofact_21","cofact_22","cofact_23","cofact_30","cofact_31","cofact_32","cofact_33","vector3","setTranslationFromFloats","copyToArray","o","multiplyToArray","tm0","tm1","tm2","tm3","tm4","tm5","tm6","tm7","tm8","tm9","tm10","tm11","tm12","tm13","tm14","tm15","om0","om1","om2","om3","om4","om5","om6","om7","om8","om9","om10","om11","om12","om13","om14","om15","om","node","rotationQuaternion","decompose","scaling","position","translation","preserveScalingNode","setAll","signX","signY","signZ","determinant","sx","sy","sz","row","setRowFromFloats","Transpose","TransposeToRef","transposeToRef","getRotationMatrixToRef","_IdentityReadOnly","initialM11","initialM12","initialM13","initialM14","initialM21","initialM22","initialM23","initialM24","initialM31","initialM32","initialM33","initialM34","initialM41","initialM42","initialM43","initialM44","ComposeToRef","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","identity","FromValues","zero","RotationXToRef","c","RotationYToRef","RotationZToRef","c1","from","to","k","ScalingToRef","TranslationToRef","startValue","endValue","gradient","startM","endM","DecomposeLerpToRef","startScale","startRotation","startTranslation","endScale","endRotation","endTranslation","resultScale","resultRotation","resultTranslation","eye","target","LookAtLHToRef","xAxis","yAxis","zAxis","xSquareLength","lengthSquared","ex","ey","ez","LookAtRHToRef","back","znear","zfar","halfZRange","OrthoLHToRef","f","b","mtxConvertNDCToHalfZRange","bottom","top","OrthoOffCenterLHToRef","i0","i1","OrthoOffCenterRHToRef","projectionPlaneTilt","rot","tan","fov","aspect","reverseDepthBufferMode","PerspectiveFovLHToRef","isVerticalFovFixed","PerspectiveFovRHToRef","rightHanded","rightHandedFactor","upTan","upDegrees","downTan","downDegrees","leftTan","leftDegrees","rightTan","rightDegrees","xScale","yScale","zmin","zmax","multiply","arr","Float32Array","rm","mm","ReflectionToRef","temp","temp2","temp3","xaxis","yaxis","zaxis","zw","zx","yw","xw","BuildTuple"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Maths/math.vector.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Scalar } from \"./math.scalar\";\r\nimport { Epsilon } from \"./math.constants\";\r\nimport type { Viewport } from \"./math.viewport\";\r\nimport type { DeepImmutable, Nullable, FloatArray, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { IPlaneLike } from \"./math.like\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Plane } from \"./math.plane\";\r\nimport { PerformanceConfigurator } from \"../Engines/performanceConfigurator\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ntype TransformNode = import(\"../Meshes/transformNode\").TransformNode;\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst _ExtractAsInt = (value: number) => {\r\n    return parseInt(value.toString().replace(/\\W/g, \"\"));\r\n};\r\n\r\n/**\r\n * Class representing a vector containing 2 coordinates\r\n */\r\nexport class Vector2 {\r\n    /**\r\n     * Creates a new Vector2 from the given x and y coordinates\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     */\r\n    constructor(\r\n        /** defines the first coordinate */\r\n        public x: number = 0,\r\n        /** defines the second coordinate */\r\n        public y: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Gets a string with the Vector2 coordinates\r\n     * @returns a string with the Vector2 coordinates\r\n     */\r\n    public toString(): string {\r\n        return `{X: ${this.x} Y: ${this.y}}`;\r\n    }\r\n\r\n    /**\r\n     * Gets class name\r\n     * @returns the string \"Vector2\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector2\";\r\n    }\r\n\r\n    /**\r\n     * Gets current vector hash code\r\n     * @returns the Vector2 hash code as a number\r\n     */\r\n    public getHashCode(): number {\r\n        const x = _ExtractAsInt(this.x);\r\n        const y = _ExtractAsInt(this.y);\r\n        let hash = x;\r\n        hash = (hash * 397) ^ y;\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\r\n     * @param array defines the source array\r\n     * @param index defines the offset in source array\r\n     * @returns the current Vector2\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Vector2 {\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector2 {\r\n        Vector2.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy the current vector to an array\r\n     * @returns a new array with 2 elements: the Vector2 coordinates.\r\n     */\r\n    public asArray(): number[] {\r\n        const result = new Array<number>();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\r\n     * @param source defines the source Vector2\r\n     * @returns the current updated Vector2\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector2>): Vector2 {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    public copyFromFloats(x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    public set(x: number, y: number): Vector2 {\r\n        return this.copyFromFloats(x, y);\r\n    }\r\n    /**\r\n     * Add another vector with the current one\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public addVector3(otherVector: Vector3): Vector2 {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public subtract(otherVector: Vector2): Vector2 {\r\n        return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public multiplyInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns a new Vector2\r\n     */\r\n    public multiplyByFloats(x: number, y: number): Vector2 {\r\n        return new Vector2(this.x * x, this.y * y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public divide(otherVector: Vector2): Vector2 {\r\n        return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public divideInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 with current Vector2 negated coordinates\r\n     * @returns a new Vector2\r\n     */\r\n    public negate(): Vector2 {\r\n        return new Vector2(-this.x, -this.y);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector2 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector2\r\n     */\r\n    public negateToRef(result: Vector2): Vector2 {\r\n        return result.copyFromFloats(this.x * -1, this.y * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiply the Vector2 coordinates by scale\r\n     * @param scale defines the scaling factor\r\n     * @returns the current updated Vector2\r\n     */\r\n    public scaleInPlace(scale: number): Vector2 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\r\n     * @param scale defines the scaling factor\r\n     * @returns a new Vector2\r\n     */\r\n    public scale(scale: number): Vector2 {\r\n        const result = new Vector2(0, 0);\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector2 values by a factor to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public scaleToRef(scale: number, result: Vector2): Vector2 {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector2): Vector2 {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two vectors are equals\r\n     * @param otherVector defines the other vector\r\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector2>): boolean {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two vectors are equals (using an epsilon value)\r\n     * @param otherVector defines the other vector\r\n     * @param epsilon defines the minimal distance to consider equality\r\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector2>, epsilon: number = Epsilon): boolean {\r\n        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 floored values\r\n     * eg (1.2, 2.31) returns (1, 2)\r\n     * @returns a new Vector2\r\n     */\r\n    public floor(): Vector2 {\r\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 fractional values\r\n     * eg (1.2, 2.31) returns (0.2, 0.31)\r\n     * @returns a new Vector2\r\n     */\r\n    public fract(): Vector2 {\r\n        return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\r\n    }\r\n\r\n    /**\r\n     * Rotate the current vector into a given result vector\r\n     * @param angle defines the rotation angle\r\n     * @param result defines the result vector where to store the rotated vector\r\n     * @returns the current vector\r\n     */\r\n    public rotateToRef(angle: number, result: Vector2) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        result.x = cos * this.x - sin * this.y;\r\n        result.y = sin * this.x + cos * this.y;\r\n\r\n        return this;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets the length of the vector\r\n     * @returns the vector length (float)\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    /**\r\n     * Gets the vector squared length\r\n     * @returns the vector squared length (float)\r\n     */\r\n    public lengthSquared(): number {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Normalize the vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public normalize(): Vector2 {\r\n        Vector2.NormalizeToRef(this, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 copied from the Vector2\r\n     * @returns a new Vector2\r\n     */\r\n    public clone(): Vector2 {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Gets a new Vector2(0, 0)\r\n     * @returns a new Vector2\r\n     */\r\n    public static Zero(): Vector2 {\r\n        return new Vector2(0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2(1, 1)\r\n     * @returns a new Vector2\r\n     */\r\n    public static One(): Vector2 {\r\n        return new Vector2(1, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @returns a new Vector2\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Vector2 {\r\n        return new Vector2(array[offset], array[offset + 1]);\r\n    }\r\n\r\n    /**\r\n     * Sets \"result\" from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @param result defines the target vector\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector2): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\r\n     * @param value1 defines 1st point of control\r\n     * @param value2 defines 2nd point of control\r\n     * @param value3 defines 3rd point of control\r\n     * @param value4 defines 4th point of control\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static CatmullRom(\r\n        value1: DeepImmutable<Vector2>,\r\n        value2: DeepImmutable<Vector2>,\r\n        value3: DeepImmutable<Vector2>,\r\n        value4: DeepImmutable<Vector2>,\r\n        amount: number\r\n    ): Vector2 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n\r\n        const x =\r\n            0.5 *\r\n            (2.0 * value2.x +\r\n                (-value1.x + value3.x) * amount +\r\n                (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) * squared +\r\n                (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\r\n\r\n        const y =\r\n            0.5 *\r\n            (2.0 * value2.y +\r\n                (-value1.y + value3.y) * amount +\r\n                (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) * squared +\r\n                (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\r\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\r\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\r\n     * @param value defines the value to clamp\r\n     * @param min defines the lower limit\r\n     * @param max defines the upper limit\r\n     * @returns a new Vector2\r\n     */\r\n    public static Clamp(value: DeepImmutable<Vector2>, min: DeepImmutable<Vector2>, max: DeepImmutable<Vector2>): Vector2 {\r\n        let x = value.x;\r\n        x = x > max.x ? max.x : x;\r\n        x = x < min.x ? min.x : x;\r\n\r\n        let y = value.y;\r\n        y = y > max.y ? max.y : y;\r\n        y = y < min.y ? min.y : y;\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\"\r\n     * @param value1 defines the 1st control point\r\n     * @param tangent1 defines the outgoing tangent\r\n     * @param value2 defines the 2nd control point\r\n     * @param tangent2 defines the incoming tangent\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static Hermite(\r\n        value1: DeepImmutable<Vector2>,\r\n        tangent1: DeepImmutable<Vector2>,\r\n        value2: DeepImmutable<Vector2>,\r\n        tangent2: DeepImmutable<Vector2>,\r\n        amount: number\r\n    ): Vector2 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;\r\n        const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Vector2>,\r\n        tangent1: DeepImmutable<Vector2>,\r\n        value2: DeepImmutable<Vector2>,\r\n        tangent2: DeepImmutable<Vector2>,\r\n        time: number\r\n    ): Vector2 {\r\n        const result = Vector2.Zero();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where the derivative will be stored\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Vector2>,\r\n        tangent1: DeepImmutable<Vector2>,\r\n        value2: DeepImmutable<Vector2>,\r\n        tangent2: DeepImmutable<Vector2>,\r\n        time: number,\r\n        result: Vector2\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\r\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\r\n     * @param start defines the start vector\r\n     * @param end defines the end vector\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static Lerp(start: DeepImmutable<Vector2>, end: DeepImmutable<Vector2>, amount: number): Vector2 {\r\n        const x = start.x + (end.x - start.x) * amount;\r\n        const y = start.y + (end.y - start.y) * amount;\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\r\n     * @param left defines first vector\r\n     * @param right defines second vector\r\n     * @returns the dot product (float)\r\n     */\r\n    public static Dot(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): number {\r\n        return left.x * right.x + left.y * right.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 equal to the normalized given vector\r\n     * @param vector defines the vector to normalize\r\n     * @returns a new Vector2\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector2>): Vector2 {\r\n        const newVector = Vector2.Zero();\r\n        this.NormalizeToRef(vector, newVector);\r\n        return newVector;\r\n    }\r\n\r\n    /**\r\n     * Normalize a given vector into a second one\r\n     * @param vector defines the vector to normalize\r\n     * @param result defines the vector where to store the result\r\n     */\r\n    public static NormalizeToRef(vector: DeepImmutable<Vector2>, result: Vector2) {\r\n        const len = vector.length();\r\n\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        result.x = vector.x / len;\r\n        result.y = vector.y / len;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2 {\r\n        const x = left.x < right.x ? left.x : right.x;\r\n        const y = left.y < right.y ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2 {\r\n        const x = left.x > right.x ? left.x : right.x;\r\n        const y = left.y > right.y ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @returns a new Vector2\r\n     */\r\n    public static Transform(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>): Vector2 {\r\n        const r = Vector2.Zero();\r\n        Vector2.TransformToRef(vector, transformation, r);\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @param result defines the target vector\r\n     */\r\n    public static TransformToRef(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>, result: Vector2) {\r\n        const m = transformation.m;\r\n        const x = vector.x * m[0] + vector.y * m[4] + m[12];\r\n        const y = vector.x * m[1] + vector.y * m[5] + m[13];\r\n        result.x = x;\r\n        result.y = y;\r\n    }\r\n\r\n    /**\r\n     * Determines if a given vector is included in a triangle\r\n     * @param p defines the vector to test\r\n     * @param p0 defines 1st triangle point\r\n     * @param p1 defines 2nd triangle point\r\n     * @param p2 defines 3rd triangle point\r\n     * @returns true if the point \"p\" is in the triangle defined by the vectors \"p0\", \"p1\", \"p2\"\r\n     */\r\n    public static PointInTriangle(p: DeepImmutable<Vector2>, p0: DeepImmutable<Vector2>, p1: DeepImmutable<Vector2>, p2: DeepImmutable<Vector2>) {\r\n        const a = (1 / 2) * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\r\n        const sign = a < 0 ? -1 : 1;\r\n        const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\r\n        const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\r\n\r\n        return s > 0 && t > 0 && s + t < 2 * a * sign;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the distance between vectors\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number {\r\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\r\n    }\r\n\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the squared distance between vectors\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number {\r\n        const x = value1.x - value2.x;\r\n        const y = value1.y - value2.y;\r\n        return x * x + y * y;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): Vector2 {\r\n        return Vector2.CenterToRef(value1, value2, Vector2.Zero());\r\n    }\r\n\r\n    /**\r\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @param ref defines third vector\r\n     * @returns ref\r\n     */\r\n    public static CenterToRef(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>, ref: DeepImmutable<Vector2>): Vector2 {\r\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);\r\n    }\r\n\r\n    /**\r\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\r\n     * @param p defines the middle point\r\n     * @param segA defines one point of the segment\r\n     * @param segB defines the other point of the segment\r\n     * @returns the shortest distance\r\n     */\r\n    public static DistanceOfPointFromSegment(p: DeepImmutable<Vector2>, segA: DeepImmutable<Vector2>, segB: DeepImmutable<Vector2>): number {\r\n        const l2 = Vector2.DistanceSquared(segA, segB);\r\n        if (l2 === 0.0) {\r\n            return Vector2.Distance(p, segA);\r\n        }\r\n        const v = segB.subtract(segA);\r\n        const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\r\n        const proj = segA.add(v.multiplyByFloats(t, t));\r\n        return Vector2.Distance(p, proj);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store (x,y,z) vector representation\r\n * A Vector3 is the main object used in 3D geometry\r\n * It can represent either the coordinates of a point the space, either a direction\r\n * Reminder: js uses a left handed forward facing system\r\n */\r\nexport class Vector3 {\r\n    private static _UpReadOnly = Vector3.Up() as DeepImmutable<Vector3>;\r\n    private static _LeftHandedForwardReadOnly = Vector3.Forward(false) as DeepImmutable<Vector3>;\r\n    private static _RightHandedForwardReadOnly = Vector3.Forward(true) as DeepImmutable<Vector3>;\r\n    private static _RightReadOnly = Vector3.Right() as DeepImmutable<Vector3>;\r\n    private static _LeftReadOnly = Vector3.Left() as DeepImmutable<Vector3>;\r\n    private static _ZeroReadOnly = Vector3.Zero() as DeepImmutable<Vector3>;\r\n\r\n    /** @hidden */\r\n    public _x: number;\r\n\r\n    /** @hidden */\r\n    public _y: number;\r\n\r\n    /** @hidden */\r\n    public _z: number;\r\n\r\n    /** @hidden */\r\n    public _isDirty = true;\r\n\r\n    /** Gets or sets the x coordinate */\r\n    public get x() {\r\n        return this._x;\r\n    }\r\n\r\n    public set x(value: number) {\r\n        this._x = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the y coordinate */\r\n    public get y() {\r\n        return this._y;\r\n    }\r\n\r\n    public set y(value: number) {\r\n        this._y = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the z coordinate */\r\n    public get z() {\r\n        return this._z;\r\n    }\r\n\r\n    public set z(value: number) {\r\n        this._z = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\r\n     * @param x defines the first coordinates (on X axis)\r\n     * @param y defines the second coordinates (on Y axis)\r\n     * @param z defines the third coordinates (on Z axis)\r\n     */\r\n    constructor(x: number = 0, y: number = 0, z: number = 0) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n    }\r\n\r\n    /**\r\n     * Creates a string representation of the Vector3\r\n     * @returns a string with the Vector3 coordinates.\r\n     */\r\n    public toString(): string {\r\n        return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"Vector3\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector3\";\r\n    }\r\n\r\n    /**\r\n     * Creates the Vector3 hash code\r\n     * @returns a number which tends to be unique between Vector3 instances\r\n     */\r\n    public getHashCode(): number {\r\n        const x = _ExtractAsInt(this._x);\r\n        const y = _ExtractAsInt(this._y);\r\n        const z = _ExtractAsInt(this._z);\r\n\r\n        let hash = x;\r\n        hash = (hash * 397) ^ y;\r\n        hash = (hash * 397) ^ z;\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Creates an array containing three elements : the coordinates of the Vector3\r\n     * @returns a new array of numbers\r\n     */\r\n    public asArray(): number[] {\r\n        const result: number[] = [];\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Vector3 {\r\n        array[index] = this._x;\r\n        array[index + 1] = this._y;\r\n        array[index + 2] = this._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector3 {\r\n        Vector3.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\r\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\r\n     */\r\n    public toQuaternion(): Quaternion {\r\n        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the given vector to the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the given coordinates to the current Vector3\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public addInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Subtract the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        this.x -= otherVector._x;\r\n        this.y -= otherVector._y;\r\n        this.z -= otherVector._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public subtract(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public subtractFromFloats(x: number, y: number, z: number): Vector3 {\r\n        return new Vector3(this._x - x, this._y - y, this._z - z);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\r\n     * @returns a new Vector3\r\n     */\r\n    public negate(): Vector3 {\r\n        return new Vector3(-this._x, -this._y, -this._z);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector3 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public negateToRef(result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Vector3 coordinates by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns the current updated Vector3\r\n     */\r\n    public scaleInPlace(scale: number): Vector3 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns a new Vector3\r\n     */\r\n    public scale(scale: number): Vector3 {\r\n        return new Vector3(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\r\n     * @param scale defines the multiplier factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public scaleToRef(scale: number, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the unmodified current Vector3\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector3): Vector3 {\r\n        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n     * @param plane defines the plane to project to\r\n     * @param origin defines the origin of the projection ray\r\n     * @returns the projected vector3\r\n     */\r\n    public projectOnPlane(plane: Plane, origin: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.projectOnPlaneToRef(plane, origin, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n     * @param plane defines the plane to project to\r\n     * @param origin defines the origin of the projection ray\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public projectOnPlaneToRef(plane: Plane, origin: Vector3, result: Vector3): void {\r\n        const n = plane.normal;\r\n        const d = plane.d;\r\n\r\n        const V = MathTmp.Vector3[0];\r\n\r\n        // ray direction\r\n        this.subtractToRef(origin, V);\r\n\r\n        V.normalize();\r\n\r\n        const denom = Vector3.Dot(V, n);\r\n        const t = -(Vector3.Dot(origin, n) + d) / denom;\r\n\r\n        // P = P0 + t*V\r\n        const scaledV = V.scaleInPlace(t);\r\n        origin.addToRef(scaledV, result);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\r\n     * @param otherVector defines the second operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector3>): boolean {\r\n        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\r\n     * @param otherVector defines the second operand\r\n     * @param epsilon defines the minimal distance to define values as equals\r\n     * @returns true if both vectors are distant less than epsilon\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector3>, epsilon: number = Epsilon): boolean {\r\n        return (\r\n            otherVector &&\r\n            Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) &&\r\n            Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) &&\r\n            Scalar.WithinEpsilon(this._z, otherVector._z, epsilon)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 coordinates equals the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    public equalsToFloats(x: number, y: number, z: number): boolean {\r\n        return this._x === x && this._y === y && this._z === z;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public multiplyInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        this.x *= otherVector._x;\r\n        this.y *= otherVector._y;\r\n        this.z *= otherVector._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the multiplication of the current Vector3 coordinates by the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the new Vector3\r\n     */\r\n    public multiplyByFloats(x: number, y: number, z: number): Vector3 {\r\n        return new Vector3(this._x * x, this._y * y, this._z * z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public divide(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public divideInPlace(otherVector: Vector3): Vector3 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<Vector3>): Vector3 {\r\n        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<Vector3>): Vector3 {\r\n        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public minimizeInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        if (x < this._x) {\r\n            this.x = x;\r\n        }\r\n        if (y < this._y) {\r\n            this.y = y;\r\n        }\r\n        if (z < this._z) {\r\n            this.z = z;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public maximizeInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        if (x > this._x) {\r\n            this.x = x;\r\n        }\r\n        if (y > this._y) {\r\n            this.y = y;\r\n        }\r\n        if (z > this._z) {\r\n            this.z = z;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\r\n     * Check if is non uniform within a certain amount of decimal places to account for this\r\n     * @param epsilon the amount the values can differ\r\n     * @returns if the the vector is non uniform to a certain number of decimal places\r\n     */\r\n    public isNonUniformWithinEpsilon(epsilon: number) {\r\n        const absX = Math.abs(this._x);\r\n        const absY = Math.abs(this._y);\r\n        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        const absZ = Math.abs(this._z);\r\n        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\r\n     */\r\n    public get isNonUniform(): boolean {\r\n        const absX = Math.abs(this._x);\r\n        const absY = Math.abs(this._y);\r\n        if (absX !== absY) {\r\n            return true;\r\n        }\r\n\r\n        const absZ = Math.abs(this._z);\r\n        if (absX !== absZ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    public floor(): Vector3 {\r\n        return new Vector3(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    public fract(): Vector3 {\r\n        return new Vector3(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\r\n    }\r\n\r\n    // Properties\r\n    /**\r\n     * Gets the length of the Vector3\r\n     * @returns the length of the Vector3\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\r\n    }\r\n\r\n    /**\r\n     * Gets the squared length of the Vector3\r\n     * @returns squared length of the Vector3\r\n     */\r\n    public lengthSquared(): number {\r\n        return this._x * this._x + this._y * this._y + this._z * this._z;\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3.\r\n     * Please note that this is an in place operation.\r\n     * @returns the current updated Vector3\r\n     */\r\n    public normalize(): Vector3 {\r\n        return this.normalizeFromLength(this.length());\r\n    }\r\n\r\n    /**\r\n     * Reorders the x y z properties of the vector in place\r\n     * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\r\n     * @returns the current updated vector\r\n     */\r\n    public reorderInPlace(order: string) {\r\n        order = order.toLowerCase();\r\n        if (order === \"xyz\") {\r\n            return this;\r\n        }\r\n        MathTmp.Vector3[0].copyFrom(this);\r\n        [\"x\", \"y\", \"z\"].forEach((val, i) => {\r\n            (<any>this)[val] = (<any>MathTmp.Vector3[0])[order[i]];\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates the vector around 0,0,0 by a quaternion\r\n     * @param quaternion the rotation quaternion\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    public rotateByQuaternionToRef(quaternion: Quaternion, result: Vector3) {\r\n        quaternion.toRotationMatrix(MathTmp.Matrix[0]);\r\n        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Rotates a vector around a given point\r\n     * @param quaternion the rotation quaternion\r\n     * @param point the point to rotate around\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    public rotateByQuaternionAroundPointToRef(quaternion: Quaternion, point: Vector3, result: Vector3) {\r\n        this.subtractToRef(point, MathTmp.Vector3[0]);\r\n        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\r\n        point.addToRef(MathTmp.Vector3[0], result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\r\n     * The cross product is then orthogonal to both current and \"other\"\r\n     * @param other defines the right operand\r\n     * @returns the cross product\r\n     */\r\n    public cross(other: Vector3) {\r\n        return Vector3.Cross(this, other);\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 with the given input length.\r\n     * Please note that this is an in place operation.\r\n     * @param len the length of the vector\r\n     * @returns the current updated Vector3\r\n     */\r\n    public normalizeFromLength(len: number): Vector3 {\r\n        if (len === 0 || len === 1.0) {\r\n            return this;\r\n        }\r\n\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 to a new vector\r\n     * @returns the new Vector3\r\n     */\r\n    public normalizeToNew(): Vector3 {\r\n        const normalized = new Vector3(0, 0, 0);\r\n        this.normalizeToRef(normalized);\r\n        return normalized;\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 to the reference\r\n     * @param reference define the Vector3 to update\r\n     * @returns the updated Vector3\r\n     */\r\n    public normalizeToRef(reference: Vector3): Vector3 {\r\n        const len = this.length();\r\n        if (len === 0 || len === 1.0) {\r\n            return reference.copyFromFloats(this._x, this._y, this._z);\r\n        }\r\n\r\n        return this.scaleToRef(1.0 / len, reference);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector3 copied from the current Vector3\r\n     * @returns the new Vector3\r\n     */\r\n    public clone(): Vector3 {\r\n        return new Vector3(this._x, this._y, this._z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given vector coordinates to the current Vector3 ones\r\n     * @param source defines the source Vector3\r\n     * @returns the current updated Vector3\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector3>): Vector3 {\r\n        return this.copyFromFloats(source._x, source._y, source._z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number): Vector3 {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public set(x: number, y: number, z: number): Vector3 {\r\n        return this.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y and z coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public setAll(v: number): Vector3 {\r\n        this.x = this.y = this.z = v;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Get the clip factor between two vectors\r\n     * @param vector0 defines the first operand\r\n     * @param vector1 defines the second operand\r\n     * @param axis defines the axis to use\r\n     * @param size defines the size along the axis\r\n     * @returns the clip factor\r\n     */\r\n    public static GetClipFactor(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, axis: DeepImmutable<Vector3>, size: number) {\r\n        const d0 = Vector3.Dot(vector0, axis) - size;\r\n        const d1 = Vector3.Dot(vector1, axis) - size;\r\n\r\n        const s = d0 / (d0 - d1);\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Get angle between two vectors\r\n     * @param vector0 angle between vector0 and vector1\r\n     * @param vector1 angle between vector0 and vector1\r\n     * @param normal direction of the normal\r\n     * @return the angle between vector0 and vector1\r\n     */\r\n    public static GetAngleBetweenVectors(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>): number {\r\n        const v0: Vector3 = vector0.normalizeToRef(MathTmp.Vector3[1]);\r\n        const v1: Vector3 = vector1.normalizeToRef(MathTmp.Vector3[2]);\r\n        const dot: number = Vector3.Dot(v0, v1);\r\n        const angle = Math.acos(dot);\r\n        const n = MathTmp.Vector3[3];\r\n        Vector3.CrossToRef(v0, v1, n);\r\n        if (Vector3.Dot(n, normal) > 0) {\r\n            return isNaN(angle) ? 0 : angle;\r\n        }\r\n        return isNaN(angle) ? -Math.PI : -Math.acos(dot);\r\n    }\r\n\r\n    /**\r\n     * Get angle between two vectors projected on a plane\r\n     * @param vector0 angle between vector0 and vector1\r\n     * @param vector1 angle between vector0 and vector1\r\n     * @param normal Normal of the projection plane\r\n     * @returns the angle between vector0 and vector1 projected on the plane with the specified normal\r\n     */\r\n    public static GetAngleBetweenVectorsOnPlane(vector0: Vector3, vector1: Vector3, normal: Vector3) {\r\n        MathTmp.Vector3[0].copyFrom(vector0);\r\n        const v0 = MathTmp.Vector3[0];\r\n        MathTmp.Vector3[1].copyFrom(vector1);\r\n        const v1 = MathTmp.Vector3[1];\r\n        MathTmp.Vector3[2].copyFrom(normal);\r\n        const vNormal = MathTmp.Vector3[2];\r\n        const right = MathTmp.Vector3[3];\r\n        const forward = MathTmp.Vector3[4];\r\n\r\n        v0.normalize();\r\n        v1.normalize();\r\n        vNormal.normalize();\r\n\r\n        Vector3.CrossToRef(vNormal, v0, right);\r\n        Vector3.CrossToRef(right, vNormal, forward);\r\n\r\n        const angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));\r\n\r\n        return Scalar.NormalizeRadians(angle);\r\n    }\r\n\r\n    /**\r\n     * Slerp between two vectors. See also `SmoothToRef`\r\n     * @param vector0 Start vector\r\n     * @param vector1 End vector\r\n     * @param slerp amount (will be clamped between 0 and 1)\r\n     * @param result The slerped vector\r\n     */\r\n    public static SlerpToRef(vector0: Vector3, vector1: Vector3, slerp: number, result: Vector3) {\r\n        slerp = Scalar.Clamp(slerp, 0, 1);\r\n        const vector0Dir = MathTmp.Vector3[0];\r\n        const vector1Dir = MathTmp.Vector3[1];\r\n\r\n        vector0Dir.copyFrom(vector0);\r\n        const vector0Length = vector0Dir.length();\r\n        vector0Dir.normalizeFromLength(vector0Length);\r\n\r\n        vector1Dir.copyFrom(vector1);\r\n        const vector1Length = vector1Dir.length();\r\n        vector1Dir.normalizeFromLength(vector1Length);\r\n\r\n        const dot = Vector3.Dot(vector0Dir, vector1Dir);\r\n\r\n        let scale0;\r\n        let scale1;\r\n\r\n        if (dot < 1 - Epsilon) {\r\n            const omega = Math.acos(dot);\r\n            const invSin = 1 / Math.sin(omega);\r\n            scale0 = Math.sin((1 - slerp) * omega) * invSin;\r\n            scale1 = Math.sin(slerp * omega) * invSin;\r\n        } else {\r\n            // Use linear interpolation\r\n            scale0 = 1 - slerp;\r\n            scale1 = slerp;\r\n        }\r\n\r\n        vector0Dir.scaleInPlace(scale0);\r\n        vector1Dir.scaleInPlace(scale1);\r\n        result.copyFrom(vector0Dir).addInPlace(vector1Dir);\r\n        result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));\r\n    }\r\n\r\n    /**\r\n     * Smooth interpolation between two vectors using Slerp\r\n     * @param source source vector\r\n     * @param goal goal vector\r\n     * @param deltaTime current interpolation frame\r\n     * @param lerpTime total interpolation time\r\n     * @param result the smoothed vector\r\n     */\r\n    public static SmoothToRef(source: Vector3, goal: Vector3, deltaTime: number, lerpTime: number, result: Vector3) {\r\n        Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Vector3 {\r\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     * @deprecated Please use FromArray instead.\r\n     */\r\n    public static FromFloatArray(array: DeepImmutable<Float32Array>, offset?: number): Vector3 {\r\n        return Vector3.FromArray(array, offset);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector3): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     * @deprecated Please use FromArrayToRef instead.\r\n     */\r\n    public static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector3): void {\r\n        return Vector3.FromArrayToRef(array, offset, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the given floats.\r\n     * @param x defines the x coordinate of the source\r\n     * @param y defines the y coordinate of the source\r\n     * @param z defines the z coordinate of the source\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void {\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\r\n     * @returns a new empty Vector3\r\n     */\r\n    public static Zero(): Vector3 {\r\n        return new Vector3(0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\r\n     * @returns a new unit Vector3\r\n     */\r\n    public static One(): Vector3 {\r\n        return new Vector3(1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\r\n     * @returns a new up Vector3\r\n     */\r\n    public static Up(): Vector3 {\r\n        return new Vector3(0.0, 1.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Gets a up Vector3 that must not be updated\r\n     */\r\n    public static get UpReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._UpReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a right Vector3 that must not be updated\r\n     */\r\n    public static get RightReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._RightReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a left Vector3 that must not be updated\r\n     */\r\n    public static get LeftReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._LeftReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a forward Vector3 that must not be updated\r\n     */\r\n    public static get LeftHandedForwardReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._LeftHandedForwardReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a forward Vector3 that must not be updated\r\n     */\r\n    public static get RightHandedForwardReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._RightHandedForwardReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a zero Vector3 that must not be updated\r\n     */\r\n    public static get ZeroReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._ZeroReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\r\n     * @returns a new down Vector3\r\n     */\r\n    public static Down(): Vector3 {\r\n        return new Vector3(0.0, -1.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\r\n     * @param rightHandedSystem is the scene right-handed (negative z)\r\n     * @returns a new forward Vector3\r\n     */\r\n    public static Forward(rightHandedSystem: boolean = false): Vector3 {\r\n        return new Vector3(0.0, 0.0, rightHandedSystem ? -1.0 : 1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\r\n     * @param rightHandedSystem is the scene right-handed (negative-z)\r\n     * @returns a new forward Vector3\r\n     */\r\n    public static Backward(rightHandedSystem: boolean = false): Vector3 {\r\n        return new Vector3(0.0, 0.0, rightHandedSystem ? 1.0 : -1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\r\n     * @returns a new right Vector3\r\n     */\r\n    public static Right(): Vector3 {\r\n        return new Vector3(1.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\r\n     * @returns a new left Vector3\r\n     */\r\n    public static Left(): Vector3 {\r\n        return new Vector3(-1.0, 0.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\r\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the transformed Vector3\r\n     */\r\n    public static TransformCoordinates(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3 {\r\n        const result = Vector3.Zero();\r\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\r\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformCoordinatesToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\r\n     * This method computes transformed coordinates only, not transformed direction vectors\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        const m = transformation.m;\r\n        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\r\n        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\r\n        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\r\n        const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\r\n\r\n        result.x = rx * rw;\r\n        result.y = ry * rw;\r\n        result.z = rz * rw;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the new Vector3\r\n     */\r\n    public static TransformNormal(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3 {\r\n        const result = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformNormalToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        const m = transformation.m;\r\n        result.x = x * m[0] + y * m[4] + z * m[8];\r\n        result.y = x * m[1] + y * m[5] + z * m[9];\r\n        result.z = x * m[2] + y * m[6] + z * m[10];\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\r\n     * @param value1 defines the first control point\r\n     * @param value2 defines the second control point\r\n     * @param value3 defines the third control point\r\n     * @param value4 defines the fourth control point\r\n     * @param amount defines the amount on the spline to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static CatmullRom(\r\n        value1: DeepImmutable<Vector3>,\r\n        value2: DeepImmutable<Vector3>,\r\n        value3: DeepImmutable<Vector3>,\r\n        value4: DeepImmutable<Vector3>,\r\n        amount: number\r\n    ): Vector3 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n\r\n        const x =\r\n            0.5 *\r\n            (2.0 * value2._x +\r\n                (-value1._x + value3._x) * amount +\r\n                (2.0 * value1._x - 5.0 * value2._x + 4.0 * value3._x - value4._x) * squared +\r\n                (-value1._x + 3.0 * value2._x - 3.0 * value3._x + value4._x) * cubed);\r\n\r\n        const y =\r\n            0.5 *\r\n            (2.0 * value2._y +\r\n                (-value1._y + value3._y) * amount +\r\n                (2.0 * value1._y - 5.0 * value2._y + 4.0 * value3._y - value4._y) * squared +\r\n                (-value1._y + 3.0 * value2._y - 3.0 * value3._y + value4._y) * cubed);\r\n\r\n        const z =\r\n            0.5 *\r\n            (2.0 * value2._z +\r\n                (-value1._z + value3._z) * amount +\r\n                (2.0 * value1._z - 5.0 * value2._z + 4.0 * value3._z - value4._z) * squared +\r\n                (-value1._z + 3.0 * value2._z - 3.0 * value3._z + value4._z) * cubed);\r\n\r\n        return new Vector3(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @returns the new Vector3\r\n     */\r\n    public static Clamp(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): Vector3 {\r\n        const v = new Vector3();\r\n        Vector3.ClampToRef(value, min, max, v);\r\n        return v;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static ClampToRef(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, result: Vector3): void {\r\n        let x = value._x;\r\n        x = x > max._x ? max._x : x;\r\n        x = x < min._x ? min._x : x;\r\n\r\n        let y = value._y;\r\n        y = y > max._y ? max._y : y;\r\n        y = y < min._y ? min._y : y;\r\n\r\n        let z = value._z;\r\n        z = z > max._z ? max._z : z;\r\n        z = z < min._z ? min._z : z;\r\n\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Checks if a given vector is inside a specific range\r\n     * @param v defines the vector to test\r\n     * @param min defines the minimum range\r\n     * @param max defines the maximum range\r\n     */\r\n    public static CheckExtends(v: Vector3, min: Vector3, max: Vector3): void {\r\n        min.minimizeInPlace(v);\r\n        max.maximizeInPlace(v);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent vector\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent vector\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    public static Hermite(\r\n        value1: DeepImmutable<Vector3>,\r\n        tangent1: DeepImmutable<Vector3>,\r\n        value2: DeepImmutable<Vector3>,\r\n        tangent2: DeepImmutable<Vector3>,\r\n        amount: number\r\n    ): Vector3 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\r\n        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\r\n        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\r\n        return new Vector3(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Vector3>,\r\n        tangent1: DeepImmutable<Vector3>,\r\n        value2: DeepImmutable<Vector3>,\r\n        tangent2: DeepImmutable<Vector3>,\r\n        time: number\r\n    ): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a Vector3 with the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Vector3>,\r\n        tangent1: DeepImmutable<Vector3>,\r\n        value2: DeepImmutable<Vector3>,\r\n        tangent2: DeepImmutable<Vector3>,\r\n        time: number,\r\n        result: Vector3\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\r\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\r\n        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    public static Lerp(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number): Vector3 {\r\n        const result = new Vector3(0, 0, 0);\r\n        Vector3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static LerpToRef(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number, result: Vector3): void {\r\n        result.x = start._x + (end._x - start._x) * amount;\r\n        result.y = start._y + (end._y - start._y) * amount;\r\n        result.z = start._z + (end._z - start._z) * amount;\r\n    }\r\n\r\n    /**\r\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    public static Dot(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): number {\r\n        return left._x * right._x + left._y * right._y + left._z * right._z;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the cross product\r\n     */\r\n    public static Cross(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        const result = Vector3.Zero();\r\n        Vector3.CrossToRef(left, right, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static CrossToRef(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>, result: Vector3): void {\r\n        const x = left._y * right._z - left._z * right._y;\r\n        const y = left._z * right._x - left._x * right._z;\r\n        const z = left._x * right._y - left._y * right._x;\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the normalization of the given vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @returns the new Vector3\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector3>): Vector3 {\r\n        const result = Vector3.Zero();\r\n        Vector3.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the normalization of the given first vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static NormalizeToRef(vector: DeepImmutable<Vector3>, result: Vector3): void {\r\n        vector.normalizeToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Project a Vector3 onto screen space\r\n     * @param vector defines the Vector3 to project\r\n     * @param world defines the world matrix to use\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @param viewport defines the screen viewport to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static Project(vector: DeepImmutable<Vector3>, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>, viewport: DeepImmutable<Viewport>): Vector3 {\r\n        const result = new Vector3();\r\n        Vector3.ProjectToRef(vector, world, transform, viewport, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Project a Vector3 onto screen space to reference\r\n     * @param vector defines the Vector3 to project\r\n     * @param world defines the world matrix to use\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @param viewport defines the screen viewport to use\r\n     * @param result the vector in which the screen space will be stored\r\n     * @returns the new Vector3\r\n     */\r\n    public static ProjectToRef(\r\n        vector: DeepImmutable<Vector3>,\r\n        world: DeepImmutable<Matrix>,\r\n        transform: DeepImmutable<Matrix>,\r\n        viewport: DeepImmutable<Viewport>,\r\n        result: DeepImmutable<Vector3>\r\n    ): Vector3 {\r\n        const cw = viewport.width;\r\n        const ch = viewport.height;\r\n        const cx = viewport.x;\r\n        const cy = viewport.y;\r\n\r\n        const viewportMatrix = MathTmp.Matrix[1];\r\n\r\n        Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\r\n\r\n        const matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(transform, matrix);\r\n        matrix.multiplyToRef(viewportMatrix, matrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(vector, matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param source\r\n     * @param matrix\r\n     * @param result\r\n     * @hidden\r\n     */\r\n    public static _UnprojectFromInvertedMatrixToRef(source: DeepImmutable<Vector3>, matrix: DeepImmutable<Matrix>, result: Vector3) {\r\n        Vector3.TransformCoordinatesToRef(source, matrix, result);\r\n        const m = matrix.m;\r\n        const num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\r\n        if (Scalar.WithinEpsilon(num, 1.0)) {\r\n            result.scaleInPlace(1.0 / num);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static UnprojectFromTransform(source: Vector3, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>): Vector3 {\r\n        return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static Unproject(\r\n        source: DeepImmutable<Vector3>,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static UnprojectToRef(\r\n        source: DeepImmutable<Vector3>,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        result: Vector3\r\n    ): void {\r\n        Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param sourceZ defines the screen space z coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static UnprojectFloatsToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        sourceZ: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        result: Vector3\r\n    ): void {\r\n        const matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const screenSource = MathTmp.Vector3[0];\r\n        screenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        screenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        if (EngineStore.LastCreatedEngine?.isNDCHalfZRange) {\r\n            screenSource.z = sourceZ;\r\n        } else {\r\n            screenSource.z = 2 * sourceZ - 1.0;\r\n        }\r\n\r\n        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\r\n    }\r\n\r\n    /**\r\n     * Gets the minimal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        const min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Gets the maximal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        const max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n\r\n    /**\r\n     * Returns the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the distance\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number {\r\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\r\n    }\r\n\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the squared distance\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number {\r\n        const x = value1._x - value2._x;\r\n        const y = value1._y - value2._y;\r\n        const z = value1._z - value2._z;\r\n\r\n        return x * x + y * y + z * z;\r\n    }\r\n\r\n    /**\r\n     * Projects \"vector\" on the triangle determined by its extremities \"p0\", \"p1\" and \"p2\", stores the result in \"ref\"\r\n     * and returns the distance to the projected point.\r\n     * From http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf\r\n     *\r\n     * @param vector the vector to get distance from\r\n     * @param p0 extremity of the triangle\r\n     * @param p1 extremity of the triangle\r\n     * @param p2 extremity of the triangle\r\n     * @param ref variable to store the result to\r\n     * @returns The distance between \"ref\" and \"vector\"\r\n     */\r\n    public static ProjectOnTriangleToRef(vector: DeepImmutable<Vector3>, p0: DeepImmutable<Vector3>, p1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, ref: Vector3): number {\r\n        const p1p0 = MathTmp.Vector3[0];\r\n        const p2p0 = MathTmp.Vector3[1];\r\n        const p2p1 = MathTmp.Vector3[2];\r\n        const normal = MathTmp.Vector3[3];\r\n        const vectorp0 = MathTmp.Vector3[4];\r\n\r\n        // Triangle vectors\r\n        p1.subtractToRef(p0, p1p0);\r\n        p2.subtractToRef(p0, p2p0);\r\n        p2.subtractToRef(p1, p2p1);\r\n\r\n        const p1p0L = p1p0.length();\r\n        const p2p0L = p2p0.length();\r\n        const p2p1L = p2p1.length();\r\n\r\n        if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {\r\n            // This is a degenerate triangle. As we assume this is part of a non-degenerate mesh,\r\n            // we will find a better intersection later.\r\n            // Let's just return one of the extremities\r\n            ref.copyFrom(p0);\r\n            return Vector3.Distance(vector, p0);\r\n        }\r\n\r\n        // Compute normal and vector to p0\r\n        vector.subtractToRef(p0, vectorp0);\r\n        Vector3.CrossToRef(p1p0, p2p0, normal);\r\n        const nl = normal.length();\r\n        if (nl < Epsilon) {\r\n            // Extremities are aligned, we are back on the case of a degenerate triangle\r\n            ref.copyFrom(p0);\r\n            return Vector3.Distance(vector, p0);\r\n        }\r\n        normal.normalizeFromLength(nl);\r\n        let l = vectorp0.length();\r\n        if (l < Epsilon) {\r\n            // Vector is p0\r\n            ref.copyFrom(p0);\r\n            return 0;\r\n        }\r\n        vectorp0.normalizeFromLength(l);\r\n\r\n        // Project to \"proj\" that lies on the triangle plane\r\n        const cosA = Vector3.Dot(normal, vectorp0);\r\n        const projVector = MathTmp.Vector3[5];\r\n        const proj = MathTmp.Vector3[6];\r\n        projVector.copyFrom(normal).scaleInPlace(-l * cosA);\r\n        proj.copyFrom(vector).addInPlace(projVector);\r\n\r\n        // Compute barycentric coordinates (v0, v1 and v2 are axis from barycenter to extremities)\r\n        const v0 = MathTmp.Vector3[4];\r\n        const v1 = MathTmp.Vector3[5];\r\n        const v2 = MathTmp.Vector3[7];\r\n        const tmp = MathTmp.Vector3[8];\r\n\r\n        v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);\r\n        tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);\r\n        v0.addInPlace(tmp).scaleInPlace(-1);\r\n\r\n        v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);\r\n        tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);\r\n        v1.addInPlace(tmp).scaleInPlace(-1);\r\n\r\n        v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);\r\n        tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);\r\n        v2.addInPlace(tmp).scaleInPlace(-1);\r\n\r\n        // Determines which edge of the triangle is closest to \"proj\"\r\n        const projP = MathTmp.Vector3[9];\r\n        let dot;\r\n        projP.copyFrom(proj).subtractInPlace(p0);\r\n        Vector3.CrossToRef(v0, projP, tmp);\r\n        dot = Vector3.Dot(tmp, normal);\r\n        const s0 = dot;\r\n\r\n        projP.copyFrom(proj).subtractInPlace(p1);\r\n        Vector3.CrossToRef(v1, projP, tmp);\r\n        dot = Vector3.Dot(tmp, normal);\r\n        const s1 = dot;\r\n\r\n        projP.copyFrom(proj).subtractInPlace(p2);\r\n        Vector3.CrossToRef(v2, projP, tmp);\r\n        dot = Vector3.Dot(tmp, normal);\r\n        const s2 = dot;\r\n\r\n        const edge = MathTmp.Vector3[10];\r\n        let e0, e1;\r\n        if (s0 > 0 && s1 < 0) {\r\n            edge.copyFrom(p1p0);\r\n            e0 = p0;\r\n            e1 = p1;\r\n        } else if (s1 > 0 && s2 < 0) {\r\n            edge.copyFrom(p2p1);\r\n            e0 = p1;\r\n            e1 = p2;\r\n        } else {\r\n            edge.copyFrom(p2p0).scaleInPlace(-1);\r\n            e0 = p2;\r\n            e1 = p0;\r\n        }\r\n\r\n        // Determines if \"proj\" lies inside the triangle\r\n        const tmp2 = MathTmp.Vector3[9];\r\n        const tmp3 = MathTmp.Vector3[4];\r\n        e0.subtractToRef(proj, tmp);\r\n        e1.subtractToRef(proj, tmp2);\r\n        Vector3.CrossToRef(tmp, tmp2, tmp3);\r\n        const isOutside = Vector3.Dot(tmp3, normal) < 0;\r\n\r\n        // If inside, we already found the projected point, \"proj\"\r\n        if (!isOutside) {\r\n            ref.copyFrom(proj);\r\n            return Math.abs(l * cosA);\r\n        }\r\n\r\n        // If outside, we find \"triProj\", the closest point from \"proj\" on the closest edge\r\n        const r = MathTmp.Vector3[5];\r\n        Vector3.CrossToRef(edge, tmp3, r);\r\n        r.normalize();\r\n        const e0proj = MathTmp.Vector3[9];\r\n        e0proj.copyFrom(e0).subtractInPlace(proj);\r\n        const e0projL = e0proj.length();\r\n        if (e0projL < Epsilon) {\r\n            // Proj is e0\r\n            ref.copyFrom(e0);\r\n            return Vector3.Distance(vector, e0);\r\n        }\r\n        e0proj.normalizeFromLength(e0projL);\r\n        const cosG = Vector3.Dot(r, e0proj);\r\n        const triProj = MathTmp.Vector3[7];\r\n        triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));\r\n\r\n        // Now we clamp \"triProj\" so it lies between e0 and e1\r\n        tmp.copyFrom(triProj).subtractInPlace(e0);\r\n        l = edge.length();\r\n        edge.normalizeFromLength(l);\r\n        let t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);\r\n        t = Scalar.Clamp(t, 0, 1);\r\n        triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));\r\n        ref.copyFrom(triProj);\r\n\r\n        return Vector3.Distance(vector, triProj);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): Vector3 {\r\n        return Vector3.CenterToRef(value1, value2, Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @param ref defines third vector\r\n     * @returns ref\r\n     */\r\n    public static CenterToRef(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>, ref: DeepImmutable<Vector3>): Vector3 {\r\n        return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);\r\n    }\r\n\r\n    /**\r\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\r\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\r\n     * to something in order to rotate it from its local system to the given target system\r\n     * Note: axis1, axis2 and axis3 are normalized during this operation\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/target_align\r\n     */\r\n    public static RotationFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Vector3 {\r\n        const rotation = Vector3.Zero();\r\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\r\n        return rotation;\r\n    }\r\n\r\n    /**\r\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the Vector3 where to store the result\r\n     */\r\n    public static RotationFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Vector3): void {\r\n        const quat = MathTmp.Quaternion[0];\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        quat.toEulerAnglesToRef(ref);\r\n    }\r\n}\r\n\r\n/**\r\n * Vector4 class created for EulerAngle class conversion to Quaternion\r\n */\r\nexport class Vector4 {\r\n    /**\r\n     * Creates a Vector4 object from the given floats.\r\n     * @param x x value of the vector\r\n     * @param y y value of the vector\r\n     * @param z z value of the vector\r\n     * @param w w value of the vector\r\n     */\r\n    constructor(\r\n        /** x value of the vector */\r\n        public x: number,\r\n        /** y value of the vector */\r\n        public y: number,\r\n        /** z value of the vector */\r\n        public z: number,\r\n        /** w value of the vector */\r\n        public w: number\r\n    ) {}\r\n\r\n    /**\r\n     * Returns the string with the Vector4 coordinates.\r\n     * @returns a string containing all the vector values\r\n     */\r\n    public toString(): string {\r\n        return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Vector4\".\r\n     * @returns \"Vector4\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector4\";\r\n    }\r\n\r\n    /**\r\n     * Returns the Vector4 hash code.\r\n     * @returns a unique hash code\r\n     */\r\n    public getHashCode(): number {\r\n        const x = _ExtractAsInt(this.x);\r\n        const y = _ExtractAsInt(this.y);\r\n        const z = _ExtractAsInt(this.z);\r\n        const w = _ExtractAsInt(this.w);\r\n\r\n        let hash = x;\r\n        hash = (hash * 397) ^ y;\r\n        hash = (hash * 397) ^ z;\r\n        hash = (hash * 397) ^ w;\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n    /**\r\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\r\n     * @returns the resulting array\r\n     */\r\n    public asArray(): number[] {\r\n        const result = new Array<number>();\r\n\r\n        this.toArray(result, 0);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array from the given index with the Vector4 coordinates.\r\n     * @param array array to populate\r\n     * @param index index of the array to start at (default: 0)\r\n     * @returns the Vector4.\r\n     */\r\n    public toArray(array: FloatArray, index?: number): Vector4 {\r\n        if (index === undefined) {\r\n            index = 0;\r\n        }\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        array[index + 2] = this.z;\r\n        array[index + 3] = this.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector4 {\r\n        Vector4.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the given vector to the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the updated Vector4.\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        this.z += otherVector.z;\r\n        this.w += otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @returns the resulting vector\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\r\n    }\r\n\r\n    /**\r\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        result.z = this.z + otherVector.z;\r\n        result.w = this.w + otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Subtract in place the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @returns the updated Vector4.\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        this.z -= otherVector.z;\r\n        this.w -= otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the new vector with the result\r\n     */\r\n    public subtract(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        result.z = this.z - otherVector.z;\r\n        result.w = this.w - otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     */\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @returns new vector containing the result\r\n     */\r\n    public subtractFromFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @param result the vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    public subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4 {\r\n        result.x = this.x - x;\r\n        result.y = this.y - y;\r\n        result.z = this.z - z;\r\n        result.w = this.w - w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\r\n     * @returns a new vector with the negated values\r\n     */\r\n    public negate(): Vector4 {\r\n        return new Vector4(-this.x, -this.y, -this.z, -this.w);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector4 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        this.w *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector4\r\n     */\r\n    public negateToRef(result: Vector4): Vector4 {\r\n        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector4 coordinates by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns the updated Vector4.\r\n     */\r\n    public scaleInPlace(scale: number): Vector4 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns a new vector with the result\r\n     */\r\n    public scale(scale: number): Vector4 {\r\n        return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @param result a vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    public scaleToRef(scale: number, result: Vector4): Vector4 {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        result.z = this.z * scale;\r\n        result.w = this.w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector4 object where to store the result\r\n     * @returns the unmodified current Vector4\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector4): Vector4 {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        result.z += this.z * scale;\r\n        result.w += this.w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\r\n     * @param otherVector the vector to compare against\r\n     * @returns true if they are equal\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector4>): boolean {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\r\n     * @param otherVector vector to compare against\r\n     * @param epsilon (Default: very small number)\r\n     * @returns true if they are equal\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector4>, epsilon: number = Epsilon): boolean {\r\n        return (\r\n            otherVector &&\r\n            Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\r\n            Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\r\n            Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) &&\r\n            Scalar.WithinEpsilon(this.w, otherVector.w, epsilon)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\r\n     * @param x x value to compare against\r\n     * @param y y value to compare against\r\n     * @param z z value to compare against\r\n     * @param w w value to compare against\r\n     * @returns true if equal\r\n     */\r\n    public equalsToFloats(x: number, y: number, z: number, w: number): boolean {\r\n        return this.x === x && this.y === y && this.z === z && this.w === w;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current Vector4 by the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns the updated Vector4.\r\n     */\r\n    public multiplyInPlace(otherVector: Vector4): Vector4 {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        this.z *= otherVector.z;\r\n        this.w *= otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns resulting new vector\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        result.z = this.z * otherVector.z;\r\n        result.w = this.w * otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\r\n     * @param x x value multiply with\r\n     * @param y y value multiply with\r\n     * @param z z value multiply with\r\n     * @param w w value multiply with\r\n     * @returns resulting new vector\r\n     */\r\n    public multiplyByFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @returns resulting new vector\r\n     */\r\n    public divide(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        result.z = this.z / otherVector.z;\r\n        result.w = this.w / otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector vector to devide with\r\n     * @returns the updated Vector3.\r\n     */\r\n    public divideInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<Vector4>): Vector4 {\r\n        if (other.x < this.x) {\r\n            this.x = other.x;\r\n        }\r\n        if (other.y < this.y) {\r\n            this.y = other.y;\r\n        }\r\n        if (other.z < this.z) {\r\n            this.z = other.z;\r\n        }\r\n        if (other.w < this.w) {\r\n            this.w = other.w;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<Vector4>): Vector4 {\r\n        if (other.x > this.x) {\r\n            this.x = other.x;\r\n        }\r\n        if (other.y > this.y) {\r\n            this.y = other.y;\r\n        }\r\n        if (other.z > this.z) {\r\n            this.z = other.z;\r\n        }\r\n        if (other.w > this.w) {\r\n            this.w = other.w;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector4 from current Vector4 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    public floor(): Vector4 {\r\n        return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector4 from current Vector3 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    public fract(): Vector4 {\r\n        return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\r\n    }\r\n\r\n    // Properties\r\n    /**\r\n     * Returns the Vector4 length (float).\r\n     * @returns the length\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    }\r\n    /**\r\n     * Returns the Vector4 squared length (float).\r\n     * @returns the length squared\r\n     */\r\n    public lengthSquared(): number {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Normalizes in place the Vector4.\r\n     * @returns the updated Vector4.\r\n     */\r\n    public normalize(): Vector4 {\r\n        const len = this.length();\r\n\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\r\n     * @returns this converted to a new vector3\r\n     */\r\n    public toVector3(): Vector3 {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 copied from the current one.\r\n     * @returns the new cloned vector\r\n     */\r\n    public clone(): Vector4 {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    }\r\n    /**\r\n     * Updates the current Vector4 with the given one coordinates.\r\n     * @param source the source vector to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector4>): Vector4 {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        this.z = source.z;\r\n        this.w = source.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to copy from\r\n     * @param y float to copy from\r\n     * @param z float to copy from\r\n     * @param w float to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public set(x: number, y: number, z: number, w: number): Vector4 {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y, z and w coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public setAll(v: number): Vector4 {\r\n        this.x = this.y = this.z = this.w = v;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new Vector4 set from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @returns the new vector\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Vector4 {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector4): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n        result.w = array[offset + 3];\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given Float32Array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector4): void {\r\n        Vector4.FromArrayToRef(array, offset, result);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" coordinates from the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @param result the vector to the floats in\r\n     */\r\n    public static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void {\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = w;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\r\n     * @returns the new vector\r\n     */\r\n    public static Zero(): Vector4 {\r\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\r\n     * @returns the new vector\r\n     */\r\n    public static One(): Vector4 {\r\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new normalized Vector4 from the given one.\r\n     * @param vector the vector to normalize\r\n     * @returns the vector\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector4>): Vector4 {\r\n        const result = Vector4.Zero();\r\n        Vector4.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the normalization of the given one.\r\n     * @param vector the vector to normalize\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static NormalizeToRef(vector: DeepImmutable<Vector4>, result: Vector4): void {\r\n        result.copyFrom(vector);\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns a vector with the minimum values from the left and right vectors\r\n     * @param left left vector to minimize\r\n     * @param right right vector to minimize\r\n     * @returns a new vector with the minimum of the left and right vector values\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4 {\r\n        const min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Returns a vector with the maximum values from the left and right vectors\r\n     * @param left left vector to maximize\r\n     * @param right right vector to maximize\r\n     * @returns a new vector with the maximum of the left and right vector values\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4 {\r\n        const max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n    /**\r\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number {\r\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\r\n    }\r\n    /**\r\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors squared\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number {\r\n        const x = value1.x - value2.x;\r\n        const y = value1.y - value2.y;\r\n        const z = value1.z - value2.z;\r\n        const w = value1.w - value2.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the center between\r\n     * @param value2 value to calulate the center between\r\n     * @return the center between the two vectors\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): Vector4 {\r\n        return Vector4.CenterToRef(value1, value2, Vector4.Zero());\r\n    }\r\n\r\n    /**\r\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @param ref defines third vector\r\n     * @returns ref\r\n     */\r\n    public static CenterToRef(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>, ref: DeepImmutable<Vector4>): Vector4 {\r\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the result of the transformation by the given matrix of the given vector.\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * The difference with Vector3.TransformCoordinates is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the transformed Vector4\r\n     */\r\n    public static TransformCoordinates(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector4 {\r\n        const result = Vector4.Zero();\r\n        Vector4.TransformCoordinatesToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * The difference with Vector3.TransformCoordinatesToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector4 where to store the result\r\n     */\r\n    public static TransformCoordinatesToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\r\n     * This method computes tranformed coordinates only, not transformed direction vectors\r\n     * The difference with Vector3.TransformCoordinatesFromFloatsToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector4 where to store the result\r\n     */\r\n    public static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        const m = transformation.m;\r\n        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\r\n        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\r\n        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\r\n        const rw = x * m[3] + y * m[7] + z * m[11] + m[15];\r\n\r\n        result.x = rx;\r\n        result.y = ry;\r\n        result.z = rz;\r\n        result.w = rw;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @returns the new vector\r\n     */\r\n    public static TransformNormal(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>): Vector4 {\r\n        const result = Vector4.Zero();\r\n        Vector4.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static TransformNormalToRef(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        const m = transformation.m;\r\n        const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\r\n        const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\r\n        const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = vector.w;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param x value to transform\r\n     * @param y value to transform\r\n     * @param z value to transform\r\n     * @param w value to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the results in\r\n     */\r\n    public static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        const m = transformation.m;\r\n        result.x = x * m[0] + y * m[4] + z * m[8];\r\n        result.y = x * m[1] + y * m[5] + z * m[9];\r\n        result.z = x * m[2] + y * m[6] + z * m[10];\r\n        result.w = w;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector4 from a Vector3\r\n     * @param source defines the source data\r\n     * @param w defines the 4th component (default is 0)\r\n     * @returns a new Vector4\r\n     */\r\n    public static FromVector3(source: Vector3, w: number = 0) {\r\n        return new Vector4(source._x, source._y, source._z, w);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store quaternion data\r\n * @see https://en.wikipedia.org/wiki/Quaternion\r\n * @see https://doc.babylonjs.com/features/position,_rotation,_scaling\r\n */\r\nexport class Quaternion {\r\n    /** @hidden */\r\n    public _x: number;\r\n\r\n    /** @hidden */\r\n    public _y: number;\r\n\r\n    /** @hidden */\r\n    public _z: number;\r\n\r\n    /** @hidden */\r\n    public _w: number;\r\n\r\n    /** @hidden */\r\n    public _isDirty = true;\r\n\r\n    /** Gets or sets the x coordinate */\r\n    public get x() {\r\n        return this._x;\r\n    }\r\n\r\n    public set x(value: number) {\r\n        this._x = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the y coordinate */\r\n    public get y() {\r\n        return this._y;\r\n    }\r\n\r\n    public set y(value: number) {\r\n        this._y = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the z coordinate */\r\n    public get z() {\r\n        return this._z;\r\n    }\r\n\r\n    public set z(value: number) {\r\n        this._z = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the w coordinate */\r\n    public get w() {\r\n        return this._w;\r\n    }\r\n\r\n    public set w(value: number) {\r\n        this._w = value;\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Creates a new Quaternion from the given floats\r\n     * @param x defines the first component (0 by default)\r\n     * @param y defines the second component (0 by default)\r\n     * @param z defines the third component (0 by default)\r\n     * @param w defines the fourth component (1.0 by default)\r\n     */\r\n    constructor(x: number = 0.0, y: number = 0.0, z: number = 0.0, w: number = 1.0) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._w = w;\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation for the current quaternion\r\n     * @returns a string with the Quaternion coordinates\r\n     */\r\n    public toString(): string {\r\n        return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the quaternion\r\n     * @returns the string \"Quaternion\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Quaternion\";\r\n    }\r\n\r\n    /**\r\n     * Gets a hash code for this quaternion\r\n     * @returns the quaternion hash code\r\n     */\r\n    public getHashCode(): number {\r\n        const x = _ExtractAsInt(this._x);\r\n        const y = _ExtractAsInt(this._y);\r\n        const z = _ExtractAsInt(this._z);\r\n        const w = _ExtractAsInt(this._w);\r\n\r\n        let hash = x;\r\n        hash = (hash * 397) ^ y;\r\n        hash = (hash * 397) ^ z;\r\n        hash = (hash * 397) ^ w;\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion to an array\r\n     * @returns a new array populated with 4 elements from the quaternion coordinates\r\n     */\r\n    public asArray(): number[] {\r\n        return [this._x, this._y, this._z, this._w];\r\n    }\r\n    /**\r\n     * Check if two quaternions are equals\r\n     * @param otherQuaternion defines the second operand\r\n     * @return true if the current quaternion and the given one coordinates are strictly equals\r\n     */\r\n    public equals(otherQuaternion: DeepImmutable<Quaternion>): boolean {\r\n        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two quaternions are equals (using an epsilon value)\r\n     * @param otherQuaternion defines the other quaternion\r\n     * @param epsilon defines the minimal distance to consider equality\r\n     * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\r\n     */\r\n    public equalsWithEpsilon(otherQuaternion: DeepImmutable<Quaternion>, epsilon: number = Epsilon): boolean {\r\n        return (\r\n            otherQuaternion &&\r\n            Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) &&\r\n            Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) &&\r\n            Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) &&\r\n            Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Clone the current quaternion\r\n     * @returns a new quaternion copied from the current one\r\n     */\r\n    public clone(): Quaternion {\r\n        return new Quaternion(this._x, this._y, this._z, this._w);\r\n    }\r\n\r\n    /**\r\n     * Copy a quaternion to the current one\r\n     * @param other defines the other quaternion\r\n     * @returns the updated current quaternion\r\n     */\r\n    public copyFrom(other: DeepImmutable<Quaternion>): Quaternion {\r\n        this.x = other._x;\r\n        this.y = other._y;\r\n        this.z = other._z;\r\n        this.w = other._w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion with the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number, w: number): Quaternion {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion from the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    public set(x: number, y: number, z: number, w: number): Quaternion {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Adds two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\r\n     */\r\n    public add(other: DeepImmutable<Quaternion>): Quaternion {\r\n        return new Quaternion(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\r\n    }\r\n\r\n    /**\r\n     * Add a quaternion to the current one\r\n     * @param other defines the quaternion to add\r\n     * @returns the current quaternion\r\n     */\r\n    public addInPlace(other: DeepImmutable<Quaternion>): Quaternion {\r\n        this._x += other._x;\r\n        this._y += other._y;\r\n        this._z += other._z;\r\n        this._w += other._w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Subtract two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the subtraction result of the given one from the current one\r\n     */\r\n    public subtract(other: Quaternion): Quaternion {\r\n        return new Quaternion(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\r\n     */\r\n    public scale(value: number): Quaternion {\r\n        return new Quaternion(this._x * value, this._y * value, this._z * value, this._w * value);\r\n    }\r\n\r\n    /**\r\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    public scaleToRef(scale: number, result: Quaternion): Quaternion {\r\n        result.x = this._x * scale;\r\n        result.y = this._y * scale;\r\n        result.z = this._z * scale;\r\n        result.w = this._w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns the current modified quaternion\r\n     */\r\n    public scaleInPlace(value: number): Quaternion {\r\n        this.x *= value;\r\n        this.y *= value;\r\n        this.z *= value;\r\n        this.w *= value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Quaternion): Quaternion {\r\n        result.x += this._x * scale;\r\n        result.y += this._y * scale;\r\n        result.z += this._z * scale;\r\n        result.w += this._w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two quaternions\r\n     * @param q1 defines the second operand\r\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\r\n     */\r\n    public multiply(q1: DeepImmutable<Quaternion>): Quaternion {\r\n        const result = new Quaternion(0, 0, 0, 1.0);\r\n        this.multiplyToRef(q1, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @param result defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    public multiplyToRef(q1: DeepImmutable<Quaternion>, result: Quaternion): Quaternion {\r\n        const x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\r\n        const y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\r\n        const z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\r\n        const w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\r\n        result.copyFromFloats(x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @returns the currentupdated quaternion\r\n     */\r\n    public multiplyInPlace(q1: DeepImmutable<Quaternion>): Quaternion {\r\n        this.multiplyToRef(q1, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\r\n     * @param ref defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    public conjugateToRef(ref: Quaternion): Quaternion {\r\n        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    public conjugateInPlace(): Quaternion {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns a new quaternion\r\n     */\r\n    public conjugate(): Quaternion {\r\n        const result = new Quaternion(-this._x, -this._y, -this._z, this._w);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets length of current quaternion\r\n     * @returns the quaternion length (float)\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\r\n    }\r\n\r\n    /**\r\n     * Normalize in place the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    public normalize(): Quaternion {\r\n        const len = this.length();\r\n\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n\r\n        const inv = 1.0 / len;\r\n        this.x *= inv;\r\n        this.y *= inv;\r\n        this.z *= inv;\r\n        this.w *= inv;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the Euler angles translated from the current quaternion\r\n     * @returns a new Vector3 containing the Euler angles\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\r\n     */\r\n    public toEulerAngles(): Vector3 {\r\n        const result = Vector3.Zero();\r\n        this.toEulerAnglesToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\r\n     * @param result defines the vector which will be filled with the Euler angles\r\n     * @returns the current unchanged quaternion\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\r\n     */\r\n    public toEulerAnglesToRef(result: Vector3): Quaternion {\r\n        const qz = this._z;\r\n        const qx = this._x;\r\n        const qy = this._y;\r\n        const qw = this._w;\r\n\r\n        const sqw = qw * qw;\r\n        const sqz = qz * qz;\r\n        const sqx = qx * qx;\r\n        const sqy = qy * qy;\r\n\r\n        const zAxisY = qy * qz - qx * qw;\r\n        const limit = 0.4999999;\r\n\r\n        if (zAxisY < -limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = Math.PI / 2;\r\n            result.z = 0;\r\n        } else if (zAxisY > limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = -Math.PI / 2;\r\n            result.z = 0;\r\n        } else {\r\n            result.z = Math.atan2(2.0 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);\r\n            result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\r\n            result.y = Math.atan2(2.0 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the given rotation matrix with the current quaternion values\r\n     * @param result defines the target matrix\r\n     * @returns the current unchanged quaternion\r\n     */\r\n    public toRotationMatrix(result: Matrix): Quaternion {\r\n        Matrix.FromQuaternionToRef(this, result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion from the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @returns the current updated quaternion\r\n     */\r\n    public fromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion {\r\n        Quaternion.FromRotationMatrixToRef(matrix, this);\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new quaternion from a rotation matrix\r\n     * @param matrix defines the source matrix\r\n     * @returns a new quaternion created from the given rotation matrix values\r\n     */\r\n    public static FromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion {\r\n        const result = new Quaternion();\r\n        Quaternion.FromRotationMatrixToRef(matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Updates the given quaternion with the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static FromRotationMatrixToRef(matrix: DeepImmutable<Matrix>, result: Quaternion): void {\r\n        const data = matrix.m;\r\n        const m11 = data[0],\r\n            m12 = data[4],\r\n            m13 = data[8];\r\n        const m21 = data[1],\r\n            m22 = data[5],\r\n            m23 = data[9];\r\n        const m31 = data[2],\r\n            m32 = data[6],\r\n            m33 = data[10];\r\n        const trace = m11 + m22 + m33;\r\n        let s;\r\n\r\n        if (trace > 0) {\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n\r\n            result.w = 0.25 / s;\r\n            result.x = (m32 - m23) * s;\r\n            result.y = (m13 - m31) * s;\r\n            result.z = (m21 - m12) * s;\r\n        } else if (m11 > m22 && m11 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n\r\n            result.w = (m32 - m23) / s;\r\n            result.x = 0.25 * s;\r\n            result.y = (m12 + m21) / s;\r\n            result.z = (m13 + m31) / s;\r\n        } else if (m22 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n\r\n            result.w = (m13 - m31) / s;\r\n            result.x = (m12 + m21) / s;\r\n            result.y = 0.25 * s;\r\n            result.z = (m23 + m32) / s;\r\n        } else {\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n\r\n            result.w = (m21 - m12) / s;\r\n            result.x = (m13 + m31) / s;\r\n            result.y = (m23 + m32) / s;\r\n            result.z = 0.25 * s;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    public static Dot(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>): number {\r\n        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\r\n    }\r\n\r\n    /**\r\n     * Checks if the two quaternions are close to each other\r\n     * @param quat0 defines the first quaternion to check\r\n     * @param quat1 defines the second quaternion to check\r\n     * @returns true if the two quaternions are close to each other\r\n     */\r\n    public static AreClose(quat0: DeepImmutable<Quaternion>, quat1: DeepImmutable<Quaternion>): boolean {\r\n        const dot = Quaternion.Dot(quat0, quat1);\r\n\r\n        return dot >= 0;\r\n    }\r\n\r\n    /**\r\n     * Smooth interpolation between two quaternions using Slerp\r\n     *\r\n     * @param source source quaternion\r\n     * @param goal goal quaternion\r\n     * @param deltaTime current interpolation frame\r\n     * @param lerpTime total interpolation time\r\n     * @param result the smoothed quaternion\r\n     */\r\n    public static SmoothToRef(source: Quaternion, goal: Quaternion, deltaTime: number, lerpTime: number, result: Quaternion) {\r\n        let slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;\r\n        slerp = Scalar.Clamp(slerp, 0, 1);\r\n\r\n        Quaternion.SlerpToRef(source, goal, slerp, result);\r\n    }\r\n\r\n    /**\r\n     * Creates an empty quaternion\r\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\r\n     */\r\n    public static Zero(): Quaternion {\r\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @returns a new quaternion as the inverted current quaternion\r\n     */\r\n    public static Inverse(q: DeepImmutable<Quaternion>): Quaternion {\r\n        return new Quaternion(-q._x, -q._y, -q._z, q._w);\r\n    }\r\n\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @param result the quaternion the result will be stored in\r\n     * @returns the result quaternion\r\n     */\r\n    public static InverseToRef(q: Quaternion, result: Quaternion): Quaternion {\r\n        result.set(-q._x, -q._y, -q._z, q._w);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an identity quaternion\r\n     * @returns the identity quaternion\r\n     */\r\n    public static Identity(): Quaternion {\r\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given quaternion is identity\r\n     * @param quaternion defines the quaternion to check\r\n     * @returns true if the quaternion is identity\r\n     */\r\n    public static IsIdentity(quaternion: DeepImmutable<Quaternion>): boolean {\r\n        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a quaternion from a rotation around an axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\r\n     */\r\n    public static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Quaternion {\r\n        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation around an axis and stores it into the given quaternion\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @param result defines the target quaternion\r\n     * @returns the target quaternion\r\n     */\r\n    public static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Quaternion): Quaternion {\r\n        const sin = Math.sin(angle / 2);\r\n        axis.normalize();\r\n        result.w = Math.cos(angle / 2);\r\n        result.x = axis._x * sin;\r\n        result.y = axis._y * sin;\r\n        result.z = axis._z * sin;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from data stored into an array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the source array where the data starts\r\n     * @returns a new quaternion\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Quaternion {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n\r\n    /**\r\n     * Updates the given quaternion \"result\" from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the quaternion to store the result in\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Quaternion): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n        result.w = array[offset + 3];\r\n    }\r\n\r\n    /**\r\n     * Create a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @returns the new Quaternion\r\n     */\r\n    public static FromEulerAngles(x: number, y: number, z: number): Quaternion {\r\n        const q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Updates a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    public static FromEulerAnglesToRef(x: number, y: number, z: number, result: Quaternion): Quaternion {\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @returns the new Quaternion\r\n     */\r\n    public static FromEulerVector(vec: DeepImmutable<Vector3>): Quaternion {\r\n        const q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Updates a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    public static FromEulerVectorToRef(vec: DeepImmutable<Vector3>, result: Quaternion): Quaternion {\r\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Updates a quaternion so that it rotates vector vecFrom to vector vecTo\r\n     * @param vecFrom defines the direction vector from which to rotate\r\n     * @param vecTo defines the direction vector to which to rotate\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    public static FromUnitVectorsToRef(vecFrom: DeepImmutable<Vector3>, vecTo: DeepImmutable<Vector3>, result: Quaternion): Quaternion {\r\n        const r = Vector3.Dot(vecFrom, vecTo) + 1;\r\n\r\n        if (r < Epsilon) {\r\n            if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {\r\n                result.set(-vecFrom.y, vecFrom.x, 0, 0);\r\n            } else {\r\n                result.set(0, -vecFrom.z, vecFrom.y, 0);\r\n            }\r\n        } else {\r\n            Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);\r\n            result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);\r\n        }\r\n\r\n        return result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion {\r\n        const q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void {\r\n        // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\r\n        const halfRoll = roll * 0.5;\r\n        const halfPitch = pitch * 0.5;\r\n        const halfYaw = yaw * 0.5;\r\n\r\n        const sinRoll = Math.sin(halfRoll);\r\n        const cosRoll = Math.cos(halfRoll);\r\n        const sinPitch = Math.sin(halfPitch);\r\n        const cosPitch = Math.cos(halfPitch);\r\n        const sinYaw = Math.sin(halfYaw);\r\n        const cosYaw = Math.cos(halfYaw);\r\n\r\n        result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\r\n        result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\r\n        result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;\r\n        result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion {\r\n        const result = new Quaternion();\r\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void {\r\n        // Produces a quaternion from Euler angles in the z-x-z orientation\r\n        const halfGammaPlusAlpha = (gamma + alpha) * 0.5;\r\n        const halfGammaMinusAlpha = (gamma - alpha) * 0.5;\r\n        const halfBeta = beta * 0.5;\r\n\r\n        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationQuaternionFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Quaternion {\r\n        const quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        return quat;\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the target quaternion\r\n     */\r\n    public static RotationQuaternionFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Quaternion): void {\r\n        const rotMat = MathTmp.Matrix[0];\r\n        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\r\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @returns A new quaternion oriented toward the specified forward and up.\r\n     */\r\n    public static FromLookDirectionLH(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Quaternion {\r\n        const quat = new Quaternion();\r\n        Quaternion.FromLookDirectionLHToRef(forward, up, quat);\r\n        return quat;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\r\n     * This function works in left handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @param ref defines the target quaternion.\r\n     */\r\n    public static FromLookDirectionLHToRef(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, ref: Quaternion): void {\r\n        const rotMat = MathTmp.Matrix[0];\r\n        Matrix.LookDirectionLHToRef(forward, up, rotMat);\r\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @returns A new quaternion oriented toward the specified forward and up.\r\n     */\r\n    public static FromLookDirectionRH(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Quaternion {\r\n        const quat = new Quaternion();\r\n        Quaternion.FromLookDirectionRHToRef(forward, up, quat);\r\n        return quat;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\r\n     * This function works in right handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @param ref defines the target quaternion.\r\n     */\r\n    public static FromLookDirectionRHToRef(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, ref: Quaternion): void {\r\n        const rotMat = MathTmp.Matrix[0];\r\n        Matrix.LookDirectionRHToRef(forward, up, rotMat);\r\n        return Quaternion.FromRotationMatrixToRef(rotMat, ref);\r\n    }\r\n\r\n    /**\r\n     * Interpolates between two quaternions\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    public static Slerp(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        Quaternion.SlerpToRef(left, right, amount, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Interpolates between two quaternions and stores it into a target quaternion\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static SlerpToRef(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number, result: Quaternion): void {\r\n        let num2;\r\n        let num3;\r\n        let num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\r\n        let flag = false;\r\n\r\n        if (num4 < 0) {\r\n            flag = true;\r\n            num4 = -num4;\r\n        }\r\n\r\n        if (num4 > 0.999999) {\r\n            num3 = 1 - amount;\r\n            num2 = flag ? -amount : amount;\r\n        } else {\r\n            const num5 = Math.acos(num4);\r\n            const num6 = 1.0 / Math.sin(num5);\r\n            num3 = Math.sin((1.0 - amount) * num5) * num6;\r\n            num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;\r\n        }\r\n\r\n        result.x = num3 * left._x + num2 * right._x;\r\n        result.y = num3 * left._y + num2 * right._y;\r\n        result.z = num3 * left._z + num2 * right._z;\r\n        result.w = num3 * left._w + num2 * right._w;\r\n    }\r\n\r\n    /**\r\n     * Interpolate between two quaternions using Hermite interpolation\r\n     * @param value1 defines first quaternion\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second quaternion\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target quaternion\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    public static Hermite(\r\n        value1: DeepImmutable<Quaternion>,\r\n        tangent1: DeepImmutable<Quaternion>,\r\n        value2: DeepImmutable<Quaternion>,\r\n        tangent2: DeepImmutable<Quaternion>,\r\n        amount: number\r\n    ): Quaternion {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\r\n        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\r\n        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\r\n        const w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;\r\n        return new Quaternion(x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Quaternion which is the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Quaternion>,\r\n        tangent1: DeepImmutable<Quaternion>,\r\n        value2: DeepImmutable<Quaternion>,\r\n        tangent2: DeepImmutable<Quaternion>,\r\n        time: number\r\n    ): Quaternion {\r\n        const result = Quaternion.Zero();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a Quaternion with the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Quaternion>,\r\n        tangent1: DeepImmutable<Quaternion>,\r\n        value2: DeepImmutable<Quaternion>,\r\n        tangent2: DeepImmutable<Quaternion>,\r\n        time: number,\r\n        result: Quaternion\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\r\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\r\n        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\r\n        result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store matrix data (4x4)\r\n */\r\nexport class Matrix {\r\n    /**\r\n     * Gets the precision of matrix computations\r\n     */\r\n    public static get Use64Bits(): boolean {\r\n        return PerformanceConfigurator.MatrixUse64Bits;\r\n    }\r\n\r\n    private static _UpdateFlagSeed = 0;\r\n    private static _IdentityReadOnly = Matrix.Identity() as DeepImmutable<Matrix>;\r\n\r\n    private _isIdentity = false;\r\n    private _isIdentityDirty = true;\r\n    private _isIdentity3x2 = true;\r\n    private _isIdentity3x2Dirty = true;\r\n    /**\r\n     * Gets the update flag of the matrix which is an unique number for the matrix.\r\n     * It will be incremented every time the matrix data change.\r\n     * You can use it to speed the comparison between two versions of the same matrix.\r\n     */\r\n    public updateFlag: number = -1;\r\n\r\n    private readonly _m: Float32Array | Array<number>;\r\n\r\n    /**\r\n     * Gets the internal data of the matrix\r\n     */\r\n    public get m(): DeepImmutable<Float32Array | Array<number>> {\r\n        return this._m;\r\n    }\r\n\r\n    /**\r\n     * Update the updateFlag to indicate that the matrix has been updated\r\n     */\r\n    public markAsUpdated() {\r\n        this.updateFlag = Matrix._UpdateFlagSeed++;\r\n        this._isIdentity = false;\r\n        this._isIdentity3x2 = false;\r\n        this._isIdentityDirty = true;\r\n        this._isIdentity3x2Dirty = true;\r\n    }\r\n\r\n    private _updateIdentityStatus(isIdentity: boolean, isIdentityDirty: boolean = false, isIdentity3x2: boolean = false, isIdentity3x2Dirty: boolean = true) {\r\n        this._isIdentity = isIdentity;\r\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\r\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\r\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty matrix (filled with zeros)\r\n     */\r\n    public constructor() {\r\n        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\r\n            PerformanceConfigurator.MatrixTrackedMatrices!.push(this);\r\n        }\r\n\r\n        this._m = new PerformanceConfigurator.MatrixCurrentType(16);\r\n\r\n        this.markAsUpdated();\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Check if the current matrix is identity\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    public isIdentity(): boolean {\r\n        if (this._isIdentityDirty) {\r\n            this._isIdentityDirty = false;\r\n            const m = this._m;\r\n            this._isIdentity =\r\n                m[0] === 1.0 &&\r\n                m[1] === 0.0 &&\r\n                m[2] === 0.0 &&\r\n                m[3] === 0.0 &&\r\n                m[4] === 0.0 &&\r\n                m[5] === 1.0 &&\r\n                m[6] === 0.0 &&\r\n                m[7] === 0.0 &&\r\n                m[8] === 0.0 &&\r\n                m[9] === 0.0 &&\r\n                m[10] === 1.0 &&\r\n                m[11] === 0.0 &&\r\n                m[12] === 0.0 &&\r\n                m[13] === 0.0 &&\r\n                m[14] === 0.0 &&\r\n                m[15] === 1.0;\r\n        }\r\n\r\n        return this._isIdentity;\r\n    }\r\n\r\n    /**\r\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    public isIdentityAs3x2(): boolean {\r\n        if (this._isIdentity3x2Dirty) {\r\n            this._isIdentity3x2Dirty = false;\r\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\r\n                this._isIdentity3x2 = false;\r\n            } else if (\r\n                this._m[1] !== 0.0 ||\r\n                this._m[2] !== 0.0 ||\r\n                this._m[3] !== 0.0 ||\r\n                this._m[4] !== 0.0 ||\r\n                this._m[6] !== 0.0 ||\r\n                this._m[7] !== 0.0 ||\r\n                this._m[8] !== 0.0 ||\r\n                this._m[9] !== 0.0 ||\r\n                this._m[10] !== 0.0 ||\r\n                this._m[11] !== 0.0 ||\r\n                this._m[12] !== 0.0 ||\r\n                this._m[13] !== 0.0 ||\r\n                this._m[14] !== 0.0\r\n            ) {\r\n                this._isIdentity3x2 = false;\r\n            } else {\r\n                this._isIdentity3x2 = true;\r\n            }\r\n        }\r\n\r\n        return this._isIdentity3x2;\r\n    }\r\n\r\n    /**\r\n     * Gets the determinant of the matrix\r\n     * @returns the matrix determinant\r\n     */\r\n    public determinant(): number {\r\n        if (this._isIdentity === true) {\r\n            return 1;\r\n        }\r\n\r\n        const m = this._m;\r\n        const m00 = m[0],\r\n            m01 = m[1],\r\n            m02 = m[2],\r\n            m03 = m[3];\r\n        const m10 = m[4],\r\n            m11 = m[5],\r\n            m12 = m[6],\r\n            m13 = m[7];\r\n        const m20 = m[8],\r\n            m21 = m[9],\r\n            m22 = m[10],\r\n            m23 = m[11];\r\n        const m30 = m[12],\r\n            m31 = m[13],\r\n            m32 = m[14],\r\n            m33 = m[15];\r\n        // https://en.wikipedia.org/wiki/Laplace_expansion\r\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\r\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\r\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\r\n        // where\r\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\r\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\r\n        //\r\n        // Here we do that for the 1st row.\r\n\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Returns the matrix as a Float32Array or Array<number>\r\n     * @returns the matrix underlying array\r\n     */\r\n    public toArray(): DeepImmutable<Float32Array | Array<number>> {\r\n        return this._m;\r\n    }\r\n    /**\r\n     * Returns the matrix as a Float32Array or Array<number>\r\n     * @returns the matrix underlying array.\r\n     */\r\n    public asArray(): DeepImmutable<Float32Array | Array<number>> {\r\n        return this._m;\r\n    }\r\n\r\n    /**\r\n     * Inverts the current matrix in place\r\n     * @returns the current inverted matrix\r\n     */\r\n    public invert(): Matrix {\r\n        this.invertToRef(this);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets all the matrix elements to zero\r\n     * @returns the current matrix\r\n     */\r\n    public reset(): Matrix {\r\n        Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\r\n        this._updateIdentityStatus(false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the current matrix with a second one\r\n     * @param other defines the matrix to add\r\n     * @returns a new matrix as the addition of the current matrix and the given one\r\n     */\r\n    public add(other: DeepImmutable<Matrix>): Matrix {\r\n        const result = new Matrix();\r\n        this.addToRef(other, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\r\n     * @param other defines the matrix to add\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public addToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix {\r\n        const m = this._m;\r\n        const resultM = result._m;\r\n        const otherM = other.m;\r\n        for (let index = 0; index < 16; index++) {\r\n            resultM[index] = m[index] + otherM[index];\r\n        }\r\n        result.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds in place the given matrix to the current matrix\r\n     * @param other defines the second operand\r\n     * @returns the current updated matrix\r\n     */\r\n    public addToSelf(other: DeepImmutable<Matrix>): Matrix {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        for (let index = 0; index < 16; index++) {\r\n            m[index] += otherM[index];\r\n        }\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix to the current inverted Matrix\r\n     * @param other defines the target matrix\r\n     * @returns the unmodified current matrix\r\n     */\r\n    public invertToRef(other: Matrix): Matrix {\r\n        if (this._isIdentity === true) {\r\n            Matrix.IdentityToRef(other);\r\n            return this;\r\n        }\r\n\r\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\r\n        const m = this._m;\r\n        const m00 = m[0],\r\n            m01 = m[1],\r\n            m02 = m[2],\r\n            m03 = m[3];\r\n        const m10 = m[4],\r\n            m11 = m[5],\r\n            m12 = m[6],\r\n            m13 = m[7];\r\n        const m20 = m[8],\r\n            m21 = m[9],\r\n            m22 = m[10],\r\n            m23 = m[11];\r\n        const m30 = m[12],\r\n            m31 = m[13],\r\n            m32 = m[14],\r\n            m33 = m[15];\r\n\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n\r\n        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n\r\n        if (det === 0) {\r\n            // not invertible\r\n            other.copyFrom(this);\r\n            return this;\r\n        }\r\n\r\n        const detInv = 1 / det;\r\n        const det_12_33 = m12 * m33 - m32 * m13;\r\n        const det_11_33 = m11 * m33 - m31 * m13;\r\n        const det_11_32 = m11 * m32 - m31 * m12;\r\n        const det_10_33 = m10 * m33 - m30 * m13;\r\n        const det_10_32 = m10 * m32 - m30 * m12;\r\n        const det_10_31 = m10 * m31 - m30 * m11;\r\n        const det_12_23 = m12 * m23 - m22 * m13;\r\n        const det_11_23 = m11 * m23 - m21 * m13;\r\n        const det_11_22 = m11 * m22 - m21 * m12;\r\n        const det_10_23 = m10 * m23 - m20 * m13;\r\n        const det_10_22 = m10 * m22 - m20 * m12;\r\n        const det_10_21 = m10 * m21 - m20 * m11;\r\n\r\n        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\r\n        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\r\n        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\r\n        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\r\n\r\n        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\r\n        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\r\n        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\r\n        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\r\n\r\n        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\r\n        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\r\n        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\r\n        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\r\n\r\n        Matrix.FromValuesToRef(\r\n            cofact_00 * detInv,\r\n            cofact_10 * detInv,\r\n            cofact_20 * detInv,\r\n            cofact_30 * detInv,\r\n            cofact_01 * detInv,\r\n            cofact_11 * detInv,\r\n            cofact_21 * detInv,\r\n            cofact_31 * detInv,\r\n            cofact_02 * detInv,\r\n            cofact_12 * detInv,\r\n            cofact_22 * detInv,\r\n            cofact_32 * detInv,\r\n            cofact_03 * detInv,\r\n            cofact_13 * detInv,\r\n            cofact_23 * detInv,\r\n            cofact_33 * detInv,\r\n            other\r\n        );\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * add a value at the specified position in the current Matrix\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    public addAtIndex(index: number, value: number): Matrix {\r\n        this._m[index] += value;\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * mutiply the specified position in the current Matrix by a value\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    public multiplyAtIndex(index: number, value: number): Matrix {\r\n        this._m[index] *= value;\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Inserts the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    public setTranslationFromFloats(x: number, y: number, z: number): Matrix {\r\n        this._m[12] = x;\r\n        this._m[13] = y;\r\n        this._m[14] = z;\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    public addTranslationFromFloats(x: number, y: number, z: number): Matrix {\r\n        this._m[12] += x;\r\n        this._m[13] += y;\r\n        this._m[14] += z;\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Inserts the translation vector in the current matrix\r\n     * @param vector3 defines the translation to insert\r\n     * @returns the current updated matrix\r\n     */\r\n    public setTranslation(vector3: DeepImmutable<Vector3>): Matrix {\r\n        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\r\n    }\r\n\r\n    /**\r\n     * Gets the translation value of the current matrix\r\n     * @returns a new Vector3 as the extracted translation from the matrix\r\n     */\r\n    public getTranslation(): Vector3 {\r\n        return new Vector3(this._m[12], this._m[13], this._m[14]);\r\n    }\r\n\r\n    /**\r\n     * Fill a Vector3 with the extracted translation from the matrix\r\n     * @param result defines the Vector3 where to store the translation\r\n     * @returns the current matrix\r\n     */\r\n    public getTranslationToRef(result: Vector3): Matrix {\r\n        result.x = this._m[12];\r\n        result.y = this._m[13];\r\n        result.z = this._m[14];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove rotation and scaling part from the matrix\r\n     * @returns the updated matrix\r\n     */\r\n    public removeRotationAndScaling(): Matrix {\r\n        const m = this.m;\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\r\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply two matrices\r\n     * @param other defines the second operand\r\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\r\n     */\r\n    public multiply(other: DeepImmutable<Matrix>): Matrix {\r\n        const result = new Matrix();\r\n        this.multiplyToRef(other, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the current matrix from the given one\r\n     * @param other defines the source matrix\r\n     * @returns the current updated matrix\r\n     */\r\n    public copyFrom(other: DeepImmutable<Matrix>): Matrix {\r\n        other.copyToArray(this._m);\r\n        const o = other as Matrix;\r\n        this.updateFlag = o.updateFlag;\r\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array from the starting index with the current matrix values\r\n     * @param array defines the target array\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    public copyToArray(array: Float32Array | Array<number>, offset: number = 0): Matrix {\r\n        const source = this._m;\r\n        array[offset] = source[0];\r\n        array[offset + 1] = source[1];\r\n        array[offset + 2] = source[2];\r\n        array[offset + 3] = source[3];\r\n        array[offset + 4] = source[4];\r\n        array[offset + 5] = source[5];\r\n        array[offset + 6] = source[6];\r\n        array[offset + 7] = source[7];\r\n        array[offset + 8] = source[8];\r\n        array[offset + 9] = source[9];\r\n        array[offset + 10] = source[10];\r\n        array[offset + 11] = source[11];\r\n        array[offset + 12] = source[12];\r\n        array[offset + 13] = source[13];\r\n        array[offset + 14] = source[14];\r\n        array[offset + 15] = source[15];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the matrix where to store the multiplication\r\n     * @returns the current matrix\r\n     */\r\n    public multiplyToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix {\r\n        if (this._isIdentity) {\r\n            result.copyFrom(other);\r\n            return this;\r\n        }\r\n        if ((other as Matrix)._isIdentity) {\r\n            result.copyFrom(this);\r\n            return this;\r\n        }\r\n\r\n        this.multiplyToArray(other, result._m, 0);\r\n        result.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the array where to store the multiplication\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    public multiplyToArray(other: DeepImmutable<Matrix>, result: Float32Array | Array<number>, offset: number): Matrix {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        const tm0 = m[0],\r\n            tm1 = m[1],\r\n            tm2 = m[2],\r\n            tm3 = m[3];\r\n        const tm4 = m[4],\r\n            tm5 = m[5],\r\n            tm6 = m[6],\r\n            tm7 = m[7];\r\n        const tm8 = m[8],\r\n            tm9 = m[9],\r\n            tm10 = m[10],\r\n            tm11 = m[11];\r\n        const tm12 = m[12],\r\n            tm13 = m[13],\r\n            tm14 = m[14],\r\n            tm15 = m[15];\r\n\r\n        const om0 = otherM[0],\r\n            om1 = otherM[1],\r\n            om2 = otherM[2],\r\n            om3 = otherM[3];\r\n        const om4 = otherM[4],\r\n            om5 = otherM[5],\r\n            om6 = otherM[6],\r\n            om7 = otherM[7];\r\n        const om8 = otherM[8],\r\n            om9 = otherM[9],\r\n            om10 = otherM[10],\r\n            om11 = otherM[11];\r\n        const om12 = otherM[12],\r\n            om13 = otherM[13],\r\n            om14 = otherM[14],\r\n            om15 = otherM[15];\r\n\r\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\r\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\r\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\r\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\r\n\r\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\r\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\r\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\r\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\r\n\r\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\r\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\r\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\r\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\r\n\r\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\r\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\r\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\r\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Check equality between this matrix and a second one\r\n     * @param value defines the second matrix to compare\r\n     * @returns true is the current matrix and the given one values are strictly equal\r\n     */\r\n    public equals(value: DeepImmutable<Matrix>): boolean {\r\n        const other = value as Matrix;\r\n        if (!other) {\r\n            return false;\r\n        }\r\n\r\n        if (this._isIdentity || other._isIdentity) {\r\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\r\n                return this._isIdentity && other._isIdentity;\r\n            }\r\n        }\r\n\r\n        const m = this.m;\r\n        const om = other.m;\r\n        return (\r\n            m[0] === om[0] &&\r\n            m[1] === om[1] &&\r\n            m[2] === om[2] &&\r\n            m[3] === om[3] &&\r\n            m[4] === om[4] &&\r\n            m[5] === om[5] &&\r\n            m[6] === om[6] &&\r\n            m[7] === om[7] &&\r\n            m[8] === om[8] &&\r\n            m[9] === om[9] &&\r\n            m[10] === om[10] &&\r\n            m[11] === om[11] &&\r\n            m[12] === om[12] &&\r\n            m[13] === om[13] &&\r\n            m[14] === om[14] &&\r\n            m[15] === om[15]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Clone the current matrix\r\n     * @returns a new matrix from the current matrix\r\n     */\r\n    public clone(): Matrix {\r\n        const matrix = new Matrix();\r\n        matrix.copyFrom(this);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the current matrix class\r\n     * @returns the string \"Matrix\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Matrix\";\r\n    }\r\n\r\n    /**\r\n     * Gets the hash code of the current matrix\r\n     * @returns the hash code\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = _ExtractAsInt(this._m[0]);\r\n        for (let i = 1; i < 16; i++) {\r\n            hash = (hash * 397) ^ _ExtractAsInt(this._m[i]);\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Decomposes the current Matrix into a translation, rotation and scaling components of the provided node\r\n     * @param node the node to decompose the matrix to\r\n     * @returns true if operation was successful\r\n     */\r\n    public decomposeToTransformNode(node: TransformNode): boolean {\r\n        node.rotationQuaternion = node.rotationQuaternion || new Quaternion();\r\n        return this.decompose(node.scaling, node.rotationQuaternion, node.position);\r\n    }\r\n\r\n    /**\r\n     * Decomposes the current Matrix into a translation, rotation and scaling components\r\n     * @param scale defines the scale vector3 given as a reference to update\r\n     * @param rotation defines the rotation quaternion given as a reference to update\r\n     * @param translation defines the translation vector3 given as a reference to update\r\n     * @param preserveScalingNode Use scaling sign coming from this node. Otherwise scaling sign might change.\r\n     * @returns true if operation was successful\r\n     */\r\n    public decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3, preserveScalingNode?: TransformNode): boolean {\r\n        if (this._isIdentity) {\r\n            if (translation) {\r\n                translation.setAll(0);\r\n            }\r\n            if (scale) {\r\n                scale.setAll(1);\r\n            }\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0, 0, 0, 1);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        const m = this._m;\r\n        if (translation) {\r\n            translation.copyFromFloats(m[12], m[13], m[14]);\r\n        }\r\n\r\n        scale = scale || MathTmp.Vector3[0];\r\n\r\n        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\r\n        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\r\n        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\r\n\r\n        if (preserveScalingNode) {\r\n            const signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;\r\n            const signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;\r\n            const signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;\r\n\r\n            scale.x *= signX;\r\n            scale.y *= signY;\r\n            scale.z *= signZ;\r\n        } else {\r\n            if (this.determinant() <= 0) {\r\n                scale.y *= -1;\r\n            }\r\n        }\r\n\r\n        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (rotation) {\r\n            const sx = 1 / scale._x,\r\n                sy = 1 / scale._y,\r\n                sz = 1 / scale._z;\r\n            Matrix.FromValuesToRef(\r\n                m[0] * sx,\r\n                m[1] * sx,\r\n                m[2] * sx,\r\n                0.0,\r\n                m[4] * sy,\r\n                m[5] * sy,\r\n                m[6] * sy,\r\n                0.0,\r\n                m[8] * sz,\r\n                m[9] * sz,\r\n                m[10] * sz,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                MathTmp.Matrix[0]\r\n            );\r\n\r\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets specific row of the matrix\r\n     * @param index defines the number of the row to get\r\n     * @returns the index-th row of the current matrix as a new Vector4\r\n     */\r\n    public getRow(index: number): Nullable<Vector4> {\r\n        if (index < 0 || index > 3) {\r\n            return null;\r\n        }\r\n        const i = index * 4;\r\n        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\r\n    }\r\n\r\n    /**\r\n     * Sets the index-th row of the current matrix to the vector4 values\r\n     * @param index defines the number of the row to set\r\n     * @param row defines the target vector4\r\n     * @returns the updated current matrix\r\n     */\r\n    public setRow(index: number, row: Vector4): Matrix {\r\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of the matrix\r\n     * @returns the new transposed matrix\r\n     */\r\n    public transpose(): Matrix {\r\n        return Matrix.Transpose(this);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of the matrix and store it in a given matrix\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public transposeToRef(result: Matrix): Matrix {\r\n        Matrix.TransposeToRef(this, result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the index-th row of the current matrix with the given 4 x float values\r\n     * @param index defines the row index\r\n     * @param x defines the x component to set\r\n     * @param y defines the y component to set\r\n     * @param z defines the z component to set\r\n     * @param w defines the w component to set\r\n     * @returns the updated current matrix\r\n     */\r\n    public setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix {\r\n        if (index < 0 || index > 3) {\r\n            return this;\r\n        }\r\n        const i = index * 4;\r\n        this._m[i + 0] = x;\r\n        this._m[i + 1] = y;\r\n        this._m[i + 2] = z;\r\n        this._m[i + 3] = w;\r\n\r\n        this.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\r\n     * @param scale defines the scale factor\r\n     * @returns a new matrix\r\n     */\r\n    public scale(scale: number): Matrix {\r\n        const result = new Matrix();\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current matrix values by a factor to a given result matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    public scaleToRef(scale: number, result: Matrix): Matrix {\r\n        for (let index = 0; index < 16; index++) {\r\n            result._m[index] = this._m[index] * scale;\r\n        }\r\n        result.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current matrix values by a factor and add the result to a given matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Matrix): Matrix {\r\n        for (let index = 0; index < 16; index++) {\r\n            result._m[index] += this._m[index] * scale;\r\n        }\r\n        result.markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\r\n     * @param ref matrix to store the result\r\n     */\r\n    public toNormalMatrix(ref: Matrix): void {\r\n        const tmp = MathTmp.Matrix[0];\r\n        this.invertToRef(tmp);\r\n        tmp.transposeToRef(ref);\r\n        const m = ref._m;\r\n        Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\r\n    }\r\n\r\n    /**\r\n     * Gets only rotation part of the current matrix\r\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\r\n     */\r\n    public getRotationMatrix(): Matrix {\r\n        const result = new Matrix();\r\n        this.getRotationMatrixToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\r\n     * @param result defines the target matrix to store data to\r\n     * @returns the current matrix\r\n     */\r\n    public getRotationMatrixToRef(result: Matrix): Matrix {\r\n        const scale = MathTmp.Vector3[0];\r\n        if (!this.decompose(scale)) {\r\n            Matrix.IdentityToRef(result);\r\n            return this;\r\n        }\r\n\r\n        const m = this._m;\r\n        const sx = 1 / scale._x,\r\n            sy = 1 / scale._y,\r\n            sz = 1 / scale._z;\r\n        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Toggles model matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    public toggleModelMatrixHandInPlace() {\r\n        const m = this._m;\r\n        m[2] *= -1;\r\n        m[6] *= -1;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[14] *= -1;\r\n        this.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    public toggleProjectionMatrixHandInPlace() {\r\n        const m = this._m;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[10] *= -1;\r\n        m[11] *= -1;\r\n        this.markAsUpdated();\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a matrix from an array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Matrix set from the starting index of the given array\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.FromArrayToRef(array, offset, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the content of an array into a given matrix\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Matrix) {\r\n        for (let index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset];\r\n        }\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Stores an array into a matrix after having multiplied each component by a given factor\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromFloat32ArrayToRefScaled(array: DeepImmutable<Float32Array | Array<number>>, offset: number, scale: number, result: Matrix) {\r\n        for (let index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset] * scale;\r\n        }\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Gets an identity matrix that must not be updated\r\n     */\r\n    public static get IdentityReadOnly(): DeepImmutable<Matrix> {\r\n        return Matrix._IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Stores a list of values (16) inside a given matrix\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromValuesToRef(\r\n        initialM11: number,\r\n        initialM12: number,\r\n        initialM13: number,\r\n        initialM14: number,\r\n        initialM21: number,\r\n        initialM22: number,\r\n        initialM23: number,\r\n        initialM24: number,\r\n        initialM31: number,\r\n        initialM32: number,\r\n        initialM33: number,\r\n        initialM34: number,\r\n        initialM41: number,\r\n        initialM42: number,\r\n        initialM43: number,\r\n        initialM44: number,\r\n        result: Matrix\r\n    ): void {\r\n        const m = result._m;\r\n        m[0] = initialM11;\r\n        m[1] = initialM12;\r\n        m[2] = initialM13;\r\n        m[3] = initialM14;\r\n        m[4] = initialM21;\r\n        m[5] = initialM22;\r\n        m[6] = initialM23;\r\n        m[7] = initialM24;\r\n        m[8] = initialM31;\r\n        m[9] = initialM32;\r\n        m[10] = initialM33;\r\n        m[11] = initialM34;\r\n        m[12] = initialM41;\r\n        m[13] = initialM42;\r\n        m[14] = initialM43;\r\n        m[15] = initialM44;\r\n\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates new matrix from a list of values (16)\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @returns the new matrix\r\n     */\r\n    public static FromValues(\r\n        initialM11: number,\r\n        initialM12: number,\r\n        initialM13: number,\r\n        initialM14: number,\r\n        initialM21: number,\r\n        initialM22: number,\r\n        initialM23: number,\r\n        initialM24: number,\r\n        initialM31: number,\r\n        initialM32: number,\r\n        initialM33: number,\r\n        initialM34: number,\r\n        initialM41: number,\r\n        initialM42: number,\r\n        initialM43: number,\r\n        initialM44: number\r\n    ): Matrix {\r\n        const result = new Matrix();\r\n        const m = result._m;\r\n        m[0] = initialM11;\r\n        m[1] = initialM12;\r\n        m[2] = initialM13;\r\n        m[3] = initialM14;\r\n        m[4] = initialM21;\r\n        m[5] = initialM22;\r\n        m[6] = initialM23;\r\n        m[7] = initialM24;\r\n        m[8] = initialM31;\r\n        m[9] = initialM32;\r\n        m[10] = initialM33;\r\n        m[11] = initialM34;\r\n        m[12] = initialM41;\r\n        m[13] = initialM42;\r\n        m[14] = initialM43;\r\n        m[15] = initialM44;\r\n        result.markAsUpdated();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @returns a new matrix\r\n     */\r\n    public static Compose(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.ComposeToRef(scale, rotation, translation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ComposeToRef(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const m = result._m;\r\n        const x = rotation._x,\r\n            y = rotation._y,\r\n            z = rotation._z,\r\n            w = rotation._w;\r\n        const x2 = x + x,\r\n            y2 = y + y,\r\n            z2 = z + z;\r\n        const xx = x * x2,\r\n            xy = x * y2,\r\n            xz = x * z2;\r\n        const yy = y * y2,\r\n            yz = y * z2,\r\n            zz = z * z2;\r\n        const wx = w * x2,\r\n            wy = w * y2,\r\n            wz = w * z2;\r\n\r\n        const sx = scale._x,\r\n            sy = scale._y,\r\n            sz = scale._z;\r\n\r\n        m[0] = (1 - (yy + zz)) * sx;\r\n        m[1] = (xy + wz) * sx;\r\n        m[2] = (xz - wy) * sx;\r\n        m[3] = 0;\r\n\r\n        m[4] = (xy - wz) * sy;\r\n        m[5] = (1 - (xx + zz)) * sy;\r\n        m[6] = (yz + wx) * sy;\r\n        m[7] = 0;\r\n\r\n        m[8] = (xz + wy) * sz;\r\n        m[9] = (yz - wx) * sz;\r\n        m[10] = (1 - (xx + yy)) * sz;\r\n        m[11] = 0;\r\n\r\n        m[12] = translation._x;\r\n        m[13] = translation._y;\r\n        m[14] = translation._z;\r\n        m[15] = 1;\r\n\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a new identity matrix\r\n     * @returns a new identity matrix\r\n     */\r\n    public static Identity(): Matrix {\r\n        const identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n        identity._updateIdentityStatus(true);\r\n        return identity;\r\n    }\r\n\r\n    /**\r\n     * Creates a new identity matrix and stores the result in a given matrix\r\n     * @param result defines the target matrix\r\n     */\r\n    public static IdentityToRef(result: Matrix): void {\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(true);\r\n    }\r\n\r\n    /**\r\n     * Creates a new zero matrix\r\n     * @returns a new zero matrix\r\n     */\r\n    public static Zero(): Matrix {\r\n        const zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r\n        zero._updateIdentityStatus(false);\r\n        return zero;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationX(angle: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.RotationXToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new matrix as the invert of a given matrix\r\n     * @param source defines the source matrix\r\n     * @returns the new matrix\r\n     */\r\n    public static Invert(source: DeepImmutable<Matrix>): Matrix {\r\n        const result = new Matrix();\r\n        source.invertToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationXToRef(angle: number, result: Matrix): void {\r\n        const s = Math.sin(angle);\r\n        const c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationY(angle: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.RotationYToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationYToRef(angle: number, result: Matrix): void {\r\n        const s = Math.sin(angle);\r\n        const c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationZ(angle: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.RotationZToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationZToRef(angle: number, result: Matrix): void {\r\n        const s = Math.sin(angle);\r\n        const c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.RotationAxisToRef(axis, angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Matrix): void {\r\n        const s = Math.sin(-angle);\r\n        const c = Math.cos(-angle);\r\n        const c1 = 1 - c;\r\n\r\n        axis.normalize();\r\n        const m = result._m;\r\n        m[0] = axis._x * axis._x * c1 + c;\r\n        m[1] = axis._x * axis._y * c1 - axis._z * s;\r\n        m[2] = axis._x * axis._z * c1 + axis._y * s;\r\n        m[3] = 0.0;\r\n\r\n        m[4] = axis._y * axis._x * c1 + axis._z * s;\r\n        m[5] = axis._y * axis._y * c1 + c;\r\n        m[6] = axis._y * axis._z * c1 - axis._x * s;\r\n        m[7] = 0.0;\r\n\r\n        m[8] = axis._z * axis._x * c1 - axis._y * s;\r\n        m[9] = axis._z * axis._y * c1 + axis._x * s;\r\n        m[10] = axis._z * axis._z * c1 + c;\r\n        m[11] = 0.0;\r\n\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = 0.0;\r\n        m[15] = 1.0;\r\n\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\r\n     * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\r\n     * @param from defines the vector to align\r\n     * @param to defines the vector to align to\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationAlignToRef(from: DeepImmutable<Vector3>, to: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const c = Vector3.Dot(to, from);\r\n        const m = result._m;\r\n        if (c < -1 + Epsilon) {\r\n            // from and to are colinear and opposite direction.\r\n            // compute a PI rotation on Z axis\r\n            m[0] = -1;\r\n            m[1] = 0;\r\n            m[2] = 0;\r\n            m[3] = 0;\r\n            m[4] = 0;\r\n            m[5] = -1;\r\n            m[6] = 0;\r\n            m[7] = 0;\r\n            m[8] = 0;\r\n            m[9] = 0;\r\n            m[10] = 1;\r\n            m[11] = 0;\r\n        } else {\r\n            const v = Vector3.Cross(to, from);\r\n            const k = 1 / (1 + c);\r\n\r\n            m[0] = v._x * v._x * k + c;\r\n            m[1] = v._y * v._x * k - v._z;\r\n            m[2] = v._z * v._x * k + v._y;\r\n            m[3] = 0;\r\n            m[4] = v._x * v._y * k + v._z;\r\n            m[5] = v._y * v._y * k + c;\r\n            m[6] = v._z * v._y * k - v._x;\r\n            m[7] = 0;\r\n            m[8] = v._x * v._z * k - v._y;\r\n            m[9] = v._y * v._z * k + v._x;\r\n            m[10] = v._z * v._z * k + c;\r\n            m[11] = 0;\r\n        }\r\n        m[12] = 0;\r\n        m[13] = 0;\r\n        m[14] = 0;\r\n        m[15] = 1;\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (Z axis)\r\n     * @returns the new rotation matrix\r\n     */\r\n    public static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix and stores it in a given matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (Z axis)\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void {\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\r\n        MathTmp.Quaternion[0].toRotationMatrix(result);\r\n    }\r\n\r\n    /**\r\n     * Creates a scaling matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @returns the new matrix\r\n     */\r\n    public static Scaling(x: number, y: number, z: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.ScalingToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a scaling matrix and stores it in a given matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ScalingToRef(x: number, y: number, z: number, result: Matrix): void {\r\n        Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n\r\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\r\n    }\r\n\r\n    /**\r\n     * Creates a translation matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @returns the new matrix\r\n     */\r\n    public static Translation(x: number, y: number, z: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.TranslationToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a translation matrix and stores it in a given matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static TranslationToRef(x: number, y: number, z: number, result: Matrix): void {\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\r\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @returns the new matrix\r\n     */\r\n    public static Lerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @param result defines the Matrix object where to store data\r\n     */\r\n    public static LerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix): void {\r\n        const resultM = result._m;\r\n        const startM = startValue.m;\r\n        const endM = endValue.m;\r\n        for (let index = 0; index < 16; index++) {\r\n            resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\r\n        }\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Builds a new matrix whose values are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @returns the new matrix\r\n     */\r\n    public static DecomposeLerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a matrix to values which are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @param result defines the target matrix\r\n     */\r\n    public static DecomposeLerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix) {\r\n        const startScale = MathTmp.Vector3[0];\r\n        const startRotation = MathTmp.Quaternion[0];\r\n        const startTranslation = MathTmp.Vector3[1];\r\n        startValue.decompose(startScale, startRotation, startTranslation);\r\n\r\n        const endScale = MathTmp.Vector3[2];\r\n        const endRotation = MathTmp.Quaternion[1];\r\n        const endTranslation = MathTmp.Vector3[3];\r\n        endValue.decompose(endScale, endRotation, endTranslation);\r\n\r\n        const resultScale = MathTmp.Vector3[4];\r\n        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\r\n        const resultRotation = MathTmp.Quaternion[2];\r\n        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\r\n\r\n        const resultTranslation = MathTmp.Vector3[5];\r\n        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\r\n\r\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    public static LookAtLH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.LookAtLHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookAtLHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n\r\n        // Z axis\r\n        target.subtractToRef(eye, zAxis);\r\n        zAxis.normalize();\r\n\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        } else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n\r\n        // Eye angles\r\n        const ex = -Vector3.Dot(xAxis, eye);\r\n        const ey = -Vector3.Dot(yAxis, eye);\r\n        const ez = -Vector3.Dot(zAxis, eye);\r\n\r\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    public static LookAtRH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.LookAtRHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookAtRHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n\r\n        // Z axis\r\n        eye.subtractToRef(target, zAxis);\r\n        zAxis.normalize();\r\n\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        } else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n\r\n        // Eye angles\r\n        const ex = -Vector3.Dot(xAxis, eye);\r\n        const ey = -Vector3.Dot(yAxis, eye);\r\n        const ez = -Vector3.Dot(zAxis, eye);\r\n\r\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up direction being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @returns the new matrix\r\n     */\r\n    public static LookDirectionLH(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.LookDirectionLHToRef(forward, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up direction being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookDirectionLHToRef(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const back = MathTmp.Vector3[0];\r\n        back.copyFrom(forward);\r\n        back.scaleInPlace(-1);\r\n        const left = MathTmp.Vector3[1];\r\n        Vector3.CrossToRef(up, back, left);\r\n\r\n        // Generate the rotation matrix.\r\n        Matrix.FromValuesToRef(left._x, left._y, left._z, 0.0, up._x, up._y, up._z, 0.0, back._x, back._y, back._z, 0.0, 0, 0, 0, 1.0, result);\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up Vector3 being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @returns the new matrix\r\n     */\r\n    public static LookDirectionRH(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.LookDirectionRHToRef(forward, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up vector3 being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\r\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookDirectionRHToRef(forward: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const right = MathTmp.Vector3[2];\r\n        Vector3.CrossToRef(up, forward, right);\r\n\r\n        // Generate the rotation matrix.\r\n        Matrix.FromValuesToRef(right._x, right._y, right._z, 0.0, up._x, up._y, up._z, 0.0, forward._x, forward._y, forward._z, 0.0, 0, 0, 0, 1.0, result);\r\n    }\r\n\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    public static OrthoLH(width: number, height: number, znear: number, zfar: number, halfZRange?: boolean): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Store a left-handed orthographic projection to a given matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     */\r\n    public static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix, halfZRange?: boolean): void {\r\n        const n = znear;\r\n        const f = zfar;\r\n\r\n        const a = 2.0 / width;\r\n        const b = 2.0 / height;\r\n        const c = 2.0 / (f - n);\r\n        const d = -(f + n) / (f - n);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\r\n    }\r\n\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    public static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, halfZRange?: boolean): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     */\r\n    public static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix, halfZRange?: boolean): void {\r\n        const n = znear;\r\n        const f = zfar;\r\n\r\n        const a = 2.0 / (right - left);\r\n        const b = 2.0 / (top - bottom);\r\n        const c = 2.0 / (f - n);\r\n        const d = -(f + n) / (f - n);\r\n        const i0 = (left + right) / (left - right);\r\n        const i1 = (top + bottom) / (bottom - top);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a right-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @returns a new matrix as a right-handed orthographic projection matrix\r\n     */\r\n    public static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, halfZRange?: boolean): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     */\r\n    public static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix, halfZRange?: boolean): void {\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);\r\n        result._m[10] *= -1; // No need to call markAsUpdated as previous function already called it and let _isIdentityDirty to true\r\n    }\r\n\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveLH(width: number, height: number, znear: number, zfar: number, halfZRange?: boolean, projectionPlaneTilt: number = 0): Matrix {\r\n        const matrix = new Matrix();\r\n\r\n        const n = znear;\r\n        const f = zfar;\r\n\r\n        const a = (2.0 * n) / width;\r\n        const b = (2.0 * n) / height;\r\n        const c = (f + n) / (f - n);\r\n        const d = (-2.0 * f * n) / (f - n);\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\r\n\r\n        if (halfZRange) {\r\n            matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);\r\n        }\r\n\r\n        matrix._updateIdentityStatus(false);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveFovLH(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0,\r\n        reverseDepthBufferMode: boolean = false\r\n    ): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\r\n     */\r\n    public static PerspectiveFovLHToRef(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        result: Matrix,\r\n        isVerticalFovFixed = true,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0,\r\n        reverseDepthBufferMode: boolean = false\r\n    ): void {\r\n        const n = znear;\r\n        const f = zfar;\r\n\r\n        const t = 1.0 / Math.tan(fov * 0.5);\r\n        const a = isVerticalFovFixed ? t / aspect : t;\r\n        const b = isVerticalFovFixed ? t : t * aspect;\r\n        const c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;\r\n        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2.0 * f * n) / (f - n) : -2 * n;\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed perspective projection into a given matrix with depth reversed\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar not used as infinity is used as far clip\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     */\r\n    public static PerspectiveFovReverseLHToRef(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        result: Matrix,\r\n        isVerticalFovFixed = true,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0\r\n    ): void {\r\n        const t = 1.0 / Math.tan(fov * 0.5);\r\n        const a = isVerticalFovFixed ? t / aspect : t;\r\n        const b = isVerticalFovFixed ? t : t * aspect;\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, 1.0, 0.0, 0.0, 1.0, 0.0, result);\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Creates a right-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\r\n     * @returns a new matrix as a right-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveFovRH(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0,\r\n        reverseDepthBufferMode: boolean = false\r\n    ): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\r\n     */\r\n    public static PerspectiveFovRHToRef(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        result: Matrix,\r\n        isVerticalFovFixed = true,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0,\r\n        reverseDepthBufferMode: boolean = false\r\n    ): void {\r\n        //alternatively this could be expressed as:\r\n        //    m = PerspectiveFovLHToRef\r\n        //    m[10] *= -1.0;\r\n        //    m[11] *= -1.0;\r\n\r\n        const n = znear;\r\n        const f = zfar;\r\n\r\n        const t = 1.0 / Math.tan(fov * 0.5);\r\n        const a = isVerticalFovFixed ? t / aspect : t;\r\n        const b = isVerticalFovFixed ? t : t * aspect;\r\n        const c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;\r\n        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2 * f * n) / (f - n) : -2 * n;\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar not used as infinity is used as far clip\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     */\r\n    public static PerspectiveFovReverseRHToRef(\r\n        fov: number,\r\n        aspect: number,\r\n        znear: number,\r\n        zfar: number,\r\n        result: Matrix,\r\n        isVerticalFovFixed = true,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0\r\n    ): void {\r\n        const t = 1.0 / Math.tan(fov * 0.5);\r\n        const a = isVerticalFovFixed ? t / aspect : t;\r\n        const b = isVerticalFovFixed ? t : t * aspect;\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, -1.0, 0.0, 0.0, -1.0, 0.0, result);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a perspective projection for WebVR info a given matrix\r\n     * @param fov defines the field of view\r\n     * @param fov.upDegrees\r\n     * @param fov.downDegrees\r\n     * @param fov.leftDegrees\r\n     * @param fov.rightDegrees\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\r\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\r\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\r\n     */\r\n    public static PerspectiveFovWebVRToRef(\r\n        fov: { upDegrees: number; downDegrees: number; leftDegrees: number; rightDegrees: number },\r\n        znear: number,\r\n        zfar: number,\r\n        result: Matrix,\r\n        rightHanded = false,\r\n        halfZRange?: boolean,\r\n        projectionPlaneTilt: number = 0\r\n    ): void {\r\n        const rightHandedFactor = rightHanded ? -1 : 1;\r\n\r\n        const upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\r\n        const downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\r\n        const leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\r\n        const rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\r\n        const xScale = 2.0 / (leftTan + rightTan);\r\n        const yScale = 2.0 / (upTan + downTan);\r\n        const rot = Math.tan(projectionPlaneTilt);\r\n\r\n        const m = result._m;\r\n        m[0] = xScale;\r\n        m[1] = m[2] = m[3] = m[4] = 0.0;\r\n        m[5] = yScale;\r\n        m[6] = 0.0;\r\n        m[7] = rot;\r\n        m[8] = (leftTan - rightTan) * xScale * 0.5;\r\n        m[9] = -((upTan - downTan) * yScale * 0.5);\r\n        m[10] = -zfar / (znear - zfar);\r\n        m[11] = 1.0 * rightHandedFactor;\r\n        m[12] = m[13] = m[15] = 0.0;\r\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\r\n\r\n        if (halfZRange) {\r\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\r\n        }\r\n\r\n        result.markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Computes a complete transformation matrix\r\n     * @param viewport defines the viewport to use\r\n     * @param world defines the world matrix\r\n     * @param view defines the view matrix\r\n     * @param projection defines the projection matrix\r\n     * @param zmin defines the near clip plane\r\n     * @param zmax defines the far clip plane\r\n     * @returns the transformation matrix\r\n     */\r\n    public static GetFinalMatrix(\r\n        viewport: DeepImmutable<Viewport>,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        zmin: number,\r\n        zmax: number\r\n    ): Matrix {\r\n        const cw = viewport.width;\r\n        const ch = viewport.height;\r\n        const cx = viewport.x;\r\n        const cy = viewport.y;\r\n\r\n        const viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\r\n\r\n        const matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        return matrix.multiply(viewportMatrix);\r\n    }\r\n\r\n    /**\r\n     * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\r\n     */\r\n    public static GetAsMatrix2x2(matrix: DeepImmutable<Matrix>): Float32Array | Array<number> {\r\n        const m = matrix.m;\r\n        const arr = [m[0], m[1], m[4], m[5]];\r\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\r\n    }\r\n    /**\r\n     * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\r\n     */\r\n    public static GetAsMatrix3x3(matrix: DeepImmutable<Matrix>): Float32Array | Array<number> {\r\n        const m = matrix.m;\r\n        const arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\r\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of a given matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @returns the new matrix\r\n     */\r\n    public static Transpose(matrix: DeepImmutable<Matrix>): Matrix {\r\n        const result = new Matrix();\r\n        Matrix.TransposeToRef(matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of a matrix and store it in a target matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @param result defines the target matrix\r\n     */\r\n    public static TransposeToRef(matrix: DeepImmutable<Matrix>, result: Matrix): void {\r\n        const rm = result._m;\r\n        const mm = matrix.m;\r\n        rm[0] = mm[0];\r\n        rm[1] = mm[4];\r\n        rm[2] = mm[8];\r\n        rm[3] = mm[12];\r\n\r\n        rm[4] = mm[1];\r\n        rm[5] = mm[5];\r\n        rm[6] = mm[9];\r\n        rm[7] = mm[13];\r\n\r\n        rm[8] = mm[2];\r\n        rm[9] = mm[6];\r\n        rm[10] = mm[10];\r\n        rm[11] = mm[14];\r\n\r\n        rm[12] = mm[3];\r\n        rm[13] = mm[7];\r\n        rm[14] = mm[11];\r\n        rm[15] = mm[15];\r\n\r\n        result.markAsUpdated();\r\n\r\n        // identity-ness does not change when transposing\r\n        result._updateIdentityStatus((matrix as Matrix)._isIdentity, (matrix as Matrix)._isIdentityDirty);\r\n    }\r\n\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @returns a new matrix\r\n     */\r\n    public static Reflection(plane: DeepImmutable<IPlaneLike>): Matrix {\r\n        const matrix = new Matrix();\r\n        Matrix.ReflectionToRef(plane, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ReflectionToRef(plane: DeepImmutable<IPlaneLike>, result: Matrix): void {\r\n        plane.normalize();\r\n        const x = plane.normal.x;\r\n        const y = plane.normal.y;\r\n        const z = plane.normal.z;\r\n        const temp = -2 * x;\r\n        const temp2 = -2 * y;\r\n        const temp3 = -2 * z;\r\n        Matrix.FromValuesToRef(\r\n            temp * x + 1,\r\n            temp2 * x,\r\n            temp3 * x,\r\n            0.0,\r\n            temp * y,\r\n            temp2 * y + 1,\r\n            temp3 * y,\r\n            0.0,\r\n            temp * z,\r\n            temp2 * z,\r\n            temp3 * z + 1,\r\n            0.0,\r\n            temp * plane.d,\r\n            temp2 * plane.d,\r\n            temp3 * plane.d,\r\n            1.0,\r\n            result\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\r\n     * @param xaxis defines the value of the 1st axis\r\n     * @param yaxis defines the value of the 2nd axis\r\n     * @param zaxis defines the value of the 3rd axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromXYZAxesToRef(xaxis: DeepImmutable<Vector3>, yaxis: DeepImmutable<Vector3>, zaxis: DeepImmutable<Vector3>, result: Matrix) {\r\n        Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0.0, yaxis._x, yaxis._y, yaxis._z, 0.0, zaxis._x, zaxis._y, zaxis._z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\r\n     * @param quat defines the quaternion to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromQuaternionToRef(quat: DeepImmutable<Quaternion>, result: Matrix) {\r\n        const xx = quat._x * quat._x;\r\n        const yy = quat._y * quat._y;\r\n        const zz = quat._z * quat._z;\r\n        const xy = quat._x * quat._y;\r\n        const zw = quat._z * quat._w;\r\n        const zx = quat._z * quat._x;\r\n        const yw = quat._y * quat._w;\r\n        const yz = quat._y * quat._z;\r\n        const xw = quat._x * quat._w;\r\n\r\n        result._m[0] = 1.0 - 2.0 * (yy + zz);\r\n        result._m[1] = 2.0 * (xy + zw);\r\n        result._m[2] = 2.0 * (zx - yw);\r\n        result._m[3] = 0.0;\r\n\r\n        result._m[4] = 2.0 * (xy - zw);\r\n        result._m[5] = 1.0 - 2.0 * (zz + xx);\r\n        result._m[6] = 2.0 * (yz + xw);\r\n        result._m[7] = 0.0;\r\n\r\n        result._m[8] = 2.0 * (zx + yw);\r\n        result._m[9] = 2.0 * (yz - xw);\r\n        result._m[10] = 1.0 - 2.0 * (yy + xx);\r\n        result._m[11] = 0.0;\r\n\r\n        result._m[12] = 0.0;\r\n        result._m[13] = 0.0;\r\n        result._m[14] = 0.0;\r\n        result._m[15] = 1.0;\r\n\r\n        result.markAsUpdated();\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\r\n */\r\nclass MathTmp {\r\n    public static Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);\r\n    public static Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);\r\n    public static Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TmpVectors {\r\n    public static Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\r\n    public static Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\r\n    public static Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\r\n    public static Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\r\n    public static Matrix = ArrayTools.BuildTuple(8, Matrix.Identity); // 8 temp Matrices at once should be enough\r\n}\r\n\r\nRegisterClass(\"BABYLON.Vector2\", Vector2);\r\nRegisterClass(\"BABYLON.Vector3\", Vector3);\r\nRegisterClass(\"BABYLON.Vector4\", Vector4);\r\nRegisterClass(\"BABYLON.Matrix\", Matrix);\r\n\r\nconst mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\r\n"]},"metadata":{},"sourceType":"module"}