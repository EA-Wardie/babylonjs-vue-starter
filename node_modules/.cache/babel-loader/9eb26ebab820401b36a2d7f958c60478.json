{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/web.atob.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * Effect wrapping a compute shader and let execute (dispatch) the shader\n */\n\nvar ComputeEffect =\n/** @class */\nfunction () {\n  /**\n   * Creates a compute effect that can be used to execute a compute shader\n   * @param baseName Name of the effect\n   * @param options Set of all options to create the effect\n   * @param engine The engine the effect is created for\n   * @param key Effect Key identifying uniquely compiled shader variants\n   */\n  function ComputeEffect(baseName, options, engine, key) {\n    if (key === void 0) {\n      key = \"\";\n    }\n\n    var _this = this;\n\n    var _a, _b;\n    /**\n     * Name of the effect.\n     */\n\n\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n\n    this.onError = null;\n    /**\n     * Unique ID of the effect.\n     */\n\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n\n    this.onErrorObservable = new Observable();\n    /**\n     * Observable that will be called when effect is bound.\n     */\n\n    this.onBindObservable = new Observable();\n    /**\n     * @hidden\n     * Specifies if the effect was previously ready\n     */\n\n    this._wasPreviouslyReady = false;\n    this._isReady = false;\n    this._compilationError = \"\";\n    /** @hidden */\n\n    this._key = \"\";\n    this._computeSourceCodeOverride = \"\";\n    /** @hidden */\n\n    this._pipelineContext = null;\n    /** @hidden */\n\n    this._computeSourceCode = \"\";\n    this._rawComputeSourceCode = \"\";\n    this._shaderLanguage = ShaderLanguage.WGSL;\n    this.name = baseName;\n    this._key = key;\n    this._engine = engine;\n    this.uniqueId = ComputeEffect._UniqueIdSeed++;\n    this.defines = (_a = options.defines) !== null && _a !== void 0 ? _a : \"\";\n    this.onError = options.onError;\n    this.onCompiled = options.onCompiled;\n    this._entryPoint = (_b = options.entryPoint) !== null && _b !== void 0 ? _b : \"main\";\n    this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\n    this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\n    this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\n    var computeSource;\n    var hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n\n    if (baseName.computeSource) {\n      computeSource = \"source:\" + baseName.computeSource;\n    } else if (baseName.computeElement) {\n      computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\n\n      if (!computeSource) {\n        computeSource = baseName.computeElement;\n      }\n    } else {\n      computeSource = baseName.compute || baseName;\n    }\n\n    var processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: undefined,\n      isFragment: false,\n      shouldUseHighPrecisionShader: false,\n      processor: null,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: this._shaderRepository,\n      includesShadersStore: this._includeShaderStore,\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: null,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer\n    };\n\n    this._loadShader(computeSource, \"Compute\", \"\", function (computeCode) {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.PreProcess(computeCode, processorOptions, function (migratedCommputeCode) {\n        _this._rawComputeSourceCode = computeCode;\n\n        if (options.processFinalCode) {\n          migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\n        }\n\n        var finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\n\n        _this._useFinalCode(finalShaders.vertexCode, baseName);\n      }, _this._engine);\n    });\n  }\n\n  ComputeEffect.prototype._useFinalCode = function (migratedCommputeCode, baseName) {\n    if (baseName) {\n      var compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\n      this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\n    } else {\n      this._computeSourceCode = migratedCommputeCode;\n    }\n\n    this._prepareEffect();\n  };\n\n  Object.defineProperty(ComputeEffect.prototype, \"key\", {\n    /**\n     * Unique key for this effect\n     */\n    get: function get() {\n      return this._key;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n\n  ComputeEffect.prototype.isReady = function () {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  ComputeEffect.prototype._isReadyInternal = function () {\n    if (this._isReady) {\n      return true;\n    }\n\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n\n    return false;\n  };\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n\n\n  ComputeEffect.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n\n\n  ComputeEffect.prototype.getPipelineContext = function () {\n    return this._pipelineContext;\n  };\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n\n\n  ComputeEffect.prototype.getCompilationError = function () {\n    return this._compilationError;\n  };\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n\n\n  ComputeEffect.prototype.executeWhenCompiled = function (func) {\n    var _this = this;\n\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n\n    this.onCompileObservable.add(function (effect) {\n      func(effect);\n    });\n\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(function () {\n        _this._checkIsReady(null);\n      }, 16);\n    }\n  };\n\n  ComputeEffect.prototype._checkIsReady = function (previousPipelineContext) {\n    var _this = this;\n\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n\n      return;\n    }\n\n    setTimeout(function () {\n      _this._checkIsReady(previousPipelineContext);\n    }, 16);\n  };\n\n  ComputeEffect.prototype._loadShader = function (shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        var shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    } // Direct source ?\n\n\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    } // Base64 encoded ?\n\n\n    if (shader.substr(0, 7) === \"base64:\") {\n      var shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    } // Is in local store ?\n\n\n    if (this._shaderStore[shader + key + \"Shader\"]) {\n      callback(this._shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n\n    if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n\n    var shaderUrl;\n\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = this._shaderRepository + shader;\n    }\n\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  };\n\n  Object.defineProperty(ComputeEffect.prototype, \"computeSourceCode\", {\n    /**\n     * Gets the compute shader source code of this effect\n     */\n    get: function get() {\n      var _a, _b;\n\n      return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) !== null && _b !== void 0 ? _b : this._computeSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ComputeEffect.prototype, \"rawComputeSourceCode\", {\n    /**\n     * Gets the compute shader source code before it has been processed by the preprocessor\n     */\n    get: function get() {\n      return this._rawComputeSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Prepares the effect\n   * @hidden\n   */\n\n  ComputeEffect.prototype._prepareEffect = function () {\n    var _this = this;\n\n    var defines = this.defines;\n    var previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n\n    try {\n      var engine = this._engine;\n      this._pipelineContext = engine.createComputePipelineContext();\n      this._pipelineContext._name = this._key;\n\n      engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);\n\n      engine._executeWhenComputeStateIsCompiled(this._pipelineContext, function () {\n        _this._compilationError = \"\";\n        _this._isReady = true;\n\n        if (_this.onCompiled) {\n          _this.onCompiled(_this);\n        }\n\n        _this.onCompileObservable.notifyObservers(_this);\n\n        _this.onCompileObservable.clear();\n\n        if (previousPipelineContext) {\n          _this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\n        }\n      });\n\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  };\n\n  ComputeEffect.prototype._getShaderCodeAndErrorLine = function (code, error) {\n    var regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\n    var errorLine = null;\n\n    if (error && code) {\n      var res = error.match(regexp);\n\n      if (res && res.length === 2) {\n        var lineNumber = parseInt(res[1]);\n        var lines = code.split(\"\\n\", -1);\n\n        if (lines.length >= lineNumber) {\n          errorLine = \"Offending line [\".concat(lineNumber, \"] in compute code: \").concat(lines[lineNumber - 1]);\n        }\n      }\n    }\n\n    return [code, errorLine];\n  };\n\n  ComputeEffect.prototype._processCompilationErrors = function (e, previousPipelineContext) {\n    var _a;\n\n    var _b;\n\n    if (previousPipelineContext === void 0) {\n      previousPipelineContext = null;\n    }\n\n    this._compilationError = e.message; // Let's go through fallbacks then\n\n    Logger.Error(\"Unable to compile compute effect:\");\n    Logger.Error(\"Defines:\\r\\n\" + this.defines);\n\n    if (ComputeEffect.LogShaderCodeOnCompilationError) {\n      var lineErrorVertex = null,\n          code = null;\n\n      if ((_b = this._pipelineContext) === null || _b === void 0 ? void 0 : _b._getComputeShaderCode()) {\n        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError), code = _a[0], lineErrorVertex = _a[1];\n\n        if (code) {\n          Logger.Error(\"Compute code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n    }\n\n    Logger.Error(\"Error: \" + this._compilationError);\n\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n\n      this.onErrorObservable.notifyObservers(this);\n    }\n  };\n  /**\n   * Release all associated resources.\n   **/\n\n\n  ComputeEffect.prototype.dispose = function () {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n\n    this._engine._releaseComputeEffect(this);\n  };\n  /**\n   * This function will add a new compute shader to the shader store\n   * @param name the name of the shader\n   * @param computeShader compute shader content\n   */\n\n\n  ComputeEffect.RegisterShader = function (name, computeShader) {\n    ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[\"\".concat(name, \"ComputeShader\")] = computeShader;\n  };\n\n  ComputeEffect._UniqueIdSeed = 0;\n  /**\n   * Enable logging of the shader code when a compilation error occurs\n   */\n\n  ComputeEffect.LogShaderCodeOnCompilationError = true;\n  return ComputeEffect;\n}();\n\nexport { ComputeEffect };","map":{"version":3,"mappings":"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","names":["Logger","Observable","GetDOMTextContent","IsWindowObjectExist","ShaderProcessor","ShaderStore","ShaderLanguage","baseName","options","engine","key","WGSL","name","_key","_engine","uniqueId","ComputeEffect","_UniqueIdSeed","defines","_a","onError","onCompiled","_entryPoint","entryPoint","_b","_shaderStore","GetShadersStore","_shaderLanguage","_shaderRepository","GetShadersRepository","_includeShaderStore","GetIncludesShadersStore","computeSource","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","split","indexParameters","undefined","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","_loadShader","computeCode","Initialize","PreProcess","migratedCommputeCode","_this","_rawComputeSourceCode","processFinalCode","finalShaders","Finalize","_useFinalCode","vertexCode","spectorName","_computeSourceCode","_prepareEffect","Object","_isReadyInternal","_isReady","_pipelineContext","isReady","_compilationError","func","onCompileObservable","add","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","shaderCode","substr","shaderBinary","window","atob","shaderUrl","indexOf","_loadFile","toLowerCase","_computeSourceCodeOverride","_getComputeShaderCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","notifyObservers","clear","getEngine","_deleteComputePipelineContext","code","error","regexp","errorLine","res","match","length","lineNumber","parseInt","lines","concat","message","Error","LogShaderCodeOnCompilationError","lineErrorVertex","_getShaderCodeAndErrorLine","onErrorObservable","dispose","_releaseComputeEffect","computeShader"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Compute/computeEffect.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IComputePipelineContext } from \"./IComputePipelineContext\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * Options to be used when creating a compute effect.\r\n */\r\nexport interface IComputeEffectCreationOptions {\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: ComputeEffect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: ComputeEffect, errors: string) => void>;\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * Effect wrapping a compute shader and let execute (dispatch) the shader\r\n */\r\nexport class ComputeEffect {\r\n    private static _UniqueIdSeed = 0;\r\n\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public onBindObservable = new Observable<ComputeEffect>();\r\n\r\n    /**\r\n     * @hidden\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    private _engine: Engine;\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    /** @hidden */\r\n    public _key: string = \"\";\r\n    private _computeSourceCodeOverride: string = \"\";\r\n    /** @hidden */\r\n    public _pipelineContext: Nullable<IComputePipelineContext> = null;\r\n    /** @hidden */\r\n    public _computeSourceCode: string = \"\";\r\n    private _rawComputeSourceCode: string = \"\";\r\n    private _entryPoint: string;\r\n    private _shaderLanguage = ShaderLanguage.WGSL;\r\n    private _shaderStore: { [key: string]: string };\r\n    private _shaderRepository: string;\r\n    private _includeShaderStore: { [key: string]: string };\r\n\r\n    /**\r\n     * Creates a compute effect that can be used to execute a compute shader\r\n     * @param baseName Name of the effect\r\n     * @param options Set of all options to create the effect\r\n     * @param engine The engine the effect is created for\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     */\r\n    constructor(baseName: any, options: IComputeEffectCreationOptions, engine: Engine, key = \"\") {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        this._engine = engine;\r\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\r\n\r\n        this.defines = options.defines ?? \"\";\r\n        this.onError = options.onError;\r\n        this.onCompiled = options.onCompiled;\r\n        this._entryPoint = options.entryPoint ?? \"main\";\r\n\r\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\r\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\r\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\r\n\r\n        let computeSource: any;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.computeSource) {\r\n            computeSource = \"source:\" + baseName.computeSource;\r\n        } else if (baseName.computeElement) {\r\n            computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\r\n\r\n            if (!computeSource) {\r\n                computeSource = baseName.computeElement;\r\n            }\r\n        } else {\r\n            computeSource = baseName.compute || baseName;\r\n        }\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: false,\r\n            processor: null,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: this._shaderRepository,\r\n            includesShadersStore: this._includeShaderStore,\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.PreProcess(\r\n                computeCode,\r\n                processorOptions,\r\n                (migratedCommputeCode) => {\r\n                    this._rawComputeSourceCode = computeCode;\r\n                    if (options.processFinalCode) {\r\n                        migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\r\n                    }\r\n                    const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\r\n                    this._useFinalCode(finalShaders.vertexCode, baseName);\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedCommputeCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\r\n\r\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\r\n        } else {\r\n            this._computeSourceCode = migratedCommputeCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IComputePipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: ComputeEffect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IComputePipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (this._shaderStore[shader + key + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = this._shaderRepository + shader;\r\n        }\r\n\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code of this effect\r\n     */\r\n    public get computeSourceCode(): string {\r\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawComputeSourceCode(): string {\r\n        return this._rawComputeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @hidden\r\n     */\r\n    public _prepareEffect() {\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createComputePipelineContext();\r\n            this._pipelineContext._name = this._key;\r\n\r\n            engine._prepareComputePipelineContext(\r\n                this._pipelineContext,\r\n                this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode,\r\n                this._rawComputeSourceCode,\r\n                this._computeSourceCodeOverride ? null : defines,\r\n                this._entryPoint\r\n            );\r\n\r\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>): [Nullable<string>, Nullable<string>] {\r\n        const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IComputePipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile compute effect:\");\r\n        Logger.Error(\"Defines:\\r\\n\" + this.defines);\r\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getComputeShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\r\n                if (code) {\r\n                    Logger.Error(\"Compute code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseComputeEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new compute shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param computeShader compute shader content\r\n     */\r\n    public static RegisterShader(name: string, computeShader: string) {\r\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}