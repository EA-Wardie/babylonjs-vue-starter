{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Enum used to define the compatibility state between two connection points\n */\n\nexport var NodeMaterialConnectionPointCompatibilityStates;\n\n(function (NodeMaterialConnectionPointCompatibilityStates) {\n  /** Points are compatibles */\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"Compatible\"] = 0] = \"Compatible\";\n  /** Points are incompatible because of their types */\n\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TypeIncompatible\"] = 1] = \"TypeIncompatible\";\n  /** Points are incompatible because of their targets (vertex vs fragment) */\n\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TargetIncompatible\"] = 2] = \"TargetIncompatible\";\n  /** Points are incompatible because they are in the same hierarchy **/\n\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"HierarchyIssue\"] = 3] = \"HierarchyIssue\";\n})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));\n/**\n * Defines the direction of a connection point\n */\n\n\nexport var NodeMaterialConnectionPointDirection;\n\n(function (NodeMaterialConnectionPointDirection) {\n  /** Input */\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Input\"] = 0] = \"Input\";\n  /** Output */\n\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Output\"] = 1] = \"Output\";\n})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));\n/**\n * Defines a connection point for a block\n */\n\n\nvar NodeMaterialConnectionPoint =\n/** @class */\nfunction () {\n  /**\n   * Creates a new connection point\n   * @param name defines the connection point name\n   * @param ownerBlock defines the block hosting this connection point\n   * @param direction defines the direction of the connection point\n   */\n  function NodeMaterialConnectionPoint(name, ownerBlock, direction) {\n    /** @hidden */\n    this._connectedPoint = null;\n    this._endpoints = new Array();\n    /** @hidden */\n\n    this._typeConnectionSource = null;\n    /** @hidden */\n\n    this._defaultConnectionPointType = null;\n    /** @hidden */\n\n    this._linkedConnectionSource = null;\n    /** @hidden */\n\n    this._acceptedConnectionPointType = null;\n    this._type = NodeMaterialBlockConnectionPointTypes.Float;\n    /** @hidden */\n\n    this._enforceAssociatedVariableName = false;\n    /** Indicates that this connection point needs dual validation before being connected to another point */\n\n    this.needDualDirectionValidation = false;\n    /**\n     * Gets or sets the additional types supported by this connection point\n     */\n\n    this.acceptedConnectionPointTypes = new Array();\n    /**\n     * Gets or sets the additional types excluded by this connection point\n     */\n\n    this.excludedConnectionPointTypes = new Array();\n    /**\n     * Observable triggered when this point is connected\n     */\n\n    this.onConnectionObservable = new Observable();\n    /**\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\n     */\n\n    this.isExposedOnFrame = false;\n    /**\n     * Gets or sets number indicating the position that the port is exposed to on a frame\n     */\n\n    this.exposedPortPosition = -1;\n    /** @hidden */\n\n    this._prioritizeVertex = false;\n    this._target = NodeMaterialBlockTargets.VertexAndFragment;\n    this._ownerBlock = ownerBlock;\n    this.name = name;\n    this._direction = direction;\n  }\n  /**\n   * Checks if two types are equivalent\n   * @param type1 type 1 to check\n   * @param type2 type 2 to check\n   * @returns true if both types are equivalent, else false\n   */\n\n\n  NodeMaterialConnectionPoint.AreEquivalentTypes = function (type1, type2) {\n    switch (type1) {\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\n            return true;\n          }\n\n          break;\n        }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"direction\", {\n    /** Gets the direction of the point */\n    get: function get() {\n      return this._direction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"associatedVariableName\", {\n    /**\n     * Gets or sets the associated variable name in the shader\n     */\n    get: function get() {\n      if (this._ownerBlock.isInput) {\n        return this._ownerBlock.associatedVariableName;\n      }\n\n      if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\n        return this._connectedPoint.associatedVariableName;\n      }\n\n      return this._associatedVariableName;\n    },\n    set: function set(value) {\n      this._associatedVariableName = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"innerType\", {\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\n    get: function get() {\n      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n        return this.type;\n      }\n\n      return this._type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"type\", {\n    /**\n     * Gets or sets the connection point type (default is float)\n     */\n    get: function get() {\n      if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n        if (this._ownerBlock.isInput) {\n          return this._ownerBlock.type;\n        }\n\n        if (this._connectedPoint) {\n          return this._connectedPoint.type;\n        }\n\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n          return this._linkedConnectionSource.type;\n        }\n      }\n\n      if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\n        if (this._typeConnectionSource) {\n          if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\n            return this._defaultConnectionPointType;\n          }\n\n          return this._typeConnectionSource.type;\n        } else if (this._defaultConnectionPointType) {\n          return this._defaultConnectionPointType;\n        }\n      }\n\n      return this._type;\n    },\n    set: function set(value) {\n      this._type = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"target\", {\n    /** Gets or sets the target of that connection point */\n    get: function get() {\n      if (!this._prioritizeVertex || !this._ownerBlock) {\n        return this._target;\n      }\n\n      if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\n        return this._target;\n      }\n\n      if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n        return NodeMaterialBlockTargets.Fragment;\n      }\n\n      return NodeMaterialBlockTargets.Vertex;\n    },\n    set: function set(value) {\n      this._target = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnected\", {\n    /**\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\n     */\n    get: function get() {\n      return this.connectedPoint !== null || this.hasEndpoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedToInputBlock\", {\n    /**\n     * Gets a boolean indicating that the current point is connected to an input block\n     */\n    get: function get() {\n      return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectInputBlock\", {\n    /**\n     * Gets a the connected input block (if any)\n     */\n    get: function get() {\n      if (!this.isConnectedToInputBlock) {\n        return null;\n      }\n\n      return this.connectedPoint.ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectedPoint\", {\n    /** Get the other side of the connection (if any) */\n    get: function get() {\n      return this._connectedPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"ownerBlock\", {\n    /** Get the block that owns this connection point */\n    get: function get() {\n      return this._ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"sourceBlock\", {\n    /** Get the block connected on the other side of this connection (if any) */\n    get: function get() {\n      if (!this._connectedPoint) {\n        return null;\n      }\n\n      return this._connectedPoint.ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectedBlocks\", {\n    /** Get the block connected on the endpoints of this connection (if any) */\n    get: function get() {\n      if (this._endpoints.length === 0) {\n        return [];\n      }\n\n      return this._endpoints.map(function (e) {\n        return e.ownerBlock;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"endpoints\", {\n    /** Gets the list of connected endpoints */\n    get: function get() {\n      return this._endpoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"hasEndpoints\", {\n    /** Gets a boolean indicating if that output point is connected to at least one input */\n    get: function get() {\n      return this._endpoints && this._endpoints.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isDirectlyConnectedToVertexOutput\", {\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\n    get: function get() {\n      if (!this.hasEndpoints) {\n        return false;\n      }\n\n      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {\n        var endpoint = _a[_i];\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          if (endpoint.ownerBlock.outputs.some(function (o) {\n            return o.isDirectlyConnectedToVertexOutput;\n          })) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedInVertexShader\", {\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\n    get: function get() {\n      if (this.target === NodeMaterialBlockTargets.Vertex) {\n        return true;\n      }\n\n      if (!this.hasEndpoints) {\n        return false;\n      }\n\n      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {\n        var endpoint = _a[_i];\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\n          return true;\n        }\n\n        if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          if (endpoint.ownerBlock.outputs.some(function (o) {\n            return o.isConnectedInVertexShader;\n          })) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedInFragmentShader\", {\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\n    get: function get() {\n      if (this.target === NodeMaterialBlockTargets.Fragment) {\n        return true;\n      }\n\n      if (!this.hasEndpoints) {\n        return false;\n      }\n\n      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {\n        var endpoint = _a[_i];\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          if (endpoint.ownerBlock.outputs.some(function (o) {\n            return o.isConnectedInFragmentShader;\n          })) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a block suitable to be used as an input for this input point.\n   * If null is returned, a block based on the point type will be created.\n   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\n   */\n\n  NodeMaterialConnectionPoint.prototype.createCustomInputBlock = function () {\n    return null;\n  };\n  /**\n   * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\n   * @returns the class name\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.getClassName = function () {\n    return \"NodeMaterialConnectionPoint\";\n  };\n  /**\n   * Gets a boolean indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a boolean\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.canConnectTo = function (connectionPoint) {\n    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  };\n  /**\n   * Gets a number indicating if the current point can be connected to another point\n   * @param connectionPoint defines the other connection point\n   * @returns a number defining the compatibility state\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.checkCompatibilityState = function (connectionPoint) {\n    var ownerBlock = this._ownerBlock;\n    var otherBlock = connectionPoint.ownerBlock;\n\n    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      // Let's check we are not going reverse\n      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\n        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n      }\n\n      for (var _i = 0, _a = otherBlock.outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\n          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n        }\n      }\n    }\n\n    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n      // Equivalents\n      if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      } // Accepted types\n\n\n      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      } else {\n        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\n      }\n    } // Excluded\n\n\n    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\n      return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\n    } // Check hierarchy\n\n\n    var targetBlock = otherBlock;\n    var sourceBlock = ownerBlock;\n\n    if (this.direction === NodeMaterialConnectionPointDirection.Input) {\n      targetBlock = ownerBlock;\n      sourceBlock = otherBlock;\n    }\n\n    if (targetBlock.isAnAncestorOf(sourceBlock)) {\n      return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\n    }\n\n    return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  };\n  /**\n   * Connect this point to another connection point\n   * @param connectionPoint defines the other connection point\n   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\n   * @returns the current connection point\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.connectTo = function (connectionPoint, ignoreConstraints) {\n    if (ignoreConstraints === void 0) {\n      ignoreConstraints = false;\n    }\n\n    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\n      throw \"Cannot connect these two connectors.\";\n    }\n\n    this._endpoints.push(connectionPoint);\n\n    connectionPoint._connectedPoint = this;\n    this._enforceAssociatedVariableName = false;\n    this.onConnectionObservable.notifyObservers(connectionPoint);\n    connectionPoint.onConnectionObservable.notifyObservers(this);\n    return this;\n  };\n  /**\n   * Disconnect this point from one of his endpoint\n   * @param endpoint defines the other connection point\n   * @returns the current connection point\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.disconnectFrom = function (endpoint) {\n    var index = this._endpoints.indexOf(endpoint);\n\n    if (index === -1) {\n      return this;\n    }\n\n    this._endpoints.splice(index, 1);\n\n    endpoint._connectedPoint = null;\n    this._enforceAssociatedVariableName = false;\n    endpoint._enforceAssociatedVariableName = false;\n    return this;\n  };\n  /**\n   * Serializes this point in a JSON representation\n   * @param isInput defines if the connection point is an input (default is true)\n   * @returns the serialized point object\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.serialize = function (isInput) {\n    if (isInput === void 0) {\n      isInput = true;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.displayName = this.displayName;\n\n    if (isInput && this.connectedPoint) {\n      serializationObject.inputName = this.name;\n      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\n      serializationObject.targetConnectionName = this.connectedPoint.name;\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n\n    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Release resources\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.dispose = function () {\n    this.onConnectionObservable.clear();\n  };\n\n  return NodeMaterialConnectionPoint;\n}();\n\nexport { NodeMaterialConnectionPoint };","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","Observable","NodeMaterialConnectionPointCompatibilityStates","NodeMaterialConnectionPointDirection","name","ownerBlock","direction","Array","Float","VertexAndFragment","_ownerBlock","_direction","NodeMaterialConnectionPoint","type1","type2","Vector3","Color3","Vector4","Color4","Object","isInput","associatedVariableName","_enforceAssociatedVariableName","_associatedVariableName","_connectedPoint","value","_linkedConnectionSource","isConnected","type","_type","AutoDetect","BasedOnInput","_typeConnectionSource","_defaultConnectionPointType","_prioritizeVertex","_target","target","Fragment","Vertex","connectedPoint","hasEndpoints","isConnectedToInputBlock","_endpoints","length","map","e","_i","endpoint","Neutral","outputs","some","o","isDirectlyConnectedToVertexOutput","isConnectedInVertexShader","isConnectedInFragmentShader","connectionPoint","checkCompatibilityState","Compatible","otherBlock","TargetIncompatible","output","innerType","AreEquivalentTypes","acceptedConnectionPointTypes","indexOf","_acceptedConnectionPointType","TypeIncompatible","excludedConnectionPointTypes","targetBlock","sourceBlock","Input","isAnAncestorOf","HierarchyIssue","ignoreConstraints","canConnectTo","push","onConnectionObservable","notifyObservers","index","splice","serializationObject","displayName","inputName","targetBlockId","uniqueId","targetConnectionName","isExposedOnFrame","exposedPortPosition","clear"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/nodeMaterialBlockConnectionPoint.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\ndeclare type NodeMaterialBlock = import(\"./nodeMaterialBlock\").NodeMaterialBlock;\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @hidden */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @hidden */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _defaultConnectionPointType: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @hidden */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @hidden */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @hidden */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}