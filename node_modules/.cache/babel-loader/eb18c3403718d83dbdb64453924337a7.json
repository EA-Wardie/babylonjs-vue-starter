{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { TextureSampler } from \"./textureSampler.js\";\n/**\n * Defines the source of the internal texture\n */\n\nexport var InternalTextureSource;\n\n(function (InternalTextureSource) {\n  /**\n   * The source of the texture data is unknown\n   */\n  InternalTextureSource[InternalTextureSource[\"Unknown\"] = 0] = \"Unknown\";\n  /**\n   * Texture data comes from an URL\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Url\"] = 1] = \"Url\";\n  /**\n   * Texture data is only used for temporary storage\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Temp\"] = 2] = \"Temp\";\n  /**\n   * Texture data comes from raw data (ArrayBuffer)\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw\"] = 3] = \"Raw\";\n  /**\n   * Texture content is dynamic (video or dynamic texture)\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Dynamic\"] = 4] = \"Dynamic\";\n  /**\n   * Texture content is generated by rendering to it\n   */\n\n  InternalTextureSource[InternalTextureSource[\"RenderTarget\"] = 5] = \"RenderTarget\";\n  /**\n   * Texture content is part of a multi render target process\n   */\n\n  InternalTextureSource[InternalTextureSource[\"MultiRenderTarget\"] = 6] = \"MultiRenderTarget\";\n  /**\n   * Texture data comes from a cube data file\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Cube\"] = 7] = \"Cube\";\n  /**\n   * Texture data comes from a raw cube data\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubeRaw\"] = 8] = \"CubeRaw\";\n  /**\n   * Texture data come from a prefiltered cube data file\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubePrefiltered\"] = 9] = \"CubePrefiltered\";\n  /**\n   * Texture content is raw 3D data\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw3D\"] = 10] = \"Raw3D\";\n  /**\n   * Texture content is raw 2D array data\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw2DArray\"] = 11] = \"Raw2DArray\";\n  /**\n   * Texture content is a depth/stencil texture\n   */\n\n  InternalTextureSource[InternalTextureSource[\"DepthStencil\"] = 12] = \"DepthStencil\";\n  /**\n   * Texture data comes from a raw cube data encoded with RGBD\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubeRawRGBD\"] = 13] = \"CubeRawRGBD\";\n  /**\n   * Texture content is a depth texture\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Depth\"] = 14] = \"Depth\";\n})(InternalTextureSource || (InternalTextureSource = {}));\n/**\n * Class used to store data associated with WebGL texture data for the engine\n * This class should not be used directly\n */\n\n\nvar InternalTexture =\n/** @class */\nfunction (_super) {\n  __extends(InternalTexture, _super);\n  /**\n   * Creates a new InternalTexture\n   * @param engine defines the engine to use\n   * @param source defines the type of data that will be used\n   * @param delayAllocation if the texture allocation should be delayed (default: false)\n   */\n\n\n  function InternalTexture(engine, source, delayAllocation) {\n    if (delayAllocation === void 0) {\n      delayAllocation = false;\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * Defines if the texture is ready\n     */\n\n\n    _this.isReady = false;\n    /**\n     * Defines if the texture is a cube texture\n     */\n\n    _this.isCube = false;\n    /**\n     * Defines if the texture contains 3D data\n     */\n\n    _this.is3D = false;\n    /**\n     * Defines if the texture contains 2D array data\n     */\n\n    _this.is2DArray = false;\n    /**\n     * Defines if the texture contains multiview data\n     */\n\n    _this.isMultiview = false;\n    /**\n     * Gets the URL used to load this texture\n     */\n\n    _this.url = \"\";\n    /**\n     * Gets a boolean indicating if the texture needs mipmaps generation\n     */\n\n    _this.generateMipMaps = false;\n    /**\n     * Gets the number of samples used by the texture (WebGL2+ only)\n     */\n\n    _this.samples = 0;\n    /**\n     * Gets the type of the texture (int, float...)\n     */\n\n    _this.type = -1;\n    /**\n     * Gets the format of the texture (RGB, RGBA...)\n     */\n\n    _this.format = -1;\n    /**\n     * Observable called when the texture is loaded\n     */\n\n    _this.onLoadedObservable = new Observable();\n    /**\n     * Observable called when the texture load is raising an error\n     */\n\n    _this.onErrorObservable = new Observable();\n    /**\n     * If this callback is defined it will be called instead of the default _rebuild function\n     */\n\n    _this.onRebuildCallback = null;\n    /**\n     * Gets the width of the texture\n     */\n\n    _this.width = 0;\n    /**\n     * Gets the height of the texture\n     */\n\n    _this.height = 0;\n    /**\n     * Gets the depth of the texture\n     */\n\n    _this.depth = 0;\n    /**\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n\n    _this.baseWidth = 0;\n    /**\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n\n    _this.baseHeight = 0;\n    /**\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\n     */\n\n    _this.baseDepth = 0;\n    /**\n     * Gets a boolean indicating if the texture is inverted on Y axis\n     */\n\n    _this.invertY = false; // Private\n\n    /** @hidden */\n\n    _this._invertVScale = false;\n    /** @hidden */\n\n    _this._associatedChannel = -1;\n    /** @hidden */\n\n    _this._source = InternalTextureSource.Unknown;\n    /** @hidden */\n\n    _this._buffer = null;\n    /** @hidden */\n\n    _this._bufferView = null;\n    /** @hidden */\n\n    _this._bufferViewArray = null;\n    /** @hidden */\n\n    _this._bufferViewArrayArray = null;\n    /** @hidden */\n\n    _this._size = 0;\n    /** @hidden */\n\n    _this._extension = \"\";\n    /** @hidden */\n\n    _this._files = null;\n    /** @hidden */\n\n    _this._workingCanvas = null;\n    /** @hidden */\n\n    _this._workingContext = null;\n    /** @hidden */\n\n    _this._cachedCoordinatesMode = null;\n    /** @hidden */\n\n    _this._isDisabled = false;\n    /** @hidden */\n\n    _this._compression = null;\n    /** @hidden */\n\n    _this._sphericalPolynomial = null;\n    /** @hidden */\n\n    _this._sphericalPolynomialPromise = null;\n    /** @hidden */\n\n    _this._sphericalPolynomialComputed = false;\n    /** @hidden */\n\n    _this._lodGenerationScale = 0;\n    /** @hidden */\n\n    _this._lodGenerationOffset = 0;\n    /** @hidden */\n\n    _this._useSRGBBuffer = false; // The following three fields helps sharing generated fixed LODs for texture filtering\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\n    // They are at the level of the gl texture to benefit from the cache.\n\n    /** @hidden */\n\n    _this._lodTextureHigh = null;\n    /** @hidden */\n\n    _this._lodTextureMid = null;\n    /** @hidden */\n\n    _this._lodTextureLow = null;\n    /** @hidden */\n\n    _this._isRGBD = false;\n    /** @hidden */\n\n    _this._linearSpecularLOD = false;\n    /** @hidden */\n\n    _this._irradianceTexture = null;\n    /** @hidden */\n\n    _this._hardwareTexture = null;\n    /** @hidden */\n\n    _this._maxLodLevel = null;\n    /** @hidden */\n\n    _this._references = 1;\n    /** @hidden */\n\n    _this._gammaSpace = null;\n    _this._engine = engine;\n    _this._source = source;\n    _this._uniqueId = InternalTexture._Counter++;\n\n    if (!delayAllocation) {\n      _this._hardwareTexture = engine._createHardwareTexture();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(InternalTexture.prototype, \"useMipMaps\", {\n    /**\n     * Gets a boolean indicating if the texture uses mipmaps\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\n     */\n    get: function get() {\n      return this.generateMipMaps;\n    },\n    set: function set(value) {\n      this.generateMipMaps = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InternalTexture.prototype, \"uniqueId\", {\n    /** Gets the unique id of the internal texture */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the Engine the texture belongs to.\n   * @returns The babylon engine\n   */\n\n  InternalTexture.prototype.getEngine = function () {\n    return this._engine;\n  };\n\n  Object.defineProperty(InternalTexture.prototype, \"source\", {\n    /**\n     * Gets the data source type of the texture\n     */\n    get: function get() {\n      return this._source;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Increments the number of references (ie. the number of Texture that point to it)\n   */\n\n  InternalTexture.prototype.incrementReferences = function () {\n    this._references++;\n  };\n  /**\n   * Change the size of the texture (not the size of the content)\n   * @param width defines the new width\n   * @param height defines the new height\n   * @param depth defines the new depth (1 by default)\n   */\n\n\n  InternalTexture.prototype.updateSize = function (width, height, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    this._engine.updateTextureDimensions(this, width, height, depth);\n\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.baseWidth = width;\n    this.baseHeight = height;\n    this.baseDepth = depth;\n    this._size = width * height * depth;\n  };\n  /** @hidden */\n\n\n  InternalTexture.prototype._rebuild = function () {\n    var _this = this;\n\n    var _a;\n\n    this.isReady = false;\n    this._cachedCoordinatesMode = null;\n    this._cachedWrapU = null;\n    this._cachedWrapV = null;\n    this._cachedWrapR = null;\n    this._cachedAnisotropicFilteringLevel = null;\n\n    if (this.onRebuildCallback) {\n      var data_1 = this.onRebuildCallback(this);\n\n      var swapAndSetIsReady = function swapAndSetIsReady(proxyInternalTexture) {\n        proxyInternalTexture._swapAndDie(_this, false);\n\n        _this.isReady = data_1.isReady;\n      };\n\n      if (data_1.isAsync) {\n        data_1.proxy.then(swapAndSetIsReady);\n      } else {\n        swapAndSetIsReady(data_1.proxy);\n      }\n\n      return;\n    }\n\n    var proxy;\n\n    switch (this.source) {\n      case InternalTextureSource.Temp:\n        break;\n\n      case InternalTextureSource.Url:\n        proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function () {\n          proxy._swapAndDie(_this, false);\n\n          _this.isReady = true;\n        }, null, this._buffer, undefined, this.format, this._extension, undefined, undefined, undefined, this._useSRGBBuffer);\n        return;\n\n      case InternalTextureSource.Raw:\n        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n\n        proxy._swapAndDie(this, false);\n\n        this.isReady = true;\n        break;\n\n      case InternalTextureSource.Raw3D:\n        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n\n        proxy._swapAndDie(this, false);\n\n        this.isReady = true;\n        break;\n\n      case InternalTextureSource.Raw2DArray:\n        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n\n        proxy._swapAndDie(this, false);\n\n        this.isReady = true;\n        break;\n\n      case InternalTextureSource.Dynamic:\n        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\n\n        proxy._swapAndDie(this, false);\n\n        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, undefined, undefined, true); // The engine will make sure to update content so no need to flag it as isReady = true\n\n\n        break;\n\n      case InternalTextureSource.Cube:\n        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function () {\n          proxy._swapAndDie(_this, false);\n\n          _this.isReady = true;\n        }, null, this.format, this._extension, false, 0, 0, null, undefined, this._useSRGBBuffer);\n        return;\n\n      case InternalTextureSource.CubeRaw:\n        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        proxy._swapAndDie(this, false);\n\n        this.isReady = true;\n        break;\n\n      case InternalTextureSource.CubeRawRGBD:\n        // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\n        // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\n        return;\n\n      case InternalTextureSource.CubePrefiltered:\n        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function (proxy) {\n          if (proxy) {\n            proxy._swapAndDie(_this, false);\n          }\n\n          _this.isReady = true;\n        }, null, this.format, this._extension);\n        proxy._sphericalPolynomial = this._sphericalPolynomial;\n        return;\n    }\n  };\n  /**\n   * @param target\n   * @param swapAll\n   * @hidden\n   */\n\n\n  InternalTexture.prototype._swapAndDie = function (target, swapAll) {\n    // TODO what about refcount on target?\n    var _a;\n\n    if (swapAll === void 0) {\n      swapAll = true;\n    }\n\n    (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);\n    target._hardwareTexture = this._hardwareTexture;\n\n    if (swapAll) {\n      target._isRGBD = this._isRGBD;\n    }\n\n    if (this._lodTextureHigh) {\n      if (target._lodTextureHigh) {\n        target._lodTextureHigh.dispose();\n      }\n\n      target._lodTextureHigh = this._lodTextureHigh;\n    }\n\n    if (this._lodTextureMid) {\n      if (target._lodTextureMid) {\n        target._lodTextureMid.dispose();\n      }\n\n      target._lodTextureMid = this._lodTextureMid;\n    }\n\n    if (this._lodTextureLow) {\n      if (target._lodTextureLow) {\n        target._lodTextureLow.dispose();\n      }\n\n      target._lodTextureLow = this._lodTextureLow;\n    }\n\n    if (this._irradianceTexture) {\n      if (target._irradianceTexture) {\n        target._irradianceTexture.dispose();\n      }\n\n      target._irradianceTexture = this._irradianceTexture;\n    }\n\n    var cache = this._engine.getLoadedTexturesCache();\n\n    var index = cache.indexOf(this);\n\n    if (index !== -1) {\n      cache.splice(index, 1);\n    }\n\n    index = cache.indexOf(target);\n\n    if (index === -1) {\n      cache.push(target);\n    }\n  };\n  /**\n   * Dispose the current allocated resources\n   */\n\n\n  InternalTexture.prototype.dispose = function () {\n    this._references--;\n    this.onLoadedObservable.clear();\n    this.onErrorObservable.clear();\n\n    if (this._references === 0) {\n      this._engine._releaseTexture(this);\n\n      this._hardwareTexture = null;\n    }\n  };\n  /** @hidden */\n\n\n  InternalTexture._Counter = 0;\n  return InternalTexture;\n}(TextureSampler);\n\nexport { InternalTexture };","map":{"version":3,"mappings":";;;;AAAA,SAASA,UAAT,QAA2B,0BAA3B;AAIA,SAASC,cAAT,QAA+B,qBAA/B;AAMA;;;;AAGA,WAAYC,qBAAZ;;AAAA,WAAYA,qBAAZ,EAAiC;AAC7B;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACH,CA7DD,EAAYA,qBAAqB,KAArBA,qBAAqB,MAAjC;AA+DA;;;;;;AAIA;AAAA;AAAA;AAAqCC;AAuMjC;;;;;;;;AAMA,2BAAYC,MAAZ,EAAgCC,MAAhC,EAA+DC,eAA/D,EAAsF;AAAvB;AAAAA;AAAuB;;AAAtF,gBACIC,qBAAO,IADX;AA5MA;;;;;AAGOC,oBAAmB,KAAnB;AACP;;;;AAGOA,mBAAkB,KAAlB;AACP;;;;AAGOA,iBAAgB,KAAhB;AACP;;;;AAGOA,sBAAqB,KAArB;AACP;;;;AAGOA,wBAAuB,KAAvB;AACP;;;;AAGOA,gBAAc,EAAd;AAGP;;;;AAGOA,4BAA2B,KAA3B;AAWP;;;;AAGOA,oBAAkB,CAAlB;AACP;;;;AAGOA,iBAAe,CAAC,CAAhB;AACP;;;;AAGOA,mBAAiB,CAAC,CAAlB;AACP;;;;AAGOA,+BAAqB,IAAIR,UAAJ,EAArB;AACP;;;;AAGOQ,8BAAoB,IAAIR,UAAJ,EAApB;AACP;;;;AAGOQ,8BAMH,IANG;AAOP;;;;AAGOA,kBAAgB,CAAhB;AACP;;;;AAGOA,mBAAiB,CAAjB;AACP;;;;AAGOA,kBAAgB,CAAhB;AACP;;;;AAGOA,sBAAoB,CAApB;AACP;;;;AAGOA,uBAAqB,CAArB;AACP;;;;AAGOA,sBAAoB,CAApB;AACP;;;;AAGOA,oBAAmB,KAAnB,CA2G+E,CAzGtF;;AACA;;AACOA,0BAAgB,KAAhB;AACP;;AACOA,+BAAqB,CAAC,CAAtB;AACP;;AACOA,oBAAUN,qBAAqB,CAACO,OAAhC;AACP;;AACOD,oBAAoG,IAApG;AACP;;AACOA,wBAAyC,IAAzC;AACP;;AACOA,6BAAgD,IAAhD;AACP;;AACOA,kCAAuD,IAAvD;AACP;;AACOA,kBAAgB,CAAhB;AACP;;AACOA,uBAAqB,EAArB;AACP;;AACOA,mBAA6B,IAA7B;AACP;;AACOA,2BAAoC,IAApC;AACP;;AACOA,4BAAqD,IAArD;AACP;;AACOA,mCAA2C,IAA3C;AACP;;AACOA,wBAAuB,KAAvB;AACP;;AACOA,yBAAiC,IAAjC;AACP;;AACOA,iCAAsD,IAAtD;AACP;;AACOA,wCAAsE,IAAtE;AACP;;AACOA,yCAA+B,KAA/B;AACP;;AACOA,gCAA8B,CAA9B;AACP;;AACOA,iCAA+B,CAA/B;AACP;;AACOA,2BAA0B,KAA1B,CA+D+E,CA7DtF;AACA;AACA;;AACA;;AACOA,4BAAyC,IAAzC;AACP;;AACOA,2BAAwC,IAAxC;AACP;;AACOA,2BAAwC,IAAxC;AACP;;AACOA,oBAAmB,KAAnB;AAEP;;AACOA,+BAA8B,KAA9B;AACP;;AACOA,+BAA4C,IAA5C;AAEP;;AACOA,6BAAqD,IAArD;AAEP;;AACOA,yBAAiC,IAAjC;AAEP;;AACOA,wBAAsB,CAAtB;AAEP;;AACOA,wBAAiC,IAAjC;AAqCHA,SAAI,CAACE,OAAL,GAAeN,MAAf;AACAI,SAAI,CAACG,OAAL,GAAeN,MAAf;AACAG,SAAI,CAACI,SAAL,GAAiBC,eAAe,CAACC,QAAhB,EAAjB;;AAEA,QAAI,CAACR,eAAL,EAAsB;AAClBE,WAAI,CAACO,gBAAL,GAAwBX,MAAM,CAACY,sBAAP,EAAxB;AACH;;;AACJ;;AApLDC,wBAAWJ,yBAAX,EAAW,YAAX,EAAqB;AAJrB;;;;SAIA;AACI,aAAO,KAAKK,eAAZ;AACH,KAFoB;SAGrB,aAAsBC,KAAtB,EAAoC;AAChC,WAAKD,eAAL,GAAuBC,KAAvB;AACH,KALoB;qBAAA;;AAAA,GAArB;AAiJAF,wBAAWJ,yBAAX,EAAW,UAAX,EAAmB;AADnB;SACA;AACI,aAAO,KAAKD,SAAZ;AACH,KAFkB;qBAAA;;AAAA,GAAnB;AAIA;;;;;AAIOC,wCAAP;AACI,WAAO,KAAKH,OAAZ;AACH,GAFM;;AAOPO,wBAAWJ,yBAAX,EAAW,QAAX,EAAiB;AAHjB;;;SAGA;AACI,aAAO,KAAKF,OAAZ;AACH,KAFgB;qBAAA;;AAAA,GAAjB;AAsBA;;;;AAGOE,kDAAP;AACI,SAAKO,WAAL;AACH,GAFM;AAIP;;;;;;;;AAMOP,yCAAP,UAAkBQ,KAAlB,EAA8BC,MAA9B,EAA2CC,KAA3C,EAAyD;AAAd;AAAAA;AAAc;;AACrD,SAAKb,OAAL,CAAac,uBAAb,CAAqC,IAArC,EAA2CH,KAA3C,EAAkDC,MAAlD,EAA0DC,KAA1D;;AAEA,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AAEA,SAAKE,SAAL,GAAiBJ,KAAjB;AACA,SAAKK,UAAL,GAAkBJ,MAAlB;AACA,SAAKK,SAAL,GAAiBJ,KAAjB;AAEA,SAAKK,KAAL,GAAaP,KAAK,GAAGC,MAAR,GAAiBC,KAA9B;AACH,GAZM;AAcP;;;AACOV,uCAAP;AAAA;;;;AACI,SAAKgB,OAAL,GAAe,KAAf;AACA,SAAKC,sBAAL,GAA8B,IAA9B;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,gCAAL,GAAwC,IAAxC;;AACA,QAAI,KAAKC,iBAAT,EAA4B;AACxB,UAAMC,MAAI,GAAG,KAAKD,iBAAL,CAAuB,IAAvB,CAAb;;AACA,UAAME,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,oBAAD,EAAsC;AAC5DA,4BAAoB,CAACC,WAArB,CAAiC/B,KAAjC,EAAuC,KAAvC;;AACAA,aAAI,CAACqB,OAAL,GAAeO,MAAI,CAACP,OAApB;AACH,OAHD;;AAIA,UAAIO,MAAI,CAACI,OAAT,EAAkB;AACbJ,cAAI,CAACK,KAAL,CAAwCC,IAAxC,CAA6CL,iBAA7C;AACJ,OAFD,MAEO;AACHA,yBAAiB,CAACD,MAAI,CAACK,KAAN,CAAjB;AACH;;AACD;AACH;;AAED,QAAIA,KAAJ;;AACA,YAAQ,KAAKpC,MAAb;AACI,WAAKH,qBAAqB,CAACyC,IAA3B;AACI;;AAEJ,WAAKzC,qBAAqB,CAAC0C,GAA3B;AACIH,aAAK,GAAG,KAAK/B,OAAL,CAAamC,aAAb,CACJ,WAAKC,YAAL,MAAiB,IAAjB,IAAiBC,aAAjB,GAAiBA,EAAjB,GAAqB,KAAKC,GADtB,EAEJ,CAAC,KAAK9B,eAFF,EAGJ,KAAK+B,OAHD,EAIJ,IAJI,EAKJ,KAAKC,YALD,EAMJ;AACIT,eAAK,CAACF,WAAN,CAAkB/B,KAAlB,EAAwB,KAAxB;;AACAA,eAAI,CAACqB,OAAL,GAAe,IAAf;AACH,SATG,EAUJ,IAVI,EAWJ,KAAKsB,OAXD,EAYJC,SAZI,EAaJ,KAAKC,MAbD,EAcJ,KAAKC,UAdD,EAeJF,SAfI,EAgBJA,SAhBI,EAiBJA,SAjBI,EAkBJ,KAAKG,cAlBD,CAAR;AAoBA;;AAEJ,WAAKrD,qBAAqB,CAACsD,GAA3B;AACIf,aAAK,GAAG,KAAK/B,OAAL,CAAa+C,gBAAb,CACJ,KAAKC,WADD,EAEJ,KAAKjC,SAFD,EAGJ,KAAKC,UAHD,EAIJ,KAAK2B,MAJD,EAKJ,KAAKnC,eALD,EAMJ,KAAK+B,OAND,EAOJ,KAAKC,YAPD,EAQJ,KAAKS,YARD,EASJ,KAAKC,IATD,CAAR;;AAWAnB,aAAK,CAACF,WAAN,CAAkB,IAAlB,EAAwB,KAAxB;;AAEA,aAAKV,OAAL,GAAe,IAAf;AACA;;AAEJ,WAAK3B,qBAAqB,CAAC2D,KAA3B;AACIpB,aAAK,GAAG,KAAK/B,OAAL,CAAaoD,kBAAb,CACJ,KAAKJ,WADD,EAEJ,KAAKjC,SAFD,EAGJ,KAAKC,UAHD,EAIJ,KAAKC,SAJD,EAKJ,KAAK0B,MALD,EAMJ,KAAKnC,eAND,EAOJ,KAAK+B,OAPD,EAQJ,KAAKC,YARD,EASJ,KAAKS,YATD,EAUJ,KAAKC,IAVD,CAAR;;AAYAnB,aAAK,CAACF,WAAN,CAAkB,IAAlB,EAAwB,KAAxB;;AAEA,aAAKV,OAAL,GAAe,IAAf;AACA;;AAEJ,WAAK3B,qBAAqB,CAAC6D,UAA3B;AACItB,aAAK,GAAG,KAAK/B,OAAL,CAAasD,uBAAb,CACJ,KAAKN,WADD,EAEJ,KAAKjC,SAFD,EAGJ,KAAKC,UAHD,EAIJ,KAAKC,SAJD,EAKJ,KAAK0B,MALD,EAMJ,KAAKnC,eAND,EAOJ,KAAK+B,OAPD,EAQJ,KAAKC,YARD,EASJ,KAAKS,YATD,EAUJ,KAAKC,IAVD,CAAR;;AAYAnB,aAAK,CAACF,WAAN,CAAkB,IAAlB,EAAwB,KAAxB;;AAEA,aAAKV,OAAL,GAAe,IAAf;AACA;;AAEJ,WAAK3B,qBAAqB,CAAC+D,OAA3B;AACIxB,aAAK,GAAG,KAAK/B,OAAL,CAAawD,oBAAb,CAAkC,KAAKzC,SAAvC,EAAkD,KAAKC,UAAvD,EAAmE,KAAKR,eAAxE,EAAyF,KAAKgC,YAA9F,CAAR;;AACAT,aAAK,CAACF,WAAN,CAAkB,IAAlB,EAAwB,KAAxB;;AACA,aAAK7B,OAAL,CAAayD,oBAAb,CAAkC,IAAlC,EAAwC,KAAKzD,OAAL,CAAa0D,kBAAb,EAAxC,EAA4E,KAAKnB,OAAjF,EAA0FG,SAA1F,EAAqGA,SAArG,EAAgH,IAAhH,EAHJ,CAKI;;;AACA;;AAEJ,WAAKlD,qBAAqB,CAACmE,IAA3B;AACI5B,aAAK,GAAG,KAAK/B,OAAL,CAAa4D,iBAAb,CACJ,KAAKtB,GADD,EAEJ,IAFI,EAGJ,KAAKuB,MAHD,EAIJ,CAAC,KAAKrD,eAJF,EAKJ;AACIuB,eAAK,CAACF,WAAN,CAAkB/B,KAAlB,EAAwB,KAAxB;;AACAA,eAAI,CAACqB,OAAL,GAAe,IAAf;AACH,SARG,EASJ,IATI,EAUJ,KAAKwB,MAVD,EAWJ,KAAKC,UAXD,EAYJ,KAZI,EAaJ,CAbI,EAcJ,CAdI,EAeJ,IAfI,EAgBJF,SAhBI,EAiBJ,KAAKG,cAjBD,CAAR;AAmBA;;AAEJ,WAAKrD,qBAAqB,CAACsE,OAA3B;AACI/B,aAAK,GAAG,KAAK/B,OAAL,CAAa+D,oBAAb,CACJ,KAAKC,gBADD,EAEJ,KAAKrD,KAFD,EAGJ,KAAKgC,MAHD,EAIJ,KAAKO,IAJD,EAKJ,KAAK1C,eALD,EAMJ,KAAK+B,OAND,EAOJ,KAAKC,YAPD,EAQJ,KAAKS,YARD,CAAR;;AAUAlB,aAAK,CAACF,WAAN,CAAkB,IAAlB,EAAwB,KAAxB;;AACA,aAAKV,OAAL,GAAe,IAAf;AACA;;AAEJ,WAAK3B,qBAAqB,CAACyE,WAA3B;AACI;AACA;AACA;;AAEJ,WAAKzE,qBAAqB,CAAC0E,eAA3B;AACInC,aAAK,GAAG,KAAK/B,OAAL,CAAamE,4BAAb,CACJ,KAAK7B,GADD,EAEJ,IAFI,EAGJ,KAAK8B,mBAHD,EAIJ,KAAKC,oBAJD,EAKJ,UAACtC,KAAD,EAAM;AACF,cAAIA,KAAJ,EAAW;AACPA,iBAAK,CAACF,WAAN,CAAkB/B,KAAlB,EAAwB,KAAxB;AACH;;AACDA,eAAI,CAACqB,OAAL,GAAe,IAAf;AACH,SAVG,EAWJ,IAXI,EAYJ,KAAKwB,MAZD,EAaJ,KAAKC,UAbD,CAAR;AAeAb,aAAK,CAACuC,oBAAN,GAA6B,KAAKA,oBAAlC;AACA;AAnJR;AAqJH,GA3KM;AA6KP;;;;;;;AAKOnE,0CAAP,UAAmBoE,MAAnB,EAA4CC,OAA5C,EAA0D;AACtD;;;AADwC;AAAAA;AAAc;;AAGtD,eAAKnE,gBAAL,MAAqB,IAArB,IAAqBgC,aAArB,GAAqB,MAArB,GAAqBA,GAAEoC,QAAF,CAAWF,MAAM,CAACtE,OAAlB,EAA2B,KAAKO,eAAhC,EAAiD,KAAKkE,MAAtD,EAA8D,KAAK/D,KAAnE,EAA0E,KAAKC,MAA/E,CAArB;AAEA2D,UAAM,CAAClE,gBAAP,GAA0B,KAAKA,gBAA/B;;AACA,QAAImE,OAAJ,EAAa;AACTD,YAAM,CAACI,OAAP,GAAiB,KAAKA,OAAtB;AACH;;AAED,QAAI,KAAKC,eAAT,EAA0B;AACtB,UAAIL,MAAM,CAACK,eAAX,EAA4B;AACxBL,cAAM,CAACK,eAAP,CAAuBC,OAAvB;AACH;;AACDN,YAAM,CAACK,eAAP,GAAyB,KAAKA,eAA9B;AACH;;AAED,QAAI,KAAKE,cAAT,EAAyB;AACrB,UAAIP,MAAM,CAACO,cAAX,EAA2B;AACvBP,cAAM,CAACO,cAAP,CAAsBD,OAAtB;AACH;;AACDN,YAAM,CAACO,cAAP,GAAwB,KAAKA,cAA7B;AACH;;AAED,QAAI,KAAKC,cAAT,EAAyB;AACrB,UAAIR,MAAM,CAACQ,cAAX,EAA2B;AACvBR,cAAM,CAACQ,cAAP,CAAsBF,OAAtB;AACH;;AACDN,YAAM,CAACQ,cAAP,GAAwB,KAAKA,cAA7B;AACH;;AAED,QAAI,KAAKC,kBAAT,EAA6B;AACzB,UAAIT,MAAM,CAACS,kBAAX,EAA+B;AAC3BT,cAAM,CAACS,kBAAP,CAA0BH,OAA1B;AACH;;AACDN,YAAM,CAACS,kBAAP,GAA4B,KAAKA,kBAAjC;AACH;;AAED,QAAMC,KAAK,GAAG,KAAKjF,OAAL,CAAakF,sBAAb,EAAd;;AACA,QAAIC,KAAK,GAAGF,KAAK,CAACG,OAAN,CAAc,IAAd,CAAZ;;AACA,QAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;AACdF,WAAK,CAACI,MAAN,CAAaF,KAAb,EAAoB,CAApB;AACH;;AAEDA,SAAK,GAAGF,KAAK,CAACG,OAAN,CAAcb,MAAd,CAAR;;AACA,QAAIY,KAAK,KAAK,CAAC,CAAf,EAAkB;AACdF,WAAK,CAACK,IAAN,CAAWf,MAAX;AACH;AACJ,GAhDM;AAkDP;;;;;AAGOpE,sCAAP;AACI,SAAKO,WAAL;AACA,SAAK6E,kBAAL,CAAwBC,KAAxB;AACA,SAAKC,iBAAL,CAAuBD,KAAvB;;AACA,QAAI,KAAK9E,WAAL,KAAqB,CAAzB,EAA4B;AACxB,WAAKV,OAAL,CAAa0F,eAAb,CAA6B,IAA7B;;AACA,WAAKrF,gBAAL,GAAwB,IAAxB;AACH;AACJ,GARM;AA5SP;;;AACcF,6BAAW,CAAX;AAoTlB;AAAC,CAreD,CAAqCZ,cAArC;;SAAaY","names":["Observable","TextureSampler","InternalTextureSource","__extends","engine","source","delayAllocation","_super","_this","Unknown","_engine","_source","_uniqueId","InternalTexture","_Counter","_hardwareTexture","_createHardwareTexture","Object","generateMipMaps","value","_references","width","height","depth","updateTextureDimensions","baseWidth","baseHeight","baseDepth","_size","isReady","_cachedCoordinatesMode","_cachedWrapU","_cachedWrapV","_cachedWrapR","_cachedAnisotropicFilteringLevel","onRebuildCallback","data_1","swapAndSetIsReady","proxyInternalTexture","_swapAndDie","isAsync","proxy","then","Temp","Url","createTexture","_originalUrl","_a","url","invertY","samplingMode","_buffer","undefined","format","_extension","_useSRGBBuffer","Raw","createRawTexture","_bufferView","_compression","type","Raw3D","createRawTexture3D","Raw2DArray","createRawTexture2DArray","Dynamic","createDynamicTexture","updateDynamicTexture","getRenderingCanvas","Cube","createCubeTexture","_files","CubeRaw","createRawCubeTexture","_bufferViewArray","CubeRawRGBD","CubePrefiltered","createPrefilteredCubeTexture","_lodGenerationScale","_lodGenerationOffset","_sphericalPolynomial","target","swapAll","setUsage","isCube","_isRGBD","_lodTextureHigh","dispose","_lodTextureMid","_lodTextureLow","_irradianceTexture","cache","getLoadedTexturesCache","index","indexOf","splice","push","onLoadedObservable","clear","onErrorObservable","_releaseTexture"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/internalTexture.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable, int } from \"../../types\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"./hardwareTextureWrapper\";\r\nimport { TextureSampler } from \"./textureSampler\";\r\n\r\ndeclare type ThinEngine = import(\"../../Engines/thinEngine\").ThinEngine;\r\ndeclare type BaseTexture = import(\"../../Materials/Textures/baseTexture\").BaseTexture;\r\ndeclare type SphericalPolynomial = import(\"../../Maths/sphericalPolynomial\").SphericalPolynomial;\r\n\r\n/**\r\n * Defines the source of the internal texture\r\n */\r\nexport enum InternalTextureSource {\r\n    /**\r\n     * The source of the texture data is unknown\r\n     */\r\n    Unknown,\r\n    /**\r\n     * Texture data comes from an URL\r\n     */\r\n    Url,\r\n    /**\r\n     * Texture data is only used for temporary storage\r\n     */\r\n    Temp,\r\n    /**\r\n     * Texture data comes from raw data (ArrayBuffer)\r\n     */\r\n    Raw,\r\n    /**\r\n     * Texture content is dynamic (video or dynamic texture)\r\n     */\r\n    Dynamic,\r\n    /**\r\n     * Texture content is generated by rendering to it\r\n     */\r\n    RenderTarget,\r\n    /**\r\n     * Texture content is part of a multi render target process\r\n     */\r\n    MultiRenderTarget,\r\n    /**\r\n     * Texture data comes from a cube data file\r\n     */\r\n    Cube,\r\n    /**\r\n     * Texture data comes from a raw cube data\r\n     */\r\n    CubeRaw,\r\n    /**\r\n     * Texture data come from a prefiltered cube data file\r\n     */\r\n    CubePrefiltered,\r\n    /**\r\n     * Texture content is raw 3D data\r\n     */\r\n    Raw3D,\r\n    /**\r\n     * Texture content is raw 2D array data\r\n     */\r\n    Raw2DArray,\r\n    /**\r\n     * Texture content is a depth/stencil texture\r\n     */\r\n    DepthStencil,\r\n    /**\r\n     * Texture data comes from a raw cube data encoded with RGBD\r\n     */\r\n    CubeRawRGBD,\r\n    /**\r\n     * Texture content is a depth texture\r\n     */\r\n    Depth,\r\n}\r\n\r\n/**\r\n * Class used to store data associated with WebGL texture data for the engine\r\n * This class should not be used directly\r\n */\r\nexport class InternalTexture extends TextureSampler {\r\n    /**\r\n     * Defines if the texture is ready\r\n     */\r\n    public isReady: boolean = false;\r\n    /**\r\n     * Defines if the texture is a cube texture\r\n     */\r\n    public isCube: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 3D data\r\n     */\r\n    public is3D: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 2D array data\r\n     */\r\n    public is2DArray: boolean = false;\r\n    /**\r\n     * Defines if the texture contains multiview data\r\n     */\r\n    public isMultiview: boolean = false;\r\n    /**\r\n     * Gets the URL used to load this texture\r\n     */\r\n    public url: string = \"\";\r\n    /** @hidden */\r\n    public _originalUrl: string; // not empty only if different from url\r\n    /**\r\n     * Gets a boolean indicating if the texture needs mipmaps generation\r\n     */\r\n    public generateMipMaps: boolean = false;\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\r\n     */\r\n    public get useMipMaps() {\r\n        return this.generateMipMaps;\r\n    }\r\n    public set useMipMaps(value: boolean) {\r\n        this.generateMipMaps = value;\r\n    }\r\n    /**\r\n     * Gets the number of samples used by the texture (WebGL2+ only)\r\n     */\r\n    public samples: number = 0;\r\n    /**\r\n     * Gets the type of the texture (int, float...)\r\n     */\r\n    public type: number = -1;\r\n    /**\r\n     * Gets the format of the texture (RGB, RGBA...)\r\n     */\r\n    public format: number = -1;\r\n    /**\r\n     * Observable called when the texture is loaded\r\n     */\r\n    public onLoadedObservable = new Observable<InternalTexture>();\r\n    /**\r\n     * Observable called when the texture load is raising an error\r\n     */\r\n    public onErrorObservable = new Observable<Partial<{ message: string; exception: any }>>();\r\n    /**\r\n     * If this callback is defined it will be called instead of the default _rebuild function\r\n     */\r\n    public onRebuildCallback: Nullable<\r\n        (internalTexture: InternalTexture) => {\r\n            proxy: Nullable<InternalTexture | Promise<InternalTexture>>;\r\n            isReady: boolean;\r\n            isAsync: boolean;\r\n        }\r\n    > = null;\r\n    /**\r\n     * Gets the width of the texture\r\n     */\r\n    public width: number = 0;\r\n    /**\r\n     * Gets the height of the texture\r\n     */\r\n    public height: number = 0;\r\n    /**\r\n     * Gets the depth of the texture\r\n     */\r\n    public depth: number = 0;\r\n    /**\r\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseWidth: number = 0;\r\n    /**\r\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseHeight: number = 0;\r\n    /**\r\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseDepth: number = 0;\r\n    /**\r\n     * Gets a boolean indicating if the texture is inverted on Y axis\r\n     */\r\n    public invertY: boolean = false;\r\n\r\n    // Private\r\n    /** @hidden */\r\n    public _invertVScale = false;\r\n    /** @hidden */\r\n    public _associatedChannel = -1;\r\n    /** @hidden */\r\n    public _source = InternalTextureSource.Unknown;\r\n    /** @hidden */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    /** @hidden */\r\n    public _bufferView: Nullable<ArrayBufferView> = null;\r\n    /** @hidden */\r\n    public _bufferViewArray: Nullable<ArrayBufferView[]> = null;\r\n    /** @hidden */\r\n    public _bufferViewArrayArray: Nullable<ArrayBufferView[][]> = null;\r\n    /** @hidden */\r\n    public _size: number = 0;\r\n    /** @hidden */\r\n    public _extension: string = \"\";\r\n    /** @hidden */\r\n    public _files: Nullable<string[]> = null;\r\n    /** @hidden */\r\n    public _workingCanvas: Nullable<ICanvas> = null;\r\n    /** @hidden */\r\n    public _workingContext: Nullable<ICanvasRenderingContext> = null;\r\n    /** @hidden */\r\n    public _cachedCoordinatesMode: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _isDisabled: boolean = false;\r\n    /** @hidden */\r\n    public _compression: Nullable<string> = null;\r\n    /** @hidden */\r\n    public _sphericalPolynomial: Nullable<SphericalPolynomial> = null;\r\n    /** @hidden */\r\n    public _sphericalPolynomialPromise: Nullable<Promise<SphericalPolynomial>> = null;\r\n    /** @hidden */\r\n    public _sphericalPolynomialComputed = false;\r\n    /** @hidden */\r\n    public _lodGenerationScale: number = 0;\r\n    /** @hidden */\r\n    public _lodGenerationOffset: number = 0;\r\n    /** @hidden */\r\n    public _useSRGBBuffer: boolean = false;\r\n\r\n    // The following three fields helps sharing generated fixed LODs for texture filtering\r\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\r\n    // They are at the level of the gl texture to benefit from the cache.\r\n    /** @hidden */\r\n    public _lodTextureHigh: Nullable<BaseTexture> = null;\r\n    /** @hidden */\r\n    public _lodTextureMid: Nullable<BaseTexture> = null;\r\n    /** @hidden */\r\n    public _lodTextureLow: Nullable<BaseTexture> = null;\r\n    /** @hidden */\r\n    public _isRGBD: boolean = false;\r\n\r\n    /** @hidden */\r\n    public _linearSpecularLOD: boolean = false;\r\n    /** @hidden */\r\n    public _irradianceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @hidden */\r\n    public _hardwareTexture: Nullable<HardwareTextureWrapper> = null;\r\n\r\n    /** @hidden */\r\n    public _maxLodLevel: Nullable<number> = null;\r\n\r\n    /** @hidden */\r\n    public _references: number = 1;\r\n\r\n    /** @hidden */\r\n    public _gammaSpace: Nullable<boolean> = null;\r\n\r\n    private _engine: ThinEngine;\r\n    private _uniqueId: number;\r\n\r\n    /** @hidden */\r\n    public static _Counter = 0;\r\n\r\n    /** Gets the unique id of the internal texture */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the Engine the texture belongs to.\r\n     * @returns The babylon engine\r\n     */\r\n    public getEngine(): ThinEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the data source type of the texture\r\n     */\r\n    public get source(): InternalTextureSource {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InternalTexture\r\n     * @param engine defines the engine to use\r\n     * @param source defines the type of data that will be used\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(engine: ThinEngine, source: InternalTextureSource, delayAllocation = false) {\r\n        super();\r\n\r\n        this._engine = engine;\r\n        this._source = source;\r\n        this._uniqueId = InternalTexture._Counter++;\r\n\r\n        if (!delayAllocation) {\r\n            this._hardwareTexture = engine._createHardwareTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments the number of references (ie. the number of Texture that point to it)\r\n     */\r\n    public incrementReferences(): void {\r\n        this._references++;\r\n    }\r\n\r\n    /**\r\n     * Change the size of the texture (not the size of the content)\r\n     * @param width defines the new width\r\n     * @param height defines the new height\r\n     * @param depth defines the new depth (1 by default)\r\n     */\r\n    public updateSize(width: int, height: int, depth: int = 1): void {\r\n        this._engine.updateTextureDimensions(this, width, height, depth);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        this.baseWidth = width;\r\n        this.baseHeight = height;\r\n        this.baseDepth = depth;\r\n\r\n        this._size = width * height * depth;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.isReady = false;\r\n        this._cachedCoordinatesMode = null;\r\n        this._cachedWrapU = null;\r\n        this._cachedWrapV = null;\r\n        this._cachedWrapR = null;\r\n        this._cachedAnisotropicFilteringLevel = null;\r\n        if (this.onRebuildCallback) {\r\n            const data = this.onRebuildCallback(this);\r\n            const swapAndSetIsReady = (proxyInternalTexture: InternalTexture) => {\r\n                proxyInternalTexture._swapAndDie(this, false);\r\n                this.isReady = data.isReady;\r\n            };\r\n            if (data.isAsync) {\r\n                (data.proxy as Promise<InternalTexture>).then(swapAndSetIsReady);\r\n            } else {\r\n                swapAndSetIsReady(data.proxy as InternalTexture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let proxy: InternalTexture;\r\n        switch (this.source) {\r\n            case InternalTextureSource.Temp:\r\n                break;\r\n\r\n            case InternalTextureSource.Url:\r\n                proxy = this._engine.createTexture(\r\n                    this._originalUrl ?? this.url,\r\n                    !this.generateMipMaps,\r\n                    this.invertY,\r\n                    null,\r\n                    this.samplingMode,\r\n                    () => {\r\n                        proxy._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this._buffer,\r\n                    undefined,\r\n                    this.format,\r\n                    this._extension,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.Raw:\r\n                proxy = this._engine.createRawTexture(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw3D:\r\n                proxy = this._engine.createRawTexture3D(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw2DArray:\r\n                proxy = this._engine.createRawTexture2DArray(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Dynamic:\r\n                proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\r\n                proxy._swapAndDie(this, false);\r\n                this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas()!, this.invertY, undefined, undefined, true);\r\n\r\n                // The engine will make sure to update content so no need to flag it as isReady = true\r\n                break;\r\n\r\n            case InternalTextureSource.Cube:\r\n                proxy = this._engine.createCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._files,\r\n                    !this.generateMipMaps,\r\n                    () => {\r\n                        proxy._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension,\r\n                    false,\r\n                    0,\r\n                    0,\r\n                    null,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.CubeRaw:\r\n                proxy = this._engine.createRawCubeTexture(\r\n                    this._bufferViewArray!,\r\n                    this.width,\r\n                    this.format,\r\n                    this.type,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.CubeRawRGBD:\r\n                // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\r\n                // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\r\n                return;\r\n\r\n            case InternalTextureSource.CubePrefiltered:\r\n                proxy = this._engine.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._lodGenerationScale,\r\n                    this._lodGenerationOffset,\r\n                    (proxy) => {\r\n                        if (proxy) {\r\n                            proxy._swapAndDie(this, false);\r\n                        }\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension\r\n                );\r\n                proxy._sphericalPolynomial = this._sphericalPolynomial;\r\n                return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param target\r\n     * @param swapAll\r\n     * @hidden\r\n     */\r\n    public _swapAndDie(target: InternalTexture, swapAll = true): void {\r\n        // TODO what about refcount on target?\r\n\r\n        this._hardwareTexture?.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);\r\n\r\n        target._hardwareTexture = this._hardwareTexture;\r\n        if (swapAll) {\r\n            target._isRGBD = this._isRGBD;\r\n        }\r\n\r\n        if (this._lodTextureHigh) {\r\n            if (target._lodTextureHigh) {\r\n                target._lodTextureHigh.dispose();\r\n            }\r\n            target._lodTextureHigh = this._lodTextureHigh;\r\n        }\r\n\r\n        if (this._lodTextureMid) {\r\n            if (target._lodTextureMid) {\r\n                target._lodTextureMid.dispose();\r\n            }\r\n            target._lodTextureMid = this._lodTextureMid;\r\n        }\r\n\r\n        if (this._lodTextureLow) {\r\n            if (target._lodTextureLow) {\r\n                target._lodTextureLow.dispose();\r\n            }\r\n            target._lodTextureLow = this._lodTextureLow;\r\n        }\r\n\r\n        if (this._irradianceTexture) {\r\n            if (target._irradianceTexture) {\r\n                target._irradianceTexture.dispose();\r\n            }\r\n            target._irradianceTexture = this._irradianceTexture;\r\n        }\r\n\r\n        const cache = this._engine.getLoadedTexturesCache();\r\n        let index = cache.indexOf(this);\r\n        if (index !== -1) {\r\n            cache.splice(index, 1);\r\n        }\r\n\r\n        index = cache.indexOf(target);\r\n        if (index === -1) {\r\n            cache.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the current allocated resources\r\n     */\r\n    public dispose(): void {\r\n        this._references--;\r\n        this.onLoadedObservable.clear();\r\n        this.onErrorObservable.clear();\r\n        if (this._references === 0) {\r\n            this._engine._releaseTexture(this);\r\n            this._hardwareTexture = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}