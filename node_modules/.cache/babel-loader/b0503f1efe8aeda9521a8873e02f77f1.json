{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\n\nvar intersectBoxAASphere = function intersectBoxAASphere(boxMin, boxMax, sphereCenter, sphereRadius) {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n\n  return true;\n};\n\nvar getLowestRoot = function () {\n  var result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    var determinant = b * b - 4.0 * a * c;\n\n    if (determinant < 0) {\n      return result;\n    }\n\n    var sqrtD = Math.sqrt(determinant);\n    var r1 = (-b - sqrtD) / (2.0 * a);\n    var r2 = (-b + sqrtD) / (2.0 * a);\n\n    if (r1 > r2) {\n      var temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n\n    return result;\n  };\n}();\n/** @hidden */\n\n\nvar Collider =\n/** @class */\nfunction () {\n  function Collider() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @hidden */\n\n    this._radius = Vector3.One();\n    /** @hidden */\n\n    this._retry = 0;\n    /** @hidden */\n\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n\n  Object.defineProperty(Collider.prototype, \"collisionMask\", {\n    get: function get() {\n      return this._collisionMask;\n    },\n    set: function set(mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Collider.prototype, \"slidePlaneNormal\", {\n    /**\n     * Gets the plane normal used to compute the sliding response (in local space)\n     */\n    get: function get() {\n      return this._slidePlaneNormal;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\n   * @param source\n   * @param dir\n   * @param e\n   * @hidden\n   */\n\n  Collider.prototype._initialize = function (source, dir, e) {\n    this._velocity = dir;\n    this._velocitySquaredLength = this._velocity.lengthSquared();\n    var len = Math.sqrt(this._velocitySquaredLength);\n\n    if (len === 0 || len === 1.0) {\n      this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\n    } else {\n      dir.scaleToRef(1.0 / len, this._normalizedVelocity);\n    }\n\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  };\n  /**\n   * @param point\n   * @param pa\n   * @param pb\n   * @param pc\n   * @param n\n   * @hidden\n   */\n\n\n  Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    var d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  };\n  /**\n   * @param sphereCenter\n   * @param sphereRadius\n   * @param vecMin\n   * @param vecMax\n   * @hidden\n   */\n\n\n  Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {\n    var distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    var max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * @param faceIndex\n   * @param trianglePlaneArray\n   * @param p1\n   * @param p2\n   * @param p3\n   * @param hasMaterial\n   * @param hostMesh\n   * @hidden\n   */\n\n\n  Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    var t0;\n    var embeddedInPlane = false; //defensive programming, actually not needed.\n\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n\n    var trianglePlane = trianglePlaneArray[faceIndex];\n\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n\n    var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity); // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\n    // if true, it discard the faces having normal not facing velocity\n\n    if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\n      return;\n    }\n\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n\n      if (t0 > t1) {\n        var temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n\n      if (t0 < 0) {\n        t0 = 0;\n      }\n\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n\n    var found = false;\n    var t = 1.0;\n\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n\n      this._velocity.scaleToRef(t0, this._tempVector);\n\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n\n    if (!found) {\n      var a = this._velocitySquaredLength;\n\n      this._basePoint.subtractToRef(p1, this._tempVector);\n\n      var b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      var c = this._tempVector.lengthSquared() - 1.0;\n      var lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p1);\n      }\n\n      this._basePoint.subtractToRef(p2, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p2);\n      }\n\n      this._basePoint.subtractToRef(p3, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p3);\n      }\n\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n\n      var edgeSquaredLength = this._edge.lengthSquared();\n\n      var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n\n    if (found) {\n      var distToCollisionSquared = t * t * this._velocitySquaredLength;\n\n      if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n\n          this._nearestDistanceSquared = distToCollisionSquared;\n          this._nearestDistance = Math.sqrt(distToCollisionSquared);\n          this.collisionFound = true;\n        }\n\n        this.collidedMesh = hostMesh;\n      }\n    }\n  };\n  /**\n   * @param trianglePlaneArray\n   * @param pts\n   * @param indices\n   * @param indexStart\n   * @param indexEnd\n   * @param decal\n   * @param hasMaterial\n   * @param hostMesh\n   * @param invertTriangles\n   * @param triangleStrip\n   * @hidden\n   */\n\n\n  Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip) {\n    if (triangleStrip === void 0) {\n      triangleStrip = false;\n    }\n\n    if (triangleStrip) {\n      if (!indices || indices.length === 0) {\n        for (var i = 0; i < pts.length - 2; i += 1) {\n          var p1 = pts[i];\n          var p2 = pts[i + 1];\n          var p3 = pts[i + 2]; // stay defensive and don't check against undefined positions.\n\n          if (!p1 || !p2 || !p3) {\n            continue;\n          } // Handles strip faces one on two is reversed\n\n\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      } else {\n        for (var i = indexStart; i < indexEnd - 2; i += 1) {\n          var indexA = indices[i];\n          var indexB = indices[i + 1];\n          var indexC = indices[i + 2];\n\n          if (indexC === 0xffffffff) {\n            i += 2;\n            continue;\n          }\n\n          var p1 = pts[indexA];\n          var p2 = pts[indexB];\n          var p3 = pts[indexC]; // stay defensive and don't check against undefined positions.\n\n          if (!p1 || !p2 || !p3) {\n            continue;\n          } // Handles strip faces one on two is reversed\n\n\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      }\n    } else if (!indices || indices.length === 0) {\n      for (var i = 0; i < pts.length; i += 3) {\n        var p1 = pts[i];\n        var p2 = pts[i + 1];\n        var p3 = pts[i + 2];\n\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    } else {\n      for (var i = indexStart; i < indexEnd; i += 3) {\n        var p1 = pts[indices[i] - decal];\n        var p2 = pts[indices[i + 1] - decal];\n        var p3 = pts[indices[i + 2] - decal];\n\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    }\n  };\n  /**\n   * @param pos\n   * @param vel\n   * @hidden\n   */\n\n\n  Collider.prototype._getResponse = function (pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n\n    this._basePoint.addToRef(vel, pos);\n\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n\n    this._slidePlaneNormal.normalize();\n\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  };\n  /**\n   * If true, it check for double sided faces and only returns 1 collision instead of 2\n   */\n\n\n  Collider.DoubleSidedCheck = false;\n  return Collider;\n}();\n\nexport { Collider };","map":{"version":3,"mappings":"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","names":["Vector3","Plane","intersectBoxAASphere","boxMin","boxMax","sphereCenter","sphereRadius","x","y","z","getLowestRoot","result","root","found","a","b","c","maxR","determinant","sqrtD","Math","sqrt","r1","r2","temp","Zero","One","Object","Collider","_collisionMask","mask","isNaN","_slidePlaneNormal","source","dir","e","_velocity","_velocitySquaredLength","lengthSquared","len","_normalizedVelocity","copyFromFloats","_x","_y","_z","scaleToRef","_basePoint","multiplyToRef","_radius","_basePointWorld","_velocityWorld","_velocityWorldLength","length","_epsilon","collisionFound","point","pa","pb","pc","n","subtractToRef","_tempVector","_tempVector2","CrossToRef","_tempVector4","d","Dot","_tempVector3","vecMin","vecMax","distance","Distance","max","faceIndex","trianglePlaneArray","p1","p2","p3","hasMaterial","hostMesh","t0","embeddedInPlane","copyFromPoints","trianglePlane","isFrontFacingTo","signedDistToTrianglePlane","signedDistanceTo","normalDotVelocity","normal","DoubleSidedCheck","abs","t1","_collisionPoint","t","_planeIntersectionPoint","addInPlace","_checkPointInTriangle","copyFrom","lowestRoot","_edge","_baseToVertex","edgeSquaredLength","edgeDotVelocity","edgeDotBaseToVertex","f","scaleInPlace","addToRef","distToCollisionSquared","_nearestDistanceSquared","collisionResponse","intersectionPoint","clone","_nearestDistance","collidedMesh","pts","indices","indexStart","indexEnd","decal","invertTriangles","triangleStrip","i","_testTriangle","indexA","indexB","indexC","pos","vel","_destinationPoint","normalize","_displacementVector","SignedDistanceToPlaneFromPositionAndNormal","subtractInPlace"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Collisions/collider.ts"],"sourcesContent":["import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\nconst intersectBoxAASphere = (boxMin: Vector3, boxMax: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean => {\r\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst getLowestRoot: (a: number, b: number, c: number, maxR: number) => { root: number; found: boolean } = (function () {\r\n    const result = { root: 0, found: false };\r\n    return function (a: number, b: number, c: number, maxR: number) {\r\n        result.root = 0;\r\n        result.found = false;\r\n        const determinant = b * b - 4.0 * a * c;\r\n        if (determinant < 0) {\r\n            return result;\r\n        }\r\n\r\n        const sqrtD = Math.sqrt(determinant);\r\n        let r1 = (-b - sqrtD) / (2.0 * a);\r\n        let r2 = (-b + sqrtD) / (2.0 * a);\r\n\r\n        if (r1 > r2) {\r\n            const temp = r2;\r\n            r2 = r1;\r\n            r1 = temp;\r\n        }\r\n\r\n        if (r1 > 0 && r1 < maxR) {\r\n            result.root = r1;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        if (r2 > 0 && r2 < maxR) {\r\n            result.root = r2;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    };\r\n})();\r\n\r\n/** @hidden */\r\nexport class Collider {\r\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\r\n    // https://www.peroxide.dk/papers/collision/collision.pdf\r\n\r\n    /** Define if a collision was found */\r\n    public collisionFound: boolean;\r\n\r\n    /**\r\n     * Define last intersection point in local space\r\n     */\r\n    public intersectionPoint: Vector3;\r\n\r\n    /**\r\n     * Define last collided mesh\r\n     */\r\n    public collidedMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * If true, it check for double sided faces and only returns 1 collision instead of 2\r\n     */\r\n    public static DoubleSidedCheck = false;\r\n\r\n    private _collisionPoint = Vector3.Zero();\r\n    private _planeIntersectionPoint = Vector3.Zero();\r\n    private _tempVector = Vector3.Zero();\r\n    private _tempVector2 = Vector3.Zero();\r\n    private _tempVector3 = Vector3.Zero();\r\n    private _tempVector4 = Vector3.Zero();\r\n    private _edge = Vector3.Zero();\r\n    private _baseToVertex = Vector3.Zero();\r\n    private _destinationPoint = Vector3.Zero();\r\n    private _slidePlaneNormal = Vector3.Zero();\r\n    private _displacementVector = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _radius = Vector3.One();\r\n    /** @hidden */\r\n    public _retry = 0;\r\n    private _velocity: Vector3;\r\n    private _basePoint: Vector3;\r\n    private _epsilon: number;\r\n    /** @hidden */\r\n    public _velocityWorldLength: number;\r\n    /** @hidden */\r\n    public _basePointWorld = Vector3.Zero();\r\n    private _velocityWorld = Vector3.Zero();\r\n    private _normalizedVelocity = Vector3.Zero();\r\n    /** @hidden */\r\n    public _initialVelocity: Vector3;\r\n    /** @hidden */\r\n    public _initialPosition: Vector3;\r\n    private _nearestDistance: number;\r\n\r\n    private _collisionMask = -1;\r\n    private _velocitySquaredLength: number;\r\n    private _nearestDistanceSquared: number;\r\n\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\r\n    public get slidePlaneNormal(): Vector3 {\r\n        return this._slidePlaneNormal;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @param source\r\n     * @param dir\r\n     * @param e\r\n     * @hidden\r\n     */\r\n    public _initialize(source: Vector3, dir: Vector3, e: number): void {\r\n        this._velocity = dir;\r\n        this._velocitySquaredLength = this._velocity.lengthSquared();\r\n        const len = Math.sqrt(this._velocitySquaredLength);\r\n        if (len === 0 || len === 1.0) {\r\n            this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\r\n        } else {\r\n            dir.scaleToRef(1.0 / len, this._normalizedVelocity);\r\n        }\r\n        this._basePoint = source;\r\n\r\n        source.multiplyToRef(this._radius, this._basePointWorld);\r\n        dir.multiplyToRef(this._radius, this._velocityWorld);\r\n\r\n        this._velocityWorldLength = this._velocityWorld.length();\r\n\r\n        this._epsilon = e;\r\n        this.collisionFound = false;\r\n    }\r\n\r\n    /**\r\n     * @param point\r\n     * @param pa\r\n     * @param pb\r\n     * @param pc\r\n     * @param n\r\n     * @hidden\r\n     */\r\n    public _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean {\r\n        pa.subtractToRef(point, this._tempVector);\r\n        pb.subtractToRef(point, this._tempVector2);\r\n\r\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\r\n        let d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        pc.subtractToRef(point, this._tempVector3);\r\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        return d >= 0;\r\n    }\r\n\r\n    /**\r\n     * @param sphereCenter\r\n     * @param sphereRadius\r\n     * @param vecMin\r\n     * @param vecMax\r\n     * @hidden\r\n     */\r\n    public _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean {\r\n        const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\r\n\r\n        const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\r\n\r\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\r\n            return false;\r\n        }\r\n\r\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param faceIndex\r\n     * @param trianglePlaneArray\r\n     * @param p1\r\n     * @param p2\r\n     * @param p3\r\n     * @param hasMaterial\r\n     * @param hostMesh\r\n     * @hidden\r\n     */\r\n    public _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        let t0;\r\n        let embeddedInPlane = false;\r\n\r\n        //defensive programming, actually not needed.\r\n        if (!trianglePlaneArray) {\r\n            trianglePlaneArray = [];\r\n        }\r\n\r\n        if (!trianglePlaneArray[faceIndex]) {\r\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\r\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\r\n        }\r\n\r\n        const trianglePlane = trianglePlaneArray[faceIndex];\r\n\r\n        if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\r\n            return;\r\n        }\r\n\r\n        const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\r\n        const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\r\n\r\n        // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\r\n        // if true, it discard the faces having normal not facing velocity\r\n        if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\r\n            return;\r\n        }\r\n\r\n        if (normalDotVelocity == 0) {\r\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\r\n                return;\r\n            }\r\n            embeddedInPlane = true;\r\n            t0 = 0;\r\n        } else {\r\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n            let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n\r\n            if (t0 > t1) {\r\n                const temp = t1;\r\n                t1 = t0;\r\n                t0 = temp;\r\n            }\r\n\r\n            if (t0 > 1.0 || t1 < 0.0) {\r\n                return;\r\n            }\r\n\r\n            if (t0 < 0) {\r\n                t0 = 0;\r\n            }\r\n            if (t0 > 1.0) {\r\n                t0 = 1.0;\r\n            }\r\n        }\r\n\r\n        this._collisionPoint.copyFromFloats(0, 0, 0);\r\n\r\n        let found = false;\r\n        let t = 1.0;\r\n\r\n        if (!embeddedInPlane) {\r\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\r\n            this._velocity.scaleToRef(t0, this._tempVector);\r\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\r\n\r\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\r\n                found = true;\r\n                t = t0;\r\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            let a = this._velocitySquaredLength;\r\n\r\n            this._basePoint.subtractToRef(p1, this._tempVector);\r\n            let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            let c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            let lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p1);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p2, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p2);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p3, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p3);\r\n            }\r\n\r\n            p2.subtractToRef(p1, this._edge);\r\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\r\n            let edgeSquaredLength = this._edge.lengthSquared();\r\n            let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p1.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p3.subtractToRef(p2, this._edge);\r\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p2.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p1.subtractToRef(p3, this._edge);\r\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p3.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            const distToCollisionSquared = t * t * this._velocitySquaredLength;\r\n\r\n            if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\r\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\r\n                // onCollide observable are triggered if collideMesh is set\r\n                // this allow trigger volumes to be created.\r\n                if (hostMesh.collisionResponse) {\r\n                    if (!this.intersectionPoint) {\r\n                        this.intersectionPoint = this._collisionPoint.clone();\r\n                    } else {\r\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\r\n                    }\r\n                    this._nearestDistanceSquared = distToCollisionSquared;\r\n                    this._nearestDistance = Math.sqrt(distToCollisionSquared);\r\n                    this.collisionFound = true;\r\n                }\r\n                this.collidedMesh = hostMesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param trianglePlaneArray\r\n     * @param pts\r\n     * @param indices\r\n     * @param indexStart\r\n     * @param indexEnd\r\n     * @param decal\r\n     * @param hasMaterial\r\n     * @param hostMesh\r\n     * @param invertTriangles\r\n     * @param triangleStrip\r\n     * @hidden\r\n     */\r\n    public _collide(\r\n        trianglePlaneArray: Array<Plane>,\r\n        pts: Vector3[],\r\n        indices: IndicesArray,\r\n        indexStart: number,\r\n        indexEnd: number,\r\n        decal: number,\r\n        hasMaterial: boolean,\r\n        hostMesh: AbstractMesh,\r\n        invertTriangles?: boolean,\r\n        triangleStrip: boolean = false\r\n    ): void {\r\n        if (triangleStrip) {\r\n            if (!indices || indices.length === 0) {\r\n                for (let i = 0; i < pts.length - 2; i += 1) {\r\n                    const p1 = pts[i];\r\n                    const p2 = pts[i + 1];\r\n                    const p3 = pts[i + 2];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = indexStart; i < indexEnd - 2; i += 1) {\r\n                    const indexA = indices[i];\r\n                    const indexB = indices[i + 1];\r\n                    const indexC = indices[i + 2];\r\n\r\n                    if (indexC === 0xffffffff) {\r\n                        i += 2;\r\n                        continue;\r\n                    }\r\n\r\n                    const p1 = pts[indexA];\r\n                    const p2 = pts[indexB];\r\n                    const p3 = pts[indexC];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            }\r\n        } else if (!indices || indices.length === 0) {\r\n            for (let i = 0; i < pts.length; i += 3) {\r\n                const p1 = pts[i];\r\n                const p2 = pts[i + 1];\r\n                const p3 = pts[i + 2];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = indexStart; i < indexEnd; i += 3) {\r\n                const p1 = pts[indices[i] - decal];\r\n                const p2 = pts[indices[i + 1] - decal];\r\n                const p3 = pts[indices[i + 2] - decal];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param pos\r\n     * @param vel\r\n     * @hidden\r\n     */\r\n    public _getResponse(pos: Vector3, vel: Vector3): void {\r\n        pos.addToRef(vel, this._destinationPoint);\r\n        vel.scaleInPlace(this._nearestDistance / vel.length());\r\n\r\n        this._basePoint.addToRef(vel, pos);\r\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\r\n        this._slidePlaneNormal.normalize();\r\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\r\n\r\n        pos.addInPlace(this._displacementVector);\r\n        this.intersectionPoint.addInPlace(this._displacementVector);\r\n\r\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\r\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\r\n\r\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}