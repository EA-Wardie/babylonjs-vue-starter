{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the touch inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n */\n\nvar FreeCameraTouchInput =\n/** @class */\nfunction () {\n  /**\n   * Manage the touch inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n   * @param allowMouse Defines if mouse events can be treated as touch events\n   */\n  function FreeCameraTouchInput(\n  /**\n   * Define if mouse events can be treated as touch events\n   */\n  allowMouse) {\n    if (allowMouse === void 0) {\n      allowMouse = false;\n    }\n\n    this.allowMouse = allowMouse;\n    /**\n     * Defines the touch sensibility for rotation.\n     * The lower the faster.\n     */\n\n    this.touchAngularSensibility = 200000.0;\n    /**\n     * Defines the touch sensibility for move.\n     * The lower the faster.\n     */\n\n    this.touchMoveSensibility = 250.0;\n    /**\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\n     */\n\n    this.singleFingerRotate = false;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._pointerPressed = new Array();\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n\n\n  FreeCameraTouchInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this; // eslint-disable-next-line prefer-rest-params\n\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var previousPosition = null;\n\n    if (this._pointerInput === undefined) {\n      this._onLostFocus = function () {\n        _this._offsetX = null;\n        _this._offsetY = null;\n      };\n\n      this._pointerInput = function (p) {\n        var evt = p.event;\n        var isMouseEvent = !_this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\n\n        if (!_this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\n          return;\n        }\n\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          _this._pointerPressed.push(evt.pointerId);\n\n          if (_this._pointerPressed.length !== 1) {\n            return;\n          }\n\n          previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index === -1) {\n            return;\n          }\n\n          _this._pointerPressed.splice(index, 1);\n\n          if (index != 0) {\n            return;\n          }\n\n          previousPosition = null;\n          _this._offsetX = null;\n          _this._offsetY = null;\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          if (!previousPosition) {\n            return;\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index != 0) {\n            return;\n          }\n\n          _this._offsetX = evt.clientX - previousPosition.x;\n          _this._offsetY = -(evt.clientY - previousPosition.y);\n        }\n      };\n    }\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    if (this._onLostFocus) {\n      var engine = this.camera.getEngine();\n      var element = engine.getInputElement();\n      element && element.addEventListener(\"blur\", this._onLostFocus);\n    }\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  FreeCameraTouchInput.prototype.detachControl = function () {\n    if (this._pointerInput) {\n      if (this._observer) {\n        this.camera.getScene().onPointerObservable.remove(this._observer);\n        this._observer = null;\n      }\n\n      if (this._onLostFocus) {\n        var engine = this.camera.getEngine();\n        var element = engine.getInputElement();\n        element && element.removeEventListener(\"blur\", this._onLostFocus);\n        this._onLostFocus = null;\n      }\n\n      this._pointerPressed = [];\n      this._offsetX = null;\n      this._offsetY = null;\n    }\n  };\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n\n\n  FreeCameraTouchInput.prototype.checkInputs = function () {\n    if (this._offsetX === null || this._offsetY === null) {\n      return;\n    }\n\n    if (this._offsetX === 0 && this._offsetY === 0) {\n      return;\n    }\n\n    var camera = this.camera;\n    camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\n    var rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;\n\n    if (rotateCamera) {\n      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n    } else {\n      var speed = camera._computeLocalCameraSpeed();\n\n      var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);\n      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n    }\n  };\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n\n\n  FreeCameraTouchInput.prototype.getClassName = function () {\n    return \"FreeCameraTouchInput\";\n  };\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n\n\n  FreeCameraTouchInput.prototype.getSimpleName = function () {\n    return \"touch\";\n  };\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\n\n  return FreeCameraTouchInput;\n}();\n\nexport { FreeCameraTouchInput };\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","PointerEventTypes","Matrix","Vector3","Tools","allowMouse","Array","FreeCameraTouchInput","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","previousPosition","_pointerInput","undefined","_onLostFocus","_this","_offsetX","_offsetY","p","evt","event","isMouseEvent","camera","getEngine","hostInformation","isMobile","MouseEvent","pointerType","type","POINTERDOWN","preventDefault","_pointerPressed","push","pointerId","length","x","clientX","y","clientY","POINTERUP","index","indexOf","splice","POINTERMOVE","_observer","getScene","onPointerObservable","add","engine","element","getInputElement","addEventListener","remove","removeEventListener","cameraRotation","touchAngularSensibility","rotateCamera","singleFingerRotate","speed","_computeLocalCameraSpeed","direction","touchMoveSensibility","RotationYawPitchRollToRef","rotation","_cameraRotationMatrix","cameraDirection","addInPlace","TransformCoordinates","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/freeCameraTouchInput.ts"],"sourcesContent":["import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = !this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\r\n\r\n                if (!this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            .onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene().onPointerObservable.remove(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed = [];\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, (speed * this._offsetY) / this.touchMoveSensibility);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n"]},"metadata":{},"sourceType":"module"}