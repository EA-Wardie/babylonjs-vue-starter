{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\n */\n\nvar CylinderParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance CylinderParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  function CylinderParticleEmitter(\n  /**\n   * The radius of the emission cylinder.\n   */\n  radius,\n  /**\n   * The height of the emission cylinder.\n   */\n  height,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (height === void 0) {\n      height = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.radius = radius;\n    this.height = height;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n    this._tempVector = Vector3.Zero();\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\n   */\n\n\n  CylinderParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {\n    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\n\n    this._tempVector.normalize();\n\n    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\n    var randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\n    var angle = Math.atan2(this._tempVector.x, this._tempVector.z);\n    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\n    this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\n\n    this._tempVector.x = Math.sin(angle);\n    this._tempVector.z = Math.cos(angle);\n\n    this._tempVector.normalize();\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(this._tempVector);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  CylinderParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\n    var angle = Scalar.RandomRange(0, 2 * Math.PI); // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\n\n    var radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\n    var positionRadius = Math.sqrt(radiusDistribution) * this.radius;\n    var xPos = positionRadius * Math.cos(angle);\n    var zPos = positionRadius * Math.sin(angle);\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(xPos, yPos, zPos);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  CylinderParticleEmitter.prototype.clone = function () {\n    var newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  CylinderParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  CylinderParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  CylinderParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CYLINDEREMITTER\";\n  };\n  /**\n   * Returns the string \"CylinderParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  CylinderParticleEmitter.prototype.getClassName = function () {\n    return \"CylinderParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  CylinderParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.height = this.height;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  CylinderParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.height = serializationObject.height;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  };\n\n  return CylinderParticleEmitter;\n}();\n\nexport { CylinderParticleEmitter };\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles randomly between two vectors.\n */\n\nvar CylinderDirectedParticleEmitter =\n/** @class */\nfunction (_super) {\n  __extends(CylinderDirectedParticleEmitter, _super);\n  /**\n   * Creates a new instance CylinderDirectedParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n\n\n  function CylinderDirectedParticleEmitter(radius, height, radiusRange,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1,\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (height === void 0) {\n      height = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (direction1 === void 0) {\n      direction1 = new Vector3(0, 1, 0);\n    }\n\n    if (direction2 === void 0) {\n      direction2 = new Vector3(0, 1, 0);\n    }\n\n    var _this = _super.call(this, radius, height, radiusRange) || this;\n\n    _this.direction1 = direction1;\n    _this.direction2 = direction2;\n    return _this;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.clone = function () {\n    var newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n  };\n  /**\n   * Returns the string \"CylinderDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.getClassName = function () {\n    return \"CylinderDirectedParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.parse = function (serializationObject) {\n    _super.prototype.parse.call(this, serializationObject);\n\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  };\n\n  return CylinderDirectedParticleEmitter;\n}(CylinderParticleEmitter);\n\nexport { CylinderDirectedParticleEmitter };","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","DeepCopier","radius","height","radiusRange","directionRandomizer","Zero","CylinderParticleEmitter","worldMatrix","directionToUpdate","particle","isLocal","inverseWorldMatrix","position","subtractToRef","getTranslation","_tempVector","normalize","TransformNormalToRef","randY","RandomRange","angle","Math","atan2","x","z","PI","y","sin","cos","copyFrom","TransformNormalFromFloatsToRef","positionToUpdate","yPos","radiusDistribution","positionRadius","sqrt","xPos","zPos","copyFromFloats","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setFloat","ubo","addUniform","serializationObject","type","getClassName","__extends","direction1","direction2","_super","_this","CylinderDirectedParticleEmitter","randX","randZ","setVector3","serialize","call","asArray","parse"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/cylinderParticleEmitter.ts"],"sourcesContent":["import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\r\n */\r\nexport class CylinderParticleEmitter implements IParticleEmitterType {\r\n    private _tempVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a new instance CylinderParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission cylinder.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The height of the emission cylinder.\r\n         */\r\n        public height = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean, inverseWorldMatrix: Matrix): void {\r\n        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\r\n\r\n        this._tempVector.normalize();\r\n\r\n        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\r\n\r\n        const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\r\n\r\n        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\r\n        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\r\n\r\n        this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\r\n        this._tempVector.x = Math.sin(angle);\r\n        this._tempVector.z = Math.cos(angle);\r\n        this._tempVector.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(this._tempVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\r\n        const angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n\r\n        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\r\n        const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\r\n        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\r\n        const xPos = positionRadius * Math.cos(angle);\r\n        const zPos = positionRadius * Math.sin(angle);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(xPos, yPos, zPos);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderParticleEmitter {\r\n        const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.height = this.height;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.height = serializationObject.height;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\r\n    /**\r\n     * Creates a new instance CylinderDirectedParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius, height, radiusRange);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderDirectedParticleEmitter {\r\n        const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}