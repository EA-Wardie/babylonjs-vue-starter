{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { __extends } from \"tslib\";\nimport { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nimport { Texture } from \"./texture.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\n\nvar EquiRectangularCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(EquiRectangularCubeTexture, _super);\n  /**\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\n   * @param url The location of the image\n   * @param scene The scene the texture will be used in\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\n   * @param noMipmap Forces to not generate the mipmap if true\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n   * @param onLoad — defines a callback called when texture is loaded\n   * @param onError — defines a callback called if there is an error\n   */\n\n\n  function EquiRectangularCubeTexture(url, scene, size, noMipmap, gammaSpace, onLoad, onError) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = true;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, scene) || this;\n\n    _this._onLoad = null;\n    _this._onError = null;\n\n    if (!url) {\n      throw new Error(\"Image url is not set\");\n    }\n\n    _this._coordinatesMode = Texture.CUBIC_MODE;\n    _this.name = url;\n    _this.url = url;\n    _this._size = size;\n    _this._noMipmap = noMipmap;\n    _this.gammaSpace = gammaSpace;\n    _this._onLoad = onLoad;\n    _this._onError = onError;\n    _this.hasAlpha = false;\n    _this.isCube = true;\n    _this._texture = _this._getFromCache(url, _this._noMipmap);\n\n    if (!_this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        _this._loadImage(_this._loadTexture.bind(_this), _this._onError);\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoad();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\n   * @param loadTextureCallback\n   * @param onError\n   */\n\n\n  EquiRectangularCubeTexture.prototype._loadImage = function (loadTextureCallback, onError) {\n    var _this = this;\n\n    var canvas = document.createElement(\"canvas\");\n    LoadImage(this.url, function (image) {\n      _this._width = image.width;\n      _this._height = image.height;\n      canvas.width = _this._width;\n      canvas.height = _this._height;\n      var ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(image, 0, 0);\n      var imageData = ctx.getImageData(0, 0, image.width, image.height);\n      _this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    }, function (_, e) {\n      if (onError) {\n        onError(\"\".concat(_this.getClassName(), \" could not be loaded\"), e);\n      }\n    }, null);\n  };\n  /**\n   * Convert the image buffer into a cubemap and create a CubeTexture.\n   */\n\n\n  EquiRectangularCubeTexture.prototype._loadTexture = function () {\n    var _this = this;\n\n    var scene = this.getScene();\n\n    var callback = function callback() {\n      var imageData = _this._getFloat32ArrayFromArrayBuffer(_this._buffer); // Extract the raw linear data.\n\n\n      var data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, _this._width, _this._height, _this._size);\n      var results = []; // Push each faces.\n\n      for (var i = 0; i < 6; i++) {\n        var dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n\n      return results;\n    };\n\n    if (!scene) {\n      return;\n    }\n\n    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);\n  };\n  /**\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n   * @param buffer The ArrayBuffer that should be converted.\n   * @returns The buffer as Float32Array.\n   */\n\n\n  EquiRectangularCubeTexture.prototype._getFloat32ArrayFromArrayBuffer = function (buffer) {\n    var dataView = new DataView(buffer);\n    var floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    var k = 0;\n\n    for (var i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n\n    return floatImageData;\n  };\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"EquiRectangularCubeTexture\"\n   */\n\n\n  EquiRectangularCubeTexture.prototype.getClassName = function () {\n    return \"EquiRectangularCubeTexture\";\n  };\n  /**\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\n   * @returns A clone of the current EquiRectangularCubeTexture.\n   */\n\n\n  EquiRectangularCubeTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace); // Base texture\n\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /** The six faces of the cube. */\n\n\n  EquiRectangularCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\n  return EquiRectangularCubeTexture;\n}(BaseTexture);\n\nexport { EquiRectangularCubeTexture };","map":{"version":3,"mappings":"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","names":["PanoramaToCubeMapTools","BaseTexture","Texture","Tools","LoadImage","__extends","url","scene","size","noMipmap","gammaSpace","onLoad","onError","_super","_this","Error","_coordinatesMode","CUBIC_MODE","name","_size","_noMipmap","_onLoad","_onError","hasAlpha","isCube","_texture","_getFromCache","useDelayedTextureLoading","_loadImage","_loadTexture","bind","delayLoadState","isReady","SetImmediate","onLoadedObservable","add","EquiRectangularCubeTexture","loadTextureCallback","canvas","document","createElement","image","_width","width","_height","height","ctx","getContext","drawImage","imageData","getImageData","_buffer","data","buffer","remove","_","e","getClassName","getScene","callback","_getFloat32ArrayFromArrayBuffer","ConvertPanoramaToCubemap","results","i","dataFace","_FacesMapping","push","getEngine","createRawCubeTextureFromUrl","getCaps","textureFloat","dataView","DataView","floatImageData","Float32Array","byteLength","k","getUint8","newTexture","level","wrapU","wrapV","coordinatesIndex","coordinatesMode"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/equiRectangularCubeTexture.ts"],"sourcesContent":["import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\nimport { Texture } from \"./texture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\n\r\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\r\nexport class EquiRectangularCubeTexture extends BaseTexture {\r\n    /** The six faces of the cube. */\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _noMipmap: boolean;\r\n    private _onLoad: Nullable<() => void> = null;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /** The size of the cubemap. */\r\n    private _size: number;\r\n\r\n    /** The buffer of the image. */\r\n    private _buffer: ArrayBuffer;\r\n\r\n    /** The width of the input image. */\r\n    private _width: number;\r\n\r\n    /** The height of the input image. */\r\n    private _height: number;\r\n\r\n    /** The URL to the image. */\r\n    public url: string;\r\n\r\n    /**\r\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n     * @param url The location of the image\r\n     * @param scene The scene the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @param onLoad — defines a callback called when texture is loaded\r\n     * @param onError — defines a callback called if there is an error\r\n     */\r\n    constructor(\r\n        url: string,\r\n        scene: Scene,\r\n        size: number,\r\n        noMipmap: boolean = false,\r\n        gammaSpace: boolean = true,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(scene);\r\n\r\n        if (!url) {\r\n            throw new Error(\"Image url is not set\");\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this._size = size;\r\n        this._noMipmap = noMipmap;\r\n        this.gammaSpace = gammaSpace;\r\n        this._onLoad = onLoad;\r\n        this._onError = onError;\r\n\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            if (!scene.useDelayedTextureLoading) {\r\n                this._loadImage(this._loadTexture.bind(this), this._onError);\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else if (onLoad) {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n     * @param loadTextureCallback\r\n     * @param onError\r\n     */\r\n    private _loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\r\n        const canvas = document.createElement(\"canvas\");\r\n        LoadImage(\r\n            this.url,\r\n            (image) => {\r\n                this._width = image.width;\r\n                this._height = image.height;\r\n                canvas.width = this._width;\r\n                canvas.height = this._height;\r\n\r\n                const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                const imageData = ctx.getImageData(0, 0, image.width, image.height);\r\n                this._buffer = imageData.data.buffer as ArrayBuffer;\r\n\r\n                canvas.remove();\r\n                loadTextureCallback();\r\n            },\r\n            (_, e) => {\r\n                if (onError) {\r\n                    onError(`${this.getClassName()} could not be loaded`, e);\r\n                }\r\n            },\r\n            null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convert the image buffer into a cubemap and create a CubeTexture.\r\n     */\r\n    private _loadTexture(): void {\r\n        const scene = this.getScene();\r\n        const callback = (): Nullable<ArrayBufferView[]> => {\r\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\r\n\r\n            // Extract the raw linear data.\r\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\r\n\r\n            const results = [];\r\n\r\n            // Push each faces.\r\n            for (let i = 0; i < 6; i++) {\r\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\r\n                results.push(dataFace);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._texture = scene\r\n            .getEngine()\r\n            .createRawCubeTextureFromUrl(\r\n                this.url,\r\n                scene,\r\n                this._size,\r\n                Constants.TEXTUREFORMAT_RGB,\r\n                scene.getEngine().getCaps().textureFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INTEGER,\r\n                this._noMipmap,\r\n                callback,\r\n                null,\r\n                this._onLoad,\r\n                this._onError\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n     * @param buffer The ArrayBuffer that should be converted.\r\n     * @returns The buffer as Float32Array.\r\n     */\r\n    private _getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\r\n        const dataView = new DataView(buffer);\r\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\r\n\r\n        let k = 0;\r\n        for (let i = 0; i < buffer.byteLength; i++) {\r\n            // We drop the transparency channel, because we do not need/want it\r\n            if ((i + 1) % 4 !== 0) {\r\n                floatImageData[k++] = dataView.getUint8(i) / 255;\r\n            }\r\n        }\r\n\r\n        return floatImageData;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"EquiRectangularCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"EquiRectangularCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n     * @returns A clone of the current EquiRectangularCubeTexture.\r\n     */\r\n    public clone(): EquiRectangularCubeTexture {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}