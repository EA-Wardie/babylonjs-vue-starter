{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Quaternion } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"../Lights/directionalLight.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder.js\";\nimport { SpotLight } from \"../Lights/spotLight.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\n/**\n * Gizmo that enables viewing a light\n */\n\nvar LightGizmo =\n/** @class */\nfunction (_super) {\n  __extends(LightGizmo, _super);\n  /**\n   * Creates a LightGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n\n\n  function LightGizmo(gizmoLayer) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._cachedPosition = new Vector3();\n    _this._cachedForward = new Vector3(0, 0, 1);\n    _this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n\n    _this.onClickedObservable = new Observable();\n    _this._light = null;\n    _this.attachedMesh = new AbstractMesh(\"\", _this.gizmoLayer.utilityLayerScene);\n    _this._attachedMeshParent = new TransformNode(\"parent\", _this.gizmoLayer.utilityLayerScene);\n    _this.attachedMesh.parent = _this._attachedMeshParent;\n    _this._material = new StandardMaterial(\"light\", _this.gizmoLayer.utilityLayerScene);\n    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this._light) {\n        return;\n      }\n\n      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n\n      if (_this._isHovered && pointerInfo.event.button === 0) {\n        _this.onClickedObservable.notifyObservers(_this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n    return _this;\n  }\n\n  Object.defineProperty(LightGizmo.prototype, \"attachedNode\", {\n    /**\n     * Override attachedNode because lightgizmo only support attached mesh\n     * It will return the attached mesh (if any) and setting an attached node will log\n     * a warning\n     */\n    get: function get() {\n      return this.attachedMesh;\n    },\n    set: function set(value) {\n      console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightGizmo.prototype, \"light\", {\n    get: function get() {\n      return this._light;\n    },\n\n    /**\n     * The light that the gizmo is attached to\n     */\n    set: function set(light) {\n      var _this = this;\n\n      this._light = light;\n\n      if (light) {\n        // Create the mesh for the given light type\n        if (this._lightMesh) {\n          this._lightMesh.dispose();\n        }\n\n        if (light instanceof HemisphericLight) {\n          this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof DirectionalLight) {\n          this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof SpotLight) {\n          this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else {\n          this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n        }\n\n        this._lightMesh.getChildMeshes(false).forEach(function (m) {\n          m.material = _this._material;\n        });\n\n        this._lightMesh.parent = this._rootMesh; // Add lighting to the light gizmo\n\n        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n\n        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n        this._lightMesh.rotationQuaternion = new Quaternion();\n\n        if (!this.attachedMesh.reservedDataStore) {\n          this.attachedMesh.reservedDataStore = {};\n        }\n\n        this.attachedMesh.reservedDataStore.lightGizmo = this;\n\n        if (light.parent) {\n          this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n        } // Get update position and direction if the light has it\n\n\n        if (light.position) {\n          this.attachedMesh.position.copyFrom(light.position);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedPosition.copyFrom(this.attachedMesh.position);\n        }\n\n        if (light.direction) {\n          this.attachedMesh.setDirection(light.direction);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedForward.copyFrom(this.attachedMesh.forward);\n        }\n\n        this._update();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightGizmo.prototype, \"material\", {\n    /**\n     * Gets the material used to render the light gizmo\n     */\n    get: function get() {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n\n  LightGizmo.prototype._update = function () {\n    _super.prototype._update.call(this);\n\n    if (!this._light) {\n      return;\n    }\n\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    } // For light position and direction, a dirty flag is set to true in the setter\n    // It means setting values individually or copying values will not call setter and\n    // dirty flag will not be set to true. Hence creating a new Vector3.\n\n\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        var position = this.attachedMesh.position;\n        this._light.position = new Vector3(position.x, position.y, position.z);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        var direction = this.attachedMesh.forward;\n        this._light.direction = new Vector3(direction.x, direction.y, direction.z);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      }\n    }\n  };\n  /**\n   * Disposes of the light gizmo\n   */\n\n\n  LightGizmo.prototype.dispose = function () {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n\n    this._material.dispose();\n\n    _super.prototype.dispose.call(this);\n\n    this._attachedMeshParent.dispose();\n  };\n\n  LightGizmo._CreateHemisphericLightMesh = function (scene) {\n    var root = new Mesh(\"hemisphereLight\", scene);\n    var hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n\n    var lines = this._CreateLightLines(3, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreatePointLightMesh = function (scene) {\n    var root = new Mesh(\"pointLight\", scene);\n    var sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n\n    var lines = this._CreateLightLines(5, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateSpotLightMesh = function (scene) {\n    var root = new Mesh(\"spotLight\", scene);\n    var sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    var hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n\n    var lines = this._CreateLightLines(2, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateDirectionalLightMesh = function (scene) {\n    var root = new Mesh(\"directionalLight\", scene);\n    var mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    var sphere = CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    var line = CreateCylinder(root.name, {\n      updatable: false,\n      height: 6,\n      diameterTop: 0.3,\n      diameterBottom: 0.3,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    line.parent = mesh;\n    var left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    var right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    var arrowHead = CreateCylinder(root.name, {\n      updatable: false,\n      height: 1,\n      diameterTop: 0,\n      diameterBottom: 0.6,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }; // Static helper methods\n\n\n  LightGizmo._Scale = 0.007;\n  /**\n   * Creates the lines for a light mesh\n   * @param levels\n   * @param scene\n   */\n\n  LightGizmo._CreateLightLines = function (levels, scene) {\n    var distFromSphere = 1.2;\n    var root = new Mesh(\"root\", scene);\n    root.rotation.x = Math.PI / 2; // Create the top line, this will be cloned for all other lines\n\n    var linePivot = new Mesh(\"linePivot\", scene);\n    linePivot.parent = root;\n    var line = CreateCylinder(\"line\", {\n      updatable: false,\n      height: 2,\n      diameterTop: 0.2,\n      diameterBottom: 0.3,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    line.position.y = line.scaling.y / 2 + distFromSphere;\n    line.parent = linePivot;\n\n    if (levels < 2) {\n      return linePivot;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l_1 = linePivot.clone(\"lineParentClone\");\n      l_1.rotation.z = Math.PI / 4;\n      l_1.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l_1.getChildMeshes()[0].scaling.y = 0.5;\n      l_1.getChildMeshes()[0].scaling.x = l_1.getChildMeshes()[0].scaling.z = 0.8;\n      l_1.getChildMeshes()[0].position.y = l_1.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 3) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l_2 = linePivot.clone(\"linePivotClone\");\n      l_2.rotation.z = Math.PI / 2;\n      l_2.rotation.y = Math.PI / 2 * i;\n    }\n\n    if (levels < 4) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l_3 = linePivot.clone(\"linePivotClone\");\n      l_3.rotation.z = Math.PI + Math.PI / 4;\n      l_3.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l_3.getChildMeshes()[0].scaling.y = 0.5;\n      l_3.getChildMeshes()[0].scaling.x = l_3.getChildMeshes()[0].scaling.z = 0.8;\n      l_3.getChildMeshes()[0].position.y = l_3.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 5) {\n      return root;\n    }\n\n    var l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI;\n    return root;\n  };\n\n  return LightGizmo;\n}(Gizmo);\n\nexport { LightGizmo };","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Color3","AbstractMesh","Mesh","Gizmo","UtilityLayerRenderer","StandardMaterial","HemisphericLight","DirectionalLight","CreateSphere","CreateHemisphere","SpotLight","TransformNode","PointerEventTypes","Observable","CreateCylinder","__extends","gizmoLayer","DefaultUtilityLayer","_super","_this","attachedMesh","utilityLayerScene","_attachedMeshParent","parent","_material","diffuseColor","specularColor","_pointerObserver","onPointerObservable","add","pointerInfo","_light","_isHovered","pickInfo","_rootMesh","getChildMeshes","indexOf","pickedMesh","event","button","onClickedObservable","notifyObservers","POINTERDOWN","Object","LightGizmo","value","console","warn","light","_lightMesh","dispose","_CreateHemisphericLightMesh","_CreateDirectionalLightMesh","_CreateSpotLightMesh","_CreatePointLightMesh","forEach","m","material","gizmoLight","_getSharedGizmoLight","includedOnlyMeshes","concat","rotationQuaternion","reservedDataStore","lightGizmo","freezeWorldMatrix","getWorldMatrix","position","copyFrom","computeWorldMatrix","_cachedPosition","direction","setDirection","_cachedForward","forward","_update","call","equals","x","y","z","DistanceSquared","clear","remove","scene","root","hemisphere","name","segments","diameter","rotation","Math","PI","lines","_CreateLightLines","scaling","scaleInPlace","_Scale","sphere","mesh","line","updatable","height","diameterTop","diameterBottom","tessellation","subdivisions","left","clone","right","arrowHead","levels","distFromSphere","linePivot","i","l_1","l_2","l_3","l"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/lightGizmo.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Scene } from \"../scene\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"../Lights/directionalLight\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder\";\r\nimport { SpotLight } from \"../Lights/spotLight\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\n\r\n/**\r\n * Gizmo that enables viewing a light\r\n */\r\nexport class LightGizmo extends Gizmo {\r\n    private _lightMesh: Mesh;\r\n    private _material: StandardMaterial;\r\n    private _cachedPosition = new Vector3();\r\n    private _cachedForward = new Vector3(0, 0, 1);\r\n    private _attachedMeshParent: TransformNode;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\r\n    public onClickedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * Creates a LightGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n        super(gizmoLayer);\r\n        this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\r\n        this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\r\n\r\n        this.attachedMesh.parent = this._attachedMeshParent;\r\n        this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\r\n        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n        this._material.specularColor = new Color3(0.1, 0.1, 0.1);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this._light) {\r\n                return;\r\n            }\r\n\r\n            this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1);\r\n            if (this._isHovered && pointerInfo.event.button === 0) {\r\n                this.onClickedObservable.notifyObservers(this._light);\r\n            }\r\n        }, PointerEventTypes.POINTERDOWN);\r\n    }\r\n    private _light: Nullable<Light> = null;\r\n\r\n    /**\r\n     * Override attachedNode because lightgizmo only support attached mesh\r\n     * It will return the attached mesh (if any) and setting an attached node will log\r\n     * a warning\r\n     */\r\n    public get attachedNode() {\r\n        return this.attachedMesh;\r\n    }\r\n    public set attachedNode(value: Nullable<Node>) {\r\n        console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\r\n    }\r\n\r\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\r\n    public set light(light: Nullable<Light>) {\r\n        this._light = light;\r\n        if (light) {\r\n            // Create the mesh for the given light type\r\n            if (this._lightMesh) {\r\n                this._lightMesh.dispose();\r\n            }\r\n\r\n            if (light instanceof HemisphericLight) {\r\n                this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof DirectionalLight) {\r\n                this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof SpotLight) {\r\n                this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else {\r\n                this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            }\r\n            this._lightMesh.getChildMeshes(false).forEach((m) => {\r\n                m.material = this._material;\r\n            });\r\n            this._lightMesh.parent = this._rootMesh;\r\n\r\n            // Add lighting to the light gizmo\r\n            const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\r\n            gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\r\n\r\n            this._lightMesh.rotationQuaternion = new Quaternion();\r\n\r\n            if (!this.attachedMesh!.reservedDataStore) {\r\n                this.attachedMesh!.reservedDataStore = {};\r\n            }\r\n            this.attachedMesh!.reservedDataStore.lightGizmo = this;\r\n\r\n            if (light.parent) {\r\n                this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\r\n            }\r\n\r\n            // Get update position and direction if the light has it\r\n            if ((light as any).position) {\r\n                this.attachedMesh!.position.copyFrom((light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n            if ((light as any).direction) {\r\n                this.attachedMesh!.setDirection((light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n\r\n            this._update();\r\n        }\r\n    }\r\n    public get light() {\r\n        return this._light;\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        super._update();\r\n        if (!this._light) {\r\n            return;\r\n        }\r\n\r\n        if (this._light.parent) {\r\n            this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\r\n        }\r\n\r\n        // For light position and direction, a dirty flag is set to true in the setter\r\n        // It means setting values individually or copying values will not call setter and\r\n        // dirty flag will not be set to true. Hence creating a new Vector3.\r\n        if ((this._light as any).position) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (!this.attachedMesh!.position.equals(this._cachedPosition)) {\r\n                // update light to match gizmo\r\n                const position = this.attachedMesh!.position;\r\n                (this._light as any).position = new Vector3(position.x, position.y, position.z);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            } else {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.position.copyFrom((this._light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n        }\r\n        if ((this._light as any).direction) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (Vector3.DistanceSquared(this.attachedMesh!.forward, this._cachedForward) > 0.0001) {\r\n                // update light to match gizmo\r\n                const direction = this.attachedMesh!.forward;\r\n                (this._light as any).direction = new Vector3(direction.x, direction.y, direction.z);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            } else if (Vector3.DistanceSquared(this.attachedMesh!.forward, (this._light as any).direction) > 0.0001) {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.setDirection((this._light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Static helper methods\r\n    private static _Scale = 0.007;\r\n\r\n    /**\r\n     * Creates the lines for a light mesh\r\n     * @param levels\r\n     * @param scene\r\n     */\r\n    private static _CreateLightLines = (levels: number, scene: Scene) => {\r\n        const distFromSphere = 1.2;\r\n\r\n        const root = new Mesh(\"root\", scene);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        // Create the top line, this will be cloned for all other lines\r\n        const linePivot = new Mesh(\"linePivot\", scene);\r\n        linePivot.parent = root;\r\n        const line = CreateCylinder(\r\n            \"line\",\r\n            {\r\n                updatable: false,\r\n                height: 2,\r\n                diameterTop: 0.2,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.position.y = line.scaling.y / 2 + distFromSphere;\r\n        line.parent = linePivot;\r\n\r\n        if (levels < 2) {\r\n            return linePivot;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"lineParentClone\")!;\r\n            l.rotation.z = Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 3) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI / 2;\r\n            l.rotation.y = (Math.PI / 2) * i;\r\n        }\r\n\r\n        if (levels < 4) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI + Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 5) {\r\n            return root;\r\n        }\r\n        const l = linePivot.clone(\"linePivotClone\");\r\n        l.rotation.z = Math.PI;\r\n\r\n        return root;\r\n    };\r\n\r\n    /**\r\n     * Disposes of the light gizmo\r\n     */\r\n    public dispose() {\r\n        this.onClickedObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this._material.dispose();\r\n        super.dispose();\r\n        this._attachedMeshParent.dispose();\r\n    }\r\n\r\n    private static _CreateHemisphericLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"hemisphereLight\", scene);\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        hemisphere.position.z = -0.15;\r\n        hemisphere.rotation.x = Math.PI / 2;\r\n        hemisphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(3, scene);\r\n        lines.parent = root;\r\n\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreatePointLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"pointLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.rotation.x = Math.PI / 2;\r\n        sphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(5, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateSpotLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"spotLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.parent = root;\r\n\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);\r\n        hemisphere.parent = root;\r\n        hemisphere.rotation.x = -Math.PI / 2;\r\n\r\n        const lines = this._CreateLightLines(2, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateDirectionalLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"directionalLight\", scene);\r\n\r\n        const mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n        const sphere = CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);\r\n        sphere.parent = mesh;\r\n\r\n        const line = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 6,\r\n                diameterTop: 0.3,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.parent = mesh;\r\n\r\n        let left = line.clone(root.name)!;\r\n        left.scaling.y = 0.5;\r\n        left.position.x += 1.25;\r\n\r\n        let right = line.clone(root.name)!;\r\n        right.scaling.y = 0.5;\r\n        right.position.x += -1.25;\r\n\r\n        const arrowHead = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 1,\r\n                diameterTop: 0,\r\n                diameterBottom: 0.6,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        arrowHead.position.y += 3;\r\n        arrowHead.parent = mesh;\r\n\r\n        left = arrowHead.clone(root.name);\r\n        left.position.y = 1.5;\r\n        left.position.x += 1.25;\r\n\r\n        right = arrowHead.clone(root.name);\r\n        right.position.y = 1.5;\r\n        right.position.x += -1.25;\r\n\r\n        mesh.scaling.scaleInPlace(LightGizmo._Scale);\r\n        mesh.rotation.z = Math.PI / 2;\r\n        mesh.rotation.y = Math.PI / 2;\r\n        return root;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}