{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.videoTexture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\n\nfunction removeSource(video) {\n  // Remove any <source> elements, etc.\n  while (video.firstChild) {\n    video.removeChild(video.firstChild);\n  } // detach srcObject\n\n\n  video.srcObject = null; // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\n\n  video.src = \"\"; // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\n\n  video.removeAttribute(\"src\");\n}\n/**\n * If you want to display a video in your scene, this is the special texture for that.\n * This special texture works similar to other textures, with the exception of a few parameters.\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/videoTexture\n */\n\n\nvar VideoTexture =\n/** @class */\nfunction (_super) {\n  __extends(VideoTexture, _super);\n  /**\n   * Creates a video texture.\n   * If you want to display a video in your scene, this is the special texture for that.\n   * This special texture works similar to other textures, with the exception of a few parameters.\n   * @see https://doc.babylonjs.com/how_to/video_texture\n   * @param name optional name, will detect from video source, if not defined\n   * @param src can be used to provide an url, array of urls or an already setup HTML video element.\n   * @param scene is obviously the current scene.\n   * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\n   * @param invertY is false by default but can be used to invert video on Y axis\n   * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\n   * @param settings allows finer control over video usage\n   * @param onError defines a callback triggered when an error occurred during the loading session\n   */\n\n\n  function VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings, onError) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n\n    _this._onUserActionRequestedObservable = null;\n    _this._stillImageCaptured = false;\n    _this._displayingPosterTexture = false;\n    _this._frameId = -1;\n    _this._currentSrc = null;\n    _this._errorFound = false;\n\n    _this._createInternalTexture = function () {\n      if (_this._texture != null) {\n        if (_this._displayingPosterTexture) {\n          _this._texture.dispose();\n\n          _this._displayingPosterTexture = false;\n        } else {\n          return;\n        }\n      }\n\n      if (!_this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(_this.video.videoWidth) && Tools.IsExponentOfTwo(_this.video.videoHeight)) {\n        _this.wrapU = Texture.WRAP_ADDRESSMODE;\n        _this.wrapV = Texture.WRAP_ADDRESSMODE;\n      } else {\n        _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        _this._generateMipMaps = false;\n      }\n\n      _this._texture = _this._getEngine().createDynamicTexture(_this.video.videoWidth, _this.video.videoHeight, _this._generateMipMaps, _this.samplingMode);\n\n      if (!_this.video.autoplay && !_this._settings.poster) {\n        var oldHandler_1 = _this.video.onplaying;\n        var oldMuted_1 = _this.video.muted;\n        _this.video.muted = true;\n\n        _this.video.onplaying = function () {\n          _this.video.muted = oldMuted_1;\n          _this.video.onplaying = oldHandler_1;\n\n          _this._updateInternalTexture();\n\n          if (!_this._errorFound) {\n            _this.video.pause();\n          }\n\n          if (_this.onLoadObservable.hasObservers()) {\n            _this.onLoadObservable.notifyObservers(_this);\n          }\n        };\n\n        _this._handlePlay();\n      } else {\n        _this._updateInternalTexture();\n\n        if (_this.onLoadObservable.hasObservers()) {\n          _this.onLoadObservable.notifyObservers(_this);\n        }\n      }\n    };\n\n    _this._reset = function () {\n      if (_this._texture == null) {\n        return;\n      }\n\n      if (!_this._displayingPosterTexture) {\n        _this._texture.dispose();\n\n        _this._texture = null;\n      }\n    };\n\n    _this._updateInternalTexture = function () {\n      if (_this._texture == null) {\n        return;\n      }\n\n      if (_this.video.readyState < _this.video.HAVE_CURRENT_DATA) {\n        return;\n      }\n\n      if (_this._displayingPosterTexture) {\n        return;\n      }\n\n      var frameId = _this.getScene().getFrameId();\n\n      if (_this._frameId === frameId) {\n        return;\n      }\n\n      _this._frameId = frameId;\n\n      _this._getEngine().updateVideoTexture(_this._texture, _this.video, _this._invertY);\n    };\n\n    _this._settings = __assign({\n      autoPlay: true,\n      loop: true,\n      autoUpdateTexture: true\n    }, settings);\n    _this._onError = onError;\n    _this._generateMipMaps = generateMipMaps;\n    _this._initialSamplingMode = samplingMode;\n    _this.autoUpdateTexture = _this._settings.autoUpdateTexture;\n    _this._currentSrc = src;\n    _this.name = name || _this._getName(src);\n    _this.video = _this._getVideo(src);\n\n    if (_this._settings.poster) {\n      _this.video.poster = _this._settings.poster;\n    }\n\n    if (_this._settings.autoPlay !== undefined) {\n      _this.video.autoplay = _this._settings.autoPlay;\n    }\n\n    if (_this._settings.loop !== undefined) {\n      _this.video.loop = _this._settings.loop;\n    }\n\n    if (_this._settings.muted !== undefined) {\n      _this.video.muted = _this._settings.muted;\n    }\n\n    _this.video.setAttribute(\"playsinline\", \"\");\n\n    _this.video.addEventListener(\"paused\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"seeked\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"emptied\", _this._reset);\n\n    _this._createInternalTextureOnEvent = _this._settings.poster && !_this._settings.autoPlay ? \"play\" : \"canplay\";\n\n    _this.video.addEventListener(_this._createInternalTextureOnEvent, _this._createInternalTexture);\n\n    if (_this._settings.autoPlay) {\n      _this._handlePlay();\n    }\n\n    var videoHasEnoughData = _this.video.readyState >= _this.video.HAVE_CURRENT_DATA;\n\n    if (_this._settings.poster && (!_this._settings.autoPlay || !videoHasEnoughData)) {\n      _this._texture = _this._getEngine().createTexture(_this._settings.poster, false, !_this.invertY, scene);\n      _this._displayingPosterTexture = true;\n    } else if (videoHasEnoughData) {\n      _this._createInternalTexture();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(VideoTexture.prototype, \"onUserActionRequestedObservable\", {\n    /**\n     * Event triggered when a dom action is required by the user to play the video.\n     * This happens due to recent changes in browser policies preventing video to auto start.\n     */\n    get: function get() {\n      if (!this._onUserActionRequestedObservable) {\n        this._onUserActionRequestedObservable = new Observable();\n      }\n\n      return this._onUserActionRequestedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VideoTexture.prototype._processError = function (reason) {\n    this._errorFound = true;\n\n    if (this._onError) {\n      this._onError(reason === null || reason === void 0 ? void 0 : reason.message);\n    } else {\n      Logger.Error(reason === null || reason === void 0 ? void 0 : reason.message);\n    }\n  };\n\n  VideoTexture.prototype._handlePlay = function () {\n    var _this = this;\n\n    this._errorFound = false;\n    this.video.play()[\"catch\"](function (reason) {\n      if ((reason === null || reason === void 0 ? void 0 : reason.name) === \"NotAllowedError\") {\n        if (_this._onUserActionRequestedObservable && _this._onUserActionRequestedObservable.hasObservers()) {\n          _this._onUserActionRequestedObservable.notifyObservers(_this);\n\n          return;\n        } else if (!_this.video.muted) {\n          Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\n          _this.video.muted = true;\n          _this._errorFound = false;\n\n          _this.video.play()[\"catch\"](function (otherReason) {\n            _this._processError(otherReason);\n          });\n\n          return;\n        }\n      }\n\n      _this._processError(reason);\n    });\n  };\n  /**\n   * Get the current class name of the video texture useful for serialization or dynamic coding.\n   * @returns \"VideoTexture\"\n   */\n\n\n  VideoTexture.prototype.getClassName = function () {\n    return \"VideoTexture\";\n  };\n\n  VideoTexture.prototype._getName = function (src) {\n    if (src instanceof HTMLVideoElement) {\n      return src.currentSrc;\n    }\n\n    if (_typeof(src) === \"object\") {\n      return src.toString();\n    }\n\n    return src;\n  };\n\n  VideoTexture.prototype._getVideo = function (src) {\n    if (src.isNative) {\n      return src;\n    }\n\n    if (src instanceof HTMLVideoElement) {\n      Tools.SetCorsBehavior(src.currentSrc, src);\n      return src;\n    }\n\n    var video = document.createElement(\"video\");\n\n    if (typeof src === \"string\") {\n      Tools.SetCorsBehavior(src, video);\n      video.src = src;\n    } else {\n      Tools.SetCorsBehavior(src[0], video);\n      src.forEach(function (url) {\n        var source = document.createElement(\"source\");\n        source.src = url;\n        video.appendChild(source);\n      });\n    }\n\n    this.onDisposeObservable.addOnce(function () {\n      removeSource(video);\n    });\n    return video;\n  };\n  /**\n   * @hidden Internal method to initiate `update`.\n   */\n\n\n  VideoTexture.prototype._rebuild = function () {\n    this.update();\n  };\n  /**\n   * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\n   */\n\n\n  VideoTexture.prototype.update = function () {\n    if (!this.autoUpdateTexture) {\n      // Expecting user to call `updateTexture` manually\n      return;\n    }\n\n    this.updateTexture(true);\n  };\n  /**\n   * Update Texture in `manual` mode. Does not do anything if not visible or paused.\n   * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\n   */\n\n\n  VideoTexture.prototype.updateTexture = function (isVisible) {\n    if (!isVisible) {\n      return;\n    }\n\n    if (this.video.paused && this._stillImageCaptured) {\n      return;\n    }\n\n    this._stillImageCaptured = true;\n\n    this._updateInternalTexture();\n  };\n  /**\n   * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\n   * @param url New url.\n   */\n\n\n  VideoTexture.prototype.updateURL = function (url) {\n    this.video.src = url;\n    this._currentSrc = url;\n  };\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n\n\n  VideoTexture.prototype.clone = function () {\n    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\n  };\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n\n  VideoTexture.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._currentSrc = null;\n\n    if (this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable.clear();\n\n      this._onUserActionRequestedObservable = null;\n    }\n\n    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    this.video.removeEventListener(\"paused\", this._updateInternalTexture);\n    this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\n    this.video.removeEventListener(\"emptied\", this._reset);\n    this.video.pause();\n  };\n  /**\n   * Creates a video texture straight from a stream.\n   * @param scene Define the scene the texture should be created in\n   * @param stream Define the stream the texture should be created from\n   * @param constraints video constraints\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n\n\n  VideoTexture.CreateFromStreamAsync = function (scene, stream, constraints, invertY) {\n    if (invertY === void 0) {\n      invertY = true;\n    }\n\n    var video = scene.getEngine().createVideoElement(constraints);\n\n    if (scene.getEngine()._badOS) {\n      // Yes... I know and I hope to remove it soon...\n      document.body.appendChild(video);\n      video.style.transform = \"scale(0.0001, 0.0001)\";\n      video.style.opacity = \"0\";\n      video.style.position = \"fixed\";\n      video.style.bottom = \"0px\";\n      video.style.right = \"0px\";\n    }\n\n    video.setAttribute(\"autoplay\", \"\");\n    video.setAttribute(\"muted\", \"true\");\n    video.setAttribute(\"playsinline\", \"\");\n    video.muted = true;\n\n    if (video.mozSrcObject !== undefined) {\n      // hack for Firefox < 19\n      video.mozSrcObject = stream;\n    } else {\n      if (_typeof(video.srcObject) == \"object\") {\n        video.srcObject = stream;\n      } else {\n        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL; // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\n\n        video.src = window.URL && window.URL.createObjectURL(stream);\n      }\n    }\n\n    return new Promise(function (resolve) {\n      var onPlaying = function onPlaying() {\n        var videoTexture = new VideoTexture(\"video\", video, scene, true, invertY);\n\n        if (scene.getEngine()._badOS) {\n          videoTexture.onDisposeObservable.addOnce(function () {\n            video.remove();\n          });\n        }\n\n        videoTexture.onDisposeObservable.addOnce(function () {\n          removeSource(video);\n        });\n        resolve(videoTexture);\n        video.removeEventListener(\"playing\", onPlaying);\n      };\n\n      video.addEventListener(\"playing\", onPlaying);\n      video.play();\n    });\n  };\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Define the scene the texture should be created in\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n\n\n  VideoTexture.CreateFromWebCamAsync = function (scene, constraints, audioConstaints, invertY) {\n    var _this = this;\n\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = true;\n    }\n\n    var constraintsDeviceId;\n\n    if (constraints && constraints.deviceId) {\n      constraintsDeviceId = {\n        exact: constraints.deviceId\n      };\n    }\n\n    if (navigator.mediaDevices) {\n      return navigator.mediaDevices.getUserMedia({\n        video: constraints,\n        audio: audioConstaints\n      }).then(function (stream) {\n        return _this.CreateFromStreamAsync(scene, stream, constraints, invertY);\n      });\n    } else {\n      var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\n      if (getUserMedia) {\n        getUserMedia({\n          video: {\n            deviceId: constraintsDeviceId,\n            width: {\n              min: constraints && constraints.minWidth || 256,\n              max: constraints && constraints.maxWidth || 640\n            },\n            height: {\n              min: constraints && constraints.minHeight || 256,\n              max: constraints && constraints.maxHeight || 480\n            }\n          },\n          audio: audioConstaints\n        }, function (stream) {\n          return _this.CreateFromStreamAsync(scene, stream, constraints, invertY);\n        }, function (e) {\n          Logger.Error(e.name);\n        });\n      }\n    }\n\n    return Promise.reject(\"No support for userMedia on this device\");\n  };\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Defines the scene the texture should be created in\n   * @param onReady Defines a callback to triggered once the texture will be ready\n   * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   */\n\n\n  VideoTexture.CreateFromWebCam = function (scene, onReady, constraints, audioConstaints, invertY) {\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = true;\n    }\n\n    this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY).then(function (videoTexture) {\n      if (onReady) {\n        onReady(videoTexture);\n      }\n    })[\"catch\"](function (err) {\n      Logger.Error(err.name);\n    });\n  };\n\n  return VideoTexture;\n}(Texture);\n\nexport { VideoTexture };","map":{"version":3,"mappings":"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","names":["Observable","Tools","Logger","Texture","removeSource","video","firstChild","removeChild","srcObject","src","removeAttribute","__extends","name","scene","generateMipMaps","invertY","samplingMode","settings","onError","TRILINEAR_SAMPLINGMODE","_super","_this","_texture","_displayingPosterTexture","dispose","_getEngine","needPOTTextures","IsExponentOfTwo","videoWidth","videoHeight","wrapU","WRAP_ADDRESSMODE","wrapV","CLAMP_ADDRESSMODE","_generateMipMaps","createDynamicTexture","autoplay","_settings","poster","oldHandler_1","onplaying","oldMuted_1","muted","_updateInternalTexture","_errorFound","pause","onLoadObservable","hasObservers","notifyObservers","_handlePlay","readyState","HAVE_CURRENT_DATA","frameId","getScene","getFrameId","_frameId","updateVideoTexture","_invertY","__assign","autoPlay","loop","autoUpdateTexture","_onError","_initialSamplingMode","_currentSrc","_getName","_getVideo","undefined","setAttribute","addEventListener","_reset","_createInternalTextureOnEvent","_createInternalTexture","videoHasEnoughData","createTexture","Object","VideoTexture","_onUserActionRequestedObservable","reason","message","Error","play","Warn","otherReason","_processError","HTMLVideoElement","currentSrc","toString","isNative","SetCorsBehavior","document","createElement","forEach","url","source","appendChild","onDisposeObservable","addOnce","update","updateTexture","isVisible","paused","_stillImageCaptured","call","clear","removeEventListener","stream","constraints","getEngine","createVideoElement","_badOS","body","style","transform","opacity","position","bottom","right","mozSrcObject","window","URL","webkitURL","mozURL","msURL","createObjectURL","Promise","resolve","onPlaying","videoTexture","remove","audioConstaints","constraintsDeviceId","deviceId","exact","navigator","mediaDevices","getUserMedia","audio","then","CreateFromStreamAsync","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","width","min","minWidth","max","maxWidth","height","minHeight","maxHeight","e","reject","onReady","CreateFromWebCamAsync","err"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/videoTexture.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\nfunction removeSource(video: HTMLVideoElement): void {\r\n    // Remove any <source> elements, etc.\r\n    while (video.firstChild) {\r\n        video.removeChild(video.firstChild);\r\n    }\r\n\r\n    // detach srcObject\r\n    video.srcObject = null;\r\n\r\n    // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\r\n    video.src = \"\";\r\n\r\n    // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\r\n    video.removeAttribute(\"src\");\r\n}\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `muted` to video, if specified\r\n     */\r\n    muted?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/videoTexture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggered when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n    private _onError?: Nullable<(message?: string, exception?: any) => void>;\r\n    private _errorFound = false;\r\n\r\n    private _processError(reason: any) {\r\n        this._errorFound = true;\r\n        if (this._onError) {\r\n            this._onError(reason?.message);\r\n        } else {\r\n            Logger.Error(reason?.message);\r\n        }\r\n    }\r\n\r\n    private _handlePlay() {\r\n        this._errorFound = false;\r\n        this.video.play().catch((reason) => {\r\n            if (reason?.name === \"NotAllowedError\") {\r\n                if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                    this._onUserActionRequestedObservable.notifyObservers(this);\r\n                    return;\r\n                } else if (!this.video.muted) {\r\n                    Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\r\n                    this.video.muted = true;\r\n                    this._errorFound = false;\r\n                    this.video.play().catch((otherReason) => {\r\n                        this._processError(otherReason);\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._processError(reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/how_to/video_texture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._settings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n            ...settings,\r\n        };\r\n\r\n        this._onError = onError;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = this._settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n\r\n        if (this._settings.poster) {\r\n            this.video.poster = this._settings.poster;\r\n        }\r\n        if (this._settings.autoPlay !== undefined) {\r\n            this.video.autoplay = this._settings.autoPlay;\r\n        }\r\n        if (this._settings.loop !== undefined) {\r\n            this.video.loop = this._settings.loop;\r\n        }\r\n        if (this._settings.muted !== undefined) {\r\n            this.video.muted = this._settings.muted;\r\n        }\r\n\r\n        this.video.setAttribute(\"playsinline\", \"\");\r\n        this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"emptied\", this._reset);\r\n        this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n\r\n        if (this._settings.autoPlay) {\r\n            this._handlePlay();\r\n        }\r\n\r\n        const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\r\n        if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._getEngine()!.createTexture(this._settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        } else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the video texture useful for serialization or dynamic coding.\r\n     * @returns \"VideoTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VideoTexture\";\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if ((<any>src).isNative) {\r\n            return <HTMLVideoElement>src;\r\n        }\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n\r\n        this.onDisposeObservable.addOnce(() => {\r\n            removeSource(video);\r\n        });\r\n\r\n        return video;\r\n    }\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._texture.dispose();\r\n                this._displayingPosterTexture = false;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!this._getEngine()!.needPOTTextures || (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\r\n\r\n        if (!this.video.autoplay && !this._settings.poster) {\r\n            const oldHandler = this.video.onplaying;\r\n            const oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._updateInternalTexture();\r\n                if (!this._errorFound) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            this._handlePlay();\r\n        } else {\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    };\r\n\r\n    private _reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @hidden Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        const frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._getEngine()!.updateVideoTexture(this._texture, this.video, this._invertY);\r\n    };\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name, this._currentSrc!, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"emptied\", this._reset);\r\n        this.video.pause();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @param constraints video constraints\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream, constraints: any, invertY = true): Promise<VideoTexture> {\r\n        const video = scene.getEngine().createVideoElement(constraints);\r\n\r\n        if (scene.getEngine()._badOS) {\r\n            // Yes... I know and I hope to remove it soon...\r\n            document.body.appendChild(video);\r\n            video.style.transform = \"scale(0.0001, 0.0001)\";\r\n            video.style.opacity = \"0\";\r\n            video.style.position = \"fixed\";\r\n            video.style.bottom = \"0px\";\r\n            video.style.right = \"0px\";\r\n        }\r\n\r\n        video.setAttribute(\"autoplay\", \"\");\r\n        video.setAttribute(\"muted\", \"true\");\r\n        video.setAttribute(\"playsinline\", \"\");\r\n        video.muted = true;\r\n\r\n        if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\r\n                // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\r\n                video.src = window.URL && window.URL.createObjectURL(stream as any);\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            const onPlaying = () => {\r\n                const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY);\r\n                if (scene.getEngine()._badOS) {\r\n                    videoTexture.onDisposeObservable.addOnce(() => {\r\n                        video.remove();\r\n                    });\r\n                }\r\n                videoTexture.onDisposeObservable.addOnce(() => {\r\n                    removeSource(video);\r\n                });\r\n\r\n                resolve(videoTexture);\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): Promise<VideoTexture> {\r\n        let constraintsDeviceId;\r\n        if (constraints && constraints.deviceId) {\r\n            constraintsDeviceId = {\r\n                exact: constraints.deviceId,\r\n            };\r\n        }\r\n\r\n        if (navigator.mediaDevices) {\r\n            return navigator.mediaDevices\r\n                .getUserMedia({\r\n                    video: constraints,\r\n                    audio: audioConstaints,\r\n                })\r\n                .then((stream) => {\r\n                    return this.CreateFromStreamAsync(scene, stream, constraints, invertY);\r\n                });\r\n        } else {\r\n            const getUserMedia = (navigator as any).getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\r\n\r\n            if (getUserMedia) {\r\n                getUserMedia(\r\n                    {\r\n                        video: {\r\n                            deviceId: constraintsDeviceId,\r\n                            width: {\r\n                                min: (constraints && constraints.minWidth) || 256,\r\n                                max: (constraints && constraints.maxWidth) || 640,\r\n                            },\r\n                            height: {\r\n                                min: (constraints && constraints.minHeight) || 256,\r\n                                max: (constraints && constraints.maxHeight) || 480,\r\n                            },\r\n                        },\r\n                        audio: audioConstaints,\r\n                    },\r\n                    (stream: any) => {\r\n                        return this.CreateFromStreamAsync(scene, stream, constraints, invertY);\r\n                    },\r\n                    function (e: any) {\r\n                        Logger.Error(e.name);\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Defines the scene the texture should be created in\r\n     * @param onReady Defines a callback to triggered once the texture will be ready\r\n     * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY)\r\n            .then(function (videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function (err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}