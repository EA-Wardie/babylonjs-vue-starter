{"ast":null,"code":"import \"core-js/modules/es.array.is-array.js\";\nimport { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer.js\";\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { EndsWith } from \"../../../Misc/stringTools.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n\nfunction mapSRGBToLinear(format) {\n  switch (format) {\n    case 35916:\n      return 33776;\n\n    case 35918:\n      return 33778;\n\n    case 35919:\n      return 33779;\n\n    case 37493:\n      return 37492;\n\n    case 37497:\n      return 37496;\n\n    case 37495:\n      return 37494;\n\n    case 37840:\n      return 37808;\n\n    case 36493:\n      return 36492;\n  }\n\n  return null;\n}\n/**\n * Implementation of the KTX Texture Loader.\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nvar _KTXTextureLoader =\n/** @class */\nfunction () {\n  function _KTXTextureLoader() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = false;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @param mimeType defines the optional mime type of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n\n\n  _KTXTextureLoader.prototype.canLoad = function (extension, mimeType) {\n    // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\n    return EndsWith(extension, \".ktx\") || EndsWith(extension, \".ktx2\") || mimeType === \"image/ktx\" || mimeType === \"image/ktx2\";\n  };\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   */\n\n\n  _KTXTextureLoader.prototype.loadCubeData = function (data, texture, createPolynomials, onLoad) {\n    if (Array.isArray(data)) {\n      return;\n    } // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n\n\n    texture._invertVScale = !texture.invertY;\n    var engine = texture.getEngine();\n    var ktx = new KhronosTextureContainer(data, 6);\n    var loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\n\n    engine._unpackFlipY(true);\n\n    ktx.uploadLevels(texture, texture.generateMipMaps);\n    texture.width = ktx.pixelWidth;\n    texture.height = ktx.pixelHeight;\n\n    engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\n\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n\n    if (onLoad) {\n      onLoad();\n    }\n  };\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param callback defines the method to call once ready to upload\n   * @param options\n   */\n\n\n  _KTXTextureLoader.prototype.loadData = function (data, texture, callback, options) {\n    if (KhronosTextureContainer.IsValid(data)) {\n      // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n      texture._invertVScale = !texture.invertY;\n      var ktx_1 = new KhronosTextureContainer(data, 1);\n      var mappedFormat = mapSRGBToLinear(ktx_1.glInternalFormat);\n\n      if (mappedFormat) {\n        texture.format = mappedFormat;\n        texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\n        texture._gammaSpace = true;\n      } else {\n        texture.format = ktx_1.glInternalFormat;\n      }\n\n      callback(ktx_1.pixelWidth, ktx_1.pixelHeight, texture.generateMipMaps, true, function () {\n        ktx_1.uploadLevels(texture, texture.generateMipMaps);\n      }, ktx_1.isInvalid);\n    } else if (KhronosTextureContainer2.IsValid(data)) {\n      var ktx2 = new KhronosTextureContainer2(texture.getEngine());\n      ktx2.uploadAsync(data, texture, options).then(function () {\n        callback(texture.width, texture.height, texture.generateMipMaps, true, function () {}, false);\n      }, function (error) {\n        Logger.Warn(\"Failed to load KTX2 texture data: \".concat(error.message));\n        callback(0, 0, false, false, function () {}, true);\n      });\n    } else {\n      Logger.Error(\"texture missing KTX identifier\");\n      callback(0, 0, false, false, function () {}, true);\n    }\n  };\n\n  return _KTXTextureLoader;\n}();\n\nexport { _KTXTextureLoader }; // Register the loader.\n\nEngine._TextureLoaders.unshift(new _KTXTextureLoader());","map":{"version":3,"mappings":"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","names":["KhronosTextureContainer","KhronosTextureContainer2","Engine","EndsWith","Logger","mapSRGBToLinear","format","_KTXTextureLoader","extension","mimeType","data","texture","createPolynomials","onLoad","Array","isArray","_invertVScale","invertY","engine","getEngine","ktx","loadMipmap","numberOfMipmapLevels","generateMipMaps","_unpackFlipY","uploadLevels","width","pixelWidth","height","pixelHeight","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","callback","options","IsValid","ktx_1","mappedFormat","glInternalFormat","_useSRGBBuffer","_getUseSRGBBuffer","_gammaSpace","isInvalid","ktx2","uploadAsync","then","error","Warn","message","Error","_TextureLoaders","unshift"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Loaders/ktxTextureLoader.ts"],"sourcesContent":["import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer\";\r\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport { EndsWith } from \"../../../Misc/stringTools\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\nfunction mapSRGBToLinear(format: number): Nullable<number> {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Implementation of the KTX Texture Loader.\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _KTXTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @param mimeType defines the optional mime type of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string, mimeType?: string): boolean {\r\n        // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\r\n        return EndsWith(extension, \".ktx\") || EndsWith(extension, \".ktx2\") || mimeType === \"image/ktx\" || mimeType === \"image/ktx2\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n        texture._invertVScale = !texture.invertY;\r\n        const engine = texture.getEngine() as Engine;\r\n        const ktx = new KhronosTextureContainer(data, 6);\r\n\r\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\r\n\r\n        engine._unpackFlipY(true);\r\n\r\n        ktx.uploadLevels(texture, texture.generateMipMaps);\r\n\r\n        texture.width = ktx.pixelWidth;\r\n        texture.height = ktx.pixelHeight;\r\n\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     * @param options\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed: boolean) => void,\r\n        options?: any\r\n    ): void {\r\n        if (KhronosTextureContainer.IsValid(data)) {\r\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n            texture._invertVScale = !texture.invertY;\r\n            const ktx = new KhronosTextureContainer(data, 1);\r\n\r\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\r\n            if (mappedFormat) {\r\n                texture.format = mappedFormat;\r\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\r\n                texture._gammaSpace = true;\r\n            } else {\r\n                texture.format = ktx.glInternalFormat;\r\n            }\r\n\r\n            callback(\r\n                ktx.pixelWidth,\r\n                ktx.pixelHeight,\r\n                texture.generateMipMaps,\r\n                true,\r\n                () => {\r\n                    ktx.uploadLevels(texture, texture.generateMipMaps);\r\n                },\r\n                ktx.isInvalid\r\n            );\r\n        } else if (KhronosTextureContainer2.IsValid(data)) {\r\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\r\n            ktx2.uploadAsync(data, texture, options).then(\r\n                () => {\r\n                    callback(texture.width, texture.height, texture.generateMipMaps, true, () => {}, false);\r\n                },\r\n                (error) => {\r\n                    Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\r\n                    callback(0, 0, false, false, () => {}, true);\r\n                }\r\n            );\r\n        } else {\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            callback(0, 0, false, false, () => {}, true);\r\n        }\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.unshift(new _KTXTextureLoader());\r\n"]},"metadata":{},"sourceType":"module"}