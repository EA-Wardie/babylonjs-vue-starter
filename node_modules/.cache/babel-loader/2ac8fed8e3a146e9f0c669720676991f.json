{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { Texture } from \"./texture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Class used to store 2D array textures containing user data\n */\n\nvar RawTexture2DArray =\n/** @class */\nfunction (_super) {\n  __extends(RawTexture2DArray, _super);\n  /**\n   * Create a new RawTexture2DArray\n   * @param data defines the data of the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param depth defines the number of layers of the texture\n   * @param format defines the texture format to use\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n   * @param invertY defines if texture must be stored with Y axis inverted\n   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n   * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\n   */\n\n\n  function RawTexture2DArray(data, width, height, depth,\n  /** Gets or sets the texture format to use */\n  format, scene, generateMipMaps, invertY, samplingMode, textureType) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n\n    _this.format = format;\n    _this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);\n    _this._depth = depth;\n    _this.is2DArray = true;\n    return _this;\n  }\n\n  Object.defineProperty(RawTexture2DArray.prototype, \"depth\", {\n    /**\n     * Gets the number of layers of the texture\n     */\n    get: function get() {\n      return this._depth;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Update the texture with new data\n   * @param data defines the data to store in the texture\n   */\n\n  RawTexture2DArray.prototype.update = function (data) {\n    if (!this._texture) {\n      return;\n    }\n\n    this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  };\n  /**\n   * Creates a RGBA texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param depth defines the number of layers of the texture\n   * @param scene defines the scene the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the RGBA texture\n   */\n\n\n  RawTexture2DArray.CreateRGBATexture = function (data, width, height, depth, scene, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);\n  };\n\n  return RawTexture2DArray;\n}(Texture);\n\nexport { RawTexture2DArray };","map":{"version":3,"mappings":";;AAAA,SAASA,OAAT,QAAwB,cAAxB;AAEA,OAAO,+CAAP;AAIA;;;;AAGA;AAAA;AAAA;AAAuCC;AAUnC;;;;;;;;;;;;;;;AAaA,6BACIC,IADJ,EAEIC,KAFJ,EAGIC,MAHJ,EAIIC,KAJJ;AAKI;AACOC,QANX,EAOIC,KAPJ,EAQIC,eARJ,EASIC,OATJ,EAUIC,YAVJ,EAWIC,WAXJ,EAWoD;AAHhD;AAAAH;AAA+B;;AAC/B;AAAAC;AAAwB;;AACxB;AAAAC,qBAAuBV,OAAO,CAACY,sBAA/B;AAAqD;;AACrD;AAAAD,oBAAc,CAAd;AAAc;;AAXlB,gBAaIE,kBAAM,IAAN,EAAYN,KAAZ,EAAmB,CAACC,eAApB,EAAqCC,OAArC,KAA6C,IAbjD;;AAMWK;AASPA,SAAI,CAACC,QAAL,GAAgBR,KAAK,CAACS,SAAN,GAAkBC,uBAAlB,CAA0Cf,IAA1C,EAAgDC,KAAhD,EAAuDC,MAAvD,EAA+DC,KAA/D,EAAsEC,MAAtE,EAA8EE,eAA9E,EAA+FC,OAA/F,EAAwGC,YAAxG,EAAsH,IAAtH,EAA4HC,WAA5H,CAAhB;AAEAG,SAAI,CAACI,MAAL,GAAcb,KAAd;AACAS,SAAI,CAACK,SAAL,GAAiB,IAAjB;;AACH;;AApCDC,wBAAWC,2BAAX,EAAW,OAAX,EAAgB;AAHhB;;;SAGA;AACI,aAAO,KAAKH,MAAZ;AACH,KAFe;qBAAA;;AAAA,GAAhB;AAsCA;;;;;AAIOG,uCAAP,UAAcnB,IAAd,EAAmC;AAC/B,QAAI,CAAC,KAAKa,QAAV,EAAoB;AAChB;AACH;;AACD,SAAKO,UAAL,GAAmBC,uBAAnB,CAA2C,KAAKR,QAAhD,EAA0Db,IAA1D,EAAgE,KAAKa,QAAL,CAAcT,MAA9E,EAAsF,KAAKS,QAAL,CAAeN,OAArG,EAA8G,IAA9G,EAAoH,KAAKM,QAAL,CAAcS,IAAlI;AACH,GALM;AAOP;;;;;;;;;;;;;;;AAacH,wCAAd,UACInB,IADJ,EAEIC,KAFJ,EAGIC,MAHJ,EAIIC,KAJJ,EAKIE,KALJ,EAMIC,eANJ,EAOIC,OAPJ,EAQIC,YARJ,EASIc,IATJ,EASqD;AAHjD;AAAAhB;AAA+B;;AAC/B;AAAAC;AAAwB;;AACxB;AAAAC,qBAAuB,CAAvB;AAAuB;;AACvB;AAAAc,aAAe,CAAf;AAAe;;AAEf,WAAO,IAAIH,iBAAJ,CAAsBnB,IAAtB,EAA4BC,KAA5B,EAAmCC,MAAnC,EAA2CC,KAA3C,EAAkD,CAAlD,EAAkDE,KAAlD,EAA4DC,eAA5D,EAA4DC,OAA5D,EAAqFC,YAArF,EAAuFc,IAAvF,CAAP;AACH,GAZa;;AAalB;AAAC,CAjFD,CAAuCxB,OAAvC","names":["Texture","__extends","data","width","height","depth","format","scene","generateMipMaps","invertY","samplingMode","textureType","TRILINEAR_SAMPLINGMODE","_super","_this","_texture","getEngine","createRawTexture2DArray","_depth","is2DArray","Object","RawTexture2DArray","_getEngine","updateRawTexture2DArray","type"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/rawTexture2DArray.ts"],"sourcesContent":["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     */\r\n    constructor(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture!.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}