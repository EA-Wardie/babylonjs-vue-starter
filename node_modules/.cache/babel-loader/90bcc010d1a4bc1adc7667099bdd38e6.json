{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport \"@babylonjs/core/Meshes/thinInstanceMesh.js\";\nvar NAME = \"EXT_mesh_gpu_instancing\";\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1691)\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\n * !!! Experimental Extension Subject to Changes !!!\n */\n\nvar EXT_mesh_gpu_instancing =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function EXT_mesh_gpu_instancing(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  EXT_mesh_gpu_instancing.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /**\n   * @param context\n   * @param node\n   * @param assign\n   * @hidden\n   */\n\n\n  EXT_mesh_gpu_instancing.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      _this._loader._disableInstancedMesh++;\n\n      var promise = _this._loader.loadNodeAsync(\"/nodes/\".concat(node.index), node, assign);\n\n      _this._loader._disableInstancedMesh--;\n\n      if (!node._primitiveBabylonMeshes) {\n        return promise;\n      }\n\n      var promises = new Array();\n      var instanceCount = 0;\n\n      var loadAttribute = function loadAttribute(attribute) {\n        if (extension.attributes[attribute] == undefined) {\n          promises.push(Promise.resolve(null));\n          return;\n        }\n\n        var accessor = ArrayItem.Get(\"\".concat(extensionContext, \"/attributes/\").concat(attribute), _this._loader.gltf.accessors, extension.attributes[attribute]);\n        promises.push(_this._loader._loadFloatAccessorAsync(\"/accessors/\".concat(accessor.bufferView), accessor));\n\n        if (instanceCount === 0) {\n          instanceCount = accessor.count;\n        } else if (instanceCount !== accessor.count) {\n          throw new Error(\"\".concat(extensionContext, \"/attributes: Instance buffer accessors do not have the same count.\"));\n        }\n      };\n\n      loadAttribute(\"TRANSLATION\");\n      loadAttribute(\"ROTATION\");\n      loadAttribute(\"SCALE\");\n      return promise.then(function (babylonTransformNode) {\n        return Promise.all(promises).then(function (_a) {\n          var translationBuffer = _a[0],\n              rotationBuffer = _a[1],\n              scaleBuffer = _a[2];\n          var matrices = new Float32Array(instanceCount * 16);\n          TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\n\n          TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\n\n          TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\n\n          for (var i = 0; i < instanceCount; ++i) {\n            translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\n            rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\n            scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\n            Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\n            TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\n          }\n\n          for (var _i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {\n            var babylonMesh = _b[_i];\n            babylonMesh.thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\n          }\n\n          return babylonTransformNode;\n        });\n      });\n    });\n  };\n\n  return EXT_mesh_gpu_instancing;\n}();\n\nexport { EXT_mesh_gpu_instancing };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new EXT_mesh_gpu_instancing(loader);\n});","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","GLTFLoader","ArrayItem","NAME","loader","_loader","enabled","isExtensionUsed","EXT_mesh_gpu_instancing","context","node","assign","LoadExtensionAsync","name","extensionContext","extension","_this","_disableInstancedMesh","promise","loadNodeAsync","index","_primitiveBabylonMeshes","promises","Array","instanceCount","loadAttribute","attribute","attributes","undefined","push","Promise","resolve","accessor","Get","concat","gltf","accessors","_loadFloatAccessorAsync","bufferView","count","Error","then","babylonTransformNode","all","_a","translationBuffer","rotationBuffer","scaleBuffer","matrices","Float32Array","copyFromFloats","i","FromArrayToRef","ComposeToRef","copyToArray","_i","babylonMesh","thinInstanceSetBuffer","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\n\r\nimport type { IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\n\r\nimport \"core/Meshes/thinInstanceMesh\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1691)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\nexport class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param node\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshGpuInstancing, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            this._loader._disableInstancedMesh++;\r\n\r\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\r\n\r\n            this._loader._disableInstancedMesh--;\r\n\r\n            if (!node._primitiveBabylonMeshes) {\r\n                return promise;\r\n            }\r\n\r\n            const promises = new Array<Promise<Nullable<Float32Array>>>();\r\n            let instanceCount = 0;\r\n\r\n            const loadAttribute = (attribute: string) => {\r\n                if (extension.attributes[attribute] == undefined) {\r\n                    promises.push(Promise.resolve(null));\r\n                    return;\r\n                }\r\n\r\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\r\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\r\n\r\n                if (instanceCount === 0) {\r\n                    instanceCount = accessor.count;\r\n                } else if (instanceCount !== accessor.count) {\r\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"TRANSLATION\");\r\n            loadAttribute(\"ROTATION\");\r\n            loadAttribute(\"SCALE\");\r\n\r\n            return promise.then((babylonTransformNode) => {\r\n                return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {\r\n                    const matrices = new Float32Array(instanceCount * 16);\r\n\r\n                    TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\r\n                    TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\r\n                    TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\r\n\r\n                    for (let i = 0; i < instanceCount; ++i) {\r\n                        translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\r\n                        rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\r\n                        scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\r\n\r\n                        Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\r\n\r\n                        TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\r\n                    }\r\n\r\n                    for (const babylonMesh of node._primitiveBabylonMeshes!) {\r\n                        (babylonMesh as Mesh).thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\r\n                    }\r\n\r\n                    return babylonTransformNode;\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_mesh_gpu_instancing(loader));\r\n"]},"metadata":{},"sourceType":"module"}