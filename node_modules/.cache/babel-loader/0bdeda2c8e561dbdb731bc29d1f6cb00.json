{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\nimport { Material } from \"../../../Materials/material.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture.js\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent.js\";\nimport \"../../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../../../Shaders/procedural.vertex.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { DrawWrapper } from \"../../drawWrapper.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\n */\n\nvar ProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(ProceduralTexture, _super);\n  /**\n   * Instantiates a new procedural texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * This is the base class of any Procedural texture and contains most of the shareable code.\n   * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\n   * @param name  Define the name of the texture\n   * @param size Define the size of the texture to create\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n   * @param textureType The FBO internal texture type\n   */\n\n\n  function ProceduralTexture(name, size, fragment, scene, fallbackTexture, generateMipMaps, isCube, textureType) {\n    if (fallbackTexture === void 0) {\n      fallbackTexture = null;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (isCube === void 0) {\n      isCube = false;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n    /**\n     * Define if the texture is enabled or not (disabled texture will not render)\n     */\n\n\n    _this.isEnabled = true;\n    /**\n     * Define if the texture must be cleared before rendering (default is true)\n     */\n\n    _this.autoClear = true;\n    /**\n     * Event raised when the texture is generated\n     */\n\n    _this.onGeneratedObservable = new Observable();\n    /**\n     * Event raised before the texture is generated\n     */\n\n    _this.onBeforeGenerationObservable = new Observable();\n    /**\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\n     */\n\n    _this.nodeMaterialSource = null;\n    /** @hidden */\n\n    _this._textures = {};\n    _this._currentRefreshId = -1;\n    _this._frameId = -1;\n    _this._refreshRate = 1;\n    _this._vertexBuffers = {};\n    _this._uniforms = new Array();\n    _this._samplers = new Array();\n    _this._floats = {};\n    _this._ints = {};\n    _this._floatsArrays = {};\n    _this._colors3 = {};\n    _this._colors4 = {};\n    _this._vectors2 = {};\n    _this._vectors3 = {};\n    _this._matrices = {};\n    _this._fallbackTextureUsed = false;\n    _this._cachedDefines = null;\n    _this._contentUpdateId = -1;\n    _this._rtWrapper = null;\n    scene = _this.getScene() || EngineStore.LastCreatedScene;\n\n    var component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n\n      scene._addComponent(component);\n    }\n\n    scene.proceduralTextures.push(_this);\n    _this._fullEngine = scene.getEngine();\n    _this.name = name;\n    _this.isRenderTarget = true;\n    _this._size = size;\n    _this._textureType = textureType;\n    _this._generateMipMaps = generateMipMaps;\n    _this._drawWrapper = new DrawWrapper(_this._fullEngine);\n\n    _this.setFragment(fragment);\n\n    _this._fallbackTexture = fallbackTexture;\n\n    var rtWrapper = _this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n\n    _this._texture = rtWrapper.texture; // VBO\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    _this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(_this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n\n    _this._createIndexBuffer();\n\n    return _this;\n  }\n\n  ProceduralTexture.prototype._createRtWrapper = function (isCube, size, generateMipMaps, textureType) {\n    if (isCube) {\n      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n      this.setFloat(\"face\", 0);\n    } else {\n      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n    }\n\n    return this._rtWrapper;\n  };\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the the postprocess.\n   */\n\n\n  ProceduralTexture.prototype.getEffect = function () {\n    return this._drawWrapper.effect;\n  };\n  /**\n   * @param effect\n   * @hidden*\n   */\n\n\n  ProceduralTexture.prototype._setEffect = function (effect) {\n    this._drawWrapper.effect = effect;\n  };\n  /**\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\n   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n   */\n\n\n  ProceduralTexture.prototype.getContent = function () {\n    var _this = this;\n\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n\n    if (this._contentData) {\n      this._contentData.then(function (buffer) {\n        _this._contentData = _this.readPixels(0, 0, buffer);\n        _this._contentUpdateId = _this._frameId;\n      });\n    } else {\n      this._contentData = this.readPixels(0, 0);\n      this._contentUpdateId = this._frameId;\n    }\n\n    return this._contentData;\n  };\n\n  ProceduralTexture.prototype._createIndexBuffer = function () {\n    var engine = this._fullEngine; // Indices\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  };\n  /** @hidden */\n\n\n  ProceduralTexture.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  };\n  /**\n   * Resets the texture in order to recreate its associated resources.\n   * This can be called in case of context loss\n   */\n\n\n  ProceduralTexture.prototype.reset = function () {\n    var _a;\n\n    (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.dispose();\n  };\n\n  ProceduralTexture.prototype._getDefines = function () {\n    return \"\";\n  };\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n\n\n  ProceduralTexture.prototype.isReady = function () {\n    var _this = this;\n\n    var engine = this._fullEngine;\n    var shaders;\n\n    if (this.nodeMaterialSource) {\n      return this._drawWrapper.effect.isReady();\n    }\n\n    if (!this._fragment) {\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n\n    if (!this._texture) {\n      return false;\n    }\n\n    var defines = this._getDefines();\n\n    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n      return true;\n    }\n\n    if (this._fragment.fragmentElement !== undefined) {\n      shaders = {\n        vertex: \"procedural\",\n        fragmentElement: this._fragment.fragmentElement\n      };\n    } else {\n      shaders = {\n        vertex: \"procedural\",\n        fragment: this._fragment\n      };\n    }\n\n    if (this._cachedDefines !== defines) {\n      this._cachedDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, function () {\n        var _a;\n\n        (_a = _this._rtWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n        _this._rtWrapper = _this._texture = null;\n\n        if (_this._fallbackTexture) {\n          _this._texture = _this._fallbackTexture._texture;\n\n          if (_this._texture) {\n            _this._texture.incrementReferences();\n          }\n        }\n\n        _this._fallbackTextureUsed = true;\n      });\n    }\n\n    return this._drawWrapper.effect.isReady();\n  };\n  /**\n   * Resets the refresh counter of the texture and start bak from scratch.\n   * Could be useful to regenerate the texture if it is setup to render only once.\n   */\n\n\n  ProceduralTexture.prototype.resetRefreshCounter = function () {\n    this._currentRefreshId = -1;\n  };\n  /**\n   * Set the fragment shader to use in order to render the texture.\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n   */\n\n\n  ProceduralTexture.prototype.setFragment = function (fragment) {\n    this._fragment = fragment;\n  };\n\n  Object.defineProperty(ProceduralTexture.prototype, \"refreshRate\", {\n    /**\n     * Define the refresh rate of the texture or the rendering frequency.\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n     */\n    get: function get() {\n      return this._refreshRate;\n    },\n    set: function set(value) {\n      this._refreshRate = value;\n      this.resetRefreshCounter();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  ProceduralTexture.prototype._shouldRender = function () {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    this._currentRefreshId++;\n    return false;\n  };\n  /**\n   * Get the size the texture is rendering at.\n   * @returns the size (on cube texture it is always squared)\n   */\n\n\n  ProceduralTexture.prototype.getRenderSize = function () {\n    return this._size;\n  };\n  /**\n   * Resize the texture to new value.\n   * @param size Define the new size the texture should have\n   * @param generateMipMaps Define whether the new texture should create mip maps\n   */\n\n\n  ProceduralTexture.prototype.resize = function (size, generateMipMaps) {\n    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n      return;\n    }\n\n    var isCube = this._texture.isCube;\n\n    this._rtWrapper.dispose();\n\n    var rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n\n    this._texture = rtWrapper.texture; // Update properties\n\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  };\n\n  ProceduralTexture.prototype._checkUniform = function (uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  };\n  /**\n   * Set a texture in the shader program used to render.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setTexture = function (name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n\n    this._textures[name] = texture;\n    return this;\n  };\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setFloat = function (name, value) {\n    this._checkUniform(name);\n\n    this._floats[name] = value;\n    return this;\n  };\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setInt = function (name, value) {\n    this._checkUniform(name);\n\n    this._ints[name] = value;\n    return this;\n  };\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setFloats = function (name, value) {\n    this._checkUniform(name);\n\n    this._floatsArrays[name] = value;\n    return this;\n  };\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setColor3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3[name] = value;\n    return this;\n  };\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setColor4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4[name] = value;\n    return this;\n  };\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setVector2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2[name] = value;\n    return this;\n  };\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setVector3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3[name] = value;\n    return this;\n  };\n  /**\n   * Set a mat4 in the shader from a MAtrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @return the texture itself allowing \"fluent\" like uniform updates\n   */\n\n\n  ProceduralTexture.prototype.setMatrix = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices[name] = value;\n    return this;\n  };\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    var _a, _b;\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = this._fullEngine; // Render\n\n    engine.enableEffect(this._drawWrapper);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (var name_1 in this._textures) {\n        this._drawWrapper.effect.setTexture(name_1, this._textures[name_1]);\n      } // Float\n\n\n      for (var name_2 in this._ints) {\n        this._drawWrapper.effect.setInt(name_2, this._ints[name_2]);\n      } // Float\n\n\n      for (var name_3 in this._floats) {\n        this._drawWrapper.effect.setFloat(name_3, this._floats[name_3]);\n      } // Floats\n\n\n      for (var name_4 in this._floatsArrays) {\n        this._drawWrapper.effect.setArray(name_4, this._floatsArrays[name_4]);\n      } // Color3\n\n\n      for (var name_5 in this._colors3) {\n        this._drawWrapper.effect.setColor3(name_5, this._colors3[name_5]);\n      } // Color4\n\n\n      for (var name_6 in this._colors4) {\n        var color = this._colors4[name_6];\n\n        this._drawWrapper.effect.setFloat4(name_6, color.r, color.g, color.b, color.a);\n      } // Vector2\n\n\n      for (var name_7 in this._vectors2) {\n        this._drawWrapper.effect.setVector2(name_7, this._vectors2[name_7]);\n      } // Vector3\n\n\n      for (var name_8 in this._vectors3) {\n        this._drawWrapper.effect.setVector3(name_8, this._vectors3[name_8]);\n      } // Matrix\n\n\n      for (var name_9 in this._matrices) {\n        this._drawWrapper.effect.setMatrix(name_9, this._matrices[name_9]);\n      }\n    }\n\n    if (!this._texture || !this._rtWrapper) {\n      return;\n    }\n\n    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"procedural texture generation for \".concat(this.name), 1);\n\n    if (this.isCube) {\n      for (var face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true); // VBOs\n\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n\n        this._drawWrapper.effect.setFloat(\"face\", face); // Clear\n\n\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        } // Draw order\n\n\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      }\n    } else {\n      engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true); // VBOs\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect); // Clear\n\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      } // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Unbind\n\n\n    engine.unBindFramebuffer(this._rtWrapper, this.isCube); // Mipmaps\n\n    if (this.isCube) {\n      engine.generateMipMapsForCubemap(this._texture);\n    }\n\n    (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n\n    this.onGeneratedObservable.notifyObservers(this);\n  };\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n\n\n  ProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n\n  ProceduralTexture.prototype.dispose = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var index = scene.proceduralTextures.indexOf(this);\n\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\n\n  return ProceduralTexture;\n}(Texture);\n\nexport { ProceduralTexture };\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);","map":{"version":3,"mappings":"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","names":["serialize","Observable","VertexBuffer","SceneComponentConstants","Material","Texture","RenderTargetTexture","ProceduralTextureSceneComponent","RegisterClass","EngineStore","DrawWrapper","__extends","name","size","fragment","scene","fallbackTexture","generateMipMaps","isCube","textureType","_super","_this","Array","getScene","LastCreatedScene","component","_getComponent","NAME_PROCEDURALTEXTURE","_addComponent","proceduralTextures","push","_fullEngine","getEngine","isRenderTarget","_size","_textureType","_generateMipMaps","_drawWrapper","setFragment","_fallbackTexture","rtWrapper","_createRtWrapper","_texture","texture","vertices","_vertexBuffers","PositionKind","_createIndexBuffer","ProceduralTexture","_rtWrapper","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","type","setFloat","createRenderTargetTexture","effect","_contentData","_frameId","_contentUpdateId","then","buffer","readPixels","engine","indices","_indexBuffer","createIndexBuffer","vb","_rebuild","refreshRate","REFRESHRATE_RENDER_ONCE","_a","dispose","shaders","nodeMaterialSource","isReady","_fragment","_fallbackTextureUsed","defines","_getDefines","_cachedDefines","fragmentElement","undefined","vertex","createEffect","_uniforms","_samplers","incrementReferences","_currentRefreshId","Object","_refreshRate","value","resetRefreshCounter","isEnabled","uniformName","indexOf","_textures","_checkUniform","_floats","_ints","_floatsArrays","_colors3","_colors4","_vectors2","_vectors3","_matrices","useCameraPostProcess","enableEffect","onBeforeGenerationObservable","notifyObservers","setState","name_1","setTexture","name_2","setInt","name_3","name_4","setArray","name_5","setColor3","name_6","color","setFloat4","r","g","b","a","name_7","setVector2","name_8","setVector3","name_9","setMatrix","_debugPushGroup","face","bindFramebuffer","bindBuffers","autoClear","clear","clearColor","drawElementsType","TriangleFillMode","unBindFramebuffer","generateMipMapsForCubemap","_debugPopGroup","_b","onGenerated","onGeneratedObservable","textureSize","getSize","newTexture","width","hasAlpha","level","coordinatesMode","index","splice","vertexBuffer","_releaseBuffer","call","__decorate"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Procedurals/proceduralTexture.ts"],"sourcesContent":["import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @hidden */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @hidden */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @hidden */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @hidden*\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n        let shaders;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        } else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\r\n                this._rtWrapper?.dispose();\r\n                this._rtWrapper = this._texture = null;\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind\r\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n"]},"metadata":{},"sourceType":"module"}