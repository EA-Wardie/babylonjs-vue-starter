{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport { __extends } from \"tslib\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\n/**\n * Base class of materials working in push mode in babylon JS\n * @hidden\n */\n\nvar PushMaterial =\n/** @class */\nfunction (_super) {\n  __extends(PushMaterial, _super);\n\n  function PushMaterial(name, scene, storeEffectOnSubMeshes) {\n    if (storeEffectOnSubMeshes === void 0) {\n      storeEffectOnSubMeshes = true;\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._normalMatrix = new Matrix();\n    _this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\n    return _this;\n  }\n\n  PushMaterial.prototype.getEffect = function () {\n    return this._storeEffectOnSubMeshes ? this._activeEffect : _super.prototype.getEffect.call(this);\n  };\n\n  PushMaterial.prototype.isReady = function (mesh, useInstances) {\n    if (!mesh) {\n      return false;\n    }\n\n    if (!this._storeEffectOnSubMeshes) {\n      return true;\n    }\n\n    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n      return true;\n    }\n\n    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n  };\n\n  PushMaterial.prototype._isReadyForSubMesh = function (subMesh) {\n    var defines = subMesh.materialDefines;\n\n    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\n      if (defines._renderId === this.getScene().getRenderId()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Binds the given world matrix to the active effect\n   *\n   * @param world the matrix to bind\n   */\n\n\n  PushMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n    this._activeEffect.setMatrix(\"world\", world);\n  };\n  /**\n   * Binds the given normal matrix to the active effect\n   *\n   * @param normalMatrix the matrix to bind\n   */\n\n\n  PushMaterial.prototype.bindOnlyNormalMatrix = function (normalMatrix) {\n    this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\n  };\n\n  PushMaterial.prototype.bind = function (world, mesh) {\n    if (!mesh) {\n      return;\n    }\n\n    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n  };\n\n  PushMaterial.prototype._afterBind = function (mesh, effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    _super.prototype._afterBind.call(this, mesh, effect);\n\n    this.getScene()._cachedEffect = effect;\n  };\n\n  PushMaterial.prototype._mustRebind = function (scene, effect, visibility) {\n    if (visibility === void 0) {\n      visibility = 1;\n    }\n\n    return scene.isCachedMaterialInvalid(this, effect, visibility);\n  };\n\n  return PushMaterial;\n}(Material);\n\nexport { PushMaterial };","map":{"version":3,"mappings":";;AAEA,SAASA,MAAT,QAAuB,yBAAvB;AAGA,SAASC,QAAT,QAAyB,0BAAzB;AAGA;;;;;AAIA;AAAA;AAAA;AAAkCC;;AAK9B,wBAAYC,IAAZ,EAA0BC,KAA1B,EAAyCC,sBAAzC,EAAsE;AAA7B;AAAAA;AAA6B;;AAAtE,gBACIC,kBAAMH,IAAN,EAAYC,KAAZ,KAAkB,IADtB;;AAFUG,0BAAwB,IAAIP,MAAJ,EAAxB;AAINO,SAAI,CAACC,uBAAL,GAA+BH,sBAA/B;;AACH;;AAEMI,qCAAP;AACI,WAAO,KAAKD,uBAAL,GAA+B,KAAKE,aAApC,GAAoDJ,iBAAMK,SAAN,CAAeC,IAAf,CAAe,IAAf,CAA3D;AACH,GAFM;;AAIAH,mCAAP,UAAeI,IAAf,EAAoCC,YAApC,EAA0D;AACtD,QAAI,CAACD,IAAL,EAAW;AACP,aAAO,KAAP;AACH;;AAED,QAAI,CAAC,KAAKL,uBAAV,EAAmC;AAC/B,aAAO,IAAP;AACH;;AAED,QAAI,CAACK,IAAI,CAACE,SAAN,IAAmBF,IAAI,CAACE,SAAL,CAAeC,MAAf,KAA0B,CAAjD,EAAoD;AAChD,aAAO,IAAP;AACH;;AAED,WAAO,KAAKC,iBAAL,CAAuBJ,IAAvB,EAA6BA,IAAI,CAACE,SAAL,CAAe,CAAf,CAA7B,EAAgDD,YAAhD,CAAP;AACH,GAdM;;AAgBGL,8CAAV,UAA6BS,OAA7B,EAA6C;AACzC,QAAMC,OAAO,GAAGD,OAAO,CAACE,eAAxB;;AACA,QAAI,CAAC,KAAKC,qBAAN,IAA+BH,OAAO,CAACI,MAAvC,IAAiDH,OAArD,EAA8D;AAC1D,UAAIA,OAAO,CAACI,SAAR,KAAsB,KAAKC,QAAL,GAAgBC,WAAhB,EAA1B,EAAyD;AACrD,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH,GATS;AAWV;;;;;;;AAKOhB,+CAAP,UAA2BiB,KAA3B,EAAwC;AACpC,SAAKhB,aAAL,CAAmBiB,SAAnB,CAA6B,OAA7B,EAAsCD,KAAtC;AACH,GAFM;AAIP;;;;;;;AAKOjB,gDAAP,UAA4BmB,YAA5B,EAAgD;AAC5C,SAAKlB,aAAL,CAAmBiB,SAAnB,CAA6B,cAA7B,EAA6CC,YAA7C;AACH,GAFM;;AAIAnB,gCAAP,UAAYiB,KAAZ,EAA2Bb,IAA3B,EAAsC;AAClC,QAAI,CAACA,IAAL,EAAW;AACP;AACH;;AAED,SAAKgB,cAAL,CAAoBH,KAApB,EAA2Bb,IAA3B,EAAiCA,IAAI,CAACE,SAAL,CAAe,CAAf,CAAjC;AACH,GANM;;AAQGN,sCAAV,UAAqBI,IAArB,EAAkCS,MAAlC,EAAiE;AAA/B;AAAAA;AAA+B;;AAC7DhB,qBAAMwB,UAAN,CAAgBlB,IAAhB,CAAgB,IAAhB,EAAiBC,IAAjB,EAAuBS,MAAvB;;AACA,SAAKE,QAAL,GAAgBO,aAAhB,GAAgCT,MAAhC;AACH,GAHS;;AAKAb,uCAAV,UAAsBL,KAAtB,EAAoCkB,MAApC,EAAoDU,UAApD,EAA0E;AAAtB;AAAAA;AAAsB;;AACtE,WAAO5B,KAAK,CAAC6B,uBAAN,CAA8B,IAA9B,EAAoCX,MAApC,EAA4CU,UAA5C,CAAP;AACH,GAFS;;AAGd;AAAC,CA3ED,CAAkC/B,QAAlC","names":["Matrix","Material","__extends","name","scene","storeEffectOnSubMeshes","_super","_this","_storeEffectOnSubMeshes","PushMaterial","_activeEffect","getEffect","call","mesh","useInstances","subMeshes","length","isReadyForSubMesh","subMesh","defines","materialDefines","checkReadyOnEveryCall","effect","_renderId","getScene","getRenderId","world","setMatrix","normalMatrix","bindForSubMesh","_afterBind","_cachedEffect","visibility","isCachedMaterialInvalid"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/pushMaterial.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\r\nexport class PushMaterial extends Material {\r\n    protected _activeEffect: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene?: Scene, storeEffectOnSubMeshes = true) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect()!;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._storeEffectOnSubMeshes) {\r\n            return true;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds the given world matrix to the active effect\r\n     *\r\n     * @param world the matrix to bind\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null): void {\r\n        super._afterBind(mesh, effect);\r\n        this.getScene()._cachedEffect = effect;\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, visibility: number = 1) {\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}