{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { Color4, Color3 } from \"../Maths/math.js\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/** Defines the 4 color options */\n\nexport var PointColor;\n\n(function (PointColor) {\n  /** color value */\n  PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n  /** uv value */\n\n  PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n  /** random value */\n\n  PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n  /** stated value */\n\n  PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\n\n\nvar PointsCloudSystem =\n/** @class */\nfunction () {\n  /**\n   * Creates a PCS (Points Cloud System) object\n   * @param name (String) is the PCS name, this will be the underlying mesh name\n   * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n   * @param scene (Scene) is the scene in which the PCS is added\n   * @param options defines the options of the PCS e.g.\n   * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n   * @param options.updatable\n   */\n  function PointsCloudSystem(name, pointSize, scene, options) {\n    /**\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n     *  Example : var p = SPS.particles[i];\n     */\n    this.particles = new Array();\n    /**\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n     */\n\n    this.nbParticles = 0;\n    /**\n     * This a counter for your own usage. It's not set by any SPS functions.\n     */\n\n    this.counter = 0;\n    /**\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n     * Please read :\n     */\n\n    this.vars = {};\n    this._promises = [];\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._updatable = true;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._groups = new Array(); //start indices for each group of particles\n\n    this._groupCounter = 0;\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeBoundingBox = false;\n    this._isReady = false;\n    this.name = name;\n    this._size = pointSize;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n  }\n  /**\n   * Builds the PCS underlying mesh. Returns a standard Mesh.\n   * If no points were added to the PCS, the returned mesh is just a single point.\n   * @param material The material to use to render the mesh. If not provided, will create a default one\n   * @returns a promise for the created mesh\n   */\n\n\n  PointsCloudSystem.prototype.buildMeshAsync = function (material) {\n    var _this = this;\n\n    return Promise.all(this._promises).then(function () {\n      _this._isReady = true;\n      return _this._buildMesh(material);\n    });\n  };\n  /**\n   * @param material\n   * @hidden\n   */\n\n\n  PointsCloudSystem.prototype._buildMesh = function (material) {\n    if (this.nbParticles === 0) {\n      this.addPoints(1);\n    }\n\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    var vertexData = new VertexData();\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    var ec = 0; //emissive color value 0 for UVs, 1 for color\n\n    if (this._colors32.length > 0) {\n      ec = 1;\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    var mesh = new Mesh(this.name, this._scene);\n    vertexData.applyToMesh(mesh, this._updatable);\n    this.mesh = mesh; // free memory\n\n    this._positions = null;\n    this._uvs = null;\n    this._colors = null;\n\n    if (!this._updatable) {\n      this.particles.length = 0;\n    }\n\n    var mat = material;\n\n    if (!mat) {\n      mat = new StandardMaterial(\"point cloud material\", this._scene);\n      mat.emissiveColor = new Color3(ec, ec, ec);\n      mat.disableLighting = true;\n      mat.pointsCloud = true;\n      mat.pointSize = this._size;\n    }\n\n    mesh.material = mat;\n    return new Promise(function (resolve) {\n      return resolve(mesh);\n    });\n  }; // adds a new particle object in the particles array\n\n\n  PointsCloudSystem.prototype._addParticle = function (idx, group, groupId, idxInGroup) {\n    var cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n    this.particles.push(cp);\n    return cp;\n  };\n\n  PointsCloudSystem.prototype._randomUnitVector = function (particle) {\n    particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n    particle.color = new Color4(1, 1, 1, 1);\n  };\n\n  PointsCloudSystem.prototype._getColorIndicesForCoord = function (pointsGroup, x, y, width) {\n    var imageData = pointsGroup._groupImageData;\n    var color = y * (width * 4) + x * 4;\n    var colorIndices = [color, color + 1, color + 2, color + 3];\n    var redIndex = colorIndices[0];\n    var greenIndex = colorIndices[1];\n    var blueIndex = colorIndices[2];\n    var alphaIndex = colorIndices[3];\n    var redForCoord = imageData[redIndex];\n    var greenForCoord = imageData[greenIndex];\n    var blueForCoord = imageData[blueIndex];\n    var alphaForCoord = imageData[alphaIndex];\n    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n  };\n\n  PointsCloudSystem.prototype._setPointsColorOrUV = function (mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {\n    if (isVolume) {\n      mesh.updateFacetData();\n    }\n\n    var boundInfo = mesh.getBoundingInfo();\n    var diameter = 2 * boundInfo.boundingSphere.radius;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var place = Vector3.Zero();\n    mesh.computeWorldMatrix();\n    var meshMatrix = mesh.getWorldMatrix();\n\n    if (!meshMatrix.isIdentity()) {\n      meshPos = meshPos.slice(0);\n\n      for (var p = 0; p < meshPos.length / 3; p++) {\n        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n        meshPos[3 * p] = place.x;\n        meshPos[3 * p + 1] = place.y;\n        meshPos[3 * p + 2] = place.z;\n      }\n    }\n\n    var idxPoints = 0;\n    var id0 = 0;\n    var id1 = 0;\n    var id2 = 0;\n    var v0X = 0;\n    var v0Y = 0;\n    var v0Z = 0;\n    var v1X = 0;\n    var v1Y = 0;\n    var v1Z = 0;\n    var v2X = 0;\n    var v2Y = 0;\n    var v2Z = 0;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var uv0X = 0;\n    var uv0Y = 0;\n    var uv1X = 0;\n    var uv1Y = 0;\n    var uv2X = 0;\n    var uv2Y = 0;\n    var uv0 = Vector2.Zero();\n    var uv1 = Vector2.Zero();\n    var uv2 = Vector2.Zero();\n    var uvec0 = Vector2.Zero();\n    var uvec1 = Vector2.Zero();\n    var col0X = 0;\n    var col0Y = 0;\n    var col0Z = 0;\n    var col0A = 0;\n    var col1X = 0;\n    var col1Y = 0;\n    var col1Z = 0;\n    var col1A = 0;\n    var col2X = 0;\n    var col2Y = 0;\n    var col2Z = 0;\n    var col2A = 0;\n    var col0 = Vector4.Zero();\n    var col1 = Vector4.Zero();\n    var col2 = Vector4.Zero();\n    var colvec0 = Vector4.Zero();\n    var colvec1 = Vector4.Zero();\n    var lamda = 0;\n    var mu = 0;\n    range = range ? range : 0;\n    var facetPoint;\n    var uvPoint;\n    var colPoint = new Vector4(0, 0, 0, 0);\n    var norm = Vector3.Zero();\n    var tang = Vector3.Zero();\n    var biNorm = Vector3.Zero();\n    var angle = 0;\n    var facetPlaneVec = Vector3.Zero();\n    var gap = 0;\n    var distance = 0;\n    var ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n    var pickInfo;\n    var direction = Vector3.Zero();\n\n    for (var index = 0; index < meshInd.length / 3; index++) {\n      id0 = meshInd[3 * index];\n      id1 = meshInd[3 * index + 1];\n      id2 = meshInd[3 * index + 2];\n      v0X = meshPos[3 * id0];\n      v0Y = meshPos[3 * id0 + 1];\n      v0Z = meshPos[3 * id0 + 2];\n      v1X = meshPos[3 * id1];\n      v1Y = meshPos[3 * id1 + 1];\n      v1Z = meshPos[3 * id1 + 2];\n      v2X = meshPos[3 * id2];\n      v2Y = meshPos[3 * id2 + 1];\n      v2Z = meshPos[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n\n      if (meshUV) {\n        uv0X = meshUV[2 * id0];\n        uv0Y = meshUV[2 * id0 + 1];\n        uv1X = meshUV[2 * id1];\n        uv1Y = meshUV[2 * id1 + 1];\n        uv2X = meshUV[2 * id2];\n        uv2Y = meshUV[2 * id2 + 1];\n        uv0.set(uv0X, uv0Y);\n        uv1.set(uv1X, uv1Y);\n        uv2.set(uv2X, uv2Y);\n        uv1.subtractToRef(uv0, uvec0);\n        uv2.subtractToRef(uv1, uvec1);\n      }\n\n      if (meshCol && colorFromTexture) {\n        col0X = meshCol[4 * id0];\n        col0Y = meshCol[4 * id0 + 1];\n        col0Z = meshCol[4 * id0 + 2];\n        col0A = meshCol[4 * id0 + 3];\n        col1X = meshCol[4 * id1];\n        col1Y = meshCol[4 * id1 + 1];\n        col1Z = meshCol[4 * id1 + 2];\n        col1A = meshCol[4 * id1 + 3];\n        col2X = meshCol[4 * id2];\n        col2Y = meshCol[4 * id2 + 1];\n        col2Z = meshCol[4 * id2 + 2];\n        col2A = meshCol[4 * id2 + 3];\n        col0.set(col0X, col0Y, col0Z, col0A);\n        col1.set(col1X, col1Y, col1Z, col1A);\n        col2.set(col2X, col2Y, col2Z, col2A);\n        col1.subtractToRef(col0, colvec0);\n        col2.subtractToRef(col1, colvec1);\n      }\n\n      var width = void 0;\n      var height = void 0;\n      var deltaS = void 0;\n      var deltaV = void 0;\n      var h = void 0;\n      var s = void 0;\n      var v = void 0;\n      var hsvCol = void 0;\n      var statedColor = new Color3(0, 0, 0);\n      var colPoint3 = new Color3(0, 0, 0);\n      var pointColors = void 0;\n      var particle = void 0;\n\n      for (var i = 0; i < pointsGroup._groupDensity[index]; i++) {\n        idxPoints = this.particles.length;\n\n        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n\n        particle = this.particles[idxPoints]; //form a point inside the facet v0, v1, v2;\n\n        lamda = Scalar.RandomRange(0, 1);\n        mu = Scalar.RandomRange(0, 1);\n        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n\n        if (isVolume) {\n          norm = mesh.getFacetNormal(index).normalize().scale(-1);\n          tang = vec0.clone().normalize();\n          biNorm = Vector3.Cross(norm, tang);\n          angle = Scalar.RandomRange(0, 2 * Math.PI);\n          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n          angle = Scalar.RandomRange(0.1, Math.PI / 2);\n          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n          ray.origin = facetPoint.add(direction.scale(0.00001));\n          ray.direction = direction;\n          ray.length = diameter;\n          pickInfo = ray.intersectsMesh(mesh);\n\n          if (pickInfo.hit) {\n            distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n            gap = Scalar.RandomRange(0, 1) * distance;\n            facetPoint.addInPlace(direction.scale(gap));\n          }\n        }\n\n        particle.position = facetPoint.clone();\n\n        this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n\n        if (colorFromTexture !== undefined) {\n          if (meshUV) {\n            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n\n            if (colorFromTexture) {\n              //Set particle color to texture color\n              if (hasTexture && pointsGroup._groupImageData !== null) {\n                width = pointsGroup._groupImgWidth;\n                height = pointsGroup._groupImgHeight;\n                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                particle.color = pointColors;\n\n                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n              } else {\n                if (meshCol) {\n                  //failure in texture and colors available\n                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                } else {\n                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n              }\n            } else {\n              //Set particle uv based on a mesh uv\n              particle.uv = uvPoint.clone();\n\n              this._uvs.push(particle.uv.x, particle.uv.y);\n            }\n          }\n        } else {\n          if (color) {\n            statedColor.set(color.r, color.g, color.b);\n            deltaS = Scalar.RandomRange(-range, range);\n            deltaV = Scalar.RandomRange(-range, range);\n            hsvCol = statedColor.toHSV();\n            h = hsvCol.r;\n            s = hsvCol.g + deltaS;\n            v = hsvCol.b + deltaV;\n\n            if (s < 0) {\n              s = 0;\n            }\n\n            if (s > 1) {\n              s = 1;\n            }\n\n            if (v < 0) {\n              v = 0;\n            }\n\n            if (v > 1) {\n              v = 1;\n            }\n\n            Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n          } else {\n            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n          }\n\n          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n        }\n      }\n    }\n  }; // stores mesh texture in dynamic texture for color pixel retrieval\n  // when pointColor type is color for surface points\n\n\n  PointsCloudSystem.prototype._colorFromTexture = function (mesh, pointsGroup, isVolume) {\n    var _this = this;\n\n    if (mesh.material === null) {\n      Logger.Warn(mesh.name + \"has no material.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var mat = mesh.material;\n    var textureList = mat.getActiveTextures();\n\n    if (textureList.length === 0) {\n      Logger.Warn(mesh.name + \"has no usable texture.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var clone = mesh.clone();\n    clone.setEnabled(false);\n\n    this._promises.push(new Promise(function (resolve) {\n      BaseTexture.WhenAllReady(textureList, function () {\n        var n = pointsGroup._textureNb;\n\n        if (n < 0) {\n          n = 0;\n        }\n\n        if (n > textureList.length - 1) {\n          n = textureList.length - 1;\n        }\n\n        var finalize = function finalize() {\n          pointsGroup._groupImgWidth = textureList[n].getSize().width;\n          pointsGroup._groupImgHeight = textureList[n].getSize().height;\n\n          _this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\n\n          clone.dispose();\n          resolve();\n        };\n\n        pointsGroup._groupImageData = null;\n        var dataPromise = textureList[n].readPixels();\n\n        if (!dataPromise) {\n          finalize();\n        } else {\n          dataPromise.then(function (data) {\n            pointsGroup._groupImageData = data;\n            finalize();\n          });\n        }\n      });\n    }));\n  }; // calculates the point density per facet of a mesh for surface points\n\n\n  PointsCloudSystem.prototype._calculateDensity = function (nbPoints, positions, indices) {\n    var density = new Array();\n    var id0;\n    var id1;\n    var id2;\n    var v0X;\n    var v0Y;\n    var v0Z;\n    var v1X;\n    var v1Y;\n    var v1Z;\n    var v2X;\n    var v2Y;\n    var v2Z;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var vec2 = Vector3.Zero();\n    var a; //length of side of triangle\n\n    var b; //length of side of triangle\n\n    var c; //length of side of triangle\n\n    var p; //perimeter of triangle\n\n    var area;\n    var areas = new Array();\n    var surfaceArea = 0;\n    var nbFacets = indices.length / 3; //surface area\n\n    for (var index = 0; index < nbFacets; index++) {\n      id0 = indices[3 * index];\n      id1 = indices[3 * index + 1];\n      id2 = indices[3 * index + 2];\n      v0X = positions[3 * id0];\n      v0Y = positions[3 * id0 + 1];\n      v0Z = positions[3 * id0 + 2];\n      v1X = positions[3 * id1];\n      v1Y = positions[3 * id1 + 1];\n      v1Z = positions[3 * id1 + 2];\n      v2X = positions[3 * id2];\n      v2Y = positions[3 * id2 + 1];\n      v2Z = positions[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      vertex2.subtractToRef(vertex0, vec2);\n      a = vec0.length();\n      b = vec1.length();\n      c = vec2.length();\n      p = (a + b + c) / 2;\n      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\n      surfaceArea += area;\n      areas[index] = area;\n    }\n\n    var pointCount = 0;\n\n    for (var index = 0; index < nbFacets; index++) {\n      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);\n      pointCount += density[index];\n    }\n\n    var diff = nbPoints - pointCount;\n    var pointsPerFacet = Math.floor(diff / nbFacets);\n    var extraPoints = diff % nbFacets;\n\n    if (pointsPerFacet > 0) {\n      density = density.map(function (x) {\n        return x + pointsPerFacet;\n      });\n    }\n\n    for (var index = 0; index < extraPoints; index++) {\n      density[index] += 1;\n    }\n\n    return density;\n  };\n  /**\n   * Adds points to the PCS in random positions within a unit sphere\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n   * @returns the number of groups in the system\n   */\n\n\n  PointsCloudSystem.prototype.addPoints = function (nb, pointFunction) {\n    if (pointFunction === void 0) {\n      pointFunction = this._randomUnitVector;\n    }\n\n    var pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n    var cp; // particles\n\n    var idx = this.nbParticles;\n\n    for (var i = 0; i < nb; i++) {\n      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n\n      if (pointsGroup && pointsGroup._positionFunction) {\n        pointsGroup._positionFunction(cp, idx, i);\n      }\n\n      this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n\n      if (cp.color) {\n        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n      }\n\n      if (cp.uv) {\n        this._uvs.push(cp.uv.x, cp.uv.y);\n      }\n\n      idx++;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter;\n  };\n  /**\n   * Adds points to the PCS from the surface of the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n\n\n  PointsCloudSystem.prototype.addSurfacePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\n   * Adds points to the PCS inside the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n\n\n  PointsCloudSystem.prototype.addVolumePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n   *  This method calls `updateParticle()` for each particle of the SPS.\n   *  For an animated SPS, it is usually called within the render loop.\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n   * @returns the PCS.\n   */\n\n\n  PointsCloudSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || !this._isReady) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var uvs32 = this._uvs32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current index of the particle\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n\n    idx = 0; // particle index\n\n    var pindex = 0; //index in positions array\n\n    var cindex = 0; //index in color array\n\n    var uindex = 0; //index in uv array\n    // particle loop\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p];\n      idx = particle.idx;\n      pindex = 3 * idx;\n      cindex = 4 * idx;\n      uindex = 2 * idx; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleGlobalPosition = particle._globalPosition;\n\n      if (this._computeParticleRotation) {\n        particle.getRotationMatrix(rotMatrix);\n      }\n\n      var particleHasParent = particle.parentId !== null;\n\n      if (particleHasParent) {\n        var parent_1 = this.particles[particle.parentId];\n        var parentRotationMatrix = parent_1._rotationMatrix;\n        var parentGlobalPosition = parent_1._globalPosition;\n        var rotatedY_1 = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n        var rotatedX_1 = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n        var rotatedZ_1 = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX_1;\n        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY_1;\n        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ_1;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n        }\n      } else {\n        particleGlobalPosition.x = 0;\n        particleGlobalPosition.y = 0;\n        particleGlobalPosition.z = 0;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0];\n          particleRotationMatrix[1] = rotMatrixValues[1];\n          particleRotationMatrix[2] = rotMatrixValues[2];\n          particleRotationMatrix[3] = rotMatrixValues[4];\n          particleRotationMatrix[4] = rotMatrixValues[5];\n          particleRotationMatrix[5] = rotMatrixValues[6];\n          particleRotationMatrix[6] = rotMatrixValues[8];\n          particleRotationMatrix[7] = rotMatrixValues[9];\n          particleRotationMatrix[8] = rotMatrixValues[10];\n        }\n      }\n\n      var pivotBackTranslation = tempVectors[11];\n\n      if (particle.translateFromPivot) {\n        pivotBackTranslation.setAll(0.0);\n      } else {\n        pivotBackTranslation.copyFrom(particle.pivot);\n      } // positions\n\n\n      var tmpVertex = tempVectors[0];\n      tmpVertex.copyFrom(particle.position);\n      var vertexX = tmpVertex.x - particle.pivot.x;\n      var vertexY = tmpVertex.y - particle.pivot.y;\n      var vertexZ = tmpVertex.z - particle.pivot.z;\n      var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n      var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n      var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n      rotatedX += pivotBackTranslation.x;\n      rotatedY += pivotBackTranslation.y;\n      rotatedZ += pivotBackTranslation.z;\n      var px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n      var py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n      var pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n      if (this._computeBoundingBox) {\n        minimum.minimizeInPlaceFromFloats(px, py, pz);\n        maximum.maximizeInPlaceFromFloats(px, py, pz);\n      }\n\n      if (this._computeParticleColor && particle.color) {\n        var color = particle.color;\n        var colors32_1 = this._colors32;\n        colors32_1[cindex] = color.r;\n        colors32_1[cindex + 1] = color.g;\n        colors32_1[cindex + 2] = color.b;\n        colors32_1[cindex + 3] = color.a;\n      }\n\n      if (this._computeParticleTexture && particle.uv) {\n        var uv = particle.uv;\n        var uvs32_1 = this._uvs32;\n        uvs32_1[uindex] = uv.x;\n        uvs32_1[uindex + 1] = uv.y;\n      }\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n      }\n\n      if (this._computeParticleTexture) {\n        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n      }\n\n      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh.hasBoundingInfo) {\n        mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\n   * Disposes the PCS.\n   */\n\n\n  PointsCloudSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n  };\n  /**\n   * Visibility helper : Recomputes the visible size according to the mesh bounding box\n   * doc :\n   * @returns the PCS.\n   */\n\n\n  PointsCloudSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n   * @param size the size (float) of the visibility box\n   * note : this doesn't lock the PCS mesh bounding box.\n   * doc :\n   */\n\n\n  PointsCloudSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(PointsCloudSystem.prototype, \"isAlwaysVisible\", {\n    /**\n     * Gets whether the PCS is always visible or not\n     * doc :\n     */\n    get: function get() {\n      return this._alwaysVisible;\n    },\n\n    /**\n     * Sets the PCS as always visible or not\n     * doc :\n     */\n    set: function set(val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleRotation\", {\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not\n     * Default value : false. The PCS is faster when it's set to false\n     * Note : particle rotations are only applied to parent particles\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n     */\n    set: function set(val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleColor\", {\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get: function get() {\n      return this._computeParticleColor;\n    },\n\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set: function set(val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleTexture\", {\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get: function get() {\n      return this._computeParticleTexture;\n    },\n    set: function set(val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeBoundingBox\", {\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get: function get() {\n      return this._computeBoundingBox;\n    },\n\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set: function set(val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by users to fit their needs\n\n  /**\n   * This function does nothing. It may be overwritten to set all the particle first values.\n   * The PCS doesn't call this function, you may have to call it by your own.\n   * doc :\n   */\n\n  PointsCloudSystem.prototype.initParticles = function () {};\n  /**\n   * This function does nothing. It may be overwritten to recycle a particle\n   * The PCS doesn't call this function, you can to call it\n   * doc :\n   * @param particle The particle to recycle\n   * @returns the recycled particle\n   */\n\n\n  PointsCloudSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\n   * Updates a particle : this function should  be overwritten by the user.\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n   * doc :\n   * @example : just set a particle position or velocity and recycle conditions\n   * @param particle The particle to update\n   * @returns the updated particle\n   */\n\n\n  PointsCloudSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  PointsCloudSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n   * This will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  PointsCloudSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return PointsCloudSystem;\n}();\n\nexport { PointsCloudSystem };","map":{"version":3,"mappings":"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","names":["Color4","Color3","Vector2","Vector3","Vector4","TmpVectors","Matrix","Logger","VertexBuffer","VertexData","Mesh","EngineStore","CloudPoint","PointsGroup","Ray","StandardMaterial","BaseTexture","Scalar","PointColor","name","pointSize","scene","options","Array","_size","_scene","LastCreatedScene","updatable","undefined","_updatable","PointsCloudSystem","material","Promise","all","_promises","then","_this","_isReady","_buildMesh","nbParticles","addPoints","_positions32","Float32Array","_positions","_uvs32","_uvs","_colors32","_colors","vertexData","set","PositionKind","length","UVKind","ec","ColorKind","mesh","applyToMesh","particles","mat","emissiveColor","disableLighting","pointsCloud","resolve","idx","group","groupId","idxInGroup","cp","push","particle","position","Math","random","color","pointsGroup","x","y","width","imageData","_groupImageData","colorIndices","redIndex","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","isVolume","colorFromTexture","hasTexture","range","updateFacetData","boundInfo","getBoundingInfo","diameter","boundingSphere","radius","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","place","Zero","computeWorldMatrix","meshMatrix","getWorldMatrix","isIdentity","slice","p","TransformCoordinatesFromFloatsToRef","z","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","col1","col2","colvec0","colvec1","lamda","mu","facetPoint","uvPoint","colPoint","norm","tang","biNorm","angle","facetPlaneVec","gap","distance","ray","pickInfo","direction","index","subtractToRef","height","deltaS","deltaV","h","s","v","hsvCol","statedColor","colPoint3","pointColors","i","_groupDensity","_addParticle","_groupCounter","RandomRange","add","scale","getFacetNormal","normalize","clone","Cross","PI","cos","sin","origin","intersectsMesh","hit","pickedPoint","subtract","addInPlace","_groupImgWidth","_groupImgHeight","_getColorIndicesForCoord","round","r","g","b","a","w","uv","toHSV","HSVtoRGBToRef","Warn","_setPointsColorOrUV","textureList","getActiveTextures","setEnabled","WhenAllReady","n","_textureNb","finalize","getSize","dispose","dataPromise","readPixels","data","nbPoints","positions","indices","density","vec2","c","area","areas","surfaceArea","nbFacets","sqrt","pointCount","floor","diff","pointsPerFacet","extraPoints","map","nb","pointFunction","_randomUnitVector","_positionFunction","colorWith","colored","Random","isNaN","_groups","_calculateDensity","Color","_colorFromTexture","UV","Stated","start","end","update","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","copyFromFloats","camAxisY","camAxisZ","minimum","setAll","Number","MAX_VALUE","maximum","IdentityToRef","isFacetDataEnabled","_computeBoundingBox","boundingInfo","copyFrom","pindex","cindex","uindex","updateParticle","particleRotationMatrix","_rotationMatrix","particlePosition","particleGlobalPosition","_globalPosition","_computeParticleRotation","getRotationMatrix","particleHasParent","parentId","parent_1","parentRotationMatrix","parentGlobalPosition","rotatedY_1","rotatedX_1","rotatedZ_1","rotMatrixValues","m","pivotBackTranslation","translateFromPivot","pivot","tmpVertex","vertexX","vertexY","vertexZ","rotatedX","rotatedY","rotatedZ","px","py","pz","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","_computeParticleColor","colors32_1","_computeParticleTexture","uvs32_1","updateVerticesData","hasBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","afterUpdateParticles","vars","_indices","_normals","_indices32","_isVisibilityBoxLocked","refreshBoundingInfo","size","vis","Object","_alwaysVisible","val","alwaysSelectAsActiveMesh","stop"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/pointsCloudSystem.ts"],"sourcesContent":["import type { IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Color3 } from \"../Maths/math\";\r\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport type { Material } from \"../Materials/material\";\r\n\r\n/** Defines the 4 color options */\r\nexport enum PointColor {\r\n    /** color value */\r\n    Color = 2,\r\n    /** uv value */\r\n    UV = 1,\r\n    /** random value */\r\n    Random = 0,\r\n    /** stated value */\r\n    Stated = 3,\r\n}\r\n\r\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\r\nexport class PointsCloudSystem implements IDisposable {\r\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: CloudPoint[] = new Array<CloudPoint>();\r\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The PCS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are available.\r\n     */\r\n    public mesh: Mesh;\r\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _size: number; //size of each point particle\r\n\r\n    private _scene: Scene;\r\n    private _promises: Array<Promise<any>> = [];\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray; // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array; // updated positions for the VBO\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _updatable: boolean = true;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _groups: number[] = new Array<number>(); //start indices for each group of particles\r\n    private _groupCounter: number = 0;\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _isReady: boolean = false;\r\n\r\n    /**\r\n     * Creates a PCS (Points Cloud System) object\r\n     * @param name (String) is the PCS name, this will be the underlying mesh name\r\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\r\n     * @param scene (Scene) is the scene in which the PCS is added\r\n     * @param options defines the options of the PCS e.g.\r\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n     * @param options.updatable\r\n     */\r\n    constructor(name: string, pointSize: number, scene: Scene, options?: { updatable?: boolean }) {\r\n        this.name = name;\r\n        this._size = pointSize;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n     * If no points were added to the PCS, the returned mesh is just a single point.\r\n     * @param material The material to use to render the mesh. If not provided, will create a default one\r\n     * @returns a promise for the created mesh\r\n     */\r\n    public buildMeshAsync(material?: Material): Promise<Mesh> {\r\n        return Promise.all(this._promises).then(() => {\r\n            this._isReady = true;\r\n            return this._buildMesh(material);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param material\r\n     * @hidden\r\n     */\r\n    private _buildMesh(material?: Material): Promise<Mesh> {\r\n        if (this.nbParticles === 0) {\r\n            this.addPoints(1);\r\n        }\r\n\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        const vertexData = new VertexData();\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\r\n        if (this._colors32.length > 0) {\r\n            ec = 1;\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        const mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n\r\n        // free memory\r\n        (<any>this._positions) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        let mat = material;\r\n\r\n        if (!mat) {\r\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\r\n            (<StandardMaterial>mat).emissiveColor = new Color3(ec, ec, ec);\r\n            (<StandardMaterial>mat).disableLighting = true;\r\n            (<StandardMaterial>mat).pointsCloud = true;\r\n            (<StandardMaterial>mat).pointSize = this._size;\r\n        }\r\n        mesh.material = mat;\r\n\r\n        return new Promise((resolve) => resolve(mesh));\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, group: PointsGroup, groupId: number, idxInGroup: number): CloudPoint {\r\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\r\n        this.particles.push(cp);\r\n        return cp;\r\n    }\r\n\r\n    private _randomUnitVector(particle: CloudPoint): void {\r\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\r\n        particle.color = new Color4(1, 1, 1, 1);\r\n    }\r\n\r\n    private _getColorIndicesForCoord(pointsGroup: PointsGroup, x: number, y: number, width: number): Color4 {\r\n        const imageData = <Uint8Array>pointsGroup._groupImageData;\r\n        const color = y * (width * 4) + x * 4;\r\n        const colorIndices = [color, color + 1, color + 2, color + 3];\r\n        const redIndex = colorIndices[0];\r\n        const greenIndex = colorIndices[1];\r\n        const blueIndex = colorIndices[2];\r\n        const alphaIndex = colorIndices[3];\r\n        const redForCoord = imageData[redIndex];\r\n        const greenForCoord = imageData[greenIndex];\r\n        const blueForCoord = imageData[blueIndex];\r\n        const alphaForCoord = imageData[alphaIndex];\r\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\r\n    }\r\n\r\n    private _setPointsColorOrUV(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean, colorFromTexture?: boolean, hasTexture?: boolean, color?: Color4, range?: number) {\r\n        if (isVolume) {\r\n            mesh.updateFacetData();\r\n        }\r\n\r\n        const boundInfo = mesh.getBoundingInfo();\r\n        const diameter = 2 * boundInfo.boundingSphere.radius;\r\n\r\n        let meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const place = Vector3.Zero();\r\n        mesh.computeWorldMatrix();\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        if (!meshMatrix.isIdentity()) {\r\n            meshPos = meshPos.slice(0);\r\n            for (let p = 0; p < meshPos.length / 3; p++) {\r\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\r\n                meshPos[3 * p] = place.x;\r\n                meshPos[3 * p + 1] = place.y;\r\n                meshPos[3 * p + 2] = place.z;\r\n            }\r\n        }\r\n\r\n        let idxPoints: number = 0;\r\n\r\n        let id0: number = 0;\r\n        let id1: number = 0;\r\n        let id2: number = 0;\r\n        let v0X: number = 0;\r\n        let v0Y: number = 0;\r\n        let v0Z: number = 0;\r\n        let v1X: number = 0;\r\n        let v1Y: number = 0;\r\n        let v1Z: number = 0;\r\n        let v2X: number = 0;\r\n        let v2Y: number = 0;\r\n        let v2Z: number = 0;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n\r\n        let uv0X: number = 0;\r\n        let uv0Y: number = 0;\r\n        let uv1X: number = 0;\r\n        let uv1Y: number = 0;\r\n        let uv2X: number = 0;\r\n        let uv2Y: number = 0;\r\n        const uv0 = Vector2.Zero();\r\n        const uv1 = Vector2.Zero();\r\n        const uv2 = Vector2.Zero();\r\n        const uvec0 = Vector2.Zero();\r\n        const uvec1 = Vector2.Zero();\r\n\r\n        let col0X: number = 0;\r\n        let col0Y: number = 0;\r\n        let col0Z: number = 0;\r\n        let col0A: number = 0;\r\n        let col1X: number = 0;\r\n        let col1Y: number = 0;\r\n        let col1Z: number = 0;\r\n        let col1A: number = 0;\r\n        let col2X: number = 0;\r\n        let col2Y: number = 0;\r\n        let col2Z: number = 0;\r\n        let col2A: number = 0;\r\n        const col0 = Vector4.Zero();\r\n        const col1 = Vector4.Zero();\r\n        const col2 = Vector4.Zero();\r\n        const colvec0 = Vector4.Zero();\r\n        const colvec1 = Vector4.Zero();\r\n\r\n        let lamda: number = 0;\r\n        let mu: number = 0;\r\n        range = range ? range : 0;\r\n\r\n        let facetPoint: Vector3;\r\n        let uvPoint: Vector2;\r\n        let colPoint: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        let norm = Vector3.Zero();\r\n        let tang = Vector3.Zero();\r\n        let biNorm = Vector3.Zero();\r\n        let angle = 0;\r\n        let facetPlaneVec = Vector3.Zero();\r\n\r\n        let gap = 0;\r\n        let distance = 0;\r\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\r\n        let pickInfo: PickingInfo;\r\n        let direction = Vector3.Zero();\r\n\r\n        for (let index = 0; index < meshInd.length / 3; index++) {\r\n            id0 = meshInd[3 * index];\r\n            id1 = meshInd[3 * index + 1];\r\n            id2 = meshInd[3 * index + 2];\r\n            v0X = meshPos[3 * id0];\r\n            v0Y = meshPos[3 * id0 + 1];\r\n            v0Z = meshPos[3 * id0 + 2];\r\n            v1X = meshPos[3 * id1];\r\n            v1Y = meshPos[3 * id1 + 1];\r\n            v1Z = meshPos[3 * id1 + 2];\r\n            v2X = meshPos[3 * id2];\r\n            v2Y = meshPos[3 * id2 + 1];\r\n            v2Z = meshPos[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n\r\n            if (meshUV) {\r\n                uv0X = meshUV[2 * id0];\r\n                uv0Y = meshUV[2 * id0 + 1];\r\n                uv1X = meshUV[2 * id1];\r\n                uv1Y = meshUV[2 * id1 + 1];\r\n                uv2X = meshUV[2 * id2];\r\n                uv2Y = meshUV[2 * id2 + 1];\r\n                uv0.set(uv0X, uv0Y);\r\n                uv1.set(uv1X, uv1Y);\r\n                uv2.set(uv2X, uv2Y);\r\n                uv1.subtractToRef(uv0, uvec0);\r\n                uv2.subtractToRef(uv1, uvec1);\r\n            }\r\n\r\n            if (meshCol && colorFromTexture) {\r\n                col0X = meshCol[4 * id0];\r\n                col0Y = meshCol[4 * id0 + 1];\r\n                col0Z = meshCol[4 * id0 + 2];\r\n                col0A = meshCol[4 * id0 + 3];\r\n                col1X = meshCol[4 * id1];\r\n                col1Y = meshCol[4 * id1 + 1];\r\n                col1Z = meshCol[4 * id1 + 2];\r\n                col1A = meshCol[4 * id1 + 3];\r\n                col2X = meshCol[4 * id2];\r\n                col2Y = meshCol[4 * id2 + 1];\r\n                col2Z = meshCol[4 * id2 + 2];\r\n                col2A = meshCol[4 * id2 + 3];\r\n                col0.set(col0X, col0Y, col0Z, col0A);\r\n                col1.set(col1X, col1Y, col1Z, col1A);\r\n                col2.set(col2X, col2Y, col2Z, col2A);\r\n                col1.subtractToRef(col0, colvec0);\r\n                col2.subtractToRef(col1, colvec1);\r\n            }\r\n\r\n            let width: number;\r\n            let height: number;\r\n            let deltaS: number;\r\n            let deltaV: number;\r\n            let h: number;\r\n            let s: number;\r\n            let v: number;\r\n            let hsvCol: Color3;\r\n            const statedColor: Color3 = new Color3(0, 0, 0);\r\n            const colPoint3: Color3 = new Color3(0, 0, 0);\r\n            let pointColors: Color4;\r\n            let particle: CloudPoint;\r\n\r\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\r\n                idxPoints = this.particles.length;\r\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\r\n                particle = this.particles[idxPoints];\r\n                //form a point inside the facet v0, v1, v2;\r\n                lamda = Scalar.RandomRange(0, 1);\r\n                mu = Scalar.RandomRange(0, 1);\r\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\r\n                if (isVolume) {\r\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\r\n                    tang = vec0.clone().normalize();\r\n                    biNorm = Vector3.Cross(norm, tang);\r\n                    angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\r\n                    angle = Scalar.RandomRange(0.1, Math.PI / 2);\r\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\r\n\r\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\r\n                    ray.direction = direction;\r\n                    ray.length = diameter;\r\n                    pickInfo = ray.intersectsMesh(mesh);\r\n                    if (pickInfo.hit) {\r\n                        distance = pickInfo.pickedPoint!.subtract(facetPoint).length();\r\n                        gap = Scalar.RandomRange(0, 1) * distance;\r\n                        facetPoint.addInPlace(direction.scale(gap));\r\n                    }\r\n                }\r\n                particle.position = facetPoint.clone();\r\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\r\n                if (colorFromTexture !== undefined) {\r\n                    if (meshUV) {\r\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\r\n                        if (colorFromTexture) {\r\n                            //Set particle color to texture color\r\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\r\n                                width = pointsGroup._groupImgWidth;\r\n                                height = pointsGroup._groupImgHeight;\r\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\r\n                                particle.color = pointColors;\r\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\r\n                            } else {\r\n                                if (meshCol) {\r\n                                    //failure in texture and colors available\r\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                } else {\r\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            //Set particle uv based on a mesh uv\r\n                            particle.uv = uvPoint.clone();\r\n                            this._uvs.push(particle.uv.x, particle.uv.y);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (color) {\r\n                        statedColor.set(color.r, color.g, color.b);\r\n                        deltaS = Scalar.RandomRange(-range, range);\r\n                        deltaV = Scalar.RandomRange(-range, range);\r\n                        hsvCol = statedColor.toHSV();\r\n                        h = hsvCol.r;\r\n                        s = hsvCol.g + deltaS;\r\n                        v = hsvCol.b + deltaV;\r\n                        if (s < 0) {\r\n                            s = 0;\r\n                        }\r\n                        if (s > 1) {\r\n                            s = 1;\r\n                        }\r\n                        if (v < 0) {\r\n                            v = 0;\r\n                        }\r\n                        if (v > 1) {\r\n                            v = 1;\r\n                        }\r\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\r\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\r\n                    } else {\r\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                    }\r\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stores mesh texture in dynamic texture for color pixel retrieval\r\n    // when pointColor type is color for surface points\r\n    private _colorFromTexture(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean): void {\r\n        if (mesh.material === null) {\r\n            Logger.Warn(mesh.name + \"has no material.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const mat = mesh.material;\r\n        const textureList: BaseTexture[] = mat.getActiveTextures();\r\n        if (textureList.length === 0) {\r\n            Logger.Warn(mesh.name + \"has no usable texture.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const clone = <Mesh>mesh.clone();\r\n        clone.setEnabled(false);\r\n        this._promises.push(\r\n            new Promise((resolve: (_: void) => void) => {\r\n                BaseTexture.WhenAllReady(textureList, () => {\r\n                    let n = pointsGroup._textureNb;\r\n                    if (n < 0) {\r\n                        n = 0;\r\n                    }\r\n                    if (n > textureList.length - 1) {\r\n                        n = textureList.length - 1;\r\n                    }\r\n                    const finalize = () => {\r\n                        pointsGroup._groupImgWidth = textureList[n].getSize().width;\r\n                        pointsGroup._groupImgHeight = textureList[n].getSize().height;\r\n                        this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\r\n                        clone.dispose();\r\n                        resolve();\r\n                    };\r\n                    pointsGroup._groupImageData = null;\r\n                    const dataPromise = textureList[n].readPixels();\r\n                    if (!dataPromise) {\r\n                        finalize();\r\n                    } else {\r\n                        dataPromise.then((data) => {\r\n                            pointsGroup._groupImageData = data;\r\n                            finalize();\r\n                        });\r\n                    }\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    // calculates the point density per facet of a mesh for surface points\r\n    private _calculateDensity(nbPoints: number, positions: FloatArray, indices: IndicesArray): number[] {\r\n        let density: number[] = new Array<number>();\r\n        let id0: number;\r\n        let id1: number;\r\n        let id2: number;\r\n        let v0X: number;\r\n        let v0Y: number;\r\n        let v0Z: number;\r\n        let v1X: number;\r\n        let v1Y: number;\r\n        let v1Z: number;\r\n        let v2X: number;\r\n        let v2Y: number;\r\n        let v2Z: number;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n        const vec2 = Vector3.Zero();\r\n\r\n        let a: number; //length of side of triangle\r\n        let b: number; //length of side of triangle\r\n        let c: number; //length of side of triangle\r\n        let p: number; //perimeter of triangle\r\n        let area: number;\r\n        const areas: number[] = new Array<number>();\r\n        let surfaceArea: number = 0;\r\n\r\n        const nbFacets = indices.length / 3;\r\n\r\n        //surface area\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            id0 = indices[3 * index];\r\n            id1 = indices[3 * index + 1];\r\n            id2 = indices[3 * index + 2];\r\n            v0X = positions[3 * id0];\r\n            v0Y = positions[3 * id0 + 1];\r\n            v0Z = positions[3 * id0 + 2];\r\n            v1X = positions[3 * id1];\r\n            v1Y = positions[3 * id1 + 1];\r\n            v1Z = positions[3 * id1 + 2];\r\n            v2X = positions[3 * id2];\r\n            v2Y = positions[3 * id2 + 1];\r\n            v2Z = positions[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n            vertex2.subtractToRef(vertex0, vec2);\r\n            a = vec0.length();\r\n            b = vec1.length();\r\n            c = vec2.length();\r\n            p = (a + b + c) / 2;\r\n            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\r\n            surfaceArea += area;\r\n            areas[index] = area;\r\n        }\r\n        let pointCount: number = 0;\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            density[index] = Math.floor((nbPoints * areas[index]) / surfaceArea);\r\n            pointCount += density[index];\r\n        }\r\n\r\n        const diff: number = nbPoints - pointCount;\r\n        const pointsPerFacet: number = Math.floor(diff / nbFacets);\r\n        const extraPoints: number = diff % nbFacets;\r\n\r\n        if (pointsPerFacet > 0) {\r\n            density = density.map((x) => x + pointsPerFacet);\r\n        }\r\n\r\n        for (let index = 0; index < extraPoints; index++) {\r\n            density[index] += 1;\r\n        }\r\n\r\n        return density;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS in random positions within a unit sphere\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addPoints(nb: number, pointFunction: any = this._randomUnitVector): number {\r\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\r\n        let cp: CloudPoint;\r\n\r\n        // particles\r\n        let idx = this.nbParticles;\r\n        for (let i = 0; i < nb; i++) {\r\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\r\n            if (pointsGroup && pointsGroup._positionFunction) {\r\n                pointsGroup._positionFunction(cp, idx, i);\r\n            }\r\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\r\n            if (cp.color) {\r\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\r\n            }\r\n            if (cp.uv) {\r\n                this._uvs.push(cp.uv.x, cp.uv.y);\r\n            }\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS from the surface of the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS inside the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the PCS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): PointsCloudSystem {\r\n        if (!this._updatable || !this._isReady) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const uvs32 = this._uvs32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        let idx = 0; // current index of the particle\r\n\r\n        if (this.mesh.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) {\r\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        idx = 0; // particle index\r\n        let pindex = 0; //index in positions array\r\n        let cindex = 0; //index in color array\r\n        let uindex = 0; //index in uv array\r\n\r\n        // particle loop\r\n        for (let p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n            idx = particle.idx;\r\n            pindex = 3 * idx;\r\n            cindex = 4 * idx;\r\n            uindex = 2 * idx;\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            if (this._computeParticleRotation) {\r\n                particle.getRotationMatrix(rotMatrix);\r\n            }\r\n\r\n            const particleHasParent = particle.parentId !== null;\r\n            if (particleHasParent) {\r\n                const parent = this.particles[particle.parentId!];\r\n                const parentRotationMatrix = parent._rotationMatrix;\r\n                const parentGlobalPosition = parent._globalPosition;\r\n\r\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[1] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[2] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[3] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[4] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[5] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[6] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[7] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[8] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                }\r\n            } else {\r\n                particleGlobalPosition.x = 0;\r\n                particleGlobalPosition.y = 0;\r\n                particleGlobalPosition.z = 0;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0];\r\n                    particleRotationMatrix[1] = rotMatrixValues[1];\r\n                    particleRotationMatrix[2] = rotMatrixValues[2];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4];\r\n                    particleRotationMatrix[4] = rotMatrixValues[5];\r\n                    particleRotationMatrix[5] = rotMatrixValues[6];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8];\r\n                    particleRotationMatrix[7] = rotMatrixValues[9];\r\n                    particleRotationMatrix[8] = rotMatrixValues[10];\r\n                }\r\n            }\r\n\r\n            const pivotBackTranslation = tempVectors[11];\r\n            if (particle.translateFromPivot) {\r\n                pivotBackTranslation.setAll(0.0);\r\n            } else {\r\n                pivotBackTranslation.copyFrom(particle.pivot);\r\n            }\r\n\r\n            // positions\r\n            const tmpVertex = tempVectors[0];\r\n            tmpVertex.copyFrom(particle.position);\r\n            const vertexX = tmpVertex.x - particle.pivot.x;\r\n            const vertexY = tmpVertex.y - particle.pivot.y;\r\n            const vertexZ = tmpVertex.z - particle.pivot.z;\r\n\r\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n            rotatedX += pivotBackTranslation.x;\r\n            rotatedY += pivotBackTranslation.y;\r\n            rotatedZ += pivotBackTranslation.z;\r\n\r\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\r\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\r\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\r\n\r\n            if (this._computeBoundingBox) {\r\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n            }\r\n\r\n            if (this._computeParticleColor && particle.color) {\r\n                const color = particle.color;\r\n                const colors32 = this._colors32;\r\n                colors32[cindex] = color.r;\r\n                colors32[cindex + 1] = color.g;\r\n                colors32[cindex + 2] = color.b;\r\n                colors32[cindex + 3] = color.a;\r\n            }\r\n            if (this._computeParticleTexture && particle.uv) {\r\n                const uv = particle.uv;\r\n                const uvs32 = this._uvs32;\r\n                uvs32[uindex] = uv.x;\r\n                uvs32[uindex + 1] = uv.y;\r\n            }\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (update) {\r\n            if (this._computeParticleColor) {\r\n                mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n            }\r\n            if (this._computeParticleTexture) {\r\n                mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n            }\r\n            mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n        }\r\n\r\n        if (this._computeBoundingBox) {\r\n            if (mesh.hasBoundingInfo) {\r\n                mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\r\n            } else {\r\n                mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the PCS.\r\n     */\r\n    public dispose(): void {\r\n        this.mesh.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc :\r\n     * @returns the PCS.\r\n     */\r\n    public refreshVisibleSize(): PointsCloudSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the PCS mesh bounding box.\r\n     * doc :\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        const vis = size / 2;\r\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by users to fit their needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The PCS doesn't call this function, you may have to call it by your own.\r\n     * doc :\r\n     */\r\n    public initParticles(): void {}\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle\r\n     * The PCS doesn't call this function, you can to call it\r\n     * doc :\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc :\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}