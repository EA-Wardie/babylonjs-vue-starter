{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Collider } from \"./collider.js\";\n/** @hidden */\n\nvar DefaultCollisionCoordinator =\n/** @class */\nfunction () {\n  function DefaultCollisionCoordinator() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n\n  DefaultCollisionCoordinator.prototype.getNewPosition = function (position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n\n    this._finalPosition.multiplyInPlace(collider._radius); //run the callback\n\n\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  };\n\n  DefaultCollisionCoordinator.prototype.createCollider = function () {\n    return new Collider();\n  };\n\n  DefaultCollisionCoordinator.prototype.init = function (scene) {\n    this._scene = scene;\n  };\n\n  DefaultCollisionCoordinator.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {\n    if (excludedMesh === void 0) {\n      excludedMesh = null;\n    }\n\n    var closeDistance = Engine.CollisionsEpsilon * 10.0;\n\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    } // Check if this is a mesh else camera or -1\n\n\n    var collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n\n    collider._initialize(position, velocity, closeDistance); // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n\n\n    var meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n\n    for (var index = 0; index < meshes.length; index++) {\n      var mesh = meshes[index];\n\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n\n    collider._retry++;\n\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  };\n\n  return DefaultCollisionCoordinator;\n}();\n\nexport { DefaultCollisionCoordinator };\n\nScene.CollisionCoordinatorFactory = function () {\n  return new DefaultCollisionCoordinator();\n};","map":{"version":3,"mappings":"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","names":["Scene","Vector3","Engine","Collider","Zero","DefaultCollisionCoordinator","position","displacement","collider","maximumRetry","excludedMesh","onNewPosition","collisionIndex","divideToRef","_radius","_scaledPosition","_scaledVelocity","collidedMesh","_retry","_initialVelocity","_initialPosition","_collideWithWorld","_finalPosition","multiplyInPlace","scene","_scene","velocity","finalPosition","closeDistance","CollisionsEpsilon","copyFrom","collisionMask","_initialize","meshes","surroundingMeshes","index","length","mesh","isEnabled","checkCollisions","subMeshes","collisionGroup","_checkCollision","collisionFound","addToRef","x","y","z","_getResponse","CollisionCoordinatorFactory"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Collisions/collisionCoordinator.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Collider } from \"./collider\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/** @hidden */\r\nexport interface ICollisionCoordinator {\r\n    createCollider(): Collider;\r\n    getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: Nullable<AbstractMesh>,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void;\r\n    init(scene: Scene): void;\r\n}\r\n\r\n/** @hidden */\r\nexport class DefaultCollisionCoordinator implements ICollisionCoordinator {\r\n    private _scene: Scene;\r\n\r\n    private _scaledPosition = Vector3.Zero();\r\n    private _scaledVelocity = Vector3.Zero();\r\n\r\n    private _finalPosition = Vector3.Zero();\r\n\r\n    public getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: AbstractMesh,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void {\r\n        position.divideToRef(collider._radius, this._scaledPosition);\r\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\r\n        collider.collidedMesh = null;\r\n        collider._retry = 0;\r\n        collider._initialVelocity = this._scaledVelocity;\r\n        collider._initialPosition = this._scaledPosition;\r\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\r\n\r\n        this._finalPosition.multiplyInPlace(collider._radius);\r\n        //run the callback\r\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\r\n    }\r\n\r\n    public createCollider(): Collider {\r\n        return new Collider();\r\n    }\r\n\r\n    public init(scene: Scene): void {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _collideWithWorld(\r\n        position: Vector3,\r\n        velocity: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        finalPosition: Vector3,\r\n        excludedMesh: Nullable<AbstractMesh> = null\r\n    ): void {\r\n        const closeDistance = Engine.CollisionsEpsilon * 10.0;\r\n\r\n        if (collider._retry >= maximumRetry) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        // Check if this is a mesh else camera or -1\r\n        const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\r\n\r\n        collider._initialize(position, velocity, closeDistance);\r\n\r\n        // Check if collision detection should happen against specified list of meshes or,\r\n        // if not specified, against all meshes in the scene\r\n        const meshes = (excludedMesh && excludedMesh.surroundingMeshes) || this._scene.meshes;\r\n\r\n        for (let index = 0; index < meshes.length; index++) {\r\n            const mesh = meshes[index];\r\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\r\n                mesh._checkCollision(collider);\r\n            }\r\n        }\r\n\r\n        if (!collider.collisionFound) {\r\n            position.addToRef(velocity, finalPosition);\r\n            return;\r\n        }\r\n\r\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\r\n            collider._getResponse(position, velocity);\r\n        }\r\n\r\n        if (velocity.length() <= closeDistance) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        collider._retry++;\r\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\r\n    }\r\n}\r\n\r\nScene.CollisionCoordinatorFactory = () => {\r\n    return new DefaultCollisionCoordinator();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}