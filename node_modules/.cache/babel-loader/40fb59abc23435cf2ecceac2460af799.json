{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SerializationHelper } from \"../../Misc/decorators.js\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools.js\";\nimport { InternalTextureSource } from \"./internalTexture.js\";\nimport { CubeTexture } from \"./cubeTexture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw cube texture where the raw buffers are passed in\n */\n\nvar RawCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawCubeTexture, _super);\n  /**\n   * Creates a cube texture where the raw buffers are passed in.\n   * @param scene defines the scene the texture is attached to\n   * @param data defines the array of data to use to create each face\n   * @param size defines the size of the textures\n   * @param format defines the format of the data\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\n   * @param generateMipMaps  defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n   * @param compression defines the compression used (null by default)\n   */\n\n\n  function RawCubeTexture(scene, data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    var _this = _super.call(this, \"\", scene) || this;\n\n    _this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    return _this;\n  }\n  /**\n   * Updates the raw cube texture.\n   * @param data defines the data to store\n   * @param format defines the data format\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   */\n\n\n  RawCubeTexture.prototype.update = function (data, format, type, invertY, compression) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n  };\n  /**\n   * Updates a raw cube texture with RGBD encoded data.\n   * @param data defines the array of data [mipmap][face] to use to create each face\n   * @param sphericalPolynomial defines the spherical polynomial for irradiance\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @returns a promise that resolves when the operation is complete\n   */\n\n\n  RawCubeTexture.prototype.updateRGBDAsync = function (data, sphericalPolynomial, lodScale, lodOffset) {\n    if (sphericalPolynomial === void 0) {\n      sphericalPolynomial = null;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(function () {});\n  };\n  /**\n   * Clones the raw cube texture.\n   * @return a new cube texture\n   */\n\n\n  RawCubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    return SerializationHelper.Clone(function () {\n      var scene = _this.getScene();\n\n      var internalTexture = _this._texture;\n      var texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n\n      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n      }\n\n      return texture;\n    }, this);\n  };\n\n  return RawCubeTexture;\n}(CubeTexture);\n\nexport { RawCubeTexture };","map":{"version":3,"mappings":";AAAA,SAASA,mBAAT,QAAoC,0BAApC;AACA,SAASC,gBAAgB,IAAIC,uBAA7B,QAA4D,uCAA5D;AAIA,SAASC,qBAAT,QAAsC,sBAAtC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AAEA,OAAO,+CAAP;AAGA;;;;AAGA;AAAA;AAAA;AAAoCC;AAChC;;;;;;;;;;;;;;AAYA,0BACIC,KADJ,EAEIC,IAFJ,EAGIC,IAHJ,EAIIC,MAJJ,EAKIC,IALJ,EAMIC,eANJ,EAOIC,OAPJ,EAQIC,YARJ,EASIC,WATJ,EASwC;AALpC;AAAAL,eAAiB,CAAjB;AAAiB;;AACjB;AAAAC,aAAe,CAAf;AAAe;;AACf;AAAAC;AAAgC;;AAChC;AAAAC;AAAwB;;AACxB;AAAAC,qBAAuB,CAAvB;AAAuB;;AACvB;AAAAC;AAAoC;;AATxC,gBAWIC,kBAAM,EAAN,EAAUT,KAAV,KAAgB,IAXpB;;AAaIU,SAAI,CAACC,QAAL,GAAgBX,KAAK,CAACY,SAAN,GAAkBC,oBAAlB,CAAuCZ,IAAvC,EAA6CC,IAA7C,EAAmDC,MAAnD,EAA2DC,IAA3D,EAAiEC,eAAjE,EAAkFC,OAAlF,EAA2FC,YAA3F,EAAyGC,WAAzG,CAAhB;;AACH;AAED;;;;;;;;;;AAQOM,oCAAP,UAAcb,IAAd,EAAuCE,MAAvC,EAAuDC,IAAvD,EAAqEE,OAArE,EAAuFE,WAAvF,EAA2H;AAApC;AAAAA;AAAoC;;AACtH,SAAKG,QAAL,CAAeC,SAAf,GAAsCG,oBAAtC,CAA2D,KAAKJ,QAAhE,EAA2EV,IAA3E,EAAiFE,MAAjF,EAAyFC,IAAzF,EAA+FE,OAA/F,EAAwGE,WAAxG;AACJ,GAFM;AAIP;;;;;;;;;;AAQOM,6CAAP,UAAuBb,IAAvB,EAAkDe,mBAAlD,EAA6GC,QAA7G,EAAqIC,SAArI,EAA0J;AAAxG;AAAAF;AAAyD;;AAAE;AAAAC;AAAsB;;AAAE;AAAAC;AAAqB;;AACtJ,WAAOtB,uBAAuB,CAAC,KAAKe,QAAN,EAAiBV,IAAjB,EAAuBe,mBAAvB,EAA4CC,QAA5C,EAAsDC,SAAtD,CAAvB,CAAwFC,IAAxF,CAA6F,aAAQ,CAArG,CAAP;AACH,GAFM;AAIP;;;;;;AAIOL,mCAAP;AAAA;;AACI,WAAOpB,mBAAmB,CAAC0B,KAApB,CAA0B;AAC7B,UAAMpB,KAAK,GAAGU,KAAI,CAACW,QAAL,EAAd;;AACA,UAAMC,eAAe,GAAGZ,KAAI,CAACC,QAA7B;AAEA,UAAMY,OAAO,GAAG,IAAIT,cAAJ,CACZd,KADY,EAEZsB,eAAe,CAACE,gBAFJ,EAGZF,eAAe,CAACG,KAHJ,EAIZH,eAAe,CAACnB,MAJJ,EAKZmB,eAAe,CAAClB,IALJ,EAMZkB,eAAe,CAACjB,eANJ,EAOZiB,eAAe,CAAChB,OAPJ,EAQZgB,eAAe,CAACf,YARJ,EASZe,eAAe,CAACI,YATJ,CAAhB;;AAYA,UAAIJ,eAAe,CAACK,MAAhB,KAA2B9B,qBAAqB,CAAC+B,WAArD,EAAkE;AAC9DL,eAAO,CAACM,eAAR,CACIP,eAAe,CAACQ,qBADpB,EAEIR,eAAe,CAACS,oBAFpB,EAGIT,eAAe,CAACU,mBAHpB,EAIIV,eAAe,CAACW,oBAJpB;AAMH;;AAED,aAAOV,OAAP;AACH,KA1BM,EA0BJ,IA1BI,CAAP;AA2BH,GA5BM;;AA6BX;AAAC,CAtFD,CAAoCzB,WAApC","names":["SerializationHelper","_UpdateRGBDAsync","UpdateRGBDAsyncEnvTools","InternalTextureSource","CubeTexture","__extends","scene","data","size","format","type","generateMipMaps","invertY","samplingMode","compression","_super","_this","_texture","getEngine","createRawCubeTexture","RawCubeTexture","updateRawCubeTexture","sphericalPolynomial","lodScale","lodOffset","then","Clone","getScene","internalTexture","texture","_bufferViewArray","width","_compression","source","CubeRawRGBD","updateRGBDAsync","_bufferViewArrayArray","_sphericalPolynomial","_lodGenerationScale","_lodGenerationOffset"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/rawCubeTexture.ts"],"sourcesContent":["import { SerializationHelper } from \"../../Misc/decorators\";\r\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { InternalTextureSource } from \"./internalTexture\";\r\nimport { CubeTexture } from \"./cubeTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n\r\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\r\nexport class RawCubeTexture extends CubeTexture {\r\n    /**\r\n     * Creates a cube texture where the raw buffers are passed in.\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        generateMipMaps: boolean = false,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        compression: Nullable<string> = null\r\n    ) {\r\n        super(\"\", scene);\r\n\r\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates the raw cube texture.\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    public update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null): void {\r\n        (this._texture!.getEngine() as Engine).updateRawCubeTexture(this._texture!, data, format, type, invertY, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates a raw cube texture with RGBD encoded data.\r\n     * @param data defines the array of data [mipmap][face] to use to create each face\r\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n    public updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial> = null, lodScale: number = 0.8, lodOffset: number = 0): Promise<void> {\r\n        return UpdateRGBDAsyncEnvTools(this._texture!, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Clones the raw cube texture.\r\n     * @return a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        return SerializationHelper.Clone(() => {\r\n            const scene = this.getScene()!;\r\n            const internalTexture = this._texture!;\r\n\r\n            const texture = new RawCubeTexture(\r\n                scene,\r\n                internalTexture._bufferViewArray!,\r\n                internalTexture.width,\r\n                internalTexture.format,\r\n                internalTexture.type,\r\n                internalTexture.generateMipMaps,\r\n                internalTexture.invertY,\r\n                internalTexture.samplingMode,\r\n                internalTexture._compression\r\n            );\r\n\r\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\r\n                texture.updateRGBDAsync(\r\n                    internalTexture._bufferViewArrayArray!,\r\n                    internalTexture._sphericalPolynomial,\r\n                    internalTexture._lodGenerationScale,\r\n                    internalTexture._lodGenerationOffset\r\n                );\r\n            }\r\n\r\n            return texture;\r\n        }, this);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}