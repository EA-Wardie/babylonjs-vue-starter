{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\n */\n\nvar SixDofDragBehavior =\n/** @class */\nfunction (_super) {\n  __extends(SixDofDragBehavior, _super);\n\n  function SixDofDragBehavior() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._sceneRenderObserver = null;\n    _this._targetPosition = new Vector3(0, 0, 0);\n    _this._targetOrientation = new Quaternion();\n    _this._targetScaling = new Vector3(1, 1, 1);\n    _this._startingPosition = new Vector3(0, 0, 0);\n    _this._startingOrientation = new Quaternion();\n    _this._startingScaling = new Vector3(1, 1, 1);\n    /**\n     * Fires when position is updated\n     */\n\n    _this.onPositionChangedObservable = new Observable();\n    /**\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\n     */\n\n    _this.dragDeltaRatio = 0.2;\n    /**\n     * If the object should rotate to face the drag origin\n     */\n\n    _this.rotateDraggedObject = true;\n    /**\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\n     */\n\n    _this.rotateAroundYOnly = false;\n    /**\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\n     */\n\n    _this.rotateWithMotionController = true;\n    /**\n     * Use this flag to update the target but not move the owner node towards the target\n     */\n\n    _this.disableMovement = false;\n    /**\n     * Should the object rotate towards the camera when we start dragging it\n     */\n\n    _this.faceCameraOnDragStart = false;\n    return _this;\n  }\n\n  Object.defineProperty(SixDofDragBehavior.prototype, \"name\", {\n    /**\n     *  The name of the behavior\n     */\n    get: function get() {\n      return \"SixDofDrag\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Attaches the six DoF drag behavior\n   * @param ownerNode The mesh that will be dragged around once attached\n   */\n\n  SixDofDragBehavior.prototype.attach = function (ownerNode) {\n    var _this = this;\n\n    _super.prototype.attach.call(this, ownerNode);\n\n    ownerNode.isNearGrabbable = true; // Node that will save the owner's transform\n\n    this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\n    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity(); // On every frame move towards target scaling to avoid jitter caused by vr controllers\n\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {\n      if (_this.currentDraggingPointerIds.length === 1 && _this._moving && !_this.disableMovement) {\n        // 1 pointer only drags mesh\n        var oldParent = ownerNode.parent;\n        ownerNode.setParent(null);\n        ownerNode.position.addInPlace(_this._targetPosition.subtract(ownerNode.position).scale(_this.dragDeltaRatio));\n\n        _this.onPositionChangedObservable.notifyObservers({\n          position: ownerNode.absolutePosition\n        }); // Only rotate the mesh if it's parent has uniform scaling\n\n\n        if (!oldParent || oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, _this._targetOrientation, _this.dragDeltaRatio, ownerNode.rotationQuaternion);\n        }\n\n        ownerNode.setParent(oldParent);\n      }\n    });\n  };\n\n  SixDofDragBehavior.prototype._getPositionOffsetAround = function (transformationLocalOrigin, scaling, rotation) {\n    var translationMatrix = TmpVectors.Matrix[0]; // T\n\n    var translationMatrixInv = TmpVectors.Matrix[1]; // T'\n\n    var rotationMatrix = TmpVectors.Matrix[2]; // R\n\n    var scaleMatrix = TmpVectors.Matrix[3]; // S\n\n    var finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\n\n    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\n\n    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\n\n    Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\n\n    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\n    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n\n    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\n\n    finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\n\n    return finalMatrix.getTranslation();\n  };\n\n  SixDofDragBehavior.prototype._onePointerPositionUpdated = function (worldDeltaPosition, worldDeltaRotation) {\n    var pointerDelta = TmpVectors.Vector3[0];\n    pointerDelta.setAll(0);\n\n    if (this._dragging === this._dragType.DRAG) {\n      if (this.rotateDraggedObject) {\n        if (this.rotateAroundYOnly) {\n          // Convert change in rotation to only y axis rotation\n          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        } else {\n          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\n        }\n\n        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\n      }\n    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {\n      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\n    }\n\n    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\n  };\n\n  SixDofDragBehavior.prototype._twoPointersPositionUpdated = function () {\n    var startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\n    var startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\n    var startingCenter = TmpVectors.Vector3[0];\n    startingPosition0.addToRef(startingPosition1, startingCenter);\n    startingCenter.scaleInPlace(0.5);\n    var startingVector = TmpVectors.Vector3[1];\n    startingPosition1.subtractToRef(startingPosition0, startingVector);\n    var currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\n    var currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\n    var currentCenter = TmpVectors.Vector3[2];\n    currentPosition0.addToRef(currentPosition1, currentCenter);\n    currentCenter.scaleInPlace(0.5);\n    var currentVector = TmpVectors.Vector3[3];\n    currentPosition1.subtractToRef(currentPosition0, currentVector);\n    var scaling = currentVector.length() / startingVector.length();\n    var translation = currentCenter.subtract(startingCenter);\n    var rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);\n    var oldParent = this._ownerNode.parent;\n\n    this._ownerNode.setParent(null);\n\n    var positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\n\n    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);\n\n    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\n\n    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\n\n    this.onPositionChangedObservable.notifyObservers({\n      position: this._ownerNode.position\n    });\n\n    this._ownerNode.setParent(oldParent);\n  };\n\n  SixDofDragBehavior.prototype._targetDragStart = function () {\n    var pointerCount = this.currentDraggingPointerIds.length;\n    var oldParent = this._ownerNode.parent;\n\n    if (!this._ownerNode.rotationQuaternion) {\n      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\n    }\n\n    var worldPivot = this._ownerNode.getAbsolutePivotPoint();\n\n    this._ownerNode.setParent(null);\n\n    if (pointerCount === 1) {\n      this._targetPosition.copyFrom(this._ownerNode.position);\n\n      this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\n\n      this._targetScaling.copyFrom(this._ownerNode.scaling);\n\n      if (this.faceCameraOnDragStart && this._scene.activeCamera) {\n        var toCamera = TmpVectors.Vector3[0];\n\n        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\n\n        toCamera.normalize();\n        var quat = TmpVectors.Quaternion[0];\n\n        if (this._scene.useRightHandedSystem) {\n          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        } else {\n          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        }\n\n        quat.normalize();\n        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n\n        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\n      }\n\n      this._startingPosition.copyFrom(this._targetPosition);\n\n      this._startingOrientation.copyFrom(this._targetOrientation);\n\n      this._startingScaling.copyFrom(this._targetScaling);\n    } else if (pointerCount === 2) {\n      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\n\n      this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\n\n      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\n\n      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);\n\n      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\n\n      this._resetVirtualMeshesPosition();\n    }\n\n    this._ownerNode.setParent(oldParent);\n  };\n\n  SixDofDragBehavior.prototype._targetDrag = function (worldDeltaPosition, worldDeltaRotation) {\n    if (this.currentDraggingPointerIds.length === 1) {\n      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\n    } else if (this.currentDraggingPointerIds.length === 2) {\n      this._twoPointersPositionUpdated();\n    }\n  };\n\n  SixDofDragBehavior.prototype._targetDragEnd = function () {\n    if (this.currentDraggingPointerIds.length === 1) {\n      // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\n      this._resetVirtualMeshesPosition();\n\n      var previousFaceCameraFlag = this.faceCameraOnDragStart;\n      this.faceCameraOnDragStart = false;\n\n      this._targetDragStart();\n\n      this.faceCameraOnDragStart = previousFaceCameraFlag;\n    }\n  };\n  /**\n   *  Detaches the behavior from the mesh\n   */\n\n\n  SixDofDragBehavior.prototype.detach = function () {\n    _super.prototype.detach.call(this);\n\n    if (this._ownerNode) {\n      this._ownerNode.isNearGrabbable = false;\n\n      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    }\n\n    if (this._virtualTransformNode) {\n      this._virtualTransformNode.dispose();\n    }\n  };\n\n  return SixDofDragBehavior;\n}(BaseSixDofDragBehavior);\n\nexport { SixDofDragBehavior };","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","Observable","BaseSixDofDragBehavior","TransformNode","Space","__extends","_this","Object","SixDofDragBehavior","ownerNode","_super","attach","call","isNearGrabbable","_virtualTransformNode","_virtualScene","rotationQuaternion","Identity","_sceneRenderObserver","getScene","onBeforeRenderObservable","add","currentDraggingPointerIds","length","_moving","disableMovement","oldParent","parent","setParent","position","addInPlace","_targetPosition","subtract","scale","dragDeltaRatio","onPositionChangedObservable","notifyObservers","absolutePosition","scaling","isNonUniformWithinEpsilon","SlerpToRef","_targetOrientation","transformationLocalOrigin","rotation","translationMatrix","translationMatrixInv","rotationMatrix","scaleMatrix","finalMatrix","TranslationToRef","x","y","z","FromQuaternionToRef","ScalingToRef","multiplyToRef","getTranslation","worldDeltaPosition","worldDeltaRotation","pointerDelta","setAll","_dragging","_dragType","DRAG","rotateDraggedObject","rotateAroundYOnly","RotationYawPitchRollToRef","toEulerAngles","copyFrom","_startingOrientation","NEAR_DRAG","DRAG_WITH_CONTROLLER","rotateWithMotionController","_startingPosition","startingPosition0","_virtualMeshesInfo","startingPosition","startingPosition1","startingCenter","addToRef","scaleInPlace","startingVector","subtractToRef","currentPosition0","dragMesh","currentPosition1","currentCenter","currentVector","translation","FromEulerAngles","GetAngleBetweenVectorsOnPlane","normalize","UpReadOnly","_ownerNode","positionOffset","_getPositionOffsetAround","getAbsolutePivotPoint","scaleToRef","pointerCount","RotationYawPitchRoll","worldPivot","_targetScaling","faceCameraOnDragStart","_scene","activeCamera","toCamera","quat","useRightHandedSystem","FromLookDirectionRHToRef","FromLookDirectionLHToRef","_startingScaling","setPivotPoint","LOCAL","WORLD","_resetVirtualMeshesPosition","_onePointerPositionUpdated","_twoPointersPositionUpdated","previousFaceCameraFlag","_targetDragStart","detach","remove","dispose"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/sixDofDragBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\r\n */\r\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _virtualTransformNode: TransformNode;\r\n\r\n    protected _targetPosition = new Vector3(0, 0, 0);\r\n    protected _targetOrientation = new Quaternion();\r\n    protected _targetScaling = new Vector3(1, 1, 1);\r\n    protected _startingPosition = new Vector3(0, 0, 0);\r\n    protected _startingOrientation = new Quaternion();\r\n    protected _startingScaling = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Fires when position is updated\r\n     */\r\n    public onPositionChangedObservable = new Observable<{ position: Vector3 }>();\r\n\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n\r\n    /**\r\n     * If the object should rotate to face the drag origin\r\n     */\r\n    public rotateDraggedObject = true;\r\n\r\n    /**\r\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\r\n     */\r\n    public rotateAroundYOnly = false;\r\n\r\n    /**\r\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\r\n     */\r\n    public rotateWithMotionController = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     * Use this flag to update the target but not move the owner node towards the target\r\n     */\r\n    public disableMovement: boolean = false;\r\n\r\n    /**\r\n     * Should the object rotate towards the camera when we start dragging it\r\n     */\r\n    public faceCameraOnDragStart = false;\r\n\r\n    /**\r\n     * Attaches the six DoF drag behavior\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        super.attach(ownerNode);\r\n\r\n        ownerNode.isNearGrabbable = true;\r\n\r\n        // Node that will save the owner's transform\r\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\r\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\r\n                // 1 pointer only drags mesh\r\n                const oldParent = ownerNode.parent;\r\n                ownerNode.setParent(null);\r\n                ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\r\n\r\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\r\n\r\n                // Only rotate the mesh if it's parent has uniform scaling\r\n                if (!oldParent || ((oldParent as Mesh).scaling && !(oldParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion!, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion!);\r\n                }\r\n\r\n                ownerNode.setParent(oldParent);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _getPositionOffsetAround(transformationLocalOrigin: Vector3, scaling: number, rotation: Quaternion): Vector3 {\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\r\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\r\n\r\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\r\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\r\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\r\n\r\n        return finalMatrix.getTranslation();\r\n    }\r\n\r\n    private _onePointerPositionUpdated(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        const pointerDelta = TmpVectors.Vector3[0];\r\n        pointerDelta.setAll(0);\r\n\r\n        if (this._dragging === this._dragType.DRAG) {\r\n            if (this.rotateDraggedObject) {\r\n                if (this.rotateAroundYOnly) {\r\n                    // Convert change in rotation to only y axis rotation\r\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                } else {\r\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\r\n                }\r\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n            }\r\n        } else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\r\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n        }\r\n\r\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\r\n    }\r\n\r\n    private _twoPointersPositionUpdated() {\r\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\r\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\r\n        const startingCenter = TmpVectors.Vector3[0];\r\n        startingPosition0.addToRef(startingPosition1, startingCenter);\r\n        startingCenter.scaleInPlace(0.5);\r\n        const startingVector = TmpVectors.Vector3[1];\r\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\r\n\r\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\r\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\r\n        const currentCenter = TmpVectors.Vector3[2];\r\n        currentPosition0.addToRef(currentPosition1, currentCenter);\r\n        currentCenter.scaleInPlace(0.5);\r\n        const currentVector = TmpVectors.Vector3[3];\r\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\r\n\r\n        const scaling = currentVector.length() / startingVector.length();\r\n        const translation = currentCenter.subtract(startingCenter);\r\n        const rotationQuaternion = Quaternion.FromEulerAngles(\r\n            0,\r\n            Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly),\r\n            0\r\n        );\r\n\r\n        const oldParent = this._ownerNode.parent;\r\n        this._ownerNode.setParent(null);\r\n\r\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\r\n        this._virtualTransformNode.rotationQuaternion!.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion!);\r\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\r\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\r\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDragStart() {\r\n        const pointerCount = this.currentDraggingPointerIds.length;\r\n        const oldParent = this._ownerNode.parent;\r\n\r\n        if (!this._ownerNode.rotationQuaternion) {\r\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\r\n        }\r\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\r\n        this._ownerNode.setParent(null);\r\n\r\n        if (pointerCount === 1) {\r\n            this._targetPosition.copyFrom(this._ownerNode.position);\r\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._targetScaling.copyFrom(this._ownerNode.scaling);\r\n\r\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\r\n                const toCamera = TmpVectors.Vector3[0];\r\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\r\n                toCamera.normalize();\r\n                const quat = TmpVectors.Quaternion[0];\r\n                if (this._scene.useRightHandedSystem) {\r\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                } else {\r\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                }\r\n                quat.normalize();\r\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\r\n            }\r\n            this._startingPosition.copyFrom(this._targetPosition);\r\n            this._startingOrientation.copyFrom(this._targetOrientation);\r\n            this._startingScaling.copyFrom(this._targetScaling);\r\n        } else if (pointerCount === 2) {\r\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\r\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\r\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\r\n            this._virtualTransformNode.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\r\n            this._resetVirtualMeshesPosition();\r\n        }\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\r\n        } else if (this.currentDraggingPointerIds.length === 2) {\r\n            this._twoPointersPositionUpdated();\r\n        }\r\n    }\r\n\r\n    protected _targetDragEnd() {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\r\n            this._resetVirtualMeshesPosition();\r\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\r\n            this.faceCameraOnDragStart = false;\r\n            this._targetDragStart();\r\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        super.detach();\r\n\r\n        if (this._ownerNode) {\r\n            (this._ownerNode as Mesh).isNearGrabbable = false;\r\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n\r\n        if (this._virtualTransformNode) {\r\n            this._virtualTransformNode.dispose();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}