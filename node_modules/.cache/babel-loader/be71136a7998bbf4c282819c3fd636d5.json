{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\n\n/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nvar AndOrNotEvaluator =\n/** @class */\nfunction () {\n  function AndOrNotEvaluator() {}\n  /**\n   * Evaluate a query\n   * @param query defines the query to evaluate\n   * @param evaluateCallback defines the callback used to filter result\n   * @returns true if the query matches\n   */\n\n\n  AndOrNotEvaluator.Eval = function (query, evaluateCallback) {\n    if (!query.match(/\\([^()]*\\)/g)) {\n      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n    } else {\n      query = query.replace(/\\([^()]*\\)/g, function (r) {\n        // remove parenthesis\n        r = r.slice(1, r.length - 1);\n        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n      });\n    }\n\n    if (query === \"true\") {\n      return true;\n    }\n\n    if (query === \"false\") {\n      return false;\n    }\n\n    return AndOrNotEvaluator.Eval(query, evaluateCallback);\n  };\n\n  AndOrNotEvaluator._HandleParenthesisContent = function (parenthesisContent, evaluateCallback) {\n    evaluateCallback = evaluateCallback || function (r) {\n      return r === \"true\" ? true : false;\n    };\n\n    var result;\n    var or = parenthesisContent.split(\"||\");\n\n    for (var i in or) {\n      if (Object.prototype.hasOwnProperty.call(or, i)) {\n        var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n\n        var and = ori.split(\"&&\");\n\n        if (and.length > 1) {\n          for (var j = 0; j < and.length; ++j) {\n            var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n\n            if (andj !== \"true\" && andj !== \"false\") {\n              if (andj[0] === \"!\") {\n                result = !evaluateCallback(andj.substring(1));\n              } else {\n                result = evaluateCallback(andj);\n              }\n            } else {\n              result = andj === \"true\" ? true : false;\n            }\n\n            if (!result) {\n              // no need to continue since 'false && ... && ...' will always return false\n              ori = \"false\";\n              break;\n            }\n          }\n        }\n\n        if (result || ori === \"true\") {\n          // no need to continue since 'true || ... || ...' will always return true\n          result = true;\n          break;\n        } // result equals false (or undefined)\n\n\n        if (ori !== \"true\" && ori !== \"false\") {\n          if (ori[0] === \"!\") {\n            result = !evaluateCallback(ori.substring(1));\n          } else {\n            result = evaluateCallback(ori);\n          }\n        } else {\n          result = ori === \"true\" ? true : false;\n        }\n      }\n    } // the whole parenthesis scope is replaced by 'true' or 'false'\n\n\n    return result ? \"true\" : \"false\";\n  };\n\n  AndOrNotEvaluator._SimplifyNegation = function (booleanString) {\n    booleanString = booleanString.replace(/^[\\s!]+/, function (r) {\n      // remove whitespaces\n      r = r.replace(/[\\s]/g, function () {\n        return \"\";\n      });\n      return r.length % 2 ? \"!\" : \"\";\n    });\n    booleanString = booleanString.trim();\n\n    if (booleanString === \"!true\") {\n      booleanString = \"false\";\n    } else if (booleanString === \"!false\") {\n      booleanString = \"true\";\n    }\n\n    return booleanString;\n  };\n\n  return AndOrNotEvaluator;\n}();\n\nexport { AndOrNotEvaluator };","map":{"version":3,"mappings":"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","names":["AndOrNotEvaluator","query","evaluateCallback","match","_HandleParenthesisContent","replace","r","slice","length","Eval","parenthesisContent","result","or","split","i","Object","prototype","hasOwnProperty","call","ori","_SimplifyNegation","trim","and","j","andj","substring","booleanString"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/andOrNotEvaluator.ts"],"sourcesContent":["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}