{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { BoundingSphere } from \"../../Culling/boundingSphere.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing.js\"; // side effects\n\nimport \"../../Meshes/subMesh.project.js\"; // Tracks the interaction animation state when using a motion controller with a near interaction orb\n\nvar ControllerOrbAnimationState;\n\n(function (ControllerOrbAnimationState) {\n  /**\n   * Orb is invisible\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"DEHYDRATED\"] = 0] = \"DEHYDRATED\";\n  /**\n   * Orb is visible and inside the hover range\n   */\n\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"HOVER\"] = 1] = \"HOVER\";\n  /**\n   * Orb is visible and touching a near interaction target\n   */\n\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"TOUCH\"] = 2] = \"TOUCH\";\n})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));\n/**\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\n */\n\n\nexport var WebXRNearControllerMode;\n\n(function (WebXRNearControllerMode) {\n  /**\n   * Motion controllers will not support near interaction\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"DISABLED\"] = 0] = \"DISABLED\";\n  /**\n   * The interaction point for motion controllers will be inside of them\n   */\n\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_ON_CONTROLLER\"] = 1] = \"CENTERED_ON_CONTROLLER\";\n  /**\n   * The interaction point for motion controllers will be in front of the controller\n   */\n\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_IN_FRONT\"] = 2] = \"CENTERED_IN_FRONT\";\n})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));\n/**\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\n */\n\n\nvar WebXRNearInteraction =\n/** @class */\nfunction (_super) {\n  __extends(WebXRNearInteraction, _super);\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n\n\n  function WebXRNearInteraction(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._tmpRay = new Ray(new Vector3(), new Vector3());\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      } // get two new meshes\n\n\n      var _a = _this._generateNewTouchPointMesh(),\n          touchCollisionMesh = _a.touchCollisionMesh,\n          touchCollisionMeshFunction = _a.touchCollisionMeshFunction,\n          hydrateCollisionMeshFunction = _a.hydrateCollisionMeshFunction;\n\n      var selectionMesh = _this._generateVisualCue();\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        meshUnderPointer: null,\n        nearInteractionTargetMesh: null,\n        pick: null,\n        stalePick: null,\n        touchCollisionMesh: touchCollisionMesh,\n        touchCollisionMeshFunction: touchCollisionMeshFunction,\n        hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\n        currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\n        grabRay: new Ray(new Vector3(), new Vector3()),\n        hoverInteraction: false,\n        nearInteraction: false,\n        grabInteraction: false,\n        id: WebXRNearInteraction._IdCounter++,\n        pickedPointVisualCue: selectionMesh\n      };\n\n      if (_this._attachedController) {\n        if (!_this._options.enableNearInteractionOnAllControllers && _this._options.preferredHandedness && xrController.inputSource.handedness === _this._options.preferredHandedness) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!_this._options.enableNearInteractionOnAllControllers) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      }\n\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return _this._attachNearInteractionMode(xrController);\n\n        case \"gaze\":\n          return null;\n\n        case \"screen\":\n          return null;\n      }\n    };\n\n    _this._controllers = {};\n    _this._farInteractionFeature = null;\n    /**\n     * default color of the selection ring\n     */\n\n    _this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n\n    _this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    _this._hoverRadius = 0.1;\n    _this._pickRadius = 0.02;\n    _this._controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\n\n    _this._nearGrabLengthScale = 5;\n    _this._scene = _this._xrSessionManager.scene;\n\n    if (_this._options.nearInteractionControllerMode === undefined) {\n      _this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\n    }\n\n    if (_this._options.farInteractionFeature) {\n      _this._farInteractionFeature = _this._options.farInteractionFeature;\n    }\n\n    return _this;\n  }\n  /**\n   * Attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRNearInteraction.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    return true;\n  };\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n\n\n  WebXRNearInteraction.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n    return true;\n  };\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n\n\n  WebXRNearInteraction.prototype.getMeshUnderPointer = function (controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n\n\n  WebXRNearInteraction.prototype.getXRControllerByPointerId = function (id) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * This function sets webXRControllerPointerSelection feature that will be disabled when\n   * the hover range is reached for a mesh and will be reattached when not in hover range.\n   * This is used to remove the selection rays when moving.\n   * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\n   */\n\n\n  WebXRNearInteraction.prototype.setFarInteractionFeature = function (farInteractionFeature) {\n    this._farInteractionFeature = farInteractionFeature;\n  };\n  /**\n   * Filter used for near interaction pick and hover\n   * @param mesh\n   */\n\n\n  WebXRNearInteraction.prototype._nearPickPredicate = function (mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\n  };\n  /**\n   * Filter used for near interaction grab\n   * @param mesh\n   */\n\n\n  WebXRNearInteraction.prototype._nearGrabPredicate = function (mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\n  };\n  /**\n   * Filter used for any near interaction\n   * @param mesh\n   */\n\n\n  WebXRNearInteraction.prototype._nearInteractionPredicate = function (mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\n  };\n\n  WebXRNearInteraction.prototype._controllerAvailablePredicate = function (mesh, controllerId) {\n    var parent = mesh;\n\n    while (parent) {\n      if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\n        return false;\n      }\n\n      parent = parent.parent;\n    }\n\n    return true;\n  };\n\n  WebXRNearInteraction.prototype._handleTransitionAnimation = function (controllerData, newState) {\n    var _a;\n\n    if (controllerData.currentAnimationState === newState || this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT || !!((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n      return;\n    } // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\n\n\n    if (newState > controllerData.currentAnimationState) {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.DEHYDRATED:\n          {\n            controllerData.hydrateCollisionMeshFunction(true);\n\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.touchCollisionMeshFunction(true);\n\n            if (newState === ControllerOrbAnimationState.TOUCH) {\n              break;\n            }\n          }\n      }\n    } else {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.TOUCH:\n          {\n            controllerData.touchCollisionMeshFunction(false);\n\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.hydrateCollisionMeshFunction(false);\n\n            if (newState === ControllerOrbAnimationState.DEHYDRATED) {\n              break;\n            }\n          }\n      }\n    }\n\n    controllerData.currentAnimationState = newState;\n  };\n\n  WebXRNearInteraction.prototype._processTouchPoint = function (id, position, orientation) {\n    var _a;\n\n    var controllerData = this._controllers[id]; // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\n\n    controllerData.grabRay.origin.copyFrom(position);\n    orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\n    controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\n\n    if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n      // offset the touch point in the direction the transform is facing\n      controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n      controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\n    }\n\n    controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;\n    controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);\n  };\n\n  WebXRNearInteraction.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    Object.keys(this._controllers).forEach(function (id) {\n      var _a; // only do this for the selected pointer\n\n\n      var controllerData = _this._controllers[id];\n      var handData = (_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand; // If near interaction is not enabled/available for this controller, return early\n\n      if (!_this._options.enableNearInteractionOnAllControllers && id !== _this._attachedController || !controllerData.xrController || !handData && (!_this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        controllerData.pick = null;\n        return;\n      }\n\n      controllerData.hoverInteraction = false;\n      controllerData.nearInteraction = false; // Every frame check collisions/input\n\n      if (controllerData.xrController) {\n        if (handData) {\n          var xrIndexTip = handData.get(\"index-finger-tip\");\n\n          if (xrIndexTip) {\n            var indexTipPose = _xrFrame.getJointPose(xrIndexTip, _this._xrSessionManager.referenceSpace);\n\n            if (indexTipPose && indexTipPose.transform) {\n              var axisRHSMultiplier = _this._scene.useRightHandedSystem ? 1 : -1;\n              TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\n              TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);\n\n              _this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\n            }\n          }\n        } else if (controllerData.xrController.inputSource.gamepad && _this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\n          var controllerPose = controllerData.xrController.pointer;\n\n          if (controllerData.xrController.grip && _this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\n            controllerPose = controllerData.xrController.grip;\n          }\n\n          _this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);\n        }\n      } else {\n        return;\n      }\n\n      var accuratePickInfo = function accuratePickInfo(originalScenePick, utilityScenePick) {\n        var pick = null;\n\n        if (!utilityScenePick || !utilityScenePick.hit) {\n          // No hit in utility scene\n          pick = originalScenePick;\n        } else if (!originalScenePick || !originalScenePick.hit) {\n          // No hit in original scene\n          pick = utilityScenePick;\n        } else if (utilityScenePick.distance < originalScenePick.distance) {\n          // Hit is closer in utility scene\n          pick = utilityScenePick;\n        } else {\n          // Hit is closer in original scene\n          pick = originalScenePick;\n        }\n\n        return pick;\n      };\n\n      var populateNearInteractionInfo = function populateNearInteractionInfo(nearInteractionInfo) {\n        var result = new PickingInfo();\n        var nearInteractionAtOrigin = false;\n        var nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\n\n        if (nearInteractionInfo === null || nearInteractionInfo === void 0 ? void 0 : nearInteractionInfo.pickedPoint) {\n          nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\n        }\n\n        if (nearInteraction && !nearInteractionAtOrigin) {\n          result = nearInteractionInfo;\n        }\n\n        return result;\n      }; // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\n      // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\n      // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\n\n\n      if (!controllerData.grabInteraction) {\n        var pick = null; // near interaction hover\n\n        var utilitySceneHoverPick = null;\n\n        if (_this._options.useUtilityLayer && _this._utilityLayerScene) {\n          utilitySceneHoverPick = _this._pickWithSphere(controllerData, _this._hoverRadius, _this._utilityLayerScene, function (mesh) {\n            return _this._nearInteractionPredicate(mesh);\n          });\n        }\n\n        var originalSceneHoverPick = _this._pickWithSphere(controllerData, _this._hoverRadius, _this._scene, function (mesh) {\n          return _this._nearInteractionPredicate(mesh);\n        });\n\n        var hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\n\n        if (hoverPickInfo && hoverPickInfo.hit) {\n          pick = populateNearInteractionInfo(hoverPickInfo);\n\n          if (pick.hit) {\n            controllerData.hoverInteraction = true;\n          }\n        } // near interaction pick\n\n\n        if (controllerData.hoverInteraction) {\n          var utilitySceneNearPick = null;\n          var radius = handData ? _this._pickRadius : _this._controllerPickRadius;\n\n          if (_this._options.useUtilityLayer && _this._utilityLayerScene) {\n            utilitySceneNearPick = _this._pickWithSphere(controllerData, radius, _this._utilityLayerScene, function (mesh) {\n              return _this._nearPickPredicate(mesh);\n            });\n          }\n\n          var originalSceneNearPick = _this._pickWithSphere(controllerData, radius, _this._scene, function (mesh) {\n            return _this._nearPickPredicate(mesh);\n          });\n\n          var pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\n          var nearPick = populateNearInteractionInfo(pickInfo);\n\n          if (nearPick.hit) {\n            // Near pick takes precedence over hover interaction\n            pick = nearPick;\n            controllerData.nearInteraction = true;\n          }\n        }\n\n        controllerData.stalePick = controllerData.pick;\n        controllerData.pick = pick; // Update mesh under pointer\n\n        if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\n          controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\n          controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\n          controllerData.pickedPointVisualCue.isVisible = true;\n\n          if (_this._farInteractionFeature && _this._farInteractionFeature.attached) {\n            _this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\n          }\n        } else {\n          controllerData.meshUnderPointer = null;\n          controllerData.pickedPointVisualCue.isVisible = false;\n\n          if (_this._farInteractionFeature && _this._farInteractionFeature.attached) {\n            _this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\n          }\n        }\n      } // Update the interaction animation. Only updates if the visible touch mesh is active\n\n\n      var state = ControllerOrbAnimationState.DEHYDRATED;\n\n      if (controllerData.grabInteraction || controllerData.nearInteraction) {\n        state = ControllerOrbAnimationState.TOUCH;\n      } else if (controllerData.hoverInteraction) {\n        state = ControllerOrbAnimationState.HOVER;\n      }\n\n      _this._handleTransitionAnimation(controllerData, state);\n    });\n  };\n\n  Object.defineProperty(WebXRNearInteraction.prototype, \"_utilityLayerScene\", {\n    get: function get() {\n      return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRNearInteraction.prototype._generateVisualCue = function () {\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var selectionMesh = CreateSphere(\"nearInteraction\", {\n      diameter: 0.0035 * 3\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    selectionMesh.rotationQuaternion = Quaternion.Identity();\n    var targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    return selectionMesh;\n  };\n\n  WebXRNearInteraction.prototype._isControllerReadyForNearInteraction = function (id) {\n    if (this._farInteractionFeature) {\n      return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\n    }\n\n    return true;\n  };\n\n  WebXRNearInteraction.prototype._attachNearInteractionMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n    var pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!_this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== _this._attachedController || !controllerData.xrController || !controllerData.xrController.inputSource.hand && (!_this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        return;\n      }\n\n      if (controllerData.pick) {\n        controllerData.pick.ray = controllerData.grabRay;\n      }\n\n      if (controllerData.pick && _this._isControllerReadyForNearInteraction(controllerData.id)) {\n        _this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      } // Near pick pointer event\n\n\n      if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\n        if (!controllerData.nearInteractionTargetMesh) {\n          _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n\n          controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\n        }\n      } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\n        _this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\n\n        controllerData.nearInteractionTargetMesh = null;\n      }\n    });\n\n    var grabCheck = function grabCheck(pressed) {\n      if (_this._options.enableNearInteractionOnAllControllers || xrController.uniqueId === _this._attachedController && _this._isControllerReadyForNearInteraction(controllerData.id)) {\n        if (controllerData.pick) {\n          controllerData.pick.ray = controllerData.grabRay;\n        }\n\n        if (pressed && controllerData.pick && controllerData.meshUnderPointer && _this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n\n          _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n        }\n      } else {\n        if (pressed && !_this._options.enableNearInteractionOnAllControllers && !_this._options.disableSwitchOnClick) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      }\n    };\n\n    if (xrController.inputSource.gamepad) {\n      var init = function init(motionController) {\n        controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\n\n        if (controllerData.squeezeComponent) {\n          controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add(function (component) {\n            if (component.changes.pressed) {\n              var pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        } else {\n          controllerData.selectionComponent = motionController.getMainComponent();\n          controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(function (component) {\n            if (component.changes.pressed) {\n              var pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        }\n      };\n\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      var selectStartListener = function selectStartListener(event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && _this._isControllerReadyForNearInteraction(controllerData.id) && controllerData.meshUnderPointer && _this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n\n          _this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        }\n      };\n\n      var selectEndListener = function selectEndListener(event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && _this._isControllerReadyForNearInteraction(controllerData.id)) {\n          _this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n        }\n      };\n\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  };\n\n  WebXRNearInteraction.prototype._detachController = function (xrControllerUniqueId) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.squeezeComponent) {\n      if (controllerData.onSqueezeButtonChangedObserver) {\n        controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\n      }\n    }\n\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(function (eventName) {\n        var func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n\n        if (func) {\n          _this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n\n    controllerData.touchCollisionMesh.dispose();\n    controllerData.pickedPointVisualCue.dispose();\n\n    this._xrSessionManager.runInXRFrame(function () {\n      // Fire a pointerup\n      var pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr\"\n      };\n\n      _this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\n    }); // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n\n    if (this._attachedController === xrControllerUniqueId) {\n      // check for other controllers\n      var keys = Object.keys(this._controllers);\n\n      if (keys.length) {\n        this._attachedController = keys[0];\n      } else {\n        this._attachedController = \"\";\n      }\n    }\n  };\n\n  WebXRNearInteraction.prototype._generateNewTouchPointMesh = function () {\n    // populate information for near hover, pick and pinch\n    var meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var touchCollisionMesh = CreateSphere(\"PickSphere\", {\n      diameter: 1\n    }, meshCreationScene);\n    touchCollisionMesh.isVisible = false; // Generate the material for the touch mesh visuals\n\n    if (this._options.motionControllerOrbMaterial) {\n      touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\n    } else {\n      NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then(function (nodeMaterial) {\n        touchCollisionMesh.material = nodeMaterial;\n      });\n    }\n\n    var easingFunction = new QuadraticEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT); // Adjust the visual size based off of the size of the touch collision orb.\n    // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\n    // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\n\n    var hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);\n    var touchSize = this._controllerPickRadius * (4 / 3);\n    var touchSizeVec = new Vector3(touchSize, touchSize, touchSize);\n    var hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\n    var hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);\n    var touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\n    var touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);\n    var hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\n    var hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);\n    var touchKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: hoverTouchTransitionSizeVec\n    }, {\n      frame: 18,\n      value: touchSizeVec\n    }];\n    var releaseKeys = [{\n      frame: 0,\n      value: touchSizeVec\n    }, {\n      frame: 10,\n      value: touchHoverTransitionSizeVec\n    }, {\n      frame: 18,\n      value: hoverSizeVec\n    }];\n    var hydrateKeys = [{\n      frame: 0,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 12,\n      value: hydrateTransitionSizeVec\n    }, {\n      frame: 15,\n      value: hoverSizeVec\n    }];\n    var dehydrateKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 15,\n      value: Vector3.ZeroReadOnly\n    }];\n    var touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    touchAction.setEasingFunction(easingFunction);\n    releaseAction.setEasingFunction(easingFunction);\n    hydrateAction.setEasingFunction(easingFunction);\n    dehydrateAction.setEasingFunction(easingFunction);\n    touchAction.setKeys(touchKeys);\n    releaseAction.setKeys(releaseKeys);\n    hydrateAction.setKeys(hydrateKeys);\n    dehydrateAction.setKeys(dehydrateKeys);\n\n    var touchCollisionMeshFunction = function touchCollisionMeshFunction(isTouch) {\n      var action = isTouch ? touchAction : releaseAction;\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\n    };\n\n    var hydrateCollisionMeshFunction = function hydrateCollisionMeshFunction(isHydration) {\n      var action = isHydration ? hydrateAction : dehydrateAction;\n\n      if (isHydration) {\n        touchCollisionMesh.isVisible = true;\n      }\n\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, function () {\n        if (!isHydration) {\n          touchCollisionMesh.isVisible = false;\n        }\n      });\n    };\n\n    return {\n      touchCollisionMesh: touchCollisionMesh,\n      touchCollisionMeshFunction: touchCollisionMeshFunction,\n      hydrateCollisionMeshFunction: hydrateCollisionMeshFunction\n    };\n  };\n\n  WebXRNearInteraction.prototype._pickWithSphere = function (controllerData, radius, sceneToUse, predicate) {\n    var pickingInfo = new PickingInfo();\n    pickingInfo.distance = +Infinity;\n\n    if (controllerData.touchCollisionMesh && controllerData.xrController) {\n      var position = controllerData.touchCollisionMesh.position;\n      var sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\n\n      for (var meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\n        var mesh = sceneToUse.meshes[meshIndex];\n\n        if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\n          continue;\n        }\n\n        var result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\n\n        if (result && result.hit && result.distance < pickingInfo.distance) {\n          pickingInfo.hit = result.hit;\n          pickingInfo.pickedMesh = mesh;\n          pickingInfo.pickedPoint = result.pickedPoint;\n          pickingInfo.aimTransform = controllerData.xrController.pointer;\n          pickingInfo.gripTransform = controllerData.xrController.grip || null;\n          pickingInfo.originMesh = controllerData.touchCollisionMesh;\n          pickingInfo.distance = result.distance;\n        }\n      }\n    }\n\n    return pickingInfo;\n  };\n  /**\n   * Picks a mesh with a sphere\n   * @param mesh the mesh to pick\n   * @param sphere picking sphere in world coordinates\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   */\n\n\n  WebXRNearInteraction.PickMeshWithSphere = function (mesh, sphere, skipBoundingInfo) {\n    if (skipBoundingInfo === void 0) {\n      skipBoundingInfo = false;\n    }\n\n    var subMeshes = mesh.subMeshes;\n    var pi = new PickingInfo();\n    var boundingInfo = mesh.getBoundingInfo();\n\n    if (!mesh._generatePointsArray()) {\n      return pi;\n    }\n\n    if (!mesh.subMeshes || !boundingInfo) {\n      return pi;\n    }\n\n    if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\n      return pi;\n    }\n\n    var result = TmpVectors.Vector3[0];\n    var tmpVec = TmpVectors.Vector3[1];\n    var distance = +Infinity;\n    var tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;\n    var center = TmpVectors.Vector3[2];\n    var worldToMesh = TmpVectors.Matrix[0];\n    worldToMesh.copyFrom(mesh.getWorldMatrix());\n    worldToMesh.invert();\n    Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\n\n    for (var index = 0; index < subMeshes.length; index++) {\n      var subMesh = subMeshes[index];\n      subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);\n      Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\n      tmp = Vector3.Distance(tmpVec, sphere.center); // Check for finger inside of mesh\n\n      tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\n      tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\n\n      if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\n        tmp = 0;\n        tmpVec.copyFrom(sphere.center);\n      }\n\n      if (tmp !== -1 && tmp < distance) {\n        distance = tmp;\n        result.copyFrom(tmpVec);\n      }\n    }\n\n    if (distance < sphere.radius) {\n      pi.hit = true;\n      pi.distance = distance;\n      pi.pickedMesh = mesh;\n      pi.pickedPoint = result.clone();\n    }\n\n    return pi;\n  };\n\n  WebXRNearInteraction._IdCounter = 200;\n  /**\n   * The module's name\n   */\n\n  WebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRNearInteraction.Version = 1;\n  return WebXRNearInteraction;\n}(WebXRAbstractFeature);\n\nexport { WebXRNearInteraction }; //Register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRNearInteraction(xrSessionManager, options);\n  };\n}, WebXRNearInteraction.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","CreateSphere","Vector3","Quaternion","TmpVectors","Ray","PickingInfo","WebXRAbstractFeature","UtilityLayerRenderer","BoundingSphere","StandardMaterial","Color3","NodeMaterial","Animation","QuadraticEase","EasingFunction","ControllerOrbAnimationState","WebXRNearControllerMode","__extends","_xrSessionManager","_options","_super","_this","xrController","_controllers","uniqueId","_generateNewTouchPointMesh","touchCollisionMesh","touchCollisionMeshFunction","hydrateCollisionMeshFunction","selectionMesh","_generateVisualCue","meshUnderPointer","nearInteractionTargetMesh","pick","stalePick","currentAnimationState","DEHYDRATED","grabRay","hoverInteraction","nearInteraction","grabInteraction","id","WebXRNearInteraction","_IdCounter","pickedPointVisualCue","_attachedController","enableNearInteractionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachNearInteractionMode","_scene","scene","nearInteractionControllerMode","undefined","CENTERED_IN_FRONT","farInteractionFeature","_farInteractionFeature","attach","call","xrInput","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","constantlyUpdateMeshUnderPointer","detach","Object","keys","controllerId","i","length","mesh","isEnabled","isVisible","isPickable","isNearPickable","isNearGrabbable","parent","reservedDataStore","excludedControllerId","controllerData","newState","_a","hand","HOVER","TOUCH","position","orientation","origin","copyFrom","toEulerAnglesToRef","direction","getWorldPointerRayToRef","_tmpRay","addInPlace","scale","_nearGrabLengthScale","_hoverRadius","_xrFrame","handData","gamepad","xrIndexTip","get","indexTipPose","getJointPose","referenceSpace","transform","axisRHSMultiplier","useRightHandedSystem","set","x","y","z","w","_processTouchPoint","DISABLED","controllerPose","pointer","grip","CENTERED_ON_CONTROLLER","rotationQuaternion","accuratePickInfo","originalScenePick","utilityScenePick","hit","distance","populateNearInteractionInfo","nearInteractionInfo","result","nearInteractionAtOrigin","pickedPoint","utilitySceneHoverPick","useUtilityLayer","_utilityLayerScene","_pickWithSphere","_nearInteractionPredicate","originalSceneHoverPick","hoverPickInfo","utilitySceneNearPick","radius","_pickRadius","_controllerPickRadius","_nearPickPredicate","originalSceneNearPick","pickInfo","nearPick","pickedMesh","attached","_setPointerSelectionDisabledByPointerId","state","_handleTransitionAnimation","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","sceneToRenderTo","diameter","bakeCurrentTransformIntoVertices","Identity","targetMat","specularColor","Black","emissiveColor","selectionMeshDefaultColor","backFaceCulling","material","_getPointerSelectionDisabledByPointerId","pointerEventInit","pointerId","pointerType","onFrameObserver","onXRFrameObservable","add","ray","_isControllerReadyForNearInteraction","simulatePointerMove","simulatePointerDown","simulatePointerUp","grabCheck","pressed","_nearGrabPredicate","disableSwitchOnClick","init","motionController","squeezeComponent","getComponent","onSqueezeButtonChangedObserver","onButtonStateChangedObservable","component","changes","current","selectionComponent","getMainComponent","onButtonChangedObserver","onMotionControllerInitObservable","selectStartListener","event","selectEndListener","eventListeners","selectend","selectstart","session","addEventListener","xrControllerUniqueId","remove","eventName","func","removeEventListener","dispose","runInXRFrame","meshCreationScene","motionControllerOrbMaterial","ParseFromSnippetAsync","then","nodeMaterial","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","hoverSizeVec","touchSize","touchSizeVec","hydrateTransitionSize","hydrateTransitionSizeVec","touchHoverTransitionSize","touchHoverTransitionSizeVec","hoverTouchTransitionSize","hoverTouchTransitionSizeVec","touchKeys","frame","value","releaseKeys","hydrateKeys","ZeroReadOnly","dehydrateKeys","touchAction","ANIMATIONTYPE_VECTOR3","ANIMATIONLOOPMODE_CONSTANT","releaseAction","hydrateAction","dehydrateAction","setEasingFunction","setKeys","isTouch","action","beginDirectAnimation","isHydration","sceneToUse","predicate","pickingInfo","Infinity","sphere","CreateFromCenterAndRadius","meshIndex","meshes","_controllerAvailablePredicate","PickMeshWithSphere","aimTransform","gripTransform","originMesh","skipBoundingInfo","subMeshes","pi","boundingInfo","getBoundingInfo","_generatePointsArray","Intersects","boundingSphere","tmpVec","tmp","tmpDistanceSphereToCenter","tmpDistanceSurfaceToCenter","center","worldToMesh","Matrix","getWorldMatrix","invert","TransformCoordinatesToRef","index","subMesh","projectToRef","_positions","getIndices","Distance","getAbsolutePosition","clone","NEAR_INTERACTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRNearInteraction.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRControllerPointerSelection } from \"./WebXRControllerPointerSelection\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { IndicesArray, Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { BoundingSphere } from \"../../Culling/boundingSphere\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing\";\r\n// side effects\r\nimport \"../../Meshes/subMesh.project\";\r\n\r\ntype ControllerData = {\r\n    xrController?: WebXRInputSource;\r\n    squeezeComponent?: WebXRControllerComponent;\r\n    selectionComponent?: WebXRControllerComponent;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onSqueezeButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n    meshUnderPointer: Nullable<AbstractMesh>;\r\n    nearInteractionTargetMesh: Nullable<AbstractMesh>;\r\n    pick: Nullable<PickingInfo>;\r\n    stalePick: Nullable<PickingInfo>;\r\n    id: number;\r\n    touchCollisionMesh: AbstractMesh;\r\n    touchCollisionMeshFunction: (isTouch: boolean) => void;\r\n    hydrateCollisionMeshFunction: (isHydration: boolean) => void;\r\n    currentAnimationState: ControllerOrbAnimationState;\r\n    grabRay: Ray;\r\n    nearInteraction: boolean;\r\n    hoverInteraction: boolean;\r\n    grabInteraction: boolean;\r\n    // event support\r\n    eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n    pickedPointVisualCue: AbstractMesh;\r\n};\r\n\r\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\r\nenum ControllerOrbAnimationState {\r\n    /**\r\n     * Orb is invisible\r\n     */\r\n    DEHYDRATED,\r\n    /**\r\n     * Orb is visible and inside the hover range\r\n     */\r\n    HOVER,\r\n    /**\r\n     * Orb is visible and touching a near interaction target\r\n     */\r\n    TOUCH,\r\n}\r\n\r\n/**\r\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\r\n */\r\nexport enum WebXRNearControllerMode {\r\n    /**\r\n     * Motion controllers will not support near interaction\r\n     */\r\n    DISABLED = 0,\r\n    /**\r\n     * The interaction point for motion controllers will be inside of them\r\n     */\r\n    CENTERED_ON_CONTROLLER = 1,\r\n    /**\r\n     * The interaction point for motion controllers will be in front of the controller\r\n     */\r\n    CENTERED_IN_FRONT = 2,\r\n}\r\n\r\n/**\r\n * Options interface for the near interaction module\r\n */\r\nexport interface IWebXRNearInteractionOptions {\r\n    /**\r\n     * If provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * The xr input to use with this near interaction\r\n     */\r\n    xrInput: WebXRInput;\r\n    /**\r\n     * Enable near interaction on all controllers instead of switching between them\r\n     */\r\n    enableNearInteractionOnAllControllers?: boolean;\r\n    /**\r\n     * The preferred hand to give the near interaction to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n    /**\r\n     * Disable switching the near interaction from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * Far interaction feature to toggle when near interaction takes precedence\r\n     */\r\n    farInteractionFeature?: WebXRControllerPointerSelection;\r\n\r\n    /**\r\n     * Near interaction mode for motion controllers\r\n     */\r\n    nearInteractionControllerMode?: WebXRNearControllerMode;\r\n\r\n    /**\r\n     * Optional material for the motion controller orb, if enabled\r\n     */\r\n    motionControllerOrbMaterial?: Material;\r\n}\r\n\r\n/**\r\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\r\n */\r\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _tmpRay: Ray = new Ray(new Vector3(), new Vector3());\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        // get two new meshes\r\n        const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n        const selectionMesh = this._generateVisualCue();\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            meshUnderPointer: null,\r\n            nearInteractionTargetMesh: null,\r\n            pick: null,\r\n            stalePick: null,\r\n            touchCollisionMesh,\r\n            touchCollisionMeshFunction: touchCollisionMeshFunction,\r\n            hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\r\n            currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\r\n            grabRay: new Ray(new Vector3(), new Vector3()),\r\n            hoverInteraction: false,\r\n            nearInteraction: false,\r\n            grabInteraction: false,\r\n            id: WebXRNearInteraction._IdCounter++,\r\n            pickedPointVisualCue: selectionMesh,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enableNearInteractionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enableNearInteractionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachNearInteractionMode(xrController);\r\n            case \"gaze\":\r\n                return null;\r\n            case \"screen\":\r\n                return null;\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: ControllerData;\r\n    } = {};\r\n    private _scene: Scene;\r\n\r\n    private _attachedController: string;\r\n\r\n    private _farInteractionFeature: Nullable<WebXRControllerPointerSelection> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.NEAR_INTERACTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRNearInteractionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n        if (this._options.nearInteractionControllerMode === undefined) {\r\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\r\n        }\r\n\r\n        if (this._options.farInteractionFeature) {\r\n            this._farInteractionFeature = this._options.farInteractionFeature;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\r\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\r\n     */\r\n    public setFarInteractionFeature(farInteractionFeature: Nullable<WebXRControllerPointerSelection>) {\r\n        this._farInteractionFeature = farInteractionFeature;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction pick and hover\r\n     * @param mesh\r\n     */\r\n    private _nearPickPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction grab\r\n     * @param mesh\r\n     */\r\n    private _nearGrabPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for any near interaction\r\n     * @param mesh\r\n     */\r\n    private _nearInteractionPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\r\n    }\r\n\r\n    private _controllerAvailablePredicate(mesh: AbstractMesh, controllerId: string): boolean {\r\n        let parent: TransformNode = mesh;\r\n\r\n        while (parent) {\r\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\r\n                return false;\r\n            }\r\n            parent = parent.parent as TransformNode;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _handleTransitionAnimation(controllerData: ControllerData, newState: ControllerOrbAnimationState) {\r\n        if (\r\n            controllerData.currentAnimationState === newState ||\r\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\r\n            !!controllerData.xrController?.inputSource.hand\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\r\n        if (newState > controllerData.currentAnimationState) {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.DEHYDRATED: {\r\n                    controllerData.hydrateCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.touchCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.TOUCH: {\r\n                    controllerData.touchCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.hydrateCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        controllerData.currentAnimationState = newState;\r\n    }\r\n\r\n    private readonly _hoverRadius = 0.1;\r\n    private readonly _pickRadius = 0.02;\r\n    private readonly _controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\r\n    private readonly _nearGrabLengthScale = 5;\r\n\r\n    private _processTouchPoint(id: string, position: Vector3, orientation: Quaternion) {\r\n        const controllerData = this._controllers[id];\r\n\r\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\r\n        controllerData.grabRay.origin.copyFrom(position);\r\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\r\n\r\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\r\n            // offset the touch point in the direction the transform is facing\r\n            controllerData.xrController!.getWorldPointerRayToRef(this._tmpRay);\r\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\r\n        }\r\n\r\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;\r\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            const handData = controllerData.xrController?.inputSource.hand;\r\n            // If near interaction is not enabled/available for this controller, return early\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n            controllerData.hoverInteraction = false;\r\n            controllerData.nearInteraction = false;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                if (handData) {\r\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\r\n                    if (xrIndexTip) {\r\n                        const indexTipPose = _xrFrame.getJointPose!(xrIndexTip, this._xrSessionManager.referenceSpace);\r\n                        if (indexTipPose && indexTipPose.transform) {\r\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\r\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\r\n                            TmpVectors.Quaternion[0].set(\r\n                                indexTipPose.transform.orientation.x,\r\n                                indexTipPose.transform.orientation.y,\r\n                                indexTipPose.transform.orientation.z * axisRHSMultiplier,\r\n                                indexTipPose.transform.orientation.w * axisRHSMultiplier\r\n                            );\r\n\r\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\r\n                        }\r\n                    }\r\n                } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\r\n                    let controllerPose = controllerData.xrController.pointer;\r\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\r\n                        controllerPose = controllerData.xrController.grip;\r\n                    }\r\n\r\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion!);\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const accuratePickInfo = (originalScenePick: Nullable<PickingInfo>, utilityScenePick: Nullable<PickingInfo>): Nullable<PickingInfo> => {\r\n                let pick = null;\r\n                if (!utilityScenePick || !utilityScenePick.hit) {\r\n                    // No hit in utility scene\r\n                    pick = originalScenePick;\r\n                } else if (!originalScenePick || !originalScenePick.hit) {\r\n                    // No hit in original scene\r\n                    pick = utilityScenePick;\r\n                } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                    // Hit is closer in utility scene\r\n                    pick = utilityScenePick;\r\n                } else {\r\n                    // Hit is closer in original scene\r\n                    pick = originalScenePick;\r\n                }\r\n                return pick;\r\n            };\r\n            const populateNearInteractionInfo = (nearInteractionInfo: Nullable<PickingInfo>): PickingInfo => {\r\n                let result = new PickingInfo();\r\n\r\n                let nearInteractionAtOrigin = false;\r\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\r\n                if (nearInteractionInfo?.pickedPoint) {\r\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\r\n                }\r\n                if (nearInteraction && !nearInteractionAtOrigin) {\r\n                    result = nearInteractionInfo!;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\r\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\r\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\r\n            if (!controllerData.grabInteraction) {\r\n                let pick = null;\r\n\r\n                // near interaction hover\r\n                let utilitySceneHoverPick = null;\r\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                    utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._utilityLayerScene, (mesh: AbstractMesh) =>\r\n                        this._nearInteractionPredicate(mesh)\r\n                    );\r\n                }\r\n                const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._scene, (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh));\r\n\r\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\r\n                if (hoverPickInfo && hoverPickInfo.hit) {\r\n                    pick = populateNearInteractionInfo(hoverPickInfo);\r\n                    if (pick.hit) {\r\n                        controllerData.hoverInteraction = true;\r\n                    }\r\n                }\r\n\r\n                // near interaction pick\r\n                if (controllerData.hoverInteraction) {\r\n                    let utilitySceneNearPick = null;\r\n                    const radius = handData ? this._pickRadius : this._controllerPickRadius;\r\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    }\r\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\r\n                    const nearPick = populateNearInteractionInfo(pickInfo);\r\n                    if (nearPick.hit) {\r\n                        // Near pick takes precedence over hover interaction\r\n                        pick = nearPick;\r\n                        controllerData.nearInteraction = true;\r\n                    }\r\n                }\r\n\r\n                controllerData.stalePick = controllerData.pick;\r\n                controllerData.pick = pick;\r\n\r\n                // Update mesh under pointer\r\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\r\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\r\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\r\n                    }\r\n                } else {\r\n                    controllerData.meshUnderPointer = null;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the interaction animation. Only updates if the visible touch mesh is active\r\n            let state = ControllerOrbAnimationState.DEHYDRATED;\r\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\r\n                state = ControllerOrbAnimationState.TOUCH;\r\n            } else if (controllerData.hoverInteraction) {\r\n                state = ControllerOrbAnimationState.HOVER;\r\n            }\r\n            this._handleTransitionAnimation(controllerData, state);\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _generateVisualCue() {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const selectionMesh = CreateSphere(\r\n            \"nearInteraction\",\r\n            {\r\n                diameter: 0.0035 * 3,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        return selectionMesh;\r\n    }\r\n\r\n    private _isControllerReadyForNearInteraction(id: number) {\r\n        if (this._farInteractionFeature) {\r\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _attachNearInteractionMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                return;\r\n            }\r\n            if (controllerData.pick) {\r\n                controllerData.pick.ray = controllerData.grabRay;\r\n            }\r\n\r\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n\r\n            // Near pick pointer event\r\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\r\n                if (!controllerData.nearInteractionTargetMesh) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\r\n                }\r\n            } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\r\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\r\n                controllerData.nearInteractionTargetMesh = null;\r\n            }\r\n        });\r\n\r\n        const grabCheck = (pressed: boolean) => {\r\n            if (\r\n                this._options.enableNearInteractionOnAllControllers ||\r\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))\r\n            ) {\r\n                if (controllerData.pick) {\r\n                    controllerData.pick.ray = controllerData.grabRay;\r\n                }\r\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            } else {\r\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                    this._attachedController = xrController.uniqueId;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\r\n                if (controllerData.squeezeComponent) {\r\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                } else {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\r\n                    controllerData.meshUnderPointer &&\r\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)\r\n                ) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id)\r\n                ) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.squeezeComponent) {\r\n            if (controllerData.onSqueezeButtonChangedObserver) {\r\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func);\r\n                }\r\n            });\r\n        }\r\n        controllerData.touchCollisionMesh.dispose();\r\n        controllerData.pickedPointVisualCue.dispose();\r\n\r\n        this._xrSessionManager.runInXRFrame(() => {\r\n            // Fire a pointerup\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n        });\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewTouchPointMesh() {\r\n        // populate information for near hover, pick and pinch\r\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n\r\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 }, meshCreationScene);\r\n        touchCollisionMesh.isVisible = false;\r\n\r\n        // Generate the material for the touch mesh visuals\r\n        if (this._options.motionControllerOrbMaterial) {\r\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\r\n        } else {\r\n            NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then((nodeMaterial) => {\r\n                touchCollisionMesh.material = nodeMaterial;\r\n            });\r\n        }\r\n\r\n        const easingFunction = new QuadraticEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n\r\n        // Adjust the visual size based off of the size of the touch collision orb.\r\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\r\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\r\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);\r\n        const touchSize = this._controllerPickRadius * (4 / 3);\r\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize);\r\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\r\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);\r\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\r\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);\r\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\r\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);\r\n\r\n        const touchKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: hoverTouchTransitionSizeVec },\r\n            { frame: 18, value: touchSizeVec },\r\n        ];\r\n        const releaseKeys = [\r\n            { frame: 0, value: touchSizeVec },\r\n            { frame: 10, value: touchHoverTransitionSizeVec },\r\n            { frame: 18, value: hoverSizeVec },\r\n        ];\r\n        const hydrateKeys = [\r\n            { frame: 0, value: Vector3.ZeroReadOnly },\r\n            { frame: 12, value: hydrateTransitionSizeVec },\r\n            { frame: 15, value: hoverSizeVec },\r\n        ];\r\n        const dehydrateKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: Vector3.ZeroReadOnly },\r\n            { frame: 15, value: Vector3.ZeroReadOnly },\r\n        ];\r\n\r\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        touchAction.setEasingFunction(easingFunction);\r\n        releaseAction.setEasingFunction(easingFunction);\r\n        hydrateAction.setEasingFunction(easingFunction);\r\n        dehydrateAction.setEasingFunction(easingFunction);\r\n\r\n        touchAction.setKeys(touchKeys);\r\n        releaseAction.setKeys(releaseKeys);\r\n        hydrateAction.setKeys(hydrateKeys);\r\n        dehydrateAction.setKeys(dehydrateKeys);\r\n\r\n        const touchCollisionMeshFunction = (isTouch: boolean) => {\r\n            const action = isTouch ? touchAction : releaseAction;\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\r\n        };\r\n\r\n        const hydrateCollisionMeshFunction = (isHydration: boolean) => {\r\n            const action = isHydration ? hydrateAction : dehydrateAction;\r\n            if (isHydration) {\r\n                touchCollisionMesh.isVisible = true;\r\n            }\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\r\n                if (!isHydration) {\r\n                    touchCollisionMesh.isVisible = false;\r\n                }\r\n            });\r\n        };\r\n\r\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\r\n    }\r\n\r\n    private _pickWithSphere(controllerData: ControllerData, radius: number, sceneToUse: Scene, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo> {\r\n        const pickingInfo = new PickingInfo();\r\n        pickingInfo.distance = +Infinity;\r\n\r\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\r\n            const position = controllerData.touchCollisionMesh.position;\r\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\r\n\r\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\r\n                const mesh = sceneToUse.meshes[meshIndex];\r\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\r\n                    continue;\r\n                }\r\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\r\n\r\n                if (result && result.hit && result.distance < pickingInfo.distance) {\r\n                    pickingInfo.hit = result.hit;\r\n                    pickingInfo.pickedMesh = mesh;\r\n                    pickingInfo.pickedPoint = result.pickedPoint;\r\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\r\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\r\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\r\n                    pickingInfo.distance = result.distance;\r\n                }\r\n            }\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Picks a mesh with a sphere\r\n     * @param mesh the mesh to pick\r\n     * @param sphere picking sphere in world coordinates\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public static PickMeshWithSphere(mesh: AbstractMesh, sphere: BoundingSphere, skipBoundingInfo = false): PickingInfo {\r\n        const subMeshes = mesh.subMeshes;\r\n        const pi = new PickingInfo();\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (!mesh._generatePointsArray()) {\r\n            return pi;\r\n        }\r\n\r\n        if (!mesh.subMeshes || !boundingInfo) {\r\n            return pi;\r\n        }\r\n\r\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\r\n            return pi;\r\n        }\r\n\r\n        const result = TmpVectors.Vector3[0];\r\n        const tmpVec = TmpVectors.Vector3[1];\r\n\r\n        let distance = +Infinity;\r\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;\r\n        const center = TmpVectors.Vector3[2];\r\n        const worldToMesh = TmpVectors.Matrix[0];\r\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\r\n        worldToMesh.invert();\r\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\r\n\r\n        for (let index = 0; index < subMeshes.length; index++) {\r\n            const subMesh = subMeshes[index];\r\n\r\n            subMesh.projectToRef(center, <Vector3[]>mesh._positions, <IndicesArray>mesh.getIndices(), tmpVec);\r\n\r\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\r\n            tmp = Vector3.Distance(tmpVec, sphere.center);\r\n\r\n            // Check for finger inside of mesh\r\n            tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\r\n            tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\r\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\r\n                tmp = 0;\r\n                tmpVec.copyFrom(sphere.center);\r\n            }\r\n\r\n            if (tmp !== -1 && tmp < distance) {\r\n                distance = tmp;\r\n                result.copyFrom(tmpVec);\r\n            }\r\n        }\r\n\r\n        if (distance < sphere.radius) {\r\n            pi.hit = true;\r\n            pi.distance = distance;\r\n            pi.pickedMesh = mesh;\r\n            pi.pickedPoint = result.clone();\r\n        }\r\n\r\n        return pi;\r\n    }\r\n}\r\n\r\n//Register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRNearInteraction.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRNearInteraction(xrSessionManager, options);\r\n    },\r\n    WebXRNearInteraction.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module"}