{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { InstantiationTools } from \"../../Misc/instantiationTools.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { EncodeArrayBufferToBase64, StartsWith } from \"../../Misc/stringTools.js\";\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\n * @see https://doc.babylonjs.com/babylon101/materials#texture\n */\n\nvar Texture =\n/** @class */\nfunction (_super) {\n  __extends(Texture, _super);\n  /**\n   * Instantiates a new texture.\n   * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\n   * @see https://doc.babylonjs.com/babylon101/materials#texture\n   * @param url defines the url of the picture to load as a texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\n   * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n   * @param onLoad defines a callback triggered when the texture has been loaded\n   * @param onError defines a callback triggered when an error occurred during the loading session\n   * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\n   * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\n   * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n   * @param mimeType defines an optional mime type information\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   */\n\n\n  function Texture(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions, creationFlags) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (deleteBuffer === void 0) {\n      deleteBuffer = false;\n    }\n\n    var _this = this;\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    _this = _super.call(this, sceneOrEngine) || this;\n    /**\n     * Define the url of the texture.\n     */\n\n    _this.url = null;\n    /**\n     * Define an offset on the texture to offset the u coordinates of the UVs\n     * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\n     */\n\n    _this.uOffset = 0;\n    /**\n     * Define an offset on the texture to offset the v coordinates of the UVs\n     * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\n     */\n\n    _this.vOffset = 0;\n    /**\n     * Define an offset on the texture to scale the u coordinates of the UVs\n     * @see https://doc.babylonjs.com/how_to/more_materials#tiling\n     */\n\n    _this.uScale = 1.0;\n    /**\n     * Define an offset on the texture to scale the v coordinates of the UVs\n     * @see https://doc.babylonjs.com/how_to/more_materials#tiling\n     */\n\n    _this.vScale = 1.0;\n    /**\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\n     * The angle is defined in radians.\n     * @see https://doc.babylonjs.com/how_to/more_materials\n     */\n\n    _this.uAng = 0;\n    /**\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\n     * The angle is defined in radians.\n     * @see https://doc.babylonjs.com/how_to/more_materials\n     */\n\n    _this.vAng = 0;\n    /**\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\n     * The angle is defined in radians.\n     * @see https://doc.babylonjs.com/how_to/more_materials\n     */\n\n    _this.wAng = 0;\n    /**\n     * Defines the center of rotation (U)\n     */\n\n    _this.uRotationCenter = 0.5;\n    /**\n     * Defines the center of rotation (V)\n     */\n\n    _this.vRotationCenter = 0.5;\n    /**\n     * Defines the center of rotation (W)\n     */\n\n    _this.wRotationCenter = 0.5;\n    /**\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\n     */\n\n    _this.homogeneousRotationInUVTransform = false;\n    /**\n     * List of inspectable custom properties (used by the Inspector)\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\n     */\n\n    _this.inspectableCustomProperties = null;\n    _this._noMipmap = false;\n    /** @hidden */\n\n    _this._invertY = false;\n    _this._rowGenerationMatrix = null;\n    _this._cachedTextureMatrix = null;\n    _this._projectionModeMatrix = null;\n    _this._t0 = null;\n    _this._t1 = null;\n    _this._t2 = null;\n    _this._cachedUOffset = -1;\n    _this._cachedVOffset = -1;\n    _this._cachedUScale = 0;\n    _this._cachedVScale = 0;\n    _this._cachedUAng = -1;\n    _this._cachedVAng = -1;\n    _this._cachedWAng = -1;\n    _this._cachedProjectionMatrixId = -1;\n    _this._cachedURotationCenter = -1;\n    _this._cachedVRotationCenter = -1;\n    _this._cachedWRotationCenter = -1;\n    _this._cachedHomogeneousRotationInUVTransform = false;\n    _this._cachedCoordinatesMode = -1;\n    /** @hidden */\n\n    _this._buffer = null;\n    _this._deleteBuffer = false;\n    _this._format = null;\n    _this._delayedOnLoad = null;\n    _this._delayedOnError = null;\n    /**\n     * Observable triggered once the texture has been loaded.\n     */\n\n    _this.onLoadObservable = new Observable();\n    _this._isBlocking = true;\n    _this.name = url || \"\";\n    _this.url = url;\n    var noMipmap;\n    var useSRGBBuffer = false;\n    var internalTexture = null;\n\n    if (_typeof(noMipmapOrOptions) === \"object\" && noMipmapOrOptions !== null) {\n      noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;\n      invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;\n      samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;\n      onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;\n      onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;\n      buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;\n      deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;\n      format = noMipmapOrOptions.format;\n      mimeType = noMipmapOrOptions.mimeType;\n      loaderOptions = noMipmapOrOptions.loaderOptions;\n      creationFlags = noMipmapOrOptions.creationFlags;\n      useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;\n      internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;\n    } else {\n      noMipmap = !!noMipmapOrOptions;\n    }\n\n    _this._noMipmap = noMipmap;\n    _this._invertY = invertY === undefined ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;\n    _this._initialSamplingMode = samplingMode;\n    _this._buffer = buffer;\n    _this._deleteBuffer = deleteBuffer;\n    _this._mimeType = mimeType;\n    _this._loaderOptions = loaderOptions;\n    _this._creationFlags = creationFlags;\n    _this._useSRGBBuffer = useSRGBBuffer;\n\n    if (format) {\n      _this._format = format;\n    }\n\n    var scene = _this.getScene();\n\n    var engine = _this._getEngine();\n\n    if (!engine) {\n      return _this;\n    }\n\n    engine.onBeforeTextureInitObservable.notifyObservers(_this);\n\n    var load = function load() {\n      if (_this._texture) {\n        if (_this._texture._invertVScale) {\n          _this.vScale *= -1;\n          _this.vOffset += 1;\n        } // Update texture to match internal texture's wrapping\n\n\n        if (_this._texture._cachedWrapU !== null) {\n          _this.wrapU = _this._texture._cachedWrapU;\n          _this._texture._cachedWrapU = null;\n        }\n\n        if (_this._texture._cachedWrapV !== null) {\n          _this.wrapV = _this._texture._cachedWrapV;\n          _this._texture._cachedWrapV = null;\n        }\n\n        if (_this._texture._cachedWrapR !== null) {\n          _this.wrapR = _this._texture._cachedWrapR;\n          _this._texture._cachedWrapR = null;\n        }\n      }\n\n      if (_this.onLoadObservable.hasObservers()) {\n        _this.onLoadObservable.notifyObservers(_this);\n      }\n\n      if (onLoad) {\n        onLoad();\n      }\n\n      if (!_this.isBlocking && scene) {\n        scene.resetCachedMaterial();\n      }\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      _this._loadingError = true;\n      _this._errorObject = {\n        message: message,\n        exception: exception\n      };\n\n      if (onError) {\n        onError(message, exception);\n      }\n\n      Texture.OnTextureLoadErrorObservable.notifyObservers(_this);\n    };\n\n    if (!_this.url) {\n      _this._delayedOnLoad = load;\n      _this._delayedOnError = errorHandler;\n      return _this;\n    }\n\n    _this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : _this._getFromCache(_this.url, noMipmap, samplingMode, _this._invertY, useSRGBBuffer);\n\n    if (!_this._texture) {\n      if (!scene || !scene.useDelayedTextureLoading) {\n        try {\n          _this._texture = engine.createTexture(_this.url, noMipmap, _this._invertY, scene, samplingMode, load, errorHandler, _this._buffer, undefined, _this._format, null, mimeType, loaderOptions, creationFlags, useSRGBBuffer);\n        } catch (e) {\n          errorHandler(\"error loading\", e);\n          throw e;\n        }\n\n        if (deleteBuffer) {\n          _this._buffer = null;\n        }\n      } else {\n        _this.delayLoadState = 4;\n        _this._delayedOnLoad = load;\n        _this._delayedOnError = errorHandler;\n      }\n    } else {\n      if (_this._texture.isReady) {\n        TimingTools.SetImmediate(function () {\n          return load();\n        });\n      } else {\n        var loadObserver_1 = _this._texture.onLoadedObservable.add(load);\n\n        _this._texture.onErrorObservable.add(function (e) {\n          var _a;\n\n          errorHandler(e.message, e.exception);\n          (_a = _this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.remove(loadObserver_1);\n        });\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Texture.prototype, \"noMipmap\", {\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get: function get() {\n      return this._noMipmap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture.prototype, \"mimeType\", {\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\n    get: function get() {\n      return this._mimeType;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture.prototype, \"isBlocking\", {\n    get: function get() {\n      return this._isBlocking;\n    },\n\n    /**\n     * Is the texture preventing material to render while loading.\n     * If false, a default texture will be used instead of the loading one during the preparation step.\n     */\n    set: function set(value) {\n      this._isBlocking = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture.prototype, \"invertY\", {\n    /**\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\n     */\n    get: function get() {\n      return this._invertY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Update the url (and optional buffer) of this texture if url was null during construction.\n   * @param url the url of the texture\n   * @param buffer the buffer of the texture (defaults to null)\n   * @param onLoad callback called when the texture is loaded  (defaults to null)\n   */\n\n  Texture.prototype.updateURL = function (url, buffer, onLoad) {\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (this.url) {\n      this.releaseInternalTexture();\n      this.getScene().markAllMaterialsAsDirty(1);\n    }\n\n    if (!this.name || StartsWith(this.name, \"data:\")) {\n      this.name = url;\n    }\n\n    this.url = url;\n    this._buffer = buffer;\n    this.delayLoadState = 4;\n\n    if (onLoad) {\n      this._delayedOnLoad = onLoad;\n    }\n\n    this.delayLoad();\n  };\n  /**\n   * Finish the loading sequence of a texture flagged as delayed load.\n   * @hidden\n   */\n\n\n  Texture.prototype.delayLoad = function () {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);\n\n    if (!this._texture) {\n      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);\n\n      if (this._deleteBuffer) {\n        this._buffer = null;\n      }\n    } else {\n      if (this._delayedOnLoad) {\n        if (this._texture.isReady) {\n          TimingTools.SetImmediate(this._delayedOnLoad);\n        } else {\n          this._texture.onLoadedObservable.add(this._delayedOnLoad);\n        }\n      }\n    }\n\n    this._delayedOnLoad = null;\n    this._delayedOnError = null;\n  };\n\n  Texture.prototype._prepareRowForTextureGeneration = function (x, y, z, t) {\n    x *= this._cachedUScale;\n    y *= this._cachedVScale;\n    x -= this.uRotationCenter * this._cachedUScale;\n    y -= this.vRotationCenter * this._cachedVScale;\n    z -= this.wRotationCenter;\n    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);\n    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\n    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\n    t.z += this.wRotationCenter;\n  };\n  /**\n   * Checks if the texture has the same transform matrix than another texture\n   * @param texture texture to check against\n   * @returns true if the transforms are the same, else false\n   */\n\n\n  Texture.prototype.checkTransformsAreIdentical = function (texture) {\n    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;\n  };\n  /**\n   * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\n   * @param uBase\n   * @returns the transform matrix of the texture.\n   */\n\n\n  Texture.prototype.getTextureMatrix = function (uBase) {\n    var _this = this;\n\n    if (uBase === void 0) {\n      uBase = 1;\n    }\n\n    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {\n      return this._cachedTextureMatrix;\n    }\n\n    this._cachedUOffset = this.uOffset;\n    this._cachedVOffset = this.vOffset;\n    this._cachedUScale = this.uScale * uBase;\n    this._cachedVScale = this.vScale;\n    this._cachedUAng = this.uAng;\n    this._cachedVAng = this.vAng;\n    this._cachedWAng = this.wAng;\n    this._cachedURotationCenter = this.uRotationCenter;\n    this._cachedVRotationCenter = this.vRotationCenter;\n    this._cachedWRotationCenter = this.wRotationCenter;\n    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\n\n    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\n      this._cachedTextureMatrix = Matrix.Zero();\n      this._rowGenerationMatrix = new Matrix();\n      this._t0 = Vector3.Zero();\n      this._t1 = Vector3.Zero();\n      this._t2 = Vector3.Zero();\n    }\n\n    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);\n\n    if (this.homogeneousRotationInUVTransform) {\n      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\n      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\n      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\n      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\n      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);\n\n      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\n\n      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\n\n      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix); // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\n\n\n      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\n    } else {\n      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);\n\n      this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);\n\n      this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);\n\n      this._t1.subtractInPlace(this._t0);\n\n      this._t2.subtractInPlace(this._t0);\n\n      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0.0, this._t2.x, this._t2.y, this._t2.z, 0.0, this._t0.x, this._t0.y, this._t0.z, 0.0, 0.0, 0.0, 0.0, 1.0, this._cachedTextureMatrix);\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this._cachedTextureMatrix;\n    } // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\n    // will get different values (see MaterialHelper.PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\n\n\n    scene.markAllMaterialsAsDirty(1, function (mat) {\n      return mat.hasTexture(_this);\n    });\n    return this._cachedTextureMatrix;\n  };\n  /**\n   * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\n   * @returns The reflection texture transform\n   */\n\n\n  Texture.prototype.getReflectionTextureMatrix = function () {\n    var _this = this;\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this._cachedTextureMatrix;\n    }\n\n    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {\n      if (this.coordinatesMode === Texture.PROJECTION_MODE) {\n        if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\n          return this._cachedTextureMatrix;\n        }\n      } else {\n        return this._cachedTextureMatrix;\n      }\n    }\n\n    if (!this._cachedTextureMatrix) {\n      this._cachedTextureMatrix = Matrix.Zero();\n    }\n\n    if (!this._projectionModeMatrix) {\n      this._projectionModeMatrix = Matrix.Zero();\n    }\n\n    var flagMaterialsAsTextureDirty = this._cachedCoordinatesMode !== this.coordinatesMode;\n    this._cachedUOffset = this.uOffset;\n    this._cachedVOffset = this.vOffset;\n    this._cachedUScale = this.uScale;\n    this._cachedVScale = this.vScale;\n    this._cachedCoordinatesMode = this.coordinatesMode;\n\n    switch (this.coordinatesMode) {\n      case Texture.PLANAR_MODE:\n        {\n          Matrix.IdentityToRef(this._cachedTextureMatrix);\n          this._cachedTextureMatrix[0] = this.uScale;\n          this._cachedTextureMatrix[5] = this.vScale;\n          this._cachedTextureMatrix[12] = this.uOffset;\n          this._cachedTextureMatrix[13] = this.vOffset;\n          break;\n        }\n\n      case Texture.PROJECTION_MODE:\n        {\n          Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\n          var projectionMatrix = scene.getProjectionMatrix();\n          this._cachedProjectionMatrixId = projectionMatrix.updateFlag;\n          projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\n          break;\n        }\n\n      default:\n        Matrix.IdentityToRef(this._cachedTextureMatrix);\n        break;\n    }\n\n    if (flagMaterialsAsTextureDirty) {\n      // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\n      // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\n      scene.markAllMaterialsAsDirty(1, function (mat) {\n        return mat.getActiveTextures().indexOf(_this) !== -1;\n      });\n    }\n\n    return this._cachedTextureMatrix;\n  };\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n\n\n  Texture.prototype.clone = function () {\n    var _this = this;\n\n    var options = {\n      noMipmap: this._noMipmap,\n      invertY: this._invertY,\n      samplingMode: this.samplingMode,\n      onLoad: undefined,\n      onError: undefined,\n      buffer: this._texture ? this._texture._buffer : undefined,\n      deleteBuffer: this._deleteBuffer,\n      format: this.textureFormat,\n      mimeType: this.mimeType,\n      loaderOptions: this._loaderOptions,\n      creationFlags: this._creationFlags,\n      useSRGBBuffer: this._useSRGBBuffer\n    };\n    return SerializationHelper.Clone(function () {\n      return new Texture(_this._texture ? _this._texture.url : null, _this.getScene(), options);\n    }, this);\n  };\n  /**\n   * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\n   * @returns The JSON representation of the texture\n   */\n\n\n  Texture.prototype.serialize = function () {\n    var savedName = this.name;\n\n    if (!Texture.SerializeBuffers) {\n      if (StartsWith(this.name, \"data:\")) {\n        this.name = \"\";\n      }\n    }\n\n    if (StartsWith(this.name, \"data:\") && this.url === this.name) {\n      this.url = \"\";\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (!serializationObject) {\n      return null;\n    }\n\n    if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\n      if (typeof this._buffer === \"string\" && this._buffer.substr(0, 5) === \"data:\") {\n        serializationObject.base64String = this._buffer;\n        serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\n      } else if (this.url && StartsWith(this.url, \"data:\") && this._buffer instanceof Uint8Array) {\n        serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\n      } else if (Texture.ForceSerializeBuffers || this.url && StartsWith(this.url, \"blob:\") || this._forceSerialize) {\n        serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\n      }\n    }\n\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    serializationObject._creationFlags = this._creationFlags;\n    serializationObject._useSRGBBuffer = this._useSRGBBuffer;\n    this.name = savedName;\n    return serializationObject;\n  };\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"Texture\"\n   */\n\n\n  Texture.prototype.getClassName = function () {\n    return \"Texture\";\n  };\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n\n  Texture.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onLoadObservable.clear();\n    this._delayedOnLoad = null;\n    this._delayedOnError = null;\n  };\n  /**\n   * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\n   * @param parsedTexture Define the JSON representation of the texture\n   * @param scene Define the scene the parsed texture should be instantiated in\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n   * @returns The parsed texture if successful\n   */\n\n\n  Texture.Parse = function (parsedTexture, scene, rootUrl) {\n    if (parsedTexture.customType) {\n      var customTexture = InstantiationTools.Instantiate(parsedTexture.customType); // Update Sampling Mode\n\n      var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);\n\n      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\n        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\n          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\n        }\n      }\n\n      return parsedCustomTexture;\n    }\n\n    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\n      return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\n    }\n\n    if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\n      return null;\n    }\n\n    var onLoaded = function onLoaded() {\n      // Clear cache\n      if (texture && texture._texture) {\n        texture._texture._cachedWrapU = null;\n        texture._texture._cachedWrapV = null;\n        texture._texture._cachedWrapR = null;\n      } // Update Sampling Mode\n\n\n      if (parsedTexture.samplingMode) {\n        var sampling = parsedTexture.samplingMode;\n\n        if (texture && texture.samplingMode !== sampling) {\n          texture.updateSamplingMode(sampling);\n        }\n      } // Animations\n\n\n      if (texture && parsedTexture.animations) {\n        for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n          var parsedAnimation = parsedTexture.animations[animationIndex];\n          var internalClass = GetClass(\"BABYLON.Animation\");\n\n          if (internalClass) {\n            texture.animations.push(internalClass.Parse(parsedAnimation));\n          }\n        }\n      }\n    };\n\n    var texture = SerializationHelper.Parse(function () {\n      var _a, _b, _c;\n\n      var generateMipMaps = true;\n\n      if (parsedTexture.noMipmap) {\n        generateMipMaps = false;\n      }\n\n      if (parsedTexture.mirrorPlane) {\n        var mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\n\n        mirrorTexture._waitingRenderList = parsedTexture.renderList;\n        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\n        onLoaded();\n        return mirrorTexture;\n      } else if (parsedTexture.isRenderTarget) {\n        var renderTargetTexture = null;\n\n        if (parsedTexture.isCube) {\n          // Search for an existing reflection probe (which contains a cube render target texture)\n          if (scene.reflectionProbes) {\n            for (var index = 0; index < scene.reflectionProbes.length; index++) {\n              var probe = scene.reflectionProbes[index];\n\n              if (probe.name === parsedTexture.name) {\n                return probe.cubeTexture;\n              }\n            }\n          }\n        } else {\n          renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);\n          renderTargetTexture._waitingRenderList = parsedTexture.renderList;\n        }\n\n        onLoaded();\n        return renderTargetTexture;\n      } else {\n        var texture_1;\n\n        if (parsedTexture.base64String) {\n          texture_1 = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);\n        } else {\n          var url = void 0;\n\n          if (parsedTexture.name && parsedTexture.name.indexOf(\"://\") > 0) {\n            url = parsedTexture.name;\n          } else {\n            url = rootUrl + parsedTexture.name;\n          }\n\n          if (StartsWith(parsedTexture.url, \"data:\") || Texture.UseSerializedUrlIfAny && parsedTexture.url) {\n            url = parsedTexture.url;\n          }\n\n          texture_1 = new Texture(url, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded);\n        }\n\n        return texture_1;\n      }\n    }, parsedTexture, scene);\n    return texture;\n  };\n  /**\n   * Creates a texture from its base 64 representation.\n   * @param data Define the base64 payload without the data: prefix\n   * @param name Define the name of the texture in the scene useful fo caching purpose for instance\n   * @param scene Define the scene the texture should belong to\n   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n   * @param invertY define if the texture needs to be inverted on the y axis during loading\n   * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n   * @param onLoad define a callback triggered when the texture has been loaded\n   * @param onError define a callback triggered when an error occurred during the loading session\n   * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @returns the created texture\n   */\n\n\n  Texture.CreateFromBase64String = function (data, name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    return new Texture(\"data:\" + name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, undefined, undefined, creationFlags);\n  };\n  /**\n   * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\n   * @param name Define the name of the texture in the scene useful fo caching purpose for instance\n   * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\n   * @param scene Define the scene the texture should belong to\n   * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\n   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n   * @param invertY define if the texture needs to be inverted on the y axis during loading\n   * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n   * @param onLoad define a callback triggered when the texture has been loaded\n   * @param onError define a callback triggered when an error occurred during the loading session\n   * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @returns the created texture\n   */\n\n\n  Texture.LoadFromDataString = function (name, buffer, scene, deleteBuffer, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {\n    if (deleteBuffer === void 0) {\n      deleteBuffer = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = true;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (name.substr(0, 5) !== \"data:\") {\n      name = \"data:\" + name;\n    }\n\n    return new Texture(name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, undefined, undefined, creationFlags);\n  };\n  /**\n   * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\n   */\n\n\n  Texture.SerializeBuffers = true;\n  /**\n   * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\n   * If no buffer exists, one will be created as base64 string from the internal webgl data.\n   */\n\n  Texture.ForceSerializeBuffers = false;\n  /**\n   * This observable will notify when any texture had a loading error\n   */\n\n  Texture.OnTextureLoadErrorObservable = new Observable();\n  /**\n   * @param jsonTexture\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  Texture._CubeTextureParser = function (jsonTexture, scene, rootUrl) {\n    throw _WarnImport(\"CubeTexture\");\n  };\n  /**\n   * @param name\n   * @param renderTargetSize\n   * @param scene\n   * @param generateMipMaps\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Texture._CreateMirror = function (name, renderTargetSize, scene, generateMipMaps) {\n    throw _WarnImport(\"MirrorTexture\");\n  };\n  /**\n   * @param name\n   * @param renderTargetSize\n   * @param scene\n   * @param generateMipMaps\n   * @param creationFlags\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Texture._CreateRenderTargetTexture = function (name, renderTargetSize, scene, generateMipMaps, creationFlags) {\n    throw _WarnImport(\"RenderTargetTexture\");\n  };\n  /** nearest is mag = nearest and min = nearest and mip = linear */\n\n\n  Texture.NEAREST_SAMPLINGMODE = 1;\n  /** nearest is mag = nearest and min = nearest and mip = linear */\n\n  Texture.NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear\n\n  /** Bilinear is mag = linear and min = linear and mip = nearest */\n\n  Texture.BILINEAR_SAMPLINGMODE = 2;\n  /** Bilinear is mag = linear and min = linear and mip = nearest */\n\n  Texture.LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest\n\n  /** Trilinear is mag = linear and min = linear and mip = linear */\n\n  Texture.TRILINEAR_SAMPLINGMODE = 3;\n  /** Trilinear is mag = linear and min = linear and mip = linear */\n\n  Texture.LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear\n\n  /** mag = nearest and min = nearest and mip = nearest */\n\n  Texture.NEAREST_NEAREST_MIPNEAREST = 4;\n  /** mag = nearest and min = linear and mip = nearest */\n\n  Texture.NEAREST_LINEAR_MIPNEAREST = 5;\n  /** mag = nearest and min = linear and mip = linear */\n\n  Texture.NEAREST_LINEAR_MIPLINEAR = 6;\n  /** mag = nearest and min = linear and mip = none */\n\n  Texture.NEAREST_LINEAR = 7;\n  /** mag = nearest and min = nearest and mip = none */\n\n  Texture.NEAREST_NEAREST = 1;\n  /** mag = linear and min = nearest and mip = nearest */\n\n  Texture.LINEAR_NEAREST_MIPNEAREST = 9;\n  /** mag = linear and min = nearest and mip = linear */\n\n  Texture.LINEAR_NEAREST_MIPLINEAR = 10;\n  /** mag = linear and min = linear and mip = none */\n\n  Texture.LINEAR_LINEAR = 2;\n  /** mag = linear and min = nearest and mip = none */\n\n  Texture.LINEAR_NEAREST = 12;\n  /** Explicit coordinates mode */\n\n  Texture.EXPLICIT_MODE = 0;\n  /** Spherical coordinates mode */\n\n  Texture.SPHERICAL_MODE = 1;\n  /** Planar coordinates mode */\n\n  Texture.PLANAR_MODE = 2;\n  /** Cubic coordinates mode */\n\n  Texture.CUBIC_MODE = 3;\n  /** Projection coordinates mode */\n\n  Texture.PROJECTION_MODE = 4;\n  /** Inverse Cubic coordinates mode */\n\n  Texture.SKYBOX_MODE = 5;\n  /** Inverse Cubic coordinates mode */\n\n  Texture.INVCUBIC_MODE = 6;\n  /** Equirectangular coordinates mode */\n\n  Texture.EQUIRECTANGULAR_MODE = 7;\n  /** Equirectangular Fixed coordinates mode */\n\n  Texture.FIXED_EQUIRECTANGULAR_MODE = 8;\n  /** Equirectangular Fixed Mirrored coordinates mode */\n\n  Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\n  /** Texture is not repeating outside of 0..1 UVs */\n\n  Texture.CLAMP_ADDRESSMODE = 0;\n  /** Texture is repeating outside of 0..1 UVs */\n\n  Texture.WRAP_ADDRESSMODE = 1;\n  /** Texture is repeating and mirrored */\n\n  Texture.MIRROR_ADDRESSMODE = 2;\n  /**\n   * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\n   */\n\n  Texture.UseSerializedUrlIfAny = false;\n\n  __decorate([serialize()], Texture.prototype, \"url\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"uOffset\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"vOffset\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"uScale\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"vScale\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"uAng\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"vAng\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"wAng\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"uRotationCenter\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"vRotationCenter\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"wRotationCenter\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"homogeneousRotationInUVTransform\", void 0);\n\n  __decorate([serialize()], Texture.prototype, \"isBlocking\", null);\n\n  return Texture;\n}(BaseTexture);\n\nexport { Texture }; // References the dependencies.\n\nRegisterClass(\"BABYLON.Texture\", Texture);\nSerializationHelper._TextureParser = Texture.Parse;","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Observable","Matrix","TmpVectors","Vector3","BaseTexture","GetClass","RegisterClass","_WarnImport","TimingTools","InstantiationTools","Plane","EncodeArrayBufferToBase64","StartsWith","GenerateBase64StringFromTexture","GenerateBase64StringFromTextureAsync","CompatibilityOptions","__extends","url","sceneOrEngine","noMipmapOrOptions","invertY","samplingMode","onLoad","onError","buffer","deleteBuffer","format","mimeType","loaderOptions","creationFlags","Texture","TRILINEAR_SAMPLINGMODE","_super","_this","name","noMipmap","useSRGBBuffer","internalTexture","_a","_b","UseOpenGLOrientationForUV","_c","_d","_e","_f","_g","_h","_j","_noMipmap","_invertY","undefined","_initialSamplingMode","_buffer","_deleteBuffer","_mimeType","_loaderOptions","_creationFlags","_useSRGBBuffer","_format","scene","getScene","engine","_getEngine","onBeforeTextureInitObservable","notifyObservers","load","_texture","_invertVScale","vScale","vOffset","_cachedWrapU","wrapU","_cachedWrapV","wrapV","_cachedWrapR","wrapR","onLoadObservable","hasObservers","isBlocking","resetCachedMaterial","errorHandler","message","exception","_loadingError","_errorObject","OnTextureLoadErrorObservable","_delayedOnLoad","_delayedOnError","_getFromCache","useDelayedTextureLoading","createTexture","e","delayLoadState","isReady","SetImmediate","loadObserver_1","onLoadedObservable","add","onErrorObservable","remove","Object","_isBlocking","value","releaseInternalTexture","markAllMaterialsAsDirty","delayLoad","getEngine","x","y","z","t","_cachedUScale","_cachedVScale","uRotationCenter","vRotationCenter","wRotationCenter","TransformCoordinatesFromFloatsToRef","_rowGenerationMatrix","_cachedUOffset","_cachedVOffset","texture","uOffset","uScale","uAng","vAng","wAng","uBase","_cachedUAng","_cachedVAng","_cachedWAng","_cachedURotationCenter","_cachedVRotationCenter","_cachedWRotationCenter","homogeneousRotationInUVTransform","_cachedHomogeneousRotationInUVTransform","_cachedTextureMatrix","Zero","_t0","_t1","_t2","RotationYawPitchRollToRef","TranslationToRef","ScalingToRef","multiplyToRef","setRowFromFloats","m","_prepareRowForTextureGeneration","subtractInPlace","FromValuesToRef","mat","hasTexture","coordinatesMode","_cachedCoordinatesMode","PROJECTION_MODE","_cachedProjectionMatrixId","getProjectionMatrix","updateFlag","_projectionModeMatrix","flagMaterialsAsTextureDirty","PLANAR_MODE","IdentityToRef","projectionMatrix","getActiveTextures","indexOf","options","textureFormat","Clone","savedName","SerializeBuffers","serializationObject","call","ForceSerializeBuffers","substr","base64String","replace","Uint8Array","_forceSerialize","_engine","_features","supportSyncTextureRead","dispose","clear","parsedTexture","rootUrl","customType","customTexture","Instantiate","parsedCustomTexture","Parse","updateSamplingMode","_samplingMode","isCube","isRenderTarget","_CubeTextureParser","onLoaded","sampling","animations","animationIndex","length","parsedAnimation","internalClass","push","generateMipMaps","mirrorPlane","mirrorTexture","_CreateMirror","renderTargetSize","_waitingRenderList","renderList","FromArray","renderTargetTexture","reflectionProbes","index","probe","cubeTexture","_CreateRenderTargetTexture","texture_1","CreateFromBase64String","UseSerializedUrlIfAny","data","jsonTexture","__decorate","_TextureParser"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/texture.ts"],"sourcesContent":["import { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { InstantiationTools } from \"../../Misc/instantiationTools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { EncodeArrayBufferToBase64, StartsWith } from \"../../Misc/stringTools\";\r\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\ndeclare type CubeTexture = import(\"../../Materials/Textures/cubeTexture\").CubeTexture;\r\ndeclare type MirrorTexture = import(\"../../Materials/Textures/mirrorTexture\").MirrorTexture;\r\ndeclare type RenderTargetTexture = import(\"../../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Defines the available options when creating a texture\r\n */\r\nexport interface ITextureCreationOptions {\r\n    /** Defines if the texture will require mip maps or not (default: false) */\r\n    noMipmap?: boolean;\r\n\r\n    /** Defines if the texture needs to be inverted on the y axis during loading (default: true) */\r\n    invertY?: boolean;\r\n\r\n    /** Defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...) (default: Texture.TRILINEAR_SAMPLINGMODE) */\r\n    samplingMode?: number;\r\n\r\n    /** Defines a callback triggered when the texture has been loaded (default: null) */\r\n    onLoad?: Nullable<() => void>;\r\n\r\n    /** Defines a callback triggered when an error occurred during the loading session (default: null) */\r\n    onError?: Nullable<(message?: string, exception?: any) => void>;\r\n\r\n    /** Defines the buffer to load the texture from in case the texture is loaded from a buffer representation (default: null) */\r\n    buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;\r\n\r\n    /** Defines if the buffer we are loading the texture from should be deleted after load (default: false) */\r\n    deleteBuffer?: boolean;\r\n\r\n    /** Defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...) (default: ) */\r\n    format?: number;\r\n\r\n    /** Defines an optional mime type information (default: undefined) */\r\n    mimeType?: string;\r\n\r\n    /** Options to be passed to the loader (default: undefined) */\r\n    loaderOptions?: any;\r\n\r\n    /** Specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg) (default: undefined) */\r\n    creationFlags?: number;\r\n\r\n    /** Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture from an already existing one */\r\n    internalTexture?: InternalTexture;\r\n}\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    public static ForceSerializeBuffers = false;\r\n\r\n    /**\r\n     * This observable will notify when any texture had a loading error\r\n     */\r\n    public static OnTextureLoadErrorObservable = new Observable<BaseTexture>();\r\n\r\n    /**\r\n     * @param jsonTexture\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _WarnImport(\"CubeTexture\");\r\n    };\r\n    /**\r\n     * @param name\r\n     * @param renderTargetSize\r\n     * @param scene\r\n     * @param generateMipMaps\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _WarnImport(\"MirrorTexture\");\r\n    };\r\n    /**\r\n     * @param name\r\n     * @param renderTargetSize\r\n     * @param scene\r\n     * @param generateMipMaps\r\n     * @param creationFlags\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number): RenderTargetTexture => {\r\n        throw _WarnImport(\"RenderTargetTexture\");\r\n    };\r\n\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n     */\r\n    @serialize()\r\n    public homogeneousRotationInUVTransform = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    private _noMipmap: boolean = false;\r\n    /** @hidden */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedProjectionMatrixId: number = -1;\r\n    private _cachedURotationCenter: number = -1;\r\n    private _cachedVRotationCenter: number = -1;\r\n    private _cachedWRotationCenter: number = -1;\r\n    private _cachedHomogeneousRotationInUVTransform: boolean = false;\r\n    private _cachedCoordinatesMode: number = -1;\r\n\r\n    /** @hidden */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n    private _loaderOptions?: any;\r\n    private _creationFlags?: number;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n    public get mimeType() {\r\n        return this._mimeType;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        url: Nullable<string>,\r\n        sceneOrEngine?: Nullable<Scene | ThinEngine>,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        deleteBuffer: boolean = false,\r\n        format?: number,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n\r\n        let noMipmap: boolean;\r\n        let useSRGBBuffer: boolean = false;\r\n        let internalTexture: Nullable<InternalTexture> = null;\r\n\r\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\r\n            noMipmap = noMipmapOrOptions.noMipmap ?? false;\r\n            invertY = noMipmapOrOptions.invertY ?? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true);\r\n            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            onLoad = noMipmapOrOptions.onLoad ?? null;\r\n            onError = noMipmapOrOptions.onError ?? null;\r\n            buffer = noMipmapOrOptions.buffer ?? null;\r\n            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;\r\n            format = noMipmapOrOptions.format;\r\n            mimeType = noMipmapOrOptions.mimeType;\r\n            loaderOptions = noMipmapOrOptions.loaderOptions;\r\n            creationFlags = noMipmapOrOptions.creationFlags;\r\n            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;\r\n            internalTexture = noMipmapOrOptions.internalTexture ?? null;\r\n        } else {\r\n            noMipmap = !!noMipmapOrOptions;\r\n        }\r\n\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY === undefined ? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true) : invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        this._loaderOptions = loaderOptions;\r\n        this._creationFlags = creationFlags;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        const load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texture to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this.url) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = errorHandler;\r\n            return;\r\n        }\r\n\r\n        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                try {\r\n                    this._texture = engine.createTexture(\r\n                        this.url,\r\n                        noMipmap,\r\n                        this._invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        load,\r\n                        errorHandler,\r\n                        this._buffer,\r\n                        undefined,\r\n                        this._format,\r\n                        null,\r\n                        mimeType,\r\n                        loaderOptions,\r\n                        creationFlags,\r\n                        useSRGBBuffer\r\n                    );\r\n                } catch (e) {\r\n                    errorHandler(\"error loading\", e);\r\n                    throw e;\r\n                }\r\n                if (deleteBuffer) {\r\n                    this._buffer = null;\r\n                }\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = errorHandler;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                const loadObserver = this._texture.onLoadedObservable.add(load);\r\n                this._texture.onErrorObservable.add((e) => {\r\n                    errorHandler(e.message, e.exception);\r\n                    this._texture?.onLoadedObservable.remove(loadObserver);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     */\r\n    public updateURL(url: string, buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob> = null, onLoad?: () => void): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n\r\n        if (!this.name || StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @hidden\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene\r\n                .getEngine()\r\n                .createTexture(\r\n                    this.url,\r\n                    this._noMipmap,\r\n                    this._invertY,\r\n                    scene,\r\n                    this.samplingMode,\r\n                    this._delayedOnLoad,\r\n                    this._delayedOnError,\r\n                    this._buffer,\r\n                    null,\r\n                    this._format,\r\n                    null,\r\n                    this._mimeType,\r\n                    this._loaderOptions,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<Texture>): boolean {\r\n        return (\r\n            texture !== null &&\r\n            this.uOffset === texture.uOffset &&\r\n            this.vOffset === texture.vOffset &&\r\n            this.uScale === texture.uScale &&\r\n            this.vScale === texture.vScale &&\r\n            this.uAng === texture.uAng &&\r\n            this.vAng === texture.vAng &&\r\n            this.wAng === texture.wAng\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @param uBase\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform\r\n        ) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix!, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        } else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n            this._t1!.subtractInPlace(this._t0!);\r\n            this._t2!.subtractInPlace(this._t0!);\r\n\r\n            Matrix.FromValuesToRef(\r\n                this._t1!.x,\r\n                this._t1!.y,\r\n                this._t1!.z,\r\n                0.0,\r\n                this._t2!.x,\r\n                this._t2!.y,\r\n                this._t2!.z,\r\n                0.0,\r\n                this._t0!.x,\r\n                this._t0!.y,\r\n                this._t0!.z,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                this._cachedTextureMatrix\r\n            );\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\r\n        // will get different values (see MaterialHelper.PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.coordinatesMode === this._cachedCoordinatesMode\r\n        ) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedTextureMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        const flagMaterialsAsTextureDirty = this._cachedCoordinatesMode !== this.coordinatesMode;\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE: {\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                (<any>this._cachedTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            }\r\n            case Texture.PROJECTION_MODE: {\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n\r\n                const projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\r\n                break;\r\n            }\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        if (flagMaterialsAsTextureDirty) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\r\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.getActiveTextures().indexOf(this) !== -1;\r\n            });\r\n        }\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Texture {\r\n        const options: ITextureCreationOptions = {\r\n            noMipmap: this._noMipmap,\r\n            invertY: this._invertY,\r\n            samplingMode: this.samplingMode,\r\n            onLoad: undefined,\r\n            onError: undefined,\r\n            buffer: this._texture ? this._texture._buffer : undefined,\r\n            deleteBuffer: this._deleteBuffer,\r\n            format: this.textureFormat,\r\n            mimeType: this.mimeType,\r\n            loaderOptions: this._loaderOptions,\r\n            creationFlags: this._creationFlags,\r\n            useSRGBBuffer: this._useSRGBBuffer,\r\n        };\r\n\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const savedName = this.name;\r\n\r\n        if (!Texture.SerializeBuffers) {\r\n            if (StartsWith(this.name, \"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        if (StartsWith(this.name, \"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && StartsWith(this.url, \"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\r\n            } else if (Texture.ForceSerializeBuffers || (this.url && StartsWith(this.url, \"blob:\")) || this._forceSerialize) {\r\n                serializationObject.base64String =\r\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        serializationObject._creationFlags = this._creationFlags;\r\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            const parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            return null;\r\n        }\r\n\r\n        const onLoaded = () => {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                const sampling: number = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    const internalClass = GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let generateMipMaps: boolean = true;\r\n                if (parsedTexture.noMipmap) {\r\n                    generateMipMaps = false;\r\n                }\r\n                if (parsedTexture.mirrorPlane) {\r\n                    const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                    mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                    onLoaded();\r\n                    return mirrorTexture;\r\n                } else if (parsedTexture.isRenderTarget) {\r\n                    let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                    if (parsedTexture.isCube) {\r\n                        // Search for an existing reflection probe (which contains a cube render target texture)\r\n                        if (scene.reflectionProbes) {\r\n                            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                                const probe = scene.reflectionProbes[index];\r\n                                if (probe.name === parsedTexture.name) {\r\n                                    return probe.cubeTexture;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        renderTargetTexture = Texture._CreateRenderTargetTexture(\r\n                            parsedTexture.name,\r\n                            parsedTexture.renderTargetSize,\r\n                            scene,\r\n                            generateMipMaps,\r\n                            parsedTexture._creationFlags ?? 0\r\n                        );\r\n                        renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                    }\r\n                    onLoaded();\r\n                    return renderTargetTexture;\r\n                } else {\r\n                    let texture: Texture;\r\n\r\n                    if (parsedTexture.base64String) {\r\n                        texture = Texture.CreateFromBase64String(\r\n                            parsedTexture.base64String,\r\n                            parsedTexture.name,\r\n                            scene,\r\n                            !generateMipMaps,\r\n                            parsedTexture.invertY,\r\n                            parsedTexture.samplingMode,\r\n                            onLoaded,\r\n                            parsedTexture._creationFlags ?? 0,\r\n                            parsedTexture._useSRGBBuffer ?? false\r\n                        );\r\n                    } else {\r\n                        let url: string;\r\n                        if (parsedTexture.name && parsedTexture.name.indexOf(\"://\") > 0) {\r\n                            url = parsedTexture.name;\r\n                        } else {\r\n                            url = rootUrl + parsedTexture.name;\r\n                        }\r\n\r\n                        if (StartsWith(parsedTexture.url, \"data:\") || (Texture.UseSerializedUrlIfAny && parsedTexture.url)) {\r\n                            url = parsedTexture.url;\r\n                        }\r\n                        texture = new Texture(url, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded);\r\n                    }\r\n\r\n                    return texture;\r\n                }\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(\r\n        data: string,\r\n        name: string,\r\n        scene: Scene,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<() => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number\r\n    ): Texture {\r\n        return new Texture(\"data:\" + name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, undefined, undefined, creationFlags);\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(\r\n        name: string,\r\n        buffer: any,\r\n        scene: Scene,\r\n        deleteBuffer: boolean = false,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY: boolean = true,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number\r\n    ): Texture {\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, undefined, undefined, creationFlags);\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nRegisterClass(\"BABYLON.Texture\", Texture);\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n"]},"metadata":{},"sourceType":"module"}