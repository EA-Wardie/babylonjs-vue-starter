{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { __extends } from \"tslib\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Defines the root class used to create scene optimization to use with SceneOptimizer\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar SceneOptimization =\n/** @class */\nfunction () {\n  /**\n   * Creates the SceneOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   */\n  function SceneOptimization(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.priority = priority;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n\n\n  SceneOptimization.prototype.getDescription = function () {\n    return \"\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  SceneOptimization.prototype.apply = function (scene, optimizer) {\n    return true;\n  };\n\n  return SceneOptimization;\n}();\n\nexport { SceneOptimization };\n/**\n * Defines an optimization used to reduce the size of render target textures\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar TextureOptimization =\n/** @class */\nfunction (_super) {\n  __extends(TextureOptimization, _super);\n  /**\n   * Creates the TextureOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n\n\n  function TextureOptimization(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority,\n  /**\n   * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   */\n  maximumSize,\n  /**\n   * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumSize === void 0) {\n      maximumSize = 1024;\n    }\n\n    if (step === void 0) {\n      step = 0.5;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumSize = maximumSize;\n    _this.step = step;\n    return _this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n\n\n  TextureOptimization.prototype.getDescription = function () {\n    return \"Reducing render target texture size to \" + this.maximumSize;\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  TextureOptimization.prototype.apply = function (scene, optimizer) {\n    var allDone = true;\n\n    for (var index = 0; index < scene.textures.length; index++) {\n      var texture = scene.textures[index];\n\n      if (!texture.canRescale || texture.getContext) {\n        continue;\n      }\n\n      var currentSize = texture.getSize();\n      var maxDimension = Math.max(currentSize.width, currentSize.height);\n\n      if (maxDimension > this.maximumSize) {\n        texture.scale(this.step);\n        allDone = false;\n      }\n    }\n\n    return allDone;\n  };\n\n  return TextureOptimization;\n}(SceneOptimization);\n\nexport { TextureOptimization };\n/**\n * Defines an optimization used to increase or decrease the rendering resolution\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar HardwareScalingOptimization =\n/** @class */\nfunction (_super) {\n  __extends(HardwareScalingOptimization, _super);\n  /**\n   * Creates the HardwareScalingOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumScale defines the maximum scale to use (2 by default)\n   * @param step defines the step to use between two passes (0.5 by default)\n   */\n\n\n  function HardwareScalingOptimization(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority,\n  /**\n   * Defines the maximum scale to use (2 by default)\n   */\n  maximumScale,\n  /**\n   * Defines the step to use between two passes (0.5 by default)\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumScale === void 0) {\n      maximumScale = 2;\n    }\n\n    if (step === void 0) {\n      step = 0.25;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumScale = maximumScale;\n    _this.step = step;\n    _this._currentScale = -1;\n    _this._directionOffset = 1;\n    return _this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  HardwareScalingOptimization.prototype.getDescription = function () {\n    return \"Setting hardware scaling level to \" + this._currentScale;\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  HardwareScalingOptimization.prototype.apply = function (scene, optimizer) {\n    if (this._currentScale === -1) {\n      this._currentScale = scene.getEngine().getHardwareScalingLevel();\n\n      if (this._currentScale > this.maximumScale) {\n        this._directionOffset = -1;\n      }\n    }\n\n    this._currentScale += this._directionOffset * this.step;\n    scene.getEngine().setHardwareScalingLevel(this._currentScale);\n    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n  };\n\n  return HardwareScalingOptimization;\n}(SceneOptimization);\n\nexport { HardwareScalingOptimization };\n/**\n * Defines an optimization used to remove shadows\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar ShadowsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ShadowsOptimization, _super);\n\n  function ShadowsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  ShadowsOptimization.prototype.getDescription = function () {\n    return \"Turning shadows on/off\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  ShadowsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.shadowsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ShadowsOptimization;\n}(SceneOptimization);\n\nexport { ShadowsOptimization };\n/**\n * Defines an optimization used to turn post-processes off\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar PostProcessesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(PostProcessesOptimization, _super);\n\n  function PostProcessesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  PostProcessesOptimization.prototype.getDescription = function () {\n    return \"Turning post-processes on/off\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  PostProcessesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.postProcessesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return PostProcessesOptimization;\n}(SceneOptimization);\n\nexport { PostProcessesOptimization };\n/**\n * Defines an optimization used to turn lens flares off\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar LensFlaresOptimization =\n/** @class */\nfunction (_super) {\n  __extends(LensFlaresOptimization, _super);\n\n  function LensFlaresOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  LensFlaresOptimization.prototype.getDescription = function () {\n    return \"Turning lens flares on/off\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  LensFlaresOptimization.prototype.apply = function (scene, optimizer) {\n    scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return LensFlaresOptimization;\n}(SceneOptimization);\n\nexport { LensFlaresOptimization };\n/**\n * Defines an optimization based on user defined callback.\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar CustomOptimization =\n/** @class */\nfunction (_super) {\n  __extends(CustomOptimization, _super);\n\n  function CustomOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n\n\n  CustomOptimization.prototype.getDescription = function () {\n    if (this.onGetDescription) {\n      return this.onGetDescription();\n    }\n\n    return \"Running user defined callback\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  CustomOptimization.prototype.apply = function (scene, optimizer) {\n    if (this.onApply) {\n      return this.onApply(scene, optimizer);\n    }\n\n    return true;\n  };\n\n  return CustomOptimization;\n}(SceneOptimization);\n\nexport { CustomOptimization };\n/**\n * Defines an optimization used to turn particles off\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar ParticlesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ParticlesOptimization, _super);\n\n  function ParticlesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  ParticlesOptimization.prototype.getDescription = function () {\n    return \"Turning particles on/off\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  ParticlesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.particlesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ParticlesOptimization;\n}(SceneOptimization);\n\nexport { ParticlesOptimization };\n/**\n * Defines an optimization used to turn render targets off\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar RenderTargetsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(RenderTargetsOptimization, _super);\n\n  function RenderTargetsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n\n  RenderTargetsOptimization.prototype.getDescription = function () {\n    return \"Turning render targets off\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n\n\n  RenderTargetsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return RenderTargetsOptimization;\n}(SceneOptimization);\n\nexport { RenderTargetsOptimization };\n/**\n * Defines an optimization used to merge meshes with compatible materials\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar MergeMeshesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(MergeMeshesOptimization, _super);\n\n  function MergeMeshesOptimization() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._canBeMerged = function (abstractMesh) {\n      if (!(abstractMesh instanceof Mesh)) {\n        return false;\n      }\n\n      var mesh = abstractMesh;\n\n      if (mesh.isDisposed()) {\n        return false;\n      }\n\n      if (!mesh.isVisible || !mesh.isEnabled()) {\n        return false;\n      }\n\n      if (mesh.instances.length > 0) {\n        return false;\n      }\n\n      if (mesh.skeleton || mesh.hasLODLevels) {\n        return false;\n      }\n\n      return true;\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(MergeMeshesOptimization, \"UpdateSelectionTree\", {\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    get: function get() {\n      return MergeMeshesOptimization._UpdateSelectionTree;\n    },\n\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    set: function set(value) {\n      MergeMeshesOptimization._UpdateSelectionTree = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @return description string\n   */\n\n  MergeMeshesOptimization.prototype.getDescription = function () {\n    return \"Merging similar meshes together\";\n  };\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\n   * @returns true if everything that can be done was applied\n   */\n\n\n  MergeMeshesOptimization.prototype.apply = function (scene, optimizer, updateSelectionTree) {\n    var globalPool = scene.meshes.slice(0);\n    var globalLength = globalPool.length;\n\n    for (var index = 0; index < globalLength; index++) {\n      var currentPool = new Array();\n      var current = globalPool[index]; // Checks\n\n      if (!this._canBeMerged(current)) {\n        continue;\n      }\n\n      currentPool.push(current); // Find compatible meshes\n\n      for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {\n        var otherMesh = globalPool[subIndex];\n\n        if (!this._canBeMerged(otherMesh)) {\n          continue;\n        }\n\n        if (otherMesh.material !== current.material) {\n          continue;\n        }\n\n        if (otherMesh.checkCollisions !== current.checkCollisions) {\n          continue;\n        }\n\n        currentPool.push(otherMesh);\n        globalLength--;\n        globalPool.splice(subIndex, 1);\n        subIndex--;\n      }\n\n      if (currentPool.length < 2) {\n        continue;\n      } // Merge meshes\n\n\n      Mesh.MergeMeshes(currentPool, undefined, true);\n    } // Call the octree system optimization if it is defined.\n\n\n    var sceneAsAny = scene;\n\n    if (sceneAsAny.createOrUpdateSelectionOctree) {\n      if (updateSelectionTree != undefined) {\n        if (updateSelectionTree) {\n          sceneAsAny.createOrUpdateSelectionOctree();\n        }\n      } else if (MergeMeshesOptimization.UpdateSelectionTree) {\n        sceneAsAny.createOrUpdateSelectionOctree();\n      }\n    }\n\n    return true;\n  };\n\n  MergeMeshesOptimization._UpdateSelectionTree = false;\n  return MergeMeshesOptimization;\n}(SceneOptimization);\n\nexport { MergeMeshesOptimization };\n/**\n * Defines a list of options used by SceneOptimizer\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar SceneOptimizerOptions =\n/** @class */\nfunction () {\n  /**\n   * Creates a new list of options used by SceneOptimizer\n   * @param targetFrameRate defines the target frame rate to reach (60 by default)\n   * @param trackerDuration defines the interval between two checks (2000ms by default)\n   */\n  function SceneOptimizerOptions(\n  /**\n   * Defines the target frame rate to reach (60 by default)\n   */\n  targetFrameRate,\n  /**\n   * Defines the interval between two checks (2000ms by default)\n   */\n  trackerDuration) {\n    if (targetFrameRate === void 0) {\n      targetFrameRate = 60;\n    }\n\n    if (trackerDuration === void 0) {\n      trackerDuration = 2000;\n    }\n\n    this.targetFrameRate = targetFrameRate;\n    this.trackerDuration = trackerDuration;\n    /**\n     * Gets the list of optimizations to apply\n     */\n\n    this.optimizations = new Array();\n  }\n  /**\n   * Add a new optimization\n   * @param optimization defines the SceneOptimization to add to the list of active optimizations\n   * @returns the current SceneOptimizerOptions\n   */\n\n\n  SceneOptimizerOptions.prototype.addOptimization = function (optimization) {\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\n   * Add a new custom optimization\n   * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\n   * @param onGetDescription defines the callback called to get the description attached with the optimization.\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @returns the current SceneOptimizerOptions\n   */\n\n\n  SceneOptimizerOptions.prototype.addCustomOptimization = function (onApply, onGetDescription, priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    var optimization = new CustomOptimization(priority);\n    optimization.onApply = onApply;\n    optimization.onGetDescription = onGetDescription;\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\n   * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n\n\n  SceneOptimizerOptions.LowDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 1024));\n    return result;\n  };\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n\n\n  SceneOptimizerOptions.ModerateDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 512)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 2));\n    return result;\n  };\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n\n\n  SceneOptimizerOptions.HighDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 256)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 4));\n    return result;\n  };\n\n  return SceneOptimizerOptions;\n}();\n\nexport { SceneOptimizerOptions };\n/**\n * Class used to run optimizations in order to reach a target frame rate\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\n */\n\nvar SceneOptimizer =\n/** @class */\nfunction () {\n  /**\n   * Creates a new SceneOptimizer\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\n   * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\n   */\n  function SceneOptimizer(scene, options, autoGeneratePriorities, improvementMode) {\n    if (autoGeneratePriorities === void 0) {\n      autoGeneratePriorities = true;\n    }\n\n    if (improvementMode === void 0) {\n      improvementMode = false;\n    }\n\n    var _this = this;\n\n    this._isRunning = false;\n    this._currentPriorityLevel = 0;\n    this._targetFrameRate = 60;\n    this._trackerDuration = 2000;\n    this._currentFrameRate = 0;\n    this._improvementMode = false;\n    /**\n     * Defines an observable called when the optimizer reaches the target frame rate\n     */\n\n    this.onSuccessObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer enables an optimization\n     */\n\n    this.onNewOptimizationAppliedObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\n     */\n\n    this.onFailureObservable = new Observable();\n\n    if (!options) {\n      this._options = new SceneOptimizerOptions();\n    } else {\n      this._options = options;\n    }\n\n    if (this._options.targetFrameRate) {\n      this._targetFrameRate = this._options.targetFrameRate;\n    }\n\n    if (this._options.trackerDuration) {\n      this._trackerDuration = this._options.trackerDuration;\n    }\n\n    if (autoGeneratePriorities) {\n      var priority = 0;\n\n      for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {\n        var optim = _a[_i];\n        optim.priority = priority++;\n      }\n    }\n\n    this._improvementMode = improvementMode;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function () {\n      _this._sceneDisposeObserver = null;\n\n      _this.dispose();\n    });\n  }\n\n  Object.defineProperty(SceneOptimizer.prototype, \"isInImprovementMode\", {\n    /**\n     * Gets a boolean indicating if the optimizer is in improvement mode\n     */\n    get: function get() {\n      return this._improvementMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentPriorityLevel\", {\n    /**\n     * Gets the current priority level (0 at start)\n     */\n    get: function get() {\n      return this._currentPriorityLevel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentFrameRate\", {\n    /**\n     * Gets the current frame rate checked by the SceneOptimizer\n     */\n    get: function get() {\n      return this._currentFrameRate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"targetFrameRate\", {\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    get: function get() {\n      return this._targetFrameRate;\n    },\n\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    set: function set(value) {\n      this._targetFrameRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"trackerDuration\", {\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    get: function get() {\n      return this._trackerDuration;\n    },\n\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    set: function set(value) {\n      this._trackerDuration = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"optimizations\", {\n    /**\n     * Gets the list of active optimizations\n     */\n    get: function get() {\n      return this._options.optimizations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Stops the current optimizer\n   */\n\n  SceneOptimizer.prototype.stop = function () {\n    this._isRunning = false;\n  };\n  /**\n   * Reset the optimizer to initial step (current priority level = 0)\n   */\n\n\n  SceneOptimizer.prototype.reset = function () {\n    this._currentPriorityLevel = 0;\n  };\n  /**\n   * Start the optimizer. By default it will try to reach a specific framerate\n   * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\n   */\n\n\n  SceneOptimizer.prototype.start = function () {\n    var _this = this;\n\n    if (this._isRunning) {\n      return;\n    }\n\n    this._isRunning = true; // Let's wait for the scene to be ready before running our check\n\n    this._scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n\n  SceneOptimizer.prototype._checkCurrentState = function () {\n    var _this = this;\n\n    if (!this._isRunning) {\n      return;\n    }\n\n    var scene = this._scene;\n    var options = this._options;\n    this._currentFrameRate = Math.round(scene.getEngine().getFps());\n\n    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\n      this._isRunning = false;\n      this.onSuccessObservable.notifyObservers(this);\n      return;\n    } // Apply current level of optimizations\n\n\n    var allDone = true;\n    var noOptimizationApplied = true;\n\n    for (var index = 0; index < options.optimizations.length; index++) {\n      var optimization = options.optimizations[index];\n\n      if (optimization.priority === this._currentPriorityLevel) {\n        noOptimizationApplied = false;\n        allDone = allDone && optimization.apply(scene, this);\n        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n      }\n    } // If no optimization was applied, this is a failure :(\n\n\n    if (noOptimizationApplied) {\n      this._isRunning = false;\n      this.onFailureObservable.notifyObservers(this);\n      return;\n    } // If all optimizations were done, move to next level\n\n\n    if (allDone) {\n      this._currentPriorityLevel++;\n    } // Let's the system running for a specific amount of time before checking FPS\n\n\n    scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n  /**\n   * Release all resources\n   */\n\n\n  SceneOptimizer.prototype.dispose = function () {\n    this.stop();\n    this.onSuccessObservable.clear();\n    this.onFailureObservable.clear();\n    this.onNewOptimizationAppliedObservable.clear();\n\n    if (this._sceneDisposeObserver) {\n      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n  };\n  /**\n   * Helper function to create a SceneOptimizer with one single line of code\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param onSuccess defines a callback to call on success\n   * @param onFailure defines a callback to call on failure\n   * @returns the new SceneOptimizer object\n   */\n\n\n  SceneOptimizer.OptimizeAsync = function (scene, options, onSuccess, onFailure) {\n    var optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n\n    if (onSuccess) {\n      optimizer.onSuccessObservable.add(function () {\n        onSuccess();\n      });\n    }\n\n    if (onFailure) {\n      optimizer.onFailureObservable.add(function () {\n        onFailure();\n      });\n    }\n\n    optimizer.start();\n    return optimizer;\n  };\n\n  return SceneOptimizer;\n}();\n\nexport { SceneOptimizer };","map":{"version":3,"mappings":"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","names":["EngineStore","Mesh","Observable","priority","SceneOptimization","scene","optimizer","__extends","maximumSize","step","_super","_this","TextureOptimization","allDone","index","textures","length","texture","canRescale","getContext","currentSize","getSize","maxDimension","Math","max","width","height","scale","maximumScale","HardwareScalingOptimization","_currentScale","getEngine","getHardwareScalingLevel","_directionOffset","setHardwareScalingLevel","ShadowsOptimization","shadowsEnabled","isInImprovementMode","PostProcessesOptimization","postProcessesEnabled","LensFlaresOptimization","lensFlaresEnabled","CustomOptimization","onGetDescription","onApply","ParticlesOptimization","particlesEnabled","RenderTargetsOptimization","renderTargetsEnabled","abstractMesh","mesh","isDisposed","isVisible","isEnabled","instances","skeleton","hasLODLevels","Object","MergeMeshesOptimization","_UpdateSelectionTree","value","updateSelectionTree","globalPool","meshes","slice","globalLength","currentPool","Array","current","_canBeMerged","push","subIndex","otherMesh","material","checkCollisions","splice","MergeMeshes","undefined","sceneAsAny","createOrUpdateSelectionOctree","UpdateSelectionTree","targetFrameRate","trackerDuration","SceneOptimizerOptions","optimization","optimizations","result","addOptimization","options","autoGeneratePriorities","improvementMode","_options","_targetFrameRate","_trackerDuration","_i","optim","_improvementMode","_scene","LastCreatedScene","_sceneDisposeObserver","onDisposeObservable","add","dispose","SceneOptimizer","_currentPriorityLevel","_currentFrameRate","_isRunning","executeWhenReady","setTimeout","_checkCurrentState","round","getFps","onSuccessObservable","notifyObservers","noOptimizationApplied","apply","onNewOptimizationAppliedObservable","onFailureObservable","stop","clear","remove","onSuccess","onFailure","ModerateDegradationAllowed","start"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/sceneOptimizer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"./observable\";\r\nimport { Observable } from \"./observable\";\r\n\r\n/**\r\n * Defines the root class used to create scene optimization to use with SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates the SceneOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0\r\n    ) {}\r\n}\r\n\r\n/**\r\n * Defines an optimization used to reduce the size of render target textures\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class TextureOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Reducing render target texture size to \" + this.maximumSize;\r\n    }\r\n\r\n    /**\r\n     * Creates the TextureOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n         */\r\n        public maximumSize: number = 1024,\r\n        /**\r\n         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n         */\r\n        public step = 0.5\r\n    ) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        let allDone = true;\r\n        for (let index = 0; index < scene.textures.length; index++) {\r\n            const texture = scene.textures[index];\r\n\r\n            if (!texture.canRescale || (<any>texture).getContext) {\r\n                continue;\r\n            }\r\n\r\n            const currentSize = texture.getSize();\r\n            const maxDimension = Math.max(currentSize.width, currentSize.height);\r\n\r\n            if (maxDimension > this.maximumSize) {\r\n                texture.scale(this.step);\r\n                allDone = false;\r\n            }\r\n        }\r\n\r\n        return allDone;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to increase or decrease the rendering resolution\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class HardwareScalingOptimization extends SceneOptimization {\r\n    private _currentScale = -1;\r\n    private _directionOffset = 1;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Setting hardware scaling level to \" + this._currentScale;\r\n    }\r\n\r\n    /**\r\n     * Creates the HardwareScalingOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumScale defines the maximum scale to use (2 by default)\r\n     * @param step defines the step to use between two passes (0.5 by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum scale to use (2 by default)\r\n         */\r\n        public maximumScale: number = 2,\r\n        /**\r\n         * Defines the step to use between two passes (0.5 by default)\r\n         */\r\n        public step: number = 0.25\r\n    ) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this._currentScale === -1) {\r\n            this._currentScale = scene.getEngine().getHardwareScalingLevel();\r\n            if (this._currentScale > this.maximumScale) {\r\n                this._directionOffset = -1;\r\n            }\r\n        }\r\n\r\n        this._currentScale += this._directionOffset * this.step;\r\n\r\n        scene.getEngine().setHardwareScalingLevel(this._currentScale);\r\n\r\n        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to remove shadows\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class ShadowsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning shadows on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.shadowsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn post-processes off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class PostProcessesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning post-processes on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.postProcessesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn lens flares off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class LensFlaresOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning lens flares on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.lensFlaresEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization based on user defined callback.\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class CustomOptimization extends SceneOptimization {\r\n    /**\r\n     * Callback called to apply the custom optimization.\r\n     */\r\n    public onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean;\r\n\r\n    /**\r\n     * Callback called to get custom description\r\n     */\r\n    public onGetDescription: () => string;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        if (this.onGetDescription) {\r\n            return this.onGetDescription();\r\n        }\r\n\r\n        return \"Running user defined callback\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this.onApply) {\r\n            return this.onApply(scene, optimizer);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn particles off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class ParticlesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning particles on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.particlesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn render targets off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class RenderTargetsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning render targets off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.renderTargetsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to merge meshes with compatible materials\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class MergeMeshesOptimization extends SceneOptimization {\r\n    private static _UpdateSelectionTree = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static get UpdateSelectionTree(): boolean {\r\n        return MergeMeshesOptimization._UpdateSelectionTree;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static set UpdateSelectionTree(value: boolean) {\r\n        MergeMeshesOptimization._UpdateSelectionTree = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Merging similar meshes together\";\r\n    }\r\n\r\n    private _canBeMerged = (abstractMesh: AbstractMesh): boolean => {\r\n        if (!(abstractMesh instanceof Mesh)) {\r\n            return false;\r\n        }\r\n\r\n        const mesh = <Mesh>abstractMesh;\r\n\r\n        if (mesh.isDisposed()) {\r\n            return false;\r\n        }\r\n\r\n        if (!mesh.isVisible || !mesh.isEnabled()) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.instances.length > 0) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.skeleton || mesh.hasLODLevels) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer, updateSelectionTree?: boolean): boolean {\r\n        const globalPool = scene.meshes.slice(0);\r\n        let globalLength = globalPool.length;\r\n\r\n        for (let index = 0; index < globalLength; index++) {\r\n            const currentPool = new Array<Mesh>();\r\n            const current = globalPool[index];\r\n\r\n            // Checks\r\n            if (!this._canBeMerged(current)) {\r\n                continue;\r\n            }\r\n\r\n            currentPool.push(<Mesh>current);\r\n\r\n            // Find compatible meshes\r\n            for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\r\n                const otherMesh = globalPool[subIndex];\r\n\r\n                if (!this._canBeMerged(otherMesh)) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material !== current.material) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.checkCollisions !== current.checkCollisions) {\r\n                    continue;\r\n                }\r\n\r\n                currentPool.push(<Mesh>otherMesh);\r\n                globalLength--;\r\n\r\n                globalPool.splice(subIndex, 1);\r\n\r\n                subIndex--;\r\n            }\r\n\r\n            if (currentPool.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            // Merge meshes\r\n            Mesh.MergeMeshes(currentPool, undefined, true);\r\n        }\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const sceneAsAny = scene as any;\r\n        if (sceneAsAny.createOrUpdateSelectionOctree) {\r\n            if (updateSelectionTree != undefined) {\r\n                if (updateSelectionTree) {\r\n                    sceneAsAny.createOrUpdateSelectionOctree();\r\n                }\r\n            } else if (MergeMeshesOptimization.UpdateSelectionTree) {\r\n                sceneAsAny.createOrUpdateSelectionOctree();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines a list of options used by SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimizerOptions {\r\n    /**\r\n     * Gets the list of optimizations to apply\r\n     */\r\n    public optimizations = new Array<SceneOptimization>();\r\n\r\n    /**\r\n     * Creates a new list of options used by SceneOptimizer\r\n     * @param targetFrameRate defines the target frame rate to reach (60 by default)\r\n     * @param trackerDuration defines the interval between two checks (2000ms by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the target frame rate to reach (60 by default)\r\n         */\r\n        public targetFrameRate: number = 60,\r\n        /**\r\n         * Defines the interval between two checks (2000ms by default)\r\n         */\r\n        public trackerDuration: number = 2000\r\n    ) {}\r\n\r\n    /**\r\n     * Add a new optimization\r\n     * @param optimization defines the SceneOptimization to add to the list of active optimizations\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addOptimization(optimization: SceneOptimization): SceneOptimizerOptions {\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new custom optimization\r\n     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\r\n     * @param onGetDescription defines the callback called to get the description attached with the optimization.\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addCustomOptimization(onApply: (scene: Scene) => boolean, onGetDescription: () => string, priority: number = 0): SceneOptimizerOptions {\r\n        const optimization = new CustomOptimization(priority);\r\n        optimization.onApply = onApply;\r\n        optimization.onGetDescription = onGetDescription;\r\n\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static LowDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 1024));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static ModerateDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 512));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 2));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static HighDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 256));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 4));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to run optimizations in order to reach a target frame rate\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimizer implements IDisposable {\r\n    private _isRunning = false;\r\n    private _options: SceneOptimizerOptions;\r\n    private _scene: Scene;\r\n    private _currentPriorityLevel = 0;\r\n    private _targetFrameRate = 60;\r\n    private _trackerDuration = 2000;\r\n    private _currentFrameRate = 0;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _improvementMode = false;\r\n\r\n    /**\r\n     * Defines an observable called when the optimizer reaches the target frame rate\r\n     */\r\n    public onSuccessObservable = new Observable<SceneOptimizer>();\r\n    /**\r\n     * Defines an observable called when the optimizer enables an optimization\r\n     */\r\n    public onNewOptimizationAppliedObservable = new Observable<SceneOptimization>();\r\n    /**\r\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\r\n     */\r\n    public onFailureObservable = new Observable<SceneOptimizer>();\r\n\r\n    /**\r\n     * Gets a boolean indicating if the optimizer is in improvement mode\r\n     */\r\n    public get isInImprovementMode(): boolean {\r\n        return this._improvementMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the current priority level (0 at start)\r\n     */\r\n    public get currentPriorityLevel(): number {\r\n        return this._currentPriorityLevel;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame rate checked by the SceneOptimizer\r\n     */\r\n    public get currentFrameRate(): number {\r\n        return this._currentFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public get targetFrameRate(): number {\r\n        return this._targetFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public set targetFrameRate(value: number) {\r\n        this._targetFrameRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public get trackerDuration(): number {\r\n        return this._trackerDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public set trackerDuration(value: number) {\r\n        this._trackerDuration = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active optimizations\r\n     */\r\n    public get optimizations(): SceneOptimization[] {\r\n        return this._options.optimizations;\r\n    }\r\n\r\n    /**\r\n     * Creates a new SceneOptimizer\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\r\n     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\r\n     */\r\n    public constructor(scene: Scene, options?: SceneOptimizerOptions, autoGeneratePriorities = true, improvementMode = false) {\r\n        if (!options) {\r\n            this._options = new SceneOptimizerOptions();\r\n        } else {\r\n            this._options = options;\r\n        }\r\n\r\n        if (this._options.targetFrameRate) {\r\n            this._targetFrameRate = this._options.targetFrameRate;\r\n        }\r\n\r\n        if (this._options.trackerDuration) {\r\n            this._trackerDuration = this._options.trackerDuration;\r\n        }\r\n\r\n        if (autoGeneratePriorities) {\r\n            let priority = 0;\r\n            for (const optim of this._options.optimizations) {\r\n                optim.priority = priority++;\r\n            }\r\n        }\r\n\r\n        this._improvementMode = improvementMode;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\r\n            this._sceneDisposeObserver = null;\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops the current optimizer\r\n     */\r\n    public stop() {\r\n        this._isRunning = false;\r\n    }\r\n\r\n    /**\r\n     * Reset the optimizer to initial step (current priority level = 0)\r\n     */\r\n    public reset() {\r\n        this._currentPriorityLevel = 0;\r\n    }\r\n\r\n    /**\r\n     * Start the optimizer. By default it will try to reach a specific framerate\r\n     * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\r\n     */\r\n    public start() {\r\n        if (this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        this._isRunning = true;\r\n\r\n        // Let's wait for the scene to be ready before running our check\r\n        this._scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    private _checkCurrentState() {\r\n        if (!this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._scene;\r\n        const options = this._options;\r\n\r\n        this._currentFrameRate = Math.round(scene.getEngine().getFps());\r\n\r\n        if ((this._improvementMode && this._currentFrameRate <= this._targetFrameRate) || (!this._improvementMode && this._currentFrameRate >= this._targetFrameRate)) {\r\n            this._isRunning = false;\r\n            this.onSuccessObservable.notifyObservers(this);\r\n            return;\r\n        }\r\n\r\n        // Apply current level of optimizations\r\n        let allDone = true;\r\n        let noOptimizationApplied = true;\r\n        for (let index = 0; index < options.optimizations.length; index++) {\r\n            const optimization = options.optimizations[index];\r\n\r\n            if (optimization.priority === this._currentPriorityLevel) {\r\n                noOptimizationApplied = false;\r\n                allDone = allDone && optimization.apply(scene, this);\r\n                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\r\n            }\r\n        }\r\n\r\n        // If no optimization was applied, this is a failure :(\r\n        if (noOptimizationApplied) {\r\n            this._isRunning = false;\r\n            this.onFailureObservable.notifyObservers(this);\r\n\r\n            return;\r\n        }\r\n\r\n        // If all optimizations were done, move to next level\r\n        if (allDone) {\r\n            this._currentPriorityLevel++;\r\n        }\r\n\r\n        // Let's the system running for a specific amount of time before checking FPS\r\n        scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this.stop();\r\n        this.onSuccessObservable.clear();\r\n        this.onFailureObservable.clear();\r\n        this.onNewOptimizationAppliedObservable.clear();\r\n        if (this._sceneDisposeObserver) {\r\n            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to create a SceneOptimizer with one single line of code\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param onSuccess defines a callback to call on success\r\n     * @param onFailure defines a callback to call on failure\r\n     * @returns the new SceneOptimizer object\r\n     */\r\n    public static OptimizeAsync(scene: Scene, options?: SceneOptimizerOptions, onSuccess?: () => void, onFailure?: () => void): SceneOptimizer {\r\n        const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\r\n\r\n        if (onSuccess) {\r\n            optimizer.onSuccessObservable.add(() => {\r\n                onSuccess();\r\n            });\r\n        }\r\n\r\n        if (onFailure) {\r\n            optimizer.onFailureObservable.add(() => {\r\n                onFailure();\r\n            });\r\n        }\r\n\r\n        optimizer.start();\r\n\r\n        return optimizer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}