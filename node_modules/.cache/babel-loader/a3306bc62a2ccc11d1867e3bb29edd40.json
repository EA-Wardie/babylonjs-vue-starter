{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nimport { Effect } from \"../../../Materials/effect.js\";\n\nEffect.prototype.setStorageBuffer = function (name, buffer) {\n  this._engine.setStorageBuffer(name, buffer);\n};\n\nWebGPUEngine.prototype.createStorageBuffer = function (data, creationFlags) {\n  return this._createBuffer(data, creationFlags | 32);\n};\n\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer, data, byteOffset, byteLength) {\n  var dataBuffer = buffer;\n\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n\n  var view;\n\n  if (byteLength === undefined) {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n\n    byteLength = view.byteLength;\n  } else {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n  }\n\n  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n};\n\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer, offset, size, buffer) {\n  var _this = this;\n\n  size = size || storageBuffer.capacity;\n\n  var gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\n\n  this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset !== null && offset !== void 0 ? offset : 0, gpuBuffer, 0, size);\n\n  return new Promise(function (resolve, reject) {\n    // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\n    // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\n    _this.onEndFrameObservable.addOnce(function () {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(function () {\n        var copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\n        var data = buffer;\n\n        if (data === undefined) {\n          data = new Uint8Array(size);\n          data.set(new Uint8Array(copyArrayBuffer));\n        } else {\n          var ctor = data.constructor; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\n\n          data = new ctor(data.buffer);\n          data.set(new ctor(copyArrayBuffer));\n        }\n\n        gpuBuffer.unmap();\n\n        _this._bufferManager.releaseBuffer(gpuBuffer);\n\n        resolve(data);\n      }, function (reason) {\n        return reject(reason);\n      });\n    });\n  });\n};\n\nWebGPUEngine.prototype.setStorageBuffer = function (name, buffer) {\n  var _a, _b;\n\n  (_a = this._currentDrawContext) === null || _a === void 0 ? void 0 : _a.setBuffer(name, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.getBuffer()) !== null && _b !== void 0 ? _b : null);\n};","map":{"version":3,"mappings":"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","names":["WebGPUEngine","WebGPUConstants","Effect","prototype","setStorageBuffer","name","buffer","_engine","createStorageBuffer","data","creationFlags","_createBuffer","updateStorageBuffer","byteOffset","byteLength","dataBuffer","undefined","view","Array","Float32Array","ArrayBuffer","Uint8Array","_bufferManager","setSubData","readFromStorageBuffer","storageBuffer","offset","size","capacity","gpuBuffer","createRawBuffer","BufferUsage","MapRead","CopyDst","_renderTargetEncoder","copyBufferToBuffer","underlyingResource","Promise","resolve","reject","_this","onEndFrameObservable","addOnce","mapAsync","MapMode","Read","then","copyArrayBuffer","getMappedRange","set","ctor","constructor","unmap","releaseBuffer","reason","_currentDrawContext","_a","setBuffer","getBuffer","_b"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.storageBuffer.ts"],"sourcesContent":["import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\ndeclare type StorageBuffer = import(\"../../../Buffers/storageBuffer\").StorageBuffer;\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a storage buffer on the engine to be used in the shader.\r\n         * @param name Name of the storage buffer variable.\r\n         * @param buffer Storage buffer to set.\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._engine.setStorageBuffer(name, buffer);\r\n};\r\n\r\nWebGPUEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number): DataBuffer {\r\n    return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE);\r\n};\r\n\r\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = buffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n\r\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    size = size || storageBuffer.capacity;\r\n\r\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n    this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n        // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n        this.onEndFrameObservable.addOnce(() => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                    let data: ArrayBufferView | undefined = buffer;\r\n                    if (data === undefined) {\r\n                        data = new Uint8Array(size!);\r\n                        (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                    } else {\r\n                        const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                        data = new ctor(data.buffer);\r\n                        (data as any).set(new ctor(copyArrayBuffer));\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    this._bufferManager.releaseBuffer(gpuBuffer);\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}