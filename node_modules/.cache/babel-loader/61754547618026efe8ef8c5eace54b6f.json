{"ast":null,"code":"import \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { __assign } from \"tslib\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\n/**\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\n */\n\nvar TransmissionHelper =\n/** @class */\nfunction () {\n  /**\n   * constructor\n   * @param options Defines the options we want to customize the helper\n   * @param scene The scene to add the material to\n   */\n  function TransmissionHelper(options, scene) {\n    var _this = this;\n\n    this._opaqueRenderTarget = null;\n    this._opaqueMeshesCache = [];\n    this._transparentMeshesCache = [];\n    this._materialObservers = {};\n    this._options = __assign(__assign({}, TransmissionHelper._GetDefaultOptions()), options);\n    this._scene = scene;\n    this._scene._transmissionHelper = this;\n    this.onErrorObservable = new Observable();\n\n    this._scene.onDisposeObservable.addOnce(function () {\n      _this.dispose();\n    });\n\n    this._parseScene();\n\n    this._setupRenderTargets();\n  }\n  /**\n   * Creates the default options for the helper.\n   */\n\n\n  TransmissionHelper._GetDefaultOptions = function () {\n    return {\n      renderSize: 1024,\n      samples: 4,\n      lodGenerationScale: 1,\n      lodGenerationOffset: -4,\n      renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\n      generateMipmaps: true\n    };\n  };\n  /**\n   * Updates the background according to the new options\n   * @param options\n   */\n\n\n  TransmissionHelper.prototype.updateOptions = function (options) {\n    var _this = this; // First check if any options are actually being changed. If not, exit.\n\n\n    var newValues = Object.keys(options).filter(function (key) {\n      return _this._options[key] !== options[key];\n    });\n\n    if (!newValues.length) {\n      return;\n    }\n\n    var newOptions = __assign(__assign({}, this._options), options);\n\n    var oldOptions = this._options;\n    this._options = newOptions; // If size changes, recreate everything\n\n    if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {\n      this._setupRenderTargets();\n    } else {\n      this._opaqueRenderTarget.samples = newOptions.samples;\n      this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\n      this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\n    }\n  };\n\n  TransmissionHelper.prototype.getOpaqueTarget = function () {\n    return this._opaqueRenderTarget;\n  };\n\n  TransmissionHelper.prototype._shouldRenderAsTransmission = function (material) {\n    if (!material) {\n      return false;\n    }\n\n    if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\n      return true;\n    }\n\n    return false;\n  };\n\n  TransmissionHelper.prototype._addMesh = function (mesh) {\n    var _this = this;\n\n    this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this)); // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\n    // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\n\n    Tools.SetImmediate(function () {\n      if (_this._shouldRenderAsTransmission(mesh.material)) {\n        mesh.material.refractionTexture = _this._opaqueRenderTarget;\n\n        _this._transparentMeshesCache.push(mesh);\n      } else {\n        _this._opaqueMeshesCache.push(mesh);\n      }\n    });\n  };\n\n  TransmissionHelper.prototype._removeMesh = function (mesh) {\n    mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\n    delete this._materialObservers[mesh.uniqueId];\n\n    var idx = this._transparentMeshesCache.indexOf(mesh);\n\n    if (idx !== -1) {\n      this._transparentMeshesCache.splice(idx, 1);\n    }\n\n    idx = this._opaqueMeshesCache.indexOf(mesh);\n\n    if (idx !== -1) {\n      this._opaqueMeshesCache.splice(idx, 1);\n    }\n  };\n\n  TransmissionHelper.prototype._parseScene = function () {\n    this._scene.meshes.forEach(this._addMesh.bind(this)); // Listen for when a mesh is added to the scene and add it to our cache lists.\n\n\n    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)); // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n\n\n    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n  }; // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n\n\n  TransmissionHelper.prototype._onMeshMaterialChanged = function (mesh) {\n    var transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n\n    var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh); // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n\n\n    var useTransmission = this._shouldRenderAsTransmission(mesh.material);\n\n    if (useTransmission) {\n      if (mesh.material instanceof PBRMaterial) {\n        mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n      }\n\n      if (opaqueIdx !== -1) {\n        this._opaqueMeshesCache.splice(opaqueIdx, 1);\n\n        this._transparentMeshesCache.push(mesh);\n      } else if (transparentIdx === -1) {\n        this._transparentMeshesCache.push(mesh);\n      } // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n\n    } else {\n      if (transparentIdx !== -1) {\n        this._transparentMeshesCache.splice(transparentIdx, 1);\n\n        this._opaqueMeshesCache.push(mesh);\n      } else if (opaqueIdx === -1) {\n        this._opaqueMeshesCache.push(mesh);\n      }\n    }\n  };\n  /**\n   * Setup the render targets according to the specified options.\n   */\n\n\n  TransmissionHelper.prototype._setupRenderTargets = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    if (this._opaqueRenderTarget) {\n      this._opaqueRenderTarget.dispose();\n    }\n\n    this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);\n    this._opaqueRenderTarget.ignoreCameraViewport = true;\n    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\n    this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();\n    this._opaqueRenderTarget.gammaSpace = false;\n    this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\n    this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\n    this._opaqueRenderTarget.samples = this._options.samples;\n    var sceneImageProcessingapplyByPostProcess;\n    var saveSceneEnvIntensity;\n\n    this._opaqueRenderTarget.onBeforeBindObservable.add(function (opaqueRenderTarget) {\n      saveSceneEnvIntensity = _this._scene.environmentIntensity;\n      _this._scene.environmentIntensity = 1.0;\n      sceneImageProcessingapplyByPostProcess = _this._scene.imageProcessingConfiguration.applyByPostProcess;\n\n      if (!_this._options.clearColor) {\n        _this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\n      } else {\n        opaqueRenderTarget.clearColor.copyFrom(_this._options.clearColor);\n      } // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\n\n\n      _this._scene.imageProcessingConfiguration._applyByPostProcess = true;\n    });\n\n    this._opaqueRenderTarget.onAfterUnbindObservable.add(function () {\n      _this._scene.environmentIntensity = saveSceneEnvIntensity;\n      _this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\n    });\n\n    this._transparentMeshesCache.forEach(function (mesh) {\n      if (_this._shouldRenderAsTransmission(mesh.material)) {\n        mesh.material.refractionTexture = _this._opaqueRenderTarget;\n      }\n    });\n  };\n  /**\n   * Dispose all the elements created by the Helper.\n   */\n\n\n  TransmissionHelper.prototype.dispose = function () {\n    this._scene._transmissionHelper = undefined;\n\n    if (this._opaqueRenderTarget) {\n      this._opaqueRenderTarget.dispose();\n\n      this._opaqueRenderTarget = null;\n    }\n\n    this._transparentMeshesCache = [];\n    this._opaqueMeshesCache = [];\n  };\n\n  return TransmissionHelper;\n}();\n\nvar NAME = \"KHR_materials_transmission\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar KHR_materials_transmission =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_materials_transmission(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n\n    this.order = 175;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n\n    if (this.enabled) {\n      loader.parent.transparencyAsCoverage = true;\n    }\n  }\n  /** @hidden */\n\n\n  KHR_materials_transmission.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMaterial\n   * @hidden\n   */\n\n\n  KHR_materials_transmission.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n      return Promise.all(promises).then(function () {});\n    });\n  };\n\n  KHR_materials_transmission.prototype._loadTransparentPropertiesAsync = function (context, material, babylonMaterial, extension) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var pbrMaterial = babylonMaterial; // Enables \"refraction\" texture which represents transmitted light.\n\n    pbrMaterial.subSurface.isRefractionEnabled = true; // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n\n    pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0; // Albedo colour will tint transmission.\n\n    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n\n    if (extension.transmissionFactor !== undefined) {\n      pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n      var scene = pbrMaterial.getScene();\n\n      if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n        new TransmissionHelper({}, pbrMaterial.getScene());\n      }\n    } else {\n      pbrMaterial.subSurface.refractionIntensity = 0.0;\n      pbrMaterial.subSurface.isRefractionEnabled = false;\n      return Promise.resolve();\n    }\n\n    pbrMaterial.subSurface.minimumThickness = 0.0;\n    pbrMaterial.subSurface.maximumThickness = 0.0;\n\n    if (extension.transmissionTexture) {\n      extension.transmissionTexture.nonColorData = true;\n      return this._loader.loadTextureInfoAsync(\"\".concat(context, \"/transmissionTexture\"), extension.transmissionTexture, undefined).then(function (texture) {\n        pbrMaterial.subSurface.refractionIntensityTexture = texture;\n        pbrMaterial.subSurface.useGltfStyleTextures = true;\n      });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  return KHR_materials_transmission;\n}();\n\nexport { KHR_materials_transmission };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_transmission(loader);\n});","map":{"version":3,"mappings":"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","names":["PBRMaterial","GLTFLoader","RenderTargetTexture","Observable","Constants","Tools","options","scene","_options","__assign","TransmissionHelper","_GetDefaultOptions","_scene","_transmissionHelper","onErrorObservable","onDisposeObservable","addOnce","_this","dispose","_parseScene","_setupRenderTargets","renderSize","samples","lodGenerationScale","lodGenerationOffset","renderTargetTextureType","TEXTURETYPE_HALF_FLOAT","generateMipmaps","newValues","Object","keys","filter","key","length","newOptions","oldOptions","_opaqueRenderTarget","material","subSurface","isRefractionEnabled","mesh","_materialObservers","uniqueId","onMaterialChangedObservable","add","_onMeshMaterialChanged","bind","SetImmediate","_shouldRenderAsTransmission","refractionTexture","_transparentMeshesCache","push","_opaqueMeshesCache","remove","idx","indexOf","splice","meshes","forEach","_addMesh","onNewMeshAddedObservable","onMeshRemovedObservable","_removeMesh","transparentIdx","opaqueIdx","useTransmission","undefined","ignoreCameraViewport","renderList","clearColor","_a","clone","_b","gammaSpace","sceneImageProcessingapplyByPostProcess","saveSceneEnvIntensity","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","imageProcessingConfiguration","applyByPostProcess","toLinearSpaceToRef","copyFrom","_applyByPostProcess","onAfterUnbindObservable","NAME","loader","_loader","enabled","isExtensionUsed","parent","transparencyAsCoverage","KHR_materials_transmission","context","babylonMaterial","LoadExtensionAsync","name","extensionContext","extension","promises","Array","loadMaterialBasePropertiesAsync","loadMaterialPropertiesAsync","_loadTransparentPropertiesAsync","Promise","all","then","Error","pbrMaterial","volumeIndexOfRefraction","useAlbedoToTintRefraction","transmissionFactor","refractionIntensity","getScene","resolve","minimumThickness","maximumThickness","transmissionTexture","nonColorData","loadTextureInfoAsync","texture","refractionIntensityTexture","useGltfStyleTextures","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_transmission.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @hidden\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        if (!material) {\r\n            return false;\r\n        }\r\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material instanceof PBRMaterial) {\r\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    private _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n\r\n        let sceneImageProcessingapplyByPostProcess: boolean;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n            // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = true;\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\r\n        });\r\n\r\n        this._transparentMeshesCache.forEach((mesh: AbstractMesh) => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMaterial\r\n     * @hidden\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial as PBRMaterial;\r\n\r\n        // Enables \"refraction\" texture which represents transmitted light.\r\n        pbrMaterial.subSurface.isRefractionEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\r\n\r\n        if (extension.transmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\r\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\r\n                new TransmissionHelper({}, pbrMaterial.getScene());\r\n            }\r\n        } else {\r\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\r\n            pbrMaterial.subSurface.isRefractionEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture: BaseTexture) => {\r\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\r\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_transmission(loader));\r\n"]},"metadata":{},"sourceType":"module"}