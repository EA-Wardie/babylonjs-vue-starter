{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nNode.AddNodeConstructor(\"Light_Type_3\", function (name, scene) {\n  return function () {\n    return new HemisphericLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\n * The HemisphericLight simulates the ambient environment light,\n * so the passed direction is the light reflection direction, not the incoming direction.\n */\n\nvar HemisphericLight =\n/** @class */\nfunction (_super) {\n  __extends(HemisphericLight, _super);\n  /**\n   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n   * The HemisphericLight can't cast shadows.\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\n   * @param name The friendly name of the light\n   * @param direction The direction of the light reflection\n   * @param scene The scene the light belongs to\n   */\n\n\n  function HemisphericLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\n     * The groundColor is the light in the opposite direction to the one specified during creation.\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\n     */\n\n\n    _this.groundColor = new Color3(0.0, 0.0, 0.0);\n    _this.direction = direction || Vector3.Up();\n    return _this;\n  }\n\n  HemisphericLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightGround\", 3);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\n   * Returns the string \"HemisphericLight\".\n   * @return The class name\n   */\n\n\n  HemisphericLight.prototype.getClassName = function () {\n    return \"HemisphericLight\";\n  };\n  /**\n   * Sets the HemisphericLight direction towards the passed target (Vector3).\n   * Returns the updated direction.\n   * @param target The target the direction should point to\n   * @return The computed direction\n   */\n\n\n  HemisphericLight.prototype.setDirectionToTarget = function (target) {\n    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n    return this.direction;\n  };\n  /**\n   * Returns the shadow generator associated to the light.\n   * @returns Always null for hemispheric lights because it does not support shadows.\n   */\n\n\n  HemisphericLight.prototype.getShadowGenerator = function () {\n    return null;\n  };\n  /**\n   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n   * @param _effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The hemispheric light\n   */\n\n\n  HemisphericLight.prototype.transferToEffect = function (_effect, lightIndex) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n\n    this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n\n    return this;\n  };\n\n  HemisphericLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n    return this;\n  };\n  /**\n   * Computes the world matrix of the node\n   * @returns the world matrix\n   */\n\n\n  HemisphericLight.prototype.computeWorldMatrix = function () {\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n\n    return this._worldMatrix;\n  };\n  /**\n   * Returns the integer 3.\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n\n\n  HemisphericLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n  };\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n\n\n  HemisphericLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"HEMILIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serializeAsColor3()], HemisphericLight.prototype, \"groundColor\", void 0);\n\n  __decorate([serializeAsVector3()], HemisphericLight.prototype, \"direction\", void 0);\n\n  return HemisphericLight;\n}(Light);\n\nexport { HemisphericLight };","map":{"version":3,"mappings":"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","names":["serializeAsColor3","serializeAsVector3","Matrix","Vector3","Color3","Node","Light","AddNodeConstructor","name","scene","HemisphericLight","Zero","__extends","direction","_super","_this","Up","_uniformBuffer","addUniform","create","target","Normalize","subtract","_effect","lightIndex","normalizeDirection","updateFloat4","x","y","z","updateColor3","groundColor","scale","intensity","effect","lightDataUniformName","setFloat3","_worldMatrix","Identity","LIGHTTYPEID_HEMISPHERICLIGHT","defines","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Lights/hemisphericLight.ts"],"sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @return The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}