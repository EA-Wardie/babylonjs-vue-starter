{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport { __extends } from \"tslib\";\nimport { Action } from \"./action.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * This defines an action responsible to change the value of a property\n * by interpolating between its current value and the newly set one once triggered.\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\n */\n\nvar InterpolateValueAction =\n/** @class */\nfunction (_super) {\n  __extends(InterpolateValueAction, _super);\n  /**\n   * Instantiate the action\n   * @param triggerOptions defines the trigger options\n   * @param target defines the object containing the value to interpolate\n   * @param propertyPath defines the path to the property in the target object\n   * @param value defines the target value at the end of the interpolation\n   * @param duration defines the time it will take for the property to interpolate to the value.\n   * @param condition defines the trigger related conditions\n   * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered\n   * @param onInterpolationDone defines a callback raised once the interpolation animation has been done\n   */\n\n\n  function InterpolateValueAction(triggerOptions, target, propertyPath, value, duration, condition, stopOtherAnimations, onInterpolationDone) {\n    if (duration === void 0) {\n      duration = 1000;\n    }\n\n    var _this = _super.call(this, triggerOptions, condition) || this;\n    /**\n     * Defines the time it will take for the property to interpolate to the value.\n     */\n\n\n    _this.duration = 1000;\n    /**\n     * Observable triggered once the interpolation animation has been done.\n     */\n\n    _this.onInterpolationDoneObservable = new Observable();\n    _this.propertyPath = propertyPath;\n    _this.value = value;\n    _this.duration = duration;\n    _this.stopOtherAnimations = stopOtherAnimations;\n    _this.onInterpolationDone = onInterpolationDone;\n    _this._target = _this._effectiveTarget = target;\n    return _this;\n  }\n  /** @hidden */\n\n\n  InterpolateValueAction.prototype._prepare = function () {\n    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n    this._property = this._getProperty(this.propertyPath);\n  };\n  /**\n   * Execute the action starts the value interpolation.\n   */\n\n\n  InterpolateValueAction.prototype.execute = function () {\n    var _this = this;\n\n    var scene = this._actionManager.getScene();\n\n    var keys = [{\n      frame: 0,\n      value: this._effectiveTarget[this._property]\n    }, {\n      frame: 100,\n      value: this.value\n    }];\n    var dataType;\n\n    if (typeof this.value === \"number\") {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (this.value instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (this.value instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (this.value instanceof Matrix) {\n      dataType = Animation.ANIMATIONTYPE_MATRIX;\n    } else if (this.value instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else {\n      Logger.Warn(\"InterpolateValueAction: Unsupported type (\" + _typeof(this.value) + \")\");\n      return;\n    }\n\n    var animation = new Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setKeys(keys);\n\n    if (this.stopOtherAnimations) {\n      scene.stopAnimation(this._effectiveTarget);\n    }\n\n    var wrapper = function wrapper() {\n      _this.onInterpolationDoneObservable.notifyObservers(_this);\n\n      if (_this.onInterpolationDone) {\n        _this.onInterpolationDone();\n      }\n    };\n\n    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);\n  };\n  /**\n   * Serializes the actions and its related information.\n   * @param parent defines the object to serialize in\n   * @returns the serialized object\n   */\n\n\n  InterpolateValueAction.prototype.serialize = function (parent) {\n    return _super.prototype._serialize.call(this, {\n      name: \"InterpolateValueAction\",\n      properties: [Action._GetTargetProperty(this._target), {\n        name: \"propertyPath\",\n        value: this.propertyPath\n      }, {\n        name: \"value\",\n        value: Action._SerializeValueAsString(this.value)\n      }, {\n        name: \"duration\",\n        value: Action._SerializeValueAsString(this.duration)\n      }, {\n        name: \"stopOtherAnimations\",\n        value: Action._SerializeValueAsString(this.stopOtherAnimations) || false\n      }]\n    }, parent);\n  };\n\n  return InterpolateValueAction;\n}(Action);\n\nexport { InterpolateValueAction };\nRegisterClass(\"BABYLON.InterpolateValueAction\", InterpolateValueAction);","map":{"version":3,"mappings":"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","names":["Action","Logger","Observable","Color3","Vector3","Matrix","Quaternion","Animation","RegisterClass","__extends","triggerOptions","target","propertyPath","value","duration","condition","stopOtherAnimations","onInterpolationDone","_super","_this","_target","_effectiveTarget","InterpolateValueAction","_getEffectiveTarget","_property","_getProperty","scene","_actionManager","getScene","keys","frame","dataType","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","Warn","animation","ANIMATIONLOOPMODE_CONSTANT","setKeys","stopAnimation","wrapper","onInterpolationDoneObservable","notifyObservers","beginDirectAnimation","parent","_serialize","call","name","properties","_GetTargetProperty","_SerializeValueAsString"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Actions/interpolateValueAction.ts"],"sourcesContent":["import { Action } from \"./action\";\r\nimport type { Condition } from \"./condition\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * This defines an action responsible to change the value of a property\r\n * by interpolating between its current value and the newly set one once triggered.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n */\r\nexport class InterpolateValueAction extends Action {\r\n    /**\r\n     * Defines the path of the property where the value should be interpolated\r\n     */\r\n    public propertyPath: string;\r\n\r\n    /**\r\n     * Defines the target value at the end of the interpolation.\r\n     */\r\n    public value: any;\r\n\r\n    /**\r\n     * Defines the time it will take for the property to interpolate to the value.\r\n     */\r\n    public duration: number = 1000;\r\n\r\n    /**\r\n     * Defines if the other scene animations should be stopped when the action has been triggered\r\n     */\r\n    public stopOtherAnimations?: boolean;\r\n\r\n    /**\r\n     * Defines a callback raised once the interpolation animation has been done.\r\n     */\r\n    public onInterpolationDone?: () => void;\r\n\r\n    /**\r\n     * Observable triggered once the interpolation animation has been done.\r\n     */\r\n    public onInterpolationDoneObservable = new Observable<InterpolateValueAction>();\r\n\r\n    private _target: any;\r\n    private _effectiveTarget: any;\r\n    private _property: string;\r\n\r\n    /**\r\n     * Instantiate the action\r\n     * @param triggerOptions defines the trigger options\r\n     * @param target defines the object containing the value to interpolate\r\n     * @param propertyPath defines the path to the property in the target object\r\n     * @param value defines the target value at the end of the interpolation\r\n     * @param duration defines the time it will take for the property to interpolate to the value.\r\n     * @param condition defines the trigger related conditions\r\n     * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered\r\n     * @param onInterpolationDone defines a callback raised once the interpolation animation has been done\r\n     */\r\n    constructor(\r\n        triggerOptions: any,\r\n        target: any,\r\n        propertyPath: string,\r\n        value: any,\r\n        duration: number = 1000,\r\n        condition?: Condition,\r\n        stopOtherAnimations?: boolean,\r\n        onInterpolationDone?: () => void\r\n    ) {\r\n        super(triggerOptions, condition);\r\n\r\n        this.propertyPath = propertyPath;\r\n        this.value = value;\r\n        this.duration = duration;\r\n        this.stopOtherAnimations = stopOtherAnimations;\r\n        this.onInterpolationDone = onInterpolationDone;\r\n        this._target = this._effectiveTarget = target;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _prepare(): void {\r\n        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\r\n        this._property = this._getProperty(this.propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Execute the action starts the value interpolation.\r\n     */\r\n    public execute(): void {\r\n        const scene = this._actionManager.getScene();\r\n        const keys = [\r\n            {\r\n                frame: 0,\r\n                value: this._effectiveTarget[this._property],\r\n            },\r\n            {\r\n                frame: 100,\r\n                value: this.value,\r\n            },\r\n        ];\r\n\r\n        let dataType: number;\r\n\r\n        if (typeof this.value === \"number\") {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (this.value instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (this.value instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (this.value instanceof Matrix) {\r\n            dataType = Animation.ANIMATIONTYPE_MATRIX;\r\n        } else if (this.value instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else {\r\n            Logger.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\r\n            return;\r\n        }\r\n\r\n        const animation = new Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (this.stopOtherAnimations) {\r\n            scene.stopAnimation(this._effectiveTarget);\r\n        }\r\n\r\n        const wrapper = () => {\r\n            this.onInterpolationDoneObservable.notifyObservers(this);\r\n            if (this.onInterpolationDone) {\r\n                this.onInterpolationDone();\r\n            }\r\n        };\r\n\r\n        scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);\r\n    }\r\n\r\n    /**\r\n     * Serializes the actions and its related information.\r\n     * @param parent defines the object to serialize in\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(parent: any): any {\r\n        return super._serialize(\r\n            {\r\n                name: \"InterpolateValueAction\",\r\n                properties: [\r\n                    Action._GetTargetProperty(this._target),\r\n                    { name: \"propertyPath\", value: this.propertyPath },\r\n                    { name: \"value\", value: Action._SerializeValueAsString(this.value) },\r\n                    { name: \"duration\", value: Action._SerializeValueAsString(this.duration) },\r\n                    { name: \"stopOtherAnimations\", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false },\r\n                ],\r\n            },\r\n            parent\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InterpolateValueAction\", InterpolateValueAction);\r\n"]},"metadata":{},"sourceType":"module"}