{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * Zones around the hand\n */\n\nexport var HandConstraintZone;\n\n(function (HandConstraintZone) {\n  /**\n   * Above finger tips\n   */\n  HandConstraintZone[HandConstraintZone[\"ABOVE_FINGER_TIPS\"] = 0] = \"ABOVE_FINGER_TIPS\";\n  /**\n   * Next to the thumb\n   */\n\n  HandConstraintZone[HandConstraintZone[\"RADIAL_SIDE\"] = 1] = \"RADIAL_SIDE\";\n  /**\n   * Next to the pinky finger\n   */\n\n  HandConstraintZone[HandConstraintZone[\"ULNAR_SIDE\"] = 2] = \"ULNAR_SIDE\";\n  /**\n   * Below the wrist\n   */\n\n  HandConstraintZone[HandConstraintZone[\"BELOW_WRIST\"] = 3] = \"BELOW_WRIST\";\n})(HandConstraintZone || (HandConstraintZone = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\n\n\nexport var HandConstraintOrientation;\n\n(function (HandConstraintOrientation) {\n  /**\n   * Orientation is towards the camera\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"LOOK_AT_CAMERA\"] = 0] = \"LOOK_AT_CAMERA\";\n  /**\n   * Orientation is determined by the rotation of the palm\n   */\n\n  HandConstraintOrientation[HandConstraintOrientation[\"HAND_ROTATION\"] = 1] = \"HAND_ROTATION\";\n})(HandConstraintOrientation || (HandConstraintOrientation = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\n\n\nexport var HandConstraintVisibility;\n\n(function (HandConstraintVisibility) {\n  /**\n   * Constraint is always visible\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"ALWAYS_VISIBLE\"] = 0] = \"ALWAYS_VISIBLE\";\n  /**\n   * Constraint is only visible when the palm is up\n   */\n\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_UP\"] = 1] = \"PALM_UP\";\n  /**\n   * Constraint is only visible when the user is looking at the constraint.\n   * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\n   */\n\n  HandConstraintVisibility[HandConstraintVisibility[\"GAZE_FOCUS\"] = 2] = \"GAZE_FOCUS\";\n  /**\n   * Constraint is only visible when the palm is up and the user is looking at it\n   */\n\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_AND_GAZE\"] = 3] = \"PALM_AND_GAZE\";\n})(HandConstraintVisibility || (HandConstraintVisibility = {}));\n/**\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\n * @since 5.0.0\n */\n\n\nvar HandConstraintBehavior =\n/** @class */\nfunction () {\n  /**\n   * Builds a hand constraint behavior\n   */\n  function HandConstraintBehavior() {\n    this._sceneRenderObserver = null;\n    this._zoneAxis = {};\n    /**\n     * Sets the HandConstraintVisibility level for the hand constraint\n     */\n\n    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\n    /**\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\n     * Used with HandConstraintVisibility.PALM_UP\n     */\n\n    this.palmUpStrictness = 0.95;\n    /**\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\n     * Used with HandConstraintVisibility.GAZE_FOCUS\n     */\n\n    this.gazeProximityRadius = 0.15;\n    /**\n     * Offset distance from the hand in meters\n     */\n\n    this.targetOffset = 0.1;\n    /**\n     * Where to place the node regarding the center of the hand.\n     */\n\n    this.targetZone = HandConstraintZone.ULNAR_SIDE;\n    /**\n     * Orientation mode of the 4 zones around the hand\n     */\n\n    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Orientation mode of the node attached to this behavior\n     */\n\n    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\n     */\n\n    this.handedness = \"none\";\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n\n    this.lerpTime = 100; // For a right hand\n\n    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\n    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\n    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\n    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\n  }\n\n  Object.defineProperty(HandConstraintBehavior.prototype, \"name\", {\n    /** gets or sets behavior's name */\n    get: function get() {\n      return \"HandConstraint\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Enable the behavior */\n\n  HandConstraintBehavior.prototype.enable = function () {\n    this._node.setEnabled(true);\n  };\n  /** Disable the behavior */\n\n\n  HandConstraintBehavior.prototype.disable = function () {\n    this._node.setEnabled(false);\n  };\n\n  HandConstraintBehavior.prototype._getHandPose = function () {\n    if (!this._handTracking) {\n      return null;\n    } // Retrieve any available hand, starting by the left\n\n\n    var hand;\n\n    if (this.handedness === \"none\") {\n      hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\n    } else {\n      hand = this._handTracking.getHandByHandedness(this.handedness);\n    }\n\n    if (hand) {\n      var pinkyMetacarpal = hand.getJointMesh(\"pinky-finger-metacarpal\"\n      /* PINKY_FINGER_METACARPAL */\n      );\n      var middleMetacarpal = hand.getJointMesh(\"middle-finger-metacarpal\"\n      /* MIDDLE_FINGER_METACARPAL */\n      );\n      var wrist = hand.getJointMesh(\"wrist\"\n      /* WRIST */\n      );\n\n      if (wrist && middleMetacarpal && pinkyMetacarpal) {\n        var handPose = {\n          position: middleMetacarpal.absolutePosition,\n          quaternion: new Quaternion(),\n          id: hand.xrController.uniqueId\n        }; // palm forward\n\n        var up = TmpVectors.Vector3[0];\n        var forward = TmpVectors.Vector3[1];\n        var left = TmpVectors.Vector3[2];\n        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\n        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize(); // Create vectors for a rotation quaternion, where forward points out from the palm\n\n        Vector3.CrossToRef(up, forward, forward);\n        Vector3.CrossToRef(forward, up, left);\n        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\n        return handPose;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Initializes the hand constraint behavior\n   */\n\n\n  HandConstraintBehavior.prototype.init = function () {};\n  /**\n   * Attaches the hand constraint to a `TransformNode`\n   * @param node defines the node to attach the behavior to\n   */\n\n\n  HandConstraintBehavior.prototype.attach = function (node) {\n    var _this = this;\n\n    this._node = node;\n    this._scene = node.getScene();\n\n    if (!this._node.rotationQuaternion) {\n      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\n    }\n\n    var lastTick = Date.now();\n    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n      var pose = _this._getHandPose();\n\n      _this._node.reservedDataStore = _this._node.reservedDataStore || {};\n      _this._node.reservedDataStore.nearInteraction = _this._node.reservedDataStore.nearInteraction || {};\n      _this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\n\n      if (pose) {\n        var zoneOffset = TmpVectors.Vector3[0];\n        var camera = _this._scene.activeCamera;\n        zoneOffset.copyFrom(_this._zoneAxis[_this.targetZone]);\n        var cameraLookAtQuaternion = TmpVectors.Quaternion[0];\n\n        if (camera && (_this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || _this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\n          var toCamera = TmpVectors.Vector3[1];\n          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\n\n          if (_this._scene.useRightHandedSystem) {\n            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          } else {\n            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          }\n        }\n\n        if (_this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        } else {\n          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        }\n\n        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\n        zoneOffset.scaleInPlace(_this.targetOffset);\n        var targetPosition = TmpVectors.Vector3[2];\n        var targetRotation = TmpVectors.Quaternion[1];\n        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\n\n        if (_this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          targetRotation.copyFrom(pose.quaternion);\n        } else {\n          targetRotation.copyFrom(cameraLookAtQuaternion);\n        }\n\n        var elapsed = Date.now() - lastTick;\n        Vector3.SmoothToRef(_this._node.position, targetPosition, elapsed, _this.lerpTime, _this._node.position);\n        Quaternion.SmoothToRef(_this._node.rotationQuaternion, targetRotation, elapsed, _this.lerpTime, _this._node.rotationQuaternion);\n        _this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\n      }\n\n      _this._setVisibility(pose);\n\n      lastTick = Date.now();\n    });\n  };\n\n  HandConstraintBehavior.prototype._setVisibility = function (pose) {\n    var palmVisible = true;\n    var gazeVisible = true;\n    var camera = this._scene.activeCamera;\n\n    if (camera) {\n      var cameraForward = camera.getForwardRay();\n\n      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        gazeVisible = false;\n        var gaze = void 0;\n\n        if (this._eyeTracking) {\n          gaze = this._eyeTracking.getEyeGaze();\n        }\n\n        gaze = gaze || cameraForward;\n        var gazeToBehavior = TmpVectors.Vector3[0];\n\n        if (pose) {\n          pose.position.subtractToRef(gaze.origin, gazeToBehavior);\n        } else {\n          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\n        }\n\n        var projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\n        var projectedSquared = projectedDistance * projectedDistance;\n\n        if (projectedDistance > 0) {\n          var radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\n\n          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\n            gazeVisible = true;\n          }\n        }\n      }\n\n      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        palmVisible = false;\n\n        if (pose) {\n          var palmDirection = TmpVectors.Vector3[0];\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\n\n          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\n            palmVisible = true;\n          }\n        }\n      }\n    }\n\n    this._node.setEnabled(palmVisible && gazeVisible);\n  };\n  /**\n   * Detaches the behavior from the `TransformNode`\n   */\n\n\n  HandConstraintBehavior.prototype.detach = function () {\n    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n  };\n  /**\n   * Links the behavior to the XR experience in which to retrieve hand transform information.\n   * @param xr xr experience\n   */\n\n\n  HandConstraintBehavior.prototype.linkToXRExperience = function (xr) {\n    try {\n      this._eyeTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);\n    } catch (_a) {}\n\n    try {\n      this._handTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);\n    } catch (_b) {\n      alert(\"Hand tracking must be enabled for the Hand Menu to work\");\n    }\n  };\n\n  return HandConstraintBehavior;\n}();\n\nexport { HandConstraintBehavior };","map":{"version":3,"mappings":"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","names":["WebXRFeatureName","Quaternion","TmpVectors","Vector3","HandConstraintZone","HandConstraintOrientation","HandConstraintVisibility","PALM_AND_GAZE","ULNAR_SIDE","HAND_ROTATION","_zoneAxis","ABOVE_FINGER_TIPS","RADIAL_SIDE","BELOW_WRIST","Object","HandConstraintBehavior","_node","setEnabled","_handTracking","hand","handedness","getHandByHandedness","pinkyMetacarpal","getJointMesh","middleMetacarpal","wrist","handPose","position","absolutePosition","quaternion","id","xrController","uniqueId","up","forward","left","copyFrom","subtractInPlace","normalize","CrossToRef","FromLookDirectionLHToRef","node","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","lastTick","Date","now","_sceneRenderObserver","onBeforeRenderObservable","add","pose","_this","_getHandPose","reservedDataStore","nearInteraction","excludedControllerId","zoneOffset","camera","activeCamera","targetZone","cameraLookAtQuaternion","zoneOrientationMode","LOOK_AT_CAMERA","nodeOrientationMode","toCamera","useRightHandedSystem","FromLookDirectionRHToRef","UpReadOnly","toRotationMatrix","Matrix","TransformNormalToRef","scaleInPlace","targetOffset","targetPosition","targetRotation","addInPlace","elapsed","SmoothToRef","lerpTime","_setVisibility","palmVisible","gazeVisible","cameraForward","getForwardRay","handConstraintVisibility","GAZE_FOCUS","gaze","_eyeTracking","getEyeGaze","gazeToBehavior","subtractToRef","origin","getAbsolutePosition","projectedDistance","Dot","direction","projectedSquared","radiusSquared","lengthSquared","gazeProximityRadius","PALM_UP","palmDirection","LeftHandedForwardReadOnly","rotateByQuaternionToRef","palmUpStrictness","remove","xr","featuresManager","getEnabledFeature","EYE_TRACKING","HAND_TRACKING","alert"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/handConstraintBehavior.ts"],"sourcesContent":["import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXREyeTracking } from \"../../XR/features/WebXREyeTracking\";\r\nimport type { WebXRHandTracking } from \"../../XR/features/WebXRHandTracking\";\r\nimport { XRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport type { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintVisibility {\r\n    /**\r\n     * Constraint is always visible\r\n     */\r\n    ALWAYS_VISIBLE,\r\n    /**\r\n     * Constraint is only visible when the palm is up\r\n     */\r\n    PALM_UP,\r\n    /**\r\n     * Constraint is only visible when the user is looking at the constraint.\r\n     * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\r\n     */\r\n    GAZE_FOCUS,\r\n    /**\r\n     * Constraint is only visible when the palm is up and the user is looking at it\r\n     */\r\n    PALM_AND_GAZE,\r\n}\r\n\r\ntype HandPoseInfo = {\r\n    position: Vector3;\r\n    quaternion: Quaternion;\r\n    id: string;\r\n};\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n * @since 5.0.0\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _eyeTracking: Nullable<WebXREyeTracking>;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Sets the HandConstraintVisibility level for the hand constraint\r\n     */\r\n    public handConstraintVisibility: HandConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\r\n\r\n    /**\r\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\r\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\r\n     * Used with HandConstraintVisibility.PALM_UP\r\n     */\r\n    public palmUpStrictness: number = 0.95;\r\n\r\n    /**\r\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\r\n     * Used with HandConstraintVisibility.GAZE_FOCUS\r\n     */\r\n    public gazeProximityRadius: number = 0.15;\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.ULNAR_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\r\n     */\r\n    public handedness: XRHandedness = \"none\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    /** Enable the behavior */\r\n    public enable() {\r\n        this._node.setEnabled(true);\r\n    }\r\n\r\n    /** Disable the behavior */\r\n    public disable() {\r\n        this._node.setEnabled(false);\r\n    }\r\n\r\n    private _getHandPose(): Nullable<HandPoseInfo> {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the left\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(XRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(XRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(XRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                const handPose: HandPoseInfo = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };\r\n\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                const forward = TmpVectors.Vector3[1];\r\n                const left = TmpVectors.Vector3[2];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\r\n\r\n                // Create vectors for a rotation quaternion, where forward points out from the palm\r\n                Vector3.CrossToRef(up, forward, forward);\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\r\n\r\n                return handPose;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\r\n            }\r\n\r\n            this._setVisibility(pose);\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    private _setVisibility(pose: Nullable<HandPoseInfo>) {\r\n        let palmVisible = true;\r\n        let gazeVisible = true;\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            const cameraForward = camera.getForwardRay();\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                gazeVisible = false;\r\n                let gaze: Ray | undefined;\r\n                if (this._eyeTracking) {\r\n                    gaze = this._eyeTracking.getEyeGaze()!;\r\n                }\r\n\r\n                gaze = gaze || cameraForward;\r\n\r\n                const gazeToBehavior = TmpVectors.Vector3[0];\r\n                if (pose) {\r\n                    pose.position.subtractToRef(gaze.origin, gazeToBehavior);\r\n                } else {\r\n                    this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\r\n                }\r\n\r\n                const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\r\n                const projectedSquared = projectedDistance * projectedDistance;\r\n\r\n                if (projectedDistance > 0) {\r\n                    const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\r\n                    if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\r\n                        gazeVisible = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                palmVisible = false;\r\n\r\n                if (pose) {\r\n                    const palmDirection = TmpVectors.Vector3[0];\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\r\n\r\n                    if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\r\n                        palmVisible = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._node.setEnabled(palmVisible && gazeVisible);\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper) {\r\n        try {\r\n            this._eyeTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING) as WebXREyeTracking;\r\n        } catch {}\r\n\r\n        try {\r\n            this._handTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n        } catch {\r\n            alert(\"Hand tracking must be enabled for the Hand Menu to work\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}