{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\n/**\n * Uses the GPU to create a copy texture rescaled at a given size\n * @param texture Texture to copy from\n * @param width defines the desired width\n * @param height defines the desired height\n * @param useBilinearMode defines if bilinear mode has to be used\n * @return the generated texture\n */\n\nexport function CreateResizedCopy(texture, width, height, useBilinearMode) {\n  if (useBilinearMode === void 0) {\n    useBilinearMode = true;\n  }\n\n  var scene = texture.getScene();\n  var engine = scene.getEngine();\n  var rtt = new RenderTargetTexture(\"resized\" + texture.name, {\n    width: width,\n    height: height\n  }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);\n  rtt.wrapU = texture.wrapU;\n  rtt.wrapV = texture.wrapV;\n  rtt.uOffset = texture.uOffset;\n  rtt.vOffset = texture.vOffset;\n  rtt.uScale = texture.uScale;\n  rtt.vScale = texture.vScale;\n  rtt.uAng = texture.uAng;\n  rtt.vAng = texture.vAng;\n  rtt.wAng = texture.wAng;\n  rtt.coordinatesIndex = texture.coordinatesIndex;\n  rtt.level = texture.level;\n  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n  rtt._texture.isReady = false;\n  texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n  texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n  var passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\n  passPostProcess.externalTextureSamplerBinding = true;\n  passPostProcess.getEffect().executeWhenCompiled(function () {\n    passPostProcess.onApply = function (effect) {\n      effect.setTexture(\"textureSampler\", texture);\n    };\n\n    var internalTexture = rtt.renderTarget;\n\n    if (internalTexture) {\n      scene.postProcessManager.directRender([passPostProcess], internalTexture);\n      engine.unBindFramebuffer(internalTexture);\n      rtt.disposeFramebufferObjects();\n      passPostProcess.dispose();\n      rtt.getInternalTexture().isReady = true;\n    }\n  });\n  return rtt;\n}\n/**\n * Apply a post process to a texture\n * @param postProcessName name of the fragment post process\n * @param internalTexture the texture to encode\n * @param scene the scene hosting the texture\n * @param type type of the output texture. If not provided, use the one from internalTexture\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n * @param format format of the output texture. If not provided, use the one from internalTexture\n * @return a promise with the internalTexture having its texture replaced by the result of the processing\n */\n\nexport function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format) {\n  // Gets everything ready.\n  var engine = internalTexture.getEngine();\n  internalTexture.isReady = false;\n  samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;\n  type = type !== null && type !== void 0 ? type : internalTexture.type;\n  format = format !== null && format !== void 0 ? format : internalTexture.format;\n\n  if (type === -1) {\n    type = 0;\n  }\n\n  return new Promise(function (resolve) {\n    // Create the post process\n    var postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\n    postProcess.externalTextureSamplerBinding = true; // Hold the output of the decoding.\n\n    var encodedTexture = engine.createRenderTargetTexture({\n      width: internalTexture.width,\n      height: internalTexture.height\n    }, {\n      generateDepthBuffer: false,\n      generateMipMaps: false,\n      generateStencilBuffer: false,\n      samplingMode: samplingMode,\n      type: type,\n      format: format\n    });\n    postProcess.getEffect().executeWhenCompiled(function () {\n      // PP Render Pass\n      postProcess.onApply = function (effect) {\n        effect._bindTexture(\"textureSampler\", internalTexture);\n\n        effect.setFloat2(\"scale\", 1, 1);\n      };\n\n      scene.postProcessManager.directRender([postProcess], encodedTexture, true); // Cleanup\n\n      engine.restoreDefaultFramebuffer();\n\n      engine._releaseTexture(internalTexture);\n\n      if (postProcess) {\n        postProcess.dispose();\n      } // Internal Swap\n\n\n      encodedTexture._swapAndDie(internalTexture); // Ready to get rolling again.\n\n\n      internalTexture.type = type;\n      internalTexture.format = 5;\n      internalTexture.isReady = true;\n      resolve(internalTexture);\n    });\n  });\n} // ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\n\nvar floatView;\nvar int32View;\n/**\n * Converts a number to half float\n * @param value number to convert\n * @returns converted number\n */\n\nexport function ToHalfFloat(value) {\n  if (!floatView) {\n    floatView = new Float32Array(1);\n    int32View = new Int32Array(floatView.buffer);\n  }\n\n  floatView[0] = value;\n  var x = int32View[0];\n  var bits = x >> 16 & 0x8000;\n  /* Get the sign */\n\n  var m = x >> 12 & 0x07ff;\n  /* Keep one extra bit for rounding */\n\n  var e = x >> 23 & 0xff;\n  /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n\n  if (e < 103) {\n    return bits;\n  }\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n\n    bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n  /* If exponent underflows but not too much, return a denormal */\n\n\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n\n  bits |= e - 112 << 10 | m >> 1;\n  bits += m & 1;\n  return bits;\n}\n/**\n * Converts a half float to a number\n * @param value half float to convert\n * @returns converted half float\n */\n\nexport function FromHalfFloat(value) {\n  var s = (value & 0x8000) >> 15;\n  var e = (value & 0x7c00) >> 10;\n  var f = value & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e == 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n/**\n * Class used to host texture specific utilities\n */\n\nexport var TextureTools = {\n  /**\n   * Uses the GPU to create a copy texture rescaled at a given size\n   * @param texture Texture to copy from\n   * @param width defines the desired width\n   * @param height defines the desired height\n   * @param useBilinearMode defines if bilinear mode has to be used\n   * @return the generated texture\n   */\n  CreateResizedCopy: CreateResizedCopy,\n\n  /**\n   * Apply a post process to a texture\n   * @param postProcessName name of the fragment post process\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param type type of the output texture. If not provided, use the one from internalTexture\n   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n   * @param format format of the output texture. If not provided, use the one from internalTexture\n   * @return a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n  ApplyPostProcess: ApplyPostProcess,\n\n  /**\n   * Converts a number to half float\n   * @param value number to convert\n   * @returns converted number\n   */\n  ToHalfFloat: ToHalfFloat,\n\n  /**\n   * Converts a half float to a number\n   * @param value half float to convert\n   * @returns converted half float\n   */\n  FromHalfFloat: FromHalfFloat\n};","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","PassPostProcess","PostProcess","CreateResizedCopy","texture","width","height","useBilinearMode","scene","getScene","engine","getEngine","rtt","name","noMipmap","_texture","type","samplingMode","wrapU","wrapV","uOffset","vOffset","uScale","vScale","uAng","vAng","wAng","coordinatesIndex","level","anisotropicFilteringLevel","isReady","CLAMP_ADDRESSMODE","passPostProcess","BILINEAR_SAMPLINGMODE","NEAREST_SAMPLINGMODE","externalTextureSamplerBinding","getEffect","executeWhenCompiled","onApply","effect","setTexture","internalTexture","renderTarget","postProcessManager","directRender","unBindFramebuffer","disposeFramebufferObjects","dispose","getInternalTexture","ApplyPostProcess","postProcessName","format","Promise","resolve","postProcess","undefined","encodedTexture","createRenderTargetTexture","generateDepthBuffer","generateMipMaps","generateStencilBuffer","_bindTexture","setFloat2","restoreDefaultFramebuffer","_releaseTexture","_swapAndDie","floatView","int32View","ToHalfFloat","value","Float32Array","Int32Array","buffer","x","bits","m","e","FromHalfFloat","s","f","Math","pow","NaN","Infinity","TextureTools"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/textureTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @return the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.getEffect().executeWhenCompiled(() => {\r\n        passPostProcess.onApply = function (effect) {\r\n            effect.setTexture(\"textureSampler\", texture);\r\n        };\r\n\r\n        const internalTexture = rtt.renderTarget;\r\n\r\n        if (internalTexture) {\r\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n            engine.unBindFramebuffer(internalTexture);\r\n            rtt.disposeFramebufferObjects();\r\n            passPostProcess.dispose();\r\n\r\n            rtt.getInternalTexture()!.isReady = true;\r\n        }\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @return a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: internalTexture.width, height: internalTexture.height },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.getEffect().executeWhenCompiled(() => {\r\n            // PP Render Pass\r\n            postProcess.onApply = (effect) => {\r\n                effect._bindTexture(\"textureSampler\", internalTexture);\r\n                effect.setFloat2(\"scale\", 1, 1);\r\n            };\r\n            scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n            // Cleanup\r\n            engine.restoreDefaultFramebuffer();\r\n            engine._releaseTexture(internalTexture);\r\n            if (postProcess) {\r\n                postProcess.dispose();\r\n            }\r\n\r\n            // Internal Swap\r\n            encodedTexture._swapAndDie(internalTexture);\r\n\r\n            // Ready to get rolling again.\r\n            internalTexture.type = type!;\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.isReady = true;\r\n\r\n            resolve(internalTexture);\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @return the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @return a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n};\r\n"]},"metadata":{},"sourceType":"module"}