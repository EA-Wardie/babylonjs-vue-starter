{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nvar NAME = \"KHR_materials_volume\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume)\n * @since 5.0.0\n */\n\nvar KHR_materials_volume =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_materials_volume(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n\n    this.order = 173;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n\n    if (this.enabled) {\n      // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\n      this._loader._disableInstancedMesh++;\n    }\n  }\n  /** @hidden */\n\n\n  KHR_materials_volume.prototype.dispose = function () {\n    if (this.enabled) {\n      this._loader._disableInstancedMesh--;\n    }\n\n    this._loader = null;\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMaterial\n   * @hidden\n   */\n\n\n  KHR_materials_volume.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\n      return Promise.all(promises).then(function () {});\n    });\n  };\n\n  KHR_materials_volume.prototype._loadVolumePropertiesAsync = function (context, material, babylonMaterial, extension) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    } // If transparency isn't enabled already, this extension shouldn't do anything.\n    // i.e. it requires either the KHR_materials_transmission or KHR_materials_translucency extensions.\n\n\n    if (!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled || !extension.thicknessFactor) {\n      return Promise.resolve();\n    } // IOR in this extension only affects interior.\n\n\n    babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;\n    var attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\n    babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;\n\n    if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {\n      babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);\n    }\n\n    babylonMaterial.subSurface.minimumThickness = 0.0;\n    babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;\n    babylonMaterial.subSurface.useThicknessAsDepth = true;\n\n    if (extension.thicknessTexture) {\n      extension.thicknessTexture.nonColorData = true;\n      return this._loader.loadTextureInfoAsync(\"\".concat(context, \"/thicknessTexture\"), extension.thicknessTexture).then(function (texture) {\n        babylonMaterial.subSurface.thicknessTexture = texture;\n        babylonMaterial.subSurface.useGltfStyleTextures = true;\n      });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  return KHR_materials_volume;\n}();\n\nexport { KHR_materials_volume };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_volume(loader);\n});","map":{"version":3,"mappings":"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","names":["PBRMaterial","GLTFLoader","NAME","loader","_loader","enabled","isExtensionUsed","_disableInstancedMesh","KHR_materials_volume","context","material","babylonMaterial","LoadExtensionAsync","name","extensionContext","extension","promises","Array","push","_this","loadMaterialBasePropertiesAsync","loadMaterialPropertiesAsync","_loadVolumePropertiesAsync","Promise","all","then","Error","subSurface","isRefractionEnabled","isTranslucencyEnabled","thicknessFactor","resolve","volumeIndexOfRefraction","indexOfRefraction","attenuationDistance","undefined","Number","MAX_VALUE","tintColorAtDistance","attenuationColor","length","tintColor","copyFromFloats","minimumThickness","maximumThickness","useThicknessAsDepth","thicknessTexture","nonColorData","loadTextureInfoAsync","texture","useGltfStyleTextures","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_volume.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\ninterface IMaterialsTransmission {\r\n    attenuationColor?: number[];\r\n    attenuationDistance?: number;\r\n    thicknessTexture?: ITextureInfo;\r\n    thicknessFactor?: number;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume)\r\n * @since 5.0.0\r\n */\r\nexport class KHR_materials_volume implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 173;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\r\n            this._loader._disableInstancedMesh++;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        if (this.enabled) {\r\n            this._loader._disableInstancedMesh--;\r\n        }\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMaterial\r\n     * @hidden\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMaterialsTransmission>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadVolumePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_translucency extensions.\r\n        if ((!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled) || !extension.thicknessFactor) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // IOR in this extension only affects interior.\r\n        babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;\r\n        const attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\r\n        babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;\r\n        if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {\r\n            babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);\r\n        }\r\n\r\n        babylonMaterial.subSurface.minimumThickness = 0.0;\r\n        babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;\r\n        babylonMaterial.subSurface.useThicknessAsDepth = true;\r\n        if (extension.thicknessTexture) {\r\n            (extension.thicknessTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture).then((texture: BaseTexture) => {\r\n                babylonMaterial.subSurface.thicknessTexture = texture;\r\n                babylonMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_volume(loader));\r\n"]},"metadata":{},"sourceType":"module"}