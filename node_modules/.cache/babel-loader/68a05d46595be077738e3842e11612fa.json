{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\n\nvar BaseTexture =\n/** @class */\nfunction (_super) {\n  __extends(BaseTexture, _super);\n  /**\n   * Instantiates a new BaseTexture.\n   * Base class of all the textures in babylon.\n   * It groups all the common properties the materials, post process, lights... might need\n   * in order to make a correct use of the texture.\n   * @param sceneOrEngine Define the scene or engine the texture belongs to\n   */\n\n\n  function BaseTexture(sceneOrEngine) {\n    var _this = _super.call(this, null) || this;\n    /**\n     * Gets or sets an object used to store user defined information.\n     */\n\n\n    _this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n\n    _this.reservedDataStore = null;\n    _this._hasAlpha = false;\n    _this._getAlphaFromRGB = false;\n    /**\n     * Intensity or strength of the texture.\n     * It is commonly used by materials to fine tune the intensity of the texture\n     */\n\n    _this.level = 1;\n    _this._coordinatesIndex = 0;\n    _this._coordinatesMode = 0;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n\n    _this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n\n    _this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    _this._isCube = false;\n    _this._gammaSpace = true;\n    /**\n     * Is Z inverted in the texture (useful in a cube texture).\n     */\n\n    _this.invertZ = false;\n    /**\n     * @hidden\n     */\n\n    _this.lodLevelInAlpha = false;\n    /**\n     * Define if the texture is a render target.\n     */\n\n    _this.isRenderTarget = false;\n    /** @hidden */\n\n    _this._prefiltered = false;\n    /** @hidden */\n\n    _this._forceSerialize = false;\n    /**\n     * Define the list of animation attached to the texture.\n     */\n\n    _this.animations = new Array();\n    /**\n     * An event triggered when the texture is disposed.\n     */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    _this._scene = null;\n    /** @hidden */\n\n    _this._uid = null;\n    /** @hidden */\n\n    _this._parentContainer = null;\n    _this._loadingError = false;\n\n    if (sceneOrEngine) {\n      if (BaseTexture._IsScene(sceneOrEngine)) {\n        _this._scene = sceneOrEngine;\n      } else {\n        _this._engine = sceneOrEngine;\n      }\n    } else {\n      _this._scene = EngineStore.LastCreatedScene;\n    }\n\n    if (_this._scene) {\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.addTexture(_this);\n\n      _this._engine = _this._scene.getEngine();\n    }\n\n    _this._uid = null;\n    return _this;\n  }\n\n  Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\n    get: function get() {\n      return this._hasAlpha;\n    },\n\n    /**\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._hasAlpha === value) {\n        return;\n      }\n\n      this._hasAlpha = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"getAlphaFromRGB\", {\n    get: function get() {\n      return this._getAlphaFromRGB;\n    },\n\n    /**\n     * Defines if the alpha value should be determined via the rgb values.\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._getAlphaFromRGB === value) {\n        return;\n      }\n\n      this._getAlphaFromRGB = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"coordinatesIndex\", {\n    get: function get() {\n      return this._coordinatesIndex;\n    },\n\n    /**\n     * Define the UV channel to use starting from 0 and defaulting to 0.\n     * This is part of the texture as textures usually maps to one uv set.\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._coordinatesIndex === value) {\n        return;\n      }\n\n      this._coordinatesIndex = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\n    get: function get() {\n      return this._coordinatesMode;\n    },\n\n    /**\n     * How a texture is mapped.\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 0     | EXPLICIT_MODE                       |             |\n     * | 1     | SPHERICAL_MODE                      |             |\n     * | 2     | PLANAR_MODE                         |             |\n     * | 3     | CUBIC_MODE                          |             |\n     * | 4     | PROJECTION_MODE                     |             |\n     * | 5     | SKYBOX_MODE                         |             |\n     * | 6     | INVCUBIC_MODE                       |             |\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._coordinatesMode === value) {\n        return;\n      }\n\n      this._coordinatesMode = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1, function (mat) {\n          return mat.hasTexture(_this);\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapU\", {\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get: function get() {\n      return this._wrapU;\n    },\n    set: function set(value) {\n      this._wrapU = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapV\", {\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get: function get() {\n      return this._wrapV;\n    },\n    set: function set(value) {\n      this._wrapV = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isCube\", {\n    /**\n     * Define if the texture is a cube texture or if false a 2d texture.\n     */\n    get: function get() {\n      if (!this._texture) {\n        return this._isCube;\n      }\n\n      return this._texture.isCube;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        this._isCube = value;\n      } else {\n        this._texture.isCube = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is3D\", {\n    /**\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is3D;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is3D = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is2DArray\", {\n    /**\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is2DArray;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is2DArray = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"gammaSpace\", {\n    /**\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n     * HDR texture are usually stored in linear space.\n     * This only impacts the PBR and Background materials\n     */\n    get: function get() {\n      if (!this._texture) {\n        return this._gammaSpace;\n      } else {\n        if (this._texture._gammaSpace === null) {\n          this._texture._gammaSpace = this._gammaSpace;\n        }\n      }\n\n      return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n    },\n    set: function set(gamma) {\n      if (!this._texture) {\n        if (this._gammaSpace === gamma) {\n          return;\n        }\n\n        this._gammaSpace = gamma;\n      } else {\n        if (this._texture._gammaSpace === gamma) {\n          return;\n        }\n\n        this._texture._gammaSpace = gamma;\n      }\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isRGBD\", {\n    /**\n     * Gets or sets whether or not the texture contains RGBD data.\n     */\n    get: function get() {\n      return this._texture != null && this._texture._isRGBD;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._isRGBD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"noMipmap\", {\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationOffset\", {\n    /**\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodGenerationOffset;\n      }\n\n      return 0.0;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._lodGenerationOffset = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationScale\", {\n    /**\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodGenerationScale;\n      }\n\n      return 0.0;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._lodGenerationScale = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"linearSpecularLOD\", {\n    /**\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n     * average roughness values.\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._linearSpecularLOD;\n      }\n\n      return false;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._linearSpecularLOD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"irradianceTexture\", {\n    /**\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._irradianceTexture;\n      }\n\n      return null;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._irradianceTexture = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"uid\", {\n    /**\n     * Define the unique id of the texture in the scene.\n     */\n    get: function get() {\n      if (!this._uid) {\n        this._uid = RandomGUID();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Return a string representation of the texture.\n   * @returns the texture as a string\n   */\n\n  BaseTexture.prototype.toString = function () {\n    return this.name;\n  };\n  /**\n   * Get the class name of the texture.\n   * @returns \"BaseTexture\"\n   */\n\n\n  BaseTexture.prototype.getClassName = function () {\n    return \"BaseTexture\";\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\n    /**\n     * Callback triggered when the texture has been disposed.\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\n    /**\n     * Define if the texture is preventing a material to render or not.\n     * If not and the texture is not ready, the engine will use a default black texture instead.\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"loadingError\", {\n    /**\n     * Was there any loading error?\n     */\n    get: function get() {\n      return this._loadingError;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"errorObject\", {\n    /**\n     * If a loading error occurred this object will be populated with information about the error.\n     */\n    get: function get() {\n      return this._errorObject;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the scene the texture belongs to.\n   * @returns the scene or null if undefined\n   */\n\n  BaseTexture.prototype.getScene = function () {\n    return this._scene;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._getEngine = function () {\n    return this._engine;\n  };\n  /**\n   * Checks if the texture has the same transform matrix than another texture\n   * @param texture texture to check against\n   * @returns true if the transforms are the same, else false\n   */\n\n\n  BaseTexture.prototype.checkTransformsAreIdentical = function (texture) {\n    return texture !== null;\n  };\n  /**\n   * Get the texture transform matrix used to offset tile the texture for instance.\n   * @returns the transformation matrix\n   */\n\n\n  BaseTexture.prototype.getTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\n   * Get the texture reflection matrix used to rotate/transform the reflection.\n   * @returns the reflection matrix\n   */\n\n\n  BaseTexture.prototype.getReflectionTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n   * @returns true if ready, not blocking or if there was an error loading the texture\n   */\n\n\n  BaseTexture.prototype.isReadyOrNotBlocking = function () {\n    return !this.isBlocking || this.isReady() || this.loadingError;\n  };\n  /**\n   * Scales the texture if is `canRescale()`\n   * @param ratio the resize factor we want to use to rescale\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  BaseTexture.prototype.scale = function (ratio) {};\n\n  Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\n    /**\n     * Get if the texture can rescale.\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param url\n   * @param noMipmap\n   * @param sampling\n   * @param invertY\n   * @param useSRGBBuffer\n   * @hidden\n   */\n\n  BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling, invertY, useSRGBBuffer) {\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    var correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n\n    var texturesCache = engine.getLoadedTexturesCache();\n\n    for (var index = 0; index < texturesCache.length; index++) {\n      var texturesCacheEntry = texturesCache[index];\n\n      if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n        if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n            if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n              texturesCacheEntry.incrementReferences();\n              return texturesCacheEntry;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._rebuild = function () {};\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n\n\n  BaseTexture.prototype.clone = function () {\n    return null;\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"textureType\", {\n    /**\n     * Get the texture underlying type (INT, FLOAT...)\n     */\n    get: function get() {\n      if (!this._texture) {\n        return 0;\n      }\n\n      return this._texture.type !== undefined ? this._texture.type : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\n    /**\n     * Get the texture underlying format (RGB, RGBA...)\n     */\n    get: function get() {\n      if (!this._texture) {\n        return 5;\n      }\n\n      return this._texture.format !== undefined ? this._texture.format : 5;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Indicates that textures need to be re-calculated for all materials\n   */\n\n  BaseTexture.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    scene.markAllMaterialsAsDirty(1);\n  };\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n   * This will returns an RGBA array buffer containing either in values (0-255) or\n   * float values (0-1) depending of the underlying buffer type.\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @param buffer defines a user defined buffer to fill with data (can be null)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n   * @param x defines the region x coordinates to start reading from (default to 0)\n   * @param y defines the region y coordinates to start reading from (default to 0)pe is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n   * @param width defines the region width to read from (default to the texture size at level)\n   * @param height defines the region width to read from (default to the texture size at level)\n   * @returns The Array buffer promise containing the pixels data.\n   */\n\n\n  BaseTexture.prototype.readPixels = function (faceIndex, level, buffer, flushRenderer, noDataConversion, x, y, width, height) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (flushRenderer === void 0) {\n      flushRenderer = true;\n    }\n\n    if (noDataConversion === void 0) {\n      noDataConversion = false;\n    }\n\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (width === void 0) {\n      width = Number.MAX_VALUE;\n    }\n\n    if (height === void 0) {\n      height = Number.MAX_VALUE;\n    }\n\n    if (!this._texture) {\n      return null;\n    }\n\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    var size = this.getSize();\n    var maxWidth = size.width;\n    var maxHeight = size.height;\n\n    if (level !== 0) {\n      maxWidth = maxWidth / Math.pow(2, level);\n      maxHeight = maxHeight / Math.pow(2, level);\n      maxWidth = Math.round(maxWidth);\n      maxHeight = Math.round(maxHeight);\n    }\n\n    width = Math.min(maxWidth, width);\n    height = Math.min(maxHeight, height);\n\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n      }\n\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n    } catch (e) {\n      return null;\n    }\n  };\n  /**\n   * @param faceIndex\n   * @param level\n   * @param buffer\n   * @param flushRenderer\n   * @param noDataConversion\n   * @hidden\n   */\n\n\n  BaseTexture.prototype._readPixelsSync = function (faceIndex, level, buffer, flushRenderer, noDataConversion) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (flushRenderer === void 0) {\n      flushRenderer = true;\n    }\n\n    if (noDataConversion === void 0) {\n      noDataConversion = false;\n    }\n\n    if (!this._texture) {\n      return null;\n    }\n\n    var size = this.getSize();\n    var width = size.width;\n    var height = size.height;\n\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n      }\n\n      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n    } catch (e) {\n      return null;\n    }\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureHigh;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureMid;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureLow;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n\n  BaseTexture.prototype.dispose = function () {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      } // Remove from scene\n\n\n      this._scene._removePendingData(this);\n\n      var index = this._scene.textures.indexOf(this);\n\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n\n      this._scene = null;\n\n      if (this._parentContainer) {\n        var index_1 = this._parentContainer.textures.indexOf(this);\n\n        if (index_1 > -1) {\n          this._parentContainer.textures.splice(index_1, 1);\n        }\n\n        this._parentContainer = null;\n      }\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Serialize the texture into a JSON representation that can be parsed later on.\n   * @returns the JSON representation of the texture\n   */\n\n\n  BaseTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = SerializationHelper.Serialize(this); // Animations\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\n   * Helper function to be called back once a list of texture contains only ready textures.\n   * @param textures Define the list of textures to wait for\n   * @param callback Define the callback triggered once the entire list will be ready\n   */\n\n\n  BaseTexture.WhenAllReady = function (textures, callback) {\n    var numRemaining = textures.length;\n\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n\n    for (var i = 0; i < textures.length; i++) {\n      var texture = textures[i];\n\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        var onLoadObservable = texture.onLoadObservable;\n\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(function () {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        } else {\n          if (--numRemaining === 0) {\n            callback();\n          }\n        }\n      }\n    }\n  };\n\n  BaseTexture._IsScene = function (sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  };\n  /**\n   * Default anisotropic filtering level for the application.\n   * It is set to 4 as a good tradeoff between perf and quality.\n   */\n\n\n  BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n\n  __decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n\n  __decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n\n  __decorate([serialize(\"getAlphaFromRGB\")], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n\n  __decorate([serialize(\"coordinatesIndex\")], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n\n  __decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n\n  __decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);\n\n  return BaseTexture;\n}(ThinTexture);\n\nexport { BaseTexture };","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","serializeAsTexture","Observable","Matrix","EngineStore","RandomGUID","ThinTexture","__extends","sceneOrEngine","_super","_this","BaseTexture","DEFAULT_ANISOTROPIC_FILTERING_LEVEL","Array","_IsScene","_scene","_engine","LastCreatedScene","uniqueId","getUniqueId","addTexture","getEngine","_uid","Object","_hasAlpha","value","markAllMaterialsAsDirty","mat","hasTexture","_getAlphaFromRGB","_coordinatesIndex","_coordinatesMode","_wrapU","_wrapV","_texture","_isCube","isCube","is3D","is2DArray","_gammaSpace","_useSRGBBuffer","gamma","_markAllSubMeshesAsTexturesDirty","_isRGBD","_lodGenerationOffset","_lodGenerationScale","_linearSpecularLOD","_irradianceTexture","name","callback","_onDisposeObserver","onDisposeObservable","remove","add","_loadingError","_errorObject","texture","IdentityReadOnly","isBlocking","isReady","loadingError","ratio","url","noMipmap","sampling","invertY","useSRGBBuffer","engine","_getEngine","correctedUseSRGBBuffer","_getUseSRGBBuffer","texturesCache","getLoadedTexturesCache","index","length","texturesCacheEntry","undefined","generateMipMaps","samplingMode","incrementReferences","type","format","scene","getScene","faceIndex","level","buffer","flushRenderer","noDataConversion","x","y","width","height","Number","MAX_VALUE","size","getSize","maxWidth","maxHeight","Math","pow","round","min","_readTexturePixels","e","_readTexturePixelsSync","_lodTextureHigh","_lodTextureMid","_lodTextureLow","stopAnimation","_removePendingData","textures","indexOf","splice","onTextureRemovedObservable","notifyObservers","_parentContainer","index_1","clear","metadata","dispose","call","serializationObject","Serialize","AppendSerializedAnimations","numRemaining","i","onLoadObservable","addOnce","getClassName","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/baseTexture.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\ndeclare type Animation = import(\"../../Animations/animation\").Animation;\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    private _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    public set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    public set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    public set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    private _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _prefiltered: boolean = false;\r\n    /** @hidden */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @hidden */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param url\r\n     * @param noMipmap\r\n     * @param sampling\r\n     * @param invertY\r\n     * @param useSRGBBuffer\r\n     * @hidden\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            texturesCacheEntry.incrementReferences();\r\n                            return texturesCacheEntry;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)pe is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param faceIndex\r\n     * @param level\r\n     * @param buffer\r\n     * @param flushRenderer\r\n     * @param noDataConversion\r\n     * @hidden\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene._removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}