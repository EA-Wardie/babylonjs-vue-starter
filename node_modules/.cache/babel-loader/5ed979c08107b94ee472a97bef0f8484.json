{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Path2 } from \"../Maths/math.path.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Vector2 wth index property\n */\n\nvar IndexedVector2 =\n/** @class */\nfunction (_super) {\n  __extends(IndexedVector2, _super);\n\n  function IndexedVector2(original,\n  /** Index of the vector2 */\n  index) {\n    var _this = _super.call(this, original.x, original.y) || this;\n\n    _this.index = index;\n    return _this;\n  }\n\n  return IndexedVector2;\n}(Vector2);\n/**\n * Defines points to create a polygon\n */\n\n\nvar PolygonPoints =\n/** @class */\nfunction () {\n  function PolygonPoints() {\n    this.elements = new Array();\n  }\n\n  PolygonPoints.prototype.add = function (originalPoints) {\n    var _this = this;\n\n    var result = new Array();\n    originalPoints.forEach(function (point) {\n      var newPoint = new IndexedVector2(point, _this.elements.length);\n      result.push(newPoint);\n\n      _this.elements.push(newPoint);\n    });\n    return result;\n  };\n\n  PolygonPoints.prototype.computeBounds = function () {\n    var lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n    var lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n    this.elements.forEach(function (point) {\n      // x\n      if (point.x < lmin.x) {\n        lmin.x = point.x;\n      } else if (point.x > lmax.x) {\n        lmax.x = point.x;\n      } // y\n\n\n      if (point.y < lmin.y) {\n        lmin.y = point.y;\n      } else if (point.y > lmax.y) {\n        lmax.y = point.y;\n      }\n    });\n    return {\n      min: lmin,\n      max: lmax,\n      width: lmax.x - lmin.x,\n      height: lmax.y - lmin.y\n    };\n  };\n\n  return PolygonPoints;\n}();\n/**\n * Polygon\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  function Polygon() {}\n  /**\n   * Creates a rectangle\n   * @param xmin bottom X coord\n   * @param ymin bottom Y coord\n   * @param xmax top X coord\n   * @param ymax top Y coord\n   * @returns points that make the resulting rectangle\n   */\n\n\n  Polygon.Rectangle = function (xmin, ymin, xmax, ymax) {\n    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n  };\n  /**\n   * Creates a circle\n   * @param radius radius of circle\n   * @param cx scale in x\n   * @param cy scale in y\n   * @param numberOfSides number of sides that make up the circle\n   * @returns points that make the resulting circle\n   */\n\n\n  Polygon.Circle = function (radius, cx, cy, numberOfSides) {\n    if (cx === void 0) {\n      cx = 0;\n    }\n\n    if (cy === void 0) {\n      cy = 0;\n    }\n\n    if (numberOfSides === void 0) {\n      numberOfSides = 32;\n    }\n\n    var result = new Array();\n    var angle = 0;\n    var increment = Math.PI * 2 / numberOfSides;\n\n    for (var i = 0; i < numberOfSides; i++) {\n      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n      angle -= increment;\n    }\n\n    return result;\n  };\n  /**\n   * Creates a polygon from input string\n   * @param input Input polygon data\n   * @returns the parsed points\n   */\n\n\n  Polygon.Parse = function (input) {\n    var floats = input.split(/[^-+eE.\\d]+/).map(parseFloat).filter(function (val) {\n      return !isNaN(val);\n    });\n    var i;\n    var result = [];\n\n    for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\n      result.push(new Vector2(floats[i], floats[i + 1]));\n    }\n\n    return result;\n  };\n  /**\n   * Starts building a polygon from x and y coordinates\n   * @param x x coordinate\n   * @param y y coordinate\n   * @returns the started path2\n   */\n\n\n  Polygon.StartingAt = function (x, y) {\n    return Path2.StartingAt(x, y);\n  };\n\n  return Polygon;\n}();\n\nexport { Polygon };\n/**\n * Builds a polygon\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\n */\n\nvar PolygonMeshBuilder =\n/** @class */\nfunction () {\n  /**\n   * Creates a PolygonMeshBuilder\n   * @param name name of the builder\n   * @param contours Path of the polygon\n   * @param scene scene to add to when creating the mesh\n   * @param earcutInjection can be used to inject your own earcut reference\n   */\n  function PolygonMeshBuilder(name, contours, scene, earcutInjection) {\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    this._points = new PolygonPoints();\n    this._outlinepoints = new PolygonPoints();\n    this._holes = new Array();\n    this._epoints = new Array();\n    this._eholes = new Array();\n    this.bjsEarcut = earcutInjection;\n    this._name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    var points;\n\n    if (contours instanceof Path2) {\n      points = contours.getPoints();\n    } else {\n      points = contours;\n    }\n\n    this._addToepoint(points);\n\n    this._points.add(points);\n\n    this._outlinepoints.add(points);\n\n    if (typeof this.bjsEarcut === \"undefined\") {\n      Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n    }\n  }\n\n  PolygonMeshBuilder.prototype._addToepoint = function (points) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var p = points_1[_i];\n\n      this._epoints.push(p.x, p.y);\n    }\n  };\n  /**\n   * Adds a hole within the polygon\n   * @param hole Array of points defining the hole\n   * @returns this\n   */\n\n\n  PolygonMeshBuilder.prototype.addHole = function (hole) {\n    this._points.add(hole);\n\n    var holepoints = new PolygonPoints();\n    holepoints.add(hole);\n\n    this._holes.push(holepoints);\n\n    this._eholes.push(this._epoints.length / 2);\n\n    this._addToepoint(hole);\n\n    return this;\n  };\n  /**\n   * Creates the polygon\n   * @param updatable If the mesh should be updatable\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created mesh\n   */\n\n\n  PolygonMeshBuilder.prototype.build = function (updatable, depth, smoothingThreshold) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    if (smoothingThreshold === void 0) {\n      smoothingThreshold = 2;\n    }\n\n    var result = new Mesh(this._name, this._scene);\n    var vertexData = this.buildVertexData(depth, smoothingThreshold);\n    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n    result.setIndices(vertexData.indices);\n    return result;\n  };\n  /**\n   * Creates the polygon\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created VertexData\n   */\n\n\n  PolygonMeshBuilder.prototype.buildVertexData = function (depth, smoothingThreshold) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    if (smoothingThreshold === void 0) {\n      smoothingThreshold = 2;\n    }\n\n    var result = new VertexData();\n    var normals = new Array();\n    var positions = new Array();\n    var uvs = new Array();\n\n    var bounds = this._points.computeBounds();\n\n    this._points.elements.forEach(function (p) {\n      normals.push(0, 1.0, 0);\n      positions.push(p.x, 0, p.y);\n      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n    });\n\n    var indices = new Array();\n    var res = this.bjsEarcut(this._epoints, this._eholes, 2);\n\n    for (var i = 0; i < res.length; i++) {\n      indices.push(res[i]);\n    }\n\n    if (depth > 0) {\n      var positionscount = positions.length / 3; //get the current pointcount\n\n      this._points.elements.forEach(function (p) {\n        //add the elements at the depth\n        normals.push(0, -1.0, 0);\n        positions.push(p.x, -depth, p.y);\n        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n      });\n\n      var totalCount = indices.length;\n\n      for (var i = 0; i < totalCount; i += 3) {\n        var i0 = indices[i + 0];\n        var i1 = indices[i + 1];\n        var i2 = indices[i + 2];\n        indices.push(i2 + positionscount);\n        indices.push(i1 + positionscount);\n        indices.push(i0 + positionscount);\n      } //Add the sides\n\n\n      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\n\n      this._holes.forEach(function (hole) {\n        _this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\n      });\n    }\n\n    result.indices = indices;\n    result.positions = positions;\n    result.normals = normals;\n    result.uvs = uvs;\n    return result;\n  };\n  /**\n   * Adds a side to the polygon\n   * @param positions points that make the polygon\n   * @param normals normals of the polygon\n   * @param uvs uvs of the polygon\n   * @param indices indices of the polygon\n   * @param bounds bounds of the polygon\n   * @param points points of the polygon\n   * @param depth depth of the polygon\n   * @param flip flip of the polygon\n   * @param smoothingThreshold\n   */\n\n\n  PolygonMeshBuilder.prototype._addSide = function (positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {\n    var startIndex = positions.length / 3;\n    var ulength = 0;\n\n    for (var i = 0; i < points.elements.length; i++) {\n      var p = points.elements[i];\n      var p1 = points.elements[(i + 1) % points.elements.length];\n      positions.push(p.x, 0, p.y);\n      positions.push(p.x, -depth, p.y);\n      positions.push(p1.x, 0, p1.y);\n      positions.push(p1.x, -depth, p1.y);\n      var p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];\n      var p2 = points.elements[(i + 2) % points.elements.length];\n      var vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\n      var vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\n      var vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\n\n      if (!flip) {\n        vc = vc.scale(-1);\n        vp = vp.scale(-1);\n        vn = vn.scale(-1);\n      }\n\n      var vc_norm = vc.normalizeToNew();\n      var vp_norm = vp.normalizeToNew();\n      var vn_norm = vn.normalizeToNew();\n      var dotp = Vector3.Dot(vp_norm, vc_norm);\n\n      if (dotp > smoothingThreshold) {\n        if (dotp < Epsilon - 1) {\n          vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vp_norm = vp.add(vc).normalize();\n        }\n      } else {\n        vp_norm = vc_norm;\n      }\n\n      var dotn = Vector3.Dot(vn, vc);\n\n      if (dotn > smoothingThreshold) {\n        if (dotn < Epsilon - 1) {\n          // back to back\n          vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vn_norm = vn.add(vc).normalize();\n        }\n      } else {\n        vn_norm = vc_norm;\n      }\n\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      ulength += vc.length();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n\n      if (!flip) {\n        indices.push(startIndex);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 3);\n        indices.push(startIndex + 2);\n      } else {\n        indices.push(startIndex);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 3);\n      }\n\n      startIndex += 4;\n    }\n  };\n\n  return PolygonMeshBuilder;\n}();\n\nexport { PolygonMeshBuilder };","map":{"version":3,"mappings":"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","names":["Logger","Vector3","Vector2","VertexBuffer","Mesh","VertexData","Path2","Epsilon","EngineStore","__extends","original","index","_super","x","y","_this","Array","PolygonPoints","originalPoints","result","forEach","point","newPoint","IndexedVector2","elements","length","push","lmin","lmax","min","max","width","height","Polygon","xmin","ymin","xmax","ymax","radius","cx","cy","numberOfSides","angle","increment","Math","PI","i","cos","sin","input","floats","split","map","parseFloat","filter","val","isNaN","StartingAt","name","contours","scene","earcutInjection","bjsEarcut","_name","_scene","LastCreatedScene","points","getPoints","_addToepoint","_points","add","_outlinepoints","Warn","PolygonMeshBuilder","_i","p","_epoints","hole","holepoints","_holes","_eholes","updatable","depth","smoothingThreshold","vertexData","buildVertexData","setVerticesData","PositionKind","positions","NormalKind","normals","UVKind","uvs","setIndices","indices","bounds","computeBounds","res","positionscount","totalCount","i0","i1","i2","_addSide","flip","startIndex","ulength","p1","p0","p2","vc","vp","vn","scale","vc_norm","normalizeToNew","vp_norm","vn_norm","dotp","Dot","subtract","normalize","dotn","z"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/polygonMesh.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = new Array<IndexedVector2>();\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result = new Array<IndexedVector2>();\r\n        originalPoints.forEach((point) => {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result = new Array<Vector2>();\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals = new Array<number>();\r\n        const positions = new Array<number>();\r\n        const uvs = new Array<number>();\r\n\r\n        const bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        const indices = new Array<number>();\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vc_norm = vc.normalizeToNew();\r\n            let vp_norm = vp.normalizeToNew();\r\n            let vn_norm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vp_norm, vc_norm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vp_norm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vp_norm = vc_norm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vn_norm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vn_norm = vc_norm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}