{"ast":null,"code":"import \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\n\n/**\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\n * @param markerOpen opening marker\n * @param markerClose closing marker\n * @param block code block to parse\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\n */\nexport function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {\n  var currPos = startIndex,\n      openMarkers = 0,\n      waitForChar = \"\";\n\n  while (currPos < block.length) {\n    var currChar = block.charAt(currPos);\n\n    if (!waitForChar) {\n      switch (currChar) {\n        case markerOpen:\n          openMarkers++;\n          break;\n\n        case markerClose:\n          openMarkers--;\n          break;\n\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            var nextChar = block.charAt(currPos + 1);\n\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n            }\n          }\n\n          break;\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n        } else {\n          waitForChar = \"\";\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n\n        if (waitForChar === \"\") {\n          currPos++;\n        }\n      }\n    }\n\n    currPos++;\n\n    if (openMarkers === 0) {\n      break;\n    }\n  }\n\n  return openMarkers === 0 ? currPos - 1 : -1;\n}\n/**\n * Parses a string and skip whitespaces\n * @param s string to parse\n * @param index index where to start parsing\n * @returns the index after all whitespaces have been skipped\n */\n\nexport function SkipWhitespaces(s, index) {\n  while (index < s.length) {\n    var c = s[index];\n\n    if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\n\" && c !== \"\\xA0\") {\n      break;\n    }\n\n    index++;\n  }\n\n  return index;\n}\n/**\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\n * @param c character to check\n * @returns true if the character is an identifier character\n */\n\nexport function IsIdentifierChar(c) {\n  var v = c.charCodeAt(0);\n  return v >= 48 && v <= 57 || // 0-9\n  v >= 65 && v <= 90 || // A-Z\n  v >= 97 && v <= 122 || // a-z\n  v == 95; // _\n}\n/**\n * Removes the comments of a code block\n * @param block code block to parse\n * @returns block with the comments removed\n */\n\nexport function RemoveComments(block) {\n  var currPos = 0,\n      waitForChar = \"\",\n      inComments = false;\n  var s = [];\n\n  while (currPos < block.length) {\n    var currChar = block.charAt(currPos);\n\n    if (!waitForChar) {\n      switch (currChar) {\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            var nextChar = block.charAt(currPos + 1);\n\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n              inComments = true;\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n              inComments = true;\n            }\n          }\n\n          break;\n      }\n\n      if (!inComments) {\n        s.push(currChar);\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n          s.push(currChar);\n        } else {\n          waitForChar = \"\";\n          inComments = false;\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n\n        if (waitForChar === \"\") {\n          inComments = false;\n          currPos++;\n        }\n      } else {\n        if (!inComments) {\n          s.push(currChar);\n        }\n      }\n    }\n\n    currPos++;\n  }\n\n  return s.join(\"\");\n}\n/**\n * Finds the first occurrence of a character in a string going backward\n * @param s the string to parse\n * @param index starting index in the string\n * @param c the character to find\n * @returns the index of the character if found, else -1\n */\n\nexport function FindBackward(s, index, c) {\n  while (index >= 0 && s.charAt(index) !== c) {\n    index--;\n  }\n\n  return index;\n}\n/**\n * Escapes a string so that it is usable as a regular expression\n * @param s string to escape\n * @returns escaped string\n */\n\nexport function EscapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}","map":{"version":3,"mappings":"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","names":["ExtractBetweenMarkers","markerOpen","markerClose","block","startIndex","currPos","openMarkers","waitForChar","length","currChar","charAt","nextChar","SkipWhitespaces","s","index","c","IsIdentifierChar","v","charCodeAt","RemoveComments","inComments","push","join","FindBackward","EscapeRegExp","replace"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/codeStringParsingTools.ts"],"sourcesContent":["/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n"]},"metadata":{},"sourceType":"module"}