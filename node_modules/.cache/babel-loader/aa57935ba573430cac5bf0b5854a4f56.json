{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { BoundingSphere } from \"../Culling/boundingSphere.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\n/**\n * Represents one particle of a solid particle system.\n */\n\nvar SolidParticle =\n/** @class */\nfunction () {\n  /**\n   * Creates a Solid Particle object.\n   * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\n   * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\n   * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n   * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\n   * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\n   * @param shapeId (integer) is the model shape identifier in the SPS.\n   * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n   * @param sps defines the sps it is associated to\n   * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\n   * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\n   */\n  function SolidParticle(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo, materialIndex) {\n    if (modelBoundingInfo === void 0) {\n      modelBoundingInfo = null;\n    }\n\n    if (materialIndex === void 0) {\n      materialIndex = null;\n    }\n    /**\n     * particle global index\n     */\n\n\n    this.idx = 0;\n    /**\n     * particle identifier\n     */\n\n    this.id = 0;\n    /**\n     * The color of the particle\n     */\n\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n\n    this.rotation = Vector3.Zero();\n    /**\n     * The scaling of the particle.\n     */\n\n    this.scaling = Vector3.One();\n    /**\n     * The uvs of the particle.\n     */\n\n    this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n    /**\n     * The current speed of the particle.\n     */\n\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n\n    this.translateFromPivot = false;\n    /**\n     * Is the particle active or not ?\n     */\n\n    this.alive = true;\n    /**\n     * Is the particle visible or not ?\n     */\n\n    this.isVisible = true;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @hidden\n     */\n\n    this._pos = 0;\n    /**\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\n     */\n\n    this._ind = 0;\n    /**\n     * ModelShape id of this particle\n     */\n\n    this.shapeId = 0;\n    /**\n     * Index of the particle in its shape id\n     */\n\n    this.idxInShape = 0;\n    /**\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\n     */\n\n    this._stillInvisible = false;\n    /**\n     * @hidden Last computed particle rotation matrix\n     */\n\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n\n    this.parentId = null;\n    /**\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\n     */\n\n    this.materialIndex = null;\n    /**\n     * Custom object or properties.\n     */\n\n    this.props = null;\n    /**\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\n     * The possible values are :\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\n     * */\n\n    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n    /**\n     * @hidden Internal global position in the SPS.\n     */\n\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this.id = particleId;\n    this._pos = positionIndex;\n    this._ind = indiceIndex;\n    this._model = model;\n    this.shapeId = shapeId;\n    this.idxInShape = idxInShape;\n    this._sps = sps;\n\n    if (modelBoundingInfo) {\n      this._modelBoundingInfo = modelBoundingInfo;\n      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n    }\n\n    if (materialIndex !== null) {\n      this.materialIndex = materialIndex;\n    }\n  }\n  /**\n   * Particle BoundingInfo object\n   * @returns a BoundingInfo\n   */\n\n\n  SolidParticle.prototype.getBoundingInfo = function () {\n    return this._boundingInfo;\n  };\n\n  Object.defineProperty(SolidParticle.prototype, \"hasBoundingInfo\", {\n    /**\n     * Returns true if there is already a bounding info\n     */\n    get: function get() {\n      return this._boundingInfo !== null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\n   * @param target the particle target\n   * @returns the current particle\n   */\n\n  SolidParticle.prototype.copyToRef = function (target) {\n    target.position.copyFrom(this.position);\n    target.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      if (target.rotationQuaternion) {\n        target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        target.rotationQuaternion = this.rotationQuaternion.clone();\n      }\n    }\n\n    target.scaling.copyFrom(this.scaling);\n\n    if (this.color) {\n      if (target.color) {\n        target.color.copyFrom(this.color);\n      } else {\n        target.color = this.color.clone();\n      }\n    }\n\n    target.uvs.copyFrom(this.uvs);\n    target.velocity.copyFrom(this.velocity);\n    target.pivot.copyFrom(this.pivot);\n    target.translateFromPivot = this.translateFromPivot;\n    target.alive = this.alive;\n    target.isVisible = this.isVisible;\n    target.parentId = this.parentId;\n    target.cullingStrategy = this.cullingStrategy;\n\n    if (this.materialIndex !== null) {\n      target.materialIndex = this.materialIndex;\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(SolidParticle.prototype, \"scale\", {\n    /**\n     * Legacy support, changed scale to scaling\n     */\n    get: function get() {\n      return this.scaling;\n    },\n\n    /**\n     * Legacy support, changed scale to scaling\n     */\n    set: function set(scale) {\n      this.scaling = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticle.prototype, \"quaternion\", {\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get: function get() {\n      return this.rotationQuaternion;\n    },\n\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set: function set(q) {\n      this.rotationQuaternion = q;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n   * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n   * @param target is the object (solid particle or mesh) what the intersection is computed against.\n   * @returns true if it intersects\n   */\n\n  SolidParticle.prototype.intersectsMesh = function (target) {\n    if (!this._boundingInfo || !target.hasBoundingInfo) {\n      return false;\n    }\n\n    if (this._sps._bSphereOnly) {\n      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\n    }\n\n    return this._boundingInfo.intersects(target.getBoundingInfo(), false);\n  };\n  /**\n   * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\n   * A particle is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the particle is in the frustum planes\n   */\n\n\n  SolidParticle.prototype.isInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  };\n  /**\n   * get the rotation matrix of the particle\n   * @param m\n   * @hidden\n   */\n\n\n  SolidParticle.prototype.getRotationMatrix = function (m) {\n    var quaternion;\n\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      var rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n\n    quaternion.toRotationMatrix(m);\n  };\n\n  return SolidParticle;\n}();\n\nexport { SolidParticle };\n/**\n * Represents the shape of the model used by one particle of a solid particle system.\n * SPS internal tool, don't use it manually.\n */\n\nvar ModelShape =\n/** @class */\nfunction () {\n  /**\n   * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n   * SPS internal tool, don't use it manually.\n   * @param id\n   * @param shape\n   * @param indices\n   * @param normals\n   * @param colors\n   * @param shapeUV\n   * @param posFunction\n   * @param vtxFunction\n   * @param material\n   * @hidden\n   */\n  function ModelShape(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n    /**\n     * length of the shape in the model indices array (internal use)\n     * @hidden\n     */\n    this._indicesLength = 0;\n    this.shapeId = id;\n    this._shape = shape;\n    this._indices = indices;\n    this._indicesLength = indices.length;\n    this._shapeUV = shapeUV;\n    this._shapeColors = colors;\n    this._normals = normals;\n    this._positionFunction = posFunction;\n    this._vertexFunction = vtxFunction;\n    this._material = material;\n  }\n\n  Object.defineProperty(ModelShape.prototype, \"shapeID\", {\n    /**\n     * Get or set the shapeId\n     * @deprecated Please use shapeId instead\n     */\n    get: function get() {\n      return this.shapeId;\n    },\n    set: function set(shapeID) {\n      this.shapeId = shapeID;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ModelShape;\n}();\n\nexport { ModelShape };\n/**\n * Represents a Depth Sorted Particle in the solid particle system.\n * @hidden\n */\n\nvar DepthSortedParticle =\n/** @class */\nfunction () {\n  /**\n   * Creates a new sorted particle\n   * @param idx\n   * @param ind\n   * @param indLength\n   * @param materialIndex\n   */\n  function DepthSortedParticle(idx, ind, indLength, materialIndex) {\n    /**\n     * Particle index\n     */\n    this.idx = 0;\n    /**\n     * Index of the particle in the \"indices\" array\n     */\n\n    this.ind = 0;\n    /**\n     * Length of the particle shape in the \"indices\" array\n     */\n\n    this.indicesLength = 0;\n    /**\n     * Squared distance from the particle to the camera\n     */\n\n    this.sqDistance = 0.0;\n    /**\n     * Material index when used with MultiMaterials\n     */\n\n    this.materialIndex = 0;\n    this.idx = idx;\n    this.ind = ind;\n    this.indicesLength = indLength;\n    this.materialIndex = materialIndex;\n  }\n\n  return DepthSortedParticle;\n}();\n\nexport { DepthSortedParticle };\n/**\n * Represents a solid particle vertex\n */\n\nvar SolidParticleVertex =\n/** @class */\nfunction () {\n  /**\n   * Creates a new solid particle vertex\n   */\n  function SolidParticleVertex() {\n    this.position = Vector3.Zero();\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.uv = Vector2.Zero();\n  }\n\n  Object.defineProperty(SolidParticleVertex.prototype, \"x\", {\n    // Getters and Setters for back-compatibility\n\n    /** Vertex x coordinate */\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(val) {\n      this.position.x = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleVertex.prototype, \"y\", {\n    /** Vertex y coordinate */\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(val) {\n      this.position.y = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleVertex.prototype, \"z\", {\n    /** Vertex z coordinate */\n    get: function get() {\n      return this.position.z;\n    },\n    set: function set(val) {\n      this.position.z = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return SolidParticleVertex;\n}();\n\nexport { SolidParticleVertex };","map":{"version":3,"mappings":"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","names":["Vector3","TmpVectors","Quaternion","Vector4","Vector2","Color4","BoundingInfo","BoundingSphere","AbstractMesh","particleIndex","particleId","positionIndex","indiceIndex","model","shapeId","idxInShape","sps","modelBoundingInfo","materialIndex","Zero","One","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","idx","id","_pos","_ind","_model","_sps","_modelBoundingInfo","_boundingInfo","minimum","maximum","SolidParticle","Object","target","position","copyFrom","rotation","rotationQuaternion","clone","scaling","color","uvs","velocity","pivot","translateFromPivot","alive","isVisible","parentId","cullingStrategy","scale","q","hasBoundingInfo","_bSphereOnly","Intersects","boundingSphere","getBoundingInfo","intersects","frustumPlanes","isInFrustum","m","quaternion","RotationYawPitchRollToRef","y","x","z","toRotationMatrix","shape","indices","normals","colors","shapeUV","posFunction","vtxFunction","material","_shape","_indices","_indicesLength","length","_shapeUV","_shapeColors","_normals","_positionFunction","_vertexFunction","_material","ModelShape","shapeID","ind","indLength","indicesLength","uv","SolidParticleVertex","val"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/solidParticle.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { BoundingSphere } from \"../Culling/boundingSphere\";\r\nimport type { SolidParticleSystem } from \"./solidParticleSystem\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Material } from \"../Materials/material\";\r\n/**\r\n * Represents one particle of a solid particle system.\r\n */\r\nexport class SolidParticle {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * particle identifier\r\n     */\r\n    public id: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scaling of the particle.\r\n     */\r\n    public scaling: Vector3 = Vector3.One();\r\n    /**\r\n     * The uvs of the particle.\r\n     */\r\n    public uvs: Vector4 = new Vector4(0.0, 0.0, 1.0, 1.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Is the particle active or not ?\r\n     */\r\n    public alive: boolean = true;\r\n    /**\r\n     * Is the particle visible or not ?\r\n     */\r\n    public isVisible: boolean = true;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * @hidden ModelShape of this particle (Internal use)\r\n     */\r\n    public _model: ModelShape;\r\n    /**\r\n     * ModelShape id of this particle\r\n     */\r\n    public shapeId: number = 0;\r\n    /**\r\n     * Index of the particle in its shape id\r\n     */\r\n    public idxInShape: number = 0;\r\n    /**\r\n     * @hidden Reference to the shape model BoundingInfo object (Internal use)\r\n     */\r\n    public _modelBoundingInfo: BoundingInfo;\r\n    private _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @hidden Reference to the SPS what the particle belongs to (Internal use)\r\n     */\r\n    public _sps: SolidParticleSystem;\r\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\r\n     */\r\n    public materialIndex: Nullable<number> = null;\r\n    /**\r\n     * Custom object or properties.\r\n     */\r\n    public props: Nullable<any> = null;\r\n    /**\r\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * @hidden Internal global position in the SPS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Particle BoundingInfo object\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a Solid Particle object.\r\n     * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\r\n     * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\r\n     * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\r\n     * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\r\n     * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\r\n     * @param shapeId (integer) is the model shape identifier in the SPS.\r\n     * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\r\n     * @param sps defines the sps it is associated to\r\n     * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\r\n     * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\r\n     */\r\n    constructor(\r\n        particleIndex: number,\r\n        particleId: number,\r\n        positionIndex: number,\r\n        indiceIndex: number,\r\n        model: Nullable<ModelShape>,\r\n        shapeId: number,\r\n        idxInShape: number,\r\n        sps: SolidParticleSystem,\r\n        modelBoundingInfo: Nullable<BoundingInfo> = null,\r\n        materialIndex: Nullable<number> = null\r\n    ) {\r\n        this.idx = particleIndex;\r\n        this.id = particleId;\r\n        this._pos = positionIndex;\r\n        this._ind = indiceIndex;\r\n        this._model = <ModelShape>model;\r\n        this.shapeId = shapeId;\r\n        this.idxInShape = idxInShape;\r\n        this._sps = sps;\r\n        if (modelBoundingInfo) {\r\n            this._modelBoundingInfo = modelBoundingInfo;\r\n            this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\r\n        }\r\n        if (materialIndex !== null) {\r\n            this.materialIndex = materialIndex;\r\n        }\r\n    }\r\n    /**\r\n     * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\r\n     * @param target the particle target\r\n     * @returns the current particle\r\n     */\r\n    public copyToRef(target: SolidParticle): SolidParticle {\r\n        target.position.copyFrom(this.position);\r\n        target.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            if (target.rotationQuaternion) {\r\n                target.rotationQuaternion!.copyFrom(this.rotationQuaternion!);\r\n            } else {\r\n                target.rotationQuaternion = this.rotationQuaternion.clone();\r\n            }\r\n        }\r\n        target.scaling.copyFrom(this.scaling);\r\n        if (this.color) {\r\n            if (target.color) {\r\n                target.color!.copyFrom(this.color!);\r\n            } else {\r\n                target.color = this.color.clone();\r\n            }\r\n        }\r\n        target.uvs.copyFrom(this.uvs);\r\n        target.velocity.copyFrom(this.velocity);\r\n        target.pivot.copyFrom(this.pivot);\r\n        target.translateFromPivot = this.translateFromPivot;\r\n        target.alive = this.alive;\r\n        target.isVisible = this.isVisible;\r\n        target.parentId = this.parentId;\r\n        target.cullingStrategy = this.cullingStrategy;\r\n        if (this.materialIndex !== null) {\r\n            target.materialIndex = this.materialIndex;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public get scale(): Vector3 {\r\n        return this.scaling;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public set scale(scale: Vector3) {\r\n        this.scaling = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\r\n     * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\r\n     * @param target is the object (solid particle or mesh) what the intersection is computed against.\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh | SolidParticle): boolean {\r\n        if (!this._boundingInfo || !target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n        if (this._sps._bSphereOnly) {\r\n            return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\r\n        }\r\n        return this._boundingInfo.intersects(target.getBoundingInfo(), false);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\r\n     * A particle is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the particle is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @param m\r\n     * @hidden\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the shape of the model used by one particle of a solid particle system.\r\n * SPS internal tool, don't use it manually.\r\n */\r\nexport class ModelShape {\r\n    /**\r\n     * Get or set the shapeId\r\n     * @deprecated Please use shapeId instead\r\n     */\r\n    public get shapeID(): number {\r\n        return this.shapeId;\r\n    }\r\n    public set shapeID(shapeID: number) {\r\n        this.shapeId = shapeID;\r\n    }\r\n    /**\r\n     * The shape id\r\n     * @hidden\r\n     */\r\n    public shapeId: number;\r\n    /**\r\n     * flat array of model positions (internal use)\r\n     * @hidden\r\n     */\r\n    public _shape: Vector3[];\r\n    /**\r\n     * flat array of model UVs (internal use)\r\n     * @hidden\r\n     */\r\n    public _shapeUV: number[];\r\n    /**\r\n     * color array of the model\r\n     * @hidden\r\n     */\r\n    public _shapeColors: number[];\r\n    /**\r\n     * indices array of the model\r\n     * @hidden\r\n     */\r\n    public _indices: number[];\r\n    /**\r\n     * normals array of the model\r\n     * @hidden\r\n     */\r\n    public _normals: number[];\r\n    /**\r\n     * length of the shape in the model indices array (internal use)\r\n     * @hidden\r\n     */\r\n    public _indicesLength: number = 0;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @hidden\r\n     */\r\n    public _positionFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>;\r\n    /**\r\n     * Custom vertex function (internal use)\r\n     * @hidden\r\n     */\r\n    public _vertexFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>;\r\n    /**\r\n     * Model material (internal use)\r\n     * @hidden\r\n     */\r\n    public _material: Nullable<Material>;\r\n\r\n    /**\r\n     * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\r\n     * SPS internal tool, don't use it manually.\r\n     * @param id\r\n     * @param shape\r\n     * @param indices\r\n     * @param normals\r\n     * @param colors\r\n     * @param shapeUV\r\n     * @param posFunction\r\n     * @param vtxFunction\r\n     * @param material\r\n     * @hidden\r\n     */\r\n    constructor(\r\n        id: number,\r\n        shape: Vector3[],\r\n        indices: number[],\r\n        normals: number[],\r\n        colors: number[],\r\n        shapeUV: number[],\r\n        posFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>,\r\n        vtxFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>,\r\n        material: Nullable<Material>\r\n    ) {\r\n        this.shapeId = id;\r\n        this._shape = shape;\r\n        this._indices = indices;\r\n        this._indicesLength = indices.length;\r\n        this._shapeUV = shapeUV;\r\n        this._shapeColors = colors;\r\n        this._normals = normals;\r\n        this._positionFunction = posFunction;\r\n        this._vertexFunction = vtxFunction;\r\n        this._material = material;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Depth Sorted Particle in the solid particle system.\r\n * @hidden\r\n */\r\nexport class DepthSortedParticle {\r\n    /**\r\n     * Particle index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * Index of the particle in the \"indices\" array\r\n     */\r\n    public ind: number = 0;\r\n    /**\r\n     * Length of the particle shape in the \"indices\" array\r\n     */\r\n    public indicesLength: number = 0;\r\n    /**\r\n     * Squared distance from the particle to the camera\r\n     */\r\n    public sqDistance: number = 0.0;\r\n    /**\r\n     * Material index when used with MultiMaterials\r\n     */\r\n    public materialIndex: number = 0;\r\n\r\n    /**\r\n     * Creates a new sorted particle\r\n     * @param idx\r\n     * @param ind\r\n     * @param indLength\r\n     * @param materialIndex\r\n     */\r\n    constructor(idx: number, ind: number, indLength: number, materialIndex: number) {\r\n        this.idx = idx;\r\n        this.ind = ind;\r\n        this.indicesLength = indLength;\r\n        this.materialIndex = materialIndex;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a solid particle vertex\r\n */\r\nexport class SolidParticleVertex {\r\n    /**\r\n     * Vertex position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Vertex color\r\n     */\r\n    public color: Color4;\r\n    /**\r\n     * Vertex UV\r\n     */\r\n    public uv: Vector2;\r\n    /**\r\n     * Creates a new solid particle vertex\r\n     */\r\n    constructor() {\r\n        this.position = Vector3.Zero();\r\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this.uv = Vector2.Zero();\r\n    }\r\n    // Getters and Setters for back-compatibility\r\n    /** Vertex x coordinate */\r\n    public get x(): number {\r\n        return this.position.x;\r\n    }\r\n    public set x(val: number) {\r\n        this.position.x = val;\r\n    }\r\n    /** Vertex y coordinate */\r\n    public get y(): number {\r\n        return this.position.y;\r\n    }\r\n    public set y(val: number) {\r\n        this.position.y = val;\r\n    }\r\n    /** Vertex z coordinate */\r\n    public get z(): number {\r\n        return this.position.z;\r\n    }\r\n    public set z(val: number) {\r\n        this.position.z = val;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}