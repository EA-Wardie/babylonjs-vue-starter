{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\n */\n\nvar Skeleton =\n/** @class */\nfunction () {\n  /**\n   * Creates a new skeleton\n   * @param name defines the skeleton name\n   * @param id defines the skeleton Id\n   * @param scene defines the hosting scene\n   */\n  function Skeleton(\n  /** defines the skeleton name */\n  name,\n  /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Defines the list of child bones\n     */\n\n    this.bones = new Array();\n    /**\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n     */\n\n    this.needInitialSkinMatrix = false;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._ranges = {};\n    this._lastAbsoluteTransformsUpdateId = -1;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @hidden */\n\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @hidden */\n\n    this._hasWaitingData = null;\n    /** @hidden */\n\n    this._parentContainer = null;\n    /**\n     * Specifies if the skeleton should be serialized\n     */\n\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null; // Events\n\n    /**\n     * An observable triggered before computing the skeleton's matrices\n     */\n\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n\n    this._scene.addSkeleton(this); //make sure it will recalculate the matrix next time prepare is called.\n\n\n    this._isDirty = true;\n\n    var engineCaps = this._scene.getEngine().getCaps();\n\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n\n  Object.defineProperty(Skeleton.prototype, \"useTextureToStoreBoneMatrices\", {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get: function get() {\n      return this._useTextureToStoreBoneMatrices;\n    },\n    set: function set(value) {\n      this._useTextureToStoreBoneMatrices = value;\n\n      this._markAsDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"animationPropertiesOverride\", {\n    /**\n     * Gets or sets the animation properties override\n     */\n    get: function get() {\n      if (!this._animationPropertiesOverride) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"isUsingTextureForMatrices\", {\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get: function get() {\n      return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"uniqueId\", {\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current object class name.\n   * @return the class name\n   */\n\n  Skeleton.prototype.getClassName = function () {\n    return \"Skeleton\";\n  };\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n\n\n  Skeleton.prototype.getChildren = function () {\n    return this.bones.filter(function (b) {\n      return !b.getParent();\n    });\n  }; // Members\n\n  /**\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a Float32Array containing matrices data\n   */\n\n\n  Skeleton.prototype.getTransformMatrices = function (mesh) {\n    if (this.needInitialSkinMatrix) {\n      if (!mesh._bonesTransformMatrices) {\n        this.prepare();\n      }\n\n      return mesh._bonesTransformMatrices;\n    }\n\n    if (!this._transformMatrices) {\n      this.prepare();\n    }\n\n    return this._transformMatrices;\n  };\n  /**\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a raw texture containing the data\n   */\n\n\n  Skeleton.prototype.getTransformMatrixTexture = function (mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n\n    return this._transformMatrixTexture;\n  };\n  /**\n   * Gets the current hosting scene\n   * @returns a scene object\n   */\n\n\n  Skeleton.prototype.getScene = function () {\n    return this._scene;\n  }; // Methods\n\n  /**\n   * Gets a string representing the current skeleton data\n   * @param fullDetails defines a boolean indicating if we want a verbose version\n   * @returns a string representing the current skeleton data\n   */\n\n\n  Skeleton.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \".concat(this.name, \", nBones: \").concat(this.bones.length);\n    ret += \", nAnimationRanges: \".concat(this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name_1 in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name_1;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\n   * Get bone's index searching by name\n   * @param name defines bone's name to search for\n   * @return the indice of the bone. Returns -1 if not found\n   */\n\n\n  Skeleton.prototype.getBoneIndexByName = function (name) {\n    for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Create a new animation range\n   * @param name defines the name of the range\n   * @param from defines the start key\n   * @param to defines the end key\n   */\n\n\n  Skeleton.prototype.createAnimationRange = function (name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n\n      for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  };\n  /**\n   * Delete a specific animation range\n   * @param name defines the name of the range\n   * @param deleteFrames defines if frames must be removed as well\n   */\n\n\n  Skeleton.prototype.deleteAnimationRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\n   * Gets a specific animation range\n   * @param name defines the name of the range to look for\n   * @returns the requested animation range or null if not found\n   */\n\n\n  Skeleton.prototype.getAnimationRange = function (name) {\n    return this._ranges[name] || null;\n  };\n  /**\n   * Gets the list of all animation ranges defined on this skeleton\n   * @returns an array\n   */\n\n\n  Skeleton.prototype.getAnimationRanges = function () {\n    var animationRanges = [];\n    var name;\n\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n\n    return animationRanges;\n  };\n  /**\n   * Copy animation range from a source skeleton.\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n   * @param source defines the source skeleton\n   * @param name defines the name of the range to copy\n   * @param rescaleAsRequired defines if rescaling must be applied if required\n   * @returns true if operation was successful\n   */\n\n\n  Skeleton.prototype.copyAnimationRange = function (source, name, rescaleAsRequired) {\n    if (rescaleAsRequired === void 0) {\n      rescaleAsRequired = false;\n    }\n\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n\n    var ret = true;\n    var frameOffset = this._getHighestAnimationFrame() + 1; // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n\n    var boneDict = {};\n    var sourceBones = source.bones;\n    var nBones;\n    var i;\n\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(\"copyAnimationRange: this rig has \".concat(this.bones.length, \" bones, while source as \").concat(sourceBones.length));\n      ret = false;\n    }\n\n    var skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      var boneName = this.bones[i].name;\n      var sourceBone = boneDict[boneName];\n\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    } // do not call createAnimationRange(), since it also is done to bones, which was already done\n\n\n    var range = source.getAnimationRange(name);\n\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n\n    return ret;\n  };\n  /**\n   * Forces the skeleton to go to rest pose\n   */\n\n\n  Skeleton.prototype.returnToRest = function () {\n    for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {\n      var bone = _a[_i];\n\n      if (bone._index !== -1) {\n        bone.returnToRest();\n      }\n    }\n  };\n\n  Skeleton.prototype._getHighestAnimationFrame = function () {\n    var ret = 0;\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        var highest = this.bones[i].animations[0].getHighestFrame();\n\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n\n    return ret;\n  };\n  /**\n   * Begin a specific animation range\n   * @param name defines the name of the range to start\n   * @param loop defines if looping must be turned on (false by default)\n   * @param speedRatio defines the speed ratio to apply (1 by default)\n   * @param onAnimationEnd defines a callback which will be called when animation will end\n   * @returns a new animatable\n   */\n\n\n  Skeleton.prototype.beginAnimation = function (name, loop, speedRatio, onAnimationEnd) {\n    var range = this.getAnimationRange(name);\n\n    if (!range) {\n      return null;\n    }\n\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  };\n  /**\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n   * @param skeleton defines the Skeleton containing the animation range to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n   * @returns the original skeleton\n   */\n\n\n  Skeleton.MakeAnimationAdditive = function (skeleton, referenceFrame, range) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    var rangeValue = skeleton.getAnimationRange(range); // We can't make a range additive if it doesn't exist\n\n    if (!rangeValue) {\n      return null;\n    } // Find any current scene-level animatable belonging to the target that matches the range\n\n\n    var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n\n    var rangeAnimatable = null;\n\n    for (var index = 0; index < sceneAnimatables.length; index++) {\n      var sceneAnimatable = sceneAnimatables[index];\n\n      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    } // Convert the animations belonging to the skeleton to additive keyframes\n\n\n    var animatables = skeleton.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      var animatable = animatables[index];\n      var animations = animatable.animations;\n\n      if (!animations) {\n        continue;\n      }\n\n      for (var animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    } // Mark the scene-level animatable as additive\n\n\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n\n    return skeleton;\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._markAsDirty = function () {\n    this._isDirty = true;\n  };\n  /**\n   * @param mesh\n   * @hidden\n   */\n\n\n  Skeleton.prototype._registerMeshWithPoseMatrix = function (mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  };\n  /**\n   * @param mesh\n   * @hidden\n   */\n\n\n  Skeleton.prototype._unregisterMeshWithPoseMatrix = function (mesh) {\n    var index = this._meshesWithPoseMatrix.indexOf(mesh);\n\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  };\n\n  Skeleton.prototype._computeTransformMatrices = function (targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      bone._childUpdateId++;\n      var parentBone = bone.getParent();\n\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n        } else {\n          bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n\n      if (bone._index !== -1) {\n        var mappedIndex = bone._index === null ? index : bone._index;\n        bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  };\n  /**\n   * Build all resources required to render a skeleton\n   */\n\n\n  Skeleton.prototype.prepare = function () {\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {\n        var bone = _a[_i];\n\n        if (bone._linkedTransformNode) {\n          // Computing the world matrix also computes the local matrix.\n          bone._linkedTransformNode.computeWorldMatrix();\n\n          bone._matrix = bone._linkedTransformNode._localMatrix;\n        }\n      }\n    }\n\n    if (this.needInitialSkinMatrix) {\n      for (var _b = 0, _c = this._meshesWithPoseMatrix; _b < _c.length; _b++) {\n        var mesh = _c[_b];\n        var poseMatrix = mesh.getPoseMatrix();\n        var needsUpdate = this._isDirty;\n\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n          needsUpdate = true;\n        }\n\n        if (!needsUpdate) {\n          continue;\n        }\n\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh; // Prepare bones\n\n          for (var _d = 0, _e = this.bones; _d < _e.length; _d++) {\n            var bone = _e[_d];\n\n            if (!bone.getParent()) {\n              var matrix = bone.getBaseMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n\n              bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\n            }\n          }\n\n          if (this.isUsingTextureForMatrices) {\n            var textureWidth = (this.bones.length + 1) * 4;\n\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._isDirty) {\n        return;\n      }\n\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n\n      this._computeTransformMatrices(this._transformMatrices, null);\n\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n\n    this._isDirty = false;\n  };\n  /**\n   * Gets the list of animatables currently running for this skeleton\n   * @returns an array of animatables\n   */\n\n\n  Skeleton.prototype.getAnimatables = function () {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n\n      for (var index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n\n    return this._animatables;\n  };\n  /**\n   * Clone the current skeleton\n   * @param name defines the name of the new skeleton\n   * @param id defines the id of the new skeleton\n   * @returns the new skeleton\n   */\n\n\n  Skeleton.prototype.clone = function (name, id) {\n    var result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var source = this.bones[index];\n      var parentBone = null;\n      var parent_1 = source.getParent();\n\n      if (parent_1) {\n        var parentIndex = this.bones.indexOf(parent_1);\n        parentBone = result.bones[parentIndex];\n      }\n\n      var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n      bone._index = source._index;\n\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n\n    if (this._ranges) {\n      result._ranges = {};\n\n      for (var rangeName in this._ranges) {\n        var range = this._ranges[rangeName];\n\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n\n    this._isDirty = true;\n    return result;\n  };\n  /**\n   * Enable animation blending for this skeleton\n   * @param blendingSpeed defines the blending speed to apply\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\n   */\n\n\n  Skeleton.prototype.enableBlending = function (blendingSpeed) {\n    if (blendingSpeed === void 0) {\n      blendingSpeed = 0.01;\n    }\n\n    this.bones.forEach(function (bone) {\n      bone.animations.forEach(function (animation) {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  };\n  /**\n   * Releases all resources associated with the current skeleton\n   */\n\n\n  Skeleton.prototype.dispose = function () {\n    this._meshesWithPoseMatrix = []; // Animations\n\n    this.getScene().stopAnimation(this); // Remove from scene\n\n    this.getScene().removeSkeleton(this);\n\n    if (this._parentContainer) {\n      var index = this._parentContainer.skeletons.indexOf(this);\n\n      if (index > -1) {\n        this._parentContainer.skeletons.splice(index, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    }\n  };\n  /**\n   * Serialize the skeleton in a JSON object\n   * @returns a JSON object\n   */\n\n\n  Skeleton.prototype.serialize = function () {\n    var _a;\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      var parent_2 = bone.getParent();\n      var serializedBone = {\n        parentBoneIndex: parent_2 ? this.bones.indexOf(parent_2) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        id: bone.id,\n        matrix: bone.getBaseMatrix().toArray(),\n        rest: bone.getRestPose().toArray(),\n        linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id\n      };\n      serializationObject.bones.push(serializedBone);\n\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n\n      serializationObject.ranges = [];\n\n      for (var name_2 in this._ranges) {\n        var source = this._ranges[name_2];\n\n        if (!source) {\n          continue;\n        }\n\n        var range = {};\n        range.name = name_2;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\n   * Creates a new skeleton from serialized data\n   * @param parsedSkeleton defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns a new skeleton\n   */\n\n\n  Skeleton.Parse = function (parsedSkeleton, scene) {\n    var skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n    var index;\n\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      var parsedBone = parsedSkeleton.bones[index];\n      var parsedBoneIndex = parsedSkeleton.bones[index].index;\n      var parentBone = null;\n\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n\n      var rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    } // placed after bones, so createAnimationRange can cascade down\n\n\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        var data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n\n    return skeleton;\n  };\n  /**\n   * Compute all node absolute transforms\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   */\n\n\n  Skeleton.prototype.computeAbsoluteTransforms = function (forceUpdate) {\n    if (forceUpdate === void 0) {\n      forceUpdate = false;\n    }\n\n    var renderId = this._scene.getRenderId();\n\n    if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\n      this.bones[0].computeAbsoluteTransforms();\n      this._lastAbsoluteTransformsUpdateId = renderId;\n    }\n  };\n  /**\n   * Gets the root pose matrix\n   * @returns a matrix\n   */\n\n\n  Skeleton.prototype.getPoseMatrix = function () {\n    var poseMatrix = null;\n\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n\n    return poseMatrix;\n  };\n  /**\n   * Sorts bones per internal index\n   */\n\n\n  Skeleton.prototype.sortBones = function () {\n    var bones = new Array();\n    var visited = new Array(this.bones.length);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n\n    this.bones = bones;\n  };\n\n  Skeleton.prototype._sortBones = function (index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n\n    visited[index] = true;\n    var bone = this.bones[index];\n    if (!bone) return;\n\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n\n    var parentBone = bone.getParent();\n\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n\n    bones.push(bone);\n  };\n  /**\n   * Set the current local matrix as the restPose for all bones in the skeleton.\n   */\n\n\n  Skeleton.prototype.setCurrentPoseAsRest = function () {\n    this.bones.forEach(function (b) {\n      b.setCurrentPoseAsRest();\n    });\n  };\n\n  return Skeleton;\n}();\n\nexport { Skeleton };","map":{"version":3,"mappings":"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","names":["Bone","Observable","Vector3","Matrix","TmpVectors","RawTexture","Animation","AnimationRange","EngineStore","Logger","DeepCopier","name","id","scene","Array","Identity","bones","_scene","LastCreatedScene","_uniqueId","getUniqueId","addSkeleton","_isDirty","engineCaps","getEngine","getCaps","_canUseTextureForBones","textureFloat","maxVertexTextureImageUnits","Object","Skeleton","_useTextureToStoreBoneMatrices","value","_markAsDirty","_animationPropertiesOverride","animationPropertiesOverride","useTextureToStoreBoneMatrices","filter","b","getParent","mesh","needInitialSkinMatrix","_bonesTransformMatrices","prepare","_transformMatrices","_transformMatrixTexture","fullDetails","ret","concat","length","_ranges","keys","first","name_1","boneIndex","cache","from","to","i","nBones","animations","createRange","deleteFrames","deleteRange","animationRanges","push","source","rescaleAsRequired","getAnimationRange","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","copyAnimationRange","range","_i","bone","_index","returnToRest","highest","getHighestFrame","loop","speedRatio","onAnimationEnd","beginAnimation","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animatable","animIndex","MakeAnimationAdditive","isAdditive","_meshesWithPoseMatrix","indexOf","splice","targetMatrix","initialSkinMatrix","onBeforeComputeObservable","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getWorldMatrix","copyFrom","mappedIndex","getInvertedAbsoluteTransform","multiplyToArray","_identity","copyToArray","_numBonesWithLinkedTransformNode","_linkedTransformNode","computeWorldMatrix","_matrix","_localMatrix","_b","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","_d","matrix","getBaseMatrix","_updateDifferenceMatrix","isUsingTextureForMatrices","textureWidth","getSize","width","dispose","CreateRGBATexture","_computeTransformMatrices","update","_animatables","result","parent_1","parentIndex","clone","getRestPose","linkTransformNode","DeepCopy","rangeName","blendingSpeed","forEach","animation","enableBlending","getScene","stopAnimation","removeSkeleton","_parentContainer","skeletons","serializationObject","asArray","parent_2","serializedBone","parentBoneIndex","getIndex","toArray","rest","linkedTransformNodeId","getTransformNode","_a","metadata","serialize","ranges","name_2","parsedSkeleton","FromArray","parsedBone","parsedBoneIndex","undefined","Parse","_hasWaitingData","_waitingTransformNodeId","data","createAnimationRange","forceUpdate","renderId","getRenderId","_lastAbsoluteTransformsUpdateId","computeAbsoluteTransforms","visited","_sortBones","setCurrentPoseAsRest"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Bones/skeleton.ts"],"sourcesContent":["import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones = new Array<Bone>();\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _lastAbsoluteTransformsUpdateId = -1;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @hidden */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @hidden */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: AbstractMesh): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare();\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices) {\r\n            this.prepare();\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @return the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @param mesh\r\n     * @hidden\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @param mesh\r\n     * @hidden\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\r\n                } else {\r\n                    bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     */\r\n    public prepare(): void {\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    // Computing the world matrix also computes the local matrix.\r\n                    bone._linkedTransformNode.computeWorldMatrix();\r\n                    bone._matrix = bone._linkedTransformNode._localMatrix;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBaseMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        this.bones.forEach((bone) => {\r\n            bone.animations.forEach((animation: Animation) => {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix = [];\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBaseMatrix().toArray(),\r\n                rest: bone.getRestPose().toArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute transforms\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        const renderId = this._scene.getRenderId();\r\n\r\n        if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\r\n            this.bones[0].computeAbsoluteTransforms();\r\n            this._lastAbsoluteTransformsUpdateId = renderId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones = new Array<Bone>();\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) return;\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.bones.forEach((b) => {\r\n            b.setCurrentPoseAsRest();\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}