{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Matrix, Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration.js\";\nimport \"../Animations/animatable.js\";\nimport \"../Rendering/geometryBufferRendererSceneComponent.js\";\nimport \"../Shaders/motionBlur.fragment.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\n * As an example, all you have to do is to create the post-process:\n *  var mb = new BABYLON.MotionBlurPostProcess(\n *      'mb', // The name of the effect.\n *      scene, // The scene containing the objects to blur according to their velocity.\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\n *      camera // The camera to apply the render pass to.\n * );\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\n */\n\nvar MotionBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(MotionBlurPostProcess, _super);\n  /**\n   * Creates a new instance MotionBlurPostProcess\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to blur according to their velocity.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n\n\n  function MotionBlurPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = false;\n    }\n\n    var _this = _super.call(this, name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\"], [\"velocitySampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation) || this;\n    /**\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\n     */\n\n\n    _this.motionStrength = 1;\n    _this._motionBlurSamples = 32;\n    _this._isObjectBased = true;\n    _this._forceGeometryBuffer = false;\n    _this._invViewProjection = null;\n    _this._previousViewProjection = null;\n    _this._forceGeometryBuffer = forceGeometryBuffer; // Set up assets\n\n    if (_this._forceGeometryBuffer) {\n      scene.enableGeometryBufferRenderer();\n\n      if (_this._geometryBufferRenderer) {\n        _this._geometryBufferRenderer.enableVelocity = true;\n      }\n    } else {\n      scene.enablePrePassRenderer();\n\n      if (_this._prePassRenderer) {\n        _this._prePassRenderer.markAsDirty();\n\n        _this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n\n    _this._applyMode();\n\n    return _this;\n  }\n\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"motionBlurSamples\", {\n    /**\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\n     */\n    get: function get() {\n      return this._motionBlurSamples;\n    },\n\n    /**\n     * Sets the number of iterations to be used for motion blur quality\n     */\n    set: function set(samples) {\n      this._motionBlurSamples = samples;\n\n      this._updateEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"isObjectBased\", {\n    /**\n     * Gets whether or not the motion blur post-process is in object based mode.\n     */\n    get: function get() {\n      return this._isObjectBased;\n    },\n\n    /**\n     * Sets whether or not the motion blur post-process is in object based mode.\n     */\n    set: function set(value) {\n      if (this._isObjectBased === value) {\n        return;\n      }\n\n      this._isObjectBased = value;\n\n      this._applyMode();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"_geometryBufferRenderer\", {\n    get: function get() {\n      if (!this._forceGeometryBuffer) {\n        return null;\n      }\n\n      return this._scene.geometryBufferRenderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"_prePassRenderer\", {\n    get: function get() {\n      if (this._forceGeometryBuffer) {\n        return null;\n      }\n\n      return this._scene.prePassRenderer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"MotionBlurPostProcess\" string\n   */\n\n  MotionBlurPostProcess.prototype.getClassName = function () {\n    return \"MotionBlurPostProcess\";\n  };\n  /**\n   * Excludes the given skinned mesh from computing bones velocities.\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\n   */\n\n\n  MotionBlurPostProcess.prototype.excludeSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      list.push(skinnedMesh);\n    }\n  };\n  /**\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\n   */\n\n\n  MotionBlurPostProcess.prototype.removeExcludedSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      var index = list.indexOf(skinnedMesh);\n\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  };\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n\n\n  MotionBlurPostProcess.prototype.dispose = function (camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\n   * Called on the mode changed (object based or screen based).\n   */\n\n\n  MotionBlurPostProcess.prototype._applyMode = function () {\n    var _this = this;\n\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n\n    this._updateEffect();\n\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyObjectBased(effect);\n      };\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = Matrix.Identity();\n\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyScreenBased(effect);\n      };\n    }\n  };\n  /**\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\n   * @param effect\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyObjectBased = function (effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      var velocityIndex = this._prePassRenderer.getIndex(2);\n\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\n    }\n  };\n  /**\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\n   * @param effect\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyScreenBased = function (effect) {\n    var viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());\n\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection = viewProjection;\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\n\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      var depthIndex = this._prePassRenderer.getIndex(5);\n\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\n    }\n  };\n  /**\n   * Called on the effect must be updated (changed mode, samples count, etc.).\n   */\n\n\n  MotionBlurPostProcess.prototype._updateEffect = function () {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      var defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  };\n  /**\n   * @param parsedPostProcess\n   * @param targetCamera\n   * @param scene\n   * @param rootUrl\n   * @hidden\n   */\n\n\n  MotionBlurPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\n\n  return MotionBlurPostProcess;\n}(PostProcess);\n\nexport { MotionBlurPostProcess };\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);","map":{"version":3,"mappings":"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","names":["Logger","Matrix","Vector2","PostProcess","GeometryBufferRenderer","MotionBlurConfiguration","serialize","SerializationHelper","RegisterClass","__extends","name","scene","options","camera","samplingMode","engine","reusable","textureType","blockCompilation","forceGeometryBuffer","_super","undefined","_this","_forceGeometryBuffer","enableGeometryBufferRenderer","_geometryBufferRenderer","enableVelocity","enablePrePassRenderer","_prePassRenderer","markAsDirty","_prePassEffectConfiguration","_applyMode","Object","MotionBlurPostProcess","_motionBlurSamples","samples","_updateEffect","_isObjectBased","value","_scene","geometryBufferRenderer","prePassRenderer","skinnedMesh","skeleton","list","excludedSkinnedMeshesFromVelocity","excludedSkinnedMesh","push","index","indexOf","splice","_previousTransformationMatrices","_previousBonesTransformationMatrices","dispose","call","Warn","updateEffect","_invViewProjection","_previousViewProjection","isObjectBased","texturesRequired","onApply","effect","_onApplyObjectBased","Identity","_onApplyScreenBased","setVector2","width","height","setFloat","getAnimationRatio","motionStrength","velocityIndex","getTextureIndex","VELOCITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","getRenderTarget","viewProjection","getProjectionMatrix","multiply","getViewMatrix","invertToRef","setMatrix","depthIndex","DEPTH_TEXTURE_TYPE","defines","toFixed","join","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/motionBlurPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport \"../Rendering/geometryBufferRendererSceneComponent\";\r\nimport \"../Shaders/motionBlur.fragment\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n        this._updateEffect();\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this._isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _isObjectBased: boolean = true;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _invViewProjection: Nullable<Matrix> = null;\r\n    private _previousViewProjection: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"motionBlur\",\r\n            [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\"],\r\n            [\"velocitySampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = true;\r\n            }\r\n        } else {\r\n            scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode(): void {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return this.updateEffect();\r\n        }\r\n\r\n        this._updateEffect();\r\n\r\n        this._invViewProjection = null;\r\n        this._previousViewProjection = null;\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_VELOCITY_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            this._invViewProjection = Matrix.Identity();\r\n            this._previousViewProjection = Matrix.Identity();\r\n\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_DEPTH_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        const viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());\r\n\r\n        viewProjection.invertToRef(this._invViewProjection!);\r\n        effect.setMatrix(\"inverseViewProjection\", this._invViewProjection!);\r\n\r\n        effect.setMatrix(\"prevViewProjection\", this._previousViewProjection!);\r\n        this._previousViewProjection = viewProjection;\r\n\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect must be updated (changed mode, samples count, etc.).\r\n     */\r\n    private _updateEffect(): void {\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            const defines: string[] = [\r\n                \"#define GEOMETRY_SUPPORTED\",\r\n                \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1),\r\n                this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\",\r\n            ];\r\n\r\n            this.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param parsedPostProcess\r\n     * @param targetCamera\r\n     * @param scene\r\n     * @param rootUrl\r\n     * @hidden\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new MotionBlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\r\n"]},"metadata":{},"sourceType":"module"}