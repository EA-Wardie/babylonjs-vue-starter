{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport { __awaiter, __generator } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer.js\";\n/**\n * Configuration object for WebXR output canvas\n */\n\nvar WebXRManagedOutputCanvasOptions =\n/** @class */\nfunction () {\n  function WebXRManagedOutputCanvasOptions() {}\n  /**\n   * Get the default values of the configuration object\n   * @param engine defines the engine to use (can be null)\n   * @returns default values of this configuration object\n   */\n\n\n  WebXRManagedOutputCanvasOptions.GetDefaults = function (engine) {\n    var defaults = new WebXRManagedOutputCanvasOptions();\n    defaults.canvasOptions = {\n      antialias: true,\n      depth: true,\n      stencil: engine ? engine.isStencilEnable : true,\n      alpha: true,\n      multiview: false,\n      framebufferScaleFactor: 1\n    };\n    defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\n    return defaults;\n  };\n\n  return WebXRManagedOutputCanvasOptions;\n}();\n\nexport { WebXRManagedOutputCanvasOptions };\n/**\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\n */\n\nvar WebXRManagedOutputCanvas =\n/** @class */\nfunction () {\n  /**\n   * Initializes the canvas to be added/removed upon entering/exiting xr\n   * @param _xrSessionManager The XR Session manager\n   * @param _options optional configuration for this canvas output. defaults will be used if not provided\n   */\n  function WebXRManagedOutputCanvas(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = WebXRManagedOutputCanvasOptions.GetDefaults();\n    }\n\n    var _this = this;\n\n    this._options = _options;\n    this._canvas = null;\n    this._engine = null;\n    /**\n     * xr layer for the canvas\n     */\n\n    this.xrLayer = null;\n    this._xrLayerWrapper = null;\n    /**\n     * Observers registered here will be triggered when the xr layer was initialized\n     */\n\n    this.onXRLayerInitObservable = new Observable();\n    this._engine = _xrSessionManager.scene.getEngine();\n\n    this._engine.onDisposeObservable.addOnce(function () {\n      _this._engine = null;\n    });\n\n    if (!_options.canvasElement) {\n      var canvas = document.createElement(\"canvas\");\n      canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\n\n      this._setManagedOutputCanvas(canvas);\n    } else {\n      this._setManagedOutputCanvas(_options.canvasElement);\n    }\n\n    _xrSessionManager.onXRSessionInit.add(function () {\n      _this._addCanvas();\n    });\n\n    _xrSessionManager.onXRSessionEnded.add(function () {\n      _this._removeCanvas();\n    });\n  }\n  /**\n   * Disposes of the object\n   */\n\n\n  WebXRManagedOutputCanvas.prototype.dispose = function () {\n    this._removeCanvas();\n\n    this._setManagedOutputCanvas(null);\n  };\n  /**\n   * Initializes a XRWebGLLayer to be used as the session's baseLayer.\n   * @param xrSession xr session\n   * @returns a promise that will resolve once the XR Layer has been created\n   */\n\n\n  WebXRManagedOutputCanvas.prototype.initializeXRLayerAsync = function (xrSession) {\n    return __awaiter(this, void 0, void 0, function () {\n      var createLayer;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        createLayer = function createLayer() {\n          _this.xrLayer = new XRWebGLLayer(xrSession, _this.canvasContext, _this._options.canvasOptions);\n          _this._xrLayerWrapper = new WebXRWebGLLayerWrapper(_this.xrLayer);\n\n          _this.onXRLayerInitObservable.notifyObservers(_this.xrLayer);\n\n          return _this.xrLayer;\n        }; // support canvases without makeXRCompatible\n\n\n        if (!this.canvasContext.makeXRCompatible) {\n          return [2\n          /*return*/\n          , Promise.resolve(createLayer())];\n        }\n\n        return [2\n        /*return*/\n        , this.canvasContext.makeXRCompatible().then( // catch any error and continue. When using the emulator is throws this error for no apparent reason.\n        function () {}, function () {\n          // log the error, continue nonetheless!\n          Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\n        }).then(function () {\n          return createLayer();\n        })];\n      });\n    });\n  };\n\n  WebXRManagedOutputCanvas.prototype._addCanvas = function () {\n    var _this = this;\n\n    if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.appendChild(this._canvas);\n    }\n\n    if (this.xrLayer) {\n      this._setCanvasSize(true);\n    } else {\n      this.onXRLayerInitObservable.addOnce(function () {\n        _this._setCanvasSize(true);\n      });\n    }\n  };\n\n  WebXRManagedOutputCanvas.prototype._removeCanvas = function () {\n    if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.removeChild(this._canvas);\n    }\n\n    this._setCanvasSize(false);\n  };\n\n  WebXRManagedOutputCanvas.prototype._setCanvasSize = function (init, xrLayer) {\n    if (init === void 0) {\n      init = true;\n    }\n\n    if (xrLayer === void 0) {\n      xrLayer = this._xrLayerWrapper;\n    }\n\n    if (!this._canvas || !this._engine) {\n      return;\n    }\n\n    if (init) {\n      if (xrLayer) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = xrLayer.getWidth() + \"px\";\n          this._canvas.style.height = xrLayer.getHeight() + \"px\";\n        } else {\n          this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\n        }\n      }\n    } else {\n      if (this._originalCanvasSize) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = this._originalCanvasSize.width + \"px\";\n          this._canvas.style.height = this._originalCanvasSize.height + \"px\";\n        } else {\n          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\n        }\n      }\n    }\n  };\n\n  WebXRManagedOutputCanvas.prototype._setManagedOutputCanvas = function (canvas) {\n    this._removeCanvas();\n\n    if (!canvas) {\n      this._canvas = null;\n      this.canvasContext = null;\n    } else {\n      this._originalCanvasSize = {\n        width: canvas.offsetWidth,\n        height: canvas.offsetHeight\n      };\n      this._canvas = canvas;\n      this.canvasContext = this._canvas.getContext(\"webgl2\");\n\n      if (!this.canvasContext) {\n        this.canvasContext = this._canvas.getContext(\"webgl\");\n      }\n    }\n  };\n\n  return WebXRManagedOutputCanvas;\n}();\n\nexport { WebXRManagedOutputCanvas };","map":{"version":3,"mappings":"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","names":["Observable","Tools","WebXRWebGLLayerWrapper","WebXRManagedOutputCanvasOptions","engine","defaults","canvasOptions","antialias","depth","stencil","isStencilEnable","alpha","multiview","framebufferScaleFactor","newCanvasCssStyle","_xrSessionManager","_options","GetDefaults","_engine","scene","getEngine","onDisposeObservable","addOnce","_this","canvasElement","canvas","document","createElement","style","cssText","_setManagedOutputCanvas","onXRSessionInit","add","_addCanvas","onXRSessionEnded","_removeCanvas","WebXRManagedOutputCanvas","xrSession","createLayer","xrLayer","XRWebGLLayer","canvasContext","_xrLayerWrapper","onXRLayerInitObservable","notifyObservers","makeXRCompatible","Promise","resolve","then","Warn","_canvas","getRenderingCanvas","body","appendChild","_setCanvasSize","contains","removeChild","init","width","getWidth","height","getHeight","setSize","_originalCanvasSize","offsetWidth","offsetHeight","getContext"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRManagedOutputCanvas.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            multiview: false,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<ThinEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            return Promise.resolve(createLayer());\r\n        }\r\n\r\n        return (this.canvasContext as any)\r\n            .makeXRCompatible()\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {\r\n                    // log the error, continue nonetheless!\r\n                    Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                }\r\n            )\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}