{"ast":null,"code":"import \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { __assign } from \"tslib\";\nimport { ThinEngine } from \"../../Engines/thinEngine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\n\nThinEngine.prototype._createDepthStencilCubeTexture = function (size, options, rtWrapper) {\n  var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.isCube = true;\n\n  if (this.webGLVersion === 1) {\n    Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\n    return internalTexture;\n  }\n\n  var internalOptions = __assign({\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false\n  }, options);\n\n  var gl = this._gl;\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\n\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\n\n  rtWrapper._depthStencilTexture = internalTexture;\n  rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil; // Create the depth/stencil buffer\n\n  for (var face = 0; face < 6; face++) {\n    if (internalOptions.generateStencil) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\n    }\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  this._internalTexturesCache.push(internalTexture);\n\n  return internalTexture;\n};\n\nThinEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var onload = function onload(data) {\n    loadedFiles[index] = data;\n    loadedFiles._internalCount++;\n\n    if (loadedFiles._internalCount === 6) {\n      onfinish(loadedFiles);\n    }\n  };\n\n  var onerror = function onerror(request, exception) {\n    if (onErrorCallBack && request) {\n      onErrorCallBack(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  this._loadFile(url, onload, undefined, undefined, true, onerror);\n};\n\nThinEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedFiles = [];\n  loadedFiles._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\n  }\n};\n\nThinEngine.prototype._cascadeLoadImgs = function (scene, texture, onfinish, files, onError, mimeType) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedImages = [];\n  loadedImages._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\n  }\n};\n\nThinEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, texture, onfinish, onErrorCallBack, mimeType) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var tokenPendingData = RandomGUID();\n\n  var onload = function onload(img) {\n    loadedImages[index] = img;\n    loadedImages._internalCount++;\n\n    if (scene) {\n      scene._removePendingData(tokenPendingData);\n    }\n\n    if (loadedImages._internalCount === 6 && onfinish) {\n      onfinish(texture, loadedImages);\n    }\n  };\n\n  var onerror = function onerror(message, exception) {\n    if (scene) {\n      scene._removePendingData(tokenPendingData);\n    }\n\n    if (onErrorCallBack) {\n      onErrorCallBack(message, exception);\n    }\n  };\n\n  LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\n\n  if (scene) {\n    scene._addPendingData(tokenPendingData);\n  }\n};\n\nThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  var gl = this._gl;\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  texture.samplingMode = loadMipmap ? 3 : 2;\n\n  if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\n    texture._maxLodLevel = maxLevel;\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n};\n\nThinEngine.prototype.createCubeTextureBase = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = false;\n  }\n\n  if (lodScale === void 0) {\n    lodScale = 0;\n  }\n\n  if (lodOffset === void 0) {\n    lodOffset = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = null;\n  }\n\n  if (beforeLoadCubeDataCallback === void 0) {\n    beforeLoadCubeDataCallback = null;\n  }\n\n  if (imageHandler === void 0) {\n    imageHandler = null;\n  }\n\n  if (useSRGBBuffer === void 0) {\n    useSRGBBuffer = false;\n  }\n\n  var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n  texture.isCube = true;\n  texture.url = rootUrl;\n  texture.generateMipMaps = !noMipmap;\n  texture._lodGenerationScale = lodScale;\n  texture._lodGenerationOffset = lodOffset;\n  texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\n\n  if (!this._doNotHandleContextLost) {\n    texture._extension = forcedExtension;\n    texture._files = files;\n  }\n\n  var originalRootUrl = rootUrl;\n\n  if (this._transformTextureUrl && !fallback) {\n    rootUrl = this._transformTextureUrl(rootUrl);\n  }\n\n  var lastDot = rootUrl.lastIndexOf(\".\");\n  var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n  var loader = null;\n\n  for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {\n    var availableLoader = _a[_i];\n\n    if (availableLoader.canLoad(extension)) {\n      loader = availableLoader;\n      break;\n    }\n  }\n\n  var onInternalError = function onInternalError(request, exception) {\n    if (rootUrl === originalRootUrl) {\n      if (onError && request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    } else {\n      // fall back to the original url if the transformed url fails to load\n      Logger.Warn(\"Failed to load \".concat(rootUrl, \", falling back to the \").concat(originalRootUrl));\n\n      _this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);\n    }\n  };\n\n  if (loader) {\n    var onloaddata_1 = function onloaddata_1(data) {\n      if (beforeLoadCubeDataCallback) {\n        beforeLoadCubeDataCallback(texture, data);\n      }\n\n      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\n    };\n\n    if (files && files.length === 6) {\n      if (loader.supportCascades) {\n        this._cascadeLoadFiles(scene, function (images) {\n          return onloaddata_1(images.map(function (image) {\n            return new Uint8Array(image);\n          }));\n        }, files, onError);\n      } else {\n        if (onError) {\n          onError(\"Textures type does not support cascades.\");\n        } else {\n          Logger.Warn(\"Texture loader does not support cascades.\");\n        }\n      }\n    } else {\n      this._loadFile(rootUrl, function (data) {\n        return onloaddata_1(new Uint8Array(data));\n      }, undefined, undefined, true, onInternalError);\n    }\n  } else {\n    if (!files) {\n      throw new Error(\"Cannot load cubemap because files were not defined\");\n    }\n\n    this._cascadeLoadImgs(scene, texture, function (texture, imgs) {\n      if (imageHandler) {\n        imageHandler(texture, imgs);\n      }\n    }, files, onError);\n  }\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, loaderOptions, useSRGBBuffer) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = false;\n  }\n\n  if (lodScale === void 0) {\n    lodScale = 0;\n  }\n\n  if (lodOffset === void 0) {\n    lodOffset = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = null;\n  }\n\n  if (useSRGBBuffer === void 0) {\n    useSRGBBuffer = false;\n  }\n\n  var gl = this._gl;\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, function (texture) {\n    return _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n  }, function (texture, imgs) {\n    var width = _this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize) : imgs[0].width;\n    var height = width;\n    var faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\n    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n    _this._unpackFlipY(false);\n\n    var internalFormat = format ? _this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;\n    var texelFormat = format ? _this._getInternalFormat(format) : gl.RGBA;\n\n    if (texture._useSRGBBuffer && _this.webGLVersion === 1) {\n      texelFormat = internalFormat;\n    }\n\n    for (var index = 0; index < faces.length; index++) {\n      if (imgs[index].width !== width || imgs[index].height !== height) {\n        _this._prepareWorkingCanvas();\n\n        if (!_this._workingCanvas || !_this._workingContext) {\n          Logger.Warn(\"Cannot create canvas to resize texture.\");\n          return;\n        }\n\n        _this._workingCanvas.width = width;\n        _this._workingCanvas.height = height;\n\n        _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);\n      } else {\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\n      }\n    }\n\n    if (!noMipmap) {\n      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n    }\n\n    _this._setCubeMapTextureParams(texture, !noMipmap);\n\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n\n    if (format) {\n      texture.format = format;\n    }\n\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};","map":{"version":3,"mappings":"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","names":["ThinEngine","InternalTexture","InternalTextureSource","Logger","LoadImage","RandomGUID","prototype","_createDepthStencilCubeTexture","size","options","rtWrapper","internalTexture","DepthStencil","isCube","webGLVersion","Error","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","gl","_gl","_bindTextureDirectly","TEXTURE_CUBE_MAP","_setupDepthStencilTexture","_depthStencilTexture","_depthStencilTextureWithStencil","face","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","DEPTH24_STENCIL8","DEPTH_STENCIL","UNSIGNED_INT_24_8","DEPTH_COMPONENT24","DEPTH_COMPONENT","UNSIGNED_INT","_internalTexturesCache","push","_partialLoadFile","url","index","loadedFiles","onfinish","onErrorCallBack","onload","data","_internalCount","onerror","request","exception","status","statusText","_loadFile","undefined","_cascadeLoadFiles","scene","files","onError","_cascadeLoadImgs","texture","mimeType","loadedImages","_partialLoadImg","tokenPendingData","img","_removePendingData","message","offlineProvider","_addPendingData","_setCubeMapTextureParams","loadMipmap","maxLevel","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","samplingMode","getCaps","textureMaxLevel","TEXTURE_MAX_LEVEL","_maxLodLevel","createCubeTextureBase","rootUrl","noMipmap","onLoad","format","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","beforeLoadCubeDataCallback","imageHandler","useSRGBBuffer","Cube","generateMipMaps","_lodGenerationScale","_lodGenerationOffset","_useSRGBBuffer","_caps","supportSRGBBuffers","isWebGPU","_doNotHandleContextLost","_extension","_files","originalRootUrl","_transformTextureUrl","lastDot","lastIndexOf","extension","substring","toLowerCase","loader","_TextureLoaders","_i","availableLoader","canLoad","onInternalError","Warn","concat","_this","onloaddata_1","loadCubeData","length","supportCascades","images","map","image","Uint8Array","imgs","createCubeTexture","loaderOptions","width","needPOTTextures","GetExponentOfTwo","maxCubemapTextureSize","height","faces","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","_unpackFlipY","internalFormat","_getInternalFormat","SRGB8_ALPHA8","RGBA","texelFormat","_prepareWorkingCanvas","_workingCanvas","_workingContext","drawImage","UNSIGNED_BYTE","generateMipmap","isReady","onLoadedObservable","notifyObservers","clear"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.cubeTexture.ts"],"sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { IInternalTextureLoader } from \"../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @param rtWrapper The render target wrapper for which the depth/stencil texture must be created\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @hidden */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /** @hidden */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @hidden */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * @hidden\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n    rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene._removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene._removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene._addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const lastDot = rootUrl.lastIndexOf(\".\");\r\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (const availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            if (beforeLoadCubeDataCallback) {\r\n                beforeLoadCubeDataCallback(texture, data);\r\n            }\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            } else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        } else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    } else {\r\n        if (!files) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n"]},"metadata":{},"sourceType":"module"}