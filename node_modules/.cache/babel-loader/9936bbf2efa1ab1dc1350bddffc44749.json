{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\n\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\n\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(function (resolve) {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(function (module) {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\n\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {\n  var buffer = new decoderModule.DecoderBuffer();\n  buffer.Init(dataView, dataView.byteLength);\n  var decoder = new decoderModule.Decoder();\n  var geometry;\n  var status;\n\n  try {\n    var type = decoder.GetEncodedGeometryType(buffer);\n\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        geometry = new decoderModule.Mesh();\n        status = decoder.DecodeBufferToMesh(buffer, geometry);\n        break;\n\n      case decoderModule.POINT_CLOUD:\n        geometry = new decoderModule.PointCloud();\n        status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type \".concat(type));\n    }\n\n    if (!status.ok() || !geometry.ptr) {\n      throw new Error(status.error_msg());\n    }\n\n    if (type === decoderModule.TRIANGULAR_MESH) {\n      var numFaces = geometry.num_faces();\n      var numIndices = numFaces * 3;\n      var byteLength = numIndices * 4;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n        var indices = new Uint32Array(numIndices);\n        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n        onIndicesData(indices);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    }\n\n    var processAttribute = function processAttribute(kind, attribute, divider) {\n      if (divider === void 0) {\n        divider = 1;\n      }\n\n      var numComponents = attribute.num_components();\n      var numPoints = geometry.num_points();\n      var numValues = numPoints * numComponents;\n      var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n\n        if (kind === \"color\" && numComponents === 3) {\n          var babylonData = new Float32Array(numPoints * 4);\n\n          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n            babylonData[i + 0] = values[j + 0];\n            babylonData[i + 1] = values[j + 1];\n            babylonData[i + 2] = values[j + 2];\n            babylonData[i + 3] = 1;\n          }\n\n          onAttributeData(kind, babylonData);\n        } else {\n          var babylonData = new Float32Array(numValues);\n          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n\n          if (divider !== 1) {\n            for (var i = 0; i < babylonData.length; i++) {\n              babylonData[i] = babylonData[i] / divider;\n            }\n          }\n\n          onAttributeData(kind, babylonData);\n        }\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n\n    if (attributes) {\n      for (var kind in attributes) {\n        var id = attributes[kind];\n        var attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        var divider = dividers && dividers[kind] || 1;\n        processAttribute(kind, attribute, divider);\n      }\n    } else {\n      var nativeAttributeTypes = {\n        position: \"POSITION\",\n        normal: \"NORMAL\",\n        color: \"COLOR\",\n        uv: \"TEX_COORD\"\n      };\n\n      for (var kind in nativeAttributeTypes) {\n        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n\n        if (id !== -1) {\n          var attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(kind, attribute);\n        }\n      }\n    }\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(buffer);\n  }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\n\n\nfunction worker() {\n  var decoderPromise;\n\n  onmessage = function onmessage(event) {\n    var data = event.data;\n\n    switch (data.id) {\n      case \"init\":\n        {\n          var decoder = data.decoder;\n\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n\n          postMessage(\"done\");\n          break;\n        }\n\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n\n          decoderPromise.then(function (decoder) {\n            decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\n              postMessage({\n                id: \"indices\",\n                value: indices\n              }, [indices.buffer]);\n            }, function (kind, data) {\n              postMessage({\n                id: kind,\n                value: data\n              }, [data.buffer]);\n            });\n            postMessage(\"done\");\n          });\n          break;\n        }\n    }\n  };\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\n * ```javascript\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\n * ```\n *\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\n */\n\n\nvar DracoCompression =\n/** @class */\nfunction () {\n  /**\n   * Constructor\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  function DracoCompression(numWorkers) {\n    if (numWorkers === void 0) {\n      numWorkers = DracoCompression.DefaultNumWorkers;\n    }\n\n    var decoder = DracoCompression.Configuration.decoder;\n    var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && (typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === \"object\" ? {\n      url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\n      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl))\n    } : {\n      url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n\n    if (numWorkers && typeof Worker === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        var workerContent = \"\".concat(decodeMesh, \"(\").concat(worker, \")()\");\n        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        return new AutoReleaseWorkerPool(numWorkers, function () {\n          return new Promise(function (resolve, reject) {\n            var worker = new Worker(workerBlobUrl);\n\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: decoderInfo.url,\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n\n        return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n\n  Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\n    /**\n     * Returns true if the decoder configuration is available.\n     */\n    get: function get() {\n      var decoder = DracoCompression.Configuration.decoder;\n      return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && (typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === \"object\" || decoder.fallbackUrl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DracoCompression.GetDefaultNumWorkers = function () {\n    if ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    } // Use 50% of the available logical processors but capped at 4.\n\n\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  };\n\n  Object.defineProperty(DracoCompression, \"Default\", {\n    /**\n     * Default instance for the draco compression object.\n     */\n    get: function get() {\n      if (!DracoCompression._Default) {\n        DracoCompression._Default = new DracoCompression();\n      }\n\n      return DracoCompression._Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Stop all async operations and release resources.\n   */\n\n  DracoCompression.prototype.dispose = function () {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(function (workerPool) {\n        workerPool.dispose();\n      });\n    }\n\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  };\n  /**\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n   * @returns a promise that resolves when ready\n   */\n\n\n  DracoCompression.prototype.whenReadyAsync = function () {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function () {});\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function () {});\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Decode Draco compressed mesh data to vertex data.\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @param dividers a list of optional dividers for normalization\n   * @returns A promise that resolves with the decoded vertex data\n   */\n\n\n  DracoCompression.prototype.decodeMeshAsync = function (data, attributes, dividers) {\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function (workerPool) {\n        return new Promise(function (resolve, reject) {\n          workerPool.push(function (worker, onComplete) {\n            var vertexData = new VertexData();\n\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(vertexData);\n                onComplete();\n              } else if (message.data.id === \"indices\") {\n                vertexData.indices = message.data.value;\n              } else {\n                // check normalization\n                var divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\n\n                if (divider !== 1) {\n                  // normalize\n                  for (var i = 0; i < message.data.value.length; i++) {\n                    message.data.value[i] = message.data.value[i] / divider;\n                  }\n                }\n\n                vertexData.set(message.data.value, message.data.id);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            var dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function (decoder) {\n        var vertexData = new VertexData();\n        decodeMesh(decoder.module, dataView, attributes, function (indices) {\n          vertexData.indices = indices;\n        }, function (kind, data) {\n          vertexData.set(data, kind);\n        }, dividers);\n        return vertexData;\n      });\n    }\n\n    throw new Error(\"Draco decoder module is not available\");\n  };\n  /**\n   * The configuration. Defaults to the following urls:\n   * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n   * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\n   * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n   */\n\n\n  DracoCompression.Configuration = {\n    decoder: {\n      wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n      wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n      fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n    }\n  };\n  /**\n   * Default number of workers to create when creating the draco compression object.\n   */\n\n  DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\n  DracoCompression._Default = null;\n  return DracoCompression;\n}();\n\nexport { DracoCompression };","map":{"version":3,"mappings":"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","names":["Tools","AutoReleaseWorkerPool","VertexData","createDecoderAsync","wasmBinary","Promise","resolve","DracoDecoderModule","then","module","decodeMesh","decoderModule","dataView","attributes","onIndicesData","onAttributeData","dividers","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","geometry","status","type","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","error_msg","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","indices","Uint32Array","set","HEAPF32","_free","processAttribute","kind","attribute","divider","numComponents","num_components","numPoints","num_points","numValues","Float32Array","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","DT_FLOAT32","values","babylonData","i","j","length","id","GetAttributeByUniqueId","nativeAttributeTypes","position","normal","color","uv","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","data","url","importScripts","postMessage","value","numWorkers","DracoCompression","DefaultNumWorkers","Configuration","decoderInfo","wasmUrl","wasmBinaryUrl","WebAssembly","GetAbsoluteUrl","wasmBinaryPromise","LoadFileAsync","fallbackUrl","undefined","Worker","_workerPoolPromise","decoderWasmBinary","workerContent","concat","workerBlobUrl","URL","createObjectURL","Blob","reject","onError","error","removeEventListener","onMessage","message","addEventListener","_decoderModulePromise","LoadScriptAsync","Object","navigator","hardwareConcurrency","Math","min","floor","_Default","workerPool","dispose","ArrayBuffer","Uint8Array","push","onComplete","vertexData","dataViewCopy","byteOffset","GetDefaultNumWorkers"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Compression/dracoCompression.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\n\r\ndeclare let DracoDecoderModule: any;\r\ndeclare let WebAssembly: any;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<any> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module: any) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(\r\n    decoderModule: any,\r\n    dataView: ArrayBufferView,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (data: Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: Float32Array) => void,\r\n    dividers?: { [kind: string]: number }\r\n): void {\r\n    const buffer = new decoderModule.DecoderBuffer();\r\n    buffer.Init(dataView, dataView.byteLength);\r\n\r\n    const decoder = new decoderModule.Decoder();\r\n    let geometry: any;\r\n    let status: any;\r\n\r\n    try {\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH:\r\n                geometry = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\r\n                break;\r\n            case decoderModule.POINT_CLOUD:\r\n                geometry = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n        }\r\n\r\n        if (!status.ok() || !geometry.ptr) {\r\n            throw new Error(status.error_msg());\r\n        }\r\n\r\n        if (type === decoderModule.TRIANGULAR_MESH) {\r\n            const numFaces = geometry.num_faces();\r\n            const numIndices = numFaces * 3;\r\n            const byteLength = numIndices * 4;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\r\n                const indices = new Uint32Array(numIndices);\r\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                onIndicesData(indices);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        }\r\n\r\n        const processAttribute = (kind: string, attribute: any, divider = 1) => {\r\n            const numComponents = attribute.num_components();\r\n            const numPoints = geometry.num_points();\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\r\n                const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\r\n                if (kind === \"color\" && numComponents === 3) {\r\n                    const babylonData = new Float32Array(numPoints * 4);\r\n                    for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\r\n                        babylonData[i + 0] = values[j + 0];\r\n                        babylonData[i + 1] = values[j + 1];\r\n                        babylonData[i + 2] = values[j + 2];\r\n                        babylonData[i + 3] = 1;\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                } else {\r\n                    const babylonData = new Float32Array(numValues);\r\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\r\n                    if (divider !== 1) {\r\n                        for (let i = 0; i < babylonData.length; i++) {\r\n                            babylonData[i] = babylonData[i] / divider;\r\n                        }\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                const divider = (dividers && dividers[kind]) || 1;\r\n                processAttribute(kind, attribute, divider);\r\n            }\r\n        } else {\r\n            const nativeAttributeTypes: { [kind: string]: string } = {\r\n                position: \"POSITION\",\r\n                normal: \"NORMAL\",\r\n                color: \"COLOR\",\r\n                uv: \"TEX_COORD\",\r\n            };\r\n\r\n            for (const kind in nativeAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(kind, attribute);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        decoderModule.destroy(decoder);\r\n        decoderModule.destroy(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const data = event.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                const decoder = data.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage(\"done\");\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    decodeMesh(\r\n                        decoder,\r\n                        data.dataView,\r\n                        data.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data) => {\r\n                            postMessage({ id: kind, value: data }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage(\"done\");\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\",\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\r\n                      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl)),\r\n                  }\r\n                : {\r\n                      url: Tools.GetAbsoluteUrl(decoder.fallbackUrl!),\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n\r\n        if (numWorkers && typeof Worker === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numWorkers, () => {\r\n                    return new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: decoderInfo.url,\r\n                                wasmBinary: decoderWasmBinary,\r\n                            },\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        } else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => {});\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => {});\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param dividers a list of optional dividers for normalization\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }, dividers?: { [kind: string]: number }): Promise<VertexData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<VertexData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const vertexData = new VertexData();\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(vertexData);\r\n                                onComplete();\r\n                            } else if (message.data.id === \"indices\") {\r\n                                vertexData.indices = message.data.value;\r\n                            } else {\r\n                                // check normalization\r\n                                const divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\r\n                                if (divider !== 1) {\r\n                                    // normalize\r\n                                    for (let i = 0; i < message.data.value.length; i++) {\r\n                                        message.data.value[i] = message.data.value[i] / divider;\r\n                                    }\r\n                                }\r\n                                vertexData.set(message.data.value, message.data.id);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                const vertexData = new VertexData();\r\n                decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        vertexData.indices = indices;\r\n                    },\r\n                    (kind, data) => {\r\n                        vertexData.set(data, kind);\r\n                    },\r\n                    dividers\r\n                );\r\n                return vertexData;\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}