{"ast":null,"code":"import _typeof from \"/home/ea/Development/Babylon/red/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess.js\";\nimport { Logger } from \"./logger.js\";\nimport { Tools } from \"./tools.js\";\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback defines the callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param forceDownload force the system to download the image even if a successCallback is provided\n */\n\nexport function CreateScreenshot(engine, camera, size, successCallback, mimeType, forceDownload) {\n  if (mimeType === void 0) {\n    mimeType = \"image/png\";\n  }\n\n  if (forceDownload === void 0) {\n    forceDownload = false;\n  }\n\n  var _a = _GetScreenshotSize(engine, camera, size),\n      height = _a.height,\n      width = _a.width;\n\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n\n  if (!Tools._ScreenshotCanvas) {\n    Tools._ScreenshotCanvas = document.createElement(\"canvas\");\n  }\n\n  Tools._ScreenshotCanvas.width = width;\n  Tools._ScreenshotCanvas.height = height;\n\n  var renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\n\n  var ratio = engine.getRenderWidth() / engine.getRenderHeight();\n  var newWidth = width;\n  var newHeight = newWidth / ratio;\n\n  if (newHeight > height) {\n    newHeight = height;\n    newWidth = newHeight * ratio;\n  }\n\n  var offsetX = Math.max(0, width - newWidth) / 2;\n  var offsetY = Math.max(0, height - newHeight) / 2;\n  engine.onEndFrameObservable.addOnce(function () {\n    var renderingCanvas = engine.getRenderingCanvas();\n\n    if (renderContext && renderingCanvas) {\n      renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n    }\n\n    if (forceDownload) {\n      Tools.EncodeScreenshotCanvasData(undefined, mimeType);\n\n      if (successCallback) {\n        successCallback(\"\");\n      }\n    } else {\n      Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\n    }\n  });\n}\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\n\nexport function CreateScreenshotAsync(engine, camera, size, mimeType) {\n  if (mimeType === void 0) {\n    mimeType = \"image/png\";\n  }\n\n  return new Promise(function (resolve, reject) {\n    CreateScreenshot(engine, camera, size, function (data) {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType);\n  });\n}\n/**\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param width defines the expected width\n * @param height defines the expected height\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\n\nexport function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType) {\n  if (mimeType === void 0) {\n    mimeType = \"image/png\";\n  }\n\n  return new Promise(function (resolve) {\n    CreateScreenshot(engine, camera, {\n      width: width,\n      height: height\n    }, function () {\n      resolve();\n    }, mimeType, true);\n  });\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback The callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n */\n\nexport function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer) {\n  if (mimeType === void 0) {\n    mimeType = \"image/png\";\n  }\n\n  if (samples === void 0) {\n    samples = 1;\n  }\n\n  if (antialiasing === void 0) {\n    antialiasing = false;\n  }\n\n  if (renderSprites === void 0) {\n    renderSprites = false;\n  }\n\n  if (enableStencilBuffer === void 0) {\n    enableStencilBuffer = false;\n  }\n\n  var _a = _GetScreenshotSize(engine, camera, size),\n      height = _a.height,\n      width = _a.width;\n\n  var targetTextureSize = {\n    width: width,\n    height: height\n  };\n\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n\n  var scene = camera.getScene();\n  var previousCamera = null;\n  var previousCameras = scene.activeCameras;\n  scene.activeCameras = null;\n\n  if (scene.activeCamera !== camera) {\n    previousCamera = scene.activeCamera;\n    scene.activeCamera = camera;\n  }\n\n  scene.render(); // make sure the scene is ready to be rendered in the RTT with the right list of active meshes (which depends on the camera, that may have been changed above)\n  // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n\n  var texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);\n  texture.renderList = null;\n  texture.samples = samples;\n  texture.renderSprites = renderSprites;\n\n  var renderToTexture = function renderToTexture() {\n    engine.onEndFrameObservable.addOnce(function () {\n      texture.readPixels(undefined, undefined, undefined, false).then(function (data) {\n        Tools.DumpData(width, height, data, successCallback, mimeType, fileName, true);\n        texture.dispose();\n      });\n    }); // render the RTT\n\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    texture.render(true); // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\n    // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\n\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n\n    if (previousCamera) {\n      scene.activeCamera = previousCamera;\n    }\n\n    scene.activeCameras = previousCameras;\n    camera.getProjectionMatrix(true); // Force cache refresh;\n\n    scene.render();\n  };\n\n  if (antialiasing) {\n    var fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\n    texture.addPostProcess(fxaaPostProcess); // Async Shader Compilation can lead to none ready effects in synchronous code\n\n    if (!fxaaPostProcess.getEffect().isReady()) {\n      fxaaPostProcess.getEffect().onCompiled = function () {\n        renderToTexture();\n      };\n    } // The effect is ready we can render\n    else {\n      renderToTexture();\n    }\n  } else {\n    // No need to wait for extra resources to be ready\n    renderToTexture();\n  }\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\n\nexport function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType, samples, antialiasing, fileName, renderSprites) {\n  if (mimeType === void 0) {\n    mimeType = \"image/png\";\n  }\n\n  if (samples === void 0) {\n    samples = 1;\n  }\n\n  if (antialiasing === void 0) {\n    antialiasing = false;\n  }\n\n  if (renderSprites === void 0) {\n    renderSprites = false;\n  }\n\n  return new Promise(function (resolve, reject) {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, function (data) {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, samples, antialiasing, fileName, renderSprites);\n  });\n}\n/**\n * Gets height and width for screenshot size\n * @param engine\n * @param camera\n * @param size\n * @private\n */\n\nfunction _GetScreenshotSize(engine, camera, size) {\n  var height = 0;\n  var width = 0; //If a size value defined as object\n\n  if (_typeof(size) === \"object\") {\n    var precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n    : 1; //If a width and height values is specified\n\n    if (size.width && size.height) {\n      height = size.height * precision;\n      width = size.width * precision;\n    } //If passing only width, computing height to keep display canvas ratio.\n    else if (size.width && !size.height) {\n      width = size.width * precision;\n      height = Math.round(width / engine.getAspectRatio(camera));\n    } //If passing only height, computing width to keep display canvas ratio.\n    else if (size.height && !size.width) {\n      height = size.height * precision;\n      width = Math.round(height * engine.getAspectRatio(camera));\n    } else {\n      width = Math.round(engine.getRenderWidth() * precision);\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n  } //Assuming here that \"size\" parameter is a number\n  else if (!isNaN(size)) {\n    height = size;\n    width = size;\n  } // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n  // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n  // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n  // to resolve this, we truncate the floats here to ensure the same size\n\n\n  if (width) {\n    width = Math.floor(width);\n  }\n\n  if (height) {\n    height = Math.floor(height);\n  }\n\n  return {\n    height: height | 0,\n    width: width | 0\n  };\n}\n/**\n * Class containing a set of static utilities functions for screenshots\n */\n\n\nexport var ScreenshotTools = {\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback defines the callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param forceDownload force the system to download the image even if a successCallback is provided\n   */\n  CreateScreenshot: CreateScreenshot,\n\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotAsync: CreateScreenshotAsync,\n\n  /**\n   * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param width defines the expected width\n   * @param height defines the expected height\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotWithResizeAsync: CreateScreenshotWithResizeAsync,\n\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback The callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   */\n  CreateScreenshotUsingRenderTarget: CreateScreenshotUsingRenderTarget,\n\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotUsingRenderTargetAsync: CreateScreenshotUsingRenderTargetAsync\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @hidden\n */\n\nvar initSideEffects = function initSideEffects() {\n  // References the dependencies.\n  Tools.CreateScreenshot = CreateScreenshot;\n  Tools.CreateScreenshotAsync = CreateScreenshotAsync;\n  Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\n  Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\n};\n\ninitSideEffects();","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","FxaaPostProcess","Logger","Tools","CreateScreenshot","engine","camera","size","successCallback","mimeType","forceDownload","_GetScreenshotSize","height","width","Error","_ScreenshotCanvas","document","createElement","renderContext","getContext","ratio","getRenderWidth","getRenderHeight","newWidth","newHeight","offsetX","Math","max","offsetY","onEndFrameObservable","addOnce","renderingCanvas","getRenderingCanvas","drawImage","EncodeScreenshotCanvasData","undefined","CreateScreenshotAsync","Promise","resolve","reject","data","CreateScreenshotWithResizeAsync","CreateScreenshotUsingRenderTarget","samples","antialiasing","fileName","renderSprites","enableStencilBuffer","targetTextureSize","scene","getScene","previousCamera","previousCameras","activeCameras","activeCamera","render","texture","renderList","renderToTexture","readPixels","then","DumpData","dispose","incrementRenderId","resetCachedMaterial","getProjectionMatrix","fxaaPostProcess","addPostProcess","getEffect","isReady","onCompiled","CreateScreenshotUsingRenderTargetAsync","precision","abs","round","getAspectRatio","isNaN","floor","ScreenshotTools","initSideEffects"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/screenshotTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"./logger\";\r\nimport { Tools } from \"./tools\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback defines the callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param forceDownload force the system to download the image even if a successCallback is provided\r\n */\r\nexport function CreateScreenshot(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    forceDownload = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    if (!Tools._ScreenshotCanvas) {\r\n        Tools._ScreenshotCanvas = document.createElement(\"canvas\");\r\n    }\r\n\r\n    Tools._ScreenshotCanvas.width = width;\r\n    Tools._ScreenshotCanvas.height = height;\r\n\r\n    const renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\r\n\r\n    const ratio = engine.getRenderWidth() / engine.getRenderHeight();\r\n    let newWidth = width;\r\n    let newHeight = newWidth / ratio;\r\n    if (newHeight > height) {\r\n        newHeight = height;\r\n        newWidth = newHeight * ratio;\r\n    }\r\n\r\n    const offsetX = Math.max(0, width - newWidth) / 2;\r\n    const offsetY = Math.max(0, height - newHeight) / 2;\r\n\r\n    engine.onEndFrameObservable.addOnce(() => {\r\n        const renderingCanvas = engine.getRenderingCanvas();\r\n        if (renderContext && renderingCanvas) {\r\n            renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\r\n        }\r\n\r\n        if (forceDownload) {\r\n            Tools.EncodeScreenshotCanvasData(undefined, mimeType);\r\n            if (successCallback) {\r\n                successCallback(\"\");\r\n            }\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType: string = \"image/png\"): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param width defines the expected width\r\n * @param height defines the expected height\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotWithResizeAsync(engine: Engine, camera: Camera, width: number, height: number, mimeType: string = \"image/png\"): Promise<void> {\r\n    return new Promise((resolve) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            { width: width, height: height },\r\n            () => {\r\n                resolve();\r\n            },\r\n            mimeType,\r\n            true\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback The callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n */\r\nexport function CreateScreenshotUsingRenderTarget(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false,\r\n    enableStencilBuffer: boolean = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n    const targetTextureSize = { width, height };\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    const scene = camera.getScene();\r\n    let previousCamera: Nullable<Camera> = null;\r\n    const previousCameras = scene.activeCameras;\r\n\r\n    scene.activeCameras = null;\r\n\r\n    if (scene.activeCamera !== camera) {\r\n        previousCamera = scene.activeCamera;\r\n        scene.activeCamera = camera;\r\n    }\r\n\r\n    scene.render(); // make sure the scene is ready to be rendered in the RTT with the right list of active meshes (which depends on the camera, that may have been changed above)\r\n\r\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n    const texture = new RenderTargetTexture(\r\n        \"screenShot\",\r\n        targetTextureSize,\r\n        scene,\r\n        false,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        false,\r\n        Texture.NEAREST_SAMPLINGMODE,\r\n        undefined,\r\n        enableStencilBuffer,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        samples\r\n    );\r\n    texture.renderList = null;\r\n    texture.samples = samples;\r\n    texture.renderSprites = renderSprites;\r\n\r\n    const renderToTexture = () => {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            texture.readPixels(undefined, undefined, undefined, false)!.then((data) => {\r\n                Tools.DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true);\r\n                texture.dispose();\r\n            });\r\n        });\r\n\r\n        // render the RTT\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        texture.render(true);\r\n\r\n        // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\r\n        // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        if (previousCamera) {\r\n            scene.activeCamera = previousCamera;\r\n        }\r\n        scene.activeCameras = previousCameras;\r\n        camera.getProjectionMatrix(true); // Force cache refresh;\r\n        scene.render();\r\n    };\r\n\r\n    if (antialiasing) {\r\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\r\n        texture.addPostProcess(fxaaPostProcess);\r\n        // Async Shader Compilation can lead to none ready effects in synchronous code\r\n        if (!fxaaPostProcess.getEffect().isReady()) {\r\n            fxaaPostProcess.getEffect().onCompiled = () => {\r\n                renderToTexture();\r\n            };\r\n        }\r\n        // The effect is ready we can render\r\n        else {\r\n            renderToTexture();\r\n        }\r\n    } else {\r\n        // No need to wait for extra resources to be ready\r\n        renderToTexture();\r\n    }\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotUsingRenderTargetAsync(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            samples,\r\n            antialiasing,\r\n            fileName,\r\n            renderSprites\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Gets height and width for screenshot size\r\n * @param engine\r\n * @param camera\r\n * @param size\r\n * @private\r\n */\r\nfunction _GetScreenshotSize(engine: Engine, camera: Camera, size: IScreenshotSize | number): { height: number; width: number } {\r\n    let height = 0;\r\n    let width = 0;\r\n\r\n    //If a size value defined as object\r\n    if (typeof size === \"object\") {\r\n        const precision = size.precision\r\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n            : 1;\r\n\r\n        //If a width and height values is specified\r\n        if (size.width && size.height) {\r\n            height = size.height * precision;\r\n            width = size.width * precision;\r\n        }\r\n        //If passing only width, computing height to keep display canvas ratio.\r\n        else if (size.width && !size.height) {\r\n            width = size.width * precision;\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only height, computing width to keep display canvas ratio.\r\n        else if (size.height && !size.width) {\r\n            height = size.height * precision;\r\n            width = Math.round(height * engine.getAspectRatio(camera));\r\n        } else {\r\n            width = Math.round(engine.getRenderWidth() * precision);\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n    }\r\n    //Assuming here that \"size\" parameter is a number\r\n    else if (!isNaN(size)) {\r\n        height = size;\r\n        width = size;\r\n    }\r\n\r\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n    // to resolve this, we truncate the floats here to ensure the same size\r\n    if (width) {\r\n        width = Math.floor(width);\r\n    }\r\n    if (height) {\r\n        height = Math.floor(height);\r\n    }\r\n\r\n    return { height: height | 0, width: width | 0 };\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport const ScreenshotTools = {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     */\r\n    CreateScreenshot,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotAsync,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param width defines the expected width\r\n     * @param height defines the expected height\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotWithResizeAsync,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     */\r\n    CreateScreenshotUsingRenderTarget,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotUsingRenderTargetAsync,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @hidden\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.CreateScreenshot = CreateScreenshot;\r\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\r\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\r\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\r\n};\r\n\r\ninitSideEffects();\r\n"]},"metadata":{},"sourceType":"module"}