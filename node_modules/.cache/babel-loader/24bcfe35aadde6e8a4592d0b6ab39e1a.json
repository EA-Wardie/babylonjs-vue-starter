{"ast":null,"code":"import \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { __decorate } from \"tslib\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\"; // This helper class is only here so we can apply the nativeOverride decorator to functions.\n\nvar MathHelpers =\n/** @class */\nfunction () {\n  function MathHelpers() {}\n\n  MathHelpers.extractMinAndMaxIndexed = function (positions, indices, indexStart, indexCount, minimum, maximum) {\n    for (var index = indexStart; index < indexStart + indexCount; index++) {\n      var offset = indices[index] * 3;\n      var x = positions[offset];\n      var y = positions[offset + 1];\n      var z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  };\n\n  MathHelpers.extractMinAndMax = function (positions, start, count, stride, minimum, maximum) {\n    for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n      var x = positions[offset];\n      var y = positions[offset + 1];\n      var z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  };\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var positions = _a[0],\n        indices = _a[1];\n    return !Array.isArray(positions) && !Array.isArray(indices);\n  })], MathHelpers, \"extractMinAndMaxIndexed\", null);\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var positions = _a[0];\n    return !Array.isArray(positions);\n  })], MathHelpers, \"extractMinAndMax\", null);\n\n  return MathHelpers;\n}();\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @return minimum and maximum values\n */\n\n\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {\n  if (bias === void 0) {\n    bias = null;\n  }\n\n  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @return minimum and maximum values\n */\n\nexport function extractMinAndMax(positions, start, count, bias, stride) {\n  if (bias === void 0) {\n    bias = null;\n  }\n\n  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n  if (!stride) {\n    stride = 3;\n  }\n\n  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}","map":{"version":3,"mappings":"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","names":["Vector3","nativeOverride","MathHelpers","positions","indices","indexStart","indexCount","minimum","maximum","index","offset","x","y","z","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","start","count","stride","__decorate","filter","_a","Array","isArray","extractMinAndMaxIndexed","bias","Number","MAX_VALUE","extractMinAndMax"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Maths/math.functions.ts"],"sourcesContent":["import type { FloatArray, Nullable, IndicesArray } from \"../types\";\r\nimport type { Vector2 } from \"./math.vector\";\r\nimport { Vector3 } from \"./math.vector\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\n\r\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\r\nclass MathHelpers {\r\n    @nativeOverride.filter((...[positions, indices]: Parameters<typeof MathHelpers.extractMinAndMaxIndexed>) => !Array.isArray(positions) && !Array.isArray(indices))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\r\n            const offset = indices[index] * 3;\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[positions]: Parameters<typeof MathHelpers.extractMinAndMax>) => !Array.isArray(positions))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMax(positions: FloatArray, start: number, count: number, stride: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(\r\n    positions: FloatArray,\r\n    indices: IndicesArray,\r\n    indexStart: number,\r\n    indexCount: number,\r\n    bias: Nullable<Vector2> = null\r\n): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}