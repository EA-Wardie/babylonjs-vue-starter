{"ast":null,"code":"import \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport { ComputeEffect } from \"../../../Compute/computeEffect.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { WebGPUComputeContext } from \"../webgpuComputeContext.js\";\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext.js\";\n\nWebGPUEngine.prototype.createComputeContext = function () {\n  return new WebGPUComputeContext(this._device, this._cacheSampler);\n};\n\nWebGPUEngine.prototype.createComputeEffect = function (baseName, options) {\n  var compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\n  var name = compute + \"@\" + options.defines;\n\n  if (this._compiledComputeEffects[name]) {\n    var compiledEffect = this._compiledComputeEffects[name];\n\n    if (options.onCompiled && compiledEffect.isReady()) {\n      options.onCompiled(compiledEffect);\n    }\n\n    return compiledEffect;\n  }\n\n  var effect = new ComputeEffect(baseName, options, this, name);\n  this._compiledComputeEffects[name] = effect;\n  return effect;\n};\n\nWebGPUEngine.prototype.createComputePipelineContext = function () {\n  return new WebGPUComputePipelineContext(this);\n};\n\nWebGPUEngine.prototype.areAllComputeEffectsReady = function () {\n  for (var key in this._compiledComputeEffects) {\n    var effect = this._compiledComputeEffects[key];\n\n    if (!effect.isReady()) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nWebGPUEngine.prototype.computeDispatch = function (effect, context, bindings, x, y, z, bindingsMapping) {\n  var _this = this;\n\n  if (this._currentRenderTarget) {\n    // A render target pass is currently in effect (meaning beingRenderPass has been called on the command encoder this._renderTargetEncoder): we are not allowed to open\n    // another pass on this command encoder (even if it's a compute pass) until endPass has been called, so we need to defer the compute pass for after the current render target pass is closed\n    this._onAfterUnbindFrameBufferObservable.addOnce(function () {\n      _this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);\n    });\n\n    return;\n  }\n\n  var contextPipeline = effect._pipelineContext;\n  var computeContext = context;\n\n  if (!contextPipeline.computePipeline) {\n    contextPipeline.computePipeline = this._device.createComputePipeline({\n      compute: contextPipeline.stage\n    });\n  }\n\n  var commandEncoder = this._renderTargetEncoder;\n  var computePass = commandEncoder.beginComputePass();\n  computePass.setPipeline(contextPipeline.computePipeline);\n  var bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\n\n  for (var i = 0; i < bindGroups.length; ++i) {\n    var bindGroup = bindGroups[i];\n\n    if (!bindGroup) {\n      continue;\n    }\n\n    computePass.setBindGroup(i, bindGroup);\n  }\n\n  computePass.dispatch(x, y, z);\n  computePass.end();\n};\n\nWebGPUEngine.prototype.releaseComputeEffects = function () {\n  for (var name_1 in this._compiledComputeEffects) {\n    var webGPUPipelineContextCompute = this._compiledComputeEffects[name_1].getPipelineContext();\n\n    this._deleteComputePipelineContext(webGPUPipelineContextCompute);\n  }\n\n  this._compiledComputeEffects = {};\n};\n\nWebGPUEngine.prototype._prepareComputePipelineContext = function (pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {\n  var webGpuContext = pipelineContext;\n\n  if (this.dbgShowShaderCode) {\n    console.log(defines);\n    console.log(computeSourceCode);\n  }\n\n  webGpuContext.sources = {\n    compute: computeSourceCode,\n    rawCompute: rawComputeSourceCode\n  };\n  webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\n};\n\nWebGPUEngine.prototype._releaseComputeEffect = function (effect) {\n  if (this._compiledComputeEffects[effect._key]) {\n    delete this._compiledComputeEffects[effect._key];\n\n    this._deleteComputePipelineContext(effect.getPipelineContext());\n  }\n};\n\nWebGPUEngine.prototype._rebuildComputeEffects = function () {\n  for (var key in this._compiledComputeEffects) {\n    var effect = this._compiledComputeEffects[key];\n    effect._pipelineContext = null;\n    effect._wasPreviouslyReady = false;\n\n    effect._prepareEffect();\n  }\n};\n\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext) {\n  var webgpuPipelineContext = pipelineContext;\n\n  if (webgpuPipelineContext) {\n    pipelineContext.dispose();\n  }\n};\n\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader, defines, entryPoint) {\n  if (defines) {\n    defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n  } else {\n    defines = \"\";\n  }\n\n  return {\n    module: this._device.createShaderModule({\n      code: defines + computeShader\n    }),\n    entryPoint: entryPoint\n  };\n};","map":{"version":3,"mappings":"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","names":["ComputeEffect","WebGPUEngine","WebGPUComputeContext","WebGPUComputePipelineContext","prototype","createComputeContext","_device","_cacheSampler","createComputeEffect","baseName","options","compute","computeElement","computeToken","computeSource","name","defines","_compiledComputeEffects","compiledEffect","onCompiled","isReady","effect","createComputePipelineContext","areAllComputeEffectsReady","key","computeDispatch","context","bindings","x","y","z","bindingsMapping","_currentRenderTarget","_onAfterUnbindFrameBufferObservable","addOnce","_this","contextPipeline","_pipelineContext","computeContext","computePipeline","createComputePipeline","stage","commandEncoder","_renderTargetEncoder","computePass","beginComputePass","setPipeline","bindGroups","getBindGroups","i","length","bindGroup","setBindGroup","dispatch","end","releaseComputeEffects","name_1","webGPUPipelineContextCompute","getPipelineContext","_deleteComputePipelineContext","_prepareComputePipelineContext","pipelineContext","computeSourceCode","rawComputeSourceCode","entryPoint","webGpuContext","dbgShowShaderCode","console","log","sources","rawCompute","_createComputePipelineStageDescriptor","_releaseComputeEffect","_key","_rebuildComputeEffects","_wasPreviouslyReady","_prepareEffect","webgpuPipelineContext","dispose","computeShader","split","join","module","createShaderModule","code"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.computeShader.ts"],"sourcesContent":["import type { IComputeEffectCreationOptions } from \"../../../Compute/computeEffect\";\r\nimport { ComputeEffect } from \"../../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../../Extensions/engine.computeShader\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPUComputeContext } from \"../webgpuComputeContext\";\r\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext\";\r\n\r\ndeclare module \"../../webgpuEngine\" {\r\n    export interface WebGPUEngine {\r\n        /** @hidden */\r\n        _createComputePipelineStageDescriptor(computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return new WebGPUComputeContext(this._device, this._cacheSampler);\r\n};\r\n\r\nWebGPUEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\r\n\r\n    const name = compute + \"@\" + options.defines;\r\n    if (this._compiledComputeEffects[name]) {\r\n        const compiledEffect = <ComputeEffect>this._compiledComputeEffects[name];\r\n        if (options.onCompiled && compiledEffect.isReady()) {\r\n            options.onCompiled(compiledEffect);\r\n        }\r\n\r\n        return compiledEffect;\r\n    }\r\n    const effect = new ComputeEffect(baseName, options, this, name);\r\n    this._compiledComputeEffects[name] = effect;\r\n\r\n    return effect;\r\n};\r\n\r\nWebGPUEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    return new WebGPUComputePipelineContext(this);\r\n};\r\n\r\nWebGPUEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    if (this._currentRenderTarget) {\r\n        // A render target pass is currently in effect (meaning beingRenderPass has been called on the command encoder this._renderTargetEncoder): we are not allowed to open\r\n        // another pass on this command encoder (even if it's a compute pass) until endPass has been called, so we need to defer the compute pass for after the current render target pass is closed\r\n        this._onAfterUnbindFrameBufferObservable.addOnce(() => {\r\n            this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);\r\n        });\r\n        return;\r\n    }\r\n\r\n    const contextPipeline = effect._pipelineContext as WebGPUComputePipelineContext;\r\n    const computeContext = context as WebGPUComputeContext;\r\n\r\n    if (!contextPipeline.computePipeline) {\r\n        contextPipeline.computePipeline = this._device.createComputePipeline({\r\n            compute: contextPipeline.stage!,\r\n        });\r\n    }\r\n\r\n    const commandEncoder = this._renderTargetEncoder;\r\n    const computePass = commandEncoder.beginComputePass();\r\n\r\n    computePass.setPipeline(contextPipeline.computePipeline);\r\n\r\n    const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\r\n    for (let i = 0; i < bindGroups.length; ++i) {\r\n        const bindGroup = bindGroups[i];\r\n        if (!bindGroup) {\r\n            continue;\r\n        }\r\n        computePass.setBindGroup(i, bindGroup);\r\n    }\r\n\r\n    computePass.dispatch(x, y, z);\r\n    computePass.end();\r\n};\r\n\r\nWebGPUEngine.prototype.releaseComputeEffects = function () {\r\n    for (const name in this._compiledComputeEffects) {\r\n        const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext() as WebGPUComputePipelineContext;\r\n        this._deleteComputePipelineContext(webGPUPipelineContextCompute);\r\n    }\r\n\r\n    this._compiledComputeEffects = {};\r\n};\r\n\r\nWebGPUEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {\r\n    const webGpuContext = pipelineContext as WebGPUComputePipelineContext;\r\n\r\n    if (this.dbgShowShaderCode) {\r\n        console.log(defines);\r\n        console.log(computeSourceCode);\r\n    }\r\n\r\n    webGpuContext.sources = {\r\n        compute: computeSourceCode,\r\n        rawCompute: rawComputeSourceCode,\r\n    };\r\n\r\n    webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\r\n};\r\n\r\nWebGPUEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {\r\n    if (this._compiledComputeEffects[effect._key]) {\r\n        delete this._compiledComputeEffects[effect._key];\r\n\r\n        this._deleteComputePipelineContext(effect.getPipelineContext() as WebGPUComputePipelineContext);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._rebuildComputeEffects = function (): void {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        effect._pipelineContext = null;\r\n        effect._wasPreviouslyReady = false;\r\n        effect._prepareEffect();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {\r\n    const webgpuPipelineContext = pipelineContext as WebGPUComputePipelineContext;\r\n    if (webgpuPipelineContext) {\r\n        pipelineContext.dispose();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage {\r\n    if (defines) {\r\n        defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n    } else {\r\n        defines = \"\";\r\n    }\r\n    return {\r\n        module: this._device.createShaderModule({\r\n            code: defines + computeShader,\r\n        }),\r\n        entryPoint,\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}