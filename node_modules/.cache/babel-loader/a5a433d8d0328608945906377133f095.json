{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent.js\";\nimport { Sound } from \"@babylonjs/core/Audio/sound.js\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nvar NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\n */\n\nvar MSFT_audio_emitter =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function MSFT_audio_emitter(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.dispose = function () {\n    this._loader = null;\n    this._clips = null;\n    this._emitters = null;\n  };\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._clips = extension.clips;\n      this._emitters = extension.emitters;\n      ArrayItem.Assign(this._clips);\n      ArrayItem.Assign(this._emitters);\n    }\n  };\n  /**\n   * @param context\n   * @param scene\n   * @hidden\n   */\n\n\n  MSFT_audio_emitter.prototype.loadSceneAsync = function (context, scene) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadSceneAsync(context, scene));\n\n      for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n        var emitterIndex = _a[_i];\n        var emitter = ArrayItem.Get(\"\".concat(extensionContext, \"/emitters\"), _this._emitters, emitterIndex);\n\n        if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined || emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n          throw new Error(\"\".concat(extensionContext, \": Direction or Distance properties are not allowed on emitters attached to a scene\"));\n        }\n\n        promises.push(_this._loadEmitterAsync(\"\".concat(extensionContext, \"/emitters/\").concat(emitter.index), emitter));\n      }\n\n      return Promise.all(promises).then(function () {});\n    });\n  };\n  /**\n   * @param context\n   * @param node\n   * @param assign\n   * @hidden\n   */\n\n\n  MSFT_audio_emitter.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      return _this._loader.loadNodeAsync(extensionContext, node, function (babylonMesh) {\n        var _loop_1 = function _loop_1(emitterIndex) {\n          var emitter = ArrayItem.Get(\"\".concat(extensionContext, \"/emitters\"), _this._emitters, emitterIndex);\n          promises.push(_this._loadEmitterAsync(\"\".concat(extensionContext, \"/emitters/\").concat(emitter.index), emitter).then(function () {\n            for (var _i = 0, _a = emitter._babylonSounds; _i < _a.length; _i++) {\n              var sound = _a[_i];\n              sound.attachToMesh(babylonMesh);\n\n              if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                sound.setLocalDirectionToMesh(Vector3.Forward());\n                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n              }\n            }\n          }));\n        };\n\n        for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n          var emitterIndex = _a[_i];\n\n          _loop_1(emitterIndex);\n        }\n\n        assign(babylonMesh);\n      }).then(function (babylonMesh) {\n        return Promise.all(promises).then(function () {\n          return babylonMesh;\n        });\n      });\n    });\n  };\n  /**\n   * @param context\n   * @param animation\n   * @hidden\n   */\n\n\n  MSFT_audio_emitter.prototype.loadAnimationAsync = function (context, animation) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, animation, this.name, function (extensionContext, extension) {\n      return _this._loader.loadAnimationAsync(context, animation).then(function (babylonAnimationGroup) {\n        var promises = new Array();\n        ArrayItem.Assign(extension.events);\n\n        for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {\n          var event_1 = _a[_i];\n          promises.push(_this._loadAnimationEventAsync(\"\".concat(extensionContext, \"/events/\").concat(event_1.index), context, animation, event_1, babylonAnimationGroup));\n        }\n\n        return Promise.all(promises).then(function () {\n          return babylonAnimationGroup;\n        });\n      });\n    });\n  };\n\n  MSFT_audio_emitter.prototype._loadClipAsync = function (context, clip) {\n    if (clip._objectURL) {\n      return clip._objectURL;\n    }\n\n    var promise;\n\n    if (clip.uri) {\n      promise = this._loader.loadUriAsync(context, clip, clip.uri);\n    } else {\n      var bufferView = ArrayItem.Get(\"\".concat(context, \"/bufferView\"), this._loader.gltf.bufferViews, clip.bufferView);\n      promise = this._loader.loadBufferViewAsync(\"/bufferViews/\".concat(bufferView.index), bufferView);\n    }\n\n    clip._objectURL = promise.then(function (data) {\n      return URL.createObjectURL(new Blob([data], {\n        type: clip.mimeType\n      }));\n    });\n    return clip._objectURL;\n  };\n\n  MSFT_audio_emitter.prototype._loadEmitterAsync = function (context, emitter) {\n    var _this = this;\n\n    emitter._babylonSounds = emitter._babylonSounds || [];\n\n    if (!emitter._babylonData) {\n      var clipPromises = new Array();\n      var name_1 = emitter.name || \"emitter\".concat(emitter.index);\n      var options_1 = {\n        loop: false,\n        autoplay: false,\n        volume: emitter.volume == undefined ? 1 : emitter.volume\n      };\n\n      var _loop_2 = function _loop_2(i) {\n        var clipContext = \"/extensions/\".concat(this_1.name, \"/clips\");\n        var clip = ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i].clip);\n        clipPromises.push(this_1._loadClipAsync(\"\".concat(clipContext, \"/\").concat(emitter.clips[i].clip), clip).then(function (objectURL) {\n          var sound = emitter._babylonSounds[i] = new Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);\n          sound.refDistance = emitter.refDistance || 1;\n          sound.maxDistance = emitter.maxDistance || 256;\n          sound.rolloffFactor = emitter.rolloffFactor || 1;\n          sound.distanceModel = emitter.distanceModel || \"exponential\";\n        }));\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < emitter.clips.length; i++) {\n        _loop_2(i);\n      }\n\n      var promise = Promise.all(clipPromises).then(function () {\n        var weights = emitter.clips.map(function (clip) {\n          return clip.weight || 1;\n        });\n        var weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n\n        if (emitter.innerAngle) {\n          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n        }\n\n        if (emitter.outerAngle) {\n          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n        }\n\n        if (emitter.volume) {\n          weightedSound.volume = emitter.volume;\n        }\n\n        emitter._babylonData.sound = weightedSound;\n      });\n      emitter._babylonData = {\n        loaded: promise\n      };\n    }\n\n    return emitter._babylonData.loaded;\n  };\n\n  MSFT_audio_emitter.prototype._getEventAction = function (context, sound, action, time, startOffset) {\n    switch (action) {\n      case \"play\"\n      /* play */\n      :\n        {\n          return function (currentFrame) {\n            var frameOffset = (startOffset || 0) + (currentFrame - time);\n            sound.play(frameOffset);\n          };\n        }\n\n      case \"stop\"\n      /* stop */\n      :\n        {\n          return function () {\n            sound.stop();\n          };\n        }\n\n      case \"pause\"\n      /* pause */\n      :\n        {\n          return function () {\n            sound.pause();\n          };\n        }\n\n      default:\n        {\n          throw new Error(\"\".concat(context, \": Unsupported action \").concat(action));\n        }\n    }\n  };\n\n  MSFT_audio_emitter.prototype._loadAnimationEventAsync = function (context, animationContext, animation, event, babylonAnimationGroup) {\n    var _this = this;\n\n    if (babylonAnimationGroup.targetedAnimations.length == 0) {\n      return Promise.resolve();\n    }\n\n    var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n    var emitterIndex = event.emitter;\n    var emitter = ArrayItem.Get(\"/extensions/\".concat(this.name, \"/emitters\"), this._emitters, emitterIndex);\n    return this._loadEmitterAsync(context, emitter).then(function () {\n      var sound = emitter._babylonData.sound;\n\n      if (sound) {\n        var babylonAnimationEvent = new AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n        babylonAnimation.animation.addEvent(babylonAnimationEvent); // Make sure all started audio stops when this animation is terminated.\n\n        babylonAnimationGroup.onAnimationGroupEndObservable.add(function () {\n          sound.stop();\n        });\n        babylonAnimationGroup.onAnimationGroupPauseObservable.add(function () {\n          sound.pause();\n        });\n      }\n    });\n  };\n\n  return MSFT_audio_emitter;\n}();\n\nexport { MSFT_audio_emitter };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new MSFT_audio_emitter(loader);\n});","map":{"version":3,"mappings":"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","names":["Vector3","Tools","AnimationEvent","Sound","WeightedSound","GLTFLoader","ArrayItem","NAME","loader","_loader","enabled","isExtensionUsed","MSFT_audio_emitter","_clips","_emitters","extensions","gltf","name","extension","clips","emitters","Assign","context","scene","LoadExtensionAsync","extensionContext","promises","Array","push","_this","loadSceneAsync","_i","emitterIndex","emitter","Get","refDistance","undefined","maxDistance","rolloffFactor","distanceModel","innerAngle","outerAngle","Error","_loadEmitterAsync","concat","index","Promise","all","then","node","assign","loadNodeAsync","babylonMesh","_babylonSounds","sound","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","Math","PI","animation","loadAnimationAsync","babylonAnimationGroup","events","event_1","_loadAnimationEventAsync","clip","_objectURL","promise","uri","loadUriAsync","bufferView","bufferViews","loadBufferViewAsync","data","URL","createObjectURL","Blob","type","mimeType","_babylonData","clipPromises","name_1","options_1","loop","autoplay","volume","i","clipContext","this_1","_loadClipAsync","objectURL","babylonScene","length","weights","map","weight","weightedSound","directionalConeInnerAngle","directionalConeOuterAngle","loaded","action","time","startOffset","currentFrame","frameOffset","play","stop","pause","animationContext","event","targetedAnimations","resolve","babylonAnimation","babylonAnimationEvent","_getEventAction","addEvent","onAnimationGroupEndObservable","add","onAnimationGroupPauseObservable","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/MSFT_audio_emitter.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\r\n */\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param scene\r\n     * @hidden\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param node\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            return this._loader\r\n                .loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                    for (const emitterIndex of extension.emitters) {\r\n                        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                        promises.push(\r\n                            this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                                for (const sound of emitter._babylonSounds) {\r\n                                    sound.attachToMesh(babylonMesh);\r\n                                    if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                        sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                        sound.setDirectionalCone(\r\n                                            2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                            2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                            0\r\n                                        );\r\n                                    }\r\n                                }\r\n                            })\r\n                        );\r\n                    }\r\n\r\n                    assign(babylonMesh);\r\n                })\r\n                .then((babylonMesh) => {\r\n                    return Promise.all(promises).then(() => {\r\n                        return babylonMesh;\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param animation\r\n     * @hidden\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                ArrayItem.Assign(extension.events);\r\n                for (const event of extension.events) {\r\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n                }\r\n\r\n                return Promise.all(promises).then(() => {\r\n                    return babylonAnimationGroup;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));\r\n"]},"metadata":{},"sourceType":"module"}