{"ast":null,"code":"import \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.date.to-iso-string.js\";\nimport { EventState, Observable } from \"../observable.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { Tools } from \"../tools.js\";\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array.js\"; // the initial size of our array, should be a multiple of two!\n\nvar InitialArraySize = 1800; // three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\n\nvar NumberOfBitsInHexcode = 24; // Allows single numeral hex numbers to be appended by a 0.\n\nvar HexPadding = \"0\"; // header for the timestamp column\n\nvar TimestampColHeader = \"timestamp\"; // header for the numPoints column\n\nvar NumPointsColHeader = \"numPoints\"; // regex to capture all carriage returns in the string.\n\nvar CarriageReturnRegex = /\\r/g; // string to use as separator when exporting extra information along with the dataset id\n\nvar ExportedDataSeparator = \"@\";\n/**\n * The collector class handles the collection and storage of data into the appropriate array.\n * The collector also handles notifying any observers of any updates.\n */\n\nvar PerformanceViewerCollector =\n/** @class */\nfunction () {\n  /**\n   * Handles the creation of a performance viewer collector.\n   * @param _scene the scene to collect on.\n   * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\n   */\n  function PerformanceViewerCollector(_scene, _enabledStrategyCallbacks) {\n    var _this = this;\n\n    this._scene = _scene;\n    /**\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\n     * This method will then notify all observers with the latest slice.\n     */\n\n    this._collectDataAtFrame = function () {\n      var timestamp = PrecisionDate.Now - _this._startingTimestamp;\n      var numPoints = _this.datasets.ids.length; // add the starting index for the slice\n\n      var numberOfIndices = _this.datasets.startingIndices.itemLength;\n      var startingIndex = 0;\n\n      if (numberOfIndices > 0) {\n        var previousStartingIndex = _this.datasets.startingIndices.at(numberOfIndices - 1);\n\n        startingIndex = previousStartingIndex + _this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\n      }\n\n      _this.datasets.startingIndices.push(startingIndex); // add the first 2 items in our slice.\n\n\n      _this.datasets.data.push(timestamp);\n\n      _this.datasets.data.push(numPoints); // add the values inside the slice.\n\n\n      _this.datasets.ids.forEach(function (id) {\n        var strategy = _this._strategies.get(id);\n\n        if (!strategy) {\n          return;\n        }\n\n        _this.datasets.data.push(strategy.getData());\n      });\n\n      if (_this.datasetObservable.hasObservers()) {\n        var slice = [timestamp, numPoints];\n\n        for (var i = 0; i < numPoints; i++) {\n          slice.push(_this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\n        }\n\n        _this.datasetObservable.notifyObservers(slice);\n      }\n    };\n\n    this.datasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    };\n    this._strategies = new Map();\n    this._datasetMeta = new Map();\n    this._eventRestoreSet = new Set();\n    this._customEventObservable = new Observable();\n    this.datasetObservable = new Observable();\n    this.metadataObservable = new Observable(function (observer) {\n      return observer.callback(_this._datasetMeta, new EventState(0));\n    });\n\n    if (_enabledStrategyCallbacks) {\n      this.addCollectionStrategies.apply(this, _enabledStrategyCallbacks);\n    }\n  }\n\n  Object.defineProperty(PerformanceViewerCollector, \"SliceDataOffset\", {\n    /**\n     * The offset for when actual data values start appearing inside a slice.\n     */\n    get: function get() {\n      return 2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceViewerCollector, \"NumberOfPointsOffset\", {\n    /**\n     * The offset for the value of the number of points inside a slice.\n     */\n    get: function get() {\n      return 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\n   * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\n   * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\n   * @param name The name of the event to register\n   * @param forceUpdate if the code should force add an event, and replace the last one.\n   * @param category the category for that event\n   * @returns The event registered, used in sendEvent\n   */\n\n  PerformanceViewerCollector.prototype.registerEvent = function (name, forceUpdate, category) {\n    var _this = this;\n\n    var _a;\n\n    if (this._strategies.has(name) && !forceUpdate) {\n      return;\n    }\n\n    if (this._strategies.has(name) && forceUpdate) {\n      (_a = this._strategies.get(name)) === null || _a === void 0 ? void 0 : _a.dispose();\n\n      this._strategies[\"delete\"](name);\n    }\n\n    var strategy = function strategy(scene) {\n      var counter = 0;\n      var value = 0;\n      var afterRenderObserver = scene.onAfterRenderObservable.add(function () {\n        value = counter;\n        counter = 0;\n      });\n\n      var stringObserver = _this._customEventObservable.add(function (eventVal) {\n        if (name !== eventVal.name) {\n          return;\n        }\n\n        if (eventVal.value !== undefined) {\n          counter = eventVal.value;\n        } else {\n          counter++;\n        }\n      });\n\n      return {\n        id: name,\n        getData: function getData() {\n          return value;\n        },\n        dispose: function dispose() {\n          scene.onAfterRenderObservable.remove(afterRenderObserver);\n\n          _this._customEventObservable.remove(stringObserver);\n        }\n      };\n    };\n\n    var event = {\n      name: name\n    };\n\n    this._eventRestoreSet.add(name);\n\n    this.addCollectionStrategies({\n      strategyCallback: strategy,\n      category: category\n    });\n    return event;\n  };\n  /**\n   * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\n   * @param event the event to handle an occurence for\n   */\n\n\n  PerformanceViewerCollector.prototype.sendEvent = function (event) {\n    this._customEventObservable.notifyObservers(event);\n  };\n  /**\n   * This event restores all custom string events if necessary.\n   */\n\n\n  PerformanceViewerCollector.prototype._restoreStringEvents = function () {\n    var _this = this;\n\n    if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\n      this._eventRestoreSet.forEach(function (event) {\n        _this.registerEvent(event, true);\n      });\n    }\n  };\n  /**\n   * This method adds additional collection strategies for data collection purposes.\n   * @param strategyCallbacks the list of data to collect with callbacks.\n   */\n\n\n  PerformanceViewerCollector.prototype.addCollectionStrategies = function () {\n    var strategyCallbacks = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      strategyCallbacks[_i] = arguments[_i];\n    } // eslint-disable-next-line prefer-const\n\n\n    for (var _a = 0, strategyCallbacks_1 = strategyCallbacks; _a < strategyCallbacks_1.length; _a++) {\n      var _b = strategyCallbacks_1[_a],\n          strategyCallback = _b.strategyCallback,\n          category = _b.category,\n          hidden = _b.hidden;\n      var strategy = strategyCallback(this._scene);\n\n      if (this._strategies.has(strategy.id)) {\n        strategy.dispose();\n        continue;\n      }\n\n      this.datasets.ids.push(strategy.id);\n\n      if (category) {\n        category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\n      }\n\n      this._datasetMeta.set(strategy.id, {\n        color: this._getHexColorFromId(strategy.id),\n        category: category,\n        hidden: hidden\n      });\n\n      this._strategies.set(strategy.id, strategy);\n    }\n\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  };\n  /**\n   * Gets a 6 character hexcode representing the colour from a passed in string.\n   * @param id the string to get a hex code for.\n   * @returns a hexcode hashed from the id.\n   */\n\n\n  PerformanceViewerCollector.prototype._getHexColorFromId = function (id) {\n    // this first bit is just a known way of hashing a string.\n    var hash = 0;\n\n    for (var i = 0; i < id.length; i++) {\n      // (hash << 5) - hash is the same as hash * 31\n      hash = id.charCodeAt(i) + ((hash << 5) - hash);\n    } // then we build the string octet by octet.\n\n\n    var hex = \"#\";\n\n    for (var i = 0; i < NumberOfBitsInHexcode; i += 8) {\n      var octet = hash >> i & 0xff;\n      hex += (HexPadding + octet.toString(16)).substr(-2);\n    }\n\n    return hex;\n  };\n  /**\n   * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\n   * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\n   * This method does not add onto the collected data accessible via the datasets variable.\n   */\n\n\n  PerformanceViewerCollector.prototype.getCurrentSlice = function () {\n    var _this = this;\n\n    var timestamp = PrecisionDate.Now - this._startingTimestamp;\n    var numPoints = this.datasets.ids.length;\n    var slice = [timestamp, numPoints]; // add the values inside the slice.\n\n    this.datasets.ids.forEach(function (id) {\n      var strategy = _this._strategies.get(id);\n\n      if (!strategy) {\n        return;\n      }\n\n      if (_this.datasetObservable.hasObservers()) {\n        slice.push(strategy.getData());\n      }\n    });\n\n    if (this.datasetObservable.hasObservers()) {\n      this.datasetObservable.notifyObservers(slice);\n    }\n  };\n  /**\n   * Updates a property for a dataset's metadata with the value provided.\n   * @param id the id of the dataset which needs its metadata updated.\n   * @param prop the property to update.\n   * @param value the value to update the property with.\n   */\n\n\n  PerformanceViewerCollector.prototype.updateMetadata = function (id, prop, value) {\n    var meta = this._datasetMeta.get(id);\n\n    if (!meta) {\n      return;\n    }\n\n    meta[prop] = value;\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  };\n  /**\n   * Completely clear, data, ids, and strategies saved to this performance collector.\n   * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\n   */\n\n\n  PerformanceViewerCollector.prototype.clear = function (preserveStringEventsRestore) {\n    this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n    this.datasets.ids.length = 0;\n    this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n\n    this._datasetMeta.clear();\n\n    this._strategies.forEach(function (strategy) {\n      return strategy.dispose();\n    });\n\n    this._strategies.clear();\n\n    if (!preserveStringEventsRestore) {\n      this._eventRestoreSet.clear();\n    }\n\n    this._hasLoadedData = false;\n  };\n\n  Object.defineProperty(PerformanceViewerCollector.prototype, \"hasLoadedData\", {\n    /**\n     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\n     * Call clear() to reset this value.\n     * @returns true if the data is loaded from a file, false otherwise.\n     */\n    get: function get() {\n      return this._hasLoadedData;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Given a string containing file data, this function parses the file data into the datasets object.\n   * It returns a boolean to indicate if this object was successfully loaded with the data.\n   * @param data string content representing the file data.\n   * @param keepDatasetMeta if it should use reuse the existing dataset metadata\n   * @returns true if the data was successfully loaded, false otherwise.\n   */\n\n  PerformanceViewerCollector.prototype.loadFromFileData = function (data, keepDatasetMeta) {\n    var lines = data.replace(CarriageReturnRegex, \"\").split(\"\\n\").map(function (line) {\n      return line.split(\",\").filter(function (s) {\n        return s.length > 0;\n      });\n    }).filter(function (line) {\n      return line.length > 0;\n    });\n    var timestampIndex = 0;\n    var numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\n\n    if (lines.length < 2) {\n      return false;\n    }\n\n    var parsedDatasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    }; // parse first line separately to populate ids!\n\n    var firstLine = lines[0],\n        dataLines = lines.slice(1); // make sure we have the correct beginning headers\n\n    if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\n      return false;\n    }\n\n    var idCategoryMap = new Map(); // populate the ids.\n\n    for (var i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\n      var _a = firstLine[i].split(ExportedDataSeparator),\n          id = _a[0],\n          category = _a[1];\n\n      parsedDatasets.ids.push(id);\n      idCategoryMap.set(id, category);\n    }\n\n    var startingIndex = 0;\n\n    for (var _i = 0, dataLines_1 = dataLines; _i < dataLines_1.length; _i++) {\n      var line = dataLines_1[_i];\n\n      if (line.length < 2) {\n        return false;\n      }\n\n      var timestamp = parseFloat(line[timestampIndex]);\n      var numPoints = parseInt(line[numPointsIndex]);\n\n      if (isNaN(numPoints) || isNaN(timestamp)) {\n        return false;\n      }\n\n      parsedDatasets.data.push(timestamp);\n      parsedDatasets.data.push(numPoints);\n\n      if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\n        return false;\n      }\n\n      for (var i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\n        var val = parseFloat(line[i]);\n\n        if (isNaN(val)) {\n          return false;\n        }\n\n        parsedDatasets.data.push(val);\n      }\n\n      parsedDatasets.startingIndices.push(startingIndex);\n      startingIndex += line.length;\n    }\n\n    this.datasets.ids = parsedDatasets.ids;\n    this.datasets.data = parsedDatasets.data;\n    this.datasets.startingIndices = parsedDatasets.startingIndices;\n\n    if (!keepDatasetMeta) {\n      this._datasetMeta.clear();\n    }\n\n    this._strategies.forEach(function (strategy) {\n      return strategy.dispose();\n    });\n\n    this._strategies.clear(); // populate metadata.\n\n\n    if (!keepDatasetMeta) {\n      for (var _b = 0, _c = this.datasets.ids; _b < _c.length; _b++) {\n        var id = _c[_b];\n        var category = idCategoryMap.get(id);\n\n        this._datasetMeta.set(id, {\n          category: category,\n          color: this._getHexColorFromId(id)\n        });\n      }\n    }\n\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n    this._hasLoadedData = true;\n    return true;\n  };\n  /**\n   * Exports the datasets inside of the collector to a csv.\n   */\n\n\n  PerformanceViewerCollector.prototype.exportDataToCsv = function () {\n    var csvContent = \"\"; // create the header line.\n\n    csvContent += \"\".concat(TimestampColHeader, \",\").concat(NumPointsColHeader);\n\n    for (var i = 0; i < this.datasets.ids.length; i++) {\n      csvContent += \",\".concat(this.datasets.ids[i]);\n\n      if (this._datasetMeta) {\n        var meta = this._datasetMeta.get(this.datasets.ids[i]);\n\n        if (meta === null || meta === void 0 ? void 0 : meta.category) {\n          csvContent += \"\".concat(ExportedDataSeparator).concat(meta.category);\n        }\n      }\n    }\n\n    csvContent += \"\\n\"; // create the data lines\n\n    for (var i = 0; i < this.datasets.startingIndices.itemLength; i++) {\n      var startingIndex = this.datasets.startingIndices.at(i);\n      var timestamp = this.datasets.data.at(startingIndex);\n      var numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\n      csvContent += \"\".concat(timestamp, \",\").concat(numPoints);\n\n      for (var offset = 0; offset < numPoints; offset++) {\n        csvContent += \",\".concat(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset));\n      } // add extra commas.\n\n\n      for (var diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\n        csvContent += \",\";\n      }\n\n      csvContent += \"\\n\";\n    }\n\n    var fileName = \"\".concat(new Date().toISOString(), \"-perfdata.csv\");\n    Tools.Download(new Blob([csvContent], {\n      type: \"text/csv\"\n    }), fileName);\n  };\n  /**\n   * Starts the realtime collection of data.\n   * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\n   */\n\n\n  PerformanceViewerCollector.prototype.start = function (shouldPreserve) {\n    if (!shouldPreserve) {\n      this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n      this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n      this._startingTimestamp = PrecisionDate.Now;\n    } else if (this._startingTimestamp === undefined) {\n      this._startingTimestamp = PrecisionDate.Now;\n    }\n\n    this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\n\n    this._restoreStringEvents();\n\n    this._isStarted = true;\n  };\n  /**\n   * Stops the collection of data.\n   */\n\n\n  PerformanceViewerCollector.prototype.stop = function () {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n\n    this._isStarted = false;\n  };\n\n  Object.defineProperty(PerformanceViewerCollector.prototype, \"isStarted\", {\n    /**\n     * Returns if the perf collector has been started or not.\n     */\n    get: function get() {\n      return this._isStarted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes of the object\n   */\n\n  PerformanceViewerCollector.prototype.dispose = function () {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n\n    this._datasetMeta.clear();\n\n    this._strategies.forEach(function (strategy) {\n      strategy.dispose();\n    });\n\n    this.datasetObservable.clear();\n    this.metadataObservable.clear();\n    this._isStarted = false;\n    this.datasets = null;\n  };\n\n  return PerformanceViewerCollector;\n}();\n\nexport { PerformanceViewerCollector };","map":{"version":3,"mappings":"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","names":["EventState","Observable","PrecisionDate","Tools","DynamicFloat32Array","InitialArraySize","NumberOfBitsInHexcode","HexPadding","TimestampColHeader","NumPointsColHeader","CarriageReturnRegex","ExportedDataSeparator","_scene","_enabledStrategyCallbacks","timestamp","Now","_this","_startingTimestamp","numPoints","datasets","ids","length","numberOfIndices","startingIndices","itemLength","startingIndex","previousStartingIndex","at","data","PerformanceViewerCollector","NumberOfPointsOffset","SliceDataOffset","push","forEach","id","strategy","_strategies","get","getData","datasetObservable","hasObservers","slice","i","notifyObservers","Map","_datasetMeta","_eventRestoreSet","Set","_customEventObservable","metadataObservable","observer","callback","addCollectionStrategies","apply","Object","name","forceUpdate","category","has","_a","dispose","scene","counter","value","afterRenderObserver","onAfterRenderObservable","add","stringObserver","eventVal","undefined","remove","event","strategyCallback","size","observers","registerEvent","strategyCallbacks","hidden","replace","RegExp","set","color","_getHexColorFromId","hash","charCodeAt","hex","octet","toString","substr","prop","meta","preserveStringEventsRestore","clear","_hasLoadedData","keepDatasetMeta","lines","split","map","line","filter","s","timestampIndex","numPointsIndex","parsedDatasets","dataLines","firstLine","idCategoryMap","_i","parseFloat","parseInt","isNaN","val","_b","csvContent","concat","offset","diff","fileName","Date","toISOString","Download","Blob","type","shouldPreserve","_collectDataAtFrame","_restoreStringEvents","_isStarted","removeCallback"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Misc/PerformanceViewer/performanceViewerCollector.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { IPerfCustomEvent, IPerfDatasets, IPerfMetadata } from \"../interfaces/iPerfViewer\";\r\nimport { EventState, Observable } from \"../observable\";\r\nimport { PrecisionDate } from \"../precisionDate\";\r\nimport { Tools } from \"../tools\";\r\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array\";\r\nimport type { IPerfViewerCollectionStrategy, PerfStrategyInitialization } from \"./performanceViewerCollectionStrategies\";\r\n\r\n// the initial size of our array, should be a multiple of two!\r\nconst InitialArraySize = 1800;\r\n\r\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\r\nconst NumberOfBitsInHexcode = 24;\r\n\r\n// Allows single numeral hex numbers to be appended by a 0.\r\nconst HexPadding = \"0\";\r\n\r\n// header for the timestamp column\r\nconst TimestampColHeader = \"timestamp\";\r\n\r\n// header for the numPoints column\r\nconst NumPointsColHeader = \"numPoints\";\r\n\r\n// regex to capture all carriage returns in the string.\r\nconst CarriageReturnRegex = /\\r/g;\r\n\r\n// string to use as separator when exporting extra information along with the dataset id\r\nconst ExportedDataSeparator = \"@\";\r\n\r\n/**\r\n * Callback strategy and optional category for data collection\r\n */\r\ninterface IPerformanceViewerStrategyParameter {\r\n    /**\r\n     * The strategy for collecting data. Available strategies are located on the PerfCollectionStrategy class\r\n     */\r\n    strategyCallback: PerfStrategyInitialization;\r\n    /**\r\n     * Category for displaying this strategy on the viewer. Can be undefined or an empty string, in which case the strategy will be displayed on top\r\n     */\r\n    category?: string;\r\n    /**\r\n     * Starts hidden\r\n     */\r\n    hidden?: boolean;\r\n}\r\n\r\n/**\r\n * The collector class handles the collection and storage of data into the appropriate array.\r\n * The collector also handles notifying any observers of any updates.\r\n */\r\nexport class PerformanceViewerCollector {\r\n    private _datasetMeta: Map<string, IPerfMetadata>;\r\n    private _strategies: Map<string, IPerfViewerCollectionStrategy>;\r\n    private _startingTimestamp: number;\r\n    private _hasLoadedData: boolean;\r\n    private _isStarted: boolean;\r\n    private readonly _customEventObservable: Observable<IPerfCustomEvent>;\r\n    private readonly _eventRestoreSet: Set<string>;\r\n\r\n    /**\r\n     * Datastructure containing the collected datasets. Warning: you should not modify the values in here, data will be of the form [timestamp, numberOfPoints, value1, value2..., timestamp, etc...]\r\n     */\r\n    public readonly datasets: IPerfDatasets;\r\n    /**\r\n     * An observable you can attach to get deltas in the dataset. Subscribing to this will increase memory consumption slightly, and may hurt performance due to increased garbage collection needed.\r\n     * Updates of slices will be of the form [timestamp, numberOfPoints, value1, value2...].\r\n     */\r\n    public readonly datasetObservable: Observable<number[]>;\r\n    /**\r\n     * An observable you can attach to get the most updated map of metadatas.\r\n     */\r\n    public readonly metadataObservable: Observable<Map<string, IPerfMetadata>>;\r\n\r\n    /**\r\n     * The offset for when actual data values start appearing inside a slice.\r\n     */\r\n    public static get SliceDataOffset() {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * The offset for the value of the number of points inside a slice.\r\n     */\r\n    public static get NumberOfPointsOffset() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Handles the creation of a performance viewer collector.\r\n     * @param _scene the scene to collect on.\r\n     * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\r\n     */\r\n    constructor(private _scene: Scene, _enabledStrategyCallbacks?: IPerformanceViewerStrategyParameter[]) {\r\n        this.datasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n        this._strategies = new Map<string, IPerfViewerCollectionStrategy>();\r\n        this._datasetMeta = new Map<string, IPerfMetadata>();\r\n        this._eventRestoreSet = new Set();\r\n        this._customEventObservable = new Observable();\r\n        this.datasetObservable = new Observable();\r\n        this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));\r\n        if (_enabledStrategyCallbacks) {\r\n            this.addCollectionStrategies(..._enabledStrategyCallbacks);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\r\n     * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\r\n     * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\r\n     * @param name The name of the event to register\r\n     * @param forceUpdate if the code should force add an event, and replace the last one.\r\n     * @param category the category for that event\r\n     * @returns The event registered, used in sendEvent\r\n     */\r\n    public registerEvent(name: string, forceUpdate?: boolean, category?: string): IPerfCustomEvent | undefined {\r\n        if (this._strategies.has(name) && !forceUpdate) {\r\n            return;\r\n        }\r\n\r\n        if (this._strategies.has(name) && forceUpdate) {\r\n            this._strategies.get(name)?.dispose();\r\n            this._strategies.delete(name);\r\n        }\r\n\r\n        const strategy: PerfStrategyInitialization = (scene) => {\r\n            let counter: number = 0;\r\n            let value: number = 0;\r\n\r\n            const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                value = counter;\r\n                counter = 0;\r\n            });\r\n\r\n            const stringObserver = this._customEventObservable.add((eventVal) => {\r\n                if (name !== eventVal.name) {\r\n                    return;\r\n                }\r\n\r\n                if (eventVal.value !== undefined) {\r\n                    counter = eventVal.value;\r\n                } else {\r\n                    counter++;\r\n                }\r\n            });\r\n\r\n            return {\r\n                id: name,\r\n                getData: () => value,\r\n                dispose: () => {\r\n                    scene.onAfterRenderObservable.remove(afterRenderObserver);\r\n                    this._customEventObservable.remove(stringObserver);\r\n                },\r\n            };\r\n        };\r\n        const event: IPerfCustomEvent = {\r\n            name,\r\n        };\r\n\r\n        this._eventRestoreSet.add(name);\r\n        this.addCollectionStrategies({ strategyCallback: strategy, category });\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\r\n     * @param event the event to handle an occurence for\r\n     */\r\n    public sendEvent(event: IPerfCustomEvent) {\r\n        this._customEventObservable.notifyObservers(event);\r\n    }\r\n\r\n    /**\r\n     * This event restores all custom string events if necessary.\r\n     */\r\n    private _restoreStringEvents() {\r\n        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\r\n            this._eventRestoreSet.forEach((event) => {\r\n                this.registerEvent(event, true);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method adds additional collection strategies for data collection purposes.\r\n     * @param strategyCallbacks the list of data to collect with callbacks.\r\n     */\r\n    public addCollectionStrategies(...strategyCallbacks: IPerformanceViewerStrategyParameter[]) {\r\n        // eslint-disable-next-line prefer-const\r\n        for (let { strategyCallback, category, hidden } of strategyCallbacks) {\r\n            const strategy = strategyCallback(this._scene);\r\n            if (this._strategies.has(strategy.id)) {\r\n                strategy.dispose();\r\n                continue;\r\n            }\r\n\r\n            this.datasets.ids.push(strategy.id);\r\n\r\n            if (category) {\r\n                category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\r\n            }\r\n\r\n            this._datasetMeta.set(strategy.id, {\r\n                color: this._getHexColorFromId(strategy.id),\r\n                category,\r\n                hidden,\r\n            });\r\n\r\n            this._strategies.set(strategy.id, strategy);\r\n        }\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Gets a 6 character hexcode representing the colour from a passed in string.\r\n     * @param id the string to get a hex code for.\r\n     * @returns a hexcode hashed from the id.\r\n     */\r\n    private _getHexColorFromId(id: string) {\r\n        // this first bit is just a known way of hashing a string.\r\n        let hash = 0;\r\n        for (let i = 0; i < id.length; i++) {\r\n            // (hash << 5) - hash is the same as hash * 31\r\n            hash = id.charCodeAt(i) + ((hash << 5) - hash);\r\n        }\r\n\r\n        // then we build the string octet by octet.\r\n        let hex = \"#\";\r\n        for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\r\n            const octet = (hash >> i) & 0xff;\r\n            hex += (HexPadding + octet.toString(16)).substr(-2);\r\n        }\r\n\r\n        return hex;\r\n    }\r\n\r\n    /**\r\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\r\n     * This method will then notify all observers with the latest slice.\r\n     */\r\n    private _collectDataAtFrame = () => {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n\r\n        // add the starting index for the slice\r\n        const numberOfIndices = this.datasets.startingIndices.itemLength;\r\n        let startingIndex = 0;\r\n\r\n        if (numberOfIndices > 0) {\r\n            const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\r\n            startingIndex =\r\n                previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\r\n        }\r\n\r\n        this.datasets.startingIndices.push(startingIndex);\r\n\r\n        // add the first 2 items in our slice.\r\n        this.datasets.data.push(timestamp);\r\n        this.datasets.data.push(numPoints);\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            this.datasets.data.push(strategy.getData());\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            const slice: number[] = [timestamp, numPoints];\r\n\r\n            for (let i = 0; i < numPoints; i++) {\r\n                slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\r\n            }\r\n\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\r\n     * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\r\n     * This method does not add onto the collected data accessible via the datasets variable.\r\n     */\r\n    public getCurrentSlice() {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n        const slice: number[] = [timestamp, numPoints];\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            if (this.datasetObservable.hasObservers()) {\r\n                slice.push(strategy.getData());\r\n            }\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates a property for a dataset's metadata with the value provided.\r\n     * @param id the id of the dataset which needs its metadata updated.\r\n     * @param prop the property to update.\r\n     * @param value the value to update the property with.\r\n     */\r\n    public updateMetadata<T extends keyof IPerfMetadata>(id: string, prop: T, value: IPerfMetadata[T]) {\r\n        const meta = this._datasetMeta.get(id);\r\n\r\n        if (!meta) {\r\n            return;\r\n        }\r\n\r\n        meta[prop] = value;\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Completely clear, data, ids, and strategies saved to this performance collector.\r\n     * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\r\n     */\r\n    public clear(preserveStringEventsRestore?: boolean) {\r\n        this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n        this.datasets.ids.length = 0;\r\n        this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        if (!preserveStringEventsRestore) {\r\n            this._eventRestoreSet.clear();\r\n        }\r\n        this._hasLoadedData = false;\r\n    }\r\n\r\n    /**\r\n     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\r\n     * Call clear() to reset this value.\r\n     * @returns true if the data is loaded from a file, false otherwise.\r\n     */\r\n    public get hasLoadedData(): boolean {\r\n        return this._hasLoadedData;\r\n    }\r\n\r\n    /**\r\n     * Given a string containing file data, this function parses the file data into the datasets object.\r\n     * It returns a boolean to indicate if this object was successfully loaded with the data.\r\n     * @param data string content representing the file data.\r\n     * @param keepDatasetMeta if it should use reuse the existing dataset metadata\r\n     * @returns true if the data was successfully loaded, false otherwise.\r\n     */\r\n    public loadFromFileData(data: string, keepDatasetMeta?: boolean): boolean {\r\n        const lines = data\r\n            .replace(CarriageReturnRegex, \"\")\r\n            .split(\"\\n\")\r\n            .map((line) => line.split(\",\").filter((s) => s.length > 0))\r\n            .filter((line) => line.length > 0);\r\n        const timestampIndex = 0;\r\n        const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\r\n        if (lines.length < 2) {\r\n            return false;\r\n        }\r\n\r\n        const parsedDatasets: IPerfDatasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n\r\n        // parse first line separately to populate ids!\r\n        const [firstLine, ...dataLines] = lines;\r\n        // make sure we have the correct beginning headers\r\n        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\r\n            return false;\r\n        }\r\n\r\n        const idCategoryMap: Map<string, string> = new Map<string, string>();\r\n\r\n        // populate the ids.\r\n        for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\r\n            const [id, category] = firstLine[i].split(ExportedDataSeparator);\r\n            parsedDatasets.ids.push(id);\r\n            idCategoryMap.set(id, category);\r\n        }\r\n\r\n        let startingIndex = 0;\r\n        for (const line of dataLines) {\r\n            if (line.length < 2) {\r\n                return false;\r\n            }\r\n\r\n            const timestamp = parseFloat(line[timestampIndex]);\r\n            const numPoints = parseInt(line[numPointsIndex]);\r\n\r\n            if (isNaN(numPoints) || isNaN(timestamp)) {\r\n                return false;\r\n            }\r\n\r\n            parsedDatasets.data.push(timestamp);\r\n            parsedDatasets.data.push(numPoints);\r\n\r\n            if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\r\n                return false;\r\n            }\r\n\r\n            for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\r\n                const val = parseFloat(line[i]);\r\n                if (isNaN(val)) {\r\n                    return false;\r\n                }\r\n                parsedDatasets.data.push(val);\r\n            }\r\n\r\n            parsedDatasets.startingIndices.push(startingIndex);\r\n            startingIndex += line.length;\r\n        }\r\n\r\n        this.datasets.ids = parsedDatasets.ids;\r\n        this.datasets.data = parsedDatasets.data;\r\n        this.datasets.startingIndices = parsedDatasets.startingIndices;\r\n        if (!keepDatasetMeta) {\r\n            this._datasetMeta.clear();\r\n        }\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        // populate metadata.\r\n        if (!keepDatasetMeta) {\r\n            for (const id of this.datasets.ids) {\r\n                const category = idCategoryMap.get(id);\r\n\r\n                this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });\r\n            }\r\n        }\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n        this._hasLoadedData = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Exports the datasets inside of the collector to a csv.\r\n     */\r\n    public exportDataToCsv() {\r\n        let csvContent = \"\";\r\n        // create the header line.\r\n        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\r\n        for (let i = 0; i < this.datasets.ids.length; i++) {\r\n            csvContent += `,${this.datasets.ids[i]}`;\r\n            if (this._datasetMeta) {\r\n                const meta = this._datasetMeta.get(this.datasets.ids[i]);\r\n                if (meta?.category) {\r\n                    csvContent += `${ExportedDataSeparator}${meta.category}`;\r\n                }\r\n            }\r\n        }\r\n        csvContent += \"\\n\";\r\n        // create the data lines\r\n        for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\r\n            const startingIndex = this.datasets.startingIndices.at(i);\r\n            const timestamp = this.datasets.data.at(startingIndex);\r\n            const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\r\n\r\n            csvContent += `${timestamp},${numPoints}`;\r\n\r\n            for (let offset = 0; offset < numPoints; offset++) {\r\n                csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\r\n            }\r\n\r\n            // add extra commas.\r\n            for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\r\n                csvContent += \",\";\r\n            }\r\n\r\n            csvContent += \"\\n\";\r\n        }\r\n\r\n        const fileName = `${new Date().toISOString()}-perfdata.csv`;\r\n        Tools.Download(new Blob([csvContent], { type: \"text/csv\" }), fileName);\r\n    }\r\n    /**\r\n     * Starts the realtime collection of data.\r\n     * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\r\n     */\r\n    public start(shouldPreserve?: boolean) {\r\n        if (!shouldPreserve) {\r\n            this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n            this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        } else if (this._startingTimestamp === undefined) {\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        }\r\n        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\r\n        this._restoreStringEvents();\r\n        this._isStarted = true;\r\n    }\r\n\r\n    /**\r\n     * Stops the collection of data.\r\n     */\r\n    public stop() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._isStarted = false;\r\n    }\r\n\r\n    /**\r\n     * Returns if the perf collector has been started or not.\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => {\r\n            strategy.dispose();\r\n        });\r\n        this.datasetObservable.clear();\r\n        this.metadataObservable.clear();\r\n        this._isStarted = false;\r\n        (<any>this.datasets) = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}