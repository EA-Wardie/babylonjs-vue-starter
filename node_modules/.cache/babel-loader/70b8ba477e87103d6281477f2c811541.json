{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport \"../Shaders/volumetricLightScattering.fragment.js\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex.js\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\n */\n\nvar VolumetricLightScatteringPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(VolumetricLightScatteringPostProcess, _super);\n  /**\n   * @constructor\n   * @param name The post-process name\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param camera The camera that the post-process will be attached to\n   * @param mesh The mesh used to create the light scattering\n   * @param samples The post-process quality, default 100\n   * @param samplingMode The post-process filtering mode\n   * @param engine The babylon engine\n   * @param reusable If the post-process is reusable\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\n   */\n\n\n  function VolumetricLightScatteringPostProcess(name, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {\n    if (samples === void 0) {\n      samples = 100;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = this;\n\n    var _a;\n\n    _this = _super.call(this, name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples) || this;\n    _this._screenCoordinates = Vector2.Zero();\n    /**\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\n     */\n\n    _this.customMeshPosition = Vector3.Zero();\n    /**\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\n     */\n\n    _this.useCustomMeshPosition = false;\n    /**\n     * If the post-process should inverse the light scattering direction\n     */\n\n    _this.invert = true;\n    /**\n     * Array containing the excluded meshes not rendered in the internal pass\n     */\n\n    _this.excludedMeshes = new Array();\n    /**\n     * Controls the overall intensity of the post-process\n     */\n\n    _this.exposure = 0.3;\n    /**\n     * Dissipates each sample's contribution in range [0, 1]\n     */\n\n    _this.decay = 0.96815;\n    /**\n     * Controls the overall intensity of each sample\n     */\n\n    _this.weight = 0.58767;\n    /**\n     * Controls the density of each sample\n     */\n\n    _this.density = 0.926;\n    scene = (_a = camera === null || camera === void 0 ? void 0 : camera.getScene()) !== null && _a !== void 0 ? _a : scene; // parameter \"scene\" can be null.\n\n    engine = scene.getEngine();\n    _this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Configure mesh\n\n    _this.mesh = mesh !== null && mesh !== void 0 ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\n    _this._volumetricLightScatteringPass = new DrawWrapper(engine); // Configure\n\n    _this._createPass(scene, ratio.passRatio || ratio);\n\n    _this.onActivate = function (camera) {\n      if (!_this.isSupported) {\n        _this.dispose(camera);\n      }\n\n      _this.onActivate = null;\n    };\n\n    _this.onApplyObservable.add(function (effect) {\n      _this._updateMeshScreenCoordinates(scene);\n\n      effect.setTexture(\"lightScatteringSampler\", _this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", _this.exposure);\n      effect.setFloat(\"decay\", _this.decay);\n      effect.setFloat(\"weight\", _this.weight);\n      effect.setFloat(\"density\", _this.density);\n      effect.setVector2(\"meshPositionOnScreen\", _this._screenCoordinates);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(VolumetricLightScatteringPostProcess.prototype, \"useDiffuseColor\", {\n    /**\n     * @hidden\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\n     */\n    get: function get() {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n      return false;\n    },\n    set: function set(useDiffuseColor) {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\n   * @returns \"VolumetricLightScatteringPostProcess\"\n   */\n\n  VolumetricLightScatteringPostProcess.prototype.getClassName = function () {\n    return \"VolumetricLightScatteringPostProcess\";\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._isReady = function (subMesh, useInstances) {\n    var mesh = subMesh.getMesh(); // Render this.mesh as default\n\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var material = subMesh.getMaterial(); // Alpha test\n\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._volumetricLightScatteringPass.effect = mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      });\n    }\n\n    return this._volumetricLightScatteringPass.effect.isReady();\n  };\n  /**\n   * Sets the new light position for light scattering effect\n   * @param position The new custom light position\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.setCustomMeshPosition = function (position) {\n    this.customMeshPosition = position;\n  };\n  /**\n   * Returns the light position for light scattering effect\n   * @return Vector3 The custom light position\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getCustomMeshPosition = function () {\n    return this.customMeshPosition;\n  };\n  /**\n   * Disposes the internal assets and detaches the post-process from the camera\n   * @param camera\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.dispose = function (camera) {\n    var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n\n    this._volumetricLightScatteringRTT.dispose();\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\n   * Returns the render target texture used by the post-process\n   * @return the render target texture used by the post-process\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getPass = function () {\n    return this._volumetricLightScatteringRTT;\n  }; // Private methods\n\n\n  VolumetricLightScatteringPostProcess.prototype._meshExcluded = function (mesh) {\n    if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._createPass = function (scene, ratio) {\n    var _this = this;\n\n    var engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    var camera = this.getCamera();\n\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } // Custom render function for submeshes\n\n\n    var renderSubMesh = function renderSubMesh(subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n\n      if (_this._meshExcluded(renderingMesh)) {\n        return;\n      }\n\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        return;\n      }\n\n      var scene = renderingMesh.getScene();\n      var engine = scene.getEngine(); // Culling\n\n      engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n\n      if (_this._isReady(subMesh, hardwareInstancedRendering)) {\n        var drawWrapper = _this._volumetricLightScatteringPass;\n\n        if (renderingMesh === _this.mesh) {\n          if (subMesh.effect) {\n            drawWrapper = subMesh._drawWrapper;\n          } else {\n            drawWrapper = material._getDrawWrapper();\n          }\n        }\n\n        var effect_1 = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect_1, material.fillMode);\n        }\n\n        if (renderingMesh === _this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else {\n          effect_1.setMatrix(\"viewProjection\", scene.getTransformMatrix()); // Alpha test\n\n          if (material && material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n            effect_1.setTexture(\"diffuseSampler\", alphaTexture);\n\n            if (alphaTexture) {\n              effect_1.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bones\n\n\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect_1.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n\n        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n          effect_1.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          if (!isInstance) {\n            effect_1.setMatrix(\"world\", world);\n          }\n        });\n      }\n    }; // Render target texture callbacks\n\n\n    var savedSceneClearColor;\n    var sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {\n      scene.clearColor = savedSceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.customIsReadyFunction = function (mesh, refreshRate) {\n      if (!mesh.isReady(false)) {\n        return false;\n      }\n\n      if (refreshRate === 0 && mesh.subMeshes) {\n        // full check: check that the effects are ready\n        for (var i = 0; i < mesh.subMeshes.length; ++i) {\n          var subMesh = mesh.subMeshes[i];\n          var material = subMesh.getMaterial();\n          var renderingMesh = subMesh.getRenderingMesh();\n\n          if (!material) {\n            continue;\n          }\n\n          var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n          var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n\n          if (!_this._isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    this._volumetricLightScatteringRTT.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var engine = scene.getEngine();\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          var submesh = transparentSubMeshes.data[index];\n          var boundingInfo = submesh.getBoundingInfo();\n\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n\n        var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort(function (a, b) {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          } // Then distance to camera\n\n\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n\n          return 0;\n        }); // Render sub meshes\n\n        engine.setAlphaMode(2);\n\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n\n        engine.setAlphaMode(0);\n      }\n    };\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._updateMeshScreenCoordinates = function (scene) {\n    var transform = scene.getTransformMatrix();\n    var meshPosition;\n\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n\n    var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }; // Static methods\n\n  /**\n   * Creates a default mesh for the Volumeric Light Scattering post-process\n   * @param name The mesh name\n   * @param scene The scene where to create the mesh\n   * @return the default mesh\n   */\n\n\n  VolumetricLightScatteringPostProcess.CreateDefaultMesh = function (name, scene) {\n    var mesh = CreatePlane(name, {\n      size: 1\n    }, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    var material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  };\n\n  __decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n\n  __decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\n\n  return VolumetricLightScatteringPostProcess;\n}(PostProcess);\n\nexport { VolumetricLightScatteringPostProcess };\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);","map":{"version":3,"mappings":"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","names":["serializeAsVector3","serialize","serializeAsMeshReference","Logger","Vector2","Vector3","Matrix","VertexBuffer","AbstractMesh","Material","MaterialHelper","StandardMaterial","Texture","RenderTargetTexture","PostProcess","CreatePlane","Color4","Color3","Viewport","RegisterClass","DrawWrapper","__extends","name","ratio","camera","mesh","samples","samplingMode","engine","reusable","scene","BILINEAR_SAMPLINGMODE","_super","postProcessRatio","_this","Zero","Array","getScene","_a","getEngine","_viewPort","toGlobal","getRenderWidth","getRenderHeight","VolumetricLightScatteringPostProcess","CreateDefaultMesh","_volumetricLightScatteringPass","_createPass","passRatio","onActivate","isSupported","dispose","onApplyObservable","add","effect","_updateMeshScreenCoordinates","setTexture","_volumetricLightScatteringRTT","setFloat","exposure","decay","weight","density","setVector2","_screenCoordinates","Object","Warn","useDiffuseColor","subMesh","useInstances","getMesh","material","isReady","defines","attribs","PositionKind","getMaterial","needAlphaTesting","push","isVerticesDataPresent","UVKind","UV2Kind","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","skeleton","bones","length","PushAttributesForInstances","getRenderingMesh","hasThinInstances","join","_cachedDefines","createEffect","undefined","maxSimultaneousMorphTargets","position","customMeshPosition","rttIndex","customRenderTargets","indexOf","splice","call","excludedMeshes","width","height","wrapU","CLAMP_ADDRESSMODE","wrapV","renderList","renderParticles","ignoreCameraViewport","getCamera","renderSubMesh","renderingMesh","effectiveMesh","getEffectiveMesh","_meshExcluded","_internalAbstractMeshDataInfo","_isActiveIntermediate","setState","backFaceCulling","cullBackFaces","batch","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","_isReady","drawWrapper","_drawWrapper","_getDrawWrapper","effect_1","enableEffect","_bind","fillMode","bind","getWorldMatrix","setMatrix","getTransformMatrix","alphaTexture","getAlphaTestTexture","getTextureMatrix","setMatrices","getTransformMatrices","_processRendering","TriangleFillMode","isInstance","world","savedSceneClearColor","sceneClearColor","onBeforeRenderObservable","clearColor","onAfterRenderObservable","customIsReadyFunction","refreshRate","subMeshes","i","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","setColorWrite","data","submesh","boundingInfo","getBoundingInfo","activeCamera","_alphaIndex","alphaIndex","_distanceToCamera","boundingSphere","centerWorld","subtract","sortedArray","slice","sort","a","b","setAlphaMode","transform","meshPosition","useCustomMeshPosition","attachedNode","parent","getAbsolutePosition","pos","Project","Identity","x","y","invert","size","billboardMode","BILLBOARDMODE_ALL","emissiveColor","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/volumetricLightScatteringPostProcess.ts"],"sourcesContent":["import { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\n\r\nimport \"../Shaders/depth.vertex\";\r\nimport \"../Shaders/volumetricLightScattering.fragment\";\r\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\r\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\r\n */\r\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\r\n    // Members\r\n    private _volumetricLightScatteringPass: DrawWrapper;\r\n    private _volumetricLightScatteringRTT: RenderTargetTexture;\r\n    private _viewPort: Viewport;\r\n    private _screenCoordinates: Vector2 = Vector2.Zero();\r\n    private _cachedDefines: string;\r\n\r\n    /**\r\n     * If not undefined, the mesh position is computed from the attached node position\r\n     */\r\n    public attachedNode: { position: Vector3 };\r\n\r\n    /**\r\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n     */\r\n    @serializeAsVector3()\r\n    public customMeshPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n     */\r\n    @serialize()\r\n    public useCustomMeshPosition: boolean = false;\r\n\r\n    /**\r\n     * If the post-process should inverse the light scattering direction\r\n     */\r\n    @serialize()\r\n    public invert: boolean = true;\r\n\r\n    /**\r\n     * The internal mesh used by the post-process\r\n     */\r\n    @serializeAsMeshReference()\r\n    public mesh: Mesh;\r\n\r\n    /**\r\n     * @hidden\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\r\n    public get useDiffuseColor(): boolean {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n        return false;\r\n    }\r\n\r\n    public set useDiffuseColor(useDiffuseColor: boolean) {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n    }\r\n\r\n    /**\r\n     * Array containing the excluded meshes not rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public excludedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * Controls the overall intensity of the post-process\r\n     */\r\n    @serialize()\r\n    public exposure = 0.3;\r\n\r\n    /**\r\n     * Dissipates each sample's contribution in range [0, 1]\r\n     */\r\n    @serialize()\r\n    public decay = 0.96815;\r\n\r\n    /**\r\n     * Controls the overall intensity of each sample\r\n     */\r\n    @serialize()\r\n    public weight = 0.58767;\r\n\r\n    /**\r\n     * Controls the density of each sample\r\n     */\r\n    @serialize()\r\n    public density = 0.926;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The post-process name\r\n     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param camera The camera that the post-process will be attached to\r\n     * @param mesh The mesh used to create the light scattering\r\n     * @param samples The post-process quality, default 100\r\n     * @param samplingMode The post-process filtering mode\r\n     * @param engine The babylon engine\r\n     * @param reusable If the post-process is reusable\r\n     * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n     */\r\n    constructor(\r\n        name: string,\r\n        ratio: any,\r\n        camera: Camera,\r\n        mesh?: Mesh,\r\n        samples: number = 100,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        scene?: Scene\r\n    ) {\r\n        super(\r\n            name,\r\n            \"volumetricLightScattering\",\r\n            [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"],\r\n            [\"lightScatteringSampler\"],\r\n            ratio.postProcessRatio || ratio,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define NUM_SAMPLES \" + samples\r\n        );\r\n        scene = camera?.getScene() ?? scene; // parameter \"scene\" can be null.\r\n\r\n        engine = scene.getEngine();\r\n        this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Configure mesh\r\n        this.mesh = mesh ?? VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\r\n        this._volumetricLightScatteringPass = new DrawWrapper(engine);\r\n\r\n        // Configure\r\n        this._createPass(scene, ratio.passRatio || ratio);\r\n\r\n        this.onActivate = (camera: Camera) => {\r\n            if (!this.isSupported) {\r\n                this.dispose(camera);\r\n            }\r\n\r\n            this.onActivate = null;\r\n        };\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this._updateMeshScreenCoordinates(<Scene>scene);\r\n\r\n            effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\r\n            effect.setFloat(\"exposure\", this.exposure);\r\n            effect.setFloat(\"decay\", this.decay);\r\n            effect.setFloat(\"weight\", this.weight);\r\n            effect.setFloat(\"density\", this.density);\r\n            effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n     * @returns \"VolumetricLightScatteringPostProcess\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VolumetricLightScatteringPostProcess\";\r\n    }\r\n\r\n    private _isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Render this.mesh as default\r\n        if (mesh === this.mesh && mesh.material) {\r\n            return mesh.material.isReady(mesh);\r\n        }\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind];\r\n        const material: any = subMesh.getMaterial();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n            }\r\n\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        const join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._volumetricLightScatteringPass.effect = mesh\r\n                .getScene()\r\n                .getEngine()\r\n                .createEffect(\r\n                    \"volumetricLightScatteringPass\",\r\n                    attribs,\r\n                    [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"],\r\n                    [\"diffuseSampler\"],\r\n                    join,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: mesh.numBoneInfluencers }\r\n                );\r\n        }\r\n\r\n        return this._volumetricLightScatteringPass.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Sets the new light position for light scattering effect\r\n     * @param position The new custom light position\r\n     */\r\n    public setCustomMeshPosition(position: Vector3): void {\r\n        this.customMeshPosition = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the light position for light scattering effect\r\n     * @return Vector3 The custom light position\r\n     */\r\n    public getCustomMeshPosition(): Vector3 {\r\n        return this.customMeshPosition;\r\n    }\r\n\r\n    /**\r\n     * Disposes the internal assets and detaches the post-process from the camera\r\n     * @param camera\r\n     */\r\n    public dispose(camera: Camera): void {\r\n        const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\r\n        if (rttIndex !== -1) {\r\n            camera.getScene().customRenderTargets.splice(rttIndex, 1);\r\n        }\r\n\r\n        this._volumetricLightScatteringRTT.dispose();\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Returns the render target texture used by the post-process\r\n     * @return the render target texture used by the post-process\r\n     */\r\n    public getPass(): RenderTargetTexture {\r\n        return this._volumetricLightScatteringRTT;\r\n    }\r\n\r\n    // Private methods\r\n    private _meshExcluded(mesh: AbstractMesh) {\r\n        if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _createPass(scene: Scene, ratio: number): void {\r\n        const engine = scene.getEngine();\r\n\r\n        this._volumetricLightScatteringRTT = new RenderTargetTexture(\r\n            \"volumetricLightScatteringMap\",\r\n            { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio },\r\n            scene,\r\n            false,\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.renderList = null;\r\n        this._volumetricLightScatteringRTT.renderParticles = false;\r\n        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\r\n\r\n        const camera = this.getCamera();\r\n        if (camera) {\r\n            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        } else {\r\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        }\r\n\r\n        // Custom render function for submeshes\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            if (this._meshExcluded(renderingMesh)) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            const material = subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            const scene = renderingMesh.getScene();\r\n            const engine = scene.getEngine();\r\n\r\n            // Culling\r\n            engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n            if (this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                let drawWrapper: DrawWrapper = this._volumetricLightScatteringPass;\r\n                if (renderingMesh === this.mesh) {\r\n                    if (subMesh.effect) {\r\n                        drawWrapper = subMesh._drawWrapper;\r\n                    } else {\r\n                        drawWrapper = material._getDrawWrapper();\r\n                    }\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (renderingMesh === this.mesh) {\r\n                    material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\r\n                } else {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                    // Alpha test\r\n                    if (material && material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n                    if (!isInstance) {\r\n                        effect.setMatrix(\"world\", world);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        // Render target texture callbacks\r\n        let savedSceneClearColor: Color4;\r\n        const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\r\n\r\n        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((): void => {\r\n            savedSceneClearColor = scene.clearColor;\r\n            scene.clearColor = sceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.onAfterRenderObservable.add((): void => {\r\n            scene.clearColor = savedSceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number) => {\r\n            if (!mesh.isReady(false)) {\r\n                return false;\r\n            }\r\n            if (refreshRate === 0 && mesh.subMeshes) {\r\n                // full check: check that the effects are ready\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        this._volumetricLightScatteringRTT.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            const engine = scene.getEngine();\r\n            let index: number;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (transparentSubMeshes.length) {\r\n                // Sort sub meshes\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    const submesh = transparentSubMeshes.data[index];\r\n                    const boundingInfo = submesh.getBoundingInfo();\r\n\r\n                    if (boundingInfo && scene.activeCamera) {\r\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\r\n                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\r\n                    }\r\n                }\r\n\r\n                const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\r\n                sortedArray.sort((a, b) => {\r\n                    // Alpha index first\r\n                    if (a._alphaIndex > b._alphaIndex) {\r\n                        return 1;\r\n                    }\r\n                    if (a._alphaIndex < b._alphaIndex) {\r\n                        return -1;\r\n                    }\r\n\r\n                    // Then distance to camera\r\n                    if (a._distanceToCamera < b._distanceToCamera) {\r\n                        return 1;\r\n                    }\r\n                    if (a._distanceToCamera > b._distanceToCamera) {\r\n                        return -1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n\r\n                // Render sub meshes\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                for (index = 0; index < sortedArray.length; index++) {\r\n                    renderSubMesh(sortedArray[index]);\r\n                }\r\n                engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n            }\r\n        };\r\n    }\r\n\r\n    private _updateMeshScreenCoordinates(scene: Scene): void {\r\n        const transform = scene.getTransformMatrix();\r\n        let meshPosition: Vector3;\r\n\r\n        if (this.useCustomMeshPosition) {\r\n            meshPosition = this.customMeshPosition;\r\n        } else if (this.attachedNode) {\r\n            meshPosition = this.attachedNode.position;\r\n        } else {\r\n            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\r\n        }\r\n\r\n        const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\r\n\r\n        this._screenCoordinates.x = pos.x / this._viewPort.width;\r\n        this._screenCoordinates.y = pos.y / this._viewPort.height;\r\n\r\n        if (this.invert) {\r\n            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    // Static methods\r\n    /**\r\n     * Creates a default mesh for the Volumeric Light Scattering post-process\r\n     * @param name The mesh name\r\n     * @param scene The scene where to create the mesh\r\n     * @return the default mesh\r\n     */\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreatePlane(name, { size: 1 }, scene);\r\n        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\r\n\r\n        const material = new StandardMaterial(name + \"Material\", scene);\r\n        material.emissiveColor = new Color3(1, 1, 1);\r\n\r\n        mesh.material = material;\r\n\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);\r\n"]},"metadata":{},"sourceType":"module"}