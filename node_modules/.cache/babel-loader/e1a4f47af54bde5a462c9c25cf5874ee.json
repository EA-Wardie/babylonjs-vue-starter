{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController.js\";\nimport { Xbox360Pad } from \"./xboxGamepad.js\";\nimport { Gamepad, GenericPad } from \"./gamepad.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { DualShockPad } from \"./dualShockGamepad.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * Manager for handling gamepads\n */\n\nvar GamepadManager =\n/** @class */\nfunction () {\n  /**\n   * Initializes the gamepad manager\n   * @param _scene BabylonJS scene\n   */\n  function GamepadManager(_scene) {\n    var _this = this;\n\n    this._scene = _scene;\n    this._babylonGamepads = [];\n    this._oneGamepadConnected = false;\n    /** @hidden */\n\n    this._isMonitoring = false;\n    /**\n     * observable to be triggered when the gamepad controller has been disconnected\n     */\n\n    this.onGamepadDisconnectedObservable = new Observable();\n\n    if (!IsWindowObjectExist()) {\n      this._gamepadEventSupported = false;\n    } else {\n      this._gamepadEventSupported = \"GamepadEvent\" in window;\n      this._gamepadSupport = navigator && (navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads);\n    }\n\n    this.onGamepadConnectedObservable = new Observable(function (observer) {\n      // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\n      for (var i in _this._babylonGamepads) {\n        var gamepad = _this._babylonGamepads[i];\n\n        if (gamepad && gamepad._isConnected) {\n          _this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\n        }\n      }\n    });\n\n    this._onGamepadConnectedEvent = function (evt) {\n      var gamepad = evt.gamepad;\n\n      if (gamepad.index in _this._babylonGamepads) {\n        if (_this._babylonGamepads[gamepad.index].isConnected) {\n          return;\n        }\n      }\n\n      var newGamepad;\n\n      if (_this._babylonGamepads[gamepad.index]) {\n        newGamepad = _this._babylonGamepads[gamepad.index];\n        newGamepad.browserGamepad = gamepad;\n        newGamepad._isConnected = true;\n      } else {\n        newGamepad = _this._addNewGamepad(gamepad);\n      }\n\n      _this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n\n      _this._startMonitoringGamepads();\n    };\n\n    this._onGamepadDisconnectedEvent = function (evt) {\n      var gamepad = evt.gamepad; // Remove the gamepad from the list of gamepads to monitor.\n\n      for (var i in _this._babylonGamepads) {\n        if (_this._babylonGamepads[i].index === gamepad.index) {\n          var disconnectedGamepad = _this._babylonGamepads[i];\n          disconnectedGamepad._isConnected = false;\n\n          _this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\n\n          disconnectedGamepad.dispose && disconnectedGamepad.dispose();\n          break;\n        }\n      }\n    };\n\n    if (this._gamepadSupport) {\n      //first add already-connected gamepads\n      this._updateGamepadObjects();\n\n      if (this._babylonGamepads.length) {\n        this._startMonitoringGamepads();\n      } // Checking if the gamepad connected event is supported (like in Firefox)\n\n\n      if (this._gamepadEventSupported) {\n        var hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\n\n        if (hostWindow) {\n          hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\n          hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\n        }\n      } else {\n        this._startMonitoringGamepads();\n      }\n    }\n  }\n\n  Object.defineProperty(GamepadManager.prototype, \"gamepads\", {\n    /**\n     * The gamepads in the game pad manager\n     */\n    get: function get() {\n      return this._babylonGamepads;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Get the gamepad controllers based on type\n   * @param type The type of gamepad controller\n   * @returns Nullable gamepad\n   */\n\n  GamepadManager.prototype.getGamepadByType = function (type) {\n    if (type === void 0) {\n      type = Gamepad.XBOX;\n    }\n\n    for (var _i = 0, _a = this._babylonGamepads; _i < _a.length; _i++) {\n      var gamepad = _a[_i];\n\n      if (gamepad && gamepad.type === type) {\n        return gamepad;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Disposes the gamepad manager\n   */\n\n\n  GamepadManager.prototype.dispose = function () {\n    if (this._gamepadEventSupported) {\n      if (this._onGamepadConnectedEvent) {\n        window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\n      }\n\n      if (this._onGamepadDisconnectedEvent) {\n        window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\n      }\n\n      this._onGamepadConnectedEvent = null;\n      this._onGamepadDisconnectedEvent = null;\n    }\n\n    this._babylonGamepads.forEach(function (gamepad) {\n      gamepad.dispose();\n    });\n\n    this.onGamepadConnectedObservable.clear();\n    this.onGamepadDisconnectedObservable.clear();\n    this._oneGamepadConnected = false;\n\n    this._stopMonitoringGamepads();\n\n    this._babylonGamepads = [];\n  };\n\n  GamepadManager.prototype._addNewGamepad = function (gamepad) {\n    if (!this._oneGamepadConnected) {\n      this._oneGamepadConnected = true;\n    }\n\n    var newGamepad;\n    var dualShock = gamepad.id.search(\"054c\") !== -1 && gamepad.id.search(\"0ce6\") === -1;\n    var xboxOne = gamepad.id.search(\"Xbox One\") !== -1;\n\n    if (xboxOne || gamepad.id.search(\"Xbox 360\") !== -1 || gamepad.id.search(\"xinput\") !== -1 || gamepad.id.search(\"045e\") !== -1 && gamepad.id.search(\"Surface Dock\") === -1) {\n      // make sure the Surface Dock Extender is not detected as an xbox controller\n      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\n    } else if (dualShock) {\n      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\n    } // if pose is supported, use the (WebVR) pose enabled controller\n    else if (gamepad.pose) {\n      newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\n    } else {\n      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\n    }\n\n    this._babylonGamepads[newGamepad.index] = newGamepad;\n    return newGamepad;\n  };\n\n  GamepadManager.prototype._startMonitoringGamepads = function () {\n    if (!this._isMonitoring) {\n      this._isMonitoring = true; //back-comp\n\n      if (!this._scene) {\n        this._checkGamepadsStatus();\n      }\n    }\n  };\n\n  GamepadManager.prototype._stopMonitoringGamepads = function () {\n    this._isMonitoring = false;\n  };\n  /** @hidden */\n\n\n  GamepadManager.prototype._checkGamepadsStatus = function () {\n    var _this = this; // Hack to be compatible Chrome\n\n\n    this._updateGamepadObjects();\n\n    for (var i in this._babylonGamepads) {\n      var gamepad = this._babylonGamepads[i];\n\n      if (!gamepad || !gamepad.isConnected) {\n        continue;\n      }\n\n      try {\n        gamepad.update();\n      } catch (_a) {\n        if (this._loggedErrors.indexOf(gamepad.index) === -1) {\n          Tools.Warn(\"Error updating gamepad \".concat(gamepad.id));\n\n          this._loggedErrors.push(gamepad.index);\n        }\n      }\n    }\n\n    if (this._isMonitoring && !this._scene) {\n      Engine.QueueNewFrame(function () {\n        _this._checkGamepadsStatus();\n      });\n    }\n  }; // This function is called only on Chrome, which does not properly support\n  // connection/disconnection events and forces you to recopy again the gamepad object\n\n\n  GamepadManager.prototype._updateGamepadObjects = function () {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [];\n\n    for (var i = 0; i < gamepads.length; i++) {\n      var gamepad = gamepads[i];\n\n      if (gamepad) {\n        if (!this._babylonGamepads[gamepad.index]) {\n          var newGamepad = this._addNewGamepad(gamepad);\n\n          this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n        } else {\n          // Forced to copy again this object for Chrome for unknown reason\n          this._babylonGamepads[i].browserGamepad = gamepad;\n\n          if (!this._babylonGamepads[i].isConnected) {\n            this._babylonGamepads[i]._isConnected = true;\n            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\n          }\n        }\n      }\n    }\n  };\n\n  return GamepadManager;\n}();\n\nexport { GamepadManager };","map":{"version":3,"mappings":"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","names":["Observable","IsWindowObjectExist","PoseEnabledControllerHelper","Xbox360Pad","Gamepad","GenericPad","Engine","DualShockPad","Tools","_scene","_gamepadEventSupported","window","_gamepadSupport","navigator","getGamepads","webkitGetGamepads","msGetGamepads","webkitGamepads","onGamepadConnectedObservable","observer","i","_this","_babylonGamepads","gamepad","_isConnected","notifyObserver","_onGamepadConnectedEvent","evt","index","isConnected","newGamepad","browserGamepad","_addNewGamepad","notifyObservers","_startMonitoringGamepads","_onGamepadDisconnectedEvent","disconnectedGamepad","onGamepadDisconnectedObservable","dispose","_updateGamepadObjects","length","hostWindow","getEngine","getHostWindow","addEventListener","Object","GamepadManager","type","XBOX","_i","removeEventListener","forEach","clear","_oneGamepadConnected","_stopMonitoringGamepads","dualShock","id","search","xboxOne","pose","InitiateController","_isMonitoring","_checkGamepadsStatus","update","_loggedErrors","indexOf","Warn","push","QueueNewFrame","gamepads"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gamepads/gamepadManager.ts"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @hidden */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && (navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads);\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        // if pose is supported, use the (WebVR) pose enabled controller\r\n        else if (gamepad.pose) {\r\n            newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            if (!this._scene) {\r\n                this._checkGamepadsStatus();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @hidden */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring && !this._scene) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}