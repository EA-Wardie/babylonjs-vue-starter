{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { Observable } from \"./observable.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager.js\";\nimport \"../Shaders/minmaxRedux.fragment.js\";\n/**\n * This class computes a min/max reduction from a texture: it means it computes the minimum\n * and maximum values from all values of the texture.\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\n * The source values are read from the red channel of the texture.\n */\n\nvar MinMaxReducer =\n/** @class */\nfunction () {\n  /**\n   * Creates a min/max reducer\n   * @param camera The camera to use for the post processes\n   */\n  function MinMaxReducer(camera) {\n    var _this = this;\n    /**\n     * Observable triggered when the computation has been performed\n     */\n\n\n    this.onAfterReductionPerformed = new Observable();\n    this._forceFullscreenViewport = true;\n    this._activated = false;\n    this._camera = camera;\n    this._postProcessManager = new PostProcessManager(camera.getScene());\n    this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(function () {\n      _this._postProcessManager._rebuild();\n    });\n  }\n\n  Object.defineProperty(MinMaxReducer.prototype, \"sourceTexture\", {\n    /**\n     * Gets the texture used to read the values from.\n     */\n    get: function get() {\n      return this._sourceTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets the source texture to read the values from.\n   * One must indicate if the texture is a depth texture or not through the depthRedux parameter\n   * because in such textures '1' value must not be taken into account to compute the maximum\n   * as this value is used to clear the texture.\n   * Note that the computation is not activated by calling this function, you must call activate() for that!\n   * @param sourceTexture The texture to read the values from. The values should be in the red channel.\n   * @param depthRedux Indicates if the texture is a depth texture or not\n   * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\n   * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n   */\n\n  MinMaxReducer.prototype.setSourceTexture = function (sourceTexture, depthRedux, type, forceFullscreenViewport) {\n    var _this = this;\n\n    if (type === void 0) {\n      type = 2;\n    }\n\n    if (forceFullscreenViewport === void 0) {\n      forceFullscreenViewport = true;\n    }\n\n    if (sourceTexture === this._sourceTexture) {\n      return;\n    }\n\n    this.dispose(false);\n    this._sourceTexture = sourceTexture;\n    this._reductionSteps = [];\n    this._forceFullscreenViewport = forceFullscreenViewport;\n\n    var scene = this._camera.getScene(); // create the first step\n\n\n    var reductionInitial = new PostProcess(\"Initial reduction phase\", \"minmaxRedux\", // shader\n    [\"texSize\"], [\"sourceTexture\"], // textures\n    1.0, // options\n    null, // camera\n    1, // sampling\n    scene.getEngine(), // engine\n    false, // reusable\n    \"#define INITIAL\" + (depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\"), // defines\n    type, undefined, undefined, undefined, 7);\n    reductionInitial.autoClear = false;\n    reductionInitial.forceFullscreenViewport = forceFullscreenViewport;\n\n    var w = this._sourceTexture.getRenderWidth(),\n        h = this._sourceTexture.getRenderHeight();\n\n    reductionInitial.onApply = function (w, h) {\n      return function (effect) {\n        effect.setTexture(\"sourceTexture\", _this._sourceTexture);\n        effect.setFloat2(\"texSize\", w, h);\n      };\n    }(w, h);\n\n    this._reductionSteps.push(reductionInitial);\n\n    var index = 1; // create the additional steps\n\n    while (w > 1 || h > 1) {\n      w = Math.max(Math.round(w / 2), 1);\n      h = Math.max(Math.round(h / 2), 1);\n      var reduction = new PostProcess(\"Reduction phase \" + index, \"minmaxRedux\", // shader\n      [\"texSize\"], null, {\n        width: w,\n        height: h\n      }, // options\n      null, // camera\n      1, // sampling\n      scene.getEngine(), // engine\n      false, // reusable\n      \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"), // defines\n      type, undefined, undefined, undefined, 7);\n      reduction.autoClear = false;\n      reduction.forceFullscreenViewport = forceFullscreenViewport;\n\n      reduction.onApply = function (w, h) {\n        return function (effect) {\n          if (w == 1 || h == 1) {\n            effect.setInt2(\"texSize\", w, h);\n          } else {\n            effect.setFloat2(\"texSize\", w, h);\n          }\n        };\n      }(w, h);\n\n      this._reductionSteps.push(reduction);\n\n      index++;\n\n      if (w == 1 && h == 1) {\n        var func = function func(w, h, reduction) {\n          var buffer = new Float32Array(4 * w * h),\n              minmax = {\n            min: 0,\n            max: 0\n          };\n          return function () {\n            scene.getEngine()._readTexturePixels(reduction.inputTexture.texture, w, h, -1, 0, buffer, false);\n\n            minmax.min = buffer[0];\n            minmax.max = buffer[1];\n\n            _this.onAfterReductionPerformed.notifyObservers(minmax);\n          };\n        };\n\n        reduction.onAfterRenderObservable.add(func(w, h, reduction));\n      }\n    }\n  };\n\n  Object.defineProperty(MinMaxReducer.prototype, \"refreshRate\", {\n    /**\n     * Defines the refresh rate of the computation.\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     */\n    get: function get() {\n      return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\n    },\n    set: function set(value) {\n      if (this._sourceTexture) {\n        this._sourceTexture.refreshRate = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MinMaxReducer.prototype, \"activated\", {\n    /**\n     * Gets the activation status of the reducer\n     */\n    get: function get() {\n      return this._activated;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Activates the reduction computation.\n   * When activated, the observers registered in onAfterReductionPerformed are\n   * called after the computation is performed\n   */\n\n  MinMaxReducer.prototype.activate = function () {\n    var _this = this;\n\n    if (this._onAfterUnbindObserver || !this._sourceTexture) {\n      return;\n    }\n\n    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(function () {\n      var _a, _b;\n\n      var engine = _this._camera.getScene().getEngine();\n\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"min max reduction\", 1);\n\n      _this._reductionSteps[0].activate(_this._camera);\n\n      _this._postProcessManager.directRender(_this._reductionSteps, _this._reductionSteps[0].inputTexture, _this._forceFullscreenViewport);\n\n      engine.unBindFramebuffer(_this._reductionSteps[0].inputTexture, false);\n      (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n    });\n    this._activated = true;\n  };\n  /**\n   * Deactivates the reduction computation.\n   */\n\n\n  MinMaxReducer.prototype.deactivate = function () {\n    if (!this._onAfterUnbindObserver || !this._sourceTexture) {\n      return;\n    }\n\n    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n\n    this._onAfterUnbindObserver = null;\n    this._activated = false;\n  };\n  /**\n   * Disposes the min/max reducer\n   * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n   */\n\n\n  MinMaxReducer.prototype.dispose = function (disposeAll) {\n    if (disposeAll === void 0) {\n      disposeAll = true;\n    }\n\n    if (disposeAll) {\n      this.onAfterReductionPerformed.clear();\n\n      if (this._onContextRestoredObserver) {\n        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n\n        this._onContextRestoredObserver = null;\n      }\n    }\n\n    this.deactivate();\n\n    if (this._reductionSteps) {\n      for (var i = 0; i < this._reductionSteps.length; ++i) {\n        this._reductionSteps[i].dispose();\n      }\n\n      this._reductionSteps = null;\n    }\n\n    if (this._postProcessManager && disposeAll) {\n      this._postProcessManager.dispose();\n    }\n\n    this._sourceTexture = null;\n  };\n\n  return MinMaxReducer;\n}();\n\nexport { MinMaxReducer };","map":{"version":3,"mappings":"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","names":["Observable","PostProcess","PostProcessManager","camera","_camera","_postProcessManager","getScene","_onContextRestoredObserver","getEngine","onContextRestoredObservable","add","_this","_rebuild","Object","MinMaxReducer","_sourceTexture","sourceTexture","depthRedux","type","forceFullscreenViewport","dispose","_reductionSteps","_forceFullscreenViewport","scene","reductionInitial","undefined","autoClear","w","getRenderWidth","h","getRenderHeight","onApply","effect","setTexture","setFloat2","push","index","Math","max","round","reduction","width","height","setInt2","func","buffer","Float32Array","minmax","min","_readTexturePixels","inputTexture","texture","onAfterReductionPerformed","notifyObservers","onAfterRenderObservable","refreshRate","value","_activated","_onAfterUnbindObserver","onAfterUnbindObservable","engine","_debugPushGroup","_a","activate","directRender","unBindFramebuffer","_debugPopGroup","_b","remove","disposeAll","clear","deactivate","i","length"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/minMaxReducer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Observer } from \"./observable\";\r\nimport { Observable } from \"./observable\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\nimport \"../Shaders/minmaxRedux.fragment\";\r\n\r\n/**\r\n * This class computes a min/max reduction from a texture: it means it computes the minimum\r\n * and maximum values from all values of the texture.\r\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\r\n * The source values are read from the red channel of the texture.\r\n */\r\nexport class MinMaxReducer {\r\n    /**\r\n     * Observable triggered when the computation has been performed\r\n     */\r\n    public onAfterReductionPerformed = new Observable<{ min: number; max: number }>();\r\n\r\n    protected _camera: Camera;\r\n    protected _sourceTexture: Nullable<RenderTargetTexture>;\r\n    protected _reductionSteps: Nullable<Array<PostProcess>>;\r\n    protected _postProcessManager: PostProcessManager;\r\n    protected _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    protected _forceFullscreenViewport = true;\r\n    protected _onContextRestoredObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * Creates a min/max reducer\r\n     * @param camera The camera to use for the post processes\r\n     */\r\n    constructor(camera: Camera) {\r\n        this._camera = camera;\r\n        this._postProcessManager = new PostProcessManager(camera.getScene());\r\n\r\n        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {\r\n            this._postProcessManager._rebuild();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used to read the values from.\r\n     */\r\n    public get sourceTexture(): Nullable<RenderTargetTexture> {\r\n        return this._sourceTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the source texture to read the values from.\r\n     * One must indicate if the texture is a depth texture or not through the depthRedux parameter\r\n     * because in such textures '1' value must not be taken into account to compute the maximum\r\n     * as this value is used to clear the texture.\r\n     * Note that the computation is not activated by calling this function, you must call activate() for that!\r\n     * @param sourceTexture The texture to read the values from. The values should be in the red channel.\r\n     * @param depthRedux Indicates if the texture is a depth texture or not\r\n     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\r\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\r\n     */\r\n    public setSourceTexture(sourceTexture: RenderTargetTexture, depthRedux: boolean, type: number = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true): void {\r\n        if (sourceTexture === this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this.dispose(false);\r\n\r\n        this._sourceTexture = sourceTexture;\r\n        this._reductionSteps = [];\r\n        this._forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n        const scene = this._camera.getScene();\r\n\r\n        // create the first step\r\n        const reductionInitial = new PostProcess(\r\n            \"Initial reduction phase\",\r\n            \"minmaxRedux\", // shader\r\n            [\"texSize\"],\r\n            [\"sourceTexture\"], // textures\r\n            1.0, // options\r\n            null, // camera\r\n            Constants.TEXTURE_NEAREST_NEAREST, // sampling\r\n            scene.getEngine(), // engine\r\n            false, // reusable\r\n            \"#define INITIAL\" + (depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\"), // defines\r\n            type,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            Constants.TEXTUREFORMAT_RG\r\n        );\r\n\r\n        reductionInitial.autoClear = false;\r\n        reductionInitial.forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n        let w = this._sourceTexture.getRenderWidth(),\r\n            h = this._sourceTexture.getRenderHeight();\r\n\r\n        reductionInitial.onApply = ((w: number, h: number) => {\r\n            return (effect: Effect) => {\r\n                effect.setTexture(\"sourceTexture\", this._sourceTexture);\r\n                effect.setFloat2(\"texSize\", w, h);\r\n            };\r\n        })(w, h);\r\n\r\n        this._reductionSteps.push(reductionInitial);\r\n\r\n        let index = 1;\r\n\r\n        // create the additional steps\r\n        while (w > 1 || h > 1) {\r\n            w = Math.max(Math.round(w / 2), 1);\r\n            h = Math.max(Math.round(h / 2), 1);\r\n\r\n            const reduction = new PostProcess(\r\n                \"Reduction phase \" + index,\r\n                \"minmaxRedux\", // shader\r\n                [\"texSize\"],\r\n                null,\r\n                { width: w, height: h }, // options\r\n                null, // camera\r\n                Constants.TEXTURE_NEAREST_NEAREST, // sampling\r\n                scene.getEngine(), // engine\r\n                false, // reusable\r\n                \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"), // defines\r\n                type,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                Constants.TEXTUREFORMAT_RG\r\n            );\r\n\r\n            reduction.autoClear = false;\r\n            reduction.forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n            reduction.onApply = ((w: number, h: number) => {\r\n                return (effect: Effect) => {\r\n                    if (w == 1 || h == 1) {\r\n                        effect.setInt2(\"texSize\", w, h);\r\n                    } else {\r\n                        effect.setFloat2(\"texSize\", w, h);\r\n                    }\r\n                };\r\n            })(w, h);\r\n\r\n            this._reductionSteps.push(reduction);\r\n\r\n            index++;\r\n\r\n            if (w == 1 && h == 1) {\r\n                const func = (w: number, h: number, reduction: PostProcess) => {\r\n                    const buffer = new Float32Array(4 * w * h),\r\n                        minmax = { min: 0, max: 0 };\r\n                    return () => {\r\n                        scene.getEngine()._readTexturePixels(reduction.inputTexture.texture!, w, h, -1, 0, buffer, false);\r\n                        minmax.min = buffer[0];\r\n                        minmax.max = buffer[1];\r\n                        this.onAfterReductionPerformed.notifyObservers(minmax);\r\n                    };\r\n                };\r\n                reduction.onAfterRenderObservable.add(func(w, h, reduction));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the computation.\r\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        if (this._sourceTexture) {\r\n            this._sourceTexture.refreshRate = value;\r\n        }\r\n    }\r\n\r\n    protected _activated = false;\r\n\r\n    /**\r\n     * Gets the activation status of the reducer\r\n     */\r\n    public get activated(): boolean {\r\n        return this._activated;\r\n    }\r\n\r\n    /**\r\n     * Activates the reduction computation.\r\n     * When activated, the observers registered in onAfterReductionPerformed are\r\n     * called after the computation is performed\r\n     */\r\n    public activate(): void {\r\n        if (this._onAfterUnbindObserver || !this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {\r\n            const engine = this._camera.getScene().getEngine();\r\n            engine._debugPushGroup?.(`min max reduction`, 1);\r\n            this._reductionSteps![0].activate(this._camera);\r\n            this._postProcessManager.directRender(this._reductionSteps!, this._reductionSteps![0].inputTexture, this._forceFullscreenViewport);\r\n            engine.unBindFramebuffer(this._reductionSteps![0].inputTexture, false);\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._activated = true;\r\n    }\r\n\r\n    /**\r\n     * Deactivates the reduction computation.\r\n     */\r\n    public deactivate(): void {\r\n        if (!this._onAfterUnbindObserver || !this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        this._onAfterUnbindObserver = null;\r\n        this._activated = false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the min/max reducer\r\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\r\n     */\r\n    public dispose(disposeAll = true): void {\r\n        if (disposeAll) {\r\n            this.onAfterReductionPerformed.clear();\r\n\r\n            if (this._onContextRestoredObserver) {\r\n                this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n                this._onContextRestoredObserver = null;\r\n            }\r\n        }\r\n\r\n        this.deactivate();\r\n\r\n        if (this._reductionSteps) {\r\n            for (let i = 0; i < this._reductionSteps.length; ++i) {\r\n                this._reductionSteps[i].dispose();\r\n            }\r\n            this._reductionSteps = null;\r\n        }\r\n\r\n        if (this._postProcessManager && disposeAll) {\r\n            this._postProcessManager.dispose();\r\n        }\r\n\r\n        this._sourceTexture = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}