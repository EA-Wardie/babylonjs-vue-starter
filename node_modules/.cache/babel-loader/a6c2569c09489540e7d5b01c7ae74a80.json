{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport { __assign } from \"tslib\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Effect } from \"./effect.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\"; // Prevents ES6 Crash if not imported.\n\nimport \"../Shaders/postprocess.vertex.js\";\n/**\n * Helper class to render one or more effects.\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\n */\n\nvar EffectRenderer =\n/** @class */\nfunction () {\n  /**\n   * Creates an effect renderer\n   * @param _engine the engine to use for rendering\n   * @param options defines the options of the effect renderer\n   */\n  function EffectRenderer(_engine, options) {\n    var _a;\n\n    if (options === void 0) {\n      options = EffectRenderer._DefaultOptions;\n    }\n\n    var _this = this;\n\n    this._engine = _engine;\n    this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n    options = __assign(__assign({}, EffectRenderer._DefaultOptions), options);\n    this._vertexBuffers = (_a = {}, _a[VertexBuffer.PositionKind] = new VertexBuffer(_engine, options.positions, VertexBuffer.PositionKind, false, false, 2), _a);\n    this._indexBuffer = _engine.createIndexBuffer(options.indices);\n    this._onContextRestoredObserver = _engine.onContextRestoredObservable.add(function () {\n      _this._indexBuffer = _engine.createIndexBuffer(options.indices);\n\n      for (var key in _this._vertexBuffers) {\n        var vertexBuffer = _this._vertexBuffers[key];\n\n        vertexBuffer._rebuild();\n      }\n    });\n  }\n  /**\n   * Sets the current viewport in normalized coordinates 0-1\n   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\n   */\n\n\n  EffectRenderer.prototype.setViewport = function (viewport) {\n    if (viewport === void 0) {\n      viewport = this._fullscreenViewport;\n    }\n\n    this._engine.setViewport(viewport);\n  };\n  /**\n   * Binds the embedded attributes buffer to the effect.\n   * @param effect Defines the effect to bind the attributes for\n   */\n\n\n  EffectRenderer.prototype.bindBuffers = function (effect) {\n    this._engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n  };\n  /**\n   * Sets the current effect wrapper to use during draw.\n   * The effect needs to be ready before calling this api.\n   * This also sets the default full screen position attribute.\n   * @param effectWrapper Defines the effect to draw with\n   */\n\n\n  EffectRenderer.prototype.applyEffectWrapper = function (effectWrapper) {\n    this._engine.depthCullingState.depthTest = false;\n    this._engine.stencilState.stencilTest = false;\n\n    this._engine.enableEffect(effectWrapper._drawWrapper);\n\n    this.bindBuffers(effectWrapper.effect);\n    effectWrapper.onApplyObservable.notifyObservers({});\n  };\n  /**\n   * Restores engine states\n   */\n\n\n  EffectRenderer.prototype.restoreStates = function () {\n    this._engine.depthCullingState.depthTest = true;\n    this._engine.stencilState.stencilTest = true;\n  };\n  /**\n   * Draws a full screen quad.\n   */\n\n\n  EffectRenderer.prototype.draw = function () {\n    this._engine.drawElementsType(0, 0, 6);\n  };\n\n  EffectRenderer.prototype._isRenderTargetTexture = function (texture) {\n    return texture.renderTarget !== undefined;\n  };\n  /**\n   * renders one or more effects to a specified texture\n   * @param effectWrapper the effect to renderer\n   * @param outputTexture texture to draw to, if null it will render to the screen.\n   */\n\n\n  EffectRenderer.prototype.render = function (effectWrapper, outputTexture) {\n    if (outputTexture === void 0) {\n      outputTexture = null;\n    } // Ensure effect is ready\n\n\n    if (!effectWrapper.effect.isReady()) {\n      return;\n    } // Reset state\n\n\n    this.setViewport();\n    var out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;\n\n    if (out) {\n      this._engine.bindFramebuffer(out);\n    }\n\n    this.applyEffectWrapper(effectWrapper);\n    this.draw();\n\n    if (out) {\n      this._engine.unBindFramebuffer(out);\n    }\n\n    this.restoreStates();\n  };\n  /**\n   * Disposes of the effect renderer\n   */\n\n\n  EffectRenderer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      delete this._vertexBuffers[VertexBuffer.PositionKind];\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    if (this._onContextRestoredObserver) {\n      this._engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);\n\n      this._onContextRestoredObserver = null;\n    }\n  }; // Fullscreen quad buffers by default.\n\n\n  EffectRenderer._DefaultOptions = {\n    positions: [1, 1, -1, 1, -1, -1, 1, -1],\n    indices: [0, 1, 2, 0, 2, 3]\n  };\n  return EffectRenderer;\n}();\n\nexport { EffectRenderer };\n/**\n * Wraps an effect to be used for rendering\n */\n\nvar EffectWrapper =\n/** @class */\nfunction () {\n  /**\n   * Creates an effect to be renderer\n   * @param creationOptions options to create the effect\n   */\n  function EffectWrapper(creationOptions) {\n    var _this = this;\n    /**\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\n     */\n\n\n    this.onApplyObservable = new Observable();\n    var effectCreationOptions;\n    var uniformNames = creationOptions.uniformNames || [];\n\n    if (creationOptions.vertexShader) {\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertexSource: creationOptions.vertexShader,\n        spectorName: creationOptions.name || \"effectWrapper\"\n      };\n    } else {\n      // Default scale to use in post process vertex shader.\n      uniformNames.push(\"scale\");\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertex: \"postprocess\",\n        spectorName: creationOptions.name || \"effectWrapper\"\n      }; // Sets the default scale to identity for the post process vertex shader.\n\n      this.onApplyObservable.add(function () {\n        _this.effect.setFloat2(\"scale\", 1, 1);\n      });\n    }\n\n    var defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\n    this._drawWrapper = new DrawWrapper(creationOptions.engine);\n\n    if (creationOptions.useShaderStore) {\n      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\n\n      if (!effectCreationOptions.vertex) {\n        effectCreationOptions.vertex = effectCreationOptions.vertexSource;\n      }\n\n      delete effectCreationOptions.fragmentSource;\n      delete effectCreationOptions.vertexSource;\n      this.effect = creationOptions.engine.createEffect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, defines, undefined, creationOptions.onCompiled, undefined, undefined, creationOptions.shaderLanguage);\n    } else {\n      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, undefined, creationOptions.onCompiled, undefined, undefined, undefined, creationOptions.shaderLanguage);\n      this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(function () {\n        _this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\n\n        _this.effect._wasPreviouslyReady = false;\n\n        _this.effect._prepareEffect();\n      });\n    }\n  }\n\n  Object.defineProperty(EffectWrapper.prototype, \"effect\", {\n    /**\n     * The underlying effect\n     */\n    get: function get() {\n      return this._drawWrapper.effect;\n    },\n    set: function set(effect) {\n      this._drawWrapper.effect = effect;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes of the effect wrapper\n   */\n\n  EffectWrapper.prototype.dispose = function () {\n    if (this._onContextRestoredObserver) {\n      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n      this._onContextRestoredObserver = null;\n    }\n\n    this.effect.dispose();\n  };\n\n  return EffectWrapper;\n}();\n\nexport { EffectWrapper };","map":{"version":3,"mappings":"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","names":["VertexBuffer","Viewport","Observable","Effect","DrawWrapper","_engine","options","EffectRenderer","_DefaultOptions","_vertexBuffers","_a","PositionKind","positions","_indexBuffer","createIndexBuffer","indices","_onContextRestoredObserver","onContextRestoredObservable","add","_this","key","vertexBuffer","_rebuild","viewport","_fullscreenViewport","setViewport","effect","bindBuffers","effectWrapper","depthCullingState","depthTest","stencilState","stencilTest","enableEffect","_drawWrapper","onApplyObservable","notifyObservers","drawElementsType","texture","renderTarget","undefined","outputTexture","isReady","out","_isRenderTargetTexture","bindFramebuffer","applyEffectWrapper","draw","unBindFramebuffer","restoreStates","dispose","_releaseBuffer","remove","creationOptions","effectCreationOptions","uniformNames","vertexShader","fragmentSource","fragmentShader","vertexSource","spectorName","name","push","vertex","setFloat2","defines","join","engine","useShaderStore","fragment","createEffect","attributeNames","samplerNames","onCompiled","shaderLanguage","_pipelineContext","_wasPreviouslyReady","_prepareEffect","Object","EffectWrapper","getEngine"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/effectRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Effect } from \"./effect\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n// Prevents ES6 Crash if not imported.\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * Effect Render Options\r\n */\r\nexport interface IEffectRendererOptions {\r\n    /**\r\n     * Defines the vertices positions.\r\n     */\r\n    positions?: number[];\r\n    /**\r\n     * Defines the indices.\r\n     */\r\n    indices?: number[];\r\n}\r\n\r\n/**\r\n * Helper class to render one or more effects.\r\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\r\n */\r\nexport class EffectRenderer {\r\n    // Fullscreen quad buffers by default.\r\n    private static _DefaultOptions: IEffectRendererOptions = {\r\n        positions: [1, 1, -1, 1, -1, -1, 1, -1],\r\n        indices: [0, 1, 2, 0, 2, 3],\r\n    };\r\n\r\n    private _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _indexBuffer: DataBuffer;\r\n\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _onContextRestoredObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * Creates an effect renderer\r\n     * @param _engine the engine to use for rendering\r\n     * @param options defines the options of the effect renderer\r\n     */\r\n    constructor(private _engine: ThinEngine, options: IEffectRendererOptions = EffectRenderer._DefaultOptions) {\r\n        options = {\r\n            ...EffectRenderer._DefaultOptions,\r\n            ...options,\r\n        };\r\n\r\n        this._vertexBuffers = {\r\n            [VertexBuffer.PositionKind]: new VertexBuffer(_engine, options.positions!, VertexBuffer.PositionKind, false, false, 2),\r\n        };\r\n        this._indexBuffer = _engine.createIndexBuffer(options.indices!);\r\n\r\n        this._onContextRestoredObserver = _engine.onContextRestoredObservable.add(() => {\r\n            this._indexBuffer = _engine.createIndexBuffer(options.indices!);\r\n\r\n            for (const key in this._vertexBuffers) {\r\n                const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n                vertexBuffer._rebuild();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current viewport in normalized coordinates 0-1\r\n     * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\r\n     */\r\n    public setViewport(viewport = this._fullscreenViewport): void {\r\n        this._engine.setViewport(viewport);\r\n    }\r\n\r\n    /**\r\n     * Binds the embedded attributes buffer to the effect.\r\n     * @param effect Defines the effect to bind the attributes for\r\n     */\r\n    public bindBuffers(effect: Effect): void {\r\n        this._engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n    }\r\n\r\n    /**\r\n     * Sets the current effect wrapper to use during draw.\r\n     * The effect needs to be ready before calling this api.\r\n     * This also sets the default full screen position attribute.\r\n     * @param effectWrapper Defines the effect to draw with\r\n     */\r\n    public applyEffectWrapper(effectWrapper: EffectWrapper): void {\r\n        this._engine.depthCullingState.depthTest = false;\r\n        this._engine.stencilState.stencilTest = false;\r\n        this._engine.enableEffect(effectWrapper._drawWrapper);\r\n        this.bindBuffers(effectWrapper.effect);\r\n        effectWrapper.onApplyObservable.notifyObservers({});\r\n    }\r\n\r\n    /**\r\n     * Restores engine states\r\n     */\r\n    public restoreStates(): void {\r\n        this._engine.depthCullingState.depthTest = true;\r\n        this._engine.stencilState.stencilTest = true;\r\n    }\r\n\r\n    /**\r\n     * Draws a full screen quad.\r\n     */\r\n    public draw(): void {\r\n        this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n    }\r\n\r\n    private _isRenderTargetTexture(texture: RenderTargetWrapper | IRenderTargetTexture): texture is IRenderTargetTexture {\r\n        return (texture as IRenderTargetTexture).renderTarget !== undefined;\r\n    }\r\n\r\n    /**\r\n     * renders one or more effects to a specified texture\r\n     * @param effectWrapper the effect to renderer\r\n     * @param outputTexture texture to draw to, if null it will render to the screen.\r\n     */\r\n    public render(effectWrapper: EffectWrapper, outputTexture: Nullable<RenderTargetWrapper | IRenderTargetTexture> = null) {\r\n        // Ensure effect is ready\r\n        if (!effectWrapper.effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        // Reset state\r\n        this.setViewport();\r\n\r\n        const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget! : outputTexture;\r\n\r\n        if (out) {\r\n            this._engine.bindFramebuffer(out);\r\n        }\r\n\r\n        this.applyEffectWrapper(effectWrapper);\r\n\r\n        this.draw();\r\n\r\n        if (out) {\r\n            this._engine.unBindFramebuffer(out);\r\n        }\r\n\r\n        this.restoreStates();\r\n    }\r\n\r\n    /**\r\n     * Disposes of the effect renderer\r\n     */\r\n    dispose() {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            delete this._vertexBuffers[VertexBuffer.PositionKind];\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        if (this._onContextRestoredObserver) {\r\n            this._engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to create an EffectWrapper\r\n */\r\ninterface EffectWrapperCreationOptions {\r\n    /**\r\n     * Engine to use to create the effect\r\n     */\r\n    engine: ThinEngine;\r\n    /**\r\n     * Fragment shader for the effect\r\n     */\r\n    fragmentShader: string;\r\n    /**\r\n     * Use the shader store instead of direct source code\r\n     */\r\n    useShaderStore?: boolean;\r\n    /**\r\n     * Vertex shader for the effect\r\n     */\r\n    vertexShader?: string;\r\n    /**\r\n     * Attributes to use in the shader\r\n     */\r\n    attributeNames?: Array<string>;\r\n    /**\r\n     * Uniforms to use in the shader\r\n     */\r\n    uniformNames?: Array<string>;\r\n    /**\r\n     * Texture sampler names to use in the shader\r\n     */\r\n    samplerNames?: Array<string>;\r\n    /**\r\n     * Defines to use in the shader\r\n     */\r\n    defines?: Array<string>;\r\n    /**\r\n     * Callback when effect is compiled\r\n     */\r\n    onCompiled?: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * The friendly name of the effect displayed in Spector.\r\n     */\r\n    name?: string;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Wraps an effect to be used for rendering\r\n */\r\nexport class EffectWrapper {\r\n    /**\r\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\r\n     */\r\n    public onApplyObservable = new Observable<{}>();\r\n    /**\r\n     * The underlying effect\r\n     */\r\n    public get effect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    public set effect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _drawWrapper: DrawWrapper;\r\n\r\n    private _onContextRestoredObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * Creates an effect to be renderer\r\n     * @param creationOptions options to create the effect\r\n     */\r\n    constructor(creationOptions: EffectWrapperCreationOptions) {\r\n        let effectCreationOptions: any;\r\n        const uniformNames = creationOptions.uniformNames || [];\r\n\r\n        if (creationOptions.vertexShader) {\r\n            effectCreationOptions = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertexSource: creationOptions.vertexShader,\r\n                spectorName: creationOptions.name || \"effectWrapper\",\r\n            };\r\n        } else {\r\n            // Default scale to use in post process vertex shader.\r\n            uniformNames.push(\"scale\");\r\n\r\n            effectCreationOptions = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertex: \"postprocess\",\r\n                spectorName: creationOptions.name || \"effectWrapper\",\r\n            };\r\n\r\n            // Sets the default scale to identity for the post process vertex shader.\r\n            this.onApplyObservable.add(() => {\r\n                this.effect.setFloat2(\"scale\", 1, 1);\r\n            });\r\n        }\r\n\r\n        const defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\r\n        this._drawWrapper = new DrawWrapper(creationOptions.engine);\r\n\r\n        if (creationOptions.useShaderStore) {\r\n            effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\r\n            if (!effectCreationOptions.vertex) {\r\n                effectCreationOptions.vertex = effectCreationOptions.vertexSource;\r\n            }\r\n\r\n            delete effectCreationOptions.fragmentSource;\r\n            delete effectCreationOptions.vertexSource;\r\n\r\n            this.effect = creationOptions.engine.createEffect(\r\n                effectCreationOptions,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled,\r\n                undefined,\r\n                undefined,\r\n                creationOptions.shaderLanguage\r\n            );\r\n        } else {\r\n            this.effect = new Effect(\r\n                effectCreationOptions,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                creationOptions.engine,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                creationOptions.shaderLanguage\r\n            );\r\n\r\n            this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {\r\n                this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\r\n                this.effect._wasPreviouslyReady = false;\r\n                this.effect._prepareEffect();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the effect wrapper\r\n     */\r\n    public dispose() {\r\n        if (this._onContextRestoredObserver) {\r\n            this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n        this.effect.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}