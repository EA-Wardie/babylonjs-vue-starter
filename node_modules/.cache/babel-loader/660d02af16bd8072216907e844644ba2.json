{"ast":null,"code":"import \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Animation } from \"./animation.js\";\nimport { Size } from \"../Maths/math.size.js\"; // Static values to help the garbage collector\n// Quaternion\n\nvar _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0)); // Vector3\n\n\nvar _staticOffsetValueVector3 = Object.freeze(Vector3.Zero()); // Vector2\n\n\nvar _staticOffsetValueVector2 = Object.freeze(Vector2.Zero()); // Size\n\n\nvar _staticOffsetValueSize = Object.freeze(Size.Zero()); // Color3\n\n\nvar _staticOffsetValueColor3 = Object.freeze(Color3.Black());\n/**\n * Defines a runtime animation\n */\n\n\nvar RuntimeAnimation =\n/** @class */\nfunction () {\n  /**\n   * Create a new RuntimeAnimation object\n   * @param target defines the target of the animation\n   * @param animation defines the source animation object\n   * @param scene defines the hosting scene\n   * @param host defines the initiating Animatable\n   */\n  function RuntimeAnimation(target, animation, scene, host) {\n    var _this = this;\n\n    this._events = new Array();\n    /**\n     * The current frame of the runtime animation\n     */\n\n    this._currentFrame = 0;\n    /**\n     * The original value of the runtime animation\n     */\n\n    this._originalValue = new Array();\n    /**\n     * The original blend value of the runtime animation\n     */\n\n    this._originalBlendValue = null;\n    /**\n     * The offsets cache of the runtime animation\n     */\n\n    this._offsetsCache = {};\n    /**\n     * The high limits cache of the runtime animation\n     */\n\n    this._highLimitsCache = {};\n    /**\n     * Specifies if the runtime animation has been stopped\n     */\n\n    this._stopped = false;\n    /**\n     * The blending factor of the runtime animation\n     */\n\n    this._blendingFactor = 0;\n    /**\n     * The current value of the runtime animation\n     */\n\n    this._currentValue = null;\n    this._currentActiveTarget = null;\n    this._directTarget = null;\n    /**\n     * The target path of the runtime animation\n     */\n\n    this._targetPath = \"\";\n    /**\n     * The weight of the runtime animation\n     */\n\n    this._weight = 1.0;\n    /**\n     * The ratio offset of the runtime animation\n     */\n\n    this._ratioOffset = 0;\n    /**\n     * The previous delay of the runtime animation\n     */\n\n    this._previousDelay = 0;\n    /**\n     * The previous ratio of the runtime animation\n     */\n\n    this._previousRatio = 0;\n    this._targetIsArray = false;\n    this._animation = animation;\n    this._target = target;\n    this._scene = scene;\n    this._host = host;\n    this._activeTargets = [];\n\n    animation._runtimeAnimations.push(this); // State\n\n\n    this._animationState = {\n      key: 0,\n      repeatCount: 0,\n      loopMode: this._getCorrectLoopMode()\n    };\n\n    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      this._animationState.workValue = Matrix.Zero();\n    } // Limits\n\n\n    this._keys = this._animation.getKeys();\n    this._minFrame = this._keys[0].frame;\n    this._maxFrame = this._keys[this._keys.length - 1].frame;\n    this._minValue = this._keys[0].value;\n    this._maxValue = this._keys[this._keys.length - 1].value; // Add a start key at frame 0 if missing\n\n    if (this._minFrame !== 0) {\n      var newKey = {\n        frame: 0,\n        value: this._minValue\n      };\n\n      this._keys.splice(0, 0, newKey);\n    } // Check data\n\n\n    if (this._target instanceof Array) {\n      var index = 0;\n\n      for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n        var target_1 = _a[_i];\n\n        this._preparePath(target_1, index);\n\n        this._getOriginalValues(index);\n\n        index++;\n      }\n\n      this._targetIsArray = true;\n    } else {\n      this._preparePath(this._target);\n\n      this._getOriginalValues();\n\n      this._targetIsArray = false;\n      this._directTarget = this._activeTargets[0];\n    } // Cloning events locally\n\n\n    var events = animation.getEvents();\n\n    if (events && events.length > 0) {\n      events.forEach(function (e) {\n        _this._events.push(e._clone());\n      });\n    }\n\n    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n  }\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentFrame\", {\n    /**\n     * Gets the current frame of the runtime animation\n     */\n    get: function get() {\n      return this._currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"weight\", {\n    /**\n     * Gets the weight of the runtime animation\n     */\n    get: function get() {\n      return this._weight;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentValue\", {\n    /**\n     * Gets the current value of the runtime animation\n     */\n    get: function get() {\n      return this._currentValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"targetPath\", {\n    /**\n     * Gets or sets the target path of the runtime animation\n     */\n    get: function get() {\n      return this._targetPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"target\", {\n    /**\n     * Gets the actual target of the runtime animation\n     */\n    get: function get() {\n      return this._currentActiveTarget;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"isAdditive\", {\n    /**\n     * Gets the additive state of the runtime animation\n     */\n    get: function get() {\n      return this._host && this._host.isAdditive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RuntimeAnimation.prototype._preparePath = function (target, targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var targetPropertyPath = this._animation.targetPropertyPath;\n\n    if (targetPropertyPath.length > 1) {\n      var property = target[targetPropertyPath[0]];\n\n      for (var index = 1; index < targetPropertyPath.length - 1; index++) {\n        property = property[targetPropertyPath[index]];\n      }\n\n      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n      this._activeTargets[targetIndex] = property;\n    } else {\n      this._targetPath = targetPropertyPath[0];\n      this._activeTargets[targetIndex] = target;\n    }\n  };\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"animation\", {\n    /**\n     * Gets the animation from the runtime animation\n     */\n    get: function get() {\n      return this._animation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Resets the runtime animation to the beginning\n   * @param restoreOriginal defines whether to restore the target property to the original value\n   */\n\n  RuntimeAnimation.prototype.reset = function (restoreOriginal) {\n    if (restoreOriginal === void 0) {\n      restoreOriginal = false;\n    }\n\n    if (restoreOriginal) {\n      if (this._target instanceof Array) {\n        var index = 0;\n\n        for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n          var target = _a[_i];\n\n          if (this._originalValue[index] !== undefined) {\n            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n          }\n\n          index++;\n        }\n      } else {\n        if (this._originalValue[0] !== undefined) {\n          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n        }\n      }\n    }\n\n    this._offsetsCache = {};\n    this._highLimitsCache = {};\n    this._currentFrame = 0;\n    this._blendingFactor = 0; // Events\n\n    for (var index = 0; index < this._events.length; index++) {\n      this._events[index].isDone = false;\n    }\n  };\n  /**\n   * Specifies if the runtime animation is stopped\n   * @returns Boolean specifying if the runtime animation is stopped\n   */\n\n\n  RuntimeAnimation.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\n   * Disposes of the runtime animation\n   */\n\n\n  RuntimeAnimation.prototype.dispose = function () {\n    var index = this._animation.runtimeAnimations.indexOf(this);\n\n    if (index > -1) {\n      this._animation.runtimeAnimations.splice(index, 1);\n    }\n  };\n  /**\n   * Apply the interpolated value to the target\n   * @param currentValue defines the value computed by the animation\n   * @param weight defines the weight to apply to this value (Defaults to 1.0)\n   */\n\n\n  RuntimeAnimation.prototype.setValue = function (currentValue, weight) {\n    if (this._targetIsArray) {\n      for (var index = 0; index < this._target.length; index++) {\n        var target = this._target[index];\n\n        this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n      }\n\n      return;\n    }\n\n    this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n  };\n\n  RuntimeAnimation.prototype._getOriginalValues = function (targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var originalValue;\n    var target = this._activeTargets[targetIndex];\n\n    if (target.getRestPose && this._targetPath === \"_matrix\") {\n      // For bones\n      originalValue = target.getRestPose();\n    } else {\n      originalValue = target[this._targetPath];\n    }\n\n    if (originalValue && originalValue.clone) {\n      this._originalValue[targetIndex] = originalValue.clone();\n    } else {\n      this._originalValue[targetIndex] = originalValue;\n    }\n  };\n\n  RuntimeAnimation.prototype._setValue = function (target, destination, currentValue, weight, targetIndex) {\n    // Set value\n    this._currentActiveTarget = destination;\n    this._weight = weight;\n\n    if (this._enableBlending && this._blendingFactor <= 1.0) {\n      if (!this._originalBlendValue) {\n        var originalValue = destination[this._targetPath];\n\n        if (originalValue.clone) {\n          this._originalBlendValue = originalValue.clone();\n        } else {\n          this._originalBlendValue = originalValue;\n        }\n      }\n\n      if (this._originalBlendValue.m) {\n        // Matrix\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\n          if (this._currentValue) {\n            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        } else {\n          if (this._currentValue) {\n            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        }\n      } else {\n        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n      }\n\n      var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n      this._blendingFactor += blendingSpeed;\n    } else {\n      if (!this._currentValue) {\n        if (currentValue === null || currentValue === void 0 ? void 0 : currentValue.clone) {\n          this._currentValue = currentValue.clone();\n        } else {\n          this._currentValue = currentValue;\n        }\n      } else if (this._currentValue.copyFrom) {\n        this._currentValue.copyFrom(currentValue);\n      } else {\n        this._currentValue = currentValue;\n      }\n    }\n\n    if (weight !== -1.0) {\n      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n    } else {\n      destination[this._targetPath] = this._currentValue;\n    }\n\n    if (target.markAsDirty) {\n      target.markAsDirty(this._animation.targetProperty);\n    }\n  };\n  /**\n   * Gets the loop pmode of the runtime animation\n   * @returns Loop Mode\n   */\n\n\n  RuntimeAnimation.prototype._getCorrectLoopMode = function () {\n    if (this._target && this._target.animationPropertiesOverride) {\n      return this._target.animationPropertiesOverride.loopMode;\n    }\n\n    return this._animation.loopMode;\n  };\n  /**\n   * Move the current animation to a given frame\n   * @param frame defines the frame to move to\n   */\n\n\n  RuntimeAnimation.prototype.goToFrame = function (frame) {\n    var keys = this._animation.getKeys();\n\n    if (frame < keys[0].frame) {\n      frame = keys[0].frame;\n    } else if (frame > keys[keys.length - 1].frame) {\n      frame = keys[keys.length - 1].frame;\n    } // Need to reset animation events\n\n\n    var events = this._events;\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset events in the future\n          events[index].isDone = events[index].frame < frame;\n        }\n      }\n    }\n\n    this._currentFrame = frame;\n\n    var currentValue = this._animation._interpolate(frame, this._animationState);\n\n    this.setValue(currentValue, -1);\n  };\n  /**\n   * @param newSpeedRatio\n   * @hidden Internal use only\n   */\n\n\n  RuntimeAnimation.prototype._prepareForSpeedRatioChange = function (newSpeedRatio) {\n    var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\n    this._ratioOffset = this._previousRatio - newRatio;\n  };\n  /**\n   * Execute the current animation\n   * @param delay defines the delay to add to the current frame\n   * @param from defines the lower bound of the animation range\n   * @param to defines the upper bound of the animation range\n   * @param loop defines if the current animation must loop\n   * @param speedRatio defines the current speed ratio\n   * @param weight defines the weight of the animation (default is -1 so no weight)\n   * @returns a boolean indicating if the animation is running\n   */\n\n\n  RuntimeAnimation.prototype.animate = function (delay, from, to, loop, speedRatio, weight) {\n    if (weight === void 0) {\n      weight = -1.0;\n    }\n\n    var animation = this._animation;\n    var targetPropertyPath = animation.targetPropertyPath;\n\n    if (!targetPropertyPath || targetPropertyPath.length < 1) {\n      this._stopped = true;\n      return false;\n    }\n\n    var returnValue = true; // Check limits\n\n    if (from < this._minFrame || from > this._maxFrame) {\n      from = this._minFrame;\n    }\n\n    if (to < this._minFrame || to > this._maxFrame) {\n      to = this._maxFrame;\n    }\n\n    var range = to - from;\n    var offsetValue; // Compute ratio which represents the frame delta between from and to\n\n    var ratio = delay * (animation.framePerSecond * speedRatio) / 1000.0 + this._ratioOffset;\n    var highLimitValue = 0;\n    this._previousDelay = delay;\n    this._previousRatio = ratio;\n\n    if (!loop && to >= from && ratio >= range) {\n      // If we are out of range and not looping get back to caller\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._maxValue);\n    } else if (!loop && from >= to && ratio <= range) {\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._minValue);\n    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n      var keyOffset = to.toString() + from.toString();\n\n      if (!this._offsetsCache[keyOffset]) {\n        this._animationState.repeatCount = 0;\n        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\n\n        var fromValue = animation._interpolate(from, this._animationState);\n\n        var toValue = animation._interpolate(to, this._animationState);\n\n        this._animationState.loopMode = this._getCorrectLoopMode();\n\n        switch (animation.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            this._offsetsCache[keyOffset] = toValue - fromValue;\n            break;\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n\n          default:\n            break;\n        }\n\n        this._highLimitsCache[keyOffset] = toValue;\n      }\n\n      highLimitValue = this._highLimitsCache[keyOffset];\n      offsetValue = this._offsetsCache[keyOffset];\n    }\n\n    if (offsetValue === undefined) {\n      switch (animation.dataType) {\n        // Float\n        case Animation.ANIMATIONTYPE_FLOAT:\n          offsetValue = 0;\n          break;\n        // Quaternion\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          offsetValue = _staticOffsetValueQuaternion;\n          break;\n        // Vector3\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n          offsetValue = _staticOffsetValueVector3;\n          break;\n        // Vector2\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n          offsetValue = _staticOffsetValueVector2;\n          break;\n        // Size\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          offsetValue = _staticOffsetValueSize;\n          break;\n        // Color3\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          offsetValue = _staticOffsetValueColor3;\n      }\n    } // Compute value\n\n\n    var currentFrame;\n\n    if (this._host && this._host.syncRoot) {\n      var syncRoot = this._host.syncRoot;\n      var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n      currentFrame = from + (to - from) * hostNormalizedFrame;\n    } else {\n      if (ratio > 0 && from > to || ratio < 0 && from < to) {\n        currentFrame = returnValue && range !== 0 ? to + ratio % range : from;\n      } else {\n        currentFrame = returnValue && range !== 0 ? from + ratio % range : to;\n      }\n    } // Reset events if looping\n\n\n    var events = this._events;\n\n    if (speedRatio > 0 && this.currentFrame > currentFrame || speedRatio < 0 && this.currentFrame < currentFrame) {\n      this._onLoop(); // Need to reset animation events\n\n\n      if (events.length) {\n        for (var index = 0; index < events.length; index++) {\n          if (!events[index].onlyOnce) {\n            // reset event, the animation is looping\n            events[index].isDone = false;\n          }\n        }\n      }\n    }\n\n    this._currentFrame = currentFrame;\n    this._animationState.repeatCount = range === 0 ? 0 : ratio / range >> 0;\n    this._animationState.highLimitValue = highLimitValue;\n    this._animationState.offsetValue = offsetValue;\n\n    var currentValue = animation._interpolate(currentFrame, this._animationState); // Set value\n\n\n    this.setValue(currentValue, weight); // Check events\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        // Make sure current frame has passed event frame and that event frame is within the current range\n        // Also, handle both forward and reverse animations\n        if (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from || range < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {\n          var event_1 = events[index];\n\n          if (!event_1.isDone) {\n            // If event should be done only once, remove it.\n            if (event_1.onlyOnce) {\n              events.splice(index, 1);\n              index--;\n            }\n\n            event_1.isDone = true;\n            event_1.action(currentFrame);\n          } // Don't do anything if the event has already be done.\n\n        }\n      }\n    }\n\n    if (!returnValue) {\n      this._stopped = true;\n    }\n\n    return returnValue;\n  };\n\n  return RuntimeAnimation;\n}();\n\nexport { RuntimeAnimation };","map":{"version":3,"mappings":"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","names":["Quaternion","Vector3","Vector2","Matrix","Color3","Animation","Size","_staticOffsetValueQuaternion","Object","freeze","_staticOffsetValueVector3","Zero","_staticOffsetValueVector2","_staticOffsetValueSize","_staticOffsetValueColor3","Black","target","animation","scene","host","Array","_animation","_target","_scene","_host","_activeTargets","_runtimeAnimations","push","_animationState","key","repeatCount","loopMode","_getCorrectLoopMode","dataType","ANIMATIONTYPE_MATRIX","workValue","_keys","getKeys","_minFrame","frame","_maxFrame","length","_minValue","value","_maxValue","newKey","splice","index","_i","target_1","_preparePath","_getOriginalValues","_targetIsArray","_directTarget","events","getEvents","forEach","e","_this","_events","_clone","_enableBlending","animationPropertiesOverride","enableBlending","RuntimeAnimation","_currentFrame","_weight","_currentValue","_targetPath","_currentActiveTarget","isAdditive","targetIndex","targetPropertyPath","property","restoreOriginal","_originalValue","undefined","_setValue","_offsetsCache","_highLimitsCache","_blendingFactor","isDone","_stopped","runtimeAnimations","indexOf","currentValue","weight","originalValue","getRestPose","clone","destination","_originalBlendValue","m","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","_registerTargetForLateAnimationBinding","markAsDirty","targetProperty","keys","onlyOnce","_interpolate","setValue","newSpeedRatio","newRatio","_previousDelay","framePerSecond","_ratioOffset","_previousRatio","delay","from","to","loop","speedRatio","returnValue","range","offsetValue","ratio","highLimitValue","_getKeyValue","ANIMATIONLOOPMODE_CYCLE","keyOffset","toString","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","subtract","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","currentFrame","syncRoot","hostNormalizedFrame","masterFrame","fromFrame","toFrame","_onLoop","event_1","action"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Animations/runtimeAnimation.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport { Animation } from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { Size } from \"../Maths/math.size\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nconst _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nconst _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nconst _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nconst _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nconst _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @hidden */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The ratio offset of the runtime animation\r\n     */\r\n    private _ratioOffset = 0;\r\n\r\n    /**\r\n     * The previous delay of the runtime animation\r\n     */\r\n    private _previousDelay: number = 0;\r\n\r\n    /**\r\n     * The previous ratio of the runtime animation\r\n     */\r\n    private _previousRatio: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target[targetPropertyPath[0]];\r\n\r\n            for (let index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getRestPose && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getRestPose();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, -1);\r\n    }\r\n\r\n    /**\r\n     * @param newSpeedRatio\r\n     * @hidden Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newRatio = (this._previousDelay * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._ratioOffset = this._previousRatio - newRatio;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param delay defines the delay to add to the current frame\r\n     * @param from defines the lower bound of the animation range\r\n     * @param to defines the upper bound of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(delay: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const range = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute ratio which represents the frame delta between from and to\r\n        const ratio = (delay * (animation.framePerSecond * speedRatio)) / 1000.0 + this._ratioOffset;\r\n        let highLimitValue = 0;\r\n\r\n        this._previousDelay = delay;\r\n        this._previousRatio = ratio;\r\n\r\n        if (!loop && to >= from && ratio >= range) {\r\n            // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && from >= to && ratio <= range) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            const keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\r\n                const fromValue = animation._interpolate(from, this._animationState);\r\n                const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + (to - from) * hostNormalizedFrame;\r\n        } else {\r\n            if ((ratio > 0 && from > to) || (ratio < 0 && from < to)) {\r\n                currentFrame = returnValue && range !== 0 ? to + (ratio % range) : from;\r\n            } else {\r\n                currentFrame = returnValue && range !== 0 ? from + (ratio % range) : to;\r\n            }\r\n        }\r\n\r\n        // Reset events if looping\r\n        const events = this._events;\r\n\r\n        if ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame)) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            if (events.length) {\r\n                for (let index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = range === 0 ? 0 : (ratio / range) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (range < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already be done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}