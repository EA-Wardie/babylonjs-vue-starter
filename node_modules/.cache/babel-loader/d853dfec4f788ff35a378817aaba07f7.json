{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport \"../../Engines/Extensions/engine.multiRender.js\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\n\nvar MultiRenderTarget =\n/** @class */\nfunction (_super) {\n  __extends(MultiRenderTarget, _super);\n  /**\n   * Instantiate a new multi render target texture.\n   * A multi render target, like a render target provides the ability to render to a texture.\n   * Unlike the render target, it can render to several draw buffers in one draw.\n   * This is specially interesting in deferred rendering or for any effects requiring more than\n   * just one color from a single pass.\n   * @param name Define the name of the texture\n   * @param size Define the size of the buffers to render to\n   * @param count Define the number of target we are rendering into\n   * @param scene Define the scene the texture belongs to\n   * @param options Define the options used to create the multi render target\n   * @param textureNames Define the names to set to the textures (if count > 0 - optional)\n   */\n\n\n  function MultiRenderTarget(name, size, count, scene, options, textureNames) {\n    var _this = this;\n\n    var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    var depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;\n    var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    var drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n    _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true) || this;\n\n    if (!_this.isSupported) {\n      _this.dispose();\n\n      return _this;\n    }\n\n    var types = [];\n    var samplingModes = [];\n\n    _this._initTypes(count, types, samplingModes, options);\n\n    var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    _this._size = size;\n    _this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      depthTextureFormat: depthTextureFormat,\n      types: types,\n      textureCount: count\n    };\n    _this._count = count;\n    _this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n\n    if (count > 0) {\n      _this._createInternalTextures();\n\n      _this._createTextures(textureNames);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"isSupported\", {\n    /**\n     * Get if draw buffers are currently supported by the used hardware and browser.\n     */\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.getCaps().drawBuffersExtension) !== null && _b !== void 0 ? _b : false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"textures\", {\n    /**\n     * Get the list of textures generated by the multi render target.\n     */\n    get: function get() {\n      return this._textures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"count\", {\n    /**\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n     */\n    get: function get() {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"depthTexture\", {\n    /**\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n     */\n    get: function get() {\n      return this._textures[this._textures.length - 1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapU\", {\n    /**\n     * Set the wrapping mode on U of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set: function set(wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapU = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapV\", {\n    /**\n     * Set the wrapping mode on V of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set: function set(wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapV = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MultiRenderTarget.prototype._initTypes = function (count, types, samplingModes, options) {\n    for (var i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n    }\n  };\n  /**\n   * @param forceFullRebuild\n   * @param textureNames\n   * @hidden\n   */\n\n\n  MultiRenderTarget.prototype._rebuild = function (forceFullRebuild, textureNames) {\n    if (forceFullRebuild === void 0) {\n      forceFullRebuild = false;\n    }\n\n    if (this._count < 1) {\n      return;\n    }\n\n    this.releaseInternalTextures();\n\n    this._createInternalTextures();\n\n    if (forceFullRebuild) {\n      this._releaseTextures();\n\n      this._createTextures(textureNames);\n    }\n\n    var internalTextures = this._renderTarget.textures;\n\n    for (var i = 0; i < internalTextures.length; i++) {\n      var texture = this._textures[i];\n      texture._texture = internalTextures[i];\n    }\n\n    if (this.samples !== 1) {\n      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n    }\n  };\n\n  MultiRenderTarget.prototype._createInternalTextures = function () {\n    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n    this._texture = this._renderTarget.texture;\n  };\n\n  MultiRenderTarget.prototype._releaseTextures = function () {\n    if (this._textures) {\n      for (var i = 0; i < this._textures.length; i++) {\n        this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n\n        this._textures[i].dispose();\n      }\n    }\n  };\n\n  MultiRenderTarget.prototype._createTextures = function (textureNames) {\n    var internalTextures = this._renderTarget.textures;\n    this._textures = [];\n\n    for (var i = 0; i < internalTextures.length; i++) {\n      var texture = new Texture(null, this.getScene());\n\n      if (textureNames === null || textureNames === void 0 ? void 0 : textureNames[i]) {\n        texture.name = textureNames[i];\n      }\n\n      texture._texture = internalTextures[i];\n\n      this._textures.push(texture);\n    }\n  };\n  /**\n   * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n   * @param texture The new texture to set in the MRT\n   * @param index The index of the texture to replace\n   * @param disposePrevious Set to true if the previous internal texture should be disposed\n   */\n\n\n  MultiRenderTarget.prototype.setInternalTexture = function (texture, index, disposePrevious) {\n    if (disposePrevious === void 0) {\n      disposePrevious = true;\n    }\n\n    if (!this.renderTarget) {\n      return;\n    }\n\n    if (index === 0) {\n      this._texture = texture;\n    }\n\n    this.renderTarget.setTexture(texture, index, disposePrevious);\n\n    if (!this.textures[index]) {\n      this.textures[index] = new Texture(null, this.getScene());\n    }\n\n    this.textures[index]._texture = texture;\n    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n\n    if (this._multiRenderTargetOptions.types) {\n      this._multiRenderTargetOptions.types[index] = texture.type;\n    }\n\n    if (this._multiRenderTargetOptions.samplingModes) {\n      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n    }\n  };\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"samples\", {\n    /**\n     * Define the number of samples used if MSAA is enabled.\n     */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(value) {\n      if (this._renderTarget) {\n        this._samples = this._renderTarget.setSamples(value);\n      } else {\n        // In case samples are set with 0 textures created, we must save the desired samples value\n        this._samples = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Resize all the textures in the multi render target.\n   * Be careful as it will recreate all the data in the new texture.\n   * @param size Define the new size\n   */\n\n  MultiRenderTarget.prototype.resize = function (size) {\n    this._size = size;\n\n    this._rebuild();\n  };\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n\n\n  MultiRenderTarget.prototype.updateCount = function (count, options, textureNames) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    var types = [];\n    var samplingModes = [];\n\n    this._initTypes(count, types, samplingModes, options);\n\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n\n    this._rebuild(true, textureNames);\n  };\n\n  MultiRenderTarget.prototype._unbindFrameBuffer = function (engine, faceIndex) {\n    var _this = this;\n\n    if (this._renderTarget) {\n      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, function () {\n        _this.onAfterRenderObservable.notifyObservers(faceIndex);\n      });\n    }\n  };\n  /**\n   * Dispose the render targets and their associated resources\n   * @param doNotDisposeInternalTextures\n   */\n\n\n  MultiRenderTarget.prototype.dispose = function (doNotDisposeInternalTextures) {\n    if (doNotDisposeInternalTextures === void 0) {\n      doNotDisposeInternalTextures = false;\n    }\n\n    this._releaseTextures();\n\n    if (!doNotDisposeInternalTextures) {\n      this.releaseInternalTextures();\n    } else {\n      // Prevent internal texture dispose in super.dispose\n      this._texture = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Release all the underlying texture used as draw buffers.\n   */\n\n\n  MultiRenderTarget.prototype.releaseInternalTextures = function () {\n    var _a, _b;\n\n    var internalTextures = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.textures;\n\n    if (!internalTextures) {\n      return;\n    }\n\n    for (var i = internalTextures.length - 1; i >= 0; i--) {\n      this._textures[i]._texture = null;\n    }\n\n    (_b = this._renderTarget) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._renderTarget = null;\n  };\n\n  return MultiRenderTarget;\n}(RenderTargetTexture);\n\nexport { MultiRenderTarget };","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","__extends","name","size","count","scene","options","textureNames","generateMipMaps","generateDepthTexture","depthTextureFormat","doNotChangeAspectRatio","undefined","drawOnlyOnFirstAttachmentByDefault","_super","_this","isSupported","dispose","types","samplingModes","_initTypes","generateDepthBuffer","generateStencilBuffer","_size","_multiRenderTargetOptions","textureCount","_count","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","Object","MultiRenderTarget","_engine","_a","getCaps","drawBuffersExtension","_b","_textures","length","wrap","i","wrapU","wrapV","push","defaultType","BILINEAR_SAMPLINGMODE","forceFullRebuild","releaseInternalTextures","_releaseTextures","internalTextures","_renderTarget","textures","texture","_texture","samples","setSamples","_getEngine","createMultipleRenderTarget","getScene","index","disposePrevious","renderTarget","setTexture","type","samplingMode","_samples","value","_rebuild","engine","faceIndex","unBindMultiColorAttachmentFramebuffer","isCube","onAfterRenderObservable","notifyObservers","doNotDisposeInternalTextures","call"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/multiRenderTarget.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define depth texture format to use\r\n     */\r\n    depthTextureFormat?: number;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    drawOnlyOnFirstAttachmentByDefault?: boolean;\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n    private _drawOnlyOnFirstAttachmentByDefault: boolean;\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\r\n     */\r\n    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\r\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        this._initTypes(count, types, samplingModes, options);\r\n\r\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._size = size;\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            depthTextureFormat: depthTextureFormat,\r\n            types: types,\r\n            textureCount: count,\r\n        };\r\n\r\n        this._count = count;\r\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\r\n\r\n        if (count > 0) {\r\n            this._createInternalTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n    }\r\n\r\n    private _initTypes(count: number, types: number[], samplingModes: number[], options?: IMultiRenderTargetOptions) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param forceFullRebuild\r\n     * @param textureNames\r\n     * @hidden\r\n     */\r\n    public _rebuild(forceFullRebuild: boolean = false, textureNames?: string[]): void {\r\n        if (this._count < 1) {\r\n            return;\r\n        }\r\n\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._releaseTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = this._textures[i];\r\n            texture._texture = internalTextures[i];\r\n        }\r\n\r\n        if (this.samples !== 1) {\r\n            this._renderTarget!.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._renderTarget = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\r\n        this._texture = this._renderTarget.texture;\r\n    }\r\n\r\n    private _releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createTextures(textureNames?: string[]): void {\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        this._textures = [];\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = new Texture(null, this.getScene());\r\n            if (textureNames?.[i]) {\r\n                texture.name = textureNames[i];\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\r\n     * @param texture The new texture to set in the MRT\r\n     * @param index The index of the texture to replace\r\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\r\n     */\r\n    public setInternalTexture(texture: InternalTexture, index: number, disposePrevious: boolean = true) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (index === 0) {\r\n            this._texture = texture;\r\n        }\r\n\r\n        this.renderTarget.setTexture(texture, index, disposePrevious);\r\n\r\n        if (!this.textures[index]) {\r\n            this.textures[index] = new Texture(null, this.getScene());\r\n        }\r\n        this.textures[index]._texture = texture;\r\n\r\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\r\n\r\n        if (this._multiRenderTargetOptions.types) {\r\n            this._multiRenderTargetOptions.types[index] = texture.type;\r\n        }\r\n        if (this._multiRenderTargetOptions.samplingModes) {\r\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        } else {\r\n            // In case samples are set with 0 textures created, we must save the desired samples value\r\n            this._samples = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._size = size;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n\r\n        this._initTypes(count, types, samplingModes, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._rebuild(true, textureNames);\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (this._renderTarget) {\r\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\r\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     * @param doNotDisposeInternalTextures\r\n     */\r\n    public dispose(doNotDisposeInternalTextures = false): void {\r\n        this._releaseTextures();\r\n        if (!doNotDisposeInternalTextures) {\r\n            this.releaseInternalTextures();\r\n        } else {\r\n            // Prevent internal texture dispose in super.dispose\r\n            this._texture = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        const internalTextures = this._renderTarget?.textures;\r\n\r\n        if (!internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\r\n            this._textures[i]._texture = null;\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}