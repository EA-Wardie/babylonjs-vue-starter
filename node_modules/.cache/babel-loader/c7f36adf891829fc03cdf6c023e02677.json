{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serializeAsVector3, serialize } from \"../Misc/decorators.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\n * @see https://doc.babylonjs.com/features/cameras#universal-camera\n */\n\nvar FreeCamera =\n/** @class */\nfunction (_super) {\n  __extends(FreeCamera, _super);\n  /**\n   * Instantiates a Free Camera.\n   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\n   * @see https://doc.babylonjs.com/features/cameras#universal-camera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the start position of the camera in the scene\n   * @param scene Define the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n\n\n  function FreeCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n    /**\n     * Define the collision ellipsoid of the camera.\n     * This is helpful to simulate a camera body like the player body around the camera\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\n     */\n\n\n    _this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\n     * Define an offset for the position of the ellipsoid around the camera.\n     * This can be helpful to determine the center of the body near the gravity center of the body\n     * instead of its head.\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\n     * Enable or disable collisions of the camera with the rest of the scene objects.\n     */\n\n    _this.checkCollisions = false;\n    /**\n     * Enable or disable gravity on the camera.\n     */\n\n    _this.applyGravity = false;\n    _this._needMoveForGravity = false;\n    _this._oldPosition = Vector3.Zero();\n    _this._diffPosition = Vector3.Zero();\n    _this._newPosition = Vector3.Zero(); // Collisions\n\n    _this._collisionMask = -1;\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      var updatePosition = function updatePosition(newPos) {\n        _this._newPosition.copyFrom(newPos);\n\n        _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);\n\n        if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {\n          _this.position.addInPlace(_this._diffPosition);\n\n          if (_this.onCollide && collidedMesh) {\n            _this.onCollide(collidedMesh);\n          }\n        }\n      };\n\n      updatePosition(newPosition);\n    };\n\n    _this.inputs = new FreeCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouse();\n\n    return _this;\n  }\n\n  Object.defineProperty(FreeCamera.prototype, \"angularSensibility\", {\n    /**\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\n     * Higher values reduce sensitivity.\n     */\n    get: function get() {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        return mouse.angularSensibility;\n      }\n\n      return 0;\n    },\n\n    /**\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\n     * Higher values reduce sensitivity.\n     */\n    set: function set(value) {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        mouse.angularSensibility = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysUp\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysUp;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysUp = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysUpward\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysUpward;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysUpward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysDown\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysDown;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysDown = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysDownward\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysDownward;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysDownward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysLeft\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysLeft;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysLeft = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysRight\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRight;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRight = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysRotateLeft\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRotateLeft;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRotateLeft = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FreeCamera.prototype, \"keysRotateRight\", {\n    /**\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRotateRight;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRotateRight = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n\n  FreeCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  FreeCamera.prototype.detachControl = function () {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n    this.cameraRotation = new Vector2(0, 0);\n  };\n\n  Object.defineProperty(FreeCamera.prototype, \"collisionMask\", {\n    /**\n     * Define a collision mask to limit the list of object the camera can collide with\n     */\n    get: function get() {\n      return this._collisionMask;\n    },\n    set: function set(mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param displacement\n   * @hidden\n   */\n\n  FreeCamera.prototype._collideWithWorld = function (displacement) {\n    var globalPosition;\n\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask; //no need for clone, as long as gravity is not on.\n\n    var actualDisplacement = displacement; //add gravity to the direction to prevent the dual-collision checking\n\n    if (this.applyGravity) {\n      //this prevents mending with cameraDirection, a global variable of the free camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  };\n  /** @hidden */\n\n\n  FreeCamera.prototype._checkInputs = function () {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n\n    this.inputs.checkInputs();\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /** @hidden */\n\n\n  FreeCamera.prototype._decideIfNeedsToMove = function () {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  FreeCamera.prototype._updatePosition = function () {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      _super.prototype._updatePosition.call(this);\n    }\n  };\n  /**\n   * Destroy the camera and release the current resources hold by it.\n   */\n\n\n  FreeCamera.prototype.dispose = function () {\n    this.inputs.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Gets the current object class name.\n   * @return the class name\n   */\n\n\n  FreeCamera.prototype.getClassName = function () {\n    return \"FreeCamera\";\n  };\n\n  __decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoid\", void 0);\n\n  __decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoidOffset\", void 0);\n\n  __decorate([serialize()], FreeCamera.prototype, \"checkCollisions\", void 0);\n\n  __decorate([serialize()], FreeCamera.prototype, \"applyGravity\", void 0);\n\n  return FreeCamera;\n}(TargetCamera);\n\nexport { FreeCamera };","map":{"version":3,"mappings":"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","names":["serializeAsVector3","serialize","Vector3","Vector2","Engine","TargetCamera","FreeCameraInputsManager","Tools","__extends","name","position","scene","setActiveOnSceneIfNoneActive","_super","_this","Zero","collisionId","newPosition","collidedMesh","updatePosition","newPos","_newPosition","copyFrom","subtractToRef","_oldPosition","_diffPosition","length","CollisionsEpsilon","addInPlace","onCollide","inputs","addKeyboard","addMouse","Object","FreeCamera","mouse","attached","angularSensibility","value","keyboard","keysUp","keysUpward","keysDown","keysDownward","keysLeft","keysRight","keysRotateLeft","keysRotateRight","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","detachElement","cameraDirection","cameraRotation","_collisionMask","mask","isNaN","displacement","globalPosition","parent","TransformCoordinates","getWorldMatrix","subtractFromFloatsToRef","ellipsoid","y","ellipsoidOffset","coordinator","getScene","collisionCoordinator","_collider","createCollider","_radius","collisionMask","actualDisplacement","applyGravity","add","gravity","getNewPosition","_onCollisionPositionChange","uniqueId","_localDirection","_transformedDirection","checkInputs","_checkInputs","call","_needMoveForGravity","Math","abs","x","z","checkCollisions","collisionsEnabled","_collideWithWorld","_updatePosition","clear","dispose","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/freeCamera.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/cameras#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _localDirection: Vector3;\r\n    /** @hidden */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/cameras#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @param displacement\r\n     * @hidden\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        const updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    };\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}