{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { PrePassRenderer } from \"./prePassRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n  get: function get() {\n    return this._prePassRenderer;\n  },\n  set: function set(value) {\n    if (value && value.isSupported) {\n      this._prePassRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.enablePrePassRenderer = function () {\n  if (this._prePassRenderer) {\n    return this._prePassRenderer;\n  }\n\n  this._prePassRenderer = new PrePassRenderer(this);\n\n  if (!this._prePassRenderer.isSupported) {\n    this._prePassRenderer = null;\n    Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n  }\n\n  return this._prePassRenderer;\n};\n\nScene.prototype.disablePrePassRenderer = function () {\n  if (!this._prePassRenderer) {\n    return;\n  }\n\n  this._prePassRenderer.dispose();\n\n  this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\n\n\nvar PrePassRendererSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function PrePassRendererSceneComponent(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  PrePassRendererSceneComponent.prototype.register = function () {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);\n\n    this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS, this, this._beforeRenderTargetClearStage);\n\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeRenderTargetDraw = function (renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n\n      this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterRenderTargetDraw = function (renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeRenderTargetClearStage = function (renderTarget) {\n    if (this.scene.prePassRenderer) {\n      if (!renderTarget._prePassRenderTarget) {\n        renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n      }\n\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n\n      this.scene.prePassRenderer._clear();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeCameraDraw = function (camera) {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n\n      this.scene.prePassRenderer._beforeDraw(camera);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterCameraDraw = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterDraw();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeClearStage = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n\n      this.scene.prePassRenderer._clear();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeRenderingMeshStage = function (mesh, subMesh, batch, effect) {\n    if (!effect) {\n      return;\n    } // Render to MRT\n\n\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterRenderingMeshStage = function (mesh) {\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.restoreAttachments();\n    }\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  PrePassRendererSceneComponent.prototype.rebuild = function () {\n    // Release textures first\n    this.scene.disablePrePassRenderer(); // Re-enable\n\n    this.scene.enablePrePassRenderer();\n  };\n  /**\n   * Disposes the component and the associated resources\n   */\n\n\n  PrePassRendererSceneComponent.prototype.dispose = function () {\n    this.scene.disablePrePassRenderer();\n  };\n\n  return PrePassRendererSceneComponent;\n}();\n\nexport { PrePassRendererSceneComponent };\n\nPrePassRenderer._SceneComponentInitialization = function (scene) {\n  // Register the G Buffer component to the scene.\n  var component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n\n  if (!component) {\n    component = new PrePassRendererSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":";;AACA,SAASA,KAAT,QAAsB,aAAtB;AAEA,SAASC,uBAAT,QAAwC,sBAAxC;AACA,SAASC,eAAT,QAAgC,sBAAhC;AACA,SAASC,MAAT,QAAuB,mBAAvB;AAuCAC,MAAM,CAACC,cAAP,CAAsBL,KAAK,CAACM,SAA5B,EAAuC,iBAAvC,EAA0D;AACtDC,KAAG,EAAE;AACD,WAAO,KAAKC,gBAAZ;AACH,GAHqD;AAItDC,KAAG,EAAE,aAAuBC,KAAvB,EAAuD;AACxD,QAAIA,KAAK,IAAIA,KAAK,CAACC,WAAnB,EAAgC;AAC5B,WAAKH,gBAAL,GAAwBE,KAAxB;AACH;AACJ,GARqD;AAStDE,YAAU,EAAE,IAT0C;AAUtDC,cAAY,EAAE;AAVwC,CAA1D;;AAaAb,KAAK,CAACM,SAAN,CAAgBQ,qBAAhB,GAAwC;AACpC,MAAI,KAAKN,gBAAT,EAA2B;AACvB,WAAO,KAAKA,gBAAZ;AACH;;AAED,OAAKA,gBAAL,GAAwB,IAAIN,eAAJ,CAAoB,IAApB,CAAxB;;AAEA,MAAI,CAAC,KAAKM,gBAAL,CAAsBG,WAA3B,EAAwC;AACpC,SAAKH,gBAAL,GAAwB,IAAxB;AACAL,UAAM,CAACY,KAAP,CAAa,6CAA6C,iFAA7C,GAAiI,0BAA9I;AACH;;AAED,SAAO,KAAKP,gBAAZ;AACH,CAbD;;AAeAR,KAAK,CAACM,SAAN,CAAgBU,sBAAhB,GAAyC;AACrC,MAAI,CAAC,KAAKR,gBAAV,EAA4B;AACxB;AACH;;AAED,OAAKA,gBAAL,CAAsBS,OAAtB;;AACA,OAAKT,gBAAL,GAAwB,IAAxB;AACH,CAPD;AASA;;;;;;AAIA;AAAA;AAAA;AAWI;;;;AAIA,yCAAYU,KAAZ,EAAwB;AAdxB;;;AAGgB,gBAAOjB,uBAAuB,CAACkB,oBAA/B;AAYZ,SAAKD,KAAL,GAAaA,KAAb;AACH;AAED;;;;;AAGOE,qDAAP;AACI,SAAKF,KAAL,CAAWG,sBAAX,CAAkCC,YAAlC,CAA+CrB,uBAAuB,CAACsB,6BAAvE,EAAsG,IAAtG,EAA4G,KAAKC,iBAAjH;;AACA,SAAKN,KAAL,CAAWO,qBAAX,CAAiCH,YAAjC,CAA8CrB,uBAAuB,CAACyB,4BAAtE,EAAoG,IAApG,EAA0G,KAAKC,gBAA/G;;AACA,SAAKT,KAAL,CAAWU,4BAAX,CAAwCN,YAAxC,CAAqDrB,uBAAuB,CAAC4B,mCAA7E,EAAkH,IAAlH,EAAwH,KAAKC,uBAA7H;;AACA,SAAKZ,KAAL,CAAWa,2BAAX,CAAuCT,YAAvC,CAAoDrB,uBAAuB,CAACyB,4BAA5E,EAA0G,IAA1G,EAAgH,KAAKM,sBAArH;;AAEA,SAAKd,KAAL,CAAWe,iBAAX,CAA6BX,YAA7B,CAA0CrB,uBAAuB,CAACiC,6BAAlE,EAAiG,IAAjG,EAAuG,KAAKD,iBAA5G;;AACA,SAAKf,KAAL,CAAWiB,6BAAX,CAAyCb,YAAzC,CAAsDrB,uBAAuB,CAACmC,yCAA9E,EAAyH,IAAzH,EAA+H,KAAKD,6BAApI;;AAEA,SAAKjB,KAAL,CAAWmB,yBAAX,CAAqCf,YAArC,CAAkDrB,uBAAuB,CAACqC,gCAA1E,EAA4G,IAA5G,EAAkH,KAAKD,yBAAvH;;AACA,SAAKnB,KAAL,CAAWqB,wBAAX,CAAoCjB,YAApC,CAAiDrB,uBAAuB,CAACuC,+BAAzE,EAA0G,IAA1G,EAAgH,KAAKD,wBAArH;AACH,GAXM;;AAaCnB,oEAAR,UAAgCqB,YAAhC,EAAmEC,SAAnE,EAAuFC,KAAvF,EAAqG;AACjG,QAAI,KAAKzB,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,WAAK1B,KAAL,CAAW0B,eAAX,CAA2BC,gBAA3B,CAA4CJ,YAAY,CAACK,oBAAzD;;AACA,WAAK5B,KAAL,CAAW0B,eAAX,CAA2BG,WAA3B,CAAuCC,SAAvC,EAAkDN,SAAlD,EAA6DC,KAA7D;AACH;AACJ,GALO;;AAOAvB,mEAAR,UAA+BqB,YAA/B,EAAkEC,SAAlE,EAAsFC,KAAtF,EAAoG;AAChG,QAAI,KAAKzB,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,WAAK1B,KAAL,CAAW0B,eAAX,CAA2BK,UAA3B,CAAsCP,SAAtC,EAAiDC,KAAjD;AACH;AACJ,GAJO;;AAMAvB,0EAAR,UAAsCqB,YAAtC,EAAuE;AACnE,QAAI,KAAKvB,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,UAAI,CAACH,YAAY,CAACK,oBAAlB,EAAwC;AACpCL,oBAAY,CAACK,oBAAb,GAAoC,KAAK5B,KAAL,CAAW0B,eAAX,CAA2BM,mBAA3B,CAA+CT,YAAY,CAACU,IAAb,GAAoB,aAAnE,EAAkFV,YAAlF,CAApC;AACH;;AACD,WAAKvB,KAAL,CAAW0B,eAAX,CAA2BC,gBAA3B,CAA4CJ,YAAY,CAACK,oBAAzD;;AACA,WAAK5B,KAAL,CAAW0B,eAAX,CAA2BQ,MAA3B;AACH;AACJ,GARO;;AAUAhC,8DAAR,UAA0BiC,MAA1B,EAAwC;AACpC,QAAI,KAAKnC,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,WAAK1B,KAAL,CAAW0B,eAAX,CAA2BC,gBAA3B,CAA4C,IAA5C;;AACA,WAAK3B,KAAL,CAAW0B,eAAX,CAA2BG,WAA3B,CAAuCM,MAAvC;AACH;AACJ,GALO;;AAOAjC,6DAAR;AACI,QAAI,KAAKF,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,WAAK1B,KAAL,CAAW0B,eAAX,CAA2BK,UAA3B;AACH;AACJ,GAJO;;AAMA7B,8DAAR;AACI,QAAI,KAAKF,KAAL,CAAW0B,eAAf,EAAgC;AAC5B,WAAK1B,KAAL,CAAW0B,eAAX,CAA2BC,gBAA3B,CAA4C,IAA5C;;AACA,WAAK3B,KAAL,CAAW0B,eAAX,CAA2BQ,MAA3B;AACH;AACJ,GALO;;AAOAhC,sEAAR,UAAkCkC,IAAlC,EAAsDC,OAAtD,EAAwEC,KAAxE,EAAgGC,MAAhG,EAAwH;AACpH,QAAI,CAACA,MAAL,EAAa;AACT;AACH,KAHmH,CAKpH;;;AACA,QAAMvC,KAAK,GAAGoC,IAAI,CAACI,QAAL,EAAd;;AACA,QAAIxC,KAAK,CAAC0B,eAAV,EAA2B;AACvB1B,WAAK,CAAC0B,eAAN,CAAsBe,wBAAtB,CAA+CF,MAA/C,EAAuDF,OAAvD;AACH;AACJ,GAVO;;AAYAnC,qEAAR,UAAiCkC,IAAjC,EAAmD;AAC/C,QAAMpC,KAAK,GAAGoC,IAAI,CAACI,QAAL,EAAd;;AAEA,QAAIxC,KAAK,CAAC0B,eAAV,EAA2B;AACvB1B,WAAK,CAAC0B,eAAN,CAAsBgB,kBAAtB;AACH;AACJ,GANO;AAQR;;;;;;AAIOxC,oDAAP;AACI;AACA,SAAKF,KAAL,CAAWF,sBAAX,GAFJ,CAII;;AACA,SAAKE,KAAL,CAAWJ,qBAAX;AACH,GANM;AAQP;;;;;AAGOM,oDAAP;AACI,SAAKF,KAAL,CAAWF,sBAAX;AACH,GAFM;;AAGX;AAAC,CApHD;;;;AAsHAd,eAAe,CAAC2D,6BAAhB,GAAgD,UAAC3C,KAAD,EAAa;AACzD;AACA,MAAI4C,SAAS,GAAG5C,KAAK,CAAC6C,aAAN,CAAoB9D,uBAAuB,CAACkB,oBAA5C,CAAhB;;AACA,MAAI,CAAC2C,SAAL,EAAgB;AACZA,aAAS,GAAG,IAAI1C,6BAAJ,CAAkCF,KAAlC,CAAZ;;AACAA,SAAK,CAAC8C,aAAN,CAAoBF,SAApB;AACH;AACJ,CAPD","names":["Scene","SceneComponentConstants","PrePassRenderer","Logger","Object","defineProperty","prototype","get","_prePassRenderer","set","value","isSupported","enumerable","configurable","enablePrePassRenderer","Error","disablePrePassRenderer","dispose","scene","NAME_PREPASSRENDERER","PrePassRendererSceneComponent","_beforeCameraDrawStage","registerStep","STEP_BEFORECAMERADRAW_PREPASS","_beforeCameraDraw","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_PREPASS","_afterCameraDraw","_beforeRenderTargetDrawStage","STEP_BEFORERENDERTARGETDRAW_PREPASS","_beforeRenderTargetDraw","_afterRenderTargetDrawStage","_afterRenderTargetDraw","_beforeClearStage","STEP_BEFORECLEARSTAGE_PREPASS","_beforeRenderTargetClearStage","STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS","_beforeRenderingMeshStage","STEP_BEFORERENDERINGMESH_PREPASS","_afterRenderingMeshStage","STEP_AFTERRENDERINGMESH_PREPASS","renderTarget","faceIndex","layer","prePassRenderer","_setRenderTarget","_prePassRenderTarget","_beforeDraw","undefined","_afterDraw","_createRenderTarget","name","_clear","camera","mesh","subMesh","batch","effect","getScene","bindAttachmentsForEffect","restoreAttachments","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/prePassRendererSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { PrePassRenderer } from \"./prePassRenderer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /** @hidden (Backing field) */\r\n        _prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the current prepass renderer associated to the scene.\r\n         */\r\n        prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Enables the prepass and associates it with the scene\r\n         * @returns the PrePassRenderer\r\n         */\r\n        enablePrePassRenderer(): Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Disables the prepass associated with the scene\r\n         */\r\n        disablePrePassRenderer(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Materials/Textures/renderTargetTexture\" {\r\n    export interface RenderTargetTexture {\r\n        /** @hidden */\r\n        _prePassRenderTarget: Nullable<PrePassRenderTarget>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\r\n    get: function (this: Scene) {\r\n        return this._prePassRenderer;\r\n    },\r\n    set: function (this: Scene, value: Nullable<PrePassRenderer>) {\r\n        if (value && value.isSupported) {\r\n            this._prePassRenderer = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.enablePrePassRenderer = function (): Nullable<PrePassRenderer> {\r\n    if (this._prePassRenderer) {\r\n        return this._prePassRenderer;\r\n    }\r\n\r\n    this._prePassRenderer = new PrePassRenderer(this);\r\n\r\n    if (!this._prePassRenderer.isSupported) {\r\n        this._prePassRenderer = null;\r\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\r\n    }\r\n\r\n    return this._prePassRenderer;\r\n};\r\n\r\nScene.prototype.disablePrePassRenderer = function (): void {\r\n    if (!this._prePassRenderer) {\r\n        return;\r\n    }\r\n\r\n    this._prePassRenderer.dispose();\r\n    this._prePassRenderer = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class PrePassRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PREPASSRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\r\n\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);\r\n        this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS, this, this._beforeRenderTargetClearStage);\r\n\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\r\n    }\r\n\r\n    private _beforeRenderTargetDraw(renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\r\n            this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _afterRenderTargetDraw(renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._afterDraw(faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _beforeRenderTargetClearStage(renderTarget: RenderTargetTexture) {\r\n        if (this.scene.prePassRenderer) {\r\n            if (!renderTarget._prePassRenderTarget) {\r\n                renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\r\n            }\r\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\r\n            this.scene.prePassRenderer._clear();\r\n        }\r\n    }\r\n\r\n    private _beforeCameraDraw(camera: Camera) {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(null);\r\n            this.scene.prePassRenderer._beforeDraw(camera);\r\n        }\r\n    }\r\n\r\n    private _afterCameraDraw() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._afterDraw();\r\n        }\r\n    }\r\n\r\n    private _beforeClearStage() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._setRenderTarget(null);\r\n            this.scene.prePassRenderer._clear();\r\n        }\r\n    }\r\n\r\n    private _beforeRenderingMeshStage(mesh: AbstractMesh, subMesh: SubMesh, batch: _InstancesBatch, effect: Nullable<Effect>) {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        // Render to MRT\r\n        const scene = mesh.getScene();\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMeshStage(mesh: AbstractMesh) {\r\n        const scene = mesh.getScene();\r\n\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.restoreAttachments();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Release textures first\r\n        this.scene.disablePrePassRenderer();\r\n\r\n        // Re-enable\r\n        this.scene.enablePrePassRenderer();\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.disablePrePassRenderer();\r\n    }\r\n}\r\n\r\nPrePassRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER) as PrePassRendererSceneComponent;\r\n    if (!component) {\r\n        component = new PrePassRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}