{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController.js\";\nimport { Node } from \"../../node.js\";\nimport { HemisphericLight } from \"../../Lights/hemisphericLight.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode.js\"; // Side effect import to add webvr support to engine\n\nimport \"../../Engines/Extensions/engine.webVR.js\";\nNode.AddNodeConstructor(\"WebVRFreeCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\n/**\n * This represents a WebVR camera.\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/divingDeeper/webXR\n * @example https://doc.babylonjs.com/how_to/webvr_camera\n */\n\nvar WebVRFreeCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebVRFreeCamera, _super);\n  /**\n   * Instantiates a WebVRFreeCamera.\n   * @param name The name of the WebVRFreeCamera\n   * @param position The starting anchor position for the camera\n   * @param scene The scene the camera belongs to\n   * @param _webVROptions a set of customizable options for the webVRCamera\n   */\n\n\n  function WebVRFreeCamera(name, position, scene, _webVROptions) {\n    if (_webVROptions === void 0) {\n      _webVROptions = {};\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n\n    _this._webVROptions = _webVROptions;\n    /**\n     * @hidden\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\n     */\n\n    _this._vrDevice = null;\n    /**\n     * The rawPose of the vrDevice.\n     */\n\n    _this.rawPose = null;\n    _this._specsVersion = \"1.1\";\n    _this._attached = false;\n    _this._descendants = []; // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n\n    _this._deviceRoomPosition = Vector3.Zero();\n    /** @hidden */\n\n    _this._deviceRoomRotationQuaternion = Quaternion.Identity();\n    _this._standingMatrix = null;\n    /**\n     * Represents device position in babylon space.\n     */\n\n    _this.devicePosition = Vector3.Zero();\n    /**\n     * Represents device rotation in babylon space.\n     */\n\n    _this.deviceRotationQuaternion = Quaternion.Identity();\n    /**\n     * The scale of the device to be used when translating from device space to babylon space.\n     */\n\n    _this.deviceScaleFactor = 1;\n    _this._deviceToWorld = Matrix.Identity();\n    _this._worldToDevice = Matrix.Identity();\n    /**\n     * References to the webVR controllers for the vrDevice.\n     */\n\n    _this.controllers = [];\n    /**\n     * Emits an event when a controller is attached.\n     */\n\n    _this.onControllersAttachedObservable = new Observable();\n    /**\n     * Emits an event when a controller's mesh has been loaded;\n     */\n\n    _this.onControllerMeshLoadedObservable = new Observable();\n    /**\n     * Emits an event when the HMD's pose has been updated.\n     */\n\n    _this.onPoseUpdatedFromDeviceObservable = new Observable();\n    _this._poseSet = false;\n    /**\n     * If the rig cameras be used as parent instead of this camera.\n     */\n\n    _this.rigParenting = true;\n    _this._defaultHeight = undefined;\n    _this._setRigMode = setWebVRRigMode.bind(null, _this);\n\n    _this._detachIfAttached = function () {\n      var vrDisplay = _this.getEngine().getVRDevice();\n\n      if (vrDisplay && !vrDisplay.isPresenting) {\n        _this.detachControl();\n      }\n    };\n\n    _this._workingVector = Vector3.Zero();\n    _this._oneVector = Vector3.One();\n    _this._workingMatrix = Matrix.Identity();\n    _this._tmpMatrix = new Matrix();\n    _this._cache.position = Vector3.Zero();\n\n    if (_webVROptions.defaultHeight) {\n      _this._defaultHeight = _webVROptions.defaultHeight;\n      _this.position.y = _this._defaultHeight;\n    }\n\n    _this.minZ = 0.1; //legacy support - the compensation boolean was removed.\n\n    if (arguments.length === 5) {\n      // eslint-disable-next-line prefer-rest-params\n      _this._webVROptions = arguments[4];\n    } // default webVR options\n\n\n    if (_this._webVROptions.trackPosition == undefined) {\n      _this._webVROptions.trackPosition = true;\n    }\n\n    if (_this._webVROptions.controllerMeshes == undefined) {\n      _this._webVROptions.controllerMeshes = true;\n    }\n\n    if (_this._webVROptions.defaultLightingOnControllers == undefined) {\n      _this._webVROptions.defaultLightingOnControllers = true;\n    }\n\n    _this.rotationQuaternion = new Quaternion();\n\n    if (_this._webVROptions && _this._webVROptions.positionScale) {\n      _this.deviceScaleFactor = _this._webVROptions.positionScale;\n    } //enable VR\n\n\n    var engine = _this.getEngine();\n\n    _this._onVREnabled = function (success) {\n      if (success) {\n        _this.initControllers();\n      }\n    };\n\n    engine.onVRRequestPresentComplete.add(_this._onVREnabled);\n    engine.initWebVR().add(function (event) {\n      if (!event.vrDisplay || _this._vrDevice === event.vrDisplay) {\n        return;\n      }\n\n      _this._vrDevice = event.vrDisplay; //reset the rig parameters.\n\n      _this.setCameraRigMode(Camera.RIG_MODE_WEBVR, {\n        parentCamera: _this,\n        vrDisplay: _this._vrDevice,\n        frameData: _this._frameData,\n        specs: _this._specsVersion\n      });\n\n      if (_this._attached) {\n        _this.getEngine().enableVR(_this._webVROptions);\n      }\n    });\n\n    if (typeof VRFrameData !== \"undefined\") {\n      _this._frameData = new VRFrameData();\n    }\n\n    if (_webVROptions.useMultiview) {\n      if (!_this.getScene().getEngine().getCaps().multiview) {\n        Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n        _this._useMultiviewToSingleView = false;\n      } else {\n        _this._useMultiviewToSingleView = true;\n        _this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", _this, 1.0);\n      }\n    }\n    /**\n     * The idea behind the following lines:\n     * objects that have the camera as parent should actually have the rig cameras as a parent.\n     * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\n     * the second will not show it correctly.\n     *\n     * To solve this - each object that has the camera as parent will be added to a protected array.\n     * When the rig camera renders, it will take this array and set all of those to be its children.\n     * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\n     * Amazing!\n     */\n\n\n    _this.getScene().onBeforeCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants = _this.getDescendants(true, function (n) {\n          // don't take the cameras or the controllers!\n          var isController = _this.controllers.some(function (controller) {\n            return controller._mesh === n;\n          });\n\n          var isRigCamera = _this._rigCameras.indexOf(n) !== -1;\n          return !isController && !isRigCamera;\n        });\n\n        _this._descendants.forEach(function (node) {\n          node.parent = camera;\n        });\n      }\n    });\n\n    _this.getScene().onAfterCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants.forEach(function (node) {\n          node.parent = _this;\n        });\n      }\n    });\n\n    return _this;\n  }\n  /**\n   * Gets the device distance from the ground in meters.\n   * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\n   */\n\n\n  WebVRFreeCamera.prototype.deviceDistanceToRoomGround = function () {\n    if (this._standingMatrix) {\n      // Add standing matrix offset to get real offset from ground in room\n      this._standingMatrix.getTranslationToRef(this._workingVector);\n\n      return this._deviceRoomPosition.y + this._workingVector.y;\n    } //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\n\n\n    return this._defaultHeight || 0;\n  };\n  /**\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n   * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  WebVRFreeCamera.prototype.useStandingMatrix = function (callback) {\n    var _this = this;\n\n    if (callback === void 0) {\n      callback = function callback(bool) {};\n    } // Use standing matrix if available\n\n\n    this.getEngine().initWebVRAsync().then(function (result) {\n      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !_this._webVROptions.trackPosition) {\n        callback(false);\n      } else {\n        _this._standingMatrix = new Matrix();\n        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, _this._standingMatrix);\n\n        if (!_this.getScene().useRightHandedSystem) {\n          if (_this._standingMatrix) {\n            _this._standingMatrix.toggleModelMatrixHandInPlace();\n          }\n        }\n\n        callback(true);\n      }\n    });\n  };\n  /**\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n   * @returns A promise with a boolean set to if the standing matrix is supported.\n   */\n\n\n  WebVRFreeCamera.prototype.useStandingMatrixAsync = function () {\n    var _this = this;\n\n    return new Promise(function (res) {\n      _this.useStandingMatrix(function (supported) {\n        res(supported);\n      });\n    });\n  };\n  /**\n   * Disposes the camera\n   */\n\n\n  WebVRFreeCamera.prototype.dispose = function () {\n    this._detachIfAttached();\n\n    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\n\n    if (this._updateCacheWhenTrackingDisabledObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Gets a vrController by name.\n   * @param name The name of the controller to retrieve\n   * @returns the controller matching the name specified or null if not found\n   */\n\n\n  WebVRFreeCamera.prototype.getControllerByName = function (name) {\n    for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {\n      var gp = _a[_i];\n\n      if (gp.hand === name) {\n        return gp;\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(WebVRFreeCamera.prototype, \"leftController\", {\n    /**\n     * The controller corresponding to the users left hand.\n     */\n    get: function get() {\n      if (!this._leftController) {\n        this._leftController = this.getControllerByName(\"left\");\n      }\n\n      return this._leftController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebVRFreeCamera.prototype, \"rightController\", {\n    /**\n     * The controller corresponding to the users right hand.\n     */\n    get: function get() {\n      if (!this._rightController) {\n        this._rightController = this.getControllerByName(\"right\");\n      }\n\n      return this._rightController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Casts a ray forward from the vrCamera's gaze.\n   * @param length Length of the ray (default: 100)\n   * @returns the ray corresponding to the gaze\n   */\n\n  WebVRFreeCamera.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (this.leftCamera) {\n      // Use left eye to avoid computation to compute center on every call\n      return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\n    } else {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n  };\n  /**\n   * @hidden\n   * Updates the camera based on device's frame data\n   */\n\n\n  WebVRFreeCamera.prototype._checkInputs = function () {\n    if (this._vrDevice && this._vrDevice.isPresenting) {\n      this._vrDevice.getFrameData(this._frameData);\n\n      this.updateFromDevice(this._frameData.pose);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /**\n   * Updates the poseControlled values based on the input device pose.\n   * @param poseData Pose coming from the device\n   */\n\n\n  WebVRFreeCamera.prototype.updateFromDevice = function (poseData) {\n    if (poseData && poseData.orientation && poseData.orientation.length === 4) {\n      this.rawPose = poseData;\n\n      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\n\n      if (this.getScene().useRightHandedSystem) {\n        this._deviceRoomRotationQuaternion.z *= -1;\n        this._deviceRoomRotationQuaternion.w *= -1;\n      }\n\n      if (this._webVROptions.trackPosition && this.rawPose.position) {\n        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n\n        if (this.getScene().useRightHandedSystem) {\n          this._deviceRoomPosition.z *= -1;\n        }\n      }\n\n      this._poseSet = true;\n    }\n  };\n  /**\n   * WebVR's attach control will start broadcasting frames to the device.\n   * Note that in certain browsers (chrome for example) this function must be called\n   * within a user-interaction callback. Example:\n   * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\n   *\n   * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\n   */\n\n\n  WebVRFreeCamera.prototype.attachControl = function (noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n\n    _super.prototype.attachControl.call(this, noPreventDefault);\n\n    this._attached = true;\n    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n\n    if (this._vrDevice) {\n      this.getEngine().enableVR(this._webVROptions);\n    }\n\n    var hostWindow = this._scene.getEngine().getHostWindow();\n\n    if (hostWindow) {\n      hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n    }\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  WebVRFreeCamera.prototype.detachControl = function () {\n    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n\n    _super.prototype.detachControl.call(this);\n\n    this._attached = false;\n    this.getEngine().disableVR();\n    window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n  };\n  /**\n   * @returns the name of this class\n   */\n\n\n  WebVRFreeCamera.prototype.getClassName = function () {\n    return \"WebVRFreeCamera\";\n  };\n  /**\n   * Calls resetPose on the vrDisplay\n   * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\n   */\n\n\n  WebVRFreeCamera.prototype.resetToCurrentRotation = function () {\n    //uses the vrDisplay's \"resetPose()\".\n    //pitch and roll won't be affected.\n    this._vrDevice.resetPose();\n  };\n  /**\n   * @hidden\n   * Updates the rig cameras (left and right eye)\n   */\n\n\n  WebVRFreeCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camLeft.position.copyFrom(this._deviceRoomPosition);\n    camRight.position.copyFrom(this._deviceRoomPosition);\n  }; // Remove translation from 6dof headset if trackposition is set to false\n\n\n  WebVRFreeCamera.prototype._correctPositionIfNotTrackPosition = function (matrix, isViewMatrix) {\n    if (isViewMatrix === void 0) {\n      isViewMatrix = false;\n    }\n\n    if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\n      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\n\n      if (!isViewMatrix) {\n        this._tmpMatrix.invert();\n      }\n\n      this._tmpMatrix.multiplyToRef(matrix, matrix);\n    }\n  };\n  /**\n   * @hidden\n   * Updates the cached values of the camera\n   * @param ignoreParentClass ignores updating the parent class's cache (default: false)\n   */\n\n\n  WebVRFreeCamera.prototype._updateCache = function (ignoreParentClass) {\n    var _this = this;\n\n    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\n      // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\n      if (!this._updateCacheCalled) {\n        // make sure it is only called once per loop. this.update() might cause an infinite loop.\n        this._updateCacheCalled = true;\n        this.update();\n      } // Set working vector to the device position in room space rotated by the new rotation\n\n\n      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\n      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector); // Subtract this vector from the current device position in world to get the translation for the device world matrix\n\n      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\n      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld); // Add translation from anchor position\n\n      this._deviceToWorld.getTranslationToRef(this._workingVector);\n\n      this._workingVector.addInPlace(this.position);\n\n      this._workingVector.subtractInPlace(this._cache.position);\n\n      this._deviceToWorld.setTranslation(this._workingVector); // Set an inverted matrix to be used when updating the camera\n\n\n      this._deviceToWorld.invertToRef(this._worldToDevice); // Update the gamepad to ensure the mesh is updated on the same frame as camera\n\n\n      this.controllers.forEach(function (controller) {\n        controller._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\n\n        controller.update();\n      });\n    }\n\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    this._updateCacheCalled = false;\n  };\n  /**\n   * @hidden\n   * Get current device position in babylon world\n   */\n\n\n  WebVRFreeCamera.prototype._computeDevicePosition = function () {\n    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n  };\n  /**\n   * Updates the current device position and rotation in the babylon world\n   */\n\n\n  WebVRFreeCamera.prototype.update = function () {\n    this._computeDevicePosition(); // Get current device rotation in babylon world\n\n\n    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\n\n    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n\n    if (this._poseSet) {\n      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\n    }\n\n    _super.prototype.update.call(this);\n  };\n  /**\n   * @hidden\n   * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\n   * @returns an identity matrix\n   */\n\n\n  WebVRFreeCamera.prototype._getViewMatrix = function () {\n    return Matrix.Identity();\n  };\n  /**\n   * This function is called by the two RIG cameras.\n   * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\n   * @hidden\n   */\n\n\n  WebVRFreeCamera.prototype._getWebVRViewMatrix = function () {\n    // Update the parent camera prior to using a child camera to avoid desynchronization\n    var parentCamera = this._cameraRigParams[\"parentCamera\"];\n\n    parentCamera._updateCache(); //WebVR 1.1\n\n\n    var viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._webvrViewMatrix.toggleModelMatrixHandInPlace();\n    } // update the camera rotation matrix\n\n\n    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget); // should the view matrix be updated with scale and position offset?\n\n    if (parentCamera.deviceScaleFactor !== 1) {\n      this._webvrViewMatrix.invert(); // scale the position, if set\n\n\n      if (parentCamera.deviceScaleFactor) {\n        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\n      }\n\n      this._webvrViewMatrix.invert();\n    } // Remove translation from 6dof headset if trackposition is set to false\n\n\n    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\n\n    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix); // Compute global position\n\n\n    this._workingMatrix = this._workingMatrix || Matrix.Identity();\n\n    this._webvrViewMatrix.invertToRef(this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\n\n    this._workingMatrix.getTranslationToRef(this._globalPosition);\n\n    this._markSyncedWithParent();\n\n    return this._webvrViewMatrix;\n  };\n  /** @hidden */\n\n\n  WebVRFreeCamera.prototype._getWebVRProjectionMatrix = function () {\n    var parentCamera = this.parent;\n    parentCamera._vrDevice.depthNear = parentCamera.minZ;\n    parentCamera._vrDevice.depthFar = parentCamera.maxZ;\n    var projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix); //babylon compatible matrix\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._projectionMatrix.toggleProjectionMatrixHandInPlace();\n    }\n\n    return this._projectionMatrix;\n  };\n  /**\n   * Initializes the controllers and their meshes\n   */\n\n\n  WebVRFreeCamera.prototype.initControllers = function () {\n    var _this = this;\n\n    this.controllers = [];\n    var manager = this.getScene().gamepadManager;\n    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController = gamepad;\n\n        if (webVrController.defaultModel) {\n          webVrController.defaultModel.setEnabled(false);\n        }\n\n        if (webVrController.hand === \"right\") {\n          _this._rightController = null;\n        }\n\n        if (webVrController.hand === \"left\") {\n          _this._leftController = null;\n        }\n\n        var controllerIndex = _this.controllers.indexOf(webVrController);\n\n        if (controllerIndex !== -1) {\n          _this.controllers.splice(controllerIndex, 1);\n        }\n      }\n    });\n    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController_1 = gamepad;\n\n        if (!_this._webVROptions.trackPosition) {\n          webVrController_1._disableTrackPosition(new Vector3(webVrController_1.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25)); // Cache must be updated before rendering controllers to avoid them being one frame behind\n\n\n          if (!_this._updateCacheWhenTrackingDisabledObserver) {\n            _this._updateCacheWhenTrackingDisabledObserver = _this._scene.onBeforeRenderObservable.add(function () {\n              _this._updateCache();\n            });\n          }\n        }\n\n        webVrController_1.deviceScaleFactor = _this.deviceScaleFactor;\n\n        webVrController_1._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(webVrController_1._deviceToWorld);\n\n        if (_this._webVROptions.controllerMeshes) {\n          if (webVrController_1.defaultModel) {\n            webVrController_1.defaultModel.setEnabled(true);\n          } else {\n            // Load the meshes\n            webVrController_1.initControllerMesh(_this.getScene(), function (loadedMesh) {\n              loadedMesh.scaling.scaleInPlace(_this.deviceScaleFactor);\n\n              _this.onControllerMeshLoadedObservable.notifyObservers(webVrController_1);\n\n              if (_this._webVROptions.defaultLightingOnControllers) {\n                if (!_this._lightOnControllers) {\n                  _this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), _this.getScene());\n                }\n\n                var activateLightOnSubMeshes_1 = function activateLightOnSubMeshes_1(mesh, light) {\n                  var children = mesh.getChildren();\n\n                  if (children && children.length !== 0) {\n                    children.forEach(function (mesh) {\n                      light.includedOnlyMeshes.push(mesh);\n                      activateLightOnSubMeshes_1(mesh, light);\n                    });\n                  }\n                };\n\n                _this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\n\n                activateLightOnSubMeshes_1(loadedMesh, _this._lightOnControllers);\n              }\n            });\n          }\n        }\n\n        webVrController_1.attachToPoseControlledCamera(_this); // since this is async - sanity check. Is the controller already stored?\n\n        if (_this.controllers.indexOf(webVrController_1) === -1) {\n          //add to the controllers array\n          _this.controllers.push(webVrController_1); // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n          // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n          // So we're overriding setting left & right manually to be sure\n\n\n          var firstViveWandDetected = false;\n\n          for (var i = 0; i < _this.controllers.length; i++) {\n            if (_this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\n              if (!firstViveWandDetected) {\n                firstViveWandDetected = true;\n                _this.controllers[i].hand = \"left\";\n              } else {\n                _this.controllers[i].hand = \"right\";\n              }\n            }\n          } //did we find enough controllers? Great! let the developer know.\n\n\n          if (_this.controllers.length >= 2) {\n            _this.onControllersAttachedObservable.notifyObservers(_this.controllers);\n          }\n        }\n      }\n    });\n  };\n\n  return WebVRFreeCamera;\n}(FreeCamera);\n\nexport { WebVRFreeCamera };","map":{"version":3,"mappings":"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","names":["Observable","FreeCamera","Camera","Quaternion","Matrix","Vector3","Gamepad","PoseEnabledControllerType","Node","HemisphericLight","Logger","VRMultiviewToSingleviewPostProcess","Tools","setWebVRRigMode","AddNodeConstructor","name","scene","WebVRFreeCamera","Zero","__extends","position","_webVROptions","_super","_this","Identity","undefined","bind","vrDisplay","getEngine","getVRDevice","isPresenting","detachControl","One","_cache","defaultHeight","_defaultHeight","y","minZ","arguments","length","trackPosition","controllerMeshes","defaultLightingOnControllers","rotationQuaternion","positionScale","deviceScaleFactor","engine","_onVREnabled","success","initControllers","onVRRequestPresentComplete","add","initWebVR","event","_vrDevice","setCameraRigMode","RIG_MODE_WEBVR","parentCamera","frameData","_frameData","specs","_specsVersion","_attached","enableVR","VRFrameData","useMultiview","getScene","getCaps","multiview","Warn","_useMultiviewToSingleView","_rigPostProcess","onBeforeCameraRenderObservable","camera","parent","rigParenting","_descendants","getDescendants","n","isController","controllers","some","controller","_mesh","isRigCamera","_rigCameras","indexOf","forEach","node","onAfterCameraRenderObservable","_standingMatrix","getTranslationToRef","_workingVector","_deviceRoomPosition","callback","bool","initWebVRAsync","then","result","stageParameters","sittingToStandingTransform","FromFloat32ArrayToRefScaled","useRightHandedSystem","toggleModelMatrixHandInPlace","Promise","res","useStandingMatrix","supported","_detachIfAttached","removeCallback","_updateCacheWhenTrackingDisabledObserver","_scene","onBeforeRenderObservable","remove","dispose","call","_i","gp","hand","Object","_leftController","getControllerByName","_rightController","leftCamera","getForwardRay","getWorldMatrix","globalPosition","getFrameData","updateFromDevice","pose","_checkInputs","poseData","orientation","rawPose","_deviceRoomRotationQuaternion","copyFromFloats","z","w","_poseSet","noPreventDefault","BackCompatCameraNoPreventDefault","attachControl","ForceAttachControlToAlwaysPreventDefault","hostWindow","getHostWindow","addEventListener","gamepadManager","onGamepadConnectedObservable","_onGamepadConnectedObserver","onGamepadDisconnectedObservable","_onGamepadDisconnectedObserver","disableVR","window","removeEventListener","resetPose","camLeft","camRight","copyFrom","matrix","isViewMatrix","TranslationToRef","_tmpMatrix","invert","multiplyToRef","ignoreParentClass","equals","_updateCacheCalled","update","toRotationMatrix","_workingMatrix","TransformCoordinatesToRef","devicePosition","subtractToRef","ComposeToRef","_oneVector","_deviceToWorld","addInPlace","subtractInPlace","setTranslation","invertToRef","_worldToDevice","_correctPositionIfNotTrackPosition","_updateCache","_computeDevicePosition","FromQuaternionToRef","FromRotationMatrixToRef","deviceRotationQuaternion","onPoseUpdatedFromDeviceObservable","notifyObservers","_cameraRigParams","viewArray","leftViewMatrix","rightViewMatrix","FromArrayToRef","_webvrViewMatrix","getRotationMatrixToRef","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","addToRef","_currentTarget","multiplyAtIndex","_globalPosition","_markSyncedWithParent","depthNear","depthFar","maxZ","projectionArray","leftProjectionMatrix","rightProjectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","manager","gamepad","type","POSE_ENABLED","webVrController","defaultModel","setEnabled","controllerIndex","splice","webVrController_1","_disableTrackPosition","initControllerMesh","loadedMesh","scaling","scaleInPlace","onControllerMeshLoadedObservable","_lightOnControllers","activateLightOnSubMeshes_1","mesh","light","children","getChildren","includedOnlyMeshes","push","attachToPoseControlledCamera","firstViveWandDetected","i","controllerType","VIVE","onControllersAttachedObservable"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/VR/webVRCamera.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\r\nimport type { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\r\nimport type { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport { Node } from \"../../node\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode\";\r\n\r\n// Side effect import to add webvr support to engine\r\nimport \"../../Engines/Extensions/engine.webVR\";\r\n\r\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose\r\n * IMPORTANT!! The data is right-hand data.\r\n * @export\r\n * @interface DevicePose\r\n */\r\nexport interface DevicePose {\r\n    /**\r\n     * The position of the device, values in array are [x,y,z].\r\n     */\r\n    readonly position: Nullable<Float32Array>;\r\n    /**\r\n     * The linearVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The linearAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearAcceleration: Nullable<Float32Array>;\r\n\r\n    /**\r\n     * The orientation of the device in a quaternion array, values in array are [x,y,z,w].\r\n     */\r\n    readonly orientation: Nullable<Float32Array>;\r\n    /**\r\n     * The angularVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The angularAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularAcceleration: Nullable<Float32Array>;\r\n}\r\n\r\n/**\r\n * Interface representing a pose controlled object in Babylon.\r\n * A pose controlled object has both regular pose values as well as pose values\r\n * from an external device such as a VR head mounted display\r\n */\r\nexport interface PoseControlled {\r\n    /**\r\n     * The position of the object in babylon space.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation quaternion of the object in babylon space.\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n    /**\r\n     * The position of the device in babylon space.\r\n     */\r\n    devicePosition?: Vector3;\r\n    /**\r\n     * The rotation quaternion of the device in babylon space.\r\n     */\r\n    deviceRotationQuaternion: Quaternion;\r\n    /**\r\n     * The raw pose coming from the device.\r\n     */\r\n    rawPose: Nullable<DevicePose>;\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    deviceScaleFactor: number;\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData the pose data to update the object with\r\n     */\r\n    updateFromDevice(poseData: DevicePose): void;\r\n}\r\n\r\n/**\r\n * Set of options to customize the webVRCamera\r\n */\r\nexport interface WebVROptions {\r\n    /**\r\n     * Sets if the webVR camera should be tracked to the vrDevice. (default: true)\r\n     */\r\n    trackPosition?: boolean;\r\n    /**\r\n     * Sets the scale of the vrDevice in babylon space. (default: 1)\r\n     */\r\n    positionScale?: number;\r\n    /**\r\n     * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)\r\n     */\r\n    displayName?: string;\r\n    /**\r\n     * Should the native controller meshes be initialized. (default: true)\r\n     */\r\n    controllerMeshes?: boolean;\r\n    /**\r\n     * Creating a default HemiLight only on controllers. (default: true)\r\n     */\r\n    defaultLightingOnControllers?: boolean;\r\n    /**\r\n     * If you don't want to use the default VR button of the helper. (default: false)\r\n     */\r\n    useCustomVRButton?: boolean;\r\n\r\n    /**\r\n     * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)\r\n     */\r\n    customVRButton?: HTMLButtonElement;\r\n\r\n    /**\r\n     * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)\r\n     */\r\n    rayLength?: number;\r\n\r\n    /**\r\n     * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)\r\n     */\r\n    defaultHeight?: number;\r\n\r\n    /**\r\n     * If multiview should be used if available (default: false)\r\n     */\r\n    useMultiview?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/divingDeeper/webXR\r\n * @example https://doc.babylonjs.com/how_to/webvr_camera\r\n */\r\nexport class WebVRFreeCamera extends FreeCamera implements PoseControlled {\r\n    /**\r\n     * @hidden\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\r\n    public _vrDevice: any = null;\r\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\r\n    public rawPose: Nullable<DevicePose> = null;\r\n    private _onVREnabled: (success: boolean) => void;\r\n    private _specsVersion: string = \"1.1\";\r\n    private _attached: boolean = false;\r\n\r\n    private _frameData: any;\r\n\r\n    protected _descendants: Array<Node> = [];\r\n\r\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\r\n    private _deviceRoomPosition = Vector3.Zero();\r\n    /** @hidden */\r\n    public _deviceRoomRotationQuaternion = Quaternion.Identity();\r\n\r\n    private _standingMatrix: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Represents device position in babylon space.\r\n     */\r\n    public devicePosition = Vector3.Zero();\r\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\r\n    public deviceRotationQuaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    public deviceScaleFactor: number = 1;\r\n\r\n    private _deviceToWorld = Matrix.Identity();\r\n    private _worldToDevice = Matrix.Identity();\r\n\r\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\r\n    public controllers: Array<WebVRController> = [];\r\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\r\n    public onControllersAttachedObservable = new Observable<Array<WebVRController>>();\r\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\r\n    public onControllerMeshLoadedObservable = new Observable<WebVRController>();\r\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\r\n    public onPoseUpdatedFromDeviceObservable = new Observable<any>();\r\n    private _poseSet = false;\r\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\r\n    public rigParenting: boolean = true;\r\n\r\n    private _lightOnControllers: HemisphericLight;\r\n\r\n    private _defaultHeight?: number = undefined;\r\n\r\n    /**\r\n     * Instantiates a WebVRFreeCamera.\r\n     * @param name The name of the WebVRFreeCamera\r\n     * @param position The starting anchor position for the camera\r\n     * @param scene The scene the camera belongs to\r\n     * @param _webVROptions a set of customizable options for the webVRCamera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, private _webVROptions: WebVROptions = {}) {\r\n        super(name, position, scene);\r\n        this._cache.position = Vector3.Zero();\r\n        if (_webVROptions.defaultHeight) {\r\n            this._defaultHeight = _webVROptions.defaultHeight;\r\n            this.position.y = this._defaultHeight;\r\n        }\r\n\r\n        this.minZ = 0.1;\r\n\r\n        //legacy support - the compensation boolean was removed.\r\n        if (arguments.length === 5) {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            this._webVROptions = arguments[4];\r\n        }\r\n\r\n        // default webVR options\r\n        if (this._webVROptions.trackPosition == undefined) {\r\n            this._webVROptions.trackPosition = true;\r\n        }\r\n        if (this._webVROptions.controllerMeshes == undefined) {\r\n            this._webVROptions.controllerMeshes = true;\r\n        }\r\n        if (this._webVROptions.defaultLightingOnControllers == undefined) {\r\n            this._webVROptions.defaultLightingOnControllers = true;\r\n        }\r\n\r\n        this.rotationQuaternion = new Quaternion();\r\n\r\n        if (this._webVROptions && this._webVROptions.positionScale) {\r\n            this.deviceScaleFactor = this._webVROptions.positionScale;\r\n        }\r\n\r\n        //enable VR\r\n        const engine = this.getEngine();\r\n        this._onVREnabled = (success: boolean) => {\r\n            if (success) {\r\n                this.initControllers();\r\n            }\r\n        };\r\n        engine.onVRRequestPresentComplete.add(this._onVREnabled);\r\n        engine.initWebVR().add((event: IDisplayChangedEventArgs) => {\r\n            if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\r\n                return;\r\n            }\r\n\r\n            this._vrDevice = event.vrDisplay;\r\n\r\n            //reset the rig parameters.\r\n            this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });\r\n\r\n            if (this._attached) {\r\n                this.getEngine().enableVR(this._webVROptions);\r\n            }\r\n        });\r\n\r\n        if (typeof VRFrameData !== \"undefined\") {\r\n            this._frameData = new VRFrameData();\r\n        }\r\n\r\n        if (_webVROptions.useMultiview) {\r\n            if (!this.getScene().getEngine().getCaps().multiview) {\r\n                Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n                this._useMultiviewToSingleView = false;\r\n            } else {\r\n                this._useMultiviewToSingleView = true;\r\n                this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The idea behind the following lines:\r\n         * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n         * the second will not show it correctly.\r\n         *\r\n         * To solve this - each object that has the camera as parent will be added to a protected array.\r\n         * When the rig camera renders, it will take this array and set all of those to be its children.\r\n         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n         * Amazing!\r\n         */\r\n        this.getScene().onBeforeCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants = this.getDescendants(true, (n) => {\r\n                    // don't take the cameras or the controllers!\r\n                    const isController = this.controllers.some((controller) => {\r\n                        return controller._mesh === n;\r\n                    });\r\n                    const isRigCamera = this._rigCameras.indexOf(<Camera>n) !== -1;\r\n                    return !isController && !isRigCamera;\r\n                });\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = camera;\r\n                });\r\n            }\r\n        });\r\n\r\n        this.getScene().onAfterCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = this;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _setRigMode = setWebVRRigMode.bind(null, this);\r\n\r\n    /**\r\n     * Gets the device distance from the ground in meters.\r\n     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n     */\r\n    public deviceDistanceToRoomGround(): number {\r\n        if (this._standingMatrix) {\r\n            // Add standing matrix offset to get real offset from ground in room\r\n            this._standingMatrix.getTranslationToRef(this._workingVector);\r\n            return this._deviceRoomPosition.y + this._workingVector.y;\r\n        }\r\n        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\r\n        return this._defaultHeight || 0;\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public useStandingMatrix(callback = (bool: boolean) => {}) {\r\n        // Use standing matrix if available\r\n        this.getEngine()\r\n            .initWebVRAsync()\r\n            .then((result) => {\r\n                if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {\r\n                    callback(false);\r\n                } else {\r\n                    this._standingMatrix = new Matrix();\r\n                    Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\r\n                    if (!this.getScene().useRightHandedSystem) {\r\n                        if (this._standingMatrix) {\r\n                            this._standingMatrix.toggleModelMatrixHandInPlace();\r\n                        }\r\n                    }\r\n                    callback(true);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @returns A promise with a boolean set to if the standing matrix is supported.\r\n     */\r\n    public useStandingMatrixAsync(): Promise<boolean> {\r\n        return new Promise((res) => {\r\n            this.useStandingMatrix((supported) => {\r\n                res(supported);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the camera\r\n     */\r\n    public dispose(): void {\r\n        this._detachIfAttached();\r\n        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\r\n        if (this._updateCacheWhenTrackingDisabledObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets a vrController by name.\r\n     * @param name The name of the controller to retrieve\r\n     * @returns the controller matching the name specified or null if not found\r\n     */\r\n    public getControllerByName(name: string): Nullable<WebVRController> {\r\n        for (const gp of this.controllers) {\r\n            if (gp.hand === name) {\r\n                return gp;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _leftController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\r\n    public get leftController(): Nullable<WebVRController> {\r\n        if (!this._leftController) {\r\n            this._leftController = this.getControllerByName(\"left\");\r\n        }\r\n\r\n        return this._leftController;\r\n    }\r\n\r\n    private _rightController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\r\n    public get rightController(): Nullable<WebVRController> {\r\n        if (!this._rightController) {\r\n            this._rightController = this.getControllerByName(\"right\");\r\n        }\r\n\r\n        return this._rightController;\r\n    }\r\n\r\n    /**\r\n     * Casts a ray forward from the vrCamera's gaze.\r\n     * @param length Length of the ray (default: 100)\r\n     * @returns the ray corresponding to the gaze\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (this.leftCamera) {\r\n            // Use left eye to avoid computation to compute center on every call\r\n            return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\r\n        } else {\r\n            return super.getForwardRay(length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the camera based on device's frame data\r\n     */\r\n    public _checkInputs(): void {\r\n        if (this._vrDevice && this._vrDevice.isPresenting) {\r\n            this._vrDevice.getFrameData(this._frameData);\r\n\r\n            this.updateFromDevice(this._frameData.pose);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData Pose coming from the device\r\n     */\r\n    updateFromDevice(poseData: DevicePose) {\r\n        if (poseData && poseData.orientation && poseData.orientation.length === 4) {\r\n            this.rawPose = poseData;\r\n            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                this._deviceRoomRotationQuaternion.z *= -1;\r\n                this._deviceRoomRotationQuaternion.w *= -1;\r\n            }\r\n            if (this._webVROptions.trackPosition && this.rawPose.position) {\r\n                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\r\n                if (this.getScene().useRightHandedSystem) {\r\n                    this._deviceRoomPosition.z *= -1;\r\n                }\r\n            }\r\n            this._poseSet = true;\r\n        }\r\n    }\r\n\r\n    private _detachIfAttached = () => {\r\n        const vrDisplay = this.getEngine().getVRDevice();\r\n        if (vrDisplay && !vrDisplay.isPresenting) {\r\n            this.detachControl();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * WebVR's attach control will start broadcasting frames to the device.\r\n     * Note that in certain browsers (chrome for example) this function must be called\r\n     * within a user-interaction callback. Example:\r\n     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n     *\r\n     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        super.attachControl(noPreventDefault);\r\n        this._attached = true;\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n\r\n        if (this._vrDevice) {\r\n            this.getEngine().enableVR(this._webVROptions);\r\n        }\r\n\r\n        const hostWindow = this._scene.getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n\r\n        super.detachControl();\r\n        this._attached = false;\r\n        this.getEngine().disableVR();\r\n        window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n    }\r\n\r\n    /**\r\n     * @returns the name of this class\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebVRFreeCamera\";\r\n    }\r\n\r\n    /**\r\n     * Calls resetPose on the vrDisplay\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n     */\r\n    public resetToCurrentRotation() {\r\n        //uses the vrDisplay's \"resetPose()\".\r\n        //pitch and roll won't be affected.\r\n        this._vrDevice.resetPose();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the rig cameras (left and right eye)\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n\r\n        camLeft.position.copyFrom(this._deviceRoomPosition);\r\n        camRight.position.copyFrom(this._deviceRoomPosition);\r\n    }\r\n\r\n    private _workingVector = Vector3.Zero();\r\n    private _oneVector = Vector3.One();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    private _updateCacheCalled: boolean;\r\n\r\n    // Remove translation from 6dof headset if trackposition is set to false\r\n    private _correctPositionIfNotTrackPosition(matrix: Matrix, isViewMatrix = false) {\r\n        if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\r\n            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\r\n            if (!isViewMatrix) {\r\n                this._tmpMatrix.invert();\r\n            }\r\n            this._tmpMatrix.multiplyToRef(matrix, matrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the cached values of the camera\r\n     * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\r\n            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\r\n            if (!this._updateCacheCalled) {\r\n                // make sure it is only called once per loop. this.update() might cause an infinite loop.\r\n                this._updateCacheCalled = true;\r\n                this.update();\r\n            }\r\n\r\n            // Set working vector to the device position in room space rotated by the new rotation\r\n            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\r\n            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\r\n\r\n            // Subtract this vector from the current device position in world to get the translation for the device world matrix\r\n            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\r\n            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\r\n\r\n            // Add translation from anchor position\r\n            this._deviceToWorld.getTranslationToRef(this._workingVector);\r\n            this._workingVector.addInPlace(this.position);\r\n            this._workingVector.subtractInPlace(this._cache.position);\r\n            this._deviceToWorld.setTranslation(this._workingVector);\r\n\r\n            // Set an inverted matrix to be used when updating the camera\r\n            this._deviceToWorld.invertToRef(this._worldToDevice);\r\n\r\n            // Update the gamepad to ensure the mesh is updated on the same frame as camera\r\n            this.controllers.forEach((controller) => {\r\n                controller._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\r\n                controller.update();\r\n            });\r\n        }\r\n\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n        this._updateCacheCalled = false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Get current device position in babylon world\r\n     */\r\n    public _computeDevicePosition() {\r\n        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\r\n    }\r\n\r\n    /**\r\n     * Updates the current device position and rotation in the babylon world\r\n     */\r\n    public update() {\r\n        this._computeDevicePosition();\r\n\r\n        // Get current device rotation in babylon world\r\n        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\r\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\r\n\r\n        if (this._poseSet) {\r\n            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\r\n        }\r\n        super.update();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n     * @returns an identity matrix\r\n     */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * This function is called by the two RIG cameras.\r\n     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n     * @hidden\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        // Update the parent camera prior to using a child camera to avoid desynchronization\r\n        const parentCamera: WebVRFreeCamera = this._cameraRigParams[\"parentCamera\"];\r\n        parentCamera._updateCache();\r\n\r\n        //WebVR 1.1\r\n        const viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\r\n\r\n        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\r\n\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._webvrViewMatrix.toggleModelMatrixHandInPlace();\r\n        }\r\n\r\n        // update the camera rotation matrix\r\n        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n\r\n        // should the view matrix be updated with scale and position offset?\r\n        if (parentCamera.deviceScaleFactor !== 1) {\r\n            this._webvrViewMatrix.invert();\r\n            // scale the position, if set\r\n            if (parentCamera.deviceScaleFactor) {\r\n                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\r\n            }\r\n\r\n            this._webvrViewMatrix.invert();\r\n        }\r\n\r\n        // Remove translation from 6dof headset if trackposition is set to false\r\n        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\r\n\r\n        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\r\n\r\n        // Compute global position\r\n        this._workingMatrix = this._workingMatrix || Matrix.Identity();\r\n        this._webvrViewMatrix.invertToRef(this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\r\n        this._workingMatrix.getTranslationToRef(this._globalPosition);\r\n        this._markSyncedWithParent();\r\n\r\n        return this._webvrViewMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n        const parentCamera = <WebVRFreeCamera>this.parent;\r\n\r\n        parentCamera._vrDevice.depthNear = parentCamera.minZ;\r\n        parentCamera._vrDevice.depthFar = parentCamera.maxZ;\r\n\r\n        const projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\r\n        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\r\n\r\n        //babylon compatible matrix\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n        }\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _updateCacheWhenTrackingDisabledObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * Initializes the controllers and their meshes\r\n     */\r\n    public initControllers() {\r\n        this.controllers = [];\r\n\r\n        const manager = this.getScene().gamepadManager;\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n\r\n                if (webVrController.defaultModel) {\r\n                    webVrController.defaultModel.setEnabled(false);\r\n                }\r\n\r\n                if (webVrController.hand === \"right\") {\r\n                    this._rightController = null;\r\n                }\r\n                if (webVrController.hand === \"left\") {\r\n                    this._leftController = null;\r\n                }\r\n                const controllerIndex = this.controllers.indexOf(webVrController);\r\n                if (controllerIndex !== -1) {\r\n                    this.controllers.splice(controllerIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n                if (!this._webVROptions.trackPosition) {\r\n                    webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\r\n                    // Cache must be updated before rendering controllers to avoid them being one frame behind\r\n                    if (!this._updateCacheWhenTrackingDisabledObserver) {\r\n                        this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n                            this._updateCache();\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.deviceScaleFactor = this.deviceScaleFactor;\r\n                webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\r\n\r\n                if (this._webVROptions.controllerMeshes) {\r\n                    if (webVrController.defaultModel) {\r\n                        webVrController.defaultModel.setEnabled(true);\r\n                    } else {\r\n                        // Load the meshes\r\n                        webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {\r\n                            loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\r\n                            this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\r\n                            if (this._webVROptions.defaultLightingOnControllers) {\r\n                                if (!this._lightOnControllers) {\r\n                                    this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\r\n                                }\r\n                                const activateLightOnSubMeshes = function (mesh: AbstractMesh, light: HemisphericLight) {\r\n                                    const children = mesh.getChildren();\r\n                                    if (children && children.length !== 0) {\r\n                                        children.forEach((mesh) => {\r\n                                            light.includedOnlyMeshes.push(<AbstractMesh>mesh);\r\n                                            activateLightOnSubMeshes(<AbstractMesh>mesh, light);\r\n                                        });\r\n                                    }\r\n                                };\r\n                                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\r\n                                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.attachToPoseControlledCamera(this);\r\n\r\n                // since this is async - sanity check. Is the controller already stored?\r\n                if (this.controllers.indexOf(webVrController) === -1) {\r\n                    //add to the controllers array\r\n                    this.controllers.push(webVrController);\r\n\r\n                    // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\r\n                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\r\n                    // So we're overriding setting left & right manually to be sure\r\n                    let firstViveWandDetected = false;\r\n\r\n                    for (let i = 0; i < this.controllers.length; i++) {\r\n                        if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\r\n                            if (!firstViveWandDetected) {\r\n                                firstViveWandDetected = true;\r\n                                this.controllers[i].hand = \"left\";\r\n                            } else {\r\n                                this.controllers[i].hand = \"right\";\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //did we find enough controllers? Great! let the developer know.\r\n                    if (this.controllers.length >= 2) {\r\n                        this.onControllersAttachedObservable.notifyObservers(this.controllers);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}