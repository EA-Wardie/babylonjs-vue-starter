{"ast":null,"code":"import \"core-js/modules/es.array.is-array.js\";\nimport { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { DDSTools } from \"../../../Misc/dds.js\";\nimport { EndsWith } from \"../../../Misc/stringTools.js\";\n/**\n * Implementation of the DDS Texture Loader.\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _DDSTextureLoader =\n/** @class */\nfunction () {\n  function _DDSTextureLoader() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = true;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n\n\n  _DDSTextureLoader.prototype.canLoad = function (extension) {\n    return EndsWith(extension, \".dds\");\n  };\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param imgs contains the cube maps\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   */\n\n\n  _DDSTextureLoader.prototype.loadCubeData = function (imgs, texture, createPolynomials, onLoad) {\n    var engine = texture.getEngine();\n    var info;\n    var loadMipmap = false;\n    var maxLevel = 1000;\n\n    if (Array.isArray(imgs)) {\n      for (var index = 0; index < imgs.length; index++) {\n        var data = imgs[index];\n        info = DDSTools.GetDDSInfo(data);\n        texture.width = info.width;\n        texture.height = info.height;\n        loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n\n        engine._unpackFlipY(info.isCompressed);\n\n        DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\n\n        if (!info.isFourCC && info.mipmapCount === 1) {\n          engine.generateMipMapsForCubemap(texture);\n        } else {\n          maxLevel = info.mipmapCount - 1;\n        }\n      }\n    } else {\n      var data = imgs;\n      info = DDSTools.GetDDSInfo(data);\n      texture.width = info.width;\n      texture.height = info.height;\n\n      if (createPolynomials) {\n        info.sphericalPolynomial = new SphericalPolynomial();\n      }\n\n      loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n\n      engine._unpackFlipY(info.isCompressed);\n\n      DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\n\n      if (!info.isFourCC && info.mipmapCount === 1) {\n        // Do not unbind as we still need to set the parameters.\n        engine.generateMipMapsForCubemap(texture, false);\n      } else {\n        maxLevel = info.mipmapCount - 1;\n      }\n    }\n\n    engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\n\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n\n    if (onLoad) {\n      onLoad({\n        isDDS: true,\n        width: texture.width,\n        info: info,\n        data: imgs,\n        texture: texture\n      });\n    }\n  };\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param callback defines the method to call once ready to upload\n   */\n\n\n  _DDSTextureLoader.prototype.loadData = function (data, texture, callback) {\n    var info = DDSTools.GetDDSInfo(data);\n    var loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> info.mipmapCount - 1 === 1;\n    callback(info.width, info.height, loadMipmap, info.isFourCC, function () {\n      DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\n    });\n  };\n\n  return _DDSTextureLoader;\n}();\n\nexport { _DDSTextureLoader }; // Register the loader.\n\nEngine._TextureLoaders.push(new _DDSTextureLoader());","map":{"version":3,"mappings":"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","names":["SphericalPolynomial","Engine","DDSTools","EndsWith","_DDSTextureLoader","extension","imgs","texture","createPolynomials","onLoad","engine","getEngine","info","loadMipmap","maxLevel","Array","isArray","index","length","data","GetDDSInfo","width","height","isRGB","isLuminance","mipmapCount","generateMipMaps","_unpackFlipY","isCompressed","UploadDDSLevels","isFourCC","generateMipMapsForCubemap","sphericalPolynomial","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","isDDS","callback","_TextureLoaders","push"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Loaders/ddsTextureLoader.ts"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport type { DDSInfo } from \"../../../Misc/dds\";\r\nimport { DDSTools } from \"../../../Misc/dds\";\r\nimport { EndsWith } from \"../../../Misc/stringTools\";\r\n/**\r\n * Implementation of the DDS Texture Loader.\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _DDSTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = true;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return EndsWith(extension, \".dds\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param imgs contains the cube maps\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(imgs: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        const engine = texture.getEngine() as Engine;\r\n        let info: DDSInfo | undefined;\r\n        let loadMipmap: boolean = false;\r\n        let maxLevel: number = 1000;\r\n        if (Array.isArray(imgs)) {\r\n            for (let index = 0; index < imgs.length; index++) {\r\n                const data = imgs[index];\r\n                info = DDSTools.GetDDSInfo(data);\r\n\r\n                texture.width = info.width;\r\n                texture.height = info.height;\r\n\r\n                loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n\r\n                engine._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\r\n\r\n                if (!info.isFourCC && info.mipmapCount === 1) {\r\n                    engine.generateMipMapsForCubemap(texture);\r\n                } else {\r\n                    maxLevel = info.mipmapCount - 1;\r\n                }\r\n            }\r\n        } else {\r\n            const data = imgs;\r\n            info = DDSTools.GetDDSInfo(data);\r\n\r\n            texture.width = info.width;\r\n            texture.height = info.height;\r\n\r\n            if (createPolynomials) {\r\n                info.sphericalPolynomial = new SphericalPolynomial();\r\n            }\r\n\r\n            loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n            engine._unpackFlipY(info.isCompressed);\r\n\r\n            DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\r\n\r\n            if (!info.isFourCC && info.mipmapCount === 1) {\r\n                // Do not unbind as we still need to set the parameters.\r\n                engine.generateMipMapsForCubemap(texture, false);\r\n            } else {\r\n                maxLevel = info.mipmapCount - 1;\r\n            }\r\n        }\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const info = DDSTools.GetDDSInfo(data);\r\n\r\n        const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> (info.mipmapCount - 1) === 1;\r\n        callback(info.width, info.height, loadMipmap, info.isFourCC, () => {\r\n            DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\r\n        });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _DDSTextureLoader());\r\n"]},"metadata":{},"sourceType":"module"}