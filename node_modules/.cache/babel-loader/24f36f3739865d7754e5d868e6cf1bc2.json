{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.define-property.js\";\n\n/**\n * This class implement a typical dictionary using a string as key and the generic type T as value.\n * The underlying implementation relies on an associative array to ensure the best performances.\n * The value can be anything including 'null' but except 'undefined'\n */\nvar StringDictionary =\n/** @class */\nfunction () {\n  function StringDictionary() {\n    this._count = 0;\n    this._data = {};\n  }\n  /**\n   * This will clear this dictionary and copy the content from the 'source' one.\n   * If the T value is a custom object, it won't be copied/cloned, the same object will be used\n   * @param source the dictionary to take the content from and copy to this dictionary\n   */\n\n\n  StringDictionary.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    this.clear();\n    source.forEach(function (t, v) {\n      return _this.add(t, v);\n    });\n  };\n  /**\n   * Get a value based from its key\n   * @param key the given key to get the matching value from\n   * @return the value if found, otherwise undefined is returned\n   */\n\n\n  StringDictionary.prototype.get = function (key) {\n    var val = this._data[key];\n\n    if (val !== undefined) {\n      return val;\n    }\n\n    return undefined;\n  };\n  /**\n   * Get a value from its key or add it if it doesn't exist.\n   * This method will ensure you that a given key/data will be present in the dictionary.\n   * @param key the given key to get the matching value from\n   * @param factory the factory that will create the value if the key is not present in the dictionary.\n   * The factory will only be invoked if there's no data for the given key.\n   * @return the value corresponding to the key.\n   */\n\n\n  StringDictionary.prototype.getOrAddWithFactory = function (key, factory) {\n    var val = this.get(key);\n\n    if (val !== undefined) {\n      return val;\n    }\n\n    val = factory(key);\n\n    if (val) {\n      this.add(key, val);\n    }\n\n    return val;\n  };\n  /**\n   * Get a value from its key if present in the dictionary otherwise add it\n   * @param key the key to get the value from\n   * @param val if there's no such key/value pair in the dictionary add it with this value\n   * @return the value corresponding to the key\n   */\n\n\n  StringDictionary.prototype.getOrAdd = function (key, val) {\n    var curVal = this.get(key);\n\n    if (curVal !== undefined) {\n      return curVal;\n    }\n\n    this.add(key, val);\n    return val;\n  };\n  /**\n   * Check if there's a given key in the dictionary\n   * @param key the key to check for\n   * @return true if the key is present, false otherwise\n   */\n\n\n  StringDictionary.prototype.contains = function (key) {\n    return this._data[key] !== undefined;\n  };\n  /**\n   * Add a new key and its corresponding value\n   * @param key the key to add\n   * @param value the value corresponding to the key\n   * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\n   */\n\n\n  StringDictionary.prototype.add = function (key, value) {\n    if (this._data[key] !== undefined) {\n      return false;\n    }\n\n    this._data[key] = value;\n    ++this._count;\n    return true;\n  };\n  /**\n   * Update a specific value associated to a key\n   * @param key defines the key to use\n   * @param value defines the value to store\n   * @returns true if the value was updated (or false if the key was not found)\n   */\n\n\n  StringDictionary.prototype.set = function (key, value) {\n    if (this._data[key] === undefined) {\n      return false;\n    }\n\n    this._data[key] = value;\n    return true;\n  };\n  /**\n   * Get the element of the given key and remove it from the dictionary\n   * @param key defines the key to search\n   * @returns the value associated with the key or null if not found\n   */\n\n\n  StringDictionary.prototype.getAndRemove = function (key) {\n    var val = this.get(key);\n\n    if (val !== undefined) {\n      delete this._data[key];\n      --this._count;\n      return val;\n    }\n\n    return null;\n  };\n  /**\n   * Remove a key/value from the dictionary.\n   * @param key the key to remove\n   * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary\n   */\n\n\n  StringDictionary.prototype.remove = function (key) {\n    if (this.contains(key)) {\n      delete this._data[key];\n      --this._count;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Clear the whole content of the dictionary\n   */\n\n\n  StringDictionary.prototype.clear = function () {\n    this._data = {};\n    this._count = 0;\n  };\n\n  Object.defineProperty(StringDictionary.prototype, \"count\", {\n    /**\n     * Gets the current count\n     */\n    get: function get() {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Execute a callback on each key/val of the dictionary.\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute on a given key/value pair\n   */\n\n  StringDictionary.prototype.forEach = function (callback) {\n    for (var cur in this._data) {\n      var val = this._data[cur];\n      callback(cur, val);\n    }\n  };\n  /**\n   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\n   * If the callback returns null or undefined the method will iterate to the next key/value pair\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\n   * @returns the first item\n   */\n\n\n  StringDictionary.prototype.first = function (callback) {\n    for (var cur in this._data) {\n      var val = this._data[cur];\n      var res = callback(cur, val);\n\n      if (res) {\n        return res;\n      }\n    }\n\n    return null;\n  };\n\n  return StringDictionary;\n}();\n\nexport { StringDictionary };","map":{"version":3,"mappings":"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","names":["StringDictionary","source","clear","forEach","t","v","add","key","val","_data","undefined","factory","get","curVal","value","_count","contains","Object","callback","cur","res"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/stringDictionary.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * This class implement a typical dictionary using a string as key and the generic type T as value.\r\n * The underlying implementation relies on an associative array to ensure the best performances.\r\n * The value can be anything including 'null' but except 'undefined'\r\n */\r\nexport class StringDictionary<T> {\r\n    /**\r\n     * This will clear this dictionary and copy the content from the 'source' one.\r\n     * If the T value is a custom object, it won't be copied/cloned, the same object will be used\r\n     * @param source the dictionary to take the content from and copy to this dictionary\r\n     */\r\n    public copyFrom(source: StringDictionary<T>) {\r\n        this.clear();\r\n        source.forEach((t, v) => this.add(t, v));\r\n    }\r\n\r\n    /**\r\n     * Get a value based from its key\r\n     * @param key the given key to get the matching value from\r\n     * @return the value if found, otherwise undefined is returned\r\n     */\r\n    public get(key: string): T | undefined {\r\n        const val = this._data[key];\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key or add it if it doesn't exist.\r\n     * This method will ensure you that a given key/data will be present in the dictionary.\r\n     * @param key the given key to get the matching value from\r\n     * @param factory the factory that will create the value if the key is not present in the dictionary.\r\n     * The factory will only be invoked if there's no data for the given key.\r\n     * @return the value corresponding to the key.\r\n     */\r\n    public getOrAddWithFactory(key: string, factory: (key: string) => T): T {\r\n        let val = this.get(key);\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n\r\n        val = factory(key);\r\n        if (val) {\r\n            this.add(key, val);\r\n        }\r\n\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key if present in the dictionary otherwise add it\r\n     * @param key the key to get the value from\r\n     * @param val if there's no such key/value pair in the dictionary add it with this value\r\n     * @return the value corresponding to the key\r\n     */\r\n    public getOrAdd(key: string, val: T): T {\r\n        const curVal = this.get(key);\r\n        if (curVal !== undefined) {\r\n            return curVal;\r\n        }\r\n\r\n        this.add(key, val);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Check if there's a given key in the dictionary\r\n     * @param key the key to check for\r\n     * @return true if the key is present, false otherwise\r\n     */\r\n    public contains(key: string): boolean {\r\n        return this._data[key] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Add a new key and its corresponding value\r\n     * @param key the key to add\r\n     * @param value the value corresponding to the key\r\n     * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\r\n     */\r\n    public add(key: string, value: T): boolean {\r\n        if (this._data[key] !== undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        ++this._count;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update a specific value associated to a key\r\n     * @param key defines the key to use\r\n     * @param value defines the value to store\r\n     * @returns true if the value was updated (or false if the key was not found)\r\n     */\r\n    public set(key: string, value: T): boolean {\r\n        if (this._data[key] === undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the element of the given key and remove it from the dictionary\r\n     * @param key defines the key to search\r\n     * @returns the value associated with the key or null if not found\r\n     */\r\n    public getAndRemove(key: string): Nullable<T> {\r\n        const val = this.get(key);\r\n        if (val !== undefined) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return val;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a key/value from the dictionary.\r\n     * @param key the key to remove\r\n     * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary\r\n     */\r\n    public remove(key: string): boolean {\r\n        if (this.contains(key)) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Clear the whole content of the dictionary\r\n     */\r\n    public clear() {\r\n        this._data = {};\r\n        this._count = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current count\r\n     */\r\n    public get count() {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on each key/val of the dictionary.\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute on a given key/value pair\r\n     */\r\n    public forEach(callback: (key: string, val: T) => void) {\r\n        for (const cur in this._data) {\r\n            const val = this._data[cur];\r\n            callback(cur, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\r\n     * If the callback returns null or undefined the method will iterate to the next key/value pair\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\r\n     * @returns the first item\r\n     */\r\n    public first<TRes>(callback: (key: string, val: T) => TRes) {\r\n        for (const cur in this._data) {\r\n            const val = this._data[cur];\r\n            const res = callback(cur, val);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _count = 0;\r\n    private _data: { [key: string]: T } = {};\r\n}\r\n"]},"metadata":{},"sourceType":"module"}