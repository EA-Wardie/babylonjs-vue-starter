{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\"; // Sets the default audio engine to Babylon.js\n\nEngine.AudioEngineFactory = function (hostElement, audioContext, audioDestination) {\n  return new AudioEngine(hostElement, audioContext, audioDestination);\n};\n/**\n * This represents the default audio engine used in babylon.\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\n */\n\n\nvar AudioEngine =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new audio engine.\n   *\n   * There should be only one per page as some browsers restrict the number\n   * of audio contexts you can create.\n   * @param hostElement defines the host element where to display the mute icon if necessary\n   * @param audioContext defines the audio context to be used by the audio engine\n   * @param audioDestination defines the audio destination node to be used by audio engine\n   */\n  function AudioEngine(hostElement, audioContext, audioDestination) {\n    if (hostElement === void 0) {\n      hostElement = null;\n    }\n\n    if (audioContext === void 0) {\n      audioContext = null;\n    }\n\n    if (audioDestination === void 0) {\n      audioDestination = null;\n    }\n\n    var _this = this;\n\n    this._audioContext = null;\n    this._audioContextInitialized = false;\n    this._muteButton = null;\n    this._audioDestination = null;\n    /**\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\n     */\n\n    this.canUseWebAudio = false;\n    /**\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\n     * @ignoreNaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n\n    this.WarnedWebAudioUnsupported = false;\n    /**\n     * Gets whether or not mp3 are supported by your browser.\n     */\n\n    this.isMP3supported = false;\n    /**\n     * Gets whether or not ogg are supported by your browser.\n     */\n\n    this.isOGGsupported = false;\n    /**\n     * Gets whether audio has been unlocked on the device.\n     * Some Browsers have strong restrictions about Audio and won t autoplay unless\n     * a user interaction has happened.\n     */\n\n    this.unlocked = true;\n    /**\n     * Defines if the audio engine relies on a custom unlocked button.\n     * In this case, the embedded button will not be displayed.\n     */\n\n    this.useCustomUnlockedButton = false;\n    /**\n     * Event raised when audio has been unlocked on the browser.\n     */\n\n    this.onAudioUnlockedObservable = new Observable();\n    /**\n     * Event raised when audio has been locked on the browser.\n     */\n\n    this.onAudioLockedObservable = new Observable();\n    this._tryToRun = false;\n\n    this._onResize = function () {\n      _this._moveButtonToTopLeft();\n    };\n\n    if (!IsWindowObjectExist()) {\n      return;\n    }\n\n    if (typeof window.AudioContext !== \"undefined\" || typeof window.webkitAudioContext !== \"undefined\") {\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n      this.canUseWebAudio = true;\n    }\n\n    var audioElem = document.createElement(\"audio\");\n    this._hostElement = hostElement;\n    this._audioContext = audioContext;\n    this._audioDestination = audioDestination;\n\n    try {\n      if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") || audioElem.canPlayType(\"audio/mp3\").replace(/^no$/, \"\"))) {\n        this.isMP3supported = true;\n      }\n    } catch (e) {// protect error during capability check.\n    }\n\n    try {\n      if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\")) {\n        this.isOGGsupported = true;\n      }\n    } catch (e) {// protect error during capability check.\n    }\n  }\n\n  Object.defineProperty(AudioEngine.prototype, \"audioContext\", {\n    /**\n     * Gets the current AudioContext if available.\n     */\n    get: function get() {\n      if (!this._audioContextInitialized) {\n        this._initializeAudioContext();\n      } else {\n        if (!this.unlocked && !this._muteButton) {\n          this._displayMuteButton();\n        }\n      }\n\n      return this._audioContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Flags the audio engine in Locked state.\n   * This happens due to new browser policies preventing audio to autoplay.\n   */\n\n  AudioEngine.prototype.lock = function () {\n    this._triggerSuspendedState();\n  };\n  /**\n   * Unlocks the audio engine once a user action has been done on the dom.\n   * This is helpful to resume play once browser policies have been satisfied.\n   */\n\n\n  AudioEngine.prototype.unlock = function () {\n    this._triggerRunningState();\n  };\n\n  AudioEngine.prototype._resumeAudioContext = function () {\n    var result;\n\n    if (this._audioContext.resume !== undefined) {\n      result = this._audioContext.resume();\n    }\n\n    return result || Promise.resolve();\n  };\n\n  AudioEngine.prototype._initializeAudioContext = function () {\n    try {\n      if (this.canUseWebAudio) {\n        if (!this._audioContext) {\n          this._audioContext = new AudioContext();\n        } // create a global volume gain node\n\n\n        this.masterGain = this._audioContext.createGain();\n        this.masterGain.gain.value = 1;\n\n        if (!this._audioDestination) {\n          this._audioDestination = this._audioContext.destination;\n        }\n\n        this.masterGain.connect(this._audioDestination);\n        this._audioContextInitialized = true;\n\n        if (this._audioContext.state === \"running\") {\n          // Do not wait for the promise to unlock.\n          this._triggerRunningState();\n        }\n      }\n    } catch (e) {\n      this.canUseWebAudio = false;\n      Logger.Error(\"Web Audio: \" + e.message);\n    }\n  };\n\n  AudioEngine.prototype._triggerRunningState = function () {\n    var _this = this;\n\n    if (this._tryToRun) {\n      return;\n    }\n\n    this._tryToRun = true;\n\n    this._resumeAudioContext().then(function () {\n      _this._tryToRun = false;\n\n      if (_this._muteButton) {\n        _this._hideMuteButton();\n      } // Notify users that the audio stack is unlocked/unmuted\n\n\n      _this.unlocked = true;\n\n      _this.onAudioUnlockedObservable.notifyObservers(_this);\n    })[\"catch\"](function () {\n      _this._tryToRun = false;\n      _this.unlocked = false;\n    });\n  };\n\n  AudioEngine.prototype._triggerSuspendedState = function () {\n    this.unlocked = false;\n    this.onAudioLockedObservable.notifyObservers(this);\n\n    this._displayMuteButton();\n  };\n\n  AudioEngine.prototype._displayMuteButton = function () {\n    var _this = this;\n\n    if (this.useCustomUnlockedButton || this._muteButton) {\n      return;\n    }\n\n    this._muteButton = document.createElement(\"BUTTON\");\n    this._muteButton.className = \"babylonUnmuteIcon\";\n    this._muteButton.id = \"babylonUnmuteIconBtn\";\n    this._muteButton.title = \"Unmute\";\n    var imageUrl = !window.SVGSVGElement ? \"https://cdn.babylonjs.com/Assets/audio.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\";\n    var css = \".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(\" + imageUrl + \");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\";\n    var style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    document.getElementsByTagName(\"head\")[0].appendChild(style);\n    document.body.appendChild(this._muteButton);\n\n    this._moveButtonToTopLeft();\n\n    this._muteButton.addEventListener(\"touchend\", function () {\n      _this._triggerRunningState();\n    }, true);\n\n    this._muteButton.addEventListener(\"click\", function () {\n      _this._triggerRunningState();\n    }, true);\n\n    window.addEventListener(\"resize\", this._onResize);\n  };\n\n  AudioEngine.prototype._moveButtonToTopLeft = function () {\n    if (this._hostElement && this._muteButton) {\n      this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\";\n      this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\";\n    }\n  };\n\n  AudioEngine.prototype._hideMuteButton = function () {\n    if (this._muteButton) {\n      document.body.removeChild(this._muteButton);\n      this._muteButton = null;\n    }\n  };\n  /**\n   * Destroy and release the resources associated with the audio context.\n   */\n\n\n  AudioEngine.prototype.dispose = function () {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      if (this._connectedAnalyser && this._audioContext) {\n        this._connectedAnalyser.stopDebugCanvas();\n\n        this._connectedAnalyser.dispose();\n\n        this.masterGain.disconnect();\n        this.masterGain.connect(this._audioContext.destination);\n        this._connectedAnalyser = null;\n      }\n\n      this.masterGain.gain.value = 1;\n    }\n\n    this.WarnedWebAudioUnsupported = false;\n\n    this._hideMuteButton();\n\n    window.removeEventListener(\"resize\", this._onResize);\n    this.onAudioUnlockedObservable.clear();\n    this.onAudioLockedObservable.clear();\n  };\n  /**\n   * Gets the global volume sets on the master gain.\n   * @returns the global volume if set or -1 otherwise\n   */\n\n\n  AudioEngine.prototype.getGlobalVolume = function () {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      return this.masterGain.gain.value;\n    } else {\n      return -1;\n    }\n  };\n  /**\n   * Sets the global volume of your experience (sets on the master gain).\n   * @param newVolume Defines the new global volume of the application\n   */\n\n\n  AudioEngine.prototype.setGlobalVolume = function (newVolume) {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      this.masterGain.gain.value = newVolume;\n    }\n  };\n  /**\n   * Connect the audio engine to an audio analyser allowing some amazing\n   * synchronization between the sounds/music and your visualization (VuMeter for instance).\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser\n   * @param analyser The analyser to connect to the engine\n   */\n\n\n  AudioEngine.prototype.connectToAnalyser = function (analyser) {\n    if (this._connectedAnalyser) {\n      this._connectedAnalyser.stopDebugCanvas();\n    }\n\n    if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {\n      this._connectedAnalyser = analyser;\n      this.masterGain.disconnect();\n\n      this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\n    }\n  };\n\n  return AudioEngine;\n}();\n\nexport { AudioEngine };","map":{"version":3,"mappings":"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","names":["Observable","Logger","Engine","IsWindowObjectExist","AudioEngineFactory","hostElement","audioContext","audioDestination","AudioEngine","_this","_moveButtonToTopLeft","window","AudioContext","webkitAudioContext","canUseWebAudio","audioElem","document","createElement","_hostElement","_audioContext","_audioDestination","canPlayType","replace","isMP3supported","e","isOGGsupported","Object","_audioContextInitialized","_initializeAudioContext","unlocked","_muteButton","_displayMuteButton","_triggerSuspendedState","_triggerRunningState","result","resume","undefined","Promise","resolve","masterGain","createGain","gain","value","destination","connect","state","Error","message","_tryToRun","_resumeAudioContext","then","_hideMuteButton","onAudioUnlockedObservable","notifyObservers","onAudioLockedObservable","useCustomUnlockedButton","className","id","title","imageUrl","SVGSVGElement","css","style","appendChild","createTextNode","getElementsByTagName","body","addEventListener","_onResize","top","offsetTop","left","offsetLeft","removeChild","_connectedAnalyser","stopDebugCanvas","dispose","disconnect","WarnedWebAudioUnsupported","removeEventListener","clear","newVolume","analyser","connectAudioNodes"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Audio/audioEngine.ts"],"sourcesContent":["import type { Analyser } from \"./analyser\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\n\r\n// Sets the default audio engine to Babylon.js\r\nEngine.AudioEngineFactory = (\r\n    hostElement: Nullable<HTMLElement>,\r\n    audioContext: Nullable<AudioContext>,\r\n    audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n) => {\r\n    return new AudioEngine(hostElement, audioContext, audioDestination);\r\n};\r\n\r\n/**\r\n * This represents the default audio engine used in babylon.\r\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\r\nexport class AudioEngine implements IAudioEngine {\r\n    private _audioContext: Nullable<AudioContext> = null;\r\n    private _audioContextInitialized = false;\r\n    private _muteButton: Nullable<HTMLButtonElement> = null;\r\n    private _hostElement: Nullable<HTMLElement>;\r\n    private _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null;\r\n\r\n    /**\r\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\r\n     */\r\n    public canUseWebAudio: boolean = false;\r\n\r\n    /**\r\n     * The master gain node defines the global audio volume of your audio engine.\r\n     */\r\n    public masterGain: GainNode;\r\n\r\n    /**\r\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\r\n     * @ignoreNaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public WarnedWebAudioUnsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not mp3 are supported by your browser.\r\n     */\r\n    public isMP3supported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not ogg are supported by your browser.\r\n     */\r\n    public isOGGsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether audio has been unlocked on the device.\r\n     * Some Browsers have strong restrictions about Audio and won t autoplay unless\r\n     * a user interaction has happened.\r\n     */\r\n    public unlocked: boolean = true;\r\n\r\n    /**\r\n     * Defines if the audio engine relies on a custom unlocked button.\r\n     * In this case, the embedded button will not be displayed.\r\n     */\r\n    public useCustomUnlockedButton: boolean = false;\r\n\r\n    /**\r\n     * Event raised when audio has been unlocked on the browser.\r\n     */\r\n    public onAudioUnlockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Event raised when audio has been locked on the browser.\r\n     */\r\n    public onAudioLockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Gets the current AudioContext if available.\r\n     */\r\n    public get audioContext(): Nullable<AudioContext> {\r\n        if (!this._audioContextInitialized) {\r\n            this._initializeAudioContext();\r\n        } else {\r\n            if (!this.unlocked && !this._muteButton) {\r\n                this._displayMuteButton();\r\n            }\r\n        }\r\n        return this._audioContext;\r\n    }\r\n\r\n    private _connectedAnalyser: Nullable<Analyser>;\r\n\r\n    /**\r\n     * Instantiates a new audio engine.\r\n     *\r\n     * There should be only one per page as some browsers restrict the number\r\n     * of audio contexts you can create.\r\n     * @param hostElement defines the host element where to display the mute icon if necessary\r\n     * @param audioContext defines the audio context to be used by the audio engine\r\n     * @param audioDestination defines the audio destination node to be used by audio engine\r\n     */\r\n    constructor(\r\n        hostElement: Nullable<HTMLElement> = null,\r\n        audioContext: Nullable<AudioContext> = null,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null\r\n    ) {\r\n        if (!IsWindowObjectExist()) {\r\n            return;\r\n        }\r\n        if (typeof window.AudioContext !== \"undefined\" || typeof window.webkitAudioContext !== \"undefined\") {\r\n            window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n            this.canUseWebAudio = true;\r\n        }\r\n\r\n        const audioElem = document.createElement(\"audio\");\r\n        this._hostElement = hostElement;\r\n        this._audioContext = audioContext;\r\n        this._audioDestination = audioDestination;\r\n\r\n        try {\r\n            if (\r\n                audioElem &&\r\n                !!audioElem.canPlayType &&\r\n                (audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") || audioElem.canPlayType(\"audio/mp3\").replace(/^no$/, \"\"))\r\n            ) {\r\n                this.isMP3supported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n\r\n        try {\r\n            if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\")) {\r\n                this.isOGGsupported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flags the audio engine in Locked state.\r\n     * This happens due to new browser policies preventing audio to autoplay.\r\n     */\r\n    public lock() {\r\n        this._triggerSuspendedState();\r\n    }\r\n\r\n    /**\r\n     * Unlocks the audio engine once a user action has been done on the dom.\r\n     * This is helpful to resume play once browser policies have been satisfied.\r\n     */\r\n    public unlock() {\r\n        this._triggerRunningState();\r\n    }\r\n\r\n    private _resumeAudioContext(): Promise<void> {\r\n        let result: Promise<void>;\r\n        if (this._audioContext!.resume !== undefined) {\r\n            result = this._audioContext!.resume();\r\n        }\r\n        return result! || Promise.resolve();\r\n    }\r\n\r\n    private _initializeAudioContext() {\r\n        try {\r\n            if (this.canUseWebAudio) {\r\n                if (!this._audioContext) {\r\n                    this._audioContext = new AudioContext();\r\n                }\r\n                // create a global volume gain node\r\n                this.masterGain = this._audioContext.createGain();\r\n                this.masterGain.gain.value = 1;\r\n                if (!this._audioDestination) {\r\n                    this._audioDestination = this._audioContext.destination;\r\n                }\r\n                this.masterGain.connect(this._audioDestination);\r\n                this._audioContextInitialized = true;\r\n                if (this._audioContext.state === \"running\") {\r\n                    // Do not wait for the promise to unlock.\r\n                    this._triggerRunningState();\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.canUseWebAudio = false;\r\n            Logger.Error(\"Web Audio: \" + e.message);\r\n        }\r\n    }\r\n\r\n    private _tryToRun = false;\r\n    private _triggerRunningState() {\r\n        if (this._tryToRun) {\r\n            return;\r\n        }\r\n        this._tryToRun = true;\r\n\r\n        this._resumeAudioContext()\r\n            .then(() => {\r\n                this._tryToRun = false;\r\n                if (this._muteButton) {\r\n                    this._hideMuteButton();\r\n                }\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            })\r\n            .catch(() => {\r\n                this._tryToRun = false;\r\n                this.unlocked = false;\r\n            });\r\n    }\r\n\r\n    private _triggerSuspendedState() {\r\n        this.unlocked = false;\r\n        this.onAudioLockedObservable.notifyObservers(this);\r\n        this._displayMuteButton();\r\n    }\r\n\r\n    private _displayMuteButton() {\r\n        if (this.useCustomUnlockedButton || this._muteButton) {\r\n            return;\r\n        }\r\n\r\n        this._muteButton = <HTMLButtonElement>document.createElement(\"BUTTON\");\r\n        this._muteButton.className = \"babylonUnmuteIcon\";\r\n        this._muteButton.id = \"babylonUnmuteIconBtn\";\r\n        this._muteButton.title = \"Unmute\";\r\n        const imageUrl = !window.SVGSVGElement\r\n            ? \"https://cdn.babylonjs.com/Assets/audio.png\"\r\n            : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\";\r\n\r\n        const css =\r\n            \".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n            imageUrl +\r\n            \");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\";\r\n\r\n        const style = document.createElement(\"style\");\r\n        style.appendChild(document.createTextNode(css));\r\n        document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n\r\n        document.body.appendChild(this._muteButton);\r\n\r\n        this._moveButtonToTopLeft();\r\n\r\n        this._muteButton.addEventListener(\r\n            \"touchend\",\r\n            () => {\r\n                this._triggerRunningState();\r\n            },\r\n            true\r\n        );\r\n        this._muteButton.addEventListener(\r\n            \"click\",\r\n            () => {\r\n                this._triggerRunningState();\r\n            },\r\n            true\r\n        );\r\n\r\n        window.addEventListener(\"resize\", this._onResize);\r\n    }\r\n\r\n    private _moveButtonToTopLeft() {\r\n        if (this._hostElement && this._muteButton) {\r\n            this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\";\r\n            this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\";\r\n        }\r\n    }\r\n\r\n    private _onResize = () => {\r\n        this._moveButtonToTopLeft();\r\n    };\r\n\r\n    private _hideMuteButton() {\r\n        if (this._muteButton) {\r\n            document.body.removeChild(this._muteButton);\r\n            this._muteButton = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy and release the resources associated with the audio context.\r\n     */\r\n    public dispose(): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            if (this._connectedAnalyser && this._audioContext) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n                this._connectedAnalyser.dispose();\r\n                this.masterGain.disconnect();\r\n                this.masterGain.connect(this._audioContext.destination);\r\n                this._connectedAnalyser = null;\r\n            }\r\n            this.masterGain.gain.value = 1;\r\n        }\r\n        this.WarnedWebAudioUnsupported = false;\r\n        this._hideMuteButton();\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n\r\n        this.onAudioUnlockedObservable.clear();\r\n        this.onAudioLockedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the global volume sets on the master gain.\r\n     * @returns the global volume if set or -1 otherwise\r\n     */\r\n    public getGlobalVolume(): number {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            return this.masterGain.gain.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the global volume of your experience (sets on the master gain).\r\n     * @param newVolume Defines the new global volume of the application\r\n     */\r\n    public setGlobalVolume(newVolume: number): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            this.masterGain.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the audio engine to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {\r\n            this._connectedAnalyser = analyser;\r\n            this.masterGain.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}