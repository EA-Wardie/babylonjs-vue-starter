{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport \"../Engines/Extensions/engine.uniformBuffer.js\";\n/**\n * Uniform buffer objects.\n *\n * Handles blocks of uniform on the GPU.\n *\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n *\n * For more information, please refer to :\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n */\n\nvar UniformBuffer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Uniform buffer objects.\n   *\n   * Handles blocks of uniform on the GPU.\n   *\n   * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n   *\n   * For more information, please refer to :\n   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n   * @param engine Define the engine the buffer is associated with\n   * @param data Define the data contained in the buffer\n   * @param dynamic Define if the buffer is updatable\n   * @param name to assign to the buffer (debugging purpose)\n   * @param forceNoUniformBuffer define that this object must not rely on UBO objects\n   */\n  function UniformBuffer(engine, data, dynamic, name, forceNoUniformBuffer) {\n    if (forceNoUniformBuffer === void 0) {\n      forceNoUniformBuffer = false;\n    } // Matrix cache\n\n\n    this._valueCache = {};\n    this._engine = engine;\n    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\n    this._dynamic = dynamic;\n    this._name = name !== null && name !== void 0 ? name : \"no-name\";\n    this._data = data || [];\n    this._uniformLocations = {};\n    this._uniformSizes = {};\n    this._uniformArraySizes = {};\n    this._uniformLocationPointer = 0;\n    this._needSync = false;\n\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers = [];\n      this._bufferIndex = -1;\n      this._createBufferOnWrite = false;\n      this._currentFrameId = 0;\n    }\n\n    if (this._noUBO) {\n      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n      this.updateFloat = this._updateFloatForEffect;\n      this.updateFloat2 = this._updateFloat2ForEffect;\n      this.updateFloat3 = this._updateFloat3ForEffect;\n      this.updateFloat4 = this._updateFloat4ForEffect;\n      this.updateFloatArray = this._updateFloatArrayForEffect;\n      this.updateArray = this._updateArrayForEffect;\n      this.updateIntArray = this._updateIntArrayForEffect;\n      this.updateMatrix = this._updateMatrixForEffect;\n      this.updateMatrices = this._updateMatricesForEffect;\n      this.updateVector3 = this._updateVector3ForEffect;\n      this.updateVector4 = this._updateVector4ForEffect;\n      this.updateColor3 = this._updateColor3ForEffect;\n      this.updateColor4 = this._updateColor4ForEffect;\n      this.updateDirectColor4 = this._updateDirectColor4ForEffect;\n      this.updateInt = this._updateIntForEffect;\n      this.updateInt2 = this._updateInt2ForEffect;\n      this.updateInt3 = this._updateInt3ForEffect;\n      this.updateInt4 = this._updateInt4ForEffect;\n    } else {\n      this._engine._uniformBuffers.push(this);\n\n      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n      this.updateFloat = this._updateFloatForUniform;\n      this.updateFloat2 = this._updateFloat2ForUniform;\n      this.updateFloat3 = this._updateFloat3ForUniform;\n      this.updateFloat4 = this._updateFloat4ForUniform;\n      this.updateFloatArray = this._updateFloatArrayForUniform;\n      this.updateArray = this._updateArrayForUniform;\n      this.updateIntArray = this._updateIntArrayForUniform;\n      this.updateMatrix = this._updateMatrixForUniform;\n      this.updateMatrices = this._updateMatricesForUniform;\n      this.updateVector3 = this._updateVector3ForUniform;\n      this.updateVector4 = this._updateVector4ForUniform;\n      this.updateColor3 = this._updateColor3ForUniform;\n      this.updateColor4 = this._updateColor4ForUniform;\n      this.updateDirectColor4 = this._updateDirectColor4ForUniform;\n      this.updateInt = this._updateIntForUniform;\n      this.updateInt2 = this._updateInt2ForUniform;\n      this.updateInt3 = this._updateInt3ForUniform;\n      this.updateInt4 = this._updateInt4ForUniform;\n    }\n  }\n\n  Object.defineProperty(UniformBuffer.prototype, \"useUbo\", {\n    /**\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\n     * or just falling back on setUniformXXX calls.\n     */\n    get: function get() {\n      return !this._noUBO;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UniformBuffer.prototype, \"isSync\", {\n    /**\n     * Indicates if the WebGL underlying uniform buffer is in sync\n     * with the javascript cache data.\n     */\n    get: function get() {\n      return !this._needSync;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Indicates if the WebGL underlying uniform buffer is dynamic.\n   * Also, a dynamic UniformBuffer will disable cache verification and always\n   * update the underlying WebGL uniform buffer to the GPU.\n   * @returns if Dynamic, otherwise false\n   */\n\n  UniformBuffer.prototype.isDynamic = function () {\n    return this._dynamic !== undefined;\n  };\n  /**\n   * The data cache on JS side.\n   * @returns the underlying data as a float array\n   */\n\n\n  UniformBuffer.prototype.getData = function () {\n    return this._bufferData;\n  };\n  /**\n   * The underlying WebGL Uniform buffer.\n   * @returns the webgl buffer\n   */\n\n\n  UniformBuffer.prototype.getBuffer = function () {\n    return this._buffer;\n  };\n  /**\n   * std140 layout specifies how to align data within an UBO structure.\n   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\n   * for specs.\n   * @param size\n   */\n\n\n  UniformBuffer.prototype._fillAlignment = function (size) {\n    // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n    // and 4x4 matrices\n    // TODO : change if other types are used\n    var alignment;\n\n    if (size <= 2) {\n      alignment = size;\n    } else {\n      alignment = 4;\n    }\n\n    if (this._uniformLocationPointer % alignment !== 0) {\n      var oldPointer = this._uniformLocationPointer;\n      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;\n      var diff = this._uniformLocationPointer - oldPointer;\n\n      for (var i = 0; i < diff; i++) {\n        this._data.push(0);\n      }\n    }\n  };\n  /**\n   * Adds an uniform in the buffer.\n   * Warning : the subsequents calls of this function must be in the same order as declared in the shader\n   * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\n   * meaning size=1,2,3,4 or 16. It does not handle struct types.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param size Data size, or data directly.\n   * @param arraySize The number of elements in the array, 0 if not an array.\n   */\n\n\n  UniformBuffer.prototype.addUniform = function (name, size, arraySize) {\n    if (arraySize === void 0) {\n      arraySize = 0;\n    }\n\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._uniformLocations[name] !== undefined) {\n      // Already existing uniform\n      return;\n    } // This function must be called in the order of the shader layout !\n    // size can be the size of the uniform, or data directly\n\n\n    var data; // std140 FTW...\n\n    if (arraySize > 0) {\n      if (size instanceof Array) {\n        throw \"addUniform should not be use with Array in UBO: \" + name;\n      }\n\n      this._fillAlignment(4);\n\n      this._uniformArraySizes[name] = {\n        strideSize: size,\n        arraySize: arraySize\n      };\n\n      if (size == 16) {\n        size = size * arraySize;\n      } else {\n        var perElementPadding = 4 - size;\n        var totalPadding = perElementPadding * arraySize;\n        size = size * arraySize + totalPadding;\n      }\n\n      data = []; // Fill with zeros\n\n      for (var i = 0; i < size; i++) {\n        data.push(0);\n      }\n    } else {\n      if (size instanceof Array) {\n        data = size;\n        size = data.length;\n      } else {\n        size = size;\n        data = []; // Fill with zeros\n\n        for (var i = 0; i < size; i++) {\n          data.push(0);\n        }\n      }\n\n      this._fillAlignment(size);\n    }\n\n    this._uniformSizes[name] = size;\n    this._uniformLocations[name] = this._uniformLocationPointer;\n    this._uniformLocationPointer += size;\n\n    for (var i = 0; i < size; i++) {\n      this._data.push(data[i]);\n    }\n\n    this._needSync = true;\n  };\n  /**\n   * Adds a Matrix 4x4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param mat A 4x4 matrix.\n   */\n\n\n  UniformBuffer.prototype.addMatrix = function (name, mat) {\n    this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\n  };\n  /**\n   * Adds a vec2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec2\n   * @param y Define the y component value of the vec2\n   */\n\n\n  UniformBuffer.prototype.addFloat2 = function (name, x, y) {\n    var temp = [x, y];\n    this.addUniform(name, temp);\n  };\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec3\n   * @param y Define the y component value of the vec3\n   * @param z Define the z component value of the vec3\n   */\n\n\n  UniformBuffer.prototype.addFloat3 = function (name, x, y, z) {\n    var temp = [x, y, z];\n    this.addUniform(name, temp);\n  };\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the vec3 from a Color\n   */\n\n\n  UniformBuffer.prototype.addColor3 = function (name, color) {\n    var temp = [color.r, color.g, color.b];\n    this.addUniform(name, temp);\n  };\n  /**\n   * Adds a vec4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the rgb components from a Color\n   * @param alpha Define the a component of the vec4\n   */\n\n\n  UniformBuffer.prototype.addColor4 = function (name, color, alpha) {\n    var temp = [color.r, color.g, color.b, alpha];\n    this.addUniform(name, temp);\n  };\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param vector Define the vec3 components from a Vector\n   */\n\n\n  UniformBuffer.prototype.addVector3 = function (name, vector) {\n    var temp = [vector.x, vector.y, vector.z];\n    this.addUniform(name, temp);\n  };\n  /**\n   * Adds a Matrix 3x3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n\n\n  UniformBuffer.prototype.addMatrix3x3 = function (name) {\n    this.addUniform(name, 12);\n  };\n  /**\n   * Adds a Matrix 2x2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n\n\n  UniformBuffer.prototype.addMatrix2x2 = function (name) {\n    this.addUniform(name, 8);\n  };\n  /**\n   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\n   */\n\n\n  UniformBuffer.prototype.create = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._buffer) {\n      return; // nothing to do\n    } // See spec, alignment must be filled as a vec4\n\n\n    this._fillAlignment(4);\n\n    this._bufferData = new Float32Array(this._data);\n\n    this._rebuild();\n\n    this._needSync = true;\n  };\n  /** @hidden */\n\n\n  UniformBuffer.prototype._rebuild = function () {\n    if (this._noUBO || !this._bufferData) {\n      return;\n    }\n\n    if (this._dynamic) {\n      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\n    } else {\n      this._buffer = this._engine.createUniformBuffer(this._bufferData);\n    }\n\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\n\n      this._bufferIndex = this._buffers.length - 1;\n      this._createBufferOnWrite = false;\n    }\n  };\n\n  Object.defineProperty(UniformBuffer.prototype, \"_numBuffers\", {\n    /** @hidden */\n    get: function get() {\n      return this._buffers.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UniformBuffer.prototype, \"_indexBuffer\", {\n    /** @hidden */\n    get: function get() {\n      return this._bufferIndex;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UniformBuffer.prototype, \"name\", {\n    /** Gets the name of this buffer */\n    get: function get() {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  UniformBuffer.prototype._buffersEqual = function (buf1, buf2) {\n    for (var i = 0; i < buf1.length; ++i) {\n      if (buf1[i] !== buf2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  UniformBuffer.prototype._copyBuffer = function (src, dst) {\n    for (var i = 0; i < src.length; ++i) {\n      dst[i] = src[i];\n    }\n  };\n  /**\n   * Updates the WebGL Uniform Buffer on the GPU.\n   * If the `dynamic` flag is set to true, no cache comparison is done.\n   * Otherwise, the buffer will be updated only if the cache differs.\n   */\n\n\n  UniformBuffer.prototype.update = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    this.bindUniformBuffer();\n\n    if (!this._buffer) {\n      this.create();\n      return;\n    }\n\n    if (!this._dynamic && !this._needSync) {\n      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n      return;\n    }\n\n    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\n      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {\n        this._needSync = false;\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n        return;\n      } else {\n        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);\n      }\n    }\n\n    this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n\n    if (this._engine._features._collectUbosUpdatedInFrame) {\n      if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\n        UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\n      }\n\n      UniformBuffer._UpdatedUbosInFrame[this._name]++;\n    }\n\n    this._needSync = false;\n    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n  };\n\n  UniformBuffer.prototype._createNewBuffer = function () {\n    if (this._bufferIndex + 1 < this._buffers.length) {\n      this._bufferIndex++;\n      this._buffer = this._buffers[this._bufferIndex][0];\n      this._createBufferOnWrite = false;\n      this._needSync = true;\n    } else {\n      this._rebuild();\n    }\n  };\n\n  UniformBuffer.prototype._checkNewFrame = function () {\n    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\n      this._currentFrameId = this._engine.frameId;\n      this._createBufferOnWrite = false;\n\n      if (this._buffers && this._buffers.length > 0) {\n        this._needSync = this._bufferIndex !== 0;\n        this._bufferIndex = 0;\n        this._buffer = this._buffers[this._bufferIndex][0];\n      } else {\n        this._bufferIndex = -1;\n      }\n    }\n  };\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n\n\n  UniformBuffer.prototype.updateUniform = function (uniformName, data, size) {\n    this._checkNewFrame();\n\n    var location = this._uniformLocations[uniformName];\n\n    if (location === undefined) {\n      if (this._buffer) {\n        // Cannot add an uniform if the buffer is already created\n        Logger.Error(\"Cannot add an uniform after UBO has been created.\");\n        return;\n      }\n\n      this.addUniform(uniformName, size);\n      location = this._uniformLocations[uniformName];\n    }\n\n    if (!this._buffer) {\n      this.create();\n    }\n\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      var changed = false;\n\n      for (var i = 0; i < size; i++) {\n        // We are checking the matrix cache before calling updateUniform so we do not need to check it here\n        // Hence the test for size === 16 to simply commit the matrix values\n        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location + i] !== Tools.FloatRound(data[i])) {\n          changed = true;\n\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n\n          this._bufferData[location + i] = data[i];\n        }\n      }\n\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (var i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  };\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n\n\n  UniformBuffer.prototype.updateUniformArray = function (uniformName, data, size) {\n    this._checkNewFrame();\n\n    var location = this._uniformLocations[uniformName];\n\n    if (location === undefined) {\n      Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform.\");\n      return;\n    }\n\n    if (!this._buffer) {\n      this.create();\n    }\n\n    var arraySizes = this._uniformArraySizes[uniformName];\n\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      var changed = false;\n      var countToFour = 0;\n      var baseStride = 0;\n\n      for (var i = 0; i < size; i++) {\n        if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\n          changed = true;\n\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n\n          this._bufferData[location + baseStride * 4 + countToFour] = data[i];\n        }\n\n        countToFour++;\n\n        if (countToFour === arraySizes.strideSize) {\n          for (; countToFour < 4; countToFour++) {\n            this._bufferData[location + baseStride * 4 + countToFour] = 0;\n          }\n\n          countToFour = 0;\n          baseStride++;\n        }\n      }\n\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (var i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  };\n\n  UniformBuffer.prototype._cacheMatrix = function (name, matrix) {\n    this._checkNewFrame();\n\n    var cache = this._valueCache[name];\n    var flag = matrix.updateFlag;\n\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n\n    this._valueCache[name] = flag;\n    return true;\n  }; // Update methods\n\n\n  UniformBuffer.prototype._updateMatrix3x3ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 3; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._TempBuffer, 12);\n  };\n\n  UniformBuffer.prototype._updateMatrix3x3ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix3x3(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix2x2(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 2; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._TempBuffer, 8);\n  };\n\n  UniformBuffer.prototype._updateFloatForEffect = function (name, x) {\n    this._currentEffect.setFloat(name, x);\n  };\n\n  UniformBuffer.prototype._updateFloatForUniform = function (name, x) {\n    UniformBuffer._TempBuffer[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForEffect = function (name, x, y, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat2(name + suffix, x, y);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForUniform = function (name, x, y) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForEffect = function (name, x, y, z, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat3(name + suffix, x, y, z);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForUniform = function (name, x, y, z) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForEffect = function (name, x, y, z, w, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForUniform = function (name, x, y, z, w) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    UniformBuffer._TempBuffer[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateFloatArrayForEffect = function (name, array) {\n    this._currentEffect.setFloatArray(name, array);\n  };\n\n  UniformBuffer.prototype._updateFloatArrayForUniform = function (name, array) {\n    this.updateUniformArray(name, array, array.length);\n  };\n\n  UniformBuffer.prototype._updateArrayForEffect = function (name, array) {\n    this._currentEffect.setArray(name, array);\n  };\n\n  UniformBuffer.prototype._updateArrayForUniform = function (name, array) {\n    this.updateUniformArray(name, array, array.length);\n  };\n\n  UniformBuffer.prototype._updateIntArrayForEffect = function (name, array) {\n    this._currentEffect.setIntArray(name, array);\n  };\n\n  UniformBuffer.prototype._updateIntArrayForUniform = function (name, array) {\n    UniformBuffer._TempBufferInt32View.set(array);\n\n    this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\n  };\n\n  UniformBuffer.prototype._updateMatrixForEffect = function (name, mat) {\n    this._currentEffect.setMatrix(name, mat);\n  };\n\n  UniformBuffer.prototype._updateMatrixForUniform = function (name, mat) {\n    if (this._cacheMatrix(name, mat)) {\n      this.updateUniform(name, mat.toArray(), 16);\n    }\n  };\n\n  UniformBuffer.prototype._updateMatricesForEffect = function (name, mat) {\n    this._currentEffect.setMatrices(name, mat);\n  };\n\n  UniformBuffer.prototype._updateMatricesForUniform = function (name, mat) {\n    this.updateUniform(name, mat, mat.length);\n  };\n\n  UniformBuffer.prototype._updateVector3ForEffect = function (name, vector) {\n    this._currentEffect.setVector3(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector3ForUniform = function (name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateVector4ForEffect = function (name, vector) {\n    this._currentEffect.setVector4(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector4ForUniform = function (name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    UniformBuffer._TempBuffer[3] = vector.w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateColor3ForEffect = function (name, color, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor3(name + suffix, color);\n  };\n\n  UniformBuffer.prototype._updateColor3ForUniform = function (name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateColor4ForEffect = function (name, color, alpha, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor4(name + suffix, color, alpha);\n  };\n\n  UniformBuffer.prototype._updateDirectColor4ForEffect = function (name, color, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setDirectColor4(name + suffix, color);\n  };\n\n  UniformBuffer.prototype._updateColor4ForUniform = function (name, color, alpha) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = alpha;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateDirectColor4ForUniform = function (name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = color.a;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateIntForEffect = function (name, x, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setInt(name + suffix, x);\n  };\n\n  UniformBuffer.prototype._updateIntForUniform = function (name, x) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  };\n\n  UniformBuffer.prototype._updateInt2ForEffect = function (name, x, y, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setInt2(name + suffix, x, y);\n  };\n\n  UniformBuffer.prototype._updateInt2ForUniform = function (name, x, y) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  };\n\n  UniformBuffer.prototype._updateInt3ForEffect = function (name, x, y, z, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setInt3(name + suffix, x, y, z);\n  };\n\n  UniformBuffer.prototype._updateInt3ForUniform = function (name, x, y, z) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateInt4ForEffect = function (name, x, y, z, w, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setInt4(name + suffix, x, y, z, w);\n  };\n\n  UniformBuffer.prototype._updateInt4ForUniform = function (name, x, y, z, w) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    UniformBuffer._TempBufferInt32View[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  };\n  /**\n   * Sets a sampler uniform on the effect.\n   * @param name Define the name of the sampler.\n   * @param texture Define the texture to set in the sampler\n   */\n\n\n  UniformBuffer.prototype.setTexture = function (name, texture) {\n    this._currentEffect.setTexture(name, texture);\n  };\n  /**\n   * Directly updates the value of the uniform in the cache AND on the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   */\n\n\n  UniformBuffer.prototype.updateUniformDirectly = function (uniformName, data) {\n    this.updateUniform(uniformName, data, data.length);\n    this.update();\n  };\n  /**\n   * Associates an effect to this uniform buffer\n   * @param effect Define the effect to associate the buffer to\n   * @param name Name of the uniform block in the shader.\n   */\n\n\n  UniformBuffer.prototype.bindToEffect = function (effect, name) {\n    this._currentEffect = effect;\n    this._currentEffectName = name;\n  };\n  /**\n   * Binds the current (GPU) buffer to the effect\n   */\n\n\n  UniformBuffer.prototype.bindUniformBuffer = function () {\n    if (!this._noUBO && this._buffer && this._currentEffect) {\n      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\n    }\n  };\n  /**\n   * Dissociates the current effect from this uniform buffer\n   */\n\n\n  UniformBuffer.prototype.unbindEffect = function () {\n    this._currentEffect = undefined;\n    this._currentEffectName = undefined;\n  };\n  /**\n   * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\n   * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\n   * @param dataBuffer buffer to look for\n   * @returns true if the buffer has been found and the class internal state points to it, else false\n   */\n\n\n  UniformBuffer.prototype.setDataBuffer = function (dataBuffer) {\n    if (!this._buffers) {\n      return this._buffer === dataBuffer;\n    }\n\n    for (var b = 0; b < this._buffers.length; ++b) {\n      var buffer = this._buffers[b];\n\n      if (buffer[0] === dataBuffer) {\n        this._bufferIndex = b;\n        this._buffer = dataBuffer;\n        this._createBufferOnWrite = false;\n        this._currentEffect = undefined;\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Disposes the uniform buffer.\n   */\n\n\n  UniformBuffer.prototype.dispose = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    var uniformBuffers = this._engine._uniformBuffers;\n    var index = uniformBuffers.indexOf(this);\n\n    if (index !== -1) {\n      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\n      uniformBuffers.pop();\n    }\n\n    if (this._engine._features.trackUbosInFrame && this._buffers) {\n      for (var i = 0; i < this._buffers.length; ++i) {\n        var buffer = this._buffers[i][0];\n\n        this._engine._releaseBuffer(buffer);\n      }\n    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n    }\n  };\n  /** @hidden */\n\n\n  UniformBuffer._UpdatedUbosInFrame = {}; // Pool for avoiding memory leaks\n\n  UniformBuffer._MAX_UNIFORM_SIZE = 256;\n  UniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\n  UniformBuffer._TempBufferInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\n  return UniformBuffer;\n}();\n\nexport { UniformBuffer };","map":{"version":3,"mappings":"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","names":["Logger","Tools","engine","data","dynamic","name","forceNoUniformBuffer","_engine","_noUBO","supportsUniformBuffers","_dynamic","_name","_data","_uniformLocations","_uniformSizes","_uniformArraySizes","_uniformLocationPointer","_needSync","_features","trackUbosInFrame","_buffers","_bufferIndex","_createBufferOnWrite","_currentFrameId","updateMatrix3x3","_updateMatrix3x3ForEffect","updateMatrix2x2","_updateMatrix2x2ForEffect","updateFloat","_updateFloatForEffect","updateFloat2","_updateFloat2ForEffect","updateFloat3","_updateFloat3ForEffect","updateFloat4","_updateFloat4ForEffect","updateFloatArray","_updateFloatArrayForEffect","updateArray","_updateArrayForEffect","updateIntArray","_updateIntArrayForEffect","updateMatrix","_updateMatrixForEffect","updateMatrices","_updateMatricesForEffect","updateVector3","_updateVector3ForEffect","updateVector4","_updateVector4ForEffect","updateColor3","_updateColor3ForEffect","updateColor4","_updateColor4ForEffect","updateDirectColor4","_updateDirectColor4ForEffect","updateInt","_updateIntForEffect","updateInt2","_updateInt2ForEffect","updateInt3","_updateInt3ForEffect","updateInt4","_updateInt4ForEffect","_uniformBuffers","push","_updateMatrix3x3ForUniform","_updateMatrix2x2ForUniform","_updateFloatForUniform","_updateFloat2ForUniform","_updateFloat3ForUniform","_updateFloat4ForUniform","_updateFloatArrayForUniform","_updateArrayForUniform","_updateIntArrayForUniform","_updateMatrixForUniform","_updateMatricesForUniform","_updateVector3ForUniform","_updateVector4ForUniform","_updateColor3ForUniform","_updateColor4ForUniform","_updateDirectColor4ForUniform","_updateIntForUniform","_updateInt2ForUniform","_updateInt3ForUniform","_updateInt4ForUniform","Object","UniformBuffer","undefined","_bufferData","_buffer","size","alignment","oldPointer","diff","i","arraySize","Array","_fillAlignment","strideSize","perElementPadding","totalPadding","length","mat","addUniform","prototype","slice","call","toArray","x","y","temp","z","color","r","g","b","alpha","vector","Float32Array","_rebuild","createDynamicUniformBuffer","createUniformBuffer","checkUbosContentBeforeUpload","buf1","buf2","src","dst","bindUniformBuffer","create","_buffersEqual","_copyBuffer","updateUniformBuffer","_collectUbosUpdatedInFrame","_UpdatedUbosInFrame","frameId","uniformName","_checkNewFrame","location","Error","changed","uniformBufferHardCheckMatrix","FloatRound","_createNewBuffer","arraySizes","countToFour","baseStride","matrix","cache","_valueCache","flag","updateFlag","_TempBuffer","updateUniform","_currentEffect","setMatrix3x3","setMatrix2x2","setFloat","suffix","setFloat2","setFloat3","w","setFloat4","array","setFloatArray","updateUniformArray","setArray","setIntArray","_TempBufferInt32View","set","setMatrix","_cacheMatrix","setMatrices","setVector3","setVector4","setColor3","setColor4","setDirectColor4","a","setInt","setInt2","setInt3","setInt4","texture","setTexture","update","effect","_currentEffectName","dataBuffer","buffer","uniformBuffers","index","indexOf","pop","_releaseBuffer","_MAX_UNIFORM_SIZE","Uint32Array"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/uniformBuffer.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport \"../Engines/Extensions/engine.uniformBuffer\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    /** @hidden */\r\n    public static _UpdatedUbosInFrame: { [name: string]: number } = {};\r\n\r\n    private _engine: ThinEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _buffers: Array<[DataBuffer, Float32Array | undefined]>;\r\n    private _bufferIndex: number;\r\n    private _createBufferOnWrite: boolean;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic?: boolean;\r\n    private _uniformLocations: { [key: string]: number };\r\n    private _uniformSizes: { [key: string]: number };\r\n    private _uniformArraySizes: { [key: string]: { strideSize: number; arraySize: number } };\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n    private _currentEffectName: string;\r\n    private _name: string;\r\n    private _currentFrameId: number;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n    private static _TempBufferInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloatArray: (name: string, array: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateArray: (name: string, array: number[]) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateDirectColor4: (name: string, color: IColor4Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     * @param name to assign to the buffer (debugging purpose)\r\n     * @param forceNoUniformBuffer define that this object must not rely on UBO objects\r\n     */\r\n    constructor(engine: ThinEngine, data?: number[], dynamic?: boolean, name?: string, forceNoUniformBuffer = false) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\r\n        this._dynamic = dynamic;\r\n        this._name = name ?? \"no-name\";\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformArraySizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._bufferIndex = -1;\r\n            this._createBufferOnWrite = false;\r\n            this._currentFrameId = 0;\r\n        }\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateFloatArray = this._updateFloatArrayForEffect;\r\n            this.updateArray = this._updateArrayForEffect;\r\n            this.updateIntArray = this._updateIntArrayForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateMatrices = this._updateMatricesForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForEffect;\r\n            this.updateInt = this._updateIntForEffect;\r\n            this.updateInt2 = this._updateInt2ForEffect;\r\n            this.updateInt3 = this._updateInt3ForEffect;\r\n            this.updateInt4 = this._updateInt4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateFloatArray = this._updateFloatArrayForUniform;\r\n            this.updateArray = this._updateArrayForUniform;\r\n            this.updateIntArray = this._updateIntArrayForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateMatrices = this._updateMatricesForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForUniform;\r\n            this.updateInt = this._updateIntForUniform;\r\n            this.updateInt2 = this._updateInt2ForUniform;\r\n            this.updateInt3 = this._updateInt3ForUniform;\r\n            this.updateInt4 = this._updateInt4ForUniform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     * @param size\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        let alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if (this._uniformLocationPointer % alignment !== 0) {\r\n            const oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            const diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (let i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\r\n     * meaning size=1,2,3,4 or 16. It does not handle struct types.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     * @param arraySize The number of elements in the array, 0 if not an array.\r\n     */\r\n    public addUniform(name: string, size: number | number[], arraySize = 0) {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        let data;\r\n\r\n        // std140 FTW...\r\n        if (arraySize > 0) {\r\n            if (size instanceof Array) {\r\n                throw \"addUniform should not be use with Array in UBO: \" + name;\r\n            }\r\n\r\n            this._fillAlignment(4);\r\n\r\n            this._uniformArraySizes[name] = { strideSize: size, arraySize };\r\n            if (size == 16) {\r\n                size = size * arraySize;\r\n            } else {\r\n                const perElementPadding = 4 - size;\r\n                const totalPadding = perElementPadding * arraySize;\r\n                size = size * arraySize + totalPadding;\r\n            }\r\n\r\n            data = [];\r\n            // Fill with zeros\r\n            for (let i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        } else {\r\n            if (size instanceof Array) {\r\n                data = size;\r\n                size = data.length;\r\n            } else {\r\n                size = <number>size;\r\n                data = [];\r\n\r\n                // Fill with zeros\r\n                for (let i = 0; i < size; i++) {\r\n                    data.push(0);\r\n                }\r\n            }\r\n            this._fillAlignment(<number>size);\r\n        }\r\n\r\n        this._uniformSizes[name] = <number>size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += <number>size;\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: IMatrixLike) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        const temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        const temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: IColor3Like) {\r\n        const temp = [color.r, color.g, color.b];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: IColor3Like, alpha: number) {\r\n        const temp = [color.r, color.g, color.b, alpha];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: IVector3Like) {\r\n        const temp = [vector.x, vector.y, vector.z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData);\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\r\n            this._bufferIndex = this._buffers.length - 1;\r\n            this._createBufferOnWrite = false;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _numBuffers(): number {\r\n        return this._buffers.length;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _indexBuffer(): number {\r\n        return this._bufferIndex;\r\n    }\r\n\r\n    /** Gets the name of this buffer */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    private _buffersEqual(buf1: Float32Array, buf2: Float32Array): boolean {\r\n        for (let i = 0; i < buf1.length; ++i) {\r\n            if (buf1[i] !== buf2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _copyBuffer(src: Float32Array, dst: Float32Array): void {\r\n        for (let i = 0; i < src.length; ++i) {\r\n            dst[i] = src[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        this.bindUniformBuffer();\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n            return;\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\r\n            if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]!)) {\r\n                this._needSync = false;\r\n                this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n                return;\r\n            } else {\r\n                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]!);\r\n            }\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        if (this._engine._features._collectUbosUpdatedInFrame) {\r\n            if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\r\n                UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame[this._name]++;\r\n        }\r\n\r\n        this._needSync = false;\r\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n    }\r\n\r\n    private _createNewBuffer() {\r\n        if (this._bufferIndex + 1 < this._buffers.length) {\r\n            this._bufferIndex++;\r\n            this._buffer = this._buffers[this._bufferIndex][0];\r\n            this._createBufferOnWrite = false;\r\n            this._needSync = true;\r\n        } else {\r\n            this._rebuild();\r\n        }\r\n    }\r\n\r\n    private _checkNewFrame(): void {\r\n        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\r\n            this._currentFrameId = this._engine.frameId;\r\n            this._createBufferOnWrite = false;\r\n            if (this._buffers && this._buffers.length > 0) {\r\n                this._needSync = this._bufferIndex !== 0;\r\n                this._bufferIndex = 0;\r\n                this._buffer = this._buffers[this._bufferIndex][0];\r\n            } else {\r\n                this._bufferIndex = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        let location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created.\");\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n\r\n            for (let i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if ((size === 16 && !this._engine._features.uniformBufferHardCheckMatrix) || this._bufferData[location + i] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniformArray(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        const location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform.\");\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        const arraySizes = this._uniformArraySizes[uniformName];\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n            let countToFour = 0;\r\n            let baseStride = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + baseStride * 4 + countToFour] = data[i];\r\n                }\r\n                countToFour++;\r\n                if (countToFour === arraySizes.strideSize) {\r\n                    for (; countToFour < 4; countToFour++) {\r\n                        this._bufferData[location + baseStride * 4 + countToFour] = 0;\r\n                    }\r\n                    countToFour = 0;\r\n                    baseStride++;\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: number } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        this._checkNewFrame();\r\n\r\n        const cache = this._valueCache[name];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 3; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 2; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number) {\r\n        this._currentEffect.setFloat(name, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        UniformBuffer._TempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateFloatArrayForEffect(name: string, array: Float32Array) {\r\n        this._currentEffect.setFloatArray(name, array);\r\n    }\r\n\r\n    private _updateFloatArrayForUniform(name: string, array: Float32Array) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateArrayForEffect(name: string, array: number[]) {\r\n        this._currentEffect.setArray(name, array);\r\n    }\r\n\r\n    private _updateArrayForUniform(name: string, array: number[]) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateIntArrayForEffect(name: string, array: Int32Array) {\r\n        this._currentEffect.setIntArray(name, array);\r\n    }\r\n\r\n    private _updateIntArrayForUniform(name: string, array: Int32Array) {\r\n        UniformBuffer._TempBufferInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: IMatrixLike) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: IMatrixLike) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.toArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateMatricesForEffect(name: string, mat: Float32Array) {\r\n        this._currentEffect.setMatrices(name, mat);\r\n    }\r\n\r\n    private _updateMatricesForUniform(name: string, mat: Float32Array) {\r\n        this.updateUniform(name, mat, mat.length);\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: IVector3Like) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: IVector3Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: IVector4Like) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: IVector4Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        UniformBuffer._TempBuffer[3] = vector.w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: IColor3Like, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: IColor3Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: IColor3Like, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateDirectColor4ForEffect(name: string, color: IColor4Like, suffix = \"\") {\r\n        this._currentEffect.setDirectColor4(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: IColor3Like, alpha: number) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateDirectColor4ForUniform(name: string, color: IColor4Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = color.a;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        UniformBuffer._TempBufferInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<ThinTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Associates an effect to this uniform buffer\r\n     * @param effect Define the effect to associate the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n        this._currentEffectName = name;\r\n    }\r\n\r\n    /**\r\n     * Binds the current (GPU) buffer to the effect\r\n     */\r\n    public bindUniformBuffer(): void {\r\n        if (!this._noUBO && this._buffer && this._currentEffect) {\r\n            this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dissociates the current effect from this uniform buffer\r\n     */\r\n    public unbindEffect(): void {\r\n        this._currentEffect = undefined as any;\r\n        this._currentEffectName = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\r\n     * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\r\n     * @param dataBuffer buffer to look for\r\n     * @returns true if the buffer has been found and the class internal state points to it, else false\r\n     */\r\n    public setDataBuffer(dataBuffer: DataBuffer): boolean {\r\n        if (!this._buffers) {\r\n            return this._buffer === dataBuffer;\r\n        }\r\n\r\n        for (let b = 0; b < this._buffers.length; ++b) {\r\n            const buffer = this._buffers[b];\r\n            if (buffer[0] === dataBuffer) {\r\n                this._bufferIndex = b;\r\n                this._buffer = dataBuffer;\r\n                this._createBufferOnWrite = false;\r\n                this._currentEffect = undefined as any;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        const index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame && this._buffers) {\r\n            for (let i = 0; i < this._buffers.length; ++i) {\r\n                const buffer = this._buffers[i][0];\r\n                this._engine._releaseBuffer(buffer!);\r\n            }\r\n        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}