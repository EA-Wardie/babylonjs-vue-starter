{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Scene } from \"../scene.js\";\nimport { PhysicsEngine } from \"./physicsEngine.js\";\nimport { PhysicsJoint } from \"./physicsJoint.js\";\n/**\n * Gets the current physics engine\n * @returns a IPhysicsEngine or null if none attached\n */\n\nScene.prototype.getPhysicsEngine = function () {\n  return this._physicsEngine;\n};\n/**\n * Enables physics to the current scene\n * @param gravity defines the scene's gravity for the physics engine\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\n * @return a boolean indicating if the physics engine was initialized\n */\n\n\nScene.prototype.enablePhysics = function (gravity, plugin) {\n  if (gravity === void 0) {\n    gravity = null;\n  }\n\n  if (this._physicsEngine) {\n    return true;\n  } // Register the component to the scene\n\n\n  var component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);\n\n  if (!component) {\n    component = new PhysicsEngineSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  try {\n    this._physicsEngine = new PhysicsEngine(gravity, plugin);\n    this._physicsTimeAccumulator = 0;\n    return true;\n  } catch (e) {\n    Logger.Error(e.message);\n    return false;\n  }\n};\n/**\n * Disables and disposes the physics engine associated with the scene\n */\n\n\nScene.prototype.disablePhysicsEngine = function () {\n  if (!this._physicsEngine) {\n    return;\n  }\n\n  this._physicsEngine.dispose();\n\n  this._physicsEngine = null;\n};\n/**\n * Gets a boolean indicating if there is an active physics engine\n * @returns a boolean indicating if there is an active physics engine\n */\n\n\nScene.prototype.isPhysicsEnabled = function () {\n  return this._physicsEngine !== undefined;\n};\n/**\n * Deletes a physics compound impostor\n * @param compound defines the compound to delete\n */\n\n\nScene.prototype.deleteCompoundImpostor = function (compound) {\n  var mesh = compound.parts[0].mesh;\n\n  if (mesh.physicsImpostor) {\n    mesh.physicsImpostor.dispose();\n    mesh.physicsImpostor = null;\n  }\n};\n/**\n * @param step\n * @hidden\n */\n\n\nScene.prototype._advancePhysicsEngineStep = function (step) {\n  if (this._physicsEngine) {\n    var subTime = this._physicsEngine.getSubTimeStep();\n\n    if (subTime > 0) {\n      this._physicsTimeAccumulator += step;\n\n      while (this._physicsTimeAccumulator > subTime) {\n        this.onBeforePhysicsObservable.notifyObservers(this);\n\n        this._physicsEngine._step(subTime / 1000);\n\n        this.onAfterPhysicsObservable.notifyObservers(this);\n        this._physicsTimeAccumulator -= subTime;\n      }\n    } else {\n      this.onBeforePhysicsObservable.notifyObservers(this);\n\n      this._physicsEngine._step(step / 1000);\n\n      this.onAfterPhysicsObservable.notifyObservers(this);\n    }\n  }\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\n  get: function get() {\n    return this._physicsImpostor;\n  },\n  set: function set(value) {\n    var _this = this;\n\n    if (this._physicsImpostor === value) {\n      return;\n    }\n\n    if (this._disposePhysicsObserver) {\n      this.onDisposeObservable.remove(this._disposePhysicsObserver);\n    }\n\n    this._physicsImpostor = value;\n\n    if (value) {\n      this._disposePhysicsObserver = this.onDisposeObservable.add(function () {\n        // Physics\n        if (_this.physicsImpostor) {\n          _this.physicsImpostor.dispose();\n\n          _this.physicsImpostor = null;\n        }\n      });\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Gets the current physics impostor\n * @see https://doc.babylonjs.com/features/physics_engine\n * @returns a physics impostor or null\n */\n\nAbstractMesh.prototype.getPhysicsImpostor = function () {\n  return this.physicsImpostor;\n};\n/**\n * Apply a physic impulse to the mesh\n * @param force defines the force to apply\n * @param contactPoint defines where to apply the force\n * @returns the current mesh\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\n */\n\n\nAbstractMesh.prototype.applyImpulse = function (force, contactPoint) {\n  if (!this.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.applyImpulse(force, contactPoint);\n  return this;\n};\n/**\n * Creates a physic joint between two meshes\n * @param otherMesh defines the other mesh to use\n * @param pivot1 defines the pivot to use on this mesh\n * @param pivot2 defines the pivot to use on the other mesh\n * @param options defines additional options (can be plugin dependent)\n * @returns the current mesh\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\n */\n\n\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {\n  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\n    mainPivot: pivot1,\n    connectedPivot: pivot2,\n    nativeParams: options\n  });\n  return this;\n};\n/**\n * Defines the physics engine scene component responsible to manage a physics engine\n */\n\n\nvar PhysicsEngineSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function PhysicsEngineSceneComponent(scene) {\n    var _this = this;\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n\n\n    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;\n    this.scene = scene;\n    this.scene.onBeforePhysicsObservable = new Observable();\n    this.scene.onAfterPhysicsObservable = new Observable(); // Replace the function used to get the deterministic frame time\n\n    this.scene.getDeterministicFrameTime = function () {\n      if (_this.scene._physicsEngine) {\n        return _this.scene._physicsEngine.getTimeStep() * 1000;\n      }\n\n      return 1000.0 / 60.0;\n    };\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.register = function () {};\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\n   * Disposes the component and the associated resources\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforePhysicsObservable.clear();\n    this.scene.onAfterPhysicsObservable.clear();\n\n    if (this.scene._physicsEngine) {\n      this.scene.disablePhysicsEngine();\n    }\n  };\n\n  return PhysicsEngineSceneComponent;\n}();\n\nexport { PhysicsEngineSceneComponent };","map":{"version":3,"mappings":"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","names":["Logger","Observable","AbstractMesh","SceneComponentConstants","Scene","PhysicsEngine","PhysicsJoint","prototype","getPhysicsEngine","_physicsEngine","enablePhysics","gravity","plugin","component","_getComponent","NAME_PHYSICSENGINE","PhysicsEngineSceneComponent","_addComponent","_physicsTimeAccumulator","e","Error","message","disablePhysicsEngine","dispose","isPhysicsEnabled","undefined","deleteCompoundImpostor","compound","mesh","parts","physicsImpostor","_advancePhysicsEngineStep","step","subTime","getSubTimeStep","onBeforePhysicsObservable","notifyObservers","_step","onAfterPhysicsObservable","Object","defineProperty","get","_physicsImpostor","set","value","_disposePhysicsObserver","onDisposeObservable","remove","add","_this","enumerable","configurable","getPhysicsImpostor","applyImpulse","force","contactPoint","setPhysicsLinkWith","otherMesh","pivot1","pivot2","options","createJoint","HingeJoint","mainPivot","connectedPivot","nativeParams","scene","getDeterministicFrameTime","getTimeStep","clear"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/physicsEngineComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\n\r\nimport type { IPhysicsEngine, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @hidden */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @return a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @return a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePlugin): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        this._physicsEngine = new PhysicsEngine(gravity, plugin);\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @param step\r\n * @hidden\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @hidden */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function (this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function (): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options,\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}