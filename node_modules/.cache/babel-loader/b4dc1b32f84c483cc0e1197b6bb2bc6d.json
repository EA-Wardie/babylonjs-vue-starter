{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Node } from \"../node.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * Class used to store bone information\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\n */\n\nvar Bone =\n/** @class */\nfunction (_super) {\n  __extends(Bone, _super);\n  /**\n   * Create a new bone\n   * @param name defines the bone name\n   * @param skeleton defines the parent skeleton\n   * @param parentBone defines the parent (can be null if the bone is the root)\n   * @param localMatrix defines the local matrix\n   * @param restPose defines the rest pose matrix\n   * @param baseMatrix defines the base matrix\n   * @param index defines index of the bone in the hierarchy\n   */\n\n\n  function Bone(\n  /**\n   * defines the bone name\n   */\n  name, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {\n    if (parentBone === void 0) {\n      parentBone = null;\n    }\n\n    if (localMatrix === void 0) {\n      localMatrix = null;\n    }\n\n    if (restPose === void 0) {\n      restPose = null;\n    }\n\n    if (baseMatrix === void 0) {\n      baseMatrix = null;\n    }\n\n    if (index === void 0) {\n      index = null;\n    }\n\n    var _this = _super.call(this, name, skeleton.getScene()) || this;\n\n    _this.name = name;\n    /**\n     * Gets the list of child bones\n     */\n\n    _this.children = new Array();\n    /** Gets the animations associated with this bone */\n\n    _this.animations = new Array();\n    /**\n     * @hidden Internal only\n     * Set this value to map this bone to a different index in the transform matrices\n     * Set this value to -1 to exclude the bone from the transform matrices\n     */\n\n    _this._index = null;\n    _this._absoluteTransform = new Matrix();\n    _this._invertedAbsoluteTransform = new Matrix();\n    _this._scalingDeterminant = 1;\n    _this._worldTransform = new Matrix();\n    _this._needToDecompose = true;\n    _this._needToCompose = false;\n    /** @hidden */\n\n    _this._linkedTransformNode = null;\n    /** @hidden */\n\n    _this._waitingTransformNodeId = null;\n    _this._skeleton = skeleton;\n    _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\n    _this._restPose = restPose ? restPose : _this._localMatrix.clone();\n    _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();\n    _this._index = index;\n    skeleton.bones.push(_this);\n\n    _this.setParent(parentBone, false);\n\n    if (baseMatrix || localMatrix) {\n      _this._updateDifferenceMatrix();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Bone.prototype, \"_matrix\", {\n    /** @hidden */\n    get: function get() {\n      this._compose();\n\n      return this._localMatrix;\n    },\n\n    /** @hidden */\n    set: function set(value) {\n      this._needToCompose = false; // in case there was a pending compose\n      // skip if the matrices are the same\n\n      if (value.updateFlag === this._localMatrix.updateFlag) {\n        return;\n      }\n\n      this._localMatrix.copyFrom(value);\n\n      this._markAsDirtyAndDecompose();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets the current object class name.\n   * @return the class name\n   */\n\n  Bone.prototype.getClassName = function () {\n    return \"Bone\";\n  }; // Members\n\n  /**\n   * Gets the parent skeleton\n   * @returns a skeleton\n   */\n\n\n  Bone.prototype.getSkeleton = function () {\n    return this._skeleton;\n  };\n\n  Object.defineProperty(Bone.prototype, \"parent\", {\n    get: function get() {\n      return this._parentNode;\n    },\n    set: function set(newParent) {\n      this.setParent(newParent);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets parent bone\n   * @returns a bone or null if the bone is the root of the bone hierarchy\n   */\n\n  Bone.prototype.getParent = function () {\n    return this.parent;\n  };\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n\n\n  Bone.prototype.getChildren = function () {\n    return this.children;\n  };\n  /**\n   * Gets the node index in matrix array generated for rendering\n   * @returns the node index\n   */\n\n\n  Bone.prototype.getIndex = function () {\n    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\n  };\n  /**\n   * Sets the parent bone\n   * @param parent defines the parent (can be null if the bone is the root)\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\n   */\n\n\n  Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (this.parent === parent) {\n      return;\n    }\n\n    if (this.parent) {\n      var index = this.parent.children.indexOf(this);\n\n      if (index !== -1) {\n        this.parent.children.splice(index, 1);\n      }\n    }\n\n    this._parentNode = parent;\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    this.markAsDirty();\n  };\n  /**\n   * Gets the local matrix\n   * @returns a matrix\n   */\n\n\n  Bone.prototype.getLocalMatrix = function () {\n    this._compose();\n\n    return this._localMatrix;\n  };\n  /**\n   * Gets the base matrix (initial matrix which remains unchanged)\n   * @returns the base matrix (as known as bind pose matrix)\n   */\n\n\n  Bone.prototype.getBaseMatrix = function () {\n    return this._baseMatrix;\n  };\n  /**\n   * Gets the rest pose matrix\n   * @returns a matrix\n   */\n\n\n  Bone.prototype.getRestPose = function () {\n    return this._restPose;\n  };\n  /**\n   * Sets the rest pose matrix\n   * @param matrix the local-space rest pose to set for this bone\n   */\n\n\n  Bone.prototype.setRestPose = function (matrix) {\n    this._restPose.copyFrom(matrix);\n  };\n  /**\n   * Gets the bind pose matrix\n   * @returns the bind pose matrix\n   * @deprecated Please use getBaseMatrix instead\n   */\n\n\n  Bone.prototype.getBindPose = function () {\n    return this._baseMatrix;\n  };\n  /**\n   * Sets the bind pose matrix\n   * @param matrix the local-space bind pose to set for this bone\n   * @deprecated Please use updateMatrix instead\n   */\n\n\n  Bone.prototype.setBindPose = function (matrix) {\n    this.updateMatrix(matrix);\n  };\n  /**\n   * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\n   */\n\n\n  Bone.prototype.getWorldMatrix = function () {\n    return this._worldTransform;\n  };\n  /**\n   * Sets the local matrix to rest pose matrix\n   */\n\n\n  Bone.prototype.returnToRest = function () {\n    var _a;\n\n    if (this._linkedTransformNode) {\n      var localScaling = TmpVectors.Vector3[0];\n      var localRotation = TmpVectors.Quaternion[0];\n      var localPosition = TmpVectors.Vector3[1];\n      this.getRestPose().decompose(localScaling, localRotation, localPosition);\n\n      this._linkedTransformNode.position.copyFrom(localPosition);\n\n      this._linkedTransformNode.rotationQuaternion = (_a = this._linkedTransformNode.rotationQuaternion) !== null && _a !== void 0 ? _a : Quaternion.Identity();\n\n      this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\n\n      this._linkedTransformNode.scaling.copyFrom(localScaling);\n    } else {\n      this._matrix = this._restPose;\n    }\n  };\n  /**\n   * Gets the inverse of the absolute transform matrix.\n   * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\n   * @returns a matrix\n   */\n\n\n  Bone.prototype.getInvertedAbsoluteTransform = function () {\n    return this._invertedAbsoluteTransform;\n  };\n  /**\n   * Gets the absolute transform matrix (ie base matrix * parent world matrix)\n   * @returns a matrix\n   */\n\n\n  Bone.prototype.getAbsoluteTransform = function () {\n    return this._absoluteTransform;\n  };\n  /**\n   * Links with the given transform node.\n   * The local matrix of this bone is copied from the transform node every frame.\n   * @param transformNode defines the transform node to link to\n   */\n\n\n  Bone.prototype.linkTransformNode = function (transformNode) {\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode--;\n    }\n\n    this._linkedTransformNode = transformNode;\n\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode++;\n    }\n  }; // Properties (matches TransformNode properties)\n\n  /**\n   * Gets the node used to drive the bone's transformation\n   * @returns a transform node or null\n   */\n\n\n  Bone.prototype.getTransformNode = function () {\n    return this._linkedTransformNode;\n  };\n\n  Object.defineProperty(Bone.prototype, \"position\", {\n    /** Gets or sets current position (in local space) */\n    get: function get() {\n      this._decompose();\n\n      return this._localPosition;\n    },\n    set: function set(newPosition) {\n      this._decompose();\n\n      this._localPosition.copyFrom(newPosition);\n\n      this._markAsDirtyAndCompose();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotation\", {\n    /** Gets or sets current rotation (in local space) */\n    get: function get() {\n      return this.getRotation();\n    },\n    set: function set(newRotation) {\n      this.setRotation(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\n    /** Gets or sets current rotation quaternion (in local space) */\n    get: function get() {\n      this._decompose();\n\n      return this._localRotation;\n    },\n    set: function set(newRotation) {\n      this.setRotationQuaternion(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"scaling\", {\n    /** Gets or sets current scaling (in local space) */\n    get: function get() {\n      return this.getScale();\n    },\n    set: function set(newScaling) {\n      this.setScale(newScaling);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"animationPropertiesOverride\", {\n    /**\n     * Gets the animation properties override\n     */\n    get: function get() {\n      return this._skeleton.animationPropertiesOverride;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  Bone.prototype._decompose = function () {\n    if (!this._needToDecompose) {\n      return;\n    }\n\n    this._needToDecompose = false;\n\n    if (!this._localScaling) {\n      this._localScaling = Vector3.Zero();\n      this._localRotation = Quaternion.Zero();\n      this._localPosition = Vector3.Zero();\n    }\n\n    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\n  };\n\n  Bone.prototype._compose = function () {\n    if (!this._needToCompose) {\n      return;\n    }\n\n    if (!this._localScaling) {\n      this._needToCompose = false;\n      return;\n    }\n\n    this._needToCompose = false;\n    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\n  };\n  /**\n   * Update the base and local matrices\n   * @param matrix defines the new base or local matrix\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\n   * @param updateLocalMatrix defines if the local matrix should be updated\n   */\n\n\n  Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix, updateLocalMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (updateLocalMatrix === void 0) {\n      updateLocalMatrix = true;\n    }\n\n    this._baseMatrix.copyFrom(matrix);\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    if (updateLocalMatrix) {\n      this._matrix = matrix;\n    } else {\n      this.markAsDirty();\n    }\n  };\n  /**\n   * @param rootMatrix\n   * @param updateChildren\n   * @hidden\n   */\n\n\n  Bone.prototype._updateDifferenceMatrix = function (rootMatrix, updateChildren) {\n    if (updateChildren === void 0) {\n      updateChildren = true;\n    }\n\n    if (!rootMatrix) {\n      rootMatrix = this._baseMatrix;\n    }\n\n    if (this.parent) {\n      rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(rootMatrix);\n    }\n\n    this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n\n    if (updateChildren) {\n      for (var index = 0; index < this.children.length; index++) {\n        this.children[index]._updateDifferenceMatrix();\n      }\n    }\n\n    this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n  };\n  /**\n   * Flag the bone as dirty (Forcing it to update everything)\n   * @returns this bone\n   */\n\n\n  Bone.prototype.markAsDirty = function () {\n    this._currentRenderId++;\n    this._childUpdateId++;\n\n    this._skeleton._markAsDirty();\n\n    return this;\n  };\n  /** @hidden */\n\n\n  Bone.prototype._markAsDirtyAndCompose = function () {\n    this.markAsDirty();\n    this._needToCompose = true;\n  };\n\n  Bone.prototype._markAsDirtyAndDecompose = function () {\n    this.markAsDirty();\n    this._needToDecompose = true;\n  };\n  /**\n   * Translate the bone in local or world space\n   * @param vec The amount to translate the bone\n   * @param space The space that the translation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n\n\n  Bone.prototype.translate = function (vec, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.addAtIndex(12, vec.x);\n      lm.addAtIndex(13, vec.y);\n      lm.addAtIndex(14, vec.z);\n    } else {\n      var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._TmpMats[0];\n      var tvec = Bone._TmpVecs[0];\n\n      if (this.parent) {\n        if (tNode && wm) {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n        }\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      tmat.setTranslationFromFloats(0, 0, 0);\n      tmat.invert();\n      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n      lm.addAtIndex(12, tvec.x);\n      lm.addAtIndex(13, tvec.y);\n      lm.addAtIndex(14, tvec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\n   * Set the position of the bone in local or world space\n   * @param position The position to set the bone\n   * @param space The space that the position is in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n\n\n  Bone.prototype.setPosition = function (position, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.setTranslationFromFloats(position.x, position.y, position.z);\n    } else {\n      var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._TmpMats[0];\n      var vec = Bone._TmpVecs[0];\n\n      if (this.parent) {\n        if (tNode && wm) {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n        }\n\n        tmat.invert();\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      Vector3.TransformCoordinatesToRef(position, tmat, vec);\n      lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\n   * Set the absolute position of the bone (world space)\n   * @param position The position to set the bone\n   * @param tNode The TransformNode that this bone is attached to\n   */\n\n\n  Bone.prototype.setAbsolutePosition = function (position, tNode) {\n    this.setPosition(position, Space.WORLD, tNode);\n  };\n  /**\n   * Scale the bone on the x, y and z axes (in local space)\n   * @param x The amount to scale the bone on the x axis\n   * @param y The amount to scale the bone on the y axis\n   * @param z The amount to scale the bone on the z axis\n   * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\n   */\n\n\n  Bone.prototype.scale = function (x, y, z, scaleChildren) {\n    if (scaleChildren === void 0) {\n      scaleChildren = false;\n    }\n\n    var locMat = this.getLocalMatrix(); // Apply new scaling on top of current local matrix\n\n    var scaleMat = Bone._TmpMats[0];\n    Matrix.ScalingToRef(x, y, z, scaleMat);\n    scaleMat.multiplyToRef(locMat, locMat); // Invert scaling matrix and apply the inverse to all children\n\n    scaleMat.invert();\n\n    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      var cm = child.getLocalMatrix();\n      cm.multiplyToRef(scaleMat, cm);\n      cm.multiplyAtIndex(12, x);\n      cm.multiplyAtIndex(13, y);\n      cm.multiplyAtIndex(14, z);\n\n      child._markAsDirtyAndDecompose();\n    }\n\n    this._markAsDirtyAndDecompose();\n\n    if (scaleChildren) {\n      for (var _b = 0, _c = this.children; _b < _c.length; _b++) {\n        var child = _c[_b];\n        child.scale(x, y, z, scaleChildren);\n      }\n    }\n  };\n  /**\n   * Set the bone scaling in local space\n   * @param scale defines the scaling vector\n   */\n\n\n  Bone.prototype.setScale = function (scale) {\n    this._decompose();\n\n    this._localScaling.copyFrom(scale);\n\n    this._markAsDirtyAndCompose();\n  };\n  /**\n   * Gets the current scaling in local space\n   * @returns the current scaling vector\n   */\n\n\n  Bone.prototype.getScale = function () {\n    this._decompose();\n\n    return this._localScaling;\n  };\n  /**\n   * Gets the current scaling in local space and stores it in a target vector\n   * @param result defines the target vector\n   */\n\n\n  Bone.prototype.getScaleToRef = function (result) {\n    this._decompose();\n\n    result.copyFrom(this._localScaling);\n  };\n  /**\n   * Set the yaw, pitch, and roll of the bone in local or world space\n   * @param yaw The rotation of the bone on the y axis\n   * @param pitch The rotation of the bone on the x axis\n   * @param roll The rotation of the bone on the z axis\n   * @param space The space that the axes of rotation are in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n\n\n  Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._TmpQuat;\n      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n\n    var rotMatInv = Bone._TmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n\n    var rotMat = Bone._TmpMats[1];\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, tNode);\n  };\n  /**\n   * Add a rotation to the bone on an axis in local or world space\n   * @param axis The axis to rotate the bone on\n   * @param amount The amount to rotate the bone\n   * @param space The space that the axis is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n\n\n  Bone.prototype.rotate = function (axis, amount, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var rmat = Bone._TmpMats[0];\n    rmat.setTranslationFromFloats(0, 0, 0);\n    Matrix.RotationAxisToRef(axis, amount, rmat);\n\n    this._rotateWithMatrix(rmat, space, tNode);\n  };\n  /**\n   * Set the rotation of the bone to a particular axis angle in local or world space\n   * @param axis The axis to rotate the bone on\n   * @param angle The angle that the bone should be rotated to\n   * @param space The space that the axis is in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n\n\n  Bone.prototype.setAxisAngle = function (axis, angle, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._TmpQuat;\n      Quaternion.RotationAxisToRef(axis, angle, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n\n    var rotMatInv = Bone._TmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n\n    var rotMat = Bone._TmpMats[1];\n    Matrix.RotationAxisToRef(axis, angle, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, tNode);\n  };\n  /**\n   * Set the euler rotation of the bone in local or world space\n   * @param rotation The euler rotation that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n\n\n  Bone.prototype.setRotation = function (rotation, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\n  };\n  /**\n   * Set the quaternion rotation of the bone in local or world space\n   * @param quat The quaternion rotation that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n\n\n  Bone.prototype.setRotationQuaternion = function (quat, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      this._decompose();\n\n      this._localRotation.copyFrom(quat);\n\n      this._markAsDirtyAndCompose();\n\n      return;\n    }\n\n    var rotMatInv = Bone._TmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n\n    var rotMat = Bone._TmpMats[1];\n    Matrix.FromQuaternionToRef(quat, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, tNode);\n  };\n  /**\n   * Set the rotation matrix of the bone in local or world space\n   * @param rotMat The rotation matrix that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n\n\n  Bone.prototype.setRotationMatrix = function (rotMat, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._TmpQuat;\n      Quaternion.FromRotationMatrixToRef(rotMat, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n\n    var rotMatInv = Bone._TmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n\n    var rotMat2 = Bone._TmpMats[1];\n    rotMat2.copyFrom(rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat2);\n\n    this._rotateWithMatrix(rotMat2, space, tNode);\n  };\n\n  Bone.prototype._rotateWithMatrix = function (rmat, space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lmat = this.getLocalMatrix();\n    var lx = lmat.m[12];\n    var ly = lmat.m[13];\n    var lz = lmat.m[14];\n    var parent = this.getParent();\n    var parentScale = Bone._TmpMats[3];\n    var parentScaleInv = Bone._TmpMats[4];\n\n    if (parent && space == Space.WORLD) {\n      if (tNode) {\n        parentScale.copyFrom(tNode.getWorldMatrix());\n        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n      } else {\n        parentScale.copyFrom(parent.getAbsoluteTransform());\n      }\n\n      parentScaleInv.copyFrom(parentScale);\n      parentScaleInv.invert();\n      lmat.multiplyToRef(parentScale, lmat);\n      lmat.multiplyToRef(rmat, lmat);\n      lmat.multiplyToRef(parentScaleInv, lmat);\n    } else {\n      if (space == Space.WORLD && tNode) {\n        parentScale.copyFrom(tNode.getWorldMatrix());\n        parentScaleInv.copyFrom(parentScale);\n        parentScaleInv.invert();\n        lmat.multiplyToRef(parentScale, lmat);\n        lmat.multiplyToRef(rmat, lmat);\n        lmat.multiplyToRef(parentScaleInv, lmat);\n      } else {\n        lmat.multiplyToRef(rmat, lmat);\n      }\n    }\n\n    lmat.setTranslationFromFloats(lx, ly, lz);\n    this.computeAbsoluteTransforms();\n\n    this._markAsDirtyAndDecompose();\n  };\n\n  Bone.prototype._getNegativeRotationToRef = function (rotMatInv, tNode) {\n    var scaleMatrix = Bone._TmpMats[2];\n    rotMatInv.copyFrom(this.getAbsoluteTransform());\n\n    if (tNode) {\n      rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\n      Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\n    } else {\n      Matrix.IdentityToRef(scaleMatrix);\n    }\n\n    rotMatInv.invert();\n\n    if (isNaN(rotMatInv.m[0])) {\n      // Matrix failed to invert.\n      // This can happen if scale is zero for example.\n      return false;\n    }\n\n    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\n    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n    return true;\n  };\n  /**\n   * Get the position of the bone in local or world space\n   * @param space The space that the returned position is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   * @returns The position of the bone\n   */\n\n\n  Bone.prototype.getPosition = function (space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(space, tNode, pos);\n    return pos;\n  };\n  /**\n   * Copy the position of the bone to a vector3 in local or world space\n   * @param space The space that the returned position is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   * @param result The vector3 to copy the position to\n   */\n\n\n  Bone.prototype.getPositionToRef = function (space, tNode, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      var lm = this.getLocalMatrix();\n      result.x = lm.m[12];\n      result.y = lm.m[13];\n      result.z = lm.m[14];\n    } else {\n      var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._TmpMats[0];\n\n      if (tNode && wm) {\n        tmat.copyFrom(this.getAbsoluteTransform());\n        tmat.multiplyToRef(wm, tmat);\n      } else {\n        tmat = this.getAbsoluteTransform();\n      }\n\n      result.x = tmat.m[12];\n      result.y = tmat.m[13];\n      result.z = tmat.m[14];\n    }\n  };\n  /**\n   * Get the absolute position of the bone (world space)\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The absolute position of the bone\n   */\n\n\n  Bone.prototype.getAbsolutePosition = function (tNode) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(Space.WORLD, tNode, pos);\n    return pos;\n  };\n  /**\n   * Copy the absolute position of the bone (world space) to the result param\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 to copy the absolute position to\n   */\n\n\n  Bone.prototype.getAbsolutePositionToRef = function (tNode, result) {\n    this.getPositionToRef(Space.WORLD, tNode, result);\n  };\n  /**\n   * Compute the absolute transforms of this bone and its children\n   */\n\n\n  Bone.prototype.computeAbsoluteTransforms = function () {\n    this._compose();\n\n    if (this.parent) {\n      this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(this._localMatrix);\n\n      var poseMatrix = this._skeleton.getPoseMatrix();\n\n      if (poseMatrix) {\n        this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n      }\n    }\n\n    var children = this.children;\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      children[i].computeAbsoluteTransforms();\n    }\n  };\n  /**\n   * Get the world direction from an axis that is in the local space of the bone\n   * @param localAxis The local direction that is used to compute the world direction\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The world direction\n   */\n\n\n  Bone.prototype.getDirection = function (localAxis, tNode) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, tNode, result);\n    return result;\n  };\n  /**\n   * Copy the world direction to a vector3 from an axis that is in the local space of the bone\n   * @param localAxis The local direction that is used to compute the world direction\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the world direction will be copied to\n   */\n\n\n  Bone.prototype.getDirectionToRef = function (localAxis, tNode, result) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var mat = Bone._TmpMats[0];\n    mat.copyFrom(this.getAbsoluteTransform());\n\n    if (tNode && wm) {\n      mat.multiplyToRef(wm, mat);\n    }\n\n    Vector3.TransformNormalToRef(localAxis, mat, result);\n    result.normalize();\n  };\n  /**\n   * Get the euler rotation of the bone in local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The euler rotation\n   */\n\n\n  Bone.prototype.getRotation = function (space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getRotationToRef(space, tNode, result);\n    return result;\n  };\n  /**\n   * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The vector3 that the rotation should be copied to\n   */\n\n\n  Bone.prototype.getRotationToRef = function (space, tNode, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var quat = Bone._TmpQuat;\n    this.getRotationQuaternionToRef(space, tNode, quat);\n    quat.toEulerAnglesToRef(result);\n  };\n  /**\n   * Get the quaternion rotation of the bone in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The quaternion rotation\n   */\n\n\n  Bone.prototype.getRotationQuaternion = function (space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var result = Quaternion.Identity();\n    this.getRotationQuaternionToRef(space, tNode, result);\n    return result;\n  };\n  /**\n   * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The quaternion that the rotation should be copied to\n   */\n\n\n  Bone.prototype.getRotationQuaternionToRef = function (space, tNode, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    if (space == Space.LOCAL) {\n      this._decompose();\n\n      result.copyFrom(this._localRotation);\n    } else {\n      var mat = Bone._TmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (tNode) {\n        amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.decompose(undefined, result, undefined);\n    }\n  };\n  /**\n   * Get the rotation matrix of the bone in local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The rotation matrix\n   */\n\n\n  Bone.prototype.getRotationMatrix = function (space, tNode) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var result = Matrix.Identity();\n    this.getRotationMatrixToRef(space, tNode, result);\n    return result;\n  };\n  /**\n   * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The quaternion that the rotation should be copied to\n   */\n\n\n  Bone.prototype.getRotationMatrixToRef = function (space, tNode, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      this.getLocalMatrix().getRotationMatrixToRef(result);\n    } else {\n      var mat = Bone._TmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (tNode) {\n        amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.getRotationMatrixToRef(result);\n    }\n  };\n  /**\n   * Get the world position of a point that is in the local space of the bone\n   * @param position The local position\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The world position\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocal = function (position, tNode) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getAbsolutePositionFromLocalToRef(position, tNode, result);\n    return result;\n  };\n  /**\n   * Get the world position of a point that is in the local space of the bone and copy it to the result param\n   * @param position The local position\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the world position should be copied to\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, tNode, result) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._TmpMats[0];\n\n    if (tNode && wm) {\n      tmat.copyFrom(this.getAbsoluteTransform());\n      tmat.multiplyToRef(wm, tmat);\n    } else {\n      tmat = this.getAbsoluteTransform();\n    }\n\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\n   * Get the local position of a point that is in world space\n   * @param position The world position\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The local position\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsolute = function (position, tNode) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\n    return result;\n  };\n  /**\n   * Get the local position of a point that is in world space and copy it to the result param\n   * @param position The world position\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the local position should be copied to\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, tNode, result) {\n    if (tNode === void 0) {\n      tNode = null;\n    }\n\n    var wm = null; //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._TmpMats[0];\n    tmat.copyFrom(this.getAbsoluteTransform());\n\n    if (tNode && wm) {\n      tmat.multiplyToRef(wm, tmat);\n    }\n\n    tmat.invert();\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\n   * Set the current local matrix as the restPose for this bone.\n   */\n\n\n  Bone.prototype.setCurrentPoseAsRest = function () {\n    this.setRestPose(this.getLocalMatrix());\n  };\n\n  Bone._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\n  Bone._TmpQuat = Quaternion.Identity();\n  Bone._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return Bone;\n}(Node);\n\nexport { Bone };","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","ArrayTools","Node","Space","__extends","name","skeleton","parentBone","localMatrix","restPose","baseMatrix","index","_super","getScene","_this","Array","_skeleton","_localMatrix","clone","Identity","_restPose","_baseMatrix","_index","bones","push","setParent","_updateDifferenceMatrix","Object","Bone","_compose","value","_needToCompose","updateFlag","copyFrom","_markAsDirtyAndDecompose","_parentNode","newParent","parent","children","getSkeleton","indexOf","updateDifferenceMatrix","splice","markAsDirty","matrix","updateMatrix","_worldTransform","_linkedTransformNode","localScaling","localRotation","localPosition","getRestPose","decompose","position","rotationQuaternion","_a","scaling","_matrix","_invertedAbsoluteTransform","_absoluteTransform","transformNode","_numBonesWithLinkedTransformNode","_decompose","_localPosition","newPosition","_markAsDirtyAndCompose","getRotation","newRotation","setRotation","_localRotation","setRotationQuaternion","getScale","newScaling","setScale","animationPropertiesOverride","_needToDecompose","_localScaling","Zero","ComposeToRef","updateLocalMatrix","rootMatrix","updateChildren","multiplyToRef","invertToRef","length","_scalingDeterminant","determinant","_currentRenderId","_childUpdateId","_markAsDirty","vec","space","tNode","LOCAL","lm","getLocalMatrix","addAtIndex","x","y","z","wm","getWorldMatrix","computeAbsoluteTransforms","tmat","_TmpMats","tvec","_TmpVecs","getAbsoluteTransform","IdentityToRef","setTranslationFromFloats","invert","TransformCoordinatesToRef","setPosition","WORLD","scaleChildren","locMat","scaleMat","ScalingToRef","_i","child","cm","multiplyAtIndex","_b","scale","result","yaw","pitch","roll","quat","_TmpQuat","RotationYawPitchRollToRef","rotMatInv","_getNegativeRotationToRef","rotMat","_rotateWithMatrix","axis","amount","rmat","RotationAxisToRef","angle","rotation","setYawPitchRoll","FromQuaternionToRef","FromRotationMatrixToRef","rotMat2","lmat","lx","m","ly","lz","getParent","parentScale","parentScaleInv","scaleMatrix","isNaN","pos","getPositionToRef","poseMatrix","getPoseMatrix","len","i","localAxis","getDirectionToRef","mat","TransformNormalToRef","normalize","getRotationToRef","getRotationQuaternionToRef","toEulerAnglesToRef","amat","undefined","getRotationMatrixToRef","getAbsolutePositionFromLocalToRef","getLocalPositionFromAbsoluteToRef","setRestPose","BuildArray"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Bones/bone.ts"],"sourcesContent":["import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type AnimationPropertiesOverride = import(\"../Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children = new Array<Bone>();\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @hidden Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix;\r\n    private _restPose: Matrix;\r\n    private _baseMatrix: Matrix;\r\n    private _absoluteTransform = new Matrix();\r\n    private _invertedAbsoluteTransform = new Matrix();\r\n    private _scalingDeterminant = 1;\r\n    private _worldTransform = new Matrix();\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @hidden */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @hidden */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @hidden */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    set _matrix(value: Matrix) {\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix\r\n     * @param restPose defines the rest pose matrix\r\n     * @param baseMatrix defines the base matrix\r\n     * @param index defines index of the bone in the hierarchy\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restPose: Nullable<Matrix> = null,\r\n        baseMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene());\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\r\n        this._restPose = restPose ? restPose : this._localMatrix.clone();\r\n        this._baseMatrix = baseMatrix ? baseMatrix : this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        if (baseMatrix || localMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateDifferenceMatrix: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns a matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the base matrix (initial matrix which remains unchanged)\r\n     * @returns the base matrix (as known as bind pose matrix)\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this._baseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this._restPose;\r\n    }\r\n\r\n    /**\r\n     * Sets the rest pose matrix\r\n     * @param matrix the local-space rest pose to set for this bone\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this._restPose.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind pose matrix\r\n     * @returns the bind pose matrix\r\n     * @deprecated Please use getBaseMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this._baseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the bind pose matrix\r\n     * @param matrix the local-space bind pose to set for this bone\r\n     * @deprecated Please use updateMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        return this._worldTransform;\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to rest pose matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestPose().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restPose;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the absolute transform matrix.\r\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n     * @returns a matrix\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this._invertedAbsoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n     * @returns a matrix\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is copied from the transform node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the base and local matrices\r\n     * @param matrix defines the new base or local matrix\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     * @param updateLocalMatrix defines if the local matrix should be updated\r\n     */\r\n    public updateMatrix(matrix: Matrix, updateDifferenceMatrix = true, updateLocalMatrix = true): void {\r\n        this._baseMatrix.copyFrom(matrix);\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = matrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param rootMatrix\r\n     * @param updateChildren\r\n     * @hidden\r\n     */\r\n    public _updateDifferenceMatrix(rootMatrix?: Matrix, updateChildren = true): void {\r\n        if (!rootMatrix) {\r\n            rootMatrix = this._baseMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(rootMatrix);\r\n        }\r\n\r\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateDifferenceMatrix();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.addAtIndex(12, vec.x);\r\n            lm.addAtIndex(13, vec.y);\r\n            lm.addAtIndex(14, vec.z);\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            tmat.setTranslationFromFloats(0, 0, 0);\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            lm.addAtIndex(12, tvec.x);\r\n            lm.addAtIndex(13, tvec.y);\r\n            lm.addAtIndex(14, tvec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            const tmat = Bone._TmpMats[0];\r\n            const vec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                }\r\n                tmat.invert();\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\r\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteTransform());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteTransforms();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getNegativeRotationToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            let tmat = Bone._TmpMats[0];\r\n\r\n            if (tNode && wm) {\r\n                tmat.copyFrom(this.getAbsoluteTransform());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteTransform();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute transforms of this bone and its children\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteTransforms();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        const mat = Bone._TmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteTransform();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteTransform();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        let tmat = Bone._TmpMats[0];\r\n\r\n        if (tNode && wm) {\r\n            tmat.copyFrom(this.getAbsoluteTransform());\r\n            tmat.multiplyToRef(wm, tmat);\r\n        } else {\r\n            tmat = this.getAbsoluteTransform();\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestPose(this.getLocalMatrix());\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}