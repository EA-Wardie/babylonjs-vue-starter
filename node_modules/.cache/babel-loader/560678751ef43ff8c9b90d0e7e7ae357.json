{"ast":null,"code":"import \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { RotationGizmo } from \"./rotationGizmo.js\";\nimport { PositionGizmo } from \"./positionGizmo.js\";\nimport { ScaleGizmo } from \"./scaleGizmo.js\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo.js\";\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\n\nvar GizmoManager =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a gizmo manager\n   * @param _scene the scene to overlay the gizmos on top of\n   * @param thickness display gizmo axis thickness\n   * @param utilityLayer the layer where gizmos are rendered\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n   */\n  function GizmoManager(_scene, thickness, utilityLayer, keepDepthUtilityLayer) {\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    if (utilityLayer === void 0) {\n      utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (keepDepthUtilityLayer === void 0) {\n      keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    this._scene = _scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\n\n    this.enableAutoPicking = true;\n    /** Fires an event when the manager is attached to a mesh */\n\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    this._scaleRatio = 1;\n    /** Node Caching for quick lookup */\n\n    this._gizmoAxisCache = new Map();\n    /**\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\n     */\n\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n     */\n\n    this.attachableMeshes = null;\n    /**\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n     */\n\n    this.attachableNodes = null;\n    /**\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n     */\n\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n\n    var attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\n\n    var gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n\n  Object.defineProperty(GizmoManager.prototype, \"keepDepthUtilityLayer\", {\n    /**\n     * Utility layer that the bounding box gizmo belongs to\n     */\n    get: function get() {\n      return this._defaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"utilityLayer\", {\n    /**\n     * Utility layer that all gizmos besides bounding box belong to\n     */\n    get: function get() {\n      return this._defaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"isHovered\", {\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get: function get() {\n      var hovered = false;\n\n      for (var key in this.gizmos) {\n        var gizmo = this.gizmos[key];\n\n        if (gizmo && gizmo.isHovered) {\n          hovered = true;\n          break;\n        }\n      }\n\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"scaleRatio\", {\n    get: function get() {\n      return this._scaleRatio;\n    },\n\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set: function set(value) {\n      this._scaleRatio = value;\n      [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(function (gizmo) {\n        if (gizmo) {\n          gizmo.scaleRatio = value;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Subscribes to pointer down events, for attaching and detaching mesh\n   * @param scene The scene layer the observer will be added to\n   */\n\n  GizmoManager.prototype._attachToMeshPointerObserver = function (scene) {\n    var _this = this; // Instantiate/dispose gizmos based on pointer actions\n\n\n    var pointerObserver = scene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this.usePointerToAttachGizmos) {\n        return;\n      }\n\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          if (_this.enableAutoPicking) {\n            var node_1 = pointerInfo.pickInfo.pickedMesh;\n\n            if (_this.attachableMeshes == null) {\n              // Attach to the most parent node\n              while (node_1 && node_1.parent != null) {\n                node_1 = node_1.parent;\n              }\n            } else {\n              // Attach to the parent node that is an attachableMesh\n              var found_1 = false;\n\n              _this.attachableMeshes.forEach(function (mesh) {\n                if (node_1 && (node_1 == mesh || node_1.isDescendantOf(mesh))) {\n                  node_1 = mesh;\n                  found_1 = true;\n                }\n              });\n\n              if (!found_1) {\n                node_1 = null;\n              }\n            }\n\n            if (node_1 instanceof AbstractMesh) {\n              if (_this._attachedMesh != node_1) {\n                _this.attachToMesh(node_1);\n              }\n            } else {\n              if (_this.clearGizmoOnEmptyPointerEvent) {\n                _this.attachToMesh(null);\n              }\n            }\n          }\n        } else {\n          if (_this.clearGizmoOnEmptyPointerEvent) {\n            _this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\n   * Attaches a set of gizmos to the specified mesh\n   * @param mesh The mesh the gizmo's should be attached to\n   */\n\n\n  GizmoManager.prototype.attachToMesh = function (mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  };\n  /**\n   * Attaches a set of gizmos to the specified node\n   * @param node The node the gizmo's should be attached to\n   */\n\n\n  GizmoManager.prototype.attachToNode = function (node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = null;\n    this._attachedNode = node;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  };\n\n  Object.defineProperty(GizmoManager.prototype, \"positionGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.positionGizmo;\n    },\n\n    /**\n     * If the position gizmo is enabled\n     */\n    set: function set(value) {\n      if (value) {\n        if (!this.gizmos.positionGizmo) {\n          this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.positionGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"rotationGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.rotationGizmo;\n    },\n\n    /**\n     * If the rotation gizmo is enabled\n     */\n    set: function set(value) {\n      if (value) {\n        if (!this.gizmos.rotationGizmo) {\n          this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.rotationGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"scaleGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.scaleGizmo;\n    },\n\n    /**\n     * If the scale gizmo is enabled\n     */\n    set: function set(value) {\n      if (value) {\n        this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n\n        if (this._attachedNode) {\n          this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.scaleGizmo) {\n        this.gizmos.scaleGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.scaleGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"boundingBoxGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.boundingBoxGizmo;\n    },\n\n    /**\n     * If the boundingBox gizmo is enabled\n     */\n    set: function set(value) {\n      if (value) {\n        this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n\n        if (this._attachedMesh) {\n          this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n        } else {\n          this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n        }\n\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n        }\n      } else if (this.gizmos.boundingBoxGizmo) {\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n\n        this.gizmos.boundingBoxGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.boundingBoxGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   */\n\n  GizmoManager.prototype.addToAxisCache = function (gizmoAxisCache) {\n    var _this = this;\n\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach(function (v, k) {\n        _this._gizmoAxisCache.set(k, v);\n      });\n    }\n  };\n  /**\n   * Disposes of the gizmo manager\n   */\n\n\n  GizmoManager.prototype.dispose = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    this._pointerObservers.forEach(function (observer) {\n      _this._scene.onPointerObservable.remove(observer);\n    });\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n\n    if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\n      (_a = this._defaultKeepDepthUtilityLayer) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n\n    if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\n      (_b = this._defaultUtilityLayer) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  };\n\n  return GizmoManager;\n}();\n\nexport { GizmoManager };","map":{"version":3,"mappings":"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","names":["Observable","PointerEventTypes","AbstractMesh","UtilityLayerRenderer","Color3","SixDofDragBehavior","Gizmo","RotationGizmo","PositionGizmo","ScaleGizmo","BoundingBoxGizmo","_scene","thickness","utilityLayer","keepDepthUtilityLayer","DefaultUtilityLayer","DefaultKeepDepthUtilityLayer","positionGizmo","rotationGizmo","scaleGizmo","boundingBoxGizmo","FromHexString","Map","_defaultUtilityLayer","_defaultKeepDepthUtilityLayer","utilityLayerScene","autoClearDepthAndStencil","_thickness","gizmos","attachToMeshPointerObserver","_attachToMeshPointerObserver","gizmoAxisPointerObserver","GizmoAxisPointerObserver","_gizmoAxisCache","_pointerObservers","Object","GizmoManager","hovered","key","gizmo","isHovered","_scaleRatio","value","forEach","scaleRatio","scene","pointerObserver","onPointerObservable","add","pointerInfo","_this","usePointerToAttachGizmos","type","POINTERDOWN","pickInfo","pickedMesh","enableAutoPicking","node_1","attachableMeshes","parent","found_1","mesh","isDescendantOf","_attachedMesh","attachToMesh","clearGizmoOnEmptyPointerEvent","removeBehavior","boundingBoxDragBehavior","_attachedNode","_gizmosEnabled","attachedMesh","boundingBoxGizmoEnabled","addBehavior","onAttachedToMeshObservable","notifyObservers","node","attachedNode","onAttachedToNodeObservable","_boundingBoxColor","gizmoAxisCache","size","v","k","set","observer","remove","dispose","_DefaultKeepDepthUtilityLayer","_a","_DefaultUtilityLayer","_b","detach","clear"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gizmos/gizmoManager.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\r\nimport type { GizmoAxisCache } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { RotationGizmo } from \"./rotationGizmo\";\r\nimport { PositionGizmo } from \"./positionGizmo\";\r\nimport { ScaleGizmo } from \"./scaleGizmo\";\r\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\n\r\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\r\nexport class GizmoManager implements IDisposable {\r\n    /**\r\n     * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time\r\n     */\r\n    public gizmos: {\r\n        positionGizmo: Nullable<PositionGizmo>;\r\n        rotationGizmo: Nullable<RotationGizmo>;\r\n        scaleGizmo: Nullable<ScaleGizmo>;\r\n        boundingBoxGizmo: Nullable<BoundingBoxGizmo>;\r\n    };\r\n\r\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\r\n    public clearGizmoOnEmptyPointerEvent = false;\r\n\r\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\r\n    public enableAutoPicking = true;\r\n\r\n    /** Fires an event when the manager is attached to a mesh */\r\n    public onAttachedToMeshObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /** Fires an event when the manager is attached to a node */\r\n    public onAttachedToNodeObservable = new Observable<Nullable<Node>>();\r\n\r\n    private _gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\r\n    private _pointerObservers: Observer<PointerInfo>[] = [];\r\n    private _attachedMesh: Nullable<AbstractMesh> = null;\r\n    private _attachedNode: Nullable<Node> = null;\r\n    private _boundingBoxColor = Color3.FromHexString(\"#0984e3\");\r\n    private _defaultUtilityLayer: UtilityLayerRenderer;\r\n    private _defaultKeepDepthUtilityLayer: UtilityLayerRenderer;\r\n    private _thickness: number = 1;\r\n    private _scaleRatio: number = 1;\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\r\n    public boundingBoxDragBehavior = new SixDofDragBehavior();\r\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\r\n    public attachableMeshes: Nullable<Array<AbstractMesh>> = null;\r\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\r\n    public attachableNodes: Nullable<Array<Node>> = null;\r\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\r\n    public usePointerToAttachGizmos = true;\r\n\r\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\r\n    public get keepDepthUtilityLayer() {\r\n        return this._defaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\r\n    public get utilityLayer() {\r\n        return this._defaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<Gizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && gizmo.isHovered) {\r\n                hovered = true;\r\n                break;\r\n            }\r\n        }\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.scaleRatio = value;\r\n            }\r\n        });\r\n    }\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a gizmo manager\r\n     * @param _scene the scene to overlay the gizmos on top of\r\n     * @param thickness display gizmo axis thickness\r\n     * @param utilityLayer the layer where gizmos are rendered\r\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        thickness: number = 1,\r\n        utilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        keepDepthUtilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer\r\n    ) {\r\n        this._defaultUtilityLayer = utilityLayer;\r\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\r\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n        this._thickness = thickness;\r\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\r\n\r\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\r\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\r\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer down events, for attaching and detaching mesh\r\n     * @param scene The scene layer the observer will be added to\r\n     */\r\n    private _attachToMeshPointerObserver(scene: Scene): Observer<PointerInfo> {\r\n        // Instantiate/dispose gizmos based on pointer actions\r\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.usePointerToAttachGizmos) {\r\n                return;\r\n            }\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\r\n                    if (this.enableAutoPicking) {\r\n                        let node: Nullable<Node> = pointerInfo.pickInfo.pickedMesh;\r\n                        if (this.attachableMeshes == null) {\r\n                            // Attach to the most parent node\r\n                            while (node && node.parent != null) {\r\n                                node = node.parent;\r\n                            }\r\n                        } else {\r\n                            // Attach to the parent node that is an attachableMesh\r\n                            let found = false;\r\n                            this.attachableMeshes.forEach((mesh) => {\r\n                                if (node && (node == mesh || node.isDescendantOf(mesh))) {\r\n                                    node = mesh;\r\n                                    found = true;\r\n                                }\r\n                            });\r\n                            if (!found) {\r\n                                node = null;\r\n                            }\r\n                        }\r\n                        if (node instanceof AbstractMesh) {\r\n                            if (this._attachedMesh != node) {\r\n                                this.attachToMesh(node);\r\n                            }\r\n                        } else {\r\n                            if (this.clearGizmoOnEmptyPointerEvent) {\r\n                                this.attachToMesh(null);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.clearGizmoOnEmptyPointerEvent) {\r\n                        this.attachToMesh(null);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified mesh\r\n     * @param mesh The mesh the gizmo's should be attached to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = mesh;\r\n        this._attachedNode = null;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<Gizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedMesh = mesh;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\r\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified node\r\n     * @param node The node the gizmo's should be attached to\r\n     */\r\n    public attachToNode(node: Nullable<Node>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = null;\r\n        this._attachedNode = node;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<Gizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedNode = node;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\r\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToNodeObservable.notifyObservers(node);\r\n    }\r\n\r\n    /**\r\n     * If the position gizmo is enabled\r\n     */\r\n    public set positionGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.positionGizmo) {\r\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.positionGizmo) {\r\n            this.gizmos.positionGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.positionGizmo = value;\r\n    }\r\n    public get positionGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.positionGizmo;\r\n    }\r\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\r\n    public set rotationGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.rotationGizmo) {\r\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.rotationGizmo) {\r\n            this.gizmos.rotationGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.rotationGizmo = value;\r\n    }\r\n    public get rotationGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.rotationGizmo;\r\n    }\r\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\r\n    public set scaleGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            if (this._attachedNode) {\r\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.scaleGizmo) {\r\n            this.gizmos.scaleGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.scaleGizmo = value;\r\n    }\r\n    public get scaleGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.scaleGizmo;\r\n    }\r\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\r\n    public set boundingBoxGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\r\n            if (this._attachedMesh) {\r\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\r\n            } else {\r\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n        } else if (this.gizmos.boundingBoxGizmo) {\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.boundingBoxGizmo = value;\r\n    }\r\n    public get boundingBoxGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.boundingBoxGizmo;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(gizmoAxisCache: Map<Mesh, GizmoAxisCache>) {\r\n        if (gizmoAxisCache.size > 0) {\r\n            gizmoAxisCache.forEach((v, k) => {\r\n                this._gizmoAxisCache.set(k, v);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo manager\r\n     */\r\n    public dispose() {\r\n        this._pointerObservers.forEach((observer) => {\r\n            this._scene.onPointerObservable.remove(observer);\r\n        });\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<Gizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo) {\r\n                gizmo.dispose();\r\n            }\r\n        }\r\n        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\r\n            this._defaultKeepDepthUtilityLayer?.dispose();\r\n        }\r\n        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\r\n            this._defaultUtilityLayer?.dispose();\r\n        }\r\n        this.boundingBoxDragBehavior.detach();\r\n        this.onAttachedToMeshObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}