{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport \"../Shaders/particles.vertex.js\"; // Adds the parsers to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedData, scene, container, rootUrl) {\n  var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n  if (!individualParser) {\n    return;\n  } // Particles Systems\n\n\n  if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n    for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n      var parsedParticleSystem = parsedData.particleSystems[index];\n      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\n    }\n  }\n});\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedParticleSystem, scene, rootUrl) {\n  if (parsedParticleSystem.activeParticleCount) {\n    var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  } else {\n    var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  }\n});\n\nEngine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError, particleSystem) {\n  var _a;\n\n  if (uniformsNames === void 0) {\n    uniformsNames = [];\n  }\n\n  if (samplers === void 0) {\n    samplers = [];\n  }\n\n  if (defines === void 0) {\n    defines = \"\";\n  }\n\n  var attributesNamesOrOptions = [];\n  var effectCreationOption = [];\n  var allSamplers = [];\n\n  if (particleSystem) {\n    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\n  } else {\n    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\n    effectCreationOption = ParticleSystem._GetEffectCreationOptions();\n  }\n\n  if (defines.indexOf(\" BILLBOARD\") === -1) {\n    defines += \"\\n#define BILLBOARD\\n\";\n  }\n\n  if (samplers.indexOf(\"diffuseSampler\") === -1) {\n    samplers.push(\"diffuseSampler\");\n  }\n\n  return this.createEffect({\n    vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : \"particles\",\n    fragmentElement: fragmentName\n  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\n};\n\nMesh.prototype.getEmittedParticleSystems = function () {\n  var results = new Array();\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n\n    if (particleSystem.emitter === this) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};\n\nMesh.prototype.getHierarchyEmittedParticleSystems = function () {\n  var results = new Array();\n  var descendants = this.getDescendants();\n  descendants.push(this);\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n    var emitter = particleSystem.emitter;\n\n    if (emitter.position && descendants.indexOf(emitter) !== -1) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};","map":{"version":3,"mappings":"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","names":["Mesh","GPUParticleSystem","AbstractScene","Engine","ParticleSystem","SceneComponentConstants","AddParser","NAME_PARTICLESYSTEM","parsedData","scene","container","rootUrl","individualParser","GetIndividualParser","particleSystems","undefined","index","cache","length","parsedParticleSystem","push","AddIndividualParser","activeParticleCount","ps","Parse","prototype","createEffectForParticles","fragmentName","uniformsNames","samplers","defines","fallbacks","onCompiled","onError","particleSystem","attributesNamesOrOptions","effectCreationOption","allSamplers","fillUniformsAttributesAndSamplerNames","_GetAttributeNamesOrOptions","_GetEffectCreationOptions","indexOf","createEffect","vertex","vertexShaderName","_a","fragmentElement","concat","getEmittedParticleSystems","results","Array","getScene","emitter","getHierarchyEmittedParticleSystems","descendants","getDescendants","position"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/particleSystemComponent.ts"],"sourcesContent":["import { Mesh } from \"../Meshes/mesh\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\n\r\n// Adds the parsers to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    const individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n\r\n    if (!individualParser) {\r\n        return;\r\n    }\r\n\r\n    // Particles Systems\r\n    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n        for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n            const parsedParticleSystem = parsedData.particleSystems[index];\r\n            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\r\n        }\r\n    }\r\n});\r\n\r\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem: any, scene: Scene, rootUrl: string) => {\r\n    if (parsedParticleSystem.activeParticleCount) {\r\n        const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    } else {\r\n        const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    }\r\n});\r\n\r\ndeclare module \"../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Create an effect to use with particle systems.\r\n         * Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass\r\n         * the particle system for which you want to create a custom effect in the last parameter\r\n         * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)\r\n         * @param uniformsNames defines a list of attribute names\r\n         * @param samplers defines an array of string used to represent textures\r\n         * @param defines defines the string containing the defines to use to compile the shaders\r\n         * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n         * @param onCompiled defines a function to call when the effect creation is successful\r\n         * @param onError defines a function to call when the effect creation has failed\r\n         * @param particleSystem the particle system you want to create the effect for\r\n         * @returns the new Effect\r\n         */\r\n        createEffectForParticles(\r\n            fragmentName: string,\r\n            uniformsNames: string[],\r\n            samplers: string[],\r\n            defines: string,\r\n            fallbacks?: EffectFallbacks,\r\n            onCompiled?: (effect: Effect) => void,\r\n            onError?: (effect: Effect, errors: string) => void,\r\n            particleSystem?: IParticleSystem\r\n        ): Effect;\r\n    }\r\n}\r\n\r\nEngine.prototype.createEffectForParticles = function (\r\n    fragmentName: string,\r\n    uniformsNames: string[] = [],\r\n    samplers: string[] = [],\r\n    defines = \"\",\r\n    fallbacks?: EffectFallbacks,\r\n    onCompiled?: (effect: Effect) => void,\r\n    onError?: (effect: Effect, errors: string) => void,\r\n    particleSystem?: IParticleSystem\r\n): Effect {\r\n    let attributesNamesOrOptions: Array<string> = [];\r\n    let effectCreationOption: Array<string> = [];\r\n    const allSamplers: Array<string> = [];\r\n\r\n    if (particleSystem) {\r\n        particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\r\n    } else {\r\n        attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\r\n        effectCreationOption = ParticleSystem._GetEffectCreationOptions();\r\n    }\r\n\r\n    if (defines.indexOf(\" BILLBOARD\") === -1) {\r\n        defines += \"\\n#define BILLBOARD\\n\";\r\n    }\r\n\r\n    if (samplers.indexOf(\"diffuseSampler\") === -1) {\r\n        samplers.push(\"diffuseSampler\");\r\n    }\r\n\r\n    return this.createEffect(\r\n        {\r\n            vertex: particleSystem?.vertexShaderName ?? \"particles\",\r\n            fragmentElement: fragmentName,\r\n        },\r\n        attributesNamesOrOptions,\r\n        effectCreationOption.concat(uniformsNames),\r\n        allSamplers.concat(samplers),\r\n        defines,\r\n        fallbacks,\r\n        onCompiled,\r\n        onError\r\n    );\r\n};\r\n\r\ndeclare module \"../Meshes/mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh is the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getEmittedParticleSystems(): IParticleSystem[];\r\n\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getHierarchyEmittedParticleSystems(): IParticleSystem[];\r\n    }\r\n}\r\n\r\nMesh.prototype.getEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results = new Array<IParticleSystem>();\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        if (particleSystem.emitter === this) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n    return results;\r\n};\r\n\r\nMesh.prototype.getHierarchyEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results = new Array<IParticleSystem>();\r\n    const descendants = this.getDescendants();\r\n    descendants.push(this);\r\n\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        const emitter: any = particleSystem.emitter;\r\n\r\n        if (emitter.position && descendants.indexOf(emitter) !== -1) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}