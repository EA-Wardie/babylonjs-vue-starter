{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __extends } from \"tslib\";\nimport { MultiRenderTarget } from \"./multiRenderTarget.js\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess.js\";\n/**\n * A multi render target designed to render the prepass.\n * Prepass is a scene component used to render information in multiple textures\n * alongside with the scene materials rendering.\n * Note : This is an internal class, and you should NOT need to instanciate this.\n * Only the `PrePassRenderer` should instanciate this class.\n * It is more likely that you need a regular `MultiRenderTarget`\n * @hidden\n */\n\nvar PrePassRenderTarget =\n/** @class */\nfunction (_super) {\n  __extends(PrePassRenderTarget, _super);\n\n  function PrePassRenderTarget(name, renderTargetTexture, size, count, scene, options) {\n    var _this = _super.call(this, name, size, count, scene, options) || this;\n    /**\n     * @hidden\n     */\n\n\n    _this._beforeCompositionPostProcesses = [];\n    /**\n     * @hidden\n     */\n\n    _this._internalTextureDirty = false;\n    /**\n     * Is this render target enabled for prepass rendering\n     */\n\n    _this.enabled = false;\n    /**\n     * Render target associated with this prePassRenderTarget\n     * If this is `null`, it means this prePassRenderTarget is associated with the scene\n     */\n\n    _this.renderTargetTexture = null;\n    _this.renderTargetTexture = renderTargetTexture;\n    return _this;\n  }\n  /**\n   * Creates a composition effect for this RT\n   * @hidden\n   */\n\n\n  PrePassRenderTarget.prototype._createCompositionEffect = function () {\n    this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\n\n    this.imageProcessingPostProcess._updateParameters();\n  };\n  /**\n   * Checks that the size of this RT is still adapted to the desired render size.\n   * @hidden\n   */\n\n\n  PrePassRenderTarget.prototype._checkSize = function () {\n    var requiredWidth = this._engine.getRenderWidth(true);\n\n    var requiredHeight = this._engine.getRenderHeight(true);\n\n    var width = this.getRenderWidth();\n    var height = this.getRenderHeight();\n\n    if (width !== requiredWidth || height !== requiredHeight) {\n      this.resize({\n        width: requiredWidth,\n        height: requiredHeight\n      });\n      this._internalTextureDirty = true;\n    }\n  };\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n\n\n  PrePassRenderTarget.prototype.updateCount = function (count, options, textureNames) {\n    _super.prototype.updateCount.call(this, count, options, textureNames);\n\n    this._internalTextureDirty = true;\n  };\n  /**\n   * Resets the post processes chains applied to this RT.\n   * @hidden\n   */\n\n\n  PrePassRenderTarget.prototype._resetPostProcessChain = function () {\n    this._beforeCompositionPostProcesses = [];\n  };\n  /**\n   * Diposes this render target\n   */\n\n\n  PrePassRenderTarget.prototype.dispose = function () {\n    var scene = this._scene;\n\n    _super.prototype.dispose.call(this);\n\n    if (scene && scene.prePassRenderer) {\n      var index = scene.prePassRenderer.renderTargets.indexOf(this);\n\n      if (index !== -1) {\n        scene.prePassRenderer.renderTargets.splice(index, 1);\n      }\n    }\n\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.dispose();\n    }\n\n    if (this.renderTargetTexture) {\n      this.renderTargetTexture._prePassRenderTarget = null;\n    }\n\n    if (this._outputPostProcess) {\n      this._outputPostProcess.autoClear = true;\n\n      this._outputPostProcess.restoreDefaultInputTexture();\n    }\n  };\n\n  return PrePassRenderTarget;\n}(MultiRenderTarget);\n\nexport { PrePassRenderTarget };","map":{"version":3,"mappings":";;;AACA,SAASA,iBAAT,QAAkC,wBAAlC;AAKA,SAASC,0BAAT,QAA2C,mDAA3C;AAGA;;;;;;;;;;AASA;AAAA;AAAA;AAAyCC;;AAyCrC,+BAAmBC,IAAnB,EAAiCC,mBAAjC,EAAqFC,IAArF,EAAgGC,KAAhG,EAA+GC,KAA/G,EAA8HC,OAA9H,EAA6K;AAA7K,gBACIC,kBAAMN,IAAN,EAAYE,IAAZ,EAAkBC,KAAlB,EAAyBC,KAAzB,EAAgCC,OAAhC,KAAwC,IAD5C;AAxCA;;;;;AAGOE,4CAAiD,EAAjD;AAqBP;;;;AAGOA,kCAAwB,KAAxB;AAEP;;;;AAGOA,oBAAmB,KAAnB;AAEP;;;;;AAIOA,gCAAqD,IAArD;AAKHA,SAAI,CAACN,mBAAL,GAA2BA,mBAA3B;;AACH;AAED;;;;;;AAIOO,2DAAP;AACI,SAAKC,0BAAL,GAAkC,IAAIX,0BAAJ,CAA+B,oBAA/B,EAAqD,CAArD,EAAwD,IAAxD,EAA8DY,SAA9D,EAAyE,KAAKC,OAA9E,CAAlC;;AACA,SAAKF,0BAAL,CAAgCG,iBAAhC;AACH,GAHM;AAKP;;;;;;AAIOJ,6CAAP;AACI,QAAMK,aAAa,GAAG,KAAKF,OAAL,CAAaG,cAAb,CAA4B,IAA5B,CAAtB;;AACA,QAAMC,cAAc,GAAG,KAAKJ,OAAL,CAAaK,eAAb,CAA6B,IAA7B,CAAvB;;AAEA,QAAMC,KAAK,GAAG,KAAKH,cAAL,EAAd;AACA,QAAMI,MAAM,GAAG,KAAKF,eAAL,EAAf;;AAEA,QAAIC,KAAK,KAAKJ,aAAV,IAA2BK,MAAM,KAAKH,cAA1C,EAA0D;AACtD,WAAKI,MAAL,CAAY;AAAEF,aAAK,EAAEJ,aAAT;AAAwBK,cAAM,EAAEH;AAAhC,OAAZ;AAEA,WAAKK,qBAAL,GAA6B,IAA7B;AACH;AACJ,GAZM;AAcP;;;;;;;;;AAOOZ,8CAAP,UAAmBL,KAAnB,EAAkCE,OAAlC,EAAuEgB,YAAvE,EAA8F;AAC1Ff,qBAAMgB,WAAN,CAAiBC,IAAjB,CAAiB,IAAjB,EAAkBpB,KAAlB,EAAyBE,OAAzB,EAAkCgB,YAAlC;;AACA,SAAKD,qBAAL,GAA6B,IAA7B;AACH,GAHM;AAKP;;;;;;AAIOZ,yDAAP;AACI,SAAKgB,+BAAL,GAAuC,EAAvC;AACH,GAFM;AAIP;;;;;AAGOhB,0CAAP;AACI,QAAMJ,KAAK,GAAG,KAAKqB,MAAnB;;AAEAnB,qBAAMoB,OAAN,CAAaH,IAAb,CAAa,IAAb;;AAEA,QAAInB,KAAK,IAAIA,KAAK,CAACuB,eAAnB,EAAoC;AAChC,UAAMC,KAAK,GAAGxB,KAAK,CAACuB,eAAN,CAAsBE,aAAtB,CAAoCC,OAApC,CAA4C,IAA5C,CAAd;;AAEA,UAAIF,KAAK,KAAK,CAAC,CAAf,EAAkB;AACdxB,aAAK,CAACuB,eAAN,CAAsBE,aAAtB,CAAoCE,MAApC,CAA2CH,KAA3C,EAAkD,CAAlD;AACH;AACJ;;AAED,QAAI,KAAKnB,0BAAT,EAAqC;AACjC,WAAKA,0BAAL,CAAgCiB,OAAhC;AACH;;AAED,QAAI,KAAKzB,mBAAT,EAA8B;AAC1B,WAAKA,mBAAL,CAAyB+B,oBAAzB,GAAgD,IAAhD;AACH;;AAED,QAAI,KAAKC,kBAAT,EAA6B;AACzB,WAAKA,kBAAL,CAAwBC,SAAxB,GAAoC,IAApC;;AACA,WAAKD,kBAAL,CAAwBE,0BAAxB;AACH;AACJ,GAzBM;;AA0BX;AAAC,CA3HD,CAAyCtC,iBAAzC","names":["MultiRenderTarget","ImageProcessingPostProcess","__extends","name","renderTargetTexture","size","count","scene","options","_super","_this","PrePassRenderTarget","imageProcessingPostProcess","undefined","_engine","_updateParameters","requiredWidth","getRenderWidth","requiredHeight","getRenderHeight","width","height","resize","_internalTextureDirty","textureNames","updateCount","call","_beforeCompositionPostProcesses","_scene","dispose","prePassRenderer","index","renderTargets","indexOf","splice","_prePassRenderTarget","_outputPostProcess","autoClear","restoreDefaultInputTexture"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/prePassRenderTarget.ts"],"sourcesContent":["import type { IMultiRenderTargetOptions } from \"./multiRenderTarget\";\r\nimport { MultiRenderTarget } from \"./multiRenderTarget\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { RenderTargetTexture } from \"./renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * A multi render target designed to render the prepass.\r\n * Prepass is a scene component used to render information in multiple textures\r\n * alongside with the scene materials rendering.\r\n * Note : This is an internal class, and you should NOT need to instanciate this.\r\n * Only the `PrePassRenderer` should instanciate this class.\r\n * It is more likely that you need a regular `MultiRenderTarget`\r\n * @hidden\r\n */\r\nexport class PrePassRenderTarget extends MultiRenderTarget {\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _beforeCompositionPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Image processing post process for composition\r\n     */\r\n    public imageProcessingPostProcess: ImageProcessingPostProcess;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _engine: Engine;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _scene: Scene;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _outputPostProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _internalTextureDirty = false;\r\n\r\n    /**\r\n     * Is this render target enabled for prepass rendering\r\n     */\r\n    public enabled: boolean = false;\r\n\r\n    /**\r\n     * Render target associated with this prePassRenderTarget\r\n     * If this is `null`, it means this prePassRenderTarget is associated with the scene\r\n     */\r\n    public renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n\r\n    public constructor(name: string, renderTargetTexture: Nullable<RenderTargetTexture>, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions | undefined) {\r\n        super(name, size, count, scene, options);\r\n\r\n        this.renderTargetTexture = renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a composition effect for this RT\r\n     * @hidden\r\n     */\r\n    public _createCompositionEffect() {\r\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\r\n        this.imageProcessingPostProcess._updateParameters();\r\n    }\r\n\r\n    /**\r\n     * Checks that the size of this RT is still adapted to the desired render size.\r\n     * @hidden\r\n     */\r\n    public _checkSize() {\r\n        const requiredWidth = this._engine.getRenderWidth(true);\r\n        const requiredHeight = this._engine.getRenderHeight(true);\r\n\r\n        const width = this.getRenderWidth();\r\n        const height = this.getRenderHeight();\r\n\r\n        if (width !== requiredWidth || height !== requiredHeight) {\r\n            this.resize({ width: requiredWidth, height: requiredHeight });\r\n\r\n            this._internalTextureDirty = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        super.updateCount(count, options, textureNames);\r\n        this._internalTextureDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the post processes chains applied to this RT.\r\n     * @hidden\r\n     */\r\n    public _resetPostProcessChain() {\r\n        this._beforeCompositionPostProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Diposes this render target\r\n     */\r\n    public dispose() {\r\n        const scene = this._scene;\r\n\r\n        super.dispose();\r\n\r\n        if (scene && scene.prePassRenderer) {\r\n            const index = scene.prePassRenderer.renderTargets.indexOf(this);\r\n\r\n            if (index !== -1) {\r\n                scene.prePassRenderer.renderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.imageProcessingPostProcess) {\r\n            this.imageProcessingPostProcess.dispose();\r\n        }\r\n\r\n        if (this.renderTargetTexture) {\r\n            this.renderTargetTexture._prePassRenderTarget = null;\r\n        }\r\n\r\n        if (this._outputPostProcess) {\r\n            this._outputPostProcess.autoClear = true;\r\n            this._outputPostProcess.restoreDefaultInputTexture();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}