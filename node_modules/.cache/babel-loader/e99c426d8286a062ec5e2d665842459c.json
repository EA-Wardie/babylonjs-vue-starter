{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { ThinEngine } from \"../../Engines/thinEngine.js\";\n/** @hidden */\n\nexport var ComputeBindingType;\n\n(function (ComputeBindingType) {\n  ComputeBindingType[ComputeBindingType[\"Texture\"] = 0] = \"Texture\";\n  ComputeBindingType[ComputeBindingType[\"StorageTexture\"] = 1] = \"StorageTexture\";\n  ComputeBindingType[ComputeBindingType[\"UniformBuffer\"] = 2] = \"UniformBuffer\";\n  ComputeBindingType[ComputeBindingType[\"StorageBuffer\"] = 3] = \"StorageBuffer\";\n  ComputeBindingType[ComputeBindingType[\"TextureWithoutSampler\"] = 4] = \"TextureWithoutSampler\";\n  ComputeBindingType[ComputeBindingType[\"Sampler\"] = 5] = \"Sampler\";\n})(ComputeBindingType || (ComputeBindingType = {}));\n\nThinEngine.prototype.createComputeEffect = function (baseName, options) {\n  throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\n};\n\nThinEngine.prototype.createComputePipelineContext = function () {\n  throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\n};\n\nThinEngine.prototype.createComputeContext = function () {\n  return undefined;\n};\n\nThinEngine.prototype.computeDispatch = function (effect, context, bindings, x, y, z, bindingsMapping) {\n  throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\n};\n\nThinEngine.prototype.areAllComputeEffectsReady = function () {\n  return true;\n};\n\nThinEngine.prototype.releaseComputeEffects = function () {};\n\nThinEngine.prototype._prepareComputePipelineContext = function (pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {};\n\nThinEngine.prototype._rebuildComputeEffects = function () {};\n\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext, action) {\n  action();\n};\n\nThinEngine.prototype._releaseComputeEffect = function (effect) {};\n\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext) {};","map":{"version":3,"mappings":";;AAIA,SAASA,UAAT,QAA2B,6BAA3B;AAeA;;AACA,WAAYC,kBAAZ;;AAAA,WAAYA,kBAAZ,EAA8B;AAC1BA;AACAA;AACAA;AACAA;AACAA;AACAA;AACH,CAPD,EAAYA,kBAAkB,KAAlBA,kBAAkB,MAA9B;;AAwFAD,UAAU,CAACE,SAAX,CAAqBC,mBAArB,GAA2C,UAAUC,QAAV,EAAyBC,OAAzB,EAA+D;AACtG,QAAM,IAAIC,KAAJ,CAAU,oEAAV,CAAN;AACH,CAFD;;AAIAN,UAAU,CAACE,SAAX,CAAqBK,4BAArB,GAAoD;AAChD,QAAM,IAAID,KAAJ,CAAU,6EAAV,CAAN;AACH,CAFD;;AAIAN,UAAU,CAACE,SAAX,CAAqBM,oBAArB,GAA4C;AACxC,SAAOC,SAAP;AACH,CAFD;;AAIAT,UAAU,CAACE,SAAX,CAAqBQ,eAArB,GAAuC,UACnCC,MADmC,EAEnCC,OAFmC,EAGnCC,QAHmC,EAInCC,CAJmC,EAKnCC,CALmC,EAMnCC,CANmC,EAOnCC,eAPmC,EAOI;AAEvC,QAAM,IAAIX,KAAJ,CAAU,gEAAV,CAAN;AACH,CAVD;;AAYAN,UAAU,CAACE,SAAX,CAAqBgB,yBAArB,GAAiD;AAC7C,SAAO,IAAP;AACH,CAFD;;AAIAlB,UAAU,CAACE,SAAX,CAAqBiB,qBAArB,GAA6C,aAAoB,CAAjE;;AAEAnB,UAAU,CAACE,SAAX,CAAqBkB,8BAArB,GAAsD,UAClDC,eADkD,EAElDC,iBAFkD,EAGlDC,oBAHkD,EAIlDC,OAJkD,EAKlDC,UALkD,EAKhC,CACZ,CANV;;AAQAzB,UAAU,CAACE,SAAX,CAAqBwB,sBAArB,GAA8C,aAAoB,CAAlE;;AAEA1B,UAAU,CAACE,SAAX,CAAqByB,kCAArB,GAA0D,UAAUN,eAAV,EAAoDO,MAApD,EAAsE;AAC5HA,QAAM;AACT,CAFD;;AAIA5B,UAAU,CAACE,SAAX,CAAqB2B,qBAArB,GAA6C,UAAUlB,MAAV,EAA+B,CAAU,CAAtF;;AAEAX,UAAU,CAACE,SAAX,CAAqB4B,6BAArB,GAAqD,UAAUT,eAAV,EAAkD,CAAU,CAAjH","names":["ThinEngine","ComputeBindingType","prototype","createComputeEffect","baseName","options","Error","createComputePipelineContext","createComputeContext","undefined","computeDispatch","effect","context","bindings","x","y","z","bindingsMapping","areAllComputeEffectsReady","releaseComputeEffects","_prepareComputePipelineContext","pipelineContext","computeSourceCode","rawComputeSourceCode","defines","entryPoint","_rebuildComputeEffects","_executeWhenComputeStateIsCompiled","action","_releaseComputeEffect","_deleteComputePipelineContext"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.computeShader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Type used to locate a resource in a compute shader.\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingLocation = { group: number; binding: number };\r\n\r\n/**\r\n * Type used to lookup a resource and retrieve its binding location\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingMapping = { [key: string]: ComputeBindingLocation };\r\n\r\n/** @hidden */\r\nexport enum ComputeBindingType {\r\n    Texture = 0,\r\n    StorageTexture = 1,\r\n    UniformBuffer = 2,\r\n    StorageBuffer = 3,\r\n    TextureWithoutSampler = 4,\r\n    Sampler = 5,\r\n}\r\n\r\n/** @hidden */\r\nexport type ComputeBindingList = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number } };\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new compute effect\r\n         * @param baseName Name of the effect\r\n         * @param options Options used to create the effect\r\n         * @returns The new compute effect\r\n         */\r\n        createComputeEffect(baseName: any, options: IComputeEffectCreationOptions): ComputeEffect;\r\n\r\n        /**\r\n         * Creates a new compute pipeline context\r\n         * @returns the new pipeline\r\n         */\r\n        createComputePipelineContext(): IComputePipelineContext;\r\n\r\n        /**\r\n         * Creates a new compute context\r\n         * @returns the new context\r\n         */\r\n        createComputeContext(): IComputeContext | undefined;\r\n\r\n        /**\r\n         * Dispatches a compute shader\r\n         * @param effect The compute effect\r\n         * @param context The compute context\r\n         * @param bindings The list of resources to bind to the shader\r\n         * @param x The number of workgroups to execute on the X dimension\r\n         * @param y The number of workgroups to execute on the Y dimension\r\n         * @param z The number of workgroups to execute on the Z dimension\r\n         * @param bindingsMapping list of bindings mapping (key is property name, value is binding location)\r\n         */\r\n        computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x: number,\r\n            y?: number,\r\n            z?: number,\r\n            bindingsMapping?: ComputeBindingMapping\r\n        ): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if all created compute effects are ready\r\n         * @returns true if all effects are ready\r\n         */\r\n        areAllComputeEffectsReady(): boolean;\r\n\r\n        /**\r\n         * Forces the engine to release all cached compute effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n         */\r\n        releaseComputeEffects(): void;\r\n\r\n        /** @hidden */\r\n        _prepareComputePipelineContext(\r\n            pipelineContext: IComputePipelineContext,\r\n            computeSourceCode: string,\r\n            rawComputeSourceCode: string,\r\n            defines: Nullable<string>,\r\n            entryPoint: string\r\n        ): void;\r\n\r\n        /** @hidden */\r\n        _rebuildComputeEffects(): void;\r\n\r\n        /** @hidden */\r\n        _executeWhenComputeStateIsCompiled(pipelineContext: IComputePipelineContext, action: () => void): void;\r\n\r\n        /** @hidden */\r\n        _releaseComputeEffect(effect: ComputeEffect): void;\r\n\r\n        /** @hidden */\r\n        _deleteComputePipelineContext(pipelineContext: IComputePipelineContext): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return undefined;\r\n};\r\n\r\nThinEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    return true;\r\n};\r\n\r\nThinEngine.prototype.releaseComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {};\r\n\r\nThinEngine.prototype._rebuildComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext: IComputePipelineContext, action: () => void): void {\r\n    action();\r\n};\r\n\r\nThinEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {};\r\n\r\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {};\r\n"]},"metadata":{},"sourceType":"module"}