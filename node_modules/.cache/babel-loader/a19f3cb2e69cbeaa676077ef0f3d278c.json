{"ast":null,"code":"import \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport { __extends } from \"tslib\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nvar builtInName_vertex_index = \"gl_VertexID\";\nvar builtInName_instance_index = \"gl_InstanceID\";\nvar builtInName_position = \"gl_Position\";\nvar builtInName_position_frag = \"gl_FragCoord\";\nvar builtInName_front_facing = \"gl_FrontFacing\";\nvar builtInName_frag_depth = \"gl_FragDepth\";\nvar builtInName_FragColor = \"gl_FragColor\";\nvar leftOverVarName = \"uniforms\";\nvar internalsVarName = \"internals\";\nvar gpuTextureViewDimensionByWebGPUTextureFunction = {\n  texture_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_external: null\n};\n/** @hidden */\n\nvar WebGPUShaderProcessorWGSL =\n/** @class */\nfunction (_super) {\n  __extends(WebGPUShaderProcessorWGSL, _super);\n\n  function WebGPUShaderProcessorWGSL() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.shaderLanguage = ShaderLanguage.WGSL;\n    _this.uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\n    _this.textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\n    _this.noPrecision = true;\n    return _this;\n  }\n\n  WebGPUShaderProcessorWGSL.prototype._getArraySize = function (name, uniformType, preProcessors) {\n    var length = 0;\n    var endArray = uniformType.lastIndexOf(\">\");\n\n    if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\n      var startArray = endArray;\n\n      while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\n        startArray--;\n      }\n\n      var lengthInString = uniformType.substring(startArray + 1, endArray);\n      length = +lengthInString;\n\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n\n      while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\n        startArray--;\n      }\n\n      uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\n    }\n\n    return [name, uniformType, length];\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.initializeShaders = function (processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._attributesWGSL = [];\n    this._attributesDeclWGSL = [];\n    this._attributeNamesWGSL = [];\n    this._varyingsWGSL = [];\n    this._varyingsDeclWGSL = [];\n    this._varyingNamesWGSL = [];\n    this._stridedUniformArrays = [];\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.preProcessShaderCode = function (code) {\n    return \"struct \".concat(WebGPUShaderProcessor.InternalsUBOName, \" {\\nyFactor__: f32,\\ntextureOutputHeight__: f32,\\n};\\nvar<uniform> \").concat(internalsVarName, \" : \").concat(WebGPUShaderProcessor.InternalsUBOName, \";\\n\") + RemoveComments(code);\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.varyingProcessor = function (varying, isFragment, preProcessors) {\n    var varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    var match = varyingRegex.exec(varying);\n\n    if (match !== null) {\n      var varyingType = match[2];\n      var name_1 = match[1];\n      var location_1;\n\n      if (isFragment) {\n        location_1 = this._webgpuProcessingContext.availableVaryings[name_1];\n\n        if (location_1 === undefined) {\n          Logger.Warn(\"Invalid fragment shader: The varying named \\\"\".concat(name_1, \"\\\" is not declared in the vertex shader! This declaration will be ignored.\"));\n        }\n      } else {\n        location_1 = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name_1, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name_1] = location_1;\n\n        this._varyingsWGSL.push(\"@location(\".concat(location_1, \") \").concat(name_1, \" : \").concat(varyingType, \",\"));\n\n        this._varyingsDeclWGSL.push(\"var<private> \".concat(name_1, \" : \").concat(varyingType, \";\"));\n\n        this._varyingNamesWGSL.push(name_1);\n      }\n\n      varying = \"\";\n    }\n\n    return varying;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.attributeProcessor = function (attribute, preProcessors) {\n    var attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    var match = attribRegex.exec(attribute);\n\n    if (match !== null) {\n      var attributeType = match[2];\n      var name_2 = match[1];\n\n      var location_2 = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name_2, attributeType, preProcessors)[2]);\n\n      this._webgpuProcessingContext.availableAttributes[name_2] = location_2;\n      this._webgpuProcessingContext.orderedAttributes[location_2] = name_2;\n\n      this._attributesWGSL.push(\"@location(\".concat(location_2, \") \").concat(name_2, \" : \").concat(attributeType, \",\"));\n\n      this._attributesDeclWGSL.push(\"var<private> \".concat(name_2, \" : \").concat(attributeType, \";\"));\n\n      this._attributeNamesWGSL.push(name_2);\n\n      attribute = \"\";\n    }\n\n    return attribute;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.uniformProcessor = function (uniform, isFragment, preProcessors) {\n    var match = this.uniformRegexp.exec(uniform);\n\n    if (match !== null) {\n      var uniformType = match[2];\n      var name_3 = match[1];\n\n      this._addUniformToLeftOverUBO(name_3, uniformType, preProcessors);\n\n      uniform = \"\";\n    }\n\n    return uniform;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.textureProcessor = function (texture, isFragment, preProcessors) {\n    var match = this.textureRegexp.exec(texture);\n\n    if (match !== null) {\n      var name_4 = match[1]; // name of the variable\n\n      var type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\n\n      var isArrayOfTexture = !!match[3];\n      var textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\n\n      var isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\n      var componentType = match[6]; // f32 or i32 or u32 or undefined\n\n      var storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(\",\")).trim() : null;\n      var arraySize = isArrayOfTexture ? this._getArraySize(name_4, type, preProcessors)[2] : 0;\n      var textureInfo = this._webgpuProcessingContext.availableTextures[name_4];\n\n      if (!textureInfo) {\n        textureInfo = {\n          isTextureArray: arraySize > 0,\n          isStorageTexture: isStorageTexture,\n          textures: [],\n          sampleType: WebGPUConstants.TextureSampleType.Float\n        };\n        arraySize = arraySize || 1;\n\n        for (var i = 0; i < arraySize; ++i) {\n          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n        }\n      } else {\n        arraySize = textureInfo.textures.length;\n      }\n\n      this._webgpuProcessingContext.availableTextures[name_4] = textureInfo;\n      var isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\n      var textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\n      var sampleType = isDepthTexture ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u32\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i32\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n      textureInfo.sampleType = sampleType;\n\n      if (textureDimension === undefined) {\n        throw \"Can't get the texture dimension corresponding to the texture function \\\"\".concat(textureFunc, \"\\\"!\");\n      }\n\n      for (var i = 0; i < arraySize; ++i) {\n        var _a = textureInfo.textures[i],\n            groupIndex = _a.groupIndex,\n            bindingIndex = _a.bindingIndex;\n\n        if (i === 0) {\n          texture = \"@group(\".concat(groupIndex, \") @binding(\").concat(bindingIndex, \") \").concat(texture);\n        }\n\n        this._addTextureBindingDescription(name_4, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\n      }\n    }\n\n    return texture;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.postProcessor = function (code) {\n    return code;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype.finalizeShaders = function (vertexCode, fragmentCode) {\n    var fragCoordCode = fragmentCode.indexOf(\"gl_FragCoord\") >= 0 ? \"\\n            if (internals.yFactor__ == 1.) {\\n                gl_FragCoord.y = internals.textureOutputHeight__ - gl_FragCoord.y;\\n            }\\n        \" : \"\"; // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\n\n    vertexCode = this._processSamplers(vertexCode, true);\n    fragmentCode = this._processSamplers(fragmentCode, false); // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\n\n    vertexCode = this._processCustomBuffers(vertexCode, true);\n    fragmentCode = this._processCustomBuffers(fragmentCode, false); // Builds the leftover UBOs.\n\n    var leftOverUBO = this._buildLeftOverUBO();\n\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode; // Vertex code\n\n    vertexCode = vertexCode.replace(/#define /g, \"//#define \");\n    vertexCode = this._processStridedUniformArrays(vertexCode);\n    var varyingsDecl = this._varyingsDeclWGSL.join(\"\\n\") + \"\\n\";\n    var vertexBuiltinDecl = \"var<private> \".concat(builtInName_vertex_index, \" : u32;\\nvar<private> \").concat(builtInName_instance_index, \" : u32;\\nvar<private> \").concat(builtInName_position, \" : vec4<f32>;\\n\");\n    var vertexAttributesDecl = this._attributesDeclWGSL.join(\"\\n\") + \"\\n\";\n    var vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\n\n    if (this._attributesWGSL.length > 0) {\n      vertexInputs += this._attributesWGSL.join(\"\\n\");\n    }\n\n    vertexInputs += \"\\n};\\n\";\n    var vertexFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\n\n    if (this._varyingsWGSL.length > 0) {\n      vertexFragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n\n    vertexFragmentInputs += \"\\n};\\n\";\n    vertexCode = vertexBuiltinDecl + vertexInputs + vertexAttributesDecl + vertexFragmentInputs + varyingsDecl + vertexCode;\n    var vertexStartingCode = \"  var output : FragmentInputs;\\n  \".concat(builtInName_vertex_index, \" = input.vertexIndex;\\n  \").concat(builtInName_instance_index, \" = input.instanceIndex;\\n\");\n\n    for (var i = 0; i < this._attributeNamesWGSL.length; ++i) {\n      var name_5 = this._attributeNamesWGSL[i];\n      vertexStartingCode += \"  \".concat(name_5, \" = input.\").concat(name_5, \";\\n\");\n    }\n\n    var vertexEndingCode = \"  output.position = \".concat(builtInName_position, \";\\n  output.position.y = output.position.y * internals.yFactor__;\\n\");\n\n    for (var i = 0; i < this._varyingNamesWGSL.length; ++i) {\n      var name_6 = this._varyingNamesWGSL[i];\n      vertexEndingCode += \"  output.\".concat(name_6, \" = \").concat(name_6, \";\\n\");\n    }\n\n    vertexEndingCode += \"  return output;\";\n    vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexStartingCode, vertexEndingCode); // fragment code\n\n    fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\n    fragmentCode = this._processStridedUniformArrays(fragmentCode);\n    fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor__)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\n\n    var fragmentBuiltinDecl = \"var<private> \".concat(builtInName_position_frag, \" : vec4<f32>;\\nvar<private> \").concat(builtInName_front_facing, \" : bool;\\nvar<private> \").concat(builtInName_FragColor, \" : vec4<f32>;\\nvar<private> \").concat(builtInName_frag_depth, \" : f32;\\n\");\n    var fragmentFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\n\n    if (this._varyingsWGSL.length > 0) {\n      fragmentFragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n\n    fragmentFragmentInputs += \"\\n};\\n\";\n    var fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\n    var hasFragDepth = false;\n    var idx = 0;\n\n    while (!hasFragDepth) {\n      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\n\n      if (idx < 0) {\n        break;\n      }\n\n      var saveIndex = idx;\n      hasFragDepth = true;\n\n      while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\n        if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\n          hasFragDepth = false;\n          break;\n        }\n\n        idx--;\n      }\n\n      idx = saveIndex + builtInName_frag_depth.length;\n    }\n\n    if (hasFragDepth) {\n      fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32;\\n\";\n    }\n\n    fragmentOutputs += \"};\\n\";\n    fragmentCode = fragmentBuiltinDecl + fragmentFragmentInputs + varyingsDecl + fragmentOutputs + fragmentCode;\n    var fragmentStartingCode = \"  var output : FragmentOutputs;\\n  \".concat(builtInName_position_frag, \" = input.position;\\n  \").concat(builtInName_front_facing, \" = input.frontFacing;\\n\") + fragCoordCode;\n\n    for (var i = 0; i < this._varyingNamesWGSL.length; ++i) {\n      var name_7 = this._varyingNamesWGSL[i];\n      fragmentStartingCode += \"  \".concat(name_7, \" = input.\").concat(name_7, \";\\n\");\n    }\n\n    var fragmentEndingCode = \"  output.color = \".concat(builtInName_FragColor, \";\\n\");\n\n    if (hasFragDepth) {\n      fragmentEndingCode += \"  output.fragDepth = \".concat(builtInName_frag_depth, \";\\n\");\n    }\n\n    fragmentEndingCode += \"  return output;\";\n    fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\n\n    this._collectBindingNames();\n\n    this._preCreateBindGroupEntries();\n\n    return {\n      vertexCode: vertexCode,\n      fragmentCode: fragmentCode\n    };\n  };\n\n  WebGPUShaderProcessorWGSL.prototype._generateLeftOverUBOCode = function (name, uniformBufferDescription) {\n    var stridedArrays = \"\";\n    var ubo = \"struct \".concat(name, \" {\\n\");\n\n    for (var _i = 0, _a = this._webgpuProcessingContext.leftOverUniforms; _i < _a.length; _i++) {\n      var leftOverUniform = _a[_i];\n      var type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\n      var size = WebGPUShaderProcessor.UniformSizes[type];\n\n      if (leftOverUniform.length > 0) {\n        if (size <= 2) {\n          var stridedArrayType = \"\".concat(name, \"_\").concat(this._stridedUniformArrays.length, \"_strided_arr\");\n          stridedArrays += \"struct \".concat(stridedArrayType, \" {\\n                        @size(16)\\n                        el: \").concat(type, \",\\n                    }\");\n\n          this._stridedUniformArrays.push(leftOverUniform.name);\n\n          ubo += \" @align(16) \".concat(leftOverUniform.name, \" : array<\").concat(stridedArrayType, \", \").concat(leftOverUniform.length, \">,\\n\");\n        } else {\n          ubo += \" \".concat(leftOverUniform.name, \" : array<\").concat(leftOverUniform.type, \", \").concat(leftOverUniform.length, \">,\\n\");\n        }\n      } else {\n        ubo += \"  \".concat(leftOverUniform.name, \" : \").concat(leftOverUniform.type, \",\\n\");\n      }\n    }\n\n    ubo += \"};\\n\";\n    ubo = \"\".concat(stridedArrays, \"\\n\").concat(ubo);\n    ubo += \"@group(\".concat(uniformBufferDescription.binding.groupIndex, \") @binding(\").concat(uniformBufferDescription.binding.bindingIndex, \") var<uniform> \").concat(leftOverVarName, \" : \").concat(name, \";\\n\");\n    return ubo;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype._processSamplers = function (code, isVertex) {\n    var samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      var match = samplerRegexp.exec(code);\n\n      if (match === null) {\n        break;\n      }\n\n      var name_8 = match[1]; // name of the variable\n\n      var samplerType = match[2]; // sampler or sampler_comparison\n\n      var textureName = name_8.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name_8.length - WebGPUShaderProcessor.AutoSamplerSuffix.length ? name_8.substring(0, name_8.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix)) : null;\n      var samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n\n      if (textureName) {\n        var textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\n\n        if (textureInfo) {\n          textureInfo.autoBindSampler = true;\n        }\n      }\n\n      var samplerInfo = this._webgpuProcessingContext.availableSamplers[name_8];\n\n      if (!samplerInfo) {\n        samplerInfo = {\n          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n          type: samplerBindingType\n        };\n        this._webgpuProcessingContext.availableSamplers[name_8] = samplerInfo;\n      }\n\n      this._addSamplerBindingDescription(name_8, samplerInfo, isVertex);\n\n      var part1 = code.substring(0, match.index);\n      var insertPart = \"@group(\".concat(samplerInfo.binding.groupIndex, \") @binding(\").concat(samplerInfo.binding.bindingIndex, \") \");\n      var part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      samplerRegexp.lastIndex += insertPart.length;\n    }\n\n    return code;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype._processCustomBuffers = function (code, isVertex) {\n    var instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      var match = instantiateBufferRegexp.exec(code);\n\n      if (match === null) {\n        break;\n      }\n\n      var type = match[1];\n      var decoration = match[3];\n      var name_9 = match[4];\n      var structName = match[5];\n      var bufferInfo = this._webgpuProcessingContext.availableBuffers[name_9];\n\n      if (!bufferInfo) {\n        var knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\n        var binding = void 0;\n\n        if (knownUBO) {\n          name_9 = structName;\n          binding = knownUBO.binding;\n\n          if (binding.groupIndex === -1) {\n            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n          }\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n\n        bufferInfo = {\n          binding: binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name_9] = bufferInfo;\n      }\n\n      this._addBufferBindingDescription(name_9, this._webgpuProcessingContext.availableBuffers[name_9], decoration === \"read_write\" ? WebGPUConstants.BufferBindingType.Storage : type === \"storage\" ? WebGPUConstants.BufferBindingType.ReadOnlyStorage : WebGPUConstants.BufferBindingType.Uniform, isVertex);\n\n      var groupIndex = bufferInfo.binding.groupIndex;\n      var bindingIndex = bufferInfo.binding.bindingIndex;\n      var part1 = code.substring(0, match.index);\n      var insertPart = \"@group(\".concat(groupIndex, \") @binding(\").concat(bindingIndex, \") \");\n      var part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      instantiateBufferRegexp.lastIndex += insertPart.length;\n    }\n\n    return code;\n  };\n\n  WebGPUShaderProcessorWGSL.prototype._processStridedUniformArrays = function (code) {\n    for (var _i = 0, _a = this._stridedUniformArrays; _i < _a.length; _i++) {\n      var uniformArrayName = _a[_i];\n      code = code.replace(new RegExp(\"\".concat(uniformArrayName, \"\\\\s*\\\\[(.*)\\\\]\"), \"g\"), \"\".concat(uniformArrayName, \"[$1].el\"));\n    }\n\n    return code;\n  };\n\n  return WebGPUShaderProcessorWGSL;\n}(WebGPUShaderProcessor);\n\nexport { WebGPUShaderProcessorWGSL };","map":{"version":3,"mappings":"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","names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","RemoveComments","ShaderLanguage","builtInName_vertex_index","builtInName_instance_index","builtInName_position","builtInName_position_frag","builtInName_front_facing","builtInName_frag_depth","builtInName_FragColor","leftOverVarName","internalsVarName","gpuTextureViewDimensionByWebGPUTextureFunction","texture_1d","TextureViewDimension","E1d","texture_2d","E2d","texture_2d_array","E2dArray","texture_3d","E3d","texture_cube","Cube","texture_cube_array","CubeArray","texture_multisampled_2d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_external","__extends","_this","WGSL","WebGPUShaderProcessorWGSL","name","uniformType","preProcessors","length","endArray","lastIndexOf","indexOf","startArray","charAt","lengthInString","substring","isNaN","trim","processingContext","_webgpuProcessingContext","_attributesWGSL","_attributesDeclWGSL","_attributeNamesWGSL","_varyingsWGSL","_varyingsDeclWGSL","_varyingNamesWGSL","_stridedUniformArrays","code","InternalsUBOName","concat","varying","isFragment","varyingRegex","match","exec","varyingType","name_1","location_1","availableVaryings","undefined","Warn","getVaryingNextLocation","_getArraySize","push","attribute","attribRegex","attributeType","name_2","location_2","getAttributeNextLocation","availableAttributes","orderedAttributes","uniform","uniformRegexp","name_3","_addUniformToLeftOverUBO","texture","textureRegexp","name_4","type","isArrayOfTexture","textureFunc","isStorageTexture","componentType","storageTextureFormat","arraySize","textureInfo","availableTextures","isTextureArray","textures","sampleType","TextureSampleType","Float","i","getNextFreeUBOBinding","isDepthTexture","textureDimension","Depth","Uint","Sint","groupIndex","bindingIndex","_addTextureBindingDescription","vertexCode","fragmentCode","fragCoordCode","_processSamplers","_processCustomBuffers","leftOverUBO","_buildLeftOverUBO","replace","_processStridedUniformArrays","varyingsDecl","join","vertexBuiltinDecl","vertexAttributesDecl","vertexInputs","vertexFragmentInputs","vertexStartingCode","name_5","vertexEndingCode","name_6","_injectStartingAndEndingCode","fragmentBuiltinDecl","fragmentFragmentInputs","fragmentOutputs","hasFragDepth","idx","saveIndex","fragmentStartingCode","name_7","fragmentEndingCode","_collectBindingNames","_preCreateBindGroupEntries","uniformBufferDescription","stridedArrays","ubo","leftOverUniforms","_i","leftOverUniform","size","UniformSizes","stridedArrayType","binding","isVertex","samplerRegexp","name_8","samplerType","textureName","AutoSamplerSuffix","samplerBindingType","SamplerBindingType","Comparison","Filtering","autoBindSampler","samplerInfo","availableSamplers","_addSamplerBindingDescription","part1","index","insertPart","part2","lastIndex","instantiateBufferRegexp","decoration","name_9","structName","bufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Storage","ReadOnlyStorage","Uniform","uniformArrayName","RegExp"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nconst builtInName_vertex_index = \"gl_VertexID\";\r\nconst builtInName_instance_index = \"gl_InstanceID\";\r\nconst builtInName_position = \"gl_Position\";\r\n\r\nconst builtInName_position_frag = \"gl_FragCoord\";\r\nconst builtInName_front_facing = \"gl_FrontFacing\";\r\nconst builtInName_frag_depth = \"gl_FragDepth\";\r\nconst builtInName_FragColor = \"gl_FragColor\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @hidden */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesDeclWGSL: string[];\r\n    protected _attributeNamesWGSL: string[];\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingsDeclWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesWGSL = [];\r\n        this._attributesDeclWGSL = [];\r\n        this._attributeNamesWGSL = [];\r\n        this._varyingsWGSL = [];\r\n        this._varyingsDeclWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        return (\r\n            `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\nyFactor__: f32,\\ntextureOutputHeight__: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n` +\r\n            RemoveComments(code)\r\n        );\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const varyingType = match[2];\r\n            const name = match[1];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`@location(${location}) ${name} : ${varyingType},`);\r\n                this._varyingsDeclWGSL.push(`var<private> ${name} : ${varyingType};`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            this._attributesWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n            this._attributesDeclWGSL.push(`var<private> ${name} : ${attributeType};`);\r\n            this._attributeNamesWGSL.push(name);\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                ? WebGPUConstants.TextureSampleType.Uint\r\n                : componentType === \"i32\"\r\n                ? WebGPUConstants.TextureSampleType.Sint\r\n                : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    public postProcessor(code: string) {\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"gl_FragCoord\") >= 0\r\n                ? `\r\n            if (internals.yFactor__ == 1.) {\r\n                gl_FragCoord.y = internals.textureOutputHeight__ - gl_FragCoord.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        const varyingsDecl = this._varyingsDeclWGSL.join(\"\\n\") + \"\\n\";\r\n\r\n        const vertexBuiltinDecl = `var<private> ${builtInName_vertex_index} : u32;\\nvar<private> ${builtInName_instance_index} : u32;\\nvar<private> ${builtInName_position} : vec4<f32>;\\n`;\r\n\r\n        const vertexAttributesDecl = this._attributesDeclWGSL.join(\"\\n\") + \"\\n\";\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesWGSL.length > 0) {\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\n\";\r\n\r\n        let vertexFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexFragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexFragmentInputs += \"\\n};\\n\";\r\n\r\n        vertexCode = vertexBuiltinDecl + vertexInputs + vertexAttributesDecl + vertexFragmentInputs + varyingsDecl + vertexCode;\r\n\r\n        let vertexStartingCode = `  var output : FragmentInputs;\\n  ${builtInName_vertex_index} = input.vertexIndex;\\n  ${builtInName_instance_index} = input.instanceIndex;\\n`;\r\n\r\n        for (let i = 0; i < this._attributeNamesWGSL.length; ++i) {\r\n            const name = this._attributeNamesWGSL[i];\r\n            vertexStartingCode += `  ${name} = input.${name};\\n`;\r\n        }\r\n\r\n        let vertexEndingCode = `  output.position = ${builtInName_position};\\n  output.position.y = output.position.y * internals.yFactor__;\\n`;\r\n\r\n        for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\r\n            const name = this._varyingNamesWGSL[i];\r\n            vertexEndingCode += `  output.${name} = ${name};\\n`;\r\n        }\r\n\r\n        vertexEndingCode += \"  return output;\";\r\n\r\n        vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexStartingCode, vertexEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor__)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n\r\n        const fragmentBuiltinDecl = `var<private> ${builtInName_position_frag} : vec4<f32>;\\nvar<private> ${builtInName_front_facing} : bool;\\nvar<private> ${builtInName_FragColor} : vec4<f32>;\\nvar<private> ${builtInName_frag_depth} : f32;\\n`;\r\n\r\n        let fragmentFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentFragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentFragmentInputs += \"\\n};\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\r\n\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32;\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\n\";\r\n\r\n        fragmentCode = fragmentBuiltinDecl + fragmentFragmentInputs + varyingsDecl + fragmentOutputs + fragmentCode;\r\n\r\n        let fragmentStartingCode =\r\n            `  var output : FragmentOutputs;\\n  ${builtInName_position_frag} = input.position;\\n  ${builtInName_front_facing} = input.frontFacing;\\n` + fragCoordCode;\r\n\r\n        for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\r\n            const name = this._varyingNamesWGSL[i];\r\n            fragmentStartingCode += `  ${name} = input.${name};\\n`;\r\n        }\r\n\r\n        let fragmentEndingCode = `  output.color = ${builtInName_FragColor};\\n`;\r\n\r\n        if (hasFragDepth) {\r\n            fragmentEndingCode += `  output.fragDepth = ${builtInName_frag_depth};\\n`;\r\n        }\r\n\r\n        fragmentEndingCode += \"  return output;\";\r\n\r\n        fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const textureName =\r\n                name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length\r\n                    ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix))\r\n                    : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                    ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                    : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}