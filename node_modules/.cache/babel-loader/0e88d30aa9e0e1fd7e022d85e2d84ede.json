{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * Particle emitter emitting particles from the inside of a box.\n * It emits the particles randomly between 2 given directions.\n */\n\nvar MeshParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance MeshParticleEmitter\n   * @param mesh defines the mesh to use as source\n   */\n  function MeshParticleEmitter(mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    this._indices = null;\n    this._positions = null;\n    this._normals = null;\n    this._storedNormal = Vector3.Zero();\n    this._mesh = null;\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n\n    this.direction1 = new Vector3(0, 1.0, 0);\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n\n    this.direction2 = new Vector3(0, 1.0, 0);\n    /**\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\n     */\n\n    this.useMeshNormalsForDirection = true;\n    this.mesh = mesh;\n  }\n\n  Object.defineProperty(MeshParticleEmitter.prototype, \"mesh\", {\n    /** Defines the mesh to use as source */\n    get: function get() {\n      return this._mesh;\n    },\n    set: function set(value) {\n      if (this._mesh === value) {\n        return;\n      }\n\n      this._mesh = value;\n\n      if (value) {\n        this._indices = value.getIndices();\n        this._positions = value.getVerticesData(VertexBuffer.PositionKind);\n        this._normals = value.getVerticesData(VertexBuffer.NormalKind);\n      } else {\n        this._indices = null;\n        this._positions = null;\n        this._normals = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n  MeshParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\n      return;\n    }\n\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  MeshParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    if (!this._indices || !this._positions) {\n      return;\n    }\n\n    var randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;\n    var bu = Math.random();\n    var bv = Math.random() * (1.0 - bu);\n    var bw = 1.0 - bu - bv;\n    var faceIndexA = this._indices[randomFaceIndex];\n    var faceIndexB = this._indices[randomFaceIndex + 1];\n    var faceIndexC = this._indices[randomFaceIndex + 2];\n    var vertexA = TmpVectors.Vector3[0];\n    var vertexB = TmpVectors.Vector3[1];\n    var vertexC = TmpVectors.Vector3[2];\n    var randomVertex = TmpVectors.Vector3[3];\n    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\n    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\n    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\n    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\n    } else {\n      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\n    }\n\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\n      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\n      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\n      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n    }\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  MeshParticleEmitter.prototype.clone = function () {\n    var newOne = new MeshParticleEmitter(this.mesh);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  MeshParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  MeshParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  MeshParticleEmitter.prototype.getEffectDefines = function () {\n    return \"\";\n  };\n  /**\n   * Returns the string \"BoxParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  MeshParticleEmitter.prototype.getClassName = function () {\n    return \"MeshParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  MeshParticleEmitter.prototype.serialize = function () {\n    var _a;\n\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    serializationObject.meshId = (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.id;\n    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   * @param scene defines the hosting scene\n   */\n\n\n  MeshParticleEmitter.prototype.parse = function (serializationObject, scene) {\n    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n\n    if (serializationObject.meshId && scene) {\n      this.mesh = scene.getLastMeshById(serializationObject.meshId);\n    }\n\n    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\n  };\n\n  return MeshParticleEmitter;\n}();\n\nexport { MeshParticleEmitter };","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","TmpVectors","Scalar","VertexBuffer","mesh","Zero","Object","MeshParticleEmitter","_mesh","value","_indices","getIndices","_positions","getVerticesData","PositionKind","_normals","NormalKind","worldMatrix","directionToUpdate","particle","isLocal","useMeshNormalsForDirection","TransformNormalToRef","_storedNormal","randX","RandomRange","direction1","x","direction2","randY","y","randZ","z","copyFromFloats","TransformNormalFromFloatsToRef","positionToUpdate","randomFaceIndex","Math","random","length","bu","bv","bw","faceIndexA","faceIndexB","faceIndexC","vertexA","vertexB","vertexC","randomVertex","FromArrayToRef","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setVector3","ubo","addUniform","serializationObject","type","getClassName","asArray","meshId","_a","id","scene","getLastMeshById"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/meshParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { IndicesArray, Nullable, FloatArray } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class MeshParticleEmitter implements IParticleEmitterType {\r\n    private _indices: Nullable<IndicesArray> = null;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _storedNormal = Vector3.Zero();\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\r\n     */\r\n    public useMeshNormalsForDirection = true;\r\n\r\n    /** Defines the mesh to use as source */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<AbstractMesh>) {\r\n        if (this._mesh === value) {\r\n            return;\r\n        }\r\n\r\n        this._mesh = value;\r\n\r\n        if (value) {\r\n            this._indices = value.getIndices();\r\n            this._positions = value.getVerticesData(VertexBuffer.PositionKind);\r\n            this._normals = value.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            this._indices = null;\r\n            this._positions = null;\r\n            this._normals = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MeshParticleEmitter\r\n     * @param mesh defines the mesh to use as source\r\n     */\r\n    constructor(mesh: Nullable<AbstractMesh> = null) {\r\n        this.mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\r\n            return;\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (!this._indices || !this._positions) {\r\n            return;\r\n        }\r\n\r\n        const randomFaceIndex = (3 * Math.random() * (this._indices.length / 3)) | 0;\r\n        const bu = Math.random();\r\n        const bv = Math.random() * (1.0 - bu);\r\n        const bw = 1.0 - bu - bv;\r\n\r\n        const faceIndexA = this._indices[randomFaceIndex];\r\n        const faceIndexB = this._indices[randomFaceIndex + 1];\r\n        const faceIndexC = this._indices[randomFaceIndex + 2];\r\n        const vertexA = TmpVectors.Vector3[0];\r\n        const vertexB = TmpVectors.Vector3[1];\r\n        const vertexC = TmpVectors.Vector3[2];\r\n        const randomVertex = TmpVectors.Vector3[3];\r\n\r\n        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\r\n\r\n        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\r\n        } else {\r\n            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\r\n        }\r\n\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\r\n\r\n            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): MeshParticleEmitter {\r\n        const newOne = new MeshParticleEmitter(this.mesh);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.meshId = this.mesh?.id;\r\n        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public parse(serializationObject: any, scene: Nullable<Scene>): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n\r\n        if (serializationObject.meshId && scene) {\r\n            this.mesh = scene.getLastMeshById(serializationObject.meshId);\r\n        }\r\n\r\n        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}