{"ast":null,"code":"import \"core-js/modules/es.array.is-array.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\nimport { EndsWith } from \"../../../Misc/stringTools.js\";\n/**\n * Loader for .basis file format\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _BasisTextureLoader =\n/** @class */\nfunction () {\n  function _BasisTextureLoader() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = false;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n\n\n  _BasisTextureLoader.prototype.canLoad = function (extension) {\n    return EndsWith(extension, \".basis\");\n  };\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   * @param onError defines the callback to trigger in case of error\n   */\n\n\n  _BasisTextureLoader.prototype.loadCubeData = function (data, texture, createPolynomials, onLoad, onError) {\n    if (Array.isArray(data)) {\n      return;\n    }\n\n    var caps = texture.getEngine().getCaps();\n    var transcodeConfig = {\n      supportedCompressionFormats: {\n        etc1: caps.etc1 ? true : false,\n        s3tc: caps.s3tc ? true : false,\n        pvrtc: caps.pvrtc ? true : false,\n        etc2: caps.etc2 ? true : false\n      }\n    };\n    TranscodeAsync(data, transcodeConfig).then(function (result) {\n      var hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n      LoadTextureFromTranscodeResult(texture, result);\n\n      texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\n\n      texture.isReady = true;\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n\n      if (onLoad) {\n        onLoad();\n      }\n    })[\"catch\"](function (err) {\n      var errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\n      Tools.Warn(errorMessage);\n      texture.isReady = true;\n\n      if (onError) {\n        onError(err);\n      }\n    });\n  };\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param callback defines the method to call once ready to upload\n   */\n\n\n  _BasisTextureLoader.prototype.loadData = function (data, texture, callback) {\n    var caps = texture.getEngine().getCaps();\n    var transcodeConfig = {\n      supportedCompressionFormats: {\n        etc1: caps.etc1 ? true : false,\n        s3tc: caps.s3tc ? true : false,\n        pvrtc: caps.pvrtc ? true : false,\n        etc2: caps.etc2 ? true : false\n      }\n    };\n    TranscodeAsync(data, transcodeConfig).then(function (result) {\n      var rootImage = result.fileInfo.images[0].levels[0];\n      var hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n      callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, function () {\n        LoadTextureFromTranscodeResult(texture, result);\n      });\n    })[\"catch\"](function () {\n      Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\n      callback(0, 0, false, false, function () {}, true);\n    });\n  };\n\n  return _BasisTextureLoader;\n}();\n\nexport { _BasisTextureLoader }; // Register the loader.\n\nEngine._TextureLoaders.push(new _BasisTextureLoader());","map":{"version":3,"mappings":"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","names":["Engine","LoadTextureFromTranscodeResult","TranscodeAsync","Tools","EndsWith","_BasisTextureLoader","extension","data","texture","createPolynomials","onLoad","onError","Array","isArray","caps","getEngine","getCaps","transcodeConfig","supportedCompressionFormats","etc1","s3tc","pvrtc","etc2","then","result","hasMipmap","fileInfo","images","levels","length","generateMipMaps","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","err","errorMessage","Warn","callback","rootImage","width","height","format","_TextureLoaders","push"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Textures/Loaders/basisTextureLoader.ts"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport { EndsWith } from \"../../../Misc/stringTools\";\r\n\r\n/**\r\n * Loader for .basis file format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _BasisTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return EndsWith(extension, \".basis\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                LoadTextureFromTranscodeResult(texture, result);\r\n                (texture.getEngine() as Engine)._setCubeMapTextureParams(texture, hasMipmap);\r\n                texture.isReady = true;\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n                if (onLoad) {\r\n                    onLoad();\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\r\n                Tools.Warn(errorMessage);\r\n                texture.isReady = true;\r\n                if (onError) {\r\n                    onError(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ): void {\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const rootImage = result.fileInfo.images[0].levels[0];\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\r\n                    LoadTextureFromTranscodeResult(texture, result);\r\n                });\r\n            })\r\n            .catch(() => {\r\n                Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\r\n                callback(0, 0, false, false, () => {}, true);\r\n            });\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _BasisTextureLoader());\r\n"]},"metadata":{},"sourceType":"module"}