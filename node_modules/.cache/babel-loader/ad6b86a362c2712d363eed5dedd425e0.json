{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor.js\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { ExtrudeShape } from \"../../Meshes/Builders/shapeBuilder.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * AmmoJS Physics plugin\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\n * @see https://github.com/kripken/ammo.js/\n */\n\nvar AmmoJSPlugin =\n/** @class */\nfunction () {\n  /**\n   * Initializes the ammoJS plugin\n   * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\n   * @param ammoInjection can be used to inject your own ammo reference\n   * @param overlappingPairCache can be used to specify your own overlapping pair cache\n   */\n  function AmmoJSPlugin(_useDeltaForWorldStep, ammoInjection, overlappingPairCache) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (ammoInjection === void 0) {\n      ammoInjection = Ammo;\n    }\n\n    if (overlappingPairCache === void 0) {\n      overlappingPairCache = null;\n    }\n\n    var _this = this;\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    /**\n     * Reference to the Ammo library\n     */\n\n    this.bjsAMMO = {};\n    /**\n     * Name of the plugin\n     */\n\n    this.name = \"AmmoJSPlugin\";\n    this._timeStep = 1 / 60;\n    this._fixedTimeStep = 1 / 60;\n    this._maxSteps = 5;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpContactCallbackResult = false;\n    this._tmpContactPoint = new Vector3();\n    this._tmpVec3 = new Vector3();\n    this._tmpMatrix = new Matrix();\n\n    if (typeof ammoInjection === \"function\") {\n      Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\n      return;\n    } else {\n      this.bjsAMMO = ammoInjection;\n    }\n\n    if (!this.isSupported()) {\n      Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\n      return;\n    } // Initialize the physics world\n\n\n    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\n    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\n    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\n    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\n    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\n    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\n    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\n\n    this._tmpAmmoConcreteContactResultCallback.addSingleResult = function (contactPoint) {\n      contactPoint = _this.bjsAMMO.wrapPointer(contactPoint, _this.bjsAMMO.btManifoldPoint);\n      var worldPoint = contactPoint.getPositionWorldOnA();\n      _this._tmpContactPoint.x = worldPoint.x();\n      _this._tmpContactPoint.y = worldPoint.y();\n      _this._tmpContactPoint.z = worldPoint.z();\n      _this._tmpContactCallbackResult = true;\n    };\n\n    this._raycastResult = new PhysicsRaycastResult(); // Create temp ammo variables\n\n    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\n\n    this._tmpAmmoTransform.setIdentity();\n\n    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\n    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\n  }\n  /**\n   * Sets the gravity of the physics world (m/(s^2))\n   * @param gravity Gravity to set\n   */\n\n\n  AmmoJSPlugin.prototype.setGravity = function (gravity) {\n    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\n\n    this.world.setGravity(this._tmpAmmoVectorA);\n    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\n  };\n  /**\n   * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\n   * @param timeStep timestep to use in seconds\n   */\n\n\n  AmmoJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this._timeStep = timeStep;\n  };\n  /**\n   * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\n   * @param fixedTimeStep fixedTimeStep to use in seconds\n   */\n\n\n  AmmoJSPlugin.prototype.setFixedTimeStep = function (fixedTimeStep) {\n    this._fixedTimeStep = fixedTimeStep;\n  };\n  /**\n   * Sets the maximum number of steps by the physics engine per frame (Default: 5)\n   * @param maxSteps the maximum number of steps by the physics engine per frame\n   */\n\n\n  AmmoJSPlugin.prototype.setMaxSteps = function (maxSteps) {\n    this._maxSteps = maxSteps;\n  };\n  /**\n   * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\n   * @returns the current timestep in seconds\n   */\n\n\n  AmmoJSPlugin.prototype.getTimeStep = function () {\n    return this._timeStep;\n  }; // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\n\n\n  AmmoJSPlugin.prototype._isImpostorInContact = function (impostor) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }; // Ammo's collision events have some weird quirks\n  // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\n  // so only fire event if both contactTest and contactPairTest have a hit\n\n\n  AmmoJSPlugin.prototype._isImpostorPairInContact = function (impostorA, impostorB) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }; // Ammo's behavior when maxSteps > 0 does not behave as described in docs\n  // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n  //\n  // When maxSteps is 0 do the entire simulation in one step\n  // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\n  // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\n\n\n  AmmoJSPlugin.prototype._stepSimulation = function (timeStep, maxSteps, fixedTimeStep) {\n    if (timeStep === void 0) {\n      timeStep = 1 / 60;\n    }\n\n    if (maxSteps === void 0) {\n      maxSteps = 10;\n    }\n\n    if (fixedTimeStep === void 0) {\n      fixedTimeStep = 1 / 60;\n    }\n\n    if (maxSteps == 0) {\n      this.world.stepSimulation(timeStep, 0);\n    } else {\n      while (maxSteps > 0 && timeStep > 0) {\n        if (timeStep - fixedTimeStep < fixedTimeStep) {\n          this.world.stepSimulation(timeStep, 0);\n          timeStep = 0;\n        } else {\n          timeStep -= fixedTimeStep;\n          this.world.stepSimulation(fixedTimeStep, 0);\n        }\n\n        maxSteps--;\n      }\n    }\n  };\n  /**\n   * Moves the physics simulation forward delta seconds and updates the given physics imposters\n   * Prior to the step the imposters physics location is set to the position of the babylon meshes\n   * After the step the babylon meshes are set to the position of the physics imposters\n   * @param delta amount of time to step forward\n   * @param impostors array of imposters to update before/after the step\n   */\n\n\n  AmmoJSPlugin.prototype.executeStep = function (delta, impostors) {\n    for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {\n      var impostor = impostors_1[_i]; // Update physics world objects to match babylon world\n\n      if (!impostor.soft) {\n        impostor.beforeStep();\n      }\n    }\n\n    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\n\n    for (var _a = 0, impostors_2 = impostors; _a < impostors_2.length; _a++) {\n      var mainImpostor = impostors_2[_a]; // After physics update make babylon world objects match physics world objects\n\n      if (mainImpostor.soft) {\n        this._afterSoftStep(mainImpostor);\n      } else {\n        mainImpostor.afterStep();\n      } // Handle collision event\n\n\n      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\n        if (this._isImpostorInContact(mainImpostor)) {\n          for (var _b = 0, _c = mainImpostor._onPhysicsCollideCallbacks; _b < _c.length; _b++) {\n            var collideCallback = _c[_b];\n\n            for (var _d = 0, _e = collideCallback.otherImpostors; _d < _e.length; _d++) {\n              var otherImpostor = _e[_d];\n\n              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\n                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\n                  mainImpostor.onCollide({\n                    body: otherImpostor.physicsBody,\n                    point: this._tmpContactPoint\n                  });\n                  otherImpostor.onCollide({\n                    body: mainImpostor.physicsBody,\n                    point: this._tmpContactPoint\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Update babylon mesh to match physics world object\n   * @param impostor imposter to match\n   */\n\n\n  AmmoJSPlugin.prototype._afterSoftStep = function (impostor) {\n    if (impostor.type === PhysicsImpostor.RopeImpostor) {\n      this._ropeStep(impostor);\n    } else {\n      this._softbodyOrClothStep(impostor);\n    }\n  };\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n\n\n  AmmoJSPlugin.prototype._ropeStep = function (impostor) {\n    var bodyVertices = impostor.physicsBody.get_m_nodes();\n    var nbVertices = bodyVertices.size();\n    var node;\n    var nodePositions;\n    var x, y, z;\n    var path = new Array();\n\n    for (var n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z();\n      path.push(new Vector3(x, y, z));\n    }\n\n    var object = impostor.object;\n    var shape = impostor.getParam(\"shape\");\n\n    if (impostor._isFromLine) {\n      impostor.object = CreateLines(\"lines\", {\n        points: path,\n        instance: object\n      });\n    } else {\n      impostor.object = ExtrudeShape(\"ext\", {\n        shape: shape,\n        path: path,\n        instance: object\n      });\n    }\n  };\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n\n\n  AmmoJSPlugin.prototype._softbodyOrClothStep = function (impostor) {\n    var normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\n    var object = impostor.object;\n    var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!vertexPositions) {\n      vertexPositions = [];\n    }\n\n    var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n\n    if (!vertexNormals) {\n      vertexNormals = [];\n    }\n\n    var nbVertices = vertexPositions.length / 3;\n    var bodyVertices = impostor.physicsBody.get_m_nodes();\n    var node;\n    var nodePositions;\n    var x, y, z;\n    var nx, ny, nz;\n\n    for (var n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z() * normalDirection;\n      var nodeNormals = node.get_m_n();\n      nx = nodeNormals.x();\n      ny = nodeNormals.y();\n      nz = nodeNormals.z() * normalDirection;\n      vertexPositions[3 * n] = x;\n      vertexPositions[3 * n + 1] = y;\n      vertexPositions[3 * n + 2] = z;\n      vertexNormals[3 * n] = nx;\n      vertexNormals[3 * n + 1] = ny;\n      vertexNormals[3 * n + 2] = nz;\n    }\n\n    var vertex_data = new VertexData();\n    vertex_data.positions = vertexPositions;\n    vertex_data.normals = vertexNormals;\n    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n\n    if (object && object.getIndices) {\n      vertex_data.indices = object.getIndices();\n    }\n\n    vertex_data.applyToMesh(object);\n  };\n  /**\n   * Applies an impulse on the imposter\n   * @param impostor imposter to apply impulse to\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the impulse on the imposter\n   */\n\n\n  AmmoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      var worldPoint = this._tmpAmmoVectorA;\n      var impulse = this._tmpAmmoVectorB; // Convert contactPoint relative to center of mass\n\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n      }\n\n      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyImpulse(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  };\n  /**\n   * Applies a force on the imposter\n   * @param impostor imposter to apply force\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the force on the imposter\n   */\n\n\n  AmmoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      var worldPoint = this._tmpAmmoVectorA;\n      var impulse = this._tmpAmmoVectorB; // Convert contactPoint relative to center of mass\n\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        var localTranslation = impostor.object.getWorldMatrix().getTranslation();\n        worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\n      } else {\n        worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      }\n\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyForce(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  };\n  /**\n   * Creates a physics body using the plugin\n   * @param impostor the imposter to create the physics body on\n   */\n\n\n  AmmoJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    // Note: this method will not be called on child imposotrs for compound impostors\n    impostor._pluginData.toDispose = []; //parent-child relationship\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        impostor.forceUpdate();\n      }\n\n      return;\n    }\n\n    if (impostor.isBodyInitRequired()) {\n      var colShape = this._createShape(impostor);\n\n      var mass = impostor.getParam(\"mass\");\n      impostor._pluginData.mass = mass;\n\n      if (impostor.soft) {\n        colShape.get_m_cfg().set_collisions(0x11);\n        colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\n        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\n        colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        this.world.addSoftBody(colShape, 1, -1);\n        impostor.physicsBody = colShape;\n\n        impostor._pluginData.toDispose.push(colShape);\n\n        this.setBodyPressure(impostor, 0);\n\n        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n          this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\n        }\n\n        this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\n        this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\n        this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\n      } else {\n        var localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\n        var startTransform = new this.bjsAMMO.btTransform();\n        impostor.object.computeWorldMatrix(true);\n        startTransform.setIdentity();\n\n        if (mass !== 0) {\n          colShape.calculateLocalInertia(mass, localInertia);\n        }\n\n        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\n\n        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);\n\n        startTransform.setOrigin(this._tmpAmmoVectorA);\n        startTransform.setRotation(this._tmpAmmoQuaternion);\n        var myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\n        var rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\n        var body = new this.bjsAMMO.btRigidBody(rbInfo); // Make objects kinematic if it's mass is 0\n\n        if (mass === 0) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\n          body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        } // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\n\n\n        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\n        } // compute delta position: compensate the difference between shape center and mesh origin\n\n\n        if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\n          var boundingInfo = impostor.object.getBoundingInfo();\n\n          this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\n\n          this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\n\n          this._tmpVec3.x /= impostor.object.scaling.x;\n          this._tmpVec3.y /= impostor.object.scaling.y;\n          this._tmpVec3.z /= impostor.object.scaling.z;\n          impostor.setDeltaPosition(this._tmpVec3);\n        }\n\n        var group = impostor.getParam(\"group\");\n        var mask = impostor.getParam(\"mask\");\n\n        if (group && mask) {\n          this.world.addRigidBody(body, group, mask);\n        } else {\n          this.world.addRigidBody(body);\n        }\n\n        impostor.physicsBody = body;\n        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\n      }\n\n      this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\n      this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\n    }\n  };\n  /**\n   * Removes the physics body from the imposter and disposes of the body's memory\n   * @param impostor imposter to remove the physics body from\n   */\n\n\n  AmmoJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    var _this = this;\n\n    if (this.world) {\n      if (impostor.soft) {\n        this.world.removeSoftBody(impostor.physicsBody);\n      } else {\n        this.world.removeRigidBody(impostor.physicsBody);\n      }\n\n      if (impostor._pluginData) {\n        impostor._pluginData.toDispose.forEach(function (d) {\n          _this.bjsAMMO.destroy(d);\n        });\n\n        impostor._pluginData.toDispose = [];\n      }\n    }\n  };\n  /**\n   * Generates a joint\n   * @param impostorJoint the imposter joint to create the joint with\n   */\n\n\n  AmmoJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var jointData = impostorJoint.joint.jointData;\n\n    if (!jointData.mainPivot) {\n      jointData.mainPivot = new Vector3(0, 0, 0);\n    }\n\n    if (!jointData.connectedPivot) {\n      jointData.connectedPivot = new Vector3(0, 0, 0);\n    }\n\n    var joint;\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.DistanceJoint:\n        {\n          var distance = jointData.maxDistance;\n\n          if (distance) {\n            jointData.mainPivot = new Vector3(0, -distance / 2, 0);\n            jointData.connectedPivot = new Vector3(0, distance / 2, 0);\n          }\n\n          joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n          break;\n        }\n\n      case PhysicsJoint.HingeJoint:\n        {\n          if (!jointData.mainAxis) {\n            jointData.mainAxis = new Vector3(0, 0, 0);\n          }\n\n          if (!jointData.connectedAxis) {\n            jointData.connectedAxis = new Vector3(0, 0, 0);\n          }\n\n          var mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\n          var connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\n          joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\n          break;\n        }\n\n      case PhysicsJoint.BallAndSocketJoint:\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n\n      default:\n        Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n    }\n\n    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\n    impostorJoint.joint.physicsJoint = joint;\n  };\n  /**\n   * Removes a joint\n   * @param impostorJoint the imposter joint to remove the joint from\n   */\n\n\n  AmmoJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    if (this.world) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    }\n  }; // adds all verticies (including child verticies) to the triangle mesh\n\n\n  AmmoJSPlugin.prototype._addMeshVerts = function (btTriangleMesh, topLevelObject, object) {\n    var _this = this;\n\n    var triangleCount = 0;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      var localMatrix = void 0;\n\n      if (topLevelObject && topLevelObject !== object) {\n        // top level matrix used for shape transform doesn't take scale into account.\n        // Moreover, every children vertex position must be in that space.\n        // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\n        var topLevelQuaternion = void 0;\n\n        if (topLevelObject.rotationQuaternion) {\n          topLevelQuaternion = topLevelObject.rotationQuaternion;\n        } else if (topLevelObject.rotation) {\n          topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\n        } else {\n          topLevelQuaternion = Quaternion.Identity();\n        }\n\n        var topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\n        topLevelMatrix.invertToRef(this._tmpMatrix);\n        var wm = object.computeWorldMatrix(false);\n        localMatrix = wm.multiply(this._tmpMatrix);\n      } else {\n        // current top level is same as object level -> only use local scaling\n        Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n        localMatrix = this._tmpMatrix;\n      }\n\n      var faceCount = indices.length / 3;\n\n      for (var i = 0; i < faceCount; i++) {\n        var triPoints = [];\n\n        for (var point = 0; point < 3; point++) {\n          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n          v = Vector3.TransformCoordinates(v, localMatrix);\n          var vec = void 0;\n\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n\n        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\n        triangleCount++;\n      }\n\n      object.getChildMeshes().forEach(function (m) {\n        triangleCount += _this._addMeshVerts(btTriangleMesh, topLevelObject, m);\n      });\n    }\n\n    return triangleCount;\n  };\n  /**\n   * Initialise the soft body vertices to match its object's (mesh) vertices\n   * Softbody vertices (nodes) are in world space and to match this\n   * The object's position and rotation is set to zero and so its vertices are also then set in world space\n   * @param impostor to create the softbody for\n   */\n\n\n  AmmoJSPlugin.prototype._softVertexData = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n\n      if (!vertexNormals) {\n        vertexNormals = [];\n      }\n\n      object.computeWorldMatrix(false);\n      var newPoints = [];\n      var newNorms = [];\n\n      for (var i = 0; i < vertexPositions.length; i += 3) {\n        var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n        var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\n        n = Vector3.TransformNormal(n, object.getWorldMatrix());\n        newPoints.push(v.x, v.y, v.z);\n        newNorms.push(n.x, n.y, n.z);\n      }\n\n      var vertex_data = new VertexData();\n      vertex_data.positions = newPoints;\n      vertex_data.normals = newNorms;\n      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n\n      if (object && object.getIndices) {\n        vertex_data.indices = object.getIndices();\n      }\n\n      vertex_data.applyToMesh(object);\n      object.position = Vector3.Zero();\n      object.rotationQuaternion = null;\n      object.rotation = Vector3.Zero();\n      object.computeWorldMatrix(true);\n      return vertex_data;\n    }\n\n    return VertexData.ExtractFromMesh(object);\n  };\n  /**\n   * Create an impostor's soft body\n   * @param impostor to create the softbody for\n   */\n\n\n  AmmoJSPlugin.prototype._createSoftbody = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertex_data = this._softVertexData(impostor);\n\n      var vertexPositions = vertex_data.positions;\n      var vertexNormals = vertex_data.normals;\n\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        var triPoints = [];\n        var triNorms = [];\n\n        for (var i = 0; i < vertexPositions.length; i += 3) {\n          var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n          var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n          triPoints.push(v.x, v.y, -v.z);\n          triNorms.push(n.x, n.y, -n.z);\n        }\n\n        var softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\n        var nbVertices = vertexPositions.length / 3;\n        var bodyVertices = softBody.get_m_nodes();\n        var node = void 0;\n        var nodeNormals = void 0;\n\n        for (var i = 0; i < nbVertices; i++) {\n          node = bodyVertices.at(i);\n          nodeNormals = node.get_m_n();\n          nodeNormals.setX(triNorms[3 * i]);\n          nodeNormals.setY(triNorms[3 * i + 1]);\n          nodeNormals.setZ(triNorms[3 * i + 2]);\n        }\n\n        return softBody;\n      }\n    }\n  };\n  /**\n   * Create cloth for an impostor\n   * @param impostor to create the softbody for\n   */\n\n\n  AmmoJSPlugin.prototype._createCloth = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertex_data = this._softVertexData(impostor);\n\n      var vertexPositions = vertex_data.positions;\n      var vertexNormals = vertex_data.normals;\n\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        var len = vertexPositions.length;\n        var segments = Math.sqrt(len / 3);\n        impostor.segments = segments;\n        var segs = segments - 1;\n\n        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n\n        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\n\n        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n\n        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\n\n        var clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam(\"fixedPoints\"), true);\n        return clothBody;\n      }\n    }\n  };\n  /**\n   * Create rope for an impostor\n   * @param impostor to create the softbody for\n   */\n\n\n  AmmoJSPlugin.prototype._createRope = function (impostor) {\n    var len;\n    var segments;\n\n    var vertex_data = this._softVertexData(impostor);\n\n    var vertexPositions = vertex_data.positions;\n    var vertexNormals = vertex_data.normals;\n\n    if (vertexPositions === null || vertexNormals === null) {\n      return new this.bjsAMMO.btCompoundShape();\n    } //force the mesh to be updatable\n\n\n    vertex_data.applyToMesh(impostor.object, true);\n    impostor._isFromLine = true; // If in lines mesh all normals will be zero\n\n    var vertexSquared = vertexNormals.map(function (x) {\n      return x * x;\n    });\n\n    var reducer = function reducer(accumulator, currentValue) {\n      return accumulator + currentValue;\n    };\n\n    var reduced = vertexSquared.reduce(reducer);\n\n    if (reduced === 0) {\n      // line mesh\n      len = vertexPositions.length;\n      segments = len / 3 - 1;\n\n      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n\n      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n    } else {\n      //extruded mesh\n      impostor._isFromLine = false;\n      var pathVectors = impostor.getParam(\"path\");\n      var shape = impostor.getParam(\"shape\");\n\n      if (shape === null) {\n        Logger.Warn(\"No shape available for extruded mesh\");\n        return new this.bjsAMMO.btCompoundShape();\n      }\n\n      len = pathVectors.length;\n      segments = len - 1;\n\n      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\n\n      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\n    }\n\n    impostor.segments = segments;\n    var fixedPoints = impostor.getParam(\"fixedPoints\");\n    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\n    var ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\n    ropeBody.get_m_cfg().set_collisions(0x11);\n    return ropeBody;\n  };\n  /**\n   * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\n   * @param impostor to create the custom physics shape for\n   */\n\n\n  AmmoJSPlugin.prototype._createCustom = function (impostor) {\n    var returnValue = null;\n\n    if (this.onCreateCustomShape) {\n      returnValue = this.onCreateCustomShape(impostor);\n    }\n\n    if (returnValue == null) {\n      returnValue = new this.bjsAMMO.btCompoundShape();\n    }\n\n    return returnValue;\n  }; // adds all verticies (including child verticies) to the convex hull shape\n\n\n  AmmoJSPlugin.prototype._addHullVerts = function (btConvexHullShape, topLevelObject, object) {\n    var _this = this;\n\n    var triangleCount = 0;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      object.computeWorldMatrix(false);\n      var faceCount = indices.length / 3;\n\n      for (var i = 0; i < faceCount; i++) {\n        var triPoints = [];\n\n        for (var point = 0; point < 3; point++) {\n          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]); // Adjust for initial scaling\n\n          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n          v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n          var vec = void 0;\n\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n\n        btConvexHullShape.addPoint(triPoints[0], true);\n        btConvexHullShape.addPoint(triPoints[1], true);\n        btConvexHullShape.addPoint(triPoints[2], true);\n        triangleCount++;\n      }\n\n      object.getChildMeshes().forEach(function (m) {\n        triangleCount += _this._addHullVerts(btConvexHullShape, topLevelObject, m);\n      });\n    }\n\n    return triangleCount;\n  };\n\n  AmmoJSPlugin.prototype._createShape = function (impostor, ignoreChildren) {\n    var _this = this;\n\n    if (ignoreChildren === void 0) {\n      ignoreChildren = false;\n    }\n\n    var object = impostor.object;\n    var returnValue;\n    var extendSize = impostor.getObjectExtendSize();\n\n    if (!ignoreChildren) {\n      var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\n      returnValue = new this.bjsAMMO.btCompoundShape(); // Add shape of all children to the compound shape\n\n      var childrenAdded_1 = 0;\n      meshChildren.forEach(function (childMesh) {\n        var childImpostor = childMesh.getPhysicsImpostor();\n\n        if (childImpostor) {\n          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\n            throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\n          }\n\n          var shape = _this._createShape(childImpostor); // Position needs to be scaled based on parent's scaling\n\n\n          var parentMat = childMesh.parent.getWorldMatrix().clone();\n          var s = new Vector3();\n          parentMat.decompose(s);\n\n          _this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\n\n          _this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);\n\n          _this._tmpAmmoTransform.setRotation(_this._tmpAmmoQuaternion);\n\n          returnValue.addChildShape(_this._tmpAmmoTransform, shape);\n          childImpostor.dispose();\n          childrenAdded_1++;\n        }\n      });\n\n      if (childrenAdded_1 > 0) {\n        // Add parents shape as a child if present\n        if (impostor.type != PhysicsImpostor.NoImpostor) {\n          var shape = this._createShape(impostor, true);\n\n          if (shape) {\n            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\n\n            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\n\n            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n\n            returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          }\n        }\n\n        return returnValue;\n      } else {\n        // If no children with impostors create the actual shape below instead\n        this.bjsAMMO.destroy(returnValue);\n        returnValue = null;\n      }\n    }\n\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        // Is there a better way to compare floats number? With an epsilon or with a Math function\n        if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 0.0001) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 0.0001)) {\n          returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\n        } else {\n          // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\n          var positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\n          var radii = [1];\n          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\n          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));\n        }\n\n        break;\n\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\n          // Height is just the height between the center of each 'sphere' of the capsule caps\n          var capRadius = extendSize.x / 2;\n          returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, extendSize.y - capRadius * 2);\n        }\n        break;\n\n      case PhysicsImpostor.CylinderImpostor:\n        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\n\n        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\n        break;\n\n      case PhysicsImpostor.PlaneImpostor:\n      case PhysicsImpostor.BoxImpostor:\n        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\n\n        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\n        break;\n\n      case PhysicsImpostor.MeshImpostor:\n        {\n          if (impostor.getParam(\"mass\") == 0) {\n            // Only create btBvhTriangleMeshShape impostor is static\n            // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\n            if (this.onCreateCustomMeshImpostor) {\n              returnValue = this.onCreateCustomMeshImpostor(impostor);\n            } else {\n              var tetraMesh = new this.bjsAMMO.btTriangleMesh();\n\n              impostor._pluginData.toDispose.push(tetraMesh);\n\n              var triangeCount = this._addMeshVerts(tetraMesh, object, object);\n\n              if (triangeCount == 0) {\n                returnValue = new this.bjsAMMO.btCompoundShape();\n              } else {\n                returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);\n              }\n            }\n\n            break;\n          }\n        }\n      // Otherwise create convexHullImpostor\n      // eslint-disable-next-line no-fallthrough\n\n      case PhysicsImpostor.ConvexHullImpostor:\n        {\n          if (this.onCreateCustomConvexHullImpostor) {\n            returnValue = this.onCreateCustomConvexHullImpostor(impostor);\n          } else {\n            var convexMesh = new this.bjsAMMO.btConvexHullShape();\n\n            var triangeCount = this._addHullVerts(convexMesh, object, object);\n\n            if (triangeCount == 0) {\n              // Cleanup Unused Convex Hull Shape\n              impostor._pluginData.toDispose.push(convexMesh);\n\n              returnValue = new this.bjsAMMO.btCompoundShape();\n            } else {\n              returnValue = convexMesh;\n            }\n          }\n\n          break;\n        }\n\n      case PhysicsImpostor.NoImpostor:\n        // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\n        returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\n        break;\n\n      case PhysicsImpostor.CustomImpostor:\n        // Only usable when the plugin's onCreateCustomShape is set\n        returnValue = this._createCustom(impostor);\n        break;\n\n      case PhysicsImpostor.SoftbodyImpostor:\n        // Only usable with a mesh that has sufficient and shared vertices\n        returnValue = this._createSoftbody(impostor);\n        break;\n\n      case PhysicsImpostor.ClothImpostor:\n        // Only usable with a ground mesh that has sufficient and shared vertices\n        returnValue = this._createCloth(impostor);\n        break;\n\n      case PhysicsImpostor.RopeImpostor:\n        // Only usable with a line mesh or an extruded mesh that is updatable\n        returnValue = this._createRope(impostor);\n        break;\n\n      default:\n        Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\n        break;\n    }\n\n    return returnValue;\n  };\n  /**\n   * Sets the physics body position/rotation from the babylon mesh's position/rotation\n   * @param impostor imposter containing the physics body and babylon object\n   */\n\n\n  AmmoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\n\n    if (!impostor.object.rotationQuaternion) {\n      if (impostor.object.rotation) {\n        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n\n        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\n      }\n    } else {\n      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n    }\n  };\n  /**\n   * Sets the babylon object's position/rotation from the physics body's position/rotation\n   * @param impostor imposter containing the physics body and babylon object\n   * @param newPosition new position\n   * @param newRotation new rotation\n   */\n\n\n  AmmoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    var trans = impostor.physicsBody.getWorldTransform(); // If rotation/position has changed update and activate rigged body\n\n    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {\n      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\n\n      trans.setOrigin(this._tmpAmmoVectorA);\n\n      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n\n      trans.setRotation(this._tmpAmmoQuaternion);\n      impostor.physicsBody.setWorldTransform(trans);\n\n      if (impostor.mass == 0) {\n        // Kinematic objects must be updated using motion state\n        var motionState = impostor.physicsBody.getMotionState();\n\n        if (motionState) {\n          motionState.setWorldTransform(trans);\n        }\n      } else {\n        impostor.physicsBody.activate();\n      }\n    }\n  };\n  /**\n   * If this plugin is supported\n   * @returns true if its supported\n   */\n\n\n  AmmoJSPlugin.prototype.isSupported = function () {\n    return this.bjsAMMO !== undefined;\n  };\n  /**\n   * Sets the linear velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n\n\n  AmmoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n\n    if (impostor.soft) {\n      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\n    }\n  };\n  /**\n   * Sets the angular velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n\n\n  AmmoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n\n    if (impostor.soft) {\n      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\n    }\n  };\n  /**\n   * gets the linear velocity\n   * @param impostor imposter to get linear velocity from\n   * @returns linear velocity\n   */\n\n\n  AmmoJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v;\n\n    if (impostor.soft) {\n      v = impostor.physicsBody.linearVelocity();\n    } else {\n      v = impostor.physicsBody.getLinearVelocity();\n    }\n\n    if (!v) {\n      return null;\n    }\n\n    var result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  };\n  /**\n   * gets the angular velocity\n   * @param impostor imposter to get angular velocity from\n   * @returns angular velocity\n   */\n\n\n  AmmoJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v;\n\n    if (impostor.soft) {\n      v = impostor.physicsBody.angularVelocity();\n    } else {\n      v = impostor.physicsBody.getAngularVelocity();\n    }\n\n    if (!v) {\n      return null;\n    }\n\n    var result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  };\n  /**\n   * Sets the mass of physics body\n   * @param impostor imposter to set the mass on\n   * @param mass mass to set\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    if (impostor.soft) {\n      impostor.physicsBody.setTotalMass(mass, false);\n    } else {\n      impostor.physicsBody.setMassProps(mass);\n    }\n\n    impostor._pluginData.mass = mass;\n  };\n  /**\n   * Gets the mass of the physics body\n   * @param impostor imposter to get the mass from\n   * @returns mass\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor._pluginData.mass || 0;\n  };\n  /**\n   * Gets friction of the impostor\n   * @param impostor impostor to get friction from\n   * @returns friction value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor._pluginData.friction || 0;\n  };\n  /**\n   * Sets friction of the impostor\n   * @param impostor impostor to set friction on\n   * @param friction friction value\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    if (impostor.soft) {\n      impostor.physicsBody.get_m_cfg().set_kDF(friction);\n    } else {\n      impostor.physicsBody.setFriction(friction);\n    }\n\n    impostor._pluginData.friction = friction;\n  };\n  /**\n   * Gets restitution of the impostor\n   * @param impostor impostor to get restitution from\n   * @returns restitution value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor._pluginData.restitution || 0;\n  };\n  /**\n   * Sets restitution of the impostor\n   * @param impostor impostor to set resitution on\n   * @param restitution resitution value\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.setRestitution(restitution);\n    impostor._pluginData.restitution = restitution;\n  };\n  /**\n   * Gets pressure inside the impostor\n   * @param impostor impostor to get pressure from\n   * @returns pressure value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyPressure = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Pressure is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.pressure || 0;\n  };\n  /**\n   * Sets pressure inside a soft body impostor\n   * Cloth and rope must remain 0 pressure\n   * @param impostor impostor to set pressure on\n   * @param pressure pressure value\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyPressure = function (impostor, pressure) {\n    if (impostor.soft) {\n      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n        impostor.physicsBody.get_m_cfg().set_kPR(pressure);\n        impostor._pluginData.pressure = pressure;\n      } else {\n        impostor.physicsBody.get_m_cfg().set_kPR(0);\n        impostor._pluginData.pressure = 0;\n      }\n    } else {\n      Logger.Warn(\"Pressure can only be applied to a softbody\");\n    }\n  };\n  /**\n   * Gets stiffness of the impostor\n   * @param impostor impostor to get stiffness from\n   * @returns pressure value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyStiffness = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Stiffness is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.stiffness || 0;\n  };\n  /**\n   * Sets stiffness of the impostor\n   * @param impostor impostor to set stiffness on\n   * @param stiffness stiffness value from 0 to 1\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyStiffness = function (impostor, stiffness) {\n    if (impostor.soft) {\n      stiffness = stiffness < 0 ? 0 : stiffness;\n      stiffness = stiffness > 1 ? 1 : stiffness;\n      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\n      impostor._pluginData.stiffness = stiffness;\n    } else {\n      Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\n    }\n  };\n  /**\n   * Gets velocityIterations of the impostor\n   * @param impostor impostor to get velocity iterations from\n   * @returns velocityIterations value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyVelocityIterations = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.velocityIterations || 0;\n  };\n  /**\n   * Sets velocityIterations of the impostor\n   * @param impostor impostor to set velocity iterations on\n   * @param velocityIterations velocityIterations value\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyVelocityIterations = function (impostor, velocityIterations) {\n    if (impostor.soft) {\n      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\n      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\n      impostor._pluginData.velocityIterations = velocityIterations;\n    } else {\n      Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\n    }\n  };\n  /**\n   * Gets positionIterations of the impostor\n   * @param impostor impostor to get position iterations from\n   * @returns positionIterations value\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyPositionIterations = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Position iterations is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.positionIterations || 0;\n  };\n  /**\n   * Sets positionIterations of the impostor\n   * @param impostor impostor to set position on\n   * @param positionIterations positionIterations value\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyPositionIterations = function (impostor, positionIterations) {\n    if (impostor.soft) {\n      positionIterations = positionIterations < 0 ? 0 : positionIterations;\n      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\n      impostor._pluginData.positionIterations = positionIterations;\n    } else {\n      Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\n    }\n  };\n  /**\n   * Append an anchor to a cloth object\n   * @param impostor is the cloth impostor to add anchor to\n   * @param otherImpostor is the rigid impostor to anchor to\n   * @param width ratio across width from 0 to 1\n   * @param height ratio up height from 0 to 1\n   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n\n\n  AmmoJSPlugin.prototype.appendAnchor = function (impostor, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {\n    if (influence === void 0) {\n      influence = 1;\n    }\n\n    if (noCollisionBetweenLinkedBodies === void 0) {\n      noCollisionBetweenLinkedBodies = false;\n    }\n\n    var segs = impostor.segments;\n    var nbAcross = Math.round((segs - 1) * width);\n    var nbUp = Math.round((segs - 1) * height);\n    var nbDown = segs - 1 - nbUp;\n    var node = nbAcross + segs * nbDown;\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  };\n  /**\n   * Append an hook to a rope object\n   * @param impostor is the rope impostor to add hook to\n   * @param otherImpostor is the rigid impostor to hook to\n   * @param length ratio along the rope from 0 to 1\n   * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n\n\n  AmmoJSPlugin.prototype.appendHook = function (impostor, otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {\n    if (influence === void 0) {\n      influence = 1;\n    }\n\n    if (noCollisionBetweenLinkedBodies === void 0) {\n      noCollisionBetweenLinkedBodies = false;\n    }\n\n    var node = Math.round(impostor.segments * length);\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  };\n  /**\n   * Sleeps the physics body and stops it from being active\n   * @param impostor impostor to sleep\n   */\n\n\n  AmmoJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.forceActivationState(0);\n  };\n  /**\n   * Activates the physics body\n   * @param impostor impostor to activate\n   */\n\n\n  AmmoJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.activate();\n  };\n  /**\n   * Updates the distance parameters of the joint\n   */\n\n\n  AmmoJSPlugin.prototype.updateDistanceJoint = function () {\n    Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\n  };\n  /**\n   * Sets a motor on the joint\n   * @param joint joint to set motor on\n   * @param speed speed of the motor\n   * @param maxForce maximum force of the motor\n   */\n\n\n  AmmoJSPlugin.prototype.setMotor = function (joint, speed, maxForce) {\n    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\n  };\n  /**\n   * Sets the motors limit\n   */\n\n\n  AmmoJSPlugin.prototype.setLimit = function () {\n    Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\n  };\n  /**\n   * Syncs the position and rotation of a mesh with the impostor\n   * @param mesh mesh to sync\n   * @param impostor impostor to update the mesh with\n   */\n\n\n  AmmoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\n    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\n    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\n      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\n      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\n      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\n    }\n  };\n  /**\n   * Gets the radius of the impostor\n   * @param impostor impostor to get radius from\n   * @returns the radius\n   */\n\n\n  AmmoJSPlugin.prototype.getRadius = function (impostor) {\n    var exntend = impostor.getObjectExtendSize();\n    return exntend.x / 2;\n  };\n  /**\n   * Gets the box size of the impostor\n   * @param impostor impostor to get box size from\n   * @param result the resulting box size\n   */\n\n\n  AmmoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var exntend = impostor.getObjectExtendSize();\n    result.x = exntend.x;\n    result.y = exntend.y;\n    result.z = exntend.z;\n  };\n  /**\n   * Disposes of the impostor\n   */\n\n\n  AmmoJSPlugin.prototype.dispose = function () {\n    // Dispose of world\n    this.bjsAMMO.destroy(this.world);\n    this.bjsAMMO.destroy(this._solver);\n    this.bjsAMMO.destroy(this._overlappingPairCache);\n    this.bjsAMMO.destroy(this._dispatcher);\n    this.bjsAMMO.destroy(this._collisionConfiguration); // Dispose of tmp variables\n\n    this.bjsAMMO.destroy(this._tmpAmmoVectorA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorB);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorC);\n    this.bjsAMMO.destroy(this._tmpAmmoTransform);\n    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\n    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\n    this.world = null;\n  };\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n\n\n  AmmoJSPlugin.prototype.raycast = function (from, to) {\n    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\n    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\n    var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\n    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\n\n    this._raycastResult.reset(from, to);\n\n    if (rayCallback.hasHit()) {\n      // TODO: do we want/need the body? If so, set all the data\n\n      /*\n      var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\n          rayCallback.get_m_collisionObject()\n      );\n      var body = {};\n      */\n      this._raycastResult.setHitData({\n        x: rayCallback.get_m_hitNormalWorld().x(),\n        y: rayCallback.get_m_hitNormalWorld().y(),\n        z: rayCallback.get_m_hitNormalWorld().z()\n      }, {\n        x: rayCallback.get_m_hitPointWorld().x(),\n        y: rayCallback.get_m_hitPointWorld().y(),\n        z: rayCallback.get_m_hitPointWorld().z()\n      });\n\n      this._raycastResult.calculateHitDistance();\n    }\n\n    this.bjsAMMO.destroy(rayCallback);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\n    return this._raycastResult;\n  };\n\n  AmmoJSPlugin._DISABLE_COLLISION_FLAG = 4;\n  AmmoJSPlugin._KINEMATIC_FLAG = 2;\n  AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG = 4;\n  return AmmoJSPlugin;\n}();\n\nexport { AmmoJSPlugin };","map":{"version":3,"mappings":"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","names":["Quaternion","Vector3","Matrix","Logger","PhysicsImpostor","PhysicsJoint","VertexBuffer","VertexData","ExtrudeShape","CreateLines","PhysicsRaycastResult","Scalar","Epsilon","_useDeltaForWorldStep","ammoInjection","overlappingPairCache","Error","bjsAMMO","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","contactPoint","_this","wrapPointer","btManifoldPoint","worldPoint","getPositionWorldOnA","_tmpContactPoint","x","y","z","_tmpContactCallbackResult","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","AmmoJSPlugin","gravity","setValue","setGravity","getWorldInfo","set_m_gravity","timeStep","_timeStep","fixedTimeStep","_fixedTimeStep","maxSteps","_maxSteps","impostor","contactTest","physicsBody","impostorA","impostorB","contactPairTest","stepSimulation","delta","impostors","_i","soft","beforeStep","_stepSimulation","_a","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","length","_isImpostorInContact","_b","collideCallback","otherImpostors","_d","otherImpostor","isActive","_isImpostorPairInContact","onCollide","body","point","type","RopeImpostor","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","size","node","nodePositions","path","Array","n","at","get_m_x","push","object","shape","getParam","_isFromLine","points","instance","normalDirection","ClothImpostor","vertexPositions","getVerticesData","PositionKind","vertexNormals","NormalKind","nx","ny","nz","nodeNormals","get_m_n","vertex_data","positions","normals","uvs","UVKind","colors","ColorKind","getIndices","indices","applyToMesh","force","activate","impulse","getWorldMatrix","subtractInPlace","getTranslation","applyImpulse","Warn","localTranslation","applyForce","_pluginData","toDispose","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","mass","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","SoftbodyImpostor","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","computeWorldMatrix","calculateLocalInertia","position","rotationQuaternion","w","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","NoImpostor","getChildShape","_DISABLE_COLLISION_FLAG","MeshImpostor","boundingInfo","getBoundingInfo","_tmpVec3","copyFrom","getAbsolutePosition","boundingBox","centerWorld","scaling","setDeltaPosition","group","mask","addRigidBody","concat","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","forEach","d","destroy","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","DistanceJoint","distance","maxDistance","btPoint2PointConstraint","HingeJoint","mainAxis","connectedAxis","btHingeConstraint","BallAndSocketJoint","addConstraint","collision","physicsJoint","removeConstraint","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","rotation","FromEulerAngles","Identity","topLevelMatrix","Compose","One","invertToRef","_tmpMatrix","wm","multiply","ScalingToRef","faceCount","i","triPoints","v","TransformCoordinates","vec","addTriangle","m","_addMeshVerts","newPoints","newNorms","TransformNormal","Zero","ExtractFromMesh","_softVertexData","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","len","segments","Math","sqrt","segs","clothBody","CreatePatch","vertexSquared","map","reducer","accumulator","currentValue","reduced","reduce","pathVectors","fixedPoints","ropeBody","CreateRope","returnValue","onCreateCustomShape","btConvexHullShape","addPoint","_addHullVerts","ignoreChildren","extendSize","getObjectExtendSize","meshChildren","childrenAdded_1","childMesh","childImpostor","getPhysicsImpostor","parentMat","clone","s","decompose","getOrigin","addChildShape","dispose","SphereImpostor","WithinEpsilon","btSphereShape","radii","btMultiSphereShape","setLocalScaling","CapsuleImpostor","capRadius","btCapsuleShape","CylinderImpostor","btCylinderShape","PlaneImpostor","BoxImpostor","btBoxShape","onCreateCustomMeshImpostor","tetraMesh","triangeCount","btBvhTriangleMeshShape","ConvexHullImpostor","onCreateCustomConvexHullImpostor","convexMesh","CustomImpostor","_createCustom","_createSoftbody","_createCloth","_createRope","getMotionState","getWorldTransform","set","_tmpQuaternion","getRotation","toEulerAnglesToRef","newPosition","newRotation","trans","abs","setWorldTransform","motionState","undefined","velocity","linearVelocity","setLinearVelocity","angularVelocity","setAngularVelocity","getLinearVelocity","result","getAngularVelocity","setTotalMass","setMassProps","friction","set_kDF","setFriction","restitution","setRestitution","pressure","set_kPR","stiffness","get_m_materials","set_m_kLST","velocityIterations","set_viterations","positionIterations","set_piterations","width","height","influence","noCollisionBetweenLinkedBodies","nbAcross","round","nbUp","nbDown","appendAnchor","forceActivationState","speed","maxForce","enableAngularMotor","mesh","exntend","from","to","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Physics/Plugins/ammoJSPlugin.ts"],"sourcesContent":["import { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { ExtrudeShape } from \"../../Meshes/Builders/shapeBuilder\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n    private _tmpVec3 = new Vector3();\r\n\r\n    private static readonly _DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly _KINEMATIC_FLAG = 2;\r\n    private static readonly _DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom mesh impostor handler function to support building custom mesh impostor vertex data\r\n     */\r\n    public onCreateCustomMeshImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom convex hull impostor handler function to support building custom convex hull impostor vertex data\r\n     */\r\n    public onCreateCustomConvexHullImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (const impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (const mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            } else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (const otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({ body: otherImpostor.physicsBody, point: this._tmpContactPoint });\r\n                                    otherImpostor.onCollide({ body: mainImpostor.physicsBody, point: this._tmpContactPoint });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        } else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        const nbVertices = bodyVertices.size();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        const path: Array<Vector3> = new Array();\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        const object = impostor.object;\r\n        const shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        } else {\r\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\r\n        const object = impostor.object;\r\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        const nbVertices = vertexPositions.length / 3;\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        let nx, ny, nz: number;\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            const nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        const vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\r\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\r\n            } else {\r\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            }\r\n\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const colShape = this._createShape(impostor);\r\n            const mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            } else {\r\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                const startTransform = new this.bjsAMMO.btTransform();\r\n                impostor.object.computeWorldMatrix(true);\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(\r\n                    impostor.object.rotationQuaternion!.x,\r\n                    impostor.object.rotationQuaternion!.y,\r\n                    impostor.object.rotationQuaternion!.z,\r\n                    impostor.object.rotationQuaternion!.w\r\n                );\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                // compute delta position: compensate the difference between shape center and mesh origin\r\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\r\n                    const boundingInfo = impostor.object.getBoundingInfo();\r\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\r\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\r\n                    this._tmpVec3.x /= impostor.object.scaling.x;\r\n                    this._tmpVec3.y /= impostor.object.scaling.y;\r\n                    this._tmpVec3.z /= impostor.object.scaling.z;\r\n                    impostor.setDeltaPosition(this._tmpVec3);\r\n                }\r\n\r\n                const group = impostor.getParam(\"group\");\r\n                const mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        const jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        let joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint: {\r\n                const distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.HingeJoint: {\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z),\r\n                    mainAxis,\r\n                    connectedAxis\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n\r\n            let localMatrix;\r\n\r\n            if (topLevelObject && topLevelObject !== object) {\r\n                // top level matrix used for shape transform doesn't take scale into account.\r\n                // Moreover, every children vertex position must be in that space.\r\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\r\n                let topLevelQuaternion;\r\n                if (topLevelObject.rotationQuaternion) {\r\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\r\n                } else if (topLevelObject.rotation) {\r\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\r\n                } else {\r\n                    topLevelQuaternion = Quaternion.Identity();\r\n                }\r\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\r\n                topLevelMatrix.invertToRef(this._tmpMatrix);\r\n                const wm = object.computeWorldMatrix(false);\r\n                localMatrix = wm.multiply(this._tmpMatrix);\r\n            } else {\r\n                // current top level is same as object level -> only use local scaling\r\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                localMatrix = this._tmpMatrix;\r\n            }\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    v = Vector3.TransformCoordinates(v, localMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const newPoints = [];\r\n            const newNorms = [];\r\n            for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            const vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const triPoints = [];\r\n                const triNorms = [];\r\n                for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\r\n\r\n                const nbVertices = vertexPositions.length / 3;\r\n                const bodyVertices = softBody.get_m_nodes();\r\n                let node: any;\r\n                let nodeNormals: any;\r\n                for (let i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const len = vertexPositions.length;\r\n                const segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                const segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        let len: number;\r\n        let segments: number;\r\n        const vertex_data = this._softVertexData(impostor);\r\n        const vertexPositions = vertex_data.positions;\r\n        const vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        const vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        const reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        const reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) {\r\n            // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        } else {\r\n            //extruded mesh\r\n            impostor._isFromLine = false;\r\n            const pathVectors = impostor.getParam(\"path\");\r\n            const shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\r\n\r\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue: any;\r\n        const extendSize = impostor.getObjectExtendSize();\r\n\r\n        if (!ignoreChildren) {\r\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            let childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                const childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    const shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    const parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    const s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(\r\n                        childMesh.rotationQuaternion!.x,\r\n                        childMesh.rotationQuaternion!.y,\r\n                        childMesh.rotationQuaternion!.z,\r\n                        childMesh.rotationQuaternion!.w\r\n                    );\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    const shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\r\n                if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 0.0001) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    const radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                {\r\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\r\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\r\n                    const capRadius = extendSize.x / 2;\r\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, extendSize.y - capRadius * 2);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    if (this.onCreateCustomMeshImpostor) {\r\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\r\n                    } else {\r\n                        const tetraMesh = new this.bjsAMMO.btTriangleMesh();\r\n                        impostor._pluginData.toDispose.push(tetraMesh);\r\n                        const triangeCount = this._addMeshVerts(tetraMesh, object, object);\r\n                        if (triangeCount == 0) {\r\n                            returnValue = new this.bjsAMMO.btCompoundShape();\r\n                        } else {\r\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // Otherwise create convexHullImpostor\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsImpostor.ConvexHullImpostor: {\r\n                if (this.onCreateCustomConvexHullImpostor) {\r\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\r\n                } else {\r\n                    const convexMesh = new this.bjsAMMO.btConvexHullShape();\r\n                    const triangeCount = this._addHullVerts(convexMesh, object, object);\r\n                    if (triangeCount == 0) {\r\n                        // Cleanup Unused Convex Hull Shape\r\n                        impostor._pluginData.toDispose.push(convexMesh);\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = convexMesh;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics body position/rotation from the babylon mesh's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(\r\n                    this._tmpAmmoTransform.getRotation().x(),\r\n                    this._tmpAmmoTransform.getRotation().y(),\r\n                    this._tmpAmmoTransform.getRotation().z(),\r\n                    this._tmpAmmoTransform.getRotation().w()\r\n                );\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(\r\n                this._tmpAmmoTransform.getRotation().x(),\r\n                this._tmpAmmoTransform.getRotation().y(),\r\n                this._tmpAmmoTransform.getRotation().z(),\r\n                this._tmpAmmoTransform.getRotation().w()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                const motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.linearVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.angularVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        } else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        } else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets restitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            } else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        } else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        } else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        } else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append an anchor to a cloth object\r\n     * @param impostor is the cloth impostor to add anchor to\r\n     * @param otherImpostor is the rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendAnchor(\r\n        impostor: PhysicsImpostor,\r\n        otherImpostor: PhysicsImpostor,\r\n        width: number,\r\n        height: number,\r\n        influence: number = 1,\r\n        noCollisionBetweenLinkedBodies: boolean = false\r\n    ) {\r\n        const segs = impostor.segments;\r\n        const nbAcross = Math.round((segs - 1) * width);\r\n        const nbUp = Math.round((segs - 1) * height);\r\n        const nbDown = segs - 1 - nbUp;\r\n        const node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        const node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.forceActivationState(0);\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     */\r\n    public updateDistanceJoint() {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     */\r\n    public setLimit() {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const exntend = impostor.getObjectExtendSize();\r\n        return exntend.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const exntend = impostor.getObjectExtendSize();\r\n        result.x = exntend.x;\r\n        result.y = exntend.y;\r\n        result.z = exntend.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of tmp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            this._raycastResult.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n        return this._raycastResult;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}