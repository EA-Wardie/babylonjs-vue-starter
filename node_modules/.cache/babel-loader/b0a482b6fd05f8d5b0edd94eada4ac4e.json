{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { PointerDragBehavior } from \"./pointerDragBehavior.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be scaled\n */\n\nvar MultiPointerScaleBehavior =\n/** @class */\nfunction () {\n  /**\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\n   */\n  function MultiPointerScaleBehavior() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n\n  Object.defineProperty(MultiPointerScaleBehavior.prototype, \"name\", {\n    /**\n     *  The name of the behavior\n     */\n    get: function get() {\n      return \"MultiPointerScale\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   *  Initializes the behavior\n   */\n\n  MultiPointerScaleBehavior.prototype.init = function () {};\n\n  MultiPointerScaleBehavior.prototype._getCurrentDistance = function () {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  };\n  /**\n   * Attaches the scale behavior the passed in mesh\n   * @param ownerNode The mesh that will be scaled around once attached\n   */\n\n\n  MultiPointerScaleBehavior.prototype.attach = function (ownerNode) {\n    var _this = this;\n\n    this._ownerNode = ownerNode; // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n\n    this._dragBehaviorA.onDragStartObservable.add(function () {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerId == _this._dragBehaviorB.currentDraggingPointerId) {\n          _this._dragBehaviorA.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    });\n\n    this._dragBehaviorB.onDragStartObservable.add(function () {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerId == _this._dragBehaviorB.currentDraggingPointerId) {\n          _this._dragBehaviorB.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    }); // Once both drag behaviors are active scale based on the distance between the two pointers\n\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragObservable.add(function () {\n        if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n          var ratio = _this._getCurrentDistance() / _this._startDistance;\n\n          _this._initialScale.scaleToRef(ratio, _this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB); // On every frame move towards target scaling to avoid jitter caused by vr controllers\n\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        var change = _this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  };\n  /**\n   *  Detaches the behavior from the mesh\n   */\n\n\n  MultiPointerScaleBehavior.prototype.detach = function () {\n    var _this = this;\n\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n\n      _this._ownerNode.removeBehavior(behavior);\n    });\n  };\n\n  return MultiPointerScaleBehavior;\n}();\n\nexport { MultiPointerScaleBehavior };","map":{"version":3,"mappings":"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","names":["PointerDragBehavior","Vector3","_dragBehaviorA","moveAttached","_dragBehaviorB","Object","MultiPointerScaleBehavior","lastDragPosition","subtract","length","ownerNode","_ownerNode","onDragStartObservable","add","_this","dragging","currentDraggingPointerId","releaseDrag","_initialScale","copyFrom","scaling","_startDistance","_getCurrentDistance","forEach","behavior","onDragObservable","ratio","scaleToRef","_targetScale","addBehavior","_sceneRenderObserver","getScene","onBeforeRenderObservable","change","scaleInPlace","addInPlace","remove","clear","removeBehavior"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/multiPointerScaleBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport { PointerDragBehavior } from \"./pointerDragBehavior\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\r\nexport class MultiPointerScaleBehavior implements Behavior<Mesh> {\r\n    private _dragBehaviorA: PointerDragBehavior;\r\n    private _dragBehaviorB: PointerDragBehavior;\r\n    private _startDistance = 0;\r\n    private _initialScale = new Vector3(0, 0, 0);\r\n    private _targetScale = new Vector3(0, 0, 0);\r\n    private _ownerNode: Mesh;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n     */\r\n    constructor() {\r\n        this._dragBehaviorA = new PointerDragBehavior({});\r\n        this._dragBehaviorA.moveAttached = false;\r\n        this._dragBehaviorB = new PointerDragBehavior({});\r\n        this._dragBehaviorB.moveAttached = false;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"MultiPointerScale\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _getCurrentDistance() {\r\n        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n\r\n        // Create 2 drag behaviors such that each will only be triggered by a separate pointer\r\n        this._dragBehaviorA.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorA.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n        this._dragBehaviorB.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorB.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Once both drag behaviors are active scale based on the distance between the two pointers\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragObservable.add(() => {\r\n                if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                    const ratio = this._getCurrentDistance() / this._startDistance;\r\n                    this._initialScale.scaleToRef(ratio, this._targetScale);\r\n                }\r\n            });\r\n        });\r\n\r\n        ownerNode.addBehavior(this._dragBehaviorA);\r\n        ownerNode.addBehavior(this._dragBehaviorB);\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\r\n                if (change.length() > 0.01) {\r\n                    ownerNode.scaling.addInPlace(change);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragStartObservable.clear();\r\n            behavior.onDragObservable.clear();\r\n            this._ownerNode.removeBehavior(behavior);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}