{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __extends } from \"tslib\";\n/**\n * Helper class to push actions to a pool of workers.\n */\n\nvar WorkerPool =\n/** @class */\nfunction () {\n  /**\n   * Constructor\n   * @param workers Array of workers to use for actions\n   */\n  function WorkerPool(workers) {\n    this._pendingActions = new Array();\n    this._workerInfos = workers.map(function (worker) {\n      return {\n        workerPromise: Promise.resolve(worker),\n        idle: true\n      };\n    });\n  }\n  /**\n   * Terminates all workers and clears any pending actions.\n   */\n\n\n  WorkerPool.prototype.dispose = function () {\n    for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {\n      var workerInfo = _a[_i];\n      workerInfo.workerPromise.then(function (worker) {\n        worker.terminate();\n      });\n    }\n\n    this._workerInfos.length = 0;\n    this._pendingActions.length = 0;\n  };\n  /**\n   * Pushes an action to the worker pool. If all the workers are active, the action will be\n   * pended until a worker has completed its action.\n   * @param action The action to perform. Call onComplete when the action is complete.\n   */\n\n\n  WorkerPool.prototype.push = function (action) {\n    if (!this._executeOnIdleWorker(action)) {\n      this._pendingActions.push(action);\n    }\n  };\n\n  WorkerPool.prototype._executeOnIdleWorker = function (action) {\n    for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {\n      var workerInfo = _a[_i];\n\n      if (workerInfo.idle) {\n        this._execute(workerInfo, action);\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  WorkerPool.prototype._execute = function (workerInfo, action) {\n    var _this = this;\n\n    workerInfo.idle = false;\n    workerInfo.workerPromise.then(function (worker) {\n      action(worker, function () {\n        var nextAction = _this._pendingActions.shift();\n\n        if (nextAction) {\n          _this._execute(workerInfo, nextAction);\n        } else {\n          workerInfo.idle = true;\n        }\n      });\n    });\n  };\n\n  return WorkerPool;\n}();\n\nexport { WorkerPool };\n/**\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\n */\n\nvar AutoReleaseWorkerPool =\n/** @class */\nfunction (_super) {\n  __extends(AutoReleaseWorkerPool, _super);\n\n  function AutoReleaseWorkerPool(maxWorkers, createWorkerAsync, options) {\n    if (options === void 0) {\n      options = AutoReleaseWorkerPool.DefaultOptions;\n    }\n\n    var _this = _super.call(this, []) || this;\n\n    _this._maxWorkers = maxWorkers;\n    _this._createWorkerAsync = createWorkerAsync;\n    _this._options = options;\n    return _this;\n  }\n\n  AutoReleaseWorkerPool.prototype.push = function (action) {\n    if (!this._executeOnIdleWorker(action)) {\n      if (this._workerInfos.length < this._maxWorkers) {\n        var workerInfo = {\n          workerPromise: this._createWorkerAsync(),\n          idle: false\n        };\n\n        this._workerInfos.push(workerInfo);\n\n        this._execute(workerInfo, action);\n      } else {\n        this._pendingActions.push(action);\n      }\n    }\n  };\n\n  AutoReleaseWorkerPool.prototype._execute = function (workerInfo, action) {\n    var _this = this; // Reset the idle timeout.\n\n\n    if (workerInfo.timeoutId) {\n      clearTimeout(workerInfo.timeoutId);\n      delete workerInfo.timeoutId;\n    }\n\n    _super.prototype._execute.call(this, workerInfo, function (worker, onComplete) {\n      action(worker, function () {\n        onComplete();\n\n        if (workerInfo.idle) {\n          // Schedule the worker to be terminated after the elapsed time.\n          workerInfo.timeoutId = setTimeout(function () {\n            workerInfo.workerPromise.then(function (worker) {\n              worker.terminate();\n            });\n\n            var indexOf = _this._workerInfos.indexOf(workerInfo);\n\n            if (indexOf !== -1) {\n              _this._workerInfos.splice(indexOf, 1);\n            }\n          }, _this._options.idleTimeElapsedBeforeRelease);\n        }\n      });\n    });\n  };\n  /**\n   * Default options for the constructor.\n   * Override to change the defaults.\n   */\n\n\n  AutoReleaseWorkerPool.DefaultOptions = {\n    idleTimeElapsedBeforeRelease: 1000\n  };\n  return AutoReleaseWorkerPool;\n}(WorkerPool);\n\nexport { AutoReleaseWorkerPool };","map":{"version":3,"mappings":"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","names":["workers","Array","_workerInfos","map","worker","workerPromise","Promise","resolve","idle","WorkerPool","_i","workerInfo","then","terminate","length","_pendingActions","action","_executeOnIdleWorker","push","_execute","nextAction","_this","shift","__extends","maxWorkers","createWorkerAsync","options","AutoReleaseWorkerPool","DefaultOptions","_super","_maxWorkers","_createWorkerAsync","_options","timeoutId","clearTimeout","call","onComplete","setTimeout","indexOf","splice","idleTimeElapsedBeforeRelease"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/workerPool.ts"],"sourcesContent":["import type { IDisposable } from \"../scene\";\r\n\r\n/** @ignore */\r\ninterface WorkerInfo {\r\n    workerPromise: Promise<Worker>;\r\n    idle: boolean;\r\n    timeoutId?: ReturnType<typeof setTimeout>;\r\n}\r\n\r\n/**\r\n * Helper class to push actions to a pool of workers.\r\n */\r\nexport class WorkerPool implements IDisposable {\r\n    protected _workerInfos: Array<WorkerInfo>;\r\n    protected _pendingActions = new Array<(worker: Worker, onComplete: () => void) => void>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param workers Array of workers to use for actions\r\n     */\r\n    constructor(workers: Array<Worker>) {\r\n        this._workerInfos = workers.map((worker) => ({\r\n            workerPromise: Promise.resolve(worker),\r\n            idle: true,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Terminates all workers and clears any pending actions.\r\n     */\r\n    public dispose(): void {\r\n        for (const workerInfo of this._workerInfos) {\r\n            workerInfo.workerPromise.then((worker) => {\r\n                worker.terminate();\r\n            });\r\n        }\r\n\r\n        this._workerInfos.length = 0;\r\n        this._pendingActions.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\r\n     * pended until a worker has completed its action.\r\n     * @param action The action to perform. Call onComplete when the action is complete.\r\n     */\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            this._pendingActions.push(action);\r\n        }\r\n    }\r\n\r\n    protected _executeOnIdleWorker(action: (worker: Worker, onComplete: () => void) => void): boolean {\r\n        for (const workerInfo of this._workerInfos) {\r\n            if (workerInfo.idle) {\r\n                this._execute(workerInfo, action);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        workerInfo.idle = false;\r\n        workerInfo.workerPromise.then((worker) => {\r\n            action(worker, () => {\r\n                const nextAction = this._pendingActions.shift();\r\n                if (nextAction) {\r\n                    this._execute(workerInfo, nextAction);\r\n                } else {\r\n                    workerInfo.idle = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Options for AutoReleaseWorkerPool\r\n */\r\nexport interface AutoReleaseWorkerPoolOptions {\r\n    /**\r\n     * Idle time elapsed before workers are terminated.\r\n     */\r\n    idleTimeElapsedBeforeRelease: number;\r\n}\r\n\r\n/**\r\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\r\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\r\n */\r\nexport class AutoReleaseWorkerPool extends WorkerPool {\r\n    /**\r\n     * Default options for the constructor.\r\n     * Override to change the defaults.\r\n     */\r\n    public static DefaultOptions: AutoReleaseWorkerPoolOptions = {\r\n        idleTimeElapsedBeforeRelease: 1000,\r\n    };\r\n\r\n    private readonly _maxWorkers: number;\r\n    private readonly _createWorkerAsync: () => Promise<Worker>;\r\n    private readonly _options: AutoReleaseWorkerPoolOptions;\r\n\r\n    constructor(maxWorkers: number, createWorkerAsync: () => Promise<Worker>, options = AutoReleaseWorkerPool.DefaultOptions) {\r\n        super([]);\r\n\r\n        this._maxWorkers = maxWorkers;\r\n        this._createWorkerAsync = createWorkerAsync;\r\n        this._options = options;\r\n    }\r\n\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            if (this._workerInfos.length < this._maxWorkers) {\r\n                const workerInfo: WorkerInfo = {\r\n                    workerPromise: this._createWorkerAsync(),\r\n                    idle: false,\r\n                };\r\n                this._workerInfos.push(workerInfo);\r\n                this._execute(workerInfo, action);\r\n            } else {\r\n                this._pendingActions.push(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        // Reset the idle timeout.\r\n        if (workerInfo.timeoutId) {\r\n            clearTimeout(workerInfo.timeoutId);\r\n            delete workerInfo.timeoutId;\r\n        }\r\n\r\n        super._execute(workerInfo, (worker, onComplete) => {\r\n            action(worker, () => {\r\n                onComplete();\r\n\r\n                if (workerInfo.idle) {\r\n                    // Schedule the worker to be terminated after the elapsed time.\r\n                    workerInfo.timeoutId = setTimeout(() => {\r\n                        workerInfo.workerPromise.then((worker) => {\r\n                            worker.terminate();\r\n                        });\r\n\r\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\r\n                        if (indexOf !== -1) {\r\n                            this._workerInfos.splice(indexOf, 1);\r\n                        }\r\n                    }, this._options.idleTimeElapsedBeforeRelease);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}