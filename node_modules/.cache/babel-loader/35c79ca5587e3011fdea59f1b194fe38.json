{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { EventConstants } from \"../../Events/deviceInputEvents.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Firefox uses a different scheme to report scroll distances to other\n * browsers. Rather than use complicated methods to calculate the exact\n * multiple we need to apply, let's just cheat and use a constant.\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\n */\n\nvar ffMultiplier = 40;\n/**\n * Manage the mouse wheel inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\n */\n\nvar ArcRotateCameraMouseWheelInput =\n/** @class */\nfunction () {\n  function ArcRotateCameraMouseWheelInput() {\n    /**\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\n     */\n    this.wheelPrecision = 3.0;\n    /**\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\n     * zooms to the location of the mouse pointer or not.  The default is false.\n     */\n\n    this.zoomToMouseLocation = false;\n    /**\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\n     */\n\n    this.wheelDeltaPercentage = 0;\n    /**\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\n     */\n\n    this.customComputeDeltaFromMouseWheel = null;\n    this._inertialPanning = Vector3.Zero();\n  }\n\n  ArcRotateCameraMouseWheelInput.prototype._computeDeltaFromMouseWheelLegacyEvent = function (mouseWheelDelta, radius) {\n    var delta = 0;\n    var wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\n\n    if (mouseWheelDelta > 0) {\n      delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\n    } else {\n      delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\n    }\n\n    return delta;\n  };\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n\n\n  ArcRotateCameraMouseWheelInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this; // was there a second variable defined?\n    // eslint-disable-next-line prefer-rest-params\n\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n\n    this._wheel = function (p) {\n      //sanity check - this should be a PointerWheel event.\n      if (p.type !== PointerEventTypes.POINTERWHEEL) {\n        return;\n      }\n\n      var event = p.event;\n      var delta = 0;\n      var mouseWheelLegacyEvent = event;\n      var wheelDelta = 0;\n      var platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\n\n      if (event.deltaY !== undefined) {\n        wheelDelta = -(event.deltaY * platformScale);\n      } else if (event.wheelDeltaY !== undefined) {\n        wheelDelta = -(event.wheelDeltaY * platformScale);\n      } else {\n        wheelDelta = mouseWheelLegacyEvent.wheelDelta;\n      }\n\n      if (_this.customComputeDeltaFromMouseWheel) {\n        delta = _this.customComputeDeltaFromMouseWheel(wheelDelta, _this, event);\n      } else {\n        if (_this.wheelDeltaPercentage) {\n          delta = _this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, _this.camera.radius); // If zooming in, estimate the target radius and use that to compute the delta for inertia\n          // this will stop multiple scroll events zooming in from adding too much inertia\n\n          if (delta > 0) {\n            var estimatedTargetRadius = _this.camera.radius;\n            var targetInertia = _this.camera.inertialRadiusOffset + delta;\n\n            for (var i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\n              estimatedTargetRadius -= targetInertia;\n              targetInertia *= _this.camera.inertia;\n            }\n\n            estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\n            delta = _this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\n          }\n        } else {\n          delta = wheelDelta / (_this.wheelPrecision * 40);\n        }\n      }\n\n      if (delta) {\n        if (_this.zoomToMouseLocation && _this._hitPlane) {\n          _this._zoomToMouse(delta);\n        } else {\n          _this.camera.inertialRadiusOffset += delta;\n        }\n      }\n\n      if (event.preventDefault) {\n        if (!noPreventDefault) {\n          event.preventDefault();\n        }\n      }\n    };\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\n\n    if (this.zoomToMouseLocation) {\n      this._inertialPanning.setAll(0);\n    }\n  };\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n\n\n  ArcRotateCameraMouseWheelInput.prototype.detachControl = function () {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this._observer = null;\n      this._wheel = null;\n    }\n  };\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n\n\n  ArcRotateCameraMouseWheelInput.prototype.checkInputs = function () {\n    if (!this.zoomToMouseLocation) {\n      return;\n    }\n\n    var camera = this.camera;\n    var motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\n\n    if (motion) {\n      // if zooming is still happening as a result of inertia, then we also need to update\n      // the hit plane.\n      this._updateHitPlane(); // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\n      // uses a different panningInertia which could cause this panning to get out of sync with\n      // the zooming, and for this to work they must be exactly in sync.\n\n\n      camera.target.addInPlace(this._inertialPanning);\n\n      this._inertialPanning.scaleInPlace(camera.inertia);\n\n      this._zeroIfClose(this._inertialPanning);\n    }\n  };\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n\n\n  ArcRotateCameraMouseWheelInput.prototype.getClassName = function () {\n    return \"ArcRotateCameraMouseWheelInput\";\n  };\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n\n\n  ArcRotateCameraMouseWheelInput.prototype.getSimpleName = function () {\n    return \"mousewheel\";\n  };\n\n  ArcRotateCameraMouseWheelInput.prototype._updateHitPlane = function () {\n    var camera = this.camera;\n    var direction = camera.target.subtract(camera.position);\n    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\n  }; // Get position on the hit plane\n\n\n  ArcRotateCameraMouseWheelInput.prototype._getPosition = function () {\n    var _a;\n\n    var camera = this.camera;\n    var scene = camera.getScene(); // since the _hitPlane is always updated to be orthogonal to the camera position vector\n    // we don't have to worry about this ray shooting off to infinity. This ray creates\n    // a vector defining where we want to zoom to.\n\n    var ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\n    var distance = 0;\n\n    if (this._hitPlane) {\n      distance = (_a = ray.intersectsPlane(this._hitPlane)) !== null && _a !== void 0 ? _a : 0;\n    } // not using this ray again, so modifying its vectors here is fine\n\n\n    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\n  };\n\n  ArcRotateCameraMouseWheelInput.prototype._zoomToMouse = function (delta) {\n    var _a, _b;\n\n    var camera = this.camera;\n    var inertiaComp = 1 - camera.inertia;\n\n    if (camera.lowerRadiusLimit) {\n      var lowerLimit = (_a = camera.lowerRadiusLimit) !== null && _a !== void 0 ? _a : 0;\n\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\n        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n\n    if (camera.upperRadiusLimit) {\n      var upperLimit = (_b = camera.upperRadiusLimit) !== null && _b !== void 0 ? _b : 0;\n\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\n        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n\n    var zoomDistance = delta / inertiaComp;\n    var ratio = zoomDistance / camera.radius;\n\n    var vec = this._getPosition(); // Now this vector tells us how much we also need to pan the camera\n    // so the targeted mouse location becomes the center of zooming.\n\n\n    var directionToZoomLocation = TmpVectors.Vector3[6];\n    vec.subtractToRef(camera.target, directionToZoomLocation);\n    directionToZoomLocation.scaleInPlace(ratio);\n    directionToZoomLocation.scaleInPlace(inertiaComp);\n\n    this._inertialPanning.addInPlace(directionToZoomLocation);\n\n    camera.inertialRadiusOffset += delta;\n  }; // Sets x y or z of passed in vector to zero if less than Epsilon.\n\n\n  ArcRotateCameraMouseWheelInput.prototype._zeroIfClose = function (vec) {\n    if (Math.abs(vec.x) < Epsilon) {\n      vec.x = 0;\n    }\n\n    if (Math.abs(vec.y) < Epsilon) {\n      vec.y = 0;\n    }\n\n    if (Math.abs(vec.z) < Epsilon) {\n      vec.z = 0;\n    }\n  };\n\n  __decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"zoomToMouseLocation\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\n\n  return ArcRotateCameraMouseWheelInput;\n}();\n\nexport { ArcRotateCameraMouseWheelInput };\nCameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","PointerEventTypes","Tools","Plane","Vector3","Matrix","TmpVectors","Epsilon","EventConstants","Scalar","ffMultiplier","Zero","ArcRotateCameraMouseWheelInput","mouseWheelDelta","radius","delta","wheelDelta","wheelDeltaPercentage","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","_wheel","p","type","POINTERWHEEL","event","mouseWheelLegacyEvent","platformScale","deltaMode","DOM_DELTA_LINE","deltaY","undefined","wheelDeltaY","_this","customComputeDeltaFromMouseWheel","_computeDeltaFromMouseWheelLegacyEvent","camera","estimatedTargetRadius","targetInertia","inertialRadiusOffset","i","Math","abs","inertia","Clamp","Number","MAX_VALUE","wheelPrecision","zoomToMouseLocation","_hitPlane","_zoomToMouse","preventDefault","_observer","getScene","onPointerObservable","add","_inertialPanning","setAll","remove","motion","inertialAlphaOffset","inertialBetaOffset","_updateHitPlane","target","addInPlace","scaleInPlace","_zeroIfClose","direction","subtract","position","FromPositionAndNormal","scene","ray","createPickingRay","pointerX","pointerY","Identity","distance","intersectsPlane","_a","origin","inertiaComp","lowerRadiusLimit","lowerLimit","upperRadiusLimit","upperLimit","_b","zoomDistance","ratio","vec","_getPosition","directionToZoomLocation","subtractToRef","x","y","z","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n\r\n            const mouseWheelLegacyEvent = event as any;\r\n            let wheelDelta = 0;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n            if (event.deltaY !== undefined) {\r\n                wheelDelta = -(event.deltaY * platformScale);\r\n            } else if ((<any>event).wheelDeltaY !== undefined) {\r\n                wheelDelta = -((<any>event).wheelDeltaY * platformScale);\r\n            } else {\r\n                wheelDelta = mouseWheelLegacyEvent.wheelDelta;\r\n            }\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation && this._hitPlane) {\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n"]},"metadata":{},"sourceType":"module"}