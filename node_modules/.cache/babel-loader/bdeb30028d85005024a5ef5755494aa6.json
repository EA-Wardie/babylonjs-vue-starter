{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _CreationDataStorage, Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { LinesMesh } from \"../../Meshes/linesMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * Creates the VertexData of the LineSystem\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n *  - lines an array of lines, each line being an array of successive Vector3\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n * @param options.lines\n * @param options.colors\n * @returns the VertexData of the LineSystem\n */\n\nexport function CreateLineSystemVertexData(options) {\n  var indices = [];\n  var positions = [];\n  var lines = options.lines;\n  var colors = options.colors;\n  var vertexColors = [];\n  var idx = 0;\n\n  for (var l = 0; l < lines.length; l++) {\n    var points = lines[l];\n\n    for (var index = 0; index < points.length; index++) {\n      positions.push(points[index].x, points[index].y, points[index].z);\n\n      if (colors) {\n        var color = colors[l];\n        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n      }\n\n      if (index > 0) {\n        indices.push(idx - 1);\n        indices.push(idx);\n      }\n\n      idx++;\n    }\n  }\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n\n  if (colors) {\n    vertexData.colors = vertexColors;\n  }\n\n  return vertexData;\n}\n/**\n * Create the VertexData for a DashedLines\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n *  - points an array successive Vector3\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n *  - dashNb the intended total number of dashes, optional, default 200\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @returns the VertexData for the DashedLines\n */\n\nexport function CreateDashedLinesVertexData(options) {\n  var dashSize = options.dashSize || 3;\n  var gapSize = options.gapSize || 1;\n  var dashNb = options.dashNb || 200;\n  var points = options.points;\n  var positions = new Array();\n  var indices = new Array();\n  var curvect = Vector3.Zero();\n  var lg = 0;\n  var nb = 0;\n  var shft = 0;\n  var dashshft = 0;\n  var curshft = 0;\n  var idx = 0;\n  var i = 0;\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    lg += curvect.length();\n  }\n\n  shft = lg / dashNb;\n  dashshft = dashSize * shft / (dashSize + gapSize);\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    nb = Math.floor(curvect.length() / shft);\n    curvect.normalize();\n\n    for (var j = 0; j < nb; j++) {\n      curshft = shft * j;\n      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n      indices.push(idx, idx + 1);\n      idx += 2;\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  return vertexData;\n}\n/**\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.lines\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line system mesh\n */\n\nexport function CreateLineSystem(name, options, scene) {\n  var instance = options.instance;\n  var lines = options.lines;\n  var colors = options.colors;\n\n  if (instance) {\n    // lines update\n    var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n    var vertexColor = void 0;\n    var lineColors = void 0;\n\n    if (colors) {\n      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n    }\n\n    var i = 0;\n    var c = 0;\n\n    for (var l = 0; l < lines.length; l++) {\n      var points = lines[l];\n\n      for (var p = 0; p < points.length; p++) {\n        positions[i] = points[p].x;\n        positions[i + 1] = points[p].y;\n        positions[i + 2] = points[p].z;\n\n        if (colors && vertexColor) {\n          lineColors = colors[l];\n          vertexColor[c] = lineColors[p].r;\n          vertexColor[c + 1] = lineColors[p].g;\n          vertexColor[c + 2] = lineColors[p].b;\n          vertexColor[c + 3] = lineColors[p].a;\n          c += 4;\n        }\n\n        i += 3;\n      }\n    }\n\n    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n    if (colors && vertexColor) {\n      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n    }\n\n    return instance;\n  } // line system creation\n\n\n  var useVertexColor = colors ? true : false;\n  var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\n  var vertexData = CreateLineSystemVertexData(options);\n  vertexData.applyToMesh(lineSystem, options.updatable);\n  return lineSystem;\n}\n/**\n * Creates a line mesh\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * The optional parameter `colors` is an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.points\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line mesh\n */\n\nexport function CreateLines(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var colors = options.colors ? [options.colors] : null;\n  var lines = CreateLineSystem(name, {\n    lines: [options.points],\n    updatable: options.updatable,\n    instance: options.instance,\n    colors: colors,\n    useVertexAlpha: options.useVertexAlpha,\n    material: options.material\n  }, scene);\n  return lines;\n}\n/**\n * Creates a dashed line mesh\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @param options.updatable\n * @param options.instance\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns the dashed line mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\n */\n\nexport function CreateDashedLines(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var points = options.points;\n  var instance = options.instance;\n  var gapSize = options.gapSize || 1;\n  var dashSize = options.dashSize || 3;\n\n  if (instance) {\n    //  dashed lines update\n    var positionFunction = function positionFunction(positions) {\n      var curvect = Vector3.Zero();\n      var nbSeg = positions.length / 6;\n      var lg = 0;\n      var nb = 0;\n      var shft = 0;\n      var dashshft = 0;\n      var curshft = 0;\n      var p = 0;\n      var i = 0;\n      var j = 0;\n\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        lg += curvect.length();\n      }\n\n      shft = lg / nbSeg;\n      var dashSize = instance._creationDataStorage.dashSize;\n      var gapSize = instance._creationDataStorage.gapSize;\n      dashshft = dashSize * shft / (dashSize + gapSize);\n\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        nb = Math.floor(curvect.length() / shft);\n        curvect.normalize();\n        j = 0;\n\n        while (j < nb && p < positions.length) {\n          curshft = shft * j;\n          positions[p] = points[i].x + curshft * curvect.x;\n          positions[p + 1] = points[i].y + curshft * curvect.y;\n          positions[p + 2] = points[i].z + curshft * curvect.z;\n          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n          p += 6;\n          j++;\n        }\n      }\n\n      while (p < positions.length) {\n        positions[p] = points[i].x;\n        positions[p + 1] = points[i].y;\n        positions[p + 2] = points[i].z;\n        p += 3;\n      }\n    };\n\n    instance.updateMeshPositions(positionFunction, false);\n    return instance;\n  } // dashed lines creation\n\n\n  var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\n  var vertexData = CreateDashedLinesVertexData(options);\n  vertexData.applyToMesh(dashedLines, options.updatable);\n  dashedLines._creationDataStorage = new _CreationDataStorage();\n  dashedLines._creationDataStorage.dashSize = dashSize;\n  dashedLines._creationDataStorage.gapSize = gapSize;\n  return dashedLines;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\n\nexport var LinesBuilder = {\n  CreateDashedLines: CreateDashedLines,\n  CreateLineSystem: CreateLineSystem,\n  CreateLines: CreateLines\n};\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\n\nMesh.CreateLines = function (name, points, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  if (updatable === void 0) {\n    updatable = false;\n  }\n\n  if (instance === void 0) {\n    instance = null;\n  }\n\n  var options = {\n    points: points,\n    updatable: updatable,\n    instance: instance\n  };\n  return CreateLines(name, options, scene);\n};\n\nMesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    points: points,\n    dashSize: dashSize,\n    gapSize: gapSize,\n    dashNb: dashNb,\n    updatable: updatable,\n    instance: instance\n  };\n  return CreateDashedLines(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","_CreationDataStorage","Mesh","VertexData","LinesMesh","VertexBuffer","CreateLineSystemVertexData","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","x","y","z","color","r","g","b","a","vertexData","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","Array","curvect","Zero","lg","nb","shft","dashshft","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLineSystem","name","scene","instance","getVerticesData","PositionKind","vertexColor","lineColors","ColorKind","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","material","applyToMesh","updatable","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","updateMeshPositions","dashedLines","LinesBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/linesBuilder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\n\r\ndeclare type Material = import(\"../../Materials/material\").Material;\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene>\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\n(Mesh as any).CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}