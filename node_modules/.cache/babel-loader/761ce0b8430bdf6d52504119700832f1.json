{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a cone.\n * It emits the particles alongside the cone volume from the base to the particle.\n * The emission direction might be randomized.\n */\n\nvar ConeParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance ConeParticleEmitter\n   * @param radius the radius of the emission cone (1 by default)\n   * @param angle the cone base angle (PI by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\n   */\n  function ConeParticleEmitter(radius, angle,\n  /** defines how much to randomize the particle direction [0-1] (default is 0) */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (angle === void 0) {\n      angle = Math.PI;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.directionRandomizer = directionRandomizer;\n    /**\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n\n    this.radiusRange = 1;\n    /**\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n\n    this.heightRange = 1;\n    /**\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\n     */\n\n    this.emitFromSpawnPointOnly = false;\n    this.angle = angle;\n    this.radius = radius;\n  }\n\n  Object.defineProperty(ConeParticleEmitter.prototype, \"radius\", {\n    /**\n     * Gets or sets the radius of the emission cone\n     */\n    get: function get() {\n      return this._radius;\n    },\n    set: function set(value) {\n      this._radius = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConeParticleEmitter.prototype, \"angle\", {\n    /**\n     * Gets or sets the angle of the emission cone\n     */\n    get: function get() {\n      return this._angle;\n    },\n    set: function set(value) {\n      this._angle = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ConeParticleEmitter.prototype._buildHeight = function () {\n    if (this._angle !== 0) {\n      this._height = this._radius / Math.tan(this._angle / 2);\n    } else {\n      this._height = 1;\n    }\n  };\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n\n  ConeParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n    } else {\n      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n    }\n\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n    directionToUpdate.normalize();\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  ConeParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var s = Scalar.RandomRange(0, Math.PI * 2);\n    var h;\n\n    if (!this.emitFromSpawnPointOnly) {\n      h = Scalar.RandomRange(0, this.heightRange); // Better distribution in a cone at normal angles.\n\n      h = 1 - h * h;\n    } else {\n      h = 0.0001;\n    }\n\n    var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n    radius = radius * h;\n    var randX = radius * Math.sin(s);\n    var randZ = radius * Math.cos(s);\n    var randY = h * this._height;\n\n    if (isLocal) {\n      positionToUpdate.x = randX;\n      positionToUpdate.y = randY;\n      positionToUpdate.z = randZ;\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  ConeParticleEmitter.prototype.clone = function () {\n    var newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  ConeParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\n    uboOrEffect.setFloat(\"coneAngle\", this._angle);\n    uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  ConeParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"radius\", 2);\n    ubo.addUniform(\"coneAngle\", 1);\n    ubo.addUniform(\"height\", 2);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  ConeParticleEmitter.prototype.getEffectDefines = function () {\n    var defines = \"#define CONEEMITTER\";\n\n    if (this.emitFromSpawnPointOnly) {\n      defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n    }\n\n    return defines;\n  };\n  /**\n   * Returns the string \"ConeParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  ConeParticleEmitter.prototype.getClassName = function () {\n    return \"ConeParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  ConeParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this._radius;\n    serializationObject.angle = this._angle;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.heightRange = this.heightRange;\n    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  ConeParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.angle = serializationObject.angle;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n    this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n    this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n  };\n\n  return ConeParticleEmitter;\n}();\n\nexport { ConeParticleEmitter };","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","TmpVectors","Scalar","radius","angle","directionRandomizer","Math","PI","Object","ConeParticleEmitter","_radius","value","_buildHeight","_angle","_height","tan","worldMatrix","directionToUpdate","particle","isLocal","copyFrom","_localPosition","normalize","position","subtractToRef","getTranslation","randX","RandomRange","randY","randZ","x","y","z","positionToUpdate","s","h","emitFromSpawnPointOnly","heightRange","radiusRange","sin","cos","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setFloat2","setFloat","ubo","addUniform","defines","serializationObject","type","getClassName","undefined"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/coneParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\r\nexport class ConeParticleEmitter implements IParticleEmitterType {\r\n    private _radius: number;\r\n    private _angle: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public radiusRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public heightRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\r\n    public emitFromSpawnPointOnly = false;\r\n\r\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    private _buildHeight() {\r\n        if (this._angle !== 0) {\r\n            this._height = this._radius / Math.tan(this._angle / 2);\r\n        } else {\r\n            this._height = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConeParticleEmitter\r\n     * @param radius the radius of the emission cone (1 by default)\r\n     * @param angle the cone base angle (PI by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        angle = Math.PI,\r\n        /** defines how much to randomize the particle direction [0-1] (default is 0) */\r\n        public directionRandomizer = 0\r\n    ) {\r\n        this.angle = angle;\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition!).normalize();\r\n        } else {\r\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\r\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\r\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\r\n        directionToUpdate.normalize();\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const s = Scalar.RandomRange(0, Math.PI * 2);\r\n        let h: number;\r\n\r\n        if (!this.emitFromSpawnPointOnly) {\r\n            h = Scalar.RandomRange(0, this.heightRange);\r\n            // Better distribution in a cone at normal angles.\r\n            h = 1 - h * h;\r\n        } else {\r\n            h = 0.0001;\r\n        }\r\n        let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\r\n        radius = radius * h;\r\n\r\n        const randX = radius * Math.sin(s);\r\n        const randZ = radius * Math.cos(s);\r\n        const randY = h * this._height;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): ConeParticleEmitter {\r\n        const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\r\n        uboOrEffect.setFloat(\"coneAngle\", this._angle);\r\n        uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 2);\r\n        ubo.addUniform(\"coneAngle\", 1);\r\n        ubo.addUniform(\"height\", 2);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        let defines = \"#define CONEEMITTER\";\r\n\r\n        if (this.emitFromSpawnPointOnly) {\r\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\r\n        }\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ConeParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ConeParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this._radius;\r\n        serializationObject.angle = this._angle;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.heightRange = this.heightRange;\r\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.angle = serializationObject.angle;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n\r\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\r\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\r\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}