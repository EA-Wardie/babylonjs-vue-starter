{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3, serializeAsQuaternion, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.\n * @see https://doc.babylonjs.com/how_to/transformnode\n */\n\nvar TransformNode =\n/** @class */\nfunction (_super) {\n  __extends(TransformNode, _super);\n\n  function TransformNode(name, scene, isPure) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (isPure === void 0) {\n      isPure = true;\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._forward = new Vector3(0, 0, 1);\n    _this._up = new Vector3(0, 1, 0);\n    _this._right = new Vector3(1, 0, 0); // Properties\n\n    _this._position = Vector3.Zero();\n    _this._rotation = Vector3.Zero();\n    _this._rotationQuaternion = null;\n    _this._scaling = Vector3.One();\n    _this._transformToBoneReferal = null;\n    _this._isAbsoluteSynced = false;\n    _this._billboardMode = TransformNode.BILLBOARDMODE_NONE;\n    _this._preserveParentRotationForBillboard = false;\n    /**\n     * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube\n     */\n\n    _this.scalingDeterminant = 1;\n    _this._infiniteDistance = false;\n    /**\n     * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.\n     * By default the system will update normals to compensate\n     */\n\n    _this.ignoreNonUniformScaling = false;\n    /**\n     * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both\n     */\n\n    _this.reIntegrateRotationIntoRotationQuaternion = false; // Cache\n\n    /** @hidden */\n\n    _this._poseMatrix = null;\n    /** @hidden */\n\n    _this._localMatrix = Matrix.Zero();\n    _this._usePivotMatrix = false;\n    _this._absolutePosition = Vector3.Zero();\n    _this._absoluteScaling = Vector3.Zero();\n    _this._absoluteRotationQuaternion = Quaternion.Identity();\n    _this._pivotMatrix = Matrix.Identity();\n    /** @hidden */\n\n    _this._postMultiplyPivotMatrix = false;\n    _this._isWorldMatrixFrozen = false;\n    /** @hidden */\n\n    _this._indexInSceneTransformNodesArray = -1;\n    /**\n     * An event triggered after the world matrix is updated\n     */\n\n    _this.onAfterWorldMatrixUpdateObservable = new Observable();\n    _this._nonUniformScaling = false;\n\n    if (isPure) {\n      _this.getScene().addTransformNode(_this);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(TransformNode.prototype, \"billboardMode\", {\n    /**\n     * Gets or sets the billboard mode. Default is 0.\n     *\n     * | Value | Type | Description |\n     * | --- | --- | --- |\n     * | 0 | BILLBOARDMODE_NONE |  |\n     * | 1 | BILLBOARDMODE_X |  |\n     * | 2 | BILLBOARDMODE_Y |  |\n     * | 4 | BILLBOARDMODE_Z |  |\n     * | 7 | BILLBOARDMODE_ALL |  |\n     *\n     */\n    get: function get() {\n      return this._billboardMode;\n    },\n    set: function set(value) {\n      if (this._billboardMode === value) {\n        return;\n      }\n\n      this._billboardMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"preserveParentRotationForBillboard\", {\n    /**\n     * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.\n     * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed\n     */\n    get: function get() {\n      return this._preserveParentRotationForBillboard;\n    },\n    set: function set(value) {\n      if (value === this._preserveParentRotationForBillboard) {\n        return;\n      }\n\n      this._preserveParentRotationForBillboard = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"infiniteDistance\", {\n    /**\n     * Gets or sets the distance of the object to max, often used by skybox\n     */\n    get: function get() {\n      return this._infiniteDistance;\n    },\n    set: function set(value) {\n      if (this._infiniteDistance === value) {\n        return;\n      }\n\n      this._infiniteDistance = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"TransformNode\" string\n   */\n\n  TransformNode.prototype.getClassName = function () {\n    return \"TransformNode\";\n  };\n\n  Object.defineProperty(TransformNode.prototype, \"position\", {\n    /**\n     * Gets or set the node position (default is (0.0, 0.0, 0.0))\n     */\n    get: function get() {\n      return this._position;\n    },\n    set: function set(newPosition) {\n      this._position = newPosition;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * return true if a pivot has been set\n   * @returns true if a pivot matrix is used\n   */\n\n  TransformNode.prototype.isUsingPivotMatrix = function () {\n    return this._usePivotMatrix;\n  };\n\n  Object.defineProperty(TransformNode.prototype, \"rotation\", {\n    /**\n     * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).\n     * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion\n     */\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(newRotation) {\n      this._rotation = newRotation;\n      this._rotationQuaternion = null;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"scaling\", {\n    /**\n     * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).\n     */\n    get: function get() {\n      return this._scaling;\n    },\n    set: function set(newScaling) {\n      this._scaling = newScaling;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"rotationQuaternion\", {\n    /**\n     * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).\n     * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)\n     */\n    get: function get() {\n      return this._rotationQuaternion;\n    },\n    set: function set(quaternion) {\n      this._rotationQuaternion = quaternion; //reset the rotation vector.\n\n      if (quaternion) {\n        this._rotation.setAll(0.0);\n      }\n\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"forward\", {\n    /**\n     * The forward direction of that transform in world space.\n     */\n    get: function get() {\n      Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);\n      return this._forward.normalize();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"up\", {\n    /**\n     * The up direction of that transform in world space.\n     */\n    get: function get() {\n      Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);\n      return this._up.normalize();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"right\", {\n    /**\n     * The right direction of that transform in world space.\n     */\n    get: function get() {\n      Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);\n      return this._right.normalize();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Copies the parameter passed Matrix into the mesh Pose matrix.\n   * @param matrix the matrix to copy the pose from\n   * @returns this TransformNode.\n   */\n\n  TransformNode.prototype.updatePoseMatrix = function (matrix) {\n    if (!this._poseMatrix) {\n      this._poseMatrix = matrix.clone();\n      return this;\n    }\n\n    this._poseMatrix.copyFrom(matrix);\n\n    return this;\n  };\n  /**\n   * Returns the mesh Pose matrix.\n   * @returns the pose matrix\n   */\n\n\n  TransformNode.prototype.getPoseMatrix = function () {\n    if (!this._poseMatrix) {\n      this._poseMatrix = Matrix.Identity();\n    }\n\n    return this._poseMatrix;\n  };\n  /** @hidden */\n\n\n  TransformNode.prototype._isSynchronized = function () {\n    var cache = this._cache;\n\n    if (this.billboardMode !== cache.billboardMode || this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n      return false;\n    }\n\n    if (cache.pivotMatrixUpdated) {\n      return false;\n    }\n\n    if (this.infiniteDistance) {\n      return false;\n    }\n\n    if (this.position._isDirty) {\n      return false;\n    }\n\n    if (this.scaling._isDirty) {\n      return false;\n    }\n\n    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this.rotation._isDirty) {\n      return false;\n    }\n\n    return true;\n  };\n  /** @hidden */\n\n\n  TransformNode.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    var cache = this._cache;\n    cache.localMatrixUpdated = false;\n    cache.billboardMode = -1;\n    cache.infiniteDistance = false;\n  };\n\n  Object.defineProperty(TransformNode.prototype, \"absolutePosition\", {\n    /**\n     * Returns the current mesh absolute position.\n     * Returns a Vector3.\n     */\n    get: function get() {\n      return this.getAbsolutePosition();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"absoluteScaling\", {\n    /**\n     * Returns the current mesh absolute scaling.\n     * Returns a Vector3.\n     */\n    get: function get() {\n      this._syncAbsoluteScalingAndRotation();\n\n      return this._absoluteScaling;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransformNode.prototype, \"absoluteRotationQuaternion\", {\n    /**\n     * Returns the current mesh absolute rotation.\n     * Returns a Quaternion.\n     */\n    get: function get() {\n      this._syncAbsoluteScalingAndRotation();\n\n      return this._absoluteRotationQuaternion;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Sets a new matrix to apply before all other transformation\n   * @param matrix defines the transform matrix\n   * @returns the current TransformNode\n   */\n\n  TransformNode.prototype.setPreTransformMatrix = function (matrix) {\n    return this.setPivotMatrix(matrix, false);\n  };\n  /**\n   * Sets a new pivot matrix to the current node\n   * @param matrix defines the new pivot matrix to use\n   * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect\n   * @returns the current TransformNode\n   */\n\n\n  TransformNode.prototype.setPivotMatrix = function (matrix, postMultiplyPivotMatrix) {\n    if (postMultiplyPivotMatrix === void 0) {\n      postMultiplyPivotMatrix = true;\n    }\n\n    this._pivotMatrix.copyFrom(matrix);\n\n    this._usePivotMatrix = !this._pivotMatrix.isIdentity();\n    this._cache.pivotMatrixUpdated = true;\n    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;\n\n    if (this._postMultiplyPivotMatrix) {\n      if (!this._pivotMatrixInverse) {\n        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);\n      } else {\n        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Returns the mesh pivot matrix.\n   * Default : Identity.\n   * @returns the matrix\n   */\n\n\n  TransformNode.prototype.getPivotMatrix = function () {\n    return this._pivotMatrix;\n  };\n  /**\n   * Instantiate (when possible) or clone that node with its hierarchy\n   * @param newParent defines the new parent to use for the instance (or clone)\n   * @param options defines options to configure how copy is done\n   * @param options.doNotInstantiate\n   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\n   * @returns an instance (or a clone) of the current node with its hierarchy\n   */\n\n\n  TransformNode.prototype.instantiateHierarchy = function (newParent, options, onNewNodeCreated) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\n\n    if (clone) {\n      if (onNewNodeCreated) {\n        onNewNodeCreated(this, clone);\n      }\n    }\n\n    for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {\n      var child = _a[_i];\n      child.instantiateHierarchy(clone, options, onNewNodeCreated);\n    }\n\n    return clone;\n  };\n  /**\n   * Prevents the World matrix to be computed any longer\n   * @param newWorldMatrix defines an optional matrix to use as world matrix\n   * @param decompose defines whether to decompose the given newWorldMatrix or directly assign\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.freezeWorldMatrix = function (newWorldMatrix, decompose) {\n    if (newWorldMatrix === void 0) {\n      newWorldMatrix = null;\n    }\n\n    if (decompose === void 0) {\n      decompose = false;\n    }\n\n    if (newWorldMatrix) {\n      if (decompose) {\n        this._rotation.setAll(0);\n\n        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();\n        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);\n        this.computeWorldMatrix(true);\n      } else {\n        this._worldMatrix = newWorldMatrix;\n\n        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\n\n        this._afterComputeWorldMatrix();\n      }\n    } else {\n      this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\n\n      this.computeWorldMatrix(true);\n    }\n\n    this._isDirty = false;\n    this._isWorldMatrixFrozen = true;\n    return this;\n  };\n  /**\n   * Allows back the World matrix computation.\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.unfreezeWorldMatrix = function () {\n    this._isWorldMatrixFrozen = false;\n    this.computeWorldMatrix(true);\n    return this;\n  };\n\n  Object.defineProperty(TransformNode.prototype, \"isWorldMatrixFrozen\", {\n    /**\n     * True if the World matrix has been frozen.\n     */\n    get: function get() {\n      return this._isWorldMatrixFrozen;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the mesh absolute position in the World.\n   * @returns a Vector3.\n   */\n\n  TransformNode.prototype.getAbsolutePosition = function () {\n    this.computeWorldMatrix();\n    return this._absolutePosition;\n  };\n  /**\n   * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\n   * @param absolutePosition the absolute position to set\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.setAbsolutePosition = function (absolutePosition) {\n    if (!absolutePosition) {\n      return this;\n    }\n\n    var absolutePositionX;\n    var absolutePositionY;\n    var absolutePositionZ;\n\n    if (absolutePosition.x === undefined) {\n      if (arguments.length < 3) {\n        return this;\n      }\n\n      absolutePositionX = arguments[0];\n      absolutePositionY = arguments[1];\n      absolutePositionZ = arguments[2];\n    } else {\n      absolutePositionX = absolutePosition.x;\n      absolutePositionY = absolutePosition.y;\n      absolutePositionZ = absolutePosition.z;\n    }\n\n    if (this.parent) {\n      var invertParentWorldMatrix = TmpVectors.Matrix[0];\n      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\n      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);\n    } else {\n      this.position.x = absolutePositionX;\n      this.position.y = absolutePositionY;\n      this.position.z = absolutePositionZ;\n    }\n\n    this._absolutePosition.copyFrom(absolutePosition);\n\n    return this;\n  };\n  /**\n   * Sets the mesh position in its local space.\n   * @param vector3 the position to set in localspace\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.setPositionWithLocalVector = function (vector3) {\n    this.computeWorldMatrix();\n    this.position = Vector3.TransformNormal(vector3, this._localMatrix);\n    return this;\n  };\n  /**\n   * Returns the mesh position in the local space from the current World matrix values.\n   * @returns a new Vector3.\n   */\n\n\n  TransformNode.prototype.getPositionExpressedInLocalSpace = function () {\n    this.computeWorldMatrix();\n    var invLocalWorldMatrix = TmpVectors.Matrix[0];\n\n    this._localMatrix.invertToRef(invLocalWorldMatrix);\n\n    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);\n  };\n  /**\n   * Translates the mesh along the passed Vector3 in its local space.\n   * @param vector3 the distance to translate in localspace\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.locallyTranslate = function (vector3) {\n    this.computeWorldMatrix(true);\n    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);\n    return this;\n  };\n  /**\n   * Orients a mesh towards a target point. Mesh must be drawn facing user.\n   * @param targetPoint the position (must be in same space as current mesh) to look at\n   * @param yawCor optional yaw (y-axis) correction in radians\n   * @param pitchCor optional pitch (x-axis) correction in radians\n   * @param rollCor optional roll (z-axis) correction in radians\n   * @param space the chosen space of the target\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.lookAt = function (targetPoint, yawCor, pitchCor, rollCor, space) {\n    if (yawCor === void 0) {\n      yawCor = 0;\n    }\n\n    if (pitchCor === void 0) {\n      pitchCor = 0;\n    }\n\n    if (rollCor === void 0) {\n      rollCor = 0;\n    }\n\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var dv = TransformNode._LookAtVectorCache;\n    var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();\n    targetPoint.subtractToRef(pos, dv);\n    this.setDirection(dv, yawCor, pitchCor, rollCor); // Correct for parent's rotation offset\n\n    if (space === Space.WORLD && this.parent) {\n      if (this.rotationQuaternion) {\n        // Get local rotation matrix of the looking object\n        var rotationMatrix = TmpVectors.Matrix[0];\n        this.rotationQuaternion.toRotationMatrix(rotationMatrix); // Offset rotation by parent's inverted rotation matrix to correct in world space\n\n        var parentRotationMatrix = TmpVectors.Matrix[1];\n        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\n        parentRotationMatrix.invert();\n        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\n        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);\n      } else {\n        // Get local rotation matrix of the looking object\n        var quaternionRotation = TmpVectors.Quaternion[0];\n        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);\n        var rotationMatrix = TmpVectors.Matrix[0];\n        quaternionRotation.toRotationMatrix(rotationMatrix); // Offset rotation by parent's inverted rotation matrix to correct in world space\n\n        var parentRotationMatrix = TmpVectors.Matrix[1];\n        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\n        parentRotationMatrix.invert();\n        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\n        quaternionRotation.fromRotationMatrix(rotationMatrix);\n        quaternionRotation.toEulerAnglesToRef(this.rotation);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\n   * This Vector3 is expressed in the World space.\n   * @param localAxis axis to rotate\n   * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\n   */\n\n\n  TransformNode.prototype.getDirection = function (localAxis) {\n    var result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, result);\n    return result;\n  };\n  /**\n   * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\n   * localAxis is expressed in the mesh local space.\n   * result is computed in the World space from the mesh World matrix.\n   * @param localAxis axis to rotate\n   * @param result the resulting transformnode\n   * @returns this TransformNode.\n   */\n\n\n  TransformNode.prototype.getDirectionToRef = function (localAxis, result) {\n    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n    return this;\n  };\n  /**\n   * Sets this transform node rotation to the given local axis.\n   * @param localAxis the axis in local space\n   * @param yawCor optional yaw (y-axis) correction in radians\n   * @param pitchCor optional pitch (x-axis) correction in radians\n   * @param rollCor optional roll (z-axis) correction in radians\n   * @returns this TransformNode\n   */\n\n\n  TransformNode.prototype.setDirection = function (localAxis, yawCor, pitchCor, rollCor) {\n    if (yawCor === void 0) {\n      yawCor = 0;\n    }\n\n    if (pitchCor === void 0) {\n      pitchCor = 0;\n    }\n\n    if (rollCor === void 0) {\n      rollCor = 0;\n    }\n\n    var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\n    var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\n    var pitch = -Math.atan2(localAxis.y, len);\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\n    } else {\n      this.rotation.x = pitch + pitchCor;\n      this.rotation.y = yaw + yawCor;\n      this.rotation.z = rollCor;\n    }\n\n    return this;\n  };\n  /**\n   * Sets a new pivot point to the current node\n   * @param point defines the new pivot point to use\n   * @param space defines if the point is in world or local space (local by default)\n   * @returns the current TransformNode\n   */\n\n\n  TransformNode.prototype.setPivotPoint = function (point, space) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (this.getScene().getRenderId() == 0) {\n      this.computeWorldMatrix(true);\n    }\n\n    var wm = this.getWorldMatrix();\n\n    if (space == Space.WORLD) {\n      var tmat = TmpVectors.Matrix[0];\n      wm.invertToRef(tmat);\n      point = Vector3.TransformCoordinates(point, tmat);\n    }\n\n    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);\n  };\n  /**\n   * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\n   * @returns the pivot point\n   */\n\n\n  TransformNode.prototype.getPivotPoint = function () {\n    var point = Vector3.Zero();\n    this.getPivotPointToRef(point);\n    return point;\n  };\n  /**\n   * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\n   * @param result the vector3 to store the result\n   * @returns this TransformNode.\n   */\n\n\n  TransformNode.prototype.getPivotPointToRef = function (result) {\n    result.x = -this._pivotMatrix.m[12];\n    result.y = -this._pivotMatrix.m[13];\n    result.z = -this._pivotMatrix.m[14];\n    return this;\n  };\n  /**\n   * Returns a new Vector3 set with the mesh pivot point World coordinates.\n   * @returns a new Vector3 set with the mesh pivot point World coordinates.\n   */\n\n\n  TransformNode.prototype.getAbsolutePivotPoint = function () {\n    var point = Vector3.Zero();\n    this.getAbsolutePivotPointToRef(point);\n    return point;\n  };\n  /**\n   * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\n   * @param result vector3 to store the result\n   * @returns this TransformNode.\n   */\n\n\n  TransformNode.prototype.getAbsolutePivotPointToRef = function (result) {\n    this.getPivotPointToRef(result);\n    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\n    return this;\n  };\n  /**\n   * Flag the transform node as dirty (Forcing it to update everything)\n   * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\n   * @returns this  node\n   */\n\n\n  TransformNode.prototype.markAsDirty = function (property) {\n    // We need to explicitly update the children\n    // as the scene.evaluateActiveMeshes will not poll the transform nodes\n    if (this._children) {\n      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        child.markAsDirty(property);\n      }\n    }\n\n    return _super.prototype.markAsDirty.call(this, property);\n  };\n  /**\n   * Defines the passed node as the parent of the current node.\n   * The node will remain exactly where it is and its position / rotation will be updated accordingly.\n   * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.\n   * In that case the node will not remain in the same space as it is, as the pivot will be applied.\n   * @see https://doc.babylonjs.com/how_to/parenting\n   * @param node the node ot set as the parent\n   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n   * @returns this TransformNode.\n   */\n\n\n  TransformNode.prototype.setParent = function (node, preserveScalingSign) {\n    if (preserveScalingSign === void 0) {\n      preserveScalingSign = false;\n    }\n\n    if (!node && !this.parent) {\n      return this;\n    }\n\n    var quatRotation = TmpVectors.Quaternion[0];\n    var position = TmpVectors.Vector3[0];\n    var scale = TmpVectors.Vector3[1];\n    var invParentMatrix = TmpVectors.Matrix[1];\n    Matrix.IdentityToRef(invParentMatrix);\n    var composedMatrix = TmpVectors.Matrix[0];\n    this.computeWorldMatrix(true);\n    var currentRotation = this.rotationQuaternion;\n\n    if (!currentRotation) {\n      currentRotation = TransformNode._TmpRotation;\n      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);\n    } // current global transformation without pivot\n\n\n    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);\n\n    if (this.parent) {\n      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);\n    } // is a node was set, calculate the difference between this and the node\n\n\n    if (node) {\n      node.computeWorldMatrix(true).invertToRef(invParentMatrix);\n      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);\n    }\n\n    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);\n\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.copyFrom(quatRotation);\n    } else {\n      quatRotation.toEulerAnglesToRef(this.rotation);\n    }\n\n    this.scaling.copyFrom(scale);\n    this.position.copyFrom(position);\n    this.parent = node;\n    return this;\n  };\n\n  Object.defineProperty(TransformNode.prototype, \"nonUniformScaling\", {\n    /**\n     * True if the scaling property of this object is non uniform eg. (1,2,1)\n     */\n    get: function get() {\n      return this._nonUniformScaling;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @param value\n   * @hidden\n   */\n\n  TransformNode.prototype._updateNonUniformScalingState = function (value) {\n    if (this._nonUniformScaling === value) {\n      return false;\n    }\n\n    this._nonUniformScaling = value;\n    return true;\n  };\n  /**\n   * Attach the current TransformNode to another TransformNode associated with a bone\n   * @param bone Bone affecting the TransformNode\n   * @param affectedTransformNode TransformNode associated with the bone\n   * @returns this object\n   */\n\n\n  TransformNode.prototype.attachToBone = function (bone, affectedTransformNode) {\n    this._currentParentWhenAttachingToBone = this.parent;\n    this._transformToBoneReferal = affectedTransformNode;\n    this.parent = bone;\n    bone.getSkeleton().prepare();\n\n    if (bone.getWorldMatrix().determinant() < 0) {\n      this.scalingDeterminant *= -1;\n    }\n\n    return this;\n  };\n  /**\n   * Detach the transform node if its associated with a bone\n   * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)\n   * @returns this object\n   */\n\n\n  TransformNode.prototype.detachFromBone = function (resetToPreviousParent) {\n    if (resetToPreviousParent === void 0) {\n      resetToPreviousParent = false;\n    }\n\n    if (!this.parent) {\n      if (resetToPreviousParent) {\n        this.parent = this._currentParentWhenAttachingToBone;\n      }\n\n      return this;\n    }\n\n    if (this.parent.getWorldMatrix().determinant() < 0) {\n      this.scalingDeterminant *= -1;\n    }\n\n    this._transformToBoneReferal = null;\n\n    if (resetToPreviousParent) {\n      this.parent = this._currentParentWhenAttachingToBone;\n    } else {\n      this.parent = null;\n    }\n\n    return this;\n  };\n  /**\n   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\n   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\n   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n   * The passed axis is also normalized.\n   * @param axis the axis to rotate around\n   * @param amount the amount to rotate in radians\n   * @param space Space to rotate in (Default: local)\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.rotate = function (axis, amount, space) {\n    axis.normalize();\n\n    if (!this.rotationQuaternion) {\n      this.rotationQuaternion = this.rotation.toQuaternion();\n      this.rotation.setAll(0);\n    }\n\n    var rotationQuaternion;\n\n    if (!space || space === Space.LOCAL) {\n      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\n      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\n    } else {\n      if (this.parent) {\n        var invertParentWorldMatrix = TmpVectors.Matrix[0];\n        this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\n        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);\n      }\n\n      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\n      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n    }\n\n    return this;\n  };\n  /**\n   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\n   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n   * The passed axis is also normalized. .\n   * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\n   * @param point the point to rotate around\n   * @param axis the axis to rotate around\n   * @param amount the amount to rotate in radians\n   * @returns the TransformNode\n   */\n\n\n  TransformNode.prototype.rotateAround = function (point, axis, amount) {\n    axis.normalize();\n\n    if (!this.rotationQuaternion) {\n      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n      this.rotation.setAll(0);\n    }\n\n    var tmpVector = TmpVectors.Vector3[0];\n    var finalScale = TmpVectors.Vector3[1];\n    var finalTranslation = TmpVectors.Vector3[2];\n    var finalRotation = TmpVectors.Quaternion[0];\n    var translationMatrix = TmpVectors.Matrix[0]; // T\n\n    var translationMatrixInv = TmpVectors.Matrix[1]; // T'\n\n    var rotationMatrix = TmpVectors.Matrix[2]; // R\n\n    var finalMatrix = TmpVectors.Matrix[3]; // T' x R x T\n\n    point.subtractToRef(this.position, tmpVector);\n    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T\n\n    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'\n\n    Matrix.RotationAxisToRef(axis, amount, rotationMatrix); // R\n\n    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n\n    finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T\n\n    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);\n    this.position.addInPlace(finalTranslation);\n    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n    return this;\n  };\n  /**\n   * Translates the mesh along the axis vector for the passed distance in the given space.\n   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\n   * @param axis the axis to translate in\n   * @param distance the distance to translate\n   * @param space Space to rotate in (Default: local)\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.translate = function (axis, distance, space) {\n    var displacementVector = axis.scale(distance);\n\n    if (!space || space === Space.LOCAL) {\n      var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\n      this.setPositionWithLocalVector(tempV3);\n    } else {\n      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\n    }\n\n    return this;\n  };\n  /**\n   * Adds a rotation step to the mesh current rotation.\n   * x, y, z are Euler angles expressed in radians.\n   * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\n   * This means this rotation is made in the mesh local space only.\n   * It's useful to set a custom rotation order different from the BJS standard one YXZ.\n   * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\n   * ```javascript\n   * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\n   * ```\n   * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\n   * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\n   * @param x Rotation to add\n   * @param y Rotation to add\n   * @param z Rotation to add\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.addRotation = function (x, y, z) {\n    var rotationQuaternion;\n\n    if (this.rotationQuaternion) {\n      rotationQuaternion = this.rotationQuaternion;\n    } else {\n      rotationQuaternion = TmpVectors.Quaternion[1];\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\n    }\n\n    var accumulation = TmpVectors.Quaternion[0];\n    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\n    rotationQuaternion.multiplyInPlace(accumulation);\n\n    if (!this.rotationQuaternion) {\n      rotationQuaternion.toEulerAnglesToRef(this.rotation);\n    }\n\n    return this;\n  };\n  /**\n   * @hidden\n   */\n\n\n  TransformNode.prototype._getEffectiveParent = function () {\n    return this.parent;\n  };\n  /**\n   * Computes the world matrix of the node\n   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\n   * @returns the world matrix\n   */\n\n\n  TransformNode.prototype.computeWorldMatrix = function (force) {\n    if (this._isWorldMatrixFrozen && !this._isDirty) {\n      return this._worldMatrix;\n    }\n\n    var currentRenderId = this.getScene().getRenderId();\n\n    if (!this._isDirty && !force && this.isSynchronized()) {\n      this._currentRenderId = currentRenderId;\n      return this._worldMatrix;\n    }\n\n    var camera = this.getScene().activeCamera;\n    var useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;\n    var useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;\n\n    this._updateCache();\n\n    var cache = this._cache;\n    cache.pivotMatrixUpdated = false;\n    cache.billboardMode = this.billboardMode;\n    cache.infiniteDistance = this.infiniteDistance;\n    cache.parent = this._parentNode;\n    this._currentRenderId = currentRenderId;\n    this._childUpdateId += 1;\n    this._isDirty = false;\n    this._position._isDirty = false;\n    this._rotation._isDirty = false;\n    this._scaling._isDirty = false;\n\n    var parent = this._getEffectiveParent(); // Scaling\n\n\n    var scaling = TransformNode._TmpScaling;\n    var translation = this._position; // Translation\n\n    if (this._infiniteDistance) {\n      if (!this.parent && camera) {\n        var cameraWorldMatrix = camera.getWorldMatrix();\n        var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\n        translation = TransformNode._TmpTranslation;\n        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);\n      }\n    } // Scaling\n\n\n    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant); // Rotation\n\n    var rotation;\n\n    if (this._rotationQuaternion) {\n      this._rotationQuaternion._isDirty = false;\n      rotation = this._rotationQuaternion;\n\n      if (this.reIntegrateRotationIntoRotationQuaternion) {\n        var len = this.rotation.lengthSquared();\n\n        if (len) {\n          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));\n\n          this._rotation.copyFromFloats(0, 0, 0);\n        }\n      }\n    } else {\n      rotation = TransformNode._TmpRotation;\n      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);\n    } // Compose\n\n\n    if (this._usePivotMatrix) {\n      var scaleMatrix = TmpVectors.Matrix[1];\n      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix); // Rotation\n\n      var rotationMatrix = TmpVectors.Matrix[0];\n      rotation.toRotationMatrix(rotationMatrix); // Composing transformations\n\n      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\n\n      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix); // Post multiply inverse of pivotMatrix\n\n      if (this._postMultiplyPivotMatrix) {\n        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);\n      }\n\n      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);\n    } else {\n      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);\n    } // Parent\n\n\n    if (parent && parent.getWorldMatrix) {\n      if (force) {\n        parent.computeWorldMatrix(force);\n      }\n\n      if (useBillboardPath) {\n        if (this._transformToBoneReferal) {\n          parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);\n        } else {\n          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());\n        } // Extract scaling and translation from parent\n\n\n        var translation_1 = TmpVectors.Vector3[5];\n        var scale = TmpVectors.Vector3[6];\n        TmpVectors.Matrix[7].decompose(scale, undefined, translation_1);\n        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);\n        TmpVectors.Matrix[7].setTranslation(translation_1);\n\n        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);\n      } else {\n        if (this._transformToBoneReferal) {\n          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);\n\n          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);\n        } else {\n          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);\n        }\n      }\n\n      this._markSyncedWithParent();\n    } else {\n      this._worldMatrix.copyFrom(this._localMatrix);\n    } // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\n\n\n    if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {\n      var storedTranslation = TmpVectors.Vector3[0];\n\n      this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation\n      // Cancel camera rotation\n\n\n      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());\n      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);\n      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);\n\n      if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\n        TmpVectors.Matrix[0].decompose(undefined, TmpVectors.Quaternion[0], undefined);\n        var eulerAngles = TmpVectors.Vector3[1];\n        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\n          eulerAngles.x = 0;\n        }\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\n          eulerAngles.y = 0;\n        }\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\n          eulerAngles.z = 0;\n        }\n\n        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\n      }\n\n      this._worldMatrix.setTranslationFromFloats(0, 0, 0);\n\n      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix); // Restore translation\n\n\n      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\n    } // Billboarding based on camera position\n    else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {\n      var storedTranslation = TmpVectors.Vector3[0]; // Save translation\n\n      this._worldMatrix.getTranslationToRef(storedTranslation); // Compute camera position in local space\n\n\n      var cameraPosition = camera.globalPosition;\n\n      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);\n\n      var camInObjSpace = TmpVectors.Vector3[1];\n      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);\n      camInObjSpace.normalize(); // Find the lookAt info in local space\n\n      var yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;\n      var len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);\n      var pitch = -Math.atan2(camInObjSpace.y, len);\n      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);\n\n      if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\n        var eulerAngles = TmpVectors.Vector3[1];\n        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\n          eulerAngles.x = 0;\n        }\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\n          eulerAngles.y = 0;\n        }\n\n        if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\n          eulerAngles.z = 0;\n        }\n\n        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\n      } else {\n        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);\n      } // Cancel translation\n\n\n      this._worldMatrix.setTranslationFromFloats(0, 0, 0); // Rotate according to lookat (diff from local to lookat)\n\n\n      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix); // Restore translation\n\n\n      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\n    } // Normal matrix\n\n\n    if (!this.ignoreNonUniformScaling) {\n      if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {\n        this._updateNonUniformScalingState(true);\n      } else if (parent && parent._nonUniformScaling) {\n        this._updateNonUniformScalingState(parent._nonUniformScaling);\n      } else {\n        this._updateNonUniformScalingState(false);\n      }\n    } else {\n      this._updateNonUniformScalingState(false);\n    }\n\n    this._afterComputeWorldMatrix(); // Absolute position\n\n\n    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\n\n    this._isAbsoluteSynced = false; // Callbacks\n\n    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\n\n    if (!this._poseMatrix) {\n      this._poseMatrix = Matrix.Invert(this._worldMatrix);\n    } // Cache the determinant\n\n\n    this._worldMatrixDeterminantIsDirty = true;\n    return this._worldMatrix;\n  };\n  /**\n   * Resets this nodeTransform's local matrix to Matrix.Identity().\n   * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.\n   */\n\n\n  TransformNode.prototype.resetLocalMatrix = function (independentOfChildren) {\n    if (independentOfChildren === void 0) {\n      independentOfChildren = true;\n    }\n\n    this.computeWorldMatrix();\n\n    if (independentOfChildren) {\n      var children = this.getChildren();\n\n      for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n\n        if (child) {\n          child.computeWorldMatrix();\n          var bakedMatrix = TmpVectors.Matrix[0];\n\n          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);\n\n          var tmpRotationQuaternion = TmpVectors.Quaternion[0];\n          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);\n\n          if (child.rotationQuaternion) {\n            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);\n          } else {\n            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);\n          }\n        }\n      }\n    }\n\n    this.scaling.copyFromFloats(1, 1, 1);\n    this.position.copyFromFloats(0, 0, 0);\n    this.rotation.copyFromFloats(0, 0, 0); //only if quaternion is already set\n\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = Quaternion.Identity();\n    }\n\n    this._worldMatrix = Matrix.Identity();\n  };\n\n  TransformNode.prototype._afterComputeWorldMatrix = function () {};\n  /**\n   * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\n   * @param func callback function to add\n   *\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.registerAfterWorldMatrixUpdate = function (func) {\n    this.onAfterWorldMatrixUpdateObservable.add(func);\n    return this;\n  };\n  /**\n   * Removes a registered callback function.\n   * @param func callback function to remove\n   * @returns the TransformNode.\n   */\n\n\n  TransformNode.prototype.unregisterAfterWorldMatrixUpdate = function (func) {\n    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\n    return this;\n  };\n  /**\n   * Gets the position of the current mesh in camera space\n   * @param camera defines the camera to use\n   * @returns a position\n   */\n\n\n  TransformNode.prototype.getPositionInCameraSpace = function (camera) {\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (!camera) {\n      camera = this.getScene().activeCamera;\n    }\n\n    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());\n  };\n  /**\n   * Returns the distance from the mesh to the active camera\n   * @param camera defines the camera to use\n   * @returns the distance\n   */\n\n\n  TransformNode.prototype.getDistanceToCamera = function (camera) {\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (!camera) {\n      camera = this.getScene().activeCamera;\n    }\n\n    return this.getAbsolutePosition().subtract(camera.globalPosition).length();\n  };\n  /**\n   * Clone the current transform node\n   * @param name Name of the new clone\n   * @param newParent New parent for the clone\n   * @param doNotCloneChildren Do not clone children hierarchy\n   * @returns the new transform node\n   */\n\n\n  TransformNode.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    var _this = this;\n\n    var result = SerializationHelper.Clone(function () {\n      return new TransformNode(name, _this.getScene());\n    }, this);\n    result.name = name;\n    result.id = name;\n\n    if (newParent) {\n      result.parent = newParent;\n    }\n\n    if (!doNotCloneChildren) {\n      // Children\n      var directDescendants = this.getDescendants(true);\n\n      for (var index = 0; index < directDescendants.length; index++) {\n        var child = directDescendants[index];\n\n        if (child.clone) {\n          child.clone(name + \".\" + child.name, result);\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Serializes the objects information.\n   * @param currentSerializationObject defines the object to serialize in\n   * @returns the serialized object\n   */\n\n\n  TransformNode.prototype.serialize = function (currentSerializationObject) {\n    var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.uniqueId = this.uniqueId; // Parent\n\n    if (this.parent) {\n      serializationObject.parentId = this.parent.uniqueId;\n    }\n\n    serializationObject.localMatrix = this.getPivotMatrix().asArray();\n    serializationObject.isEnabled = this.isEnabled(); // Parent\n\n    if (this.parent) {\n      serializationObject.parentId = this.parent.uniqueId;\n    }\n\n    return serializationObject;\n  }; // Statics\n\n  /**\n   * Returns a new TransformNode object parsed from the source provided.\n   * @param parsedTransformNode is the source.\n   * @param scene the scene the object belongs to\n   * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with\n   * @returns a new TransformNode object parsed from the source provided.\n   */\n\n\n  TransformNode.Parse = function (parsedTransformNode, scene, rootUrl) {\n    var transformNode = SerializationHelper.Parse(function () {\n      return new TransformNode(parsedTransformNode.name, scene);\n    }, parsedTransformNode, scene, rootUrl);\n\n    if (parsedTransformNode.localMatrix) {\n      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));\n    } else if (parsedTransformNode.pivotMatrix) {\n      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));\n    }\n\n    transformNode.setEnabled(parsedTransformNode.isEnabled); // Parent\n\n    if (parsedTransformNode.parentId !== undefined) {\n      transformNode._waitingParentId = parsedTransformNode.parentId;\n    }\n\n    return transformNode;\n  };\n  /**\n   * Get all child-transformNodes of this node\n   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\n   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\n   * @returns an array of TransformNode\n   */\n\n\n  TransformNode.prototype.getChildTransformNodes = function (directDescendantsOnly, predicate) {\n    var results = [];\n\n    this._getDescendants(results, directDescendantsOnly, function (node) {\n      return (!predicate || predicate(node)) && node instanceof TransformNode;\n    });\n\n    return results;\n  };\n  /**\n   * Releases resources associated with this transform node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n\n\n  TransformNode.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    } // Animations\n\n\n    this.getScene().stopAnimation(this); // Remove from scene\n\n    this.getScene().removeTransformNode(this);\n\n    if (this._parentContainer) {\n      var index = this._parentContainer.transformNodes.indexOf(this);\n\n      if (index > -1) {\n        this._parentContainer.transformNodes.splice(index, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    this.onAfterWorldMatrixUpdateObservable.clear();\n\n    if (doNotRecurse) {\n      var transformNodes = this.getChildTransformNodes(true);\n\n      for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {\n        var transformNode = transformNodes_1[_i];\n        transformNode.parent = null;\n        transformNode.computeWorldMatrix(true);\n      }\n    }\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\n   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\n   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\n   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\n   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\n   * @returns the current mesh\n   */\n\n\n  TransformNode.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n    if (includeDescendants === void 0) {\n      includeDescendants = true;\n    }\n\n    if (ignoreRotation === void 0) {\n      ignoreRotation = false;\n    }\n\n    var storedRotation = null;\n    var storedRotationQuaternion = null;\n\n    if (ignoreRotation) {\n      if (this.rotationQuaternion) {\n        storedRotationQuaternion = this.rotationQuaternion.clone();\n        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else if (this.rotation) {\n        storedRotation = this.rotation.clone();\n        this.rotation.copyFromFloats(0, 0, 0);\n      }\n    }\n\n    var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);\n    var sizeVec = boundingVectors.max.subtract(boundingVectors.min);\n    var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);\n\n    if (maxDimension === 0) {\n      return this;\n    }\n\n    var scale = 1 / maxDimension;\n    this.scaling.scaleInPlace(scale);\n\n    if (ignoreRotation) {\n      if (this.rotationQuaternion && storedRotationQuaternion) {\n        this.rotationQuaternion.copyFrom(storedRotationQuaternion);\n      } else if (this.rotation && storedRotation) {\n        this.rotation.copyFrom(storedRotation);\n      }\n    }\n\n    return this;\n  };\n\n  TransformNode.prototype._syncAbsoluteScalingAndRotation = function () {\n    if (!this._isAbsoluteSynced) {\n      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);\n\n      this._isAbsoluteSynced = true;\n    }\n  }; // Statics\n\n  /**\n   * Object will not rotate to face the camera\n   */\n\n\n  TransformNode.BILLBOARDMODE_NONE = 0;\n  /**\n   * Object will rotate to face the camera but only on the x axis\n   */\n\n  TransformNode.BILLBOARDMODE_X = 1;\n  /**\n   * Object will rotate to face the camera but only on the y axis\n   */\n\n  TransformNode.BILLBOARDMODE_Y = 2;\n  /**\n   * Object will rotate to face the camera but only on the z axis\n   */\n\n  TransformNode.BILLBOARDMODE_Z = 4;\n  /**\n   * Object will rotate to face the camera\n   */\n\n  TransformNode.BILLBOARDMODE_ALL = 7;\n  /**\n   * Object will rotate to face the camera's position instead of orientation\n   */\n\n  TransformNode.BILLBOARDMODE_USE_POSITION = 128;\n  TransformNode._TmpRotation = Quaternion.Zero();\n  TransformNode._TmpScaling = Vector3.Zero();\n  TransformNode._TmpTranslation = Vector3.Zero();\n  TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);\n  TransformNode._RotationAxisCache = new Quaternion();\n\n  __decorate([serializeAsVector3(\"position\")], TransformNode.prototype, \"_position\", void 0);\n\n  __decorate([serializeAsVector3(\"rotation\")], TransformNode.prototype, \"_rotation\", void 0);\n\n  __decorate([serializeAsQuaternion(\"rotationQuaternion\")], TransformNode.prototype, \"_rotationQuaternion\", void 0);\n\n  __decorate([serializeAsVector3(\"scaling\")], TransformNode.prototype, \"_scaling\", void 0);\n\n  __decorate([serialize(\"billboardMode\")], TransformNode.prototype, \"_billboardMode\", void 0);\n\n  __decorate([serialize()], TransformNode.prototype, \"scalingDeterminant\", void 0);\n\n  __decorate([serialize(\"infiniteDistance\")], TransformNode.prototype, \"_infiniteDistance\", void 0);\n\n  __decorate([serialize()], TransformNode.prototype, \"ignoreNonUniformScaling\", void 0);\n\n  __decorate([serialize()], TransformNode.prototype, \"reIntegrateRotationIntoRotationQuaternion\", void 0);\n\n  return TransformNode;\n}(Node);\n\nexport { TransformNode };","map":{"version":3,"mappings":"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","names":["serialize","serializeAsVector3","serializeAsQuaternion","SerializationHelper","Observable","Quaternion","Matrix","Vector3","TmpVectors","Node","Space","__extends","name","scene","isPure","_super","_this","Zero","One","TransformNode","BILLBOARDMODE_NONE","Identity","getScene","addTransformNode","Object","_billboardMode","value","_preserveParentRotationForBillboard","_infiniteDistance","_position","newPosition","_isDirty","_usePivotMatrix","_rotation","newRotation","_rotationQuaternion","_scaling","newScaling","quaternion","setAll","TransformNormalFromFloatsToRef","useRightHandedSystem","getWorldMatrix","_forward","normalize","_up","_right","matrix","_poseMatrix","clone","copyFrom","cache","_cache","billboardMode","pivotMatrixUpdated","infiniteDistance","position","scaling","rotation","_initCache","call","localMatrixUpdated","getAbsolutePosition","_syncAbsoluteScalingAndRotation","_absoluteScaling","_absoluteRotationQuaternion","setPivotMatrix","postMultiplyPivotMatrix","_pivotMatrix","isIdentity","_postMultiplyPivotMatrix","_pivotMatrixInverse","Invert","invertToRef","newParent","options","onNewNodeCreated","id","parent","getChildTransformNodes","_i","child","instantiateHierarchy","newWorldMatrix","decompose","computeWorldMatrix","_worldMatrix","_absolutePosition","copyFromFloats","m","_afterComputeWorldMatrix","_isWorldMatrixFrozen","absolutePosition","absolutePositionX","absolutePositionY","absolutePositionZ","x","undefined","arguments","length","y","z","invertParentWorldMatrix","TransformCoordinatesFromFloatsToRef","vector3","TransformNormal","_localMatrix","invLocalWorldMatrix","TransformCoordinates","targetPoint","yawCor","pitchCor","rollCor","space","LOCAL","dv","_LookAtVectorCache","pos","subtractToRef","setDirection","WORLD","rotationQuaternion","rotationMatrix","toRotationMatrix","parentRotationMatrix","getRotationMatrixToRef","invert","multiplyToRef","fromRotationMatrix","quaternionRotation","FromEulerVectorToRef","toEulerAnglesToRef","localAxis","result","getDirectionToRef","TransformNormalToRef","yaw","Math","atan2","PI","len","sqrt","pitch","RotationYawPitchRollToRef","point","getRenderId","wm","tmat","Translation","getPivotPointToRef","getAbsolutePivotPointToRef","TransformCoordinatesToRef","property","_children","markAsDirty","node","preserveScalingSign","quatRotation","scale","invParentMatrix","IdentityToRef","composedMatrix","currentRotation","_TmpRotation","ComposeToRef","_nonUniformScaling","bone","affectedTransformNode","_currentParentWhenAttachingToBone","_transformToBoneReferal","getSkeleton","prepare","determinant","scalingDeterminant","resetToPreviousParent","axis","amount","toQuaternion","RotationAxisToRef","_RotationAxisCache","RotationYawPitchRoll","tmpVector","finalScale","finalTranslation","finalRotation","translationMatrix","translationMatrixInv","finalMatrix","TranslationToRef","addInPlace","distance","displacementVector","tempV3","getPositionExpressedInLocalSpace","add","setPositionWithLocalVector","setAbsolutePosition","accumulation","multiplyInPlace","force","currentRenderId","isSynchronized","_currentRenderId","camera","activeCamera","useBillboardPosition","BILLBOARDMODE_USE_POSITION","useBillboardPath","preserveParentRotationForBillboard","_updateCache","_parentNode","_childUpdateId","_getEffectiveParent","_TmpScaling","translation","cameraWorldMatrix","cameraGlobalPosition","_TmpTranslation","reIntegrateRotationIntoRotationQuaternion","lengthSquared","scaleMatrix","ScalingToRef","addTranslationFromFloats","translation_1","setTranslation","_markSyncedWithParent","storedTranslation","getTranslationToRef","getViewMatrix","setTranslationFromFloats","BILLBOARDMODE_ALL","eulerAngles","BILLBOARDMODE_X","BILLBOARDMODE_Y","BILLBOARDMODE_Z","cameraPosition","globalPosition","camInObjSpace","FromQuaternionToRef","ignoreNonUniformScaling","isNonUniformWithinEpsilon","_updateNonUniformScalingState","_isAbsoluteSynced","onAfterWorldMatrixUpdateObservable","notifyObservers","_worldMatrixDeterminantIsDirty","independentOfChildren","children","getChildren","i","bakedMatrix","tmpRotationQuaternion","func","removeCallback","subtract","doNotCloneChildren","Clone","directDescendants","getDescendants","index","currentSerializationObject","serializationObject","Serialize","type","getClassName","uniqueId","parentId","localMatrix","getPivotMatrix","asArray","isEnabled","parsedTransformNode","rootUrl","transformNode","Parse","setPreTransformMatrix","FromArray","pivotMatrix","setEnabled","_waitingParentId","directDescendantsOnly","predicate","results","_getDescendants","doNotRecurse","disposeMaterialAndTextures","stopAnimation","removeTransformNode","_parentContainer","transformNodes","indexOf","splice","clear","dispose","includeDescendants","ignoreRotation","storedRotation","storedRotationQuaternion","boundingVectors","getHierarchyBoundingVectors","sizeVec","max","min","maxDimension","scaleInPlace","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/transformNode.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { serialize, serializeAsVector3, serializeAsQuaternion, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n/**\r\n * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.\r\n * @see https://doc.babylonjs.com/how_to/transformnode\r\n */\r\nexport class TransformNode extends Node {\r\n    // Statics\r\n    /**\r\n     * Object will not rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_NONE = 0;\r\n    /**\r\n     * Object will rotate to face the camera but only on the x axis\r\n     */\r\n    public static BILLBOARDMODE_X = 1;\r\n    /**\r\n     * Object will rotate to face the camera but only on the y axis\r\n     */\r\n    public static BILLBOARDMODE_Y = 2;\r\n    /**\r\n     * Object will rotate to face the camera but only on the z axis\r\n     */\r\n    public static BILLBOARDMODE_Z = 4;\r\n    /**\r\n     * Object will rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_ALL = 7;\r\n    /**\r\n     * Object will rotate to face the camera's position instead of orientation\r\n     */\r\n    public static BILLBOARDMODE_USE_POSITION = 128;\r\n\r\n    private static _TmpRotation = Quaternion.Zero();\r\n    private static _TmpScaling = Vector3.Zero();\r\n    private static _TmpTranslation = Vector3.Zero();\r\n\r\n    private _forward = new Vector3(0, 0, 1);\r\n    private _up = new Vector3(0, 1, 0);\r\n    private _right = new Vector3(1, 0, 0);\r\n\r\n    // Properties\r\n    @serializeAsVector3(\"position\")\r\n    private _position = Vector3.Zero();\r\n\r\n    @serializeAsVector3(\"rotation\")\r\n    private _rotation = Vector3.Zero();\r\n\r\n    @serializeAsQuaternion(\"rotationQuaternion\")\r\n    private _rotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n    @serializeAsVector3(\"scaling\")\r\n    protected _scaling = Vector3.One();\r\n    private _transformToBoneReferal: Nullable<TransformNode> = null;\r\n    private _currentParentWhenAttachingToBone: Nullable<Node>;\r\n    private _isAbsoluteSynced = false;\r\n\r\n    @serialize(\"billboardMode\")\r\n    private _billboardMode = TransformNode.BILLBOARDMODE_NONE;\r\n\r\n    /**\r\n     * Gets or sets the billboard mode. Default is 0.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | BILLBOARDMODE_NONE |  |\r\n     * | 1 | BILLBOARDMODE_X |  |\r\n     * | 2 | BILLBOARDMODE_Y |  |\r\n     * | 4 | BILLBOARDMODE_Z |  |\r\n     * | 7 | BILLBOARDMODE_ALL |  |\r\n     *\r\n     */\r\n    public get billboardMode() {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n        this._billboardMode = value;\r\n    }\r\n\r\n    private _preserveParentRotationForBillboard = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.\r\n     * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed\r\n     */\r\n    public get preserveParentRotationForBillboard() {\r\n        return this._preserveParentRotationForBillboard;\r\n    }\r\n\r\n    public set preserveParentRotationForBillboard(value: boolean) {\r\n        if (value === this._preserveParentRotationForBillboard) {\r\n            return;\r\n        }\r\n        this._preserveParentRotationForBillboard = value;\r\n    }\r\n\r\n    /**\r\n     * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube\r\n     */\r\n    @serialize()\r\n    public scalingDeterminant = 1;\r\n\r\n    @serialize(\"infiniteDistance\")\r\n    private _infiniteDistance = false;\r\n\r\n    /**\r\n     * Gets or sets the distance of the object to max, often used by skybox\r\n     */\r\n    public get infiniteDistance() {\r\n        return this._infiniteDistance;\r\n    }\r\n\r\n    public set infiniteDistance(value: boolean) {\r\n        if (this._infiniteDistance === value) {\r\n            return;\r\n        }\r\n\r\n        this._infiniteDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.\r\n     * By default the system will update normals to compensate\r\n     */\r\n    @serialize()\r\n    public ignoreNonUniformScaling = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both\r\n     */\r\n    @serialize()\r\n    public reIntegrateRotationIntoRotationQuaternion = false;\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _poseMatrix: Nullable<Matrix> = null;\r\n    /** @hidden */\r\n    public _localMatrix = Matrix.Zero();\r\n\r\n    private _usePivotMatrix = false;\r\n    private _absolutePosition = Vector3.Zero();\r\n    private _absoluteScaling = Vector3.Zero();\r\n    private _absoluteRotationQuaternion = Quaternion.Identity();\r\n    private _pivotMatrix = Matrix.Identity();\r\n    private _pivotMatrixInverse: Matrix;\r\n    /** @hidden */\r\n    public _postMultiplyPivotMatrix = false;\r\n\r\n    protected _isWorldMatrixFrozen = false;\r\n\r\n    /** @hidden */\r\n    public _indexInSceneTransformNodesArray = -1;\r\n\r\n    /**\r\n     * An event triggered after the world matrix is updated\r\n     */\r\n    public onAfterWorldMatrixUpdateObservable = new Observable<TransformNode>();\r\n\r\n    constructor(name: string, scene: Nullable<Scene> = null, isPure = true) {\r\n        super(name, scene);\r\n\r\n        if (isPure) {\r\n            this.getScene().addTransformNode(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"TransformNode\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"TransformNode\";\r\n    }\r\n\r\n    /**\r\n     * Gets or set the node position (default is (0.0, 0.0, 0.0))\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._position = newPosition;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * return true if a pivot has been set\r\n     * @returns true if a pivot matrix is used\r\n     */\r\n    public isUsingPivotMatrix(): boolean {\r\n        return this._usePivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).\r\n     * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion\r\n     */\r\n    public get rotation(): Vector3 {\r\n        return this._rotation;\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this._rotation = newRotation;\r\n        this._rotationQuaternion = null;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).\r\n     */\r\n    public get scaling(): Vector3 {\r\n        return this._scaling;\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this._scaling = newScaling;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).\r\n     * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)\r\n     */\r\n    public get rotationQuaternion(): Nullable<Quaternion> {\r\n        return this._rotationQuaternion;\r\n    }\r\n\r\n    public set rotationQuaternion(quaternion: Nullable<Quaternion>) {\r\n        this._rotationQuaternion = quaternion;\r\n        //reset the rotation vector.\r\n        if (quaternion) {\r\n            this._rotation.setAll(0.0);\r\n        }\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * The forward direction of that transform in world space.\r\n     */\r\n    public get forward(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);\r\n        return this._forward.normalize();\r\n    }\r\n\r\n    /**\r\n     * The up direction of that transform in world space.\r\n     */\r\n    public get up(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);\r\n        return this._up.normalize();\r\n    }\r\n\r\n    /**\r\n     * The right direction of that transform in world space.\r\n     */\r\n    public get right(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);\r\n        return this._right.normalize();\r\n    }\r\n\r\n    /**\r\n     * Copies the parameter passed Matrix into the mesh Pose matrix.\r\n     * @param matrix the matrix to copy the pose from\r\n     * @returns this TransformNode.\r\n     */\r\n    public updatePoseMatrix(matrix: Matrix): TransformNode {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = matrix.clone();\r\n            return this;\r\n        }\r\n        this._poseMatrix.copyFrom(matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh Pose matrix.\r\n     * @returns the pose matrix\r\n     */\r\n    public getPoseMatrix(): Matrix {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Identity();\r\n        }\r\n        return this._poseMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _isSynchronized(): boolean {\r\n        const cache = this._cache;\r\n\r\n        if (this.billboardMode !== cache.billboardMode || this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return false;\r\n        }\r\n\r\n        if (cache.pivotMatrixUpdated) {\r\n            return false;\r\n        }\r\n\r\n        if (this.infiniteDistance) {\r\n            return false;\r\n        }\r\n\r\n        if (this.position._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if (this.scaling._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if ((this._rotationQuaternion && this._rotationQuaternion._isDirty) || this.rotation._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        const cache = this._cache;\r\n        cache.localMatrixUpdated = false;\r\n        cache.billboardMode = -1;\r\n        cache.infiniteDistance = false;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute position.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absolutePosition(): Vector3 {\r\n        return this.getAbsolutePosition();\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute scaling.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absoluteScaling(): Vector3 {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteScaling;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute rotation.\r\n     * Returns a Quaternion.\r\n     */\r\n    public get absoluteRotationQuaternion(): Quaternion {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Sets a new matrix to apply before all other transformation\r\n     * @param matrix defines the transform matrix\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPreTransformMatrix(matrix: Matrix): TransformNode {\r\n        return this.setPivotMatrix(matrix, false);\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot matrix to the current node\r\n     * @param matrix defines the new pivot matrix to use\r\n     * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotMatrix(matrix: DeepImmutable<Matrix>, postMultiplyPivotMatrix = true): TransformNode {\r\n        this._pivotMatrix.copyFrom(matrix);\r\n        this._usePivotMatrix = !this._pivotMatrix.isIdentity();\r\n\r\n        this._cache.pivotMatrixUpdated = true;\r\n        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;\r\n\r\n        if (this._postMultiplyPivotMatrix) {\r\n            if (!this._pivotMatrixInverse) {\r\n                this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);\r\n            } else {\r\n                this._pivotMatrix.invertToRef(this._pivotMatrixInverse);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh pivot matrix.\r\n     * Default : Identity.\r\n     * @returns the matrix\r\n     */\r\n    public getPivotMatrix(): Matrix {\r\n        return this._pivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Prevents the World matrix to be computed any longer\r\n     * @param newWorldMatrix defines an optional matrix to use as world matrix\r\n     * @param decompose defines whether to decompose the given newWorldMatrix or directly assign\r\n     * @returns the TransformNode.\r\n     */\r\n    public freezeWorldMatrix(newWorldMatrix: Nullable<Matrix> = null, decompose = false): TransformNode {\r\n        if (newWorldMatrix) {\r\n            if (decompose) {\r\n                this._rotation.setAll(0);\r\n                this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();\r\n                newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);\r\n                this.computeWorldMatrix(true);\r\n            } else {\r\n                this._worldMatrix = newWorldMatrix;\r\n                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n                this._afterComputeWorldMatrix();\r\n            }\r\n        } else {\r\n            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\r\n            this.computeWorldMatrix(true);\r\n        }\r\n        this._isDirty = false;\r\n        this._isWorldMatrixFrozen = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Allows back the World matrix computation.\r\n     * @returns the TransformNode.\r\n     */\r\n    public unfreezeWorldMatrix() {\r\n        this._isWorldMatrixFrozen = false;\r\n        this.computeWorldMatrix(true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True if the World matrix has been frozen.\r\n     */\r\n    public get isWorldMatrixFrozen(): boolean {\r\n        return this._isWorldMatrixFrozen;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh absolute position in the World.\r\n     * @returns a Vector3.\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        return this._absolutePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\r\n     * @param absolutePosition the absolute position to set\r\n     * @returns the TransformNode.\r\n     */\r\n    public setAbsolutePosition(absolutePosition: Vector3): TransformNode {\r\n        if (!absolutePosition) {\r\n            return this;\r\n        }\r\n        let absolutePositionX;\r\n        let absolutePositionY;\r\n        let absolutePositionZ;\r\n        if (absolutePosition.x === undefined) {\r\n            if (arguments.length < 3) {\r\n                return this;\r\n            }\r\n            absolutePositionX = arguments[0];\r\n            absolutePositionY = arguments[1];\r\n            absolutePositionZ = arguments[2];\r\n        } else {\r\n            absolutePositionX = absolutePosition.x;\r\n            absolutePositionY = absolutePosition.y;\r\n            absolutePositionZ = absolutePosition.z;\r\n        }\r\n        if (this.parent) {\r\n            const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\r\n            Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);\r\n        } else {\r\n            this.position.x = absolutePositionX;\r\n            this.position.y = absolutePositionY;\r\n            this.position.z = absolutePositionZ;\r\n        }\r\n\r\n        this._absolutePosition.copyFrom(absolutePosition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh position in its local space.\r\n     * @param vector3 the position to set in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public setPositionWithLocalVector(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix();\r\n        this.position = Vector3.TransformNormal(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh position in the local space from the current World matrix values.\r\n     * @returns a new Vector3.\r\n     */\r\n    public getPositionExpressedInLocalSpace(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        const invLocalWorldMatrix = TmpVectors.Matrix[0];\r\n        this._localMatrix.invertToRef(invLocalWorldMatrix);\r\n        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the passed Vector3 in its local space.\r\n     * @param vector3 the distance to translate in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public locallyTranslate(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix(true);\r\n        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    private static _LookAtVectorCache = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Orients a mesh towards a target point. Mesh must be drawn facing user.\r\n     * @param targetPoint the position (must be in same space as current mesh) to look at\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @param space the chosen space of the target\r\n     * @returns the TransformNode.\r\n     */\r\n    public lookAt(targetPoint: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0, space: Space = Space.LOCAL): TransformNode {\r\n        const dv = TransformNode._LookAtVectorCache;\r\n        const pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();\r\n        targetPoint.subtractToRef(pos, dv);\r\n        this.setDirection(dv, yawCor, pitchCor, rollCor);\r\n\r\n        // Correct for parent's rotation offset\r\n        if (space === Space.WORLD && this.parent) {\r\n            if (this.rotationQuaternion) {\r\n                // Get local rotation matrix of the looking object\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                this.rotationQuaternion.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                this.rotationQuaternion.fromRotationMatrix(rotationMatrix);\r\n            } else {\r\n                // Get local rotation matrix of the looking object\r\n                const quaternionRotation = TmpVectors.Quaternion[0];\r\n                Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                quaternionRotation.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                quaternionRotation.fromRotationMatrix(rotationMatrix);\r\n                quaternionRotation.toEulerAnglesToRef(this.rotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     * This Vector3 is expressed in the World space.\r\n     * @param localAxis axis to rotate\r\n     * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     */\r\n    public getDirection(localAxis: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\r\n     * localAxis is expressed in the mesh local space.\r\n     * result is computed in the World space from the mesh World matrix.\r\n     * @param localAxis axis to rotate\r\n     * @param result the resulting transformnode\r\n     * @returns this TransformNode.\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, result: Vector3): TransformNode {\r\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets this transform node rotation to the given local axis.\r\n     * @param localAxis the axis in local space\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @returns this TransformNode\r\n     */\r\n    public setDirection(localAxis: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0): TransformNode {\r\n        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\r\n        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n        const pitch = -Math.atan2(localAxis.y, len);\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\r\n        } else {\r\n            this.rotation.x = pitch + pitchCor;\r\n            this.rotation.y = yaw + yawCor;\r\n            this.rotation.z = rollCor;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot point to the current node\r\n     * @param point defines the new pivot point to use\r\n     * @param space defines if the point is in world or local space (local by default)\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotPoint(point: Vector3, space: Space = Space.LOCAL): TransformNode {\r\n        if (this.getScene().getRenderId() == 0) {\r\n            this.computeWorldMatrix(true);\r\n        }\r\n\r\n        const wm = this.getWorldMatrix();\r\n\r\n        if (space == Space.WORLD) {\r\n            const tmat = TmpVectors.Matrix[0];\r\n            wm.invertToRef(tmat);\r\n            point = Vector3.TransformCoordinates(point, tmat);\r\n        }\r\n\r\n        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\r\n     * @returns the pivot point\r\n     */\r\n    public getPivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getPivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\r\n     * @param result the vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getPivotPointToRef(result: Vector3): TransformNode {\r\n        result.x = -this._pivotMatrix.m[12];\r\n        result.y = -this._pivotMatrix.m[13];\r\n        result.z = -this._pivotMatrix.m[14];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     * @returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     */\r\n    public getAbsolutePivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getAbsolutePivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\r\n     * @param result vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getAbsolutePivotPointToRef(result: Vector3): TransformNode {\r\n        this.getPivotPointToRef(result);\r\n        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Flag the transform node as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this  node\r\n     */\r\n    public markAsDirty(property?: string): Node {\r\n        // We need to explicitly update the children\r\n        // as the scene.evaluateActiveMeshes will not poll the transform nodes\r\n        if (this._children) {\r\n            for (const child of this._children) {\r\n                child.markAsDirty(property);\r\n            }\r\n        }\r\n        return super.markAsDirty(property);\r\n    }\r\n\r\n    /**\r\n     * Defines the passed node as the parent of the current node.\r\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\r\n     * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.\r\n     * In that case the node will not remain in the same space as it is, as the pivot will be applied.\r\n     * @see https://doc.babylonjs.com/how_to/parenting\r\n     * @param node the node ot set as the parent\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns this TransformNode.\r\n     */\r\n    public setParent(node: Nullable<Node>, preserveScalingSign: boolean = false): TransformNode {\r\n        if (!node && !this.parent) {\r\n            return this;\r\n        }\r\n\r\n        const quatRotation = TmpVectors.Quaternion[0];\r\n        const position = TmpVectors.Vector3[0];\r\n        const scale = TmpVectors.Vector3[1];\r\n        const invParentMatrix = TmpVectors.Matrix[1];\r\n        Matrix.IdentityToRef(invParentMatrix);\r\n        const composedMatrix = TmpVectors.Matrix[0];\r\n        this.computeWorldMatrix(true);\r\n\r\n        let currentRotation = this.rotationQuaternion;\r\n        if (!currentRotation) {\r\n            currentRotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);\r\n        }\r\n\r\n        // current global transformation without pivot\r\n        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);\r\n        if (this.parent) {\r\n            composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);\r\n        }\r\n\r\n        // is a node was set, calculate the difference between this and the node\r\n        if (node) {\r\n            node.computeWorldMatrix(true).invertToRef(invParentMatrix);\r\n            composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);\r\n        }\r\n        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.copyFrom(quatRotation);\r\n        } else {\r\n            quatRotation.toEulerAnglesToRef(this.rotation);\r\n        }\r\n\r\n        this.scaling.copyFrom(scale);\r\n        this.position.copyFrom(position);\r\n\r\n        this.parent = node;\r\n        return this;\r\n    }\r\n\r\n    private _nonUniformScaling = false;\r\n    /**\r\n     * True if the scaling property of this object is non uniform eg. (1,2,1)\r\n     */\r\n    public get nonUniformScaling(): boolean {\r\n        return this._nonUniformScaling;\r\n    }\r\n\r\n    /**\r\n     * @param value\r\n     * @hidden\r\n     */\r\n    public _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (this._nonUniformScaling === value) {\r\n            return false;\r\n        }\r\n\r\n        this._nonUniformScaling = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Attach the current TransformNode to another TransformNode associated with a bone\r\n     * @param bone Bone affecting the TransformNode\r\n     * @param affectedTransformNode TransformNode associated with the bone\r\n     * @returns this object\r\n     */\r\n    public attachToBone(bone: Bone, affectedTransformNode: TransformNode): TransformNode {\r\n        this._currentParentWhenAttachingToBone = this.parent;\r\n        this._transformToBoneReferal = affectedTransformNode;\r\n        this.parent = bone;\r\n\r\n        bone.getSkeleton().prepare();\r\n\r\n        if (bone.getWorldMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Detach the transform node if its associated with a bone\r\n     * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)\r\n     * @returns this object\r\n     */\r\n    public detachFromBone(resetToPreviousParent = false): TransformNode {\r\n        if (!this.parent) {\r\n            if (resetToPreviousParent) {\r\n                this.parent = this._currentParentWhenAttachingToBone;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (this.parent.getWorldMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        this._transformToBoneReferal = null;\r\n        if (resetToPreviousParent) {\r\n            this.parent = this._currentParentWhenAttachingToBone;\r\n        } else {\r\n            this.parent = null;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private static _RotationAxisCache = new Quaternion();\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized.\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space?: Space): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = this.rotation.toQuaternion();\r\n            this.rotation.setAll(0);\r\n        }\r\n        let rotationQuaternion: Quaternion;\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\r\n        } else {\r\n            if (this.parent) {\r\n                const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n                this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\r\n                axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);\r\n            }\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized. .\r\n     * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\r\n     * @param point the point to rotate around\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @returns the TransformNode\r\n     */\r\n    public rotateAround(point: Vector3, axis: Vector3, amount: number): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n            this.rotation.setAll(0);\r\n        }\r\n\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n        const finalScale = TmpVectors.Vector3[1];\r\n        const finalTranslation = TmpVectors.Vector3[2];\r\n\r\n        const finalRotation = TmpVectors.Quaternion[0];\r\n\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const finalMatrix = TmpVectors.Matrix[3]; // T' x R x T\r\n\r\n        point.subtractToRef(this.position, tmpVector);\r\n        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'\r\n        Matrix.RotationAxisToRef(axis, amount, rotationMatrix); // R\r\n\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T\r\n\r\n        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);\r\n\r\n        this.position.addInPlace(finalTranslation);\r\n        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the axis vector for the passed distance in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * @param axis the axis to translate in\r\n     * @param distance the distance to translate\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public translate(axis: Vector3, distance: number, space?: Space): TransformNode {\r\n        const displacementVector = axis.scale(distance);\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\r\n            this.setPositionWithLocalVector(tempV3);\r\n        } else {\r\n            this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a rotation step to the mesh current rotation.\r\n     * x, y, z are Euler angles expressed in radians.\r\n     * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\r\n     * This means this rotation is made in the mesh local space only.\r\n     * It's useful to set a custom rotation order different from the BJS standard one YXZ.\r\n     * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\r\n     * ```javascript\r\n     * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\r\n     * ```\r\n     * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\r\n     * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\r\n     * @param x Rotation to add\r\n     * @param y Rotation to add\r\n     * @param z Rotation to add\r\n     * @returns the TransformNode.\r\n     */\r\n    public addRotation(x: number, y: number, z: number): TransformNode {\r\n        let rotationQuaternion;\r\n        if (this.rotationQuaternion) {\r\n            rotationQuaternion = this.rotationQuaternion;\r\n        } else {\r\n            rotationQuaternion = TmpVectors.Quaternion[1];\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\r\n        }\r\n        const accumulation = TmpVectors.Quaternion[0];\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\r\n        rotationQuaternion.multiplyInPlace(accumulation);\r\n        if (!this.rotationQuaternion) {\r\n            rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    protected _getEffectiveParent(): Nullable<Node> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(force?: boolean): Matrix {\r\n        if (this._isWorldMatrixFrozen && !this._isDirty) {\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        const currentRenderId = this.getScene().getRenderId();\r\n        if (!this._isDirty && !force && this.isSynchronized()) {\r\n            this._currentRenderId = currentRenderId;\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        const camera = <Camera>this.getScene().activeCamera;\r\n        const useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;\r\n        const useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;\r\n\r\n        this._updateCache();\r\n        const cache = this._cache;\r\n        cache.pivotMatrixUpdated = false;\r\n        cache.billboardMode = this.billboardMode;\r\n        cache.infiniteDistance = this.infiniteDistance;\r\n        cache.parent = this._parentNode;\r\n\r\n        this._currentRenderId = currentRenderId;\r\n        this._childUpdateId += 1;\r\n        this._isDirty = false;\r\n        this._position._isDirty = false;\r\n        this._rotation._isDirty = false;\r\n        this._scaling._isDirty = false;\r\n        const parent = this._getEffectiveParent();\r\n\r\n        // Scaling\r\n        const scaling: Vector3 = TransformNode._TmpScaling;\r\n        let translation: Vector3 = this._position;\r\n\r\n        // Translation\r\n        if (this._infiniteDistance) {\r\n            if (!this.parent && camera) {\r\n                const cameraWorldMatrix = camera.getWorldMatrix();\r\n                const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\r\n\r\n                translation = TransformNode._TmpTranslation;\r\n                translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);\r\n            }\r\n        }\r\n\r\n        // Scaling\r\n        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);\r\n\r\n        // Rotation\r\n        let rotation: Quaternion;\r\n        if (this._rotationQuaternion) {\r\n            this._rotationQuaternion._isDirty = false;\r\n            rotation = this._rotationQuaternion;\r\n            if (this.reIntegrateRotationIntoRotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));\r\n                    this._rotation.copyFromFloats(0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            rotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);\r\n        }\r\n\r\n        // Compose\r\n        if (this._usePivotMatrix) {\r\n            const scaleMatrix = TmpVectors.Matrix[1];\r\n            Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);\r\n\r\n            // Rotation\r\n            const rotationMatrix = TmpVectors.Matrix[0];\r\n            rotation.toRotationMatrix(rotationMatrix);\r\n\r\n            // Composing transformations\r\n            this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n            TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);\r\n\r\n            // Post multiply inverse of pivotMatrix\r\n            if (this._postMultiplyPivotMatrix) {\r\n                this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);\r\n            }\r\n\r\n            this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);\r\n        } else {\r\n            Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);\r\n        }\r\n\r\n        // Parent\r\n        if (parent && parent.getWorldMatrix) {\r\n            if (force) {\r\n                parent.computeWorldMatrix(force);\r\n            }\r\n            if (useBillboardPath) {\r\n                if (this._transformToBoneReferal) {\r\n                    parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);\r\n                } else {\r\n                    TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());\r\n                }\r\n\r\n                // Extract scaling and translation from parent\r\n                const translation = TmpVectors.Vector3[5];\r\n                const scale = TmpVectors.Vector3[6];\r\n                TmpVectors.Matrix[7].decompose(scale, undefined, translation);\r\n                Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);\r\n                TmpVectors.Matrix[7].setTranslation(translation);\r\n\r\n                this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);\r\n            } else {\r\n                if (this._transformToBoneReferal) {\r\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);\r\n                    TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);\r\n                } else {\r\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);\r\n                }\r\n            }\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._worldMatrix.copyFrom(this._localMatrix);\r\n        }\r\n\r\n        // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\r\n        if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {\r\n            const storedTranslation = TmpVectors.Vector3[0];\r\n            this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation\r\n\r\n            // Cancel camera rotation\r\n            TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());\r\n            TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);\r\n            TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);\r\n\r\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                TmpVectors.Matrix[0].decompose(undefined, TmpVectors.Quaternion[0], undefined);\r\n                const eulerAngles = TmpVectors.Vector3[1];\r\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                    eulerAngles.x = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                    eulerAngles.y = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                    eulerAngles.z = 0;\r\n                }\r\n\r\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n            }\r\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n            // Restore translation\r\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n        }\r\n        // Billboarding based on camera position\r\n        else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {\r\n            const storedTranslation = TmpVectors.Vector3[0];\r\n            // Save translation\r\n            this._worldMatrix.getTranslationToRef(storedTranslation);\r\n\r\n            // Compute camera position in local space\r\n            const cameraPosition = camera.globalPosition;\r\n            this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);\r\n            const camInObjSpace = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);\r\n            camInObjSpace.normalize();\r\n\r\n            // Find the lookAt info in local space\r\n            const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;\r\n            const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);\r\n            const pitch = -Math.atan2(camInObjSpace.y, len);\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);\r\n\r\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                const eulerAngles = TmpVectors.Vector3[1];\r\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                    eulerAngles.x = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                    eulerAngles.y = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                    eulerAngles.z = 0;\r\n                }\r\n\r\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n            } else {\r\n                Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);\r\n            }\r\n\r\n            // Cancel translation\r\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n\r\n            // Rotate according to lookat (diff from local to lookat)\r\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n            // Restore translation\r\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n        }\r\n\r\n        // Normal matrix\r\n        if (!this.ignoreNonUniformScaling) {\r\n            if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {\r\n                this._updateNonUniformScalingState(true);\r\n            } else if (parent && (<TransformNode>parent)._nonUniformScaling) {\r\n                this._updateNonUniformScalingState((<TransformNode>parent)._nonUniformScaling);\r\n            } else {\r\n                this._updateNonUniformScalingState(false);\r\n            }\r\n        } else {\r\n            this._updateNonUniformScalingState(false);\r\n        }\r\n\r\n        this._afterComputeWorldMatrix();\r\n\r\n        // Absolute position\r\n        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n        this._isAbsoluteSynced = false;\r\n\r\n        // Callbacks\r\n        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\r\n\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Invert(this._worldMatrix);\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Resets this nodeTransform's local matrix to Matrix.Identity().\r\n     * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.\r\n     */\r\n    public resetLocalMatrix(independentOfChildren: boolean = true): void {\r\n        this.computeWorldMatrix();\r\n        if (independentOfChildren) {\r\n            const children = this.getChildren();\r\n            for (let i = 0; i < children.length; ++i) {\r\n                const child = children[i] as TransformNode;\r\n                if (child) {\r\n                    child.computeWorldMatrix();\r\n                    const bakedMatrix = TmpVectors.Matrix[0];\r\n                    child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);\r\n                    const tmpRotationQuaternion = TmpVectors.Quaternion[0];\r\n                    bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);\r\n                    if (child.rotationQuaternion) {\r\n                        child.rotationQuaternion.copyFrom(tmpRotationQuaternion);\r\n                    } else {\r\n                        tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.scaling.copyFromFloats(1, 1, 1);\r\n        this.position.copyFromFloats(0, 0, 0);\r\n        this.rotation.copyFromFloats(0, 0, 0);\r\n\r\n        //only if quaternion is already set\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n        this._worldMatrix = Matrix.Identity();\r\n    }\r\n\r\n    protected _afterComputeWorldMatrix(): void {}\r\n\r\n    /**\r\n     * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\r\n     * @param func callback function to add\r\n     *\r\n     * @returns the TransformNode.\r\n     */\r\n    public registerAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.add(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a registered callback function.\r\n     * @param func callback function to remove\r\n     * @returns the TransformNode.\r\n     */\r\n    public unregisterAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the current mesh in camera space\r\n     * @param camera defines the camera to use\r\n     * @returns a position\r\n     */\r\n    public getPositionInCameraSpace(camera: Nullable<Camera> = null): Vector3 {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n\r\n        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());\r\n    }\r\n\r\n    /**\r\n     * Returns the distance from the mesh to the active camera\r\n     * @param camera defines the camera to use\r\n     * @returns the distance\r\n     */\r\n    public getDistanceToCamera(camera: Nullable<Camera> = null): number {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n        return this.getAbsolutePosition().subtract(camera.globalPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Clone the current transform node\r\n     * @param name Name of the new clone\r\n     * @param newParent New parent for the clone\r\n     * @param doNotCloneChildren Do not clone children hierarchy\r\n     * @returns the new transform node\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<TransformNode> {\r\n        const result = SerializationHelper.Clone(() => new TransformNode(name, this.getScene()), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            const directDescendants = this.getDescendants(true);\r\n            for (let index = 0; index < directDescendants.length; index++) {\r\n                const child = directDescendants[index];\r\n\r\n                if ((<any>child).clone) {\r\n                    (<any>child).clone(name + \".\" + child.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the objects information.\r\n     * @param currentSerializationObject defines the object to serialize in\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(currentSerializationObject?: any): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.uniqueId;\r\n        }\r\n\r\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.uniqueId;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new TransformNode object parsed from the source provided.\r\n     * @param parsedTransformNode is the source.\r\n     * @param scene the scene the object belongs to\r\n     * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with\r\n     * @returns a new TransformNode object parsed from the source provided.\r\n     */\r\n    public static Parse(parsedTransformNode: any, scene: Scene, rootUrl: string): TransformNode {\r\n        const transformNode = SerializationHelper.Parse(() => new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);\r\n\r\n        if (parsedTransformNode.localMatrix) {\r\n            transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));\r\n        } else if (parsedTransformNode.pivotMatrix) {\r\n            transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));\r\n        }\r\n\r\n        transformNode.setEnabled(parsedTransformNode.isEnabled);\r\n\r\n        // Parent\r\n        if (parsedTransformNode.parentId !== undefined) {\r\n            transformNode._waitingParentId = parsedTransformNode.parentId;\r\n        }\r\n\r\n        return transformNode;\r\n    }\r\n\r\n    /**\r\n     * Get all child-transformNodes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getChildTransformNodes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): TransformNode[] {\r\n        const results: Array<TransformNode> = [];\r\n        this._getDescendants(results, directDescendantsOnly, (node: Node) => {\r\n            return (!predicate || predicate(node)) && node instanceof TransformNode;\r\n        });\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this transform node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeTransformNode(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.transformNodes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.transformNodes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n\r\n        if (doNotRecurse) {\r\n            const transformNodes = this.getChildTransformNodes(true);\r\n            for (const transformNode of transformNodes) {\r\n                transformNode.parent = null;\r\n                transformNode.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): TransformNode {\r\n        let storedRotation: Nullable<Vector3> = null;\r\n        let storedRotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion) {\r\n                storedRotationQuaternion = this.rotationQuaternion.clone();\r\n                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else if (this.rotation) {\r\n                storedRotation = this.rotation.clone();\r\n                this.rotation.copyFromFloats(0, 0, 0);\r\n            }\r\n        }\r\n\r\n        const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);\r\n        const sizeVec = boundingVectors.max.subtract(boundingVectors.min);\r\n        const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);\r\n\r\n        if (maxDimension === 0) {\r\n            return this;\r\n        }\r\n\r\n        const scale = 1 / maxDimension;\r\n\r\n        this.scaling.scaleInPlace(scale);\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion && storedRotationQuaternion) {\r\n                this.rotationQuaternion.copyFrom(storedRotationQuaternion);\r\n            } else if (this.rotation && storedRotation) {\r\n                this.rotation.copyFrom(storedRotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _syncAbsoluteScalingAndRotation(): void {\r\n        if (!this._isAbsoluteSynced) {\r\n            this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);\r\n            this._isAbsoluteSynced = true;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}