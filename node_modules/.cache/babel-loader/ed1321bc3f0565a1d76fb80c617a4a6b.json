{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an ellipsoid, defaults to a sphere\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * segments sets the number of horizontal strips optional, default 32\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.dedupTopBottomIndices\n * @returns the VertexData of the ellipsoid\n */\n\nexport function CreateSphereVertexData(options) {\n  var segments = options.segments || 32;\n  var diameterX = options.diameterX || options.diameter || 1;\n  var diameterY = options.diameterY || options.diameter || 1;\n  var diameterZ = options.diameterZ || options.diameter || 1;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n  var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n  var totalZRotationSteps = 2 + segments;\n  var totalYRotationSteps = 2 * totalZRotationSteps;\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n\n  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    var normalizedZ = zRotationStep / totalZRotationSteps;\n    var angleZ = normalizedZ * Math.PI * slice;\n\n    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      var normalizedY = yRotationStep / totalYRotationSteps;\n      var angleY = normalizedY * Math.PI * 2 * arc;\n      var rotationZ = Matrix.RotationZ(-angleZ);\n      var rotationY = Matrix.RotationY(angleY);\n      var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n      var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n      var vertex = complete.multiply(radius);\n      var normal = complete.divide(radius).normalize();\n      positions.push(vertex.x, vertex.y, vertex.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      var verticesCount = positions.length / 3;\n\n      for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        if (dedupTopBottomIndices) {\n          if (zRotationStep > 1) {\n            indices.push(firstIndex);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 1);\n          }\n\n          if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n            indices.push(firstIndex + totalYRotationSteps + 1);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 2);\n          }\n        } else {\n          indices.push(firstIndex);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 2);\n        }\n      }\n    }\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a sphere mesh\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the sphere mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\n */\n\nexport function CreateSphere(name, options, scene) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var sphere = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  sphere._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreateSphereVertexData(options);\n  vertexData.applyToMesh(sphere, options.updatable);\n  return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateSphere directly\n */\n\nexport var SphereBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateSphere: CreateSphere\n};\nVertexData.CreateSphere = CreateSphereVertexData;\n\nMesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\n  var options = {\n    segments: segments,\n    diameterX: diameter,\n    diameterY: diameter,\n    diameterZ: diameter,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateSphere(name, options, scene);\n};","map":{"version":3,"mappings":";AACA,SAASA,OAAT,EAAkBC,MAAlB,QAAgC,4BAAhC;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SAASC,UAAT,QAA2B,uBAA3B;AAGA,SAASC,oBAAT,QAAqC,sCAArC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAM,SAAUC,sBAAV,CAAiCC,OAAjC,EAYL;AACG,MAAMC,QAAQ,GAAWD,OAAO,CAACC,QAAR,IAAoB,EAA7C;AACA,MAAMC,SAAS,GAAWF,OAAO,CAACE,SAAR,IAAqBF,OAAO,CAACG,QAA7B,IAAyC,CAAnE;AACA,MAAMC,SAAS,GAAWJ,OAAO,CAACI,SAAR,IAAqBJ,OAAO,CAACG,QAA7B,IAAyC,CAAnE;AACA,MAAME,SAAS,GAAWL,OAAO,CAACK,SAAR,IAAqBL,OAAO,CAACG,QAA7B,IAAyC,CAAnE;AACA,MAAMG,GAAG,GAAWN,OAAO,CAACM,GAAR,KAAgBN,OAAO,CAACM,GAAR,IAAe,CAAf,IAAoBN,OAAO,CAACM,GAAR,GAAc,CAAlD,IAAuD,GAAvD,GAA6DN,OAAO,CAACM,GAAR,IAAe,GAAhG;AACA,MAAMC,KAAK,GAAWP,OAAO,CAACO,KAAR,IAAiBP,OAAO,CAACO,KAAR,IAAiB,CAAlC,GAAsC,GAAtC,GAA4CP,OAAO,CAACO,KAAR,IAAiB,GAAnF;AACA,MAAMC,eAAe,GAAGR,OAAO,CAACQ,eAAR,KAA4B,CAA5B,GAAgC,CAAhC,GAAoCR,OAAO,CAACQ,eAAR,IAA2BX,UAAU,CAACY,WAAlG;AACA,MAAMC,qBAAqB,GAAG,CAAC,CAACV,OAAO,CAACU,qBAAxC;AAEA,MAAMC,MAAM,GAAG,IAAIjB,OAAJ,CAAYQ,SAAS,GAAG,CAAxB,EAA2BE,SAAS,GAAG,CAAvC,EAA0CC,SAAS,GAAG,CAAtD,CAAf;AAEA,MAAMO,mBAAmB,GAAG,IAAIX,QAAhC;AACA,MAAMY,mBAAmB,GAAG,IAAID,mBAAhC;AAEA,MAAME,OAAO,GAAG,EAAhB;AACA,MAAMC,SAAS,GAAG,EAAlB;AACA,MAAMC,OAAO,GAAG,EAAhB;AACA,MAAMC,GAAG,GAAG,EAAZ;;AAEA,OAAK,IAAIC,aAAa,GAAG,CAAzB,EAA4BA,aAAa,IAAIN,mBAA7C,EAAkEM,aAAa,EAA/E,EAAmF;AAC/E,QAAMC,WAAW,GAAGD,aAAa,GAAGN,mBAApC;AACA,QAAMQ,MAAM,GAAGD,WAAW,GAAGE,IAAI,CAACC,EAAnB,GAAwBf,KAAvC;;AAEA,SAAK,IAAIgB,aAAa,GAAG,CAAzB,EAA4BA,aAAa,IAAIV,mBAA7C,EAAkEU,aAAa,EAA/E,EAAmF;AAC/E,UAAMC,WAAW,GAAGD,aAAa,GAAGV,mBAApC;AAEA,UAAMY,MAAM,GAAGD,WAAW,GAAGH,IAAI,CAACC,EAAnB,GAAwB,CAAxB,GAA4BhB,GAA3C;AAEA,UAAMoB,SAAS,GAAG/B,MAAM,CAACgC,SAAP,CAAiB,CAACP,MAAlB,CAAlB;AACA,UAAMQ,SAAS,GAAGjC,MAAM,CAACkC,SAAP,CAAiBJ,MAAjB,CAAlB;AACA,UAAMK,SAAS,GAAGpC,OAAO,CAACqC,oBAAR,CAA6BrC,OAAO,CAACsC,EAAR,EAA7B,EAA2CN,SAA3C,CAAlB;AACA,UAAMO,QAAQ,GAAGvC,OAAO,CAACqC,oBAAR,CAA6BD,SAA7B,EAAwCF,SAAxC,CAAjB;AAEA,UAAMM,MAAM,GAAGD,QAAQ,CAACE,QAAT,CAAkBxB,MAAlB,CAAf;AACA,UAAMyB,MAAM,GAAGH,QAAQ,CAACI,MAAT,CAAgB1B,MAAhB,EAAwB2B,SAAxB,EAAf;AAEAvB,eAAS,CAACwB,IAAV,CAAeL,MAAM,CAACM,CAAtB,EAAyBN,MAAM,CAACO,CAAhC,EAAmCP,MAAM,CAACQ,CAA1C;AACA1B,aAAO,CAACuB,IAAR,CAAaH,MAAM,CAACI,CAApB,EAAuBJ,MAAM,CAACK,CAA9B,EAAiCL,MAAM,CAACM,CAAxC;AACAzB,SAAG,CAACsB,IAAJ,CAASf,WAAT,EAAsB1B,oBAAoB,CAAC6C,yBAArB,GAAiD,MAAMxB,WAAvD,GAAqEA,WAA3F;AACH;;AAED,QAAID,aAAa,GAAG,CAApB,EAAuB;AACnB,UAAM0B,aAAa,GAAG7B,SAAS,CAAC8B,MAAV,GAAmB,CAAzC;;AACA,WAAK,IAAIC,UAAU,GAAGF,aAAa,GAAG,KAAK/B,mBAAmB,GAAG,CAA3B,CAAtC,EAAqEiC,UAAU,GAAGjC,mBAAb,GAAmC,CAAnC,GAAuC+B,aAA5G,EAA2HE,UAAU,EAArI,EAAyI;AACrI,YAAIpC,qBAAJ,EAA2B;AACvB,cAAIQ,aAAa,GAAG,CAApB,EAAuB;AACnBJ,mBAAO,CAACyB,IAAR,CAAaO,UAAb;AACAhC,mBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAG,CAA1B;AACAhC,mBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AACH;;AACD,cAAIK,aAAa,GAAGN,mBAAhB,IAAuCL,KAAK,GAAG,GAAnD,EAAwD;AACpDO,mBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AACAC,mBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAG,CAA1B;AACAhC,mBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AACH;AACJ,SAXD,MAWO;AACHC,iBAAO,CAACyB,IAAR,CAAaO,UAAb;AACAhC,iBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAG,CAA1B;AACAhC,iBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AAEAC,iBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AACAC,iBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAG,CAA1B;AACAhC,iBAAO,CAACyB,IAAR,CAAaO,UAAU,GAAGjC,mBAAb,GAAmC,CAAhD;AACH;AACJ;AACJ;AACJ,GAnEJ,CAqEG;;;AACAhB,YAAU,CAACkD,aAAX,CAAyBvC,eAAzB,EAA0CO,SAA1C,EAAqDD,OAArD,EAA8DE,OAA9D,EAAuEC,GAAvE,EAA4EjB,OAAO,CAACgD,QAApF,EAA8FhD,OAAO,CAACiD,OAAtG,EAtEH,CAwEG;;;AACA,MAAMC,UAAU,GAAG,IAAIrD,UAAJ,EAAnB;AAEAqD,YAAU,CAACpC,OAAX,GAAqBA,OAArB;AACAoC,YAAU,CAACnC,SAAX,GAAuBA,SAAvB;AACAmC,YAAU,CAAClC,OAAX,GAAqBA,OAArB;AACAkC,YAAU,CAACjC,GAAX,GAAiBA,GAAjB;AAEA,SAAOiC,UAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,YAAV,CACFC,IADE,EAEFpD,OAFE,EAeFqD,KAfE,EAe2B;AAb7B;AAAArD;AAYM;;AACN;AAAAqD;AAA6B;;AAE7B,MAAMC,MAAM,GAAG,IAAI1D,IAAJ,CAASwD,IAAT,EAAeC,KAAf,CAAf;AAEArD,SAAO,CAACQ,eAAR,GAA0BZ,IAAI,CAAC2D,0BAAL,CAAgCvD,OAAO,CAACQ,eAAxC,CAA1B;AACA8C,QAAM,CAACE,+BAAP,GAAyCxD,OAAO,CAACQ,eAAjD;AAEA,MAAM0C,UAAU,GAAGnD,sBAAsB,CAACC,OAAD,CAAzC;AAEAkD,YAAU,CAACO,WAAX,CAAuBH,MAAvB,EAA+BtD,OAAO,CAAC0D,SAAvC;AAEA,SAAOJ,MAAP;AACH;AAED;;;;;AAIA,OAAO,IAAMK,aAAa,GAAG;AACzB;AACAR,cAAY;AAFa,CAAtB;AAKPtD,UAAU,CAACsD,YAAX,GAA0BpD,sBAA1B;;AAECH,IAAY,CAACuD,YAAb,GAA4B,UAACC,IAAD,EAAenD,QAAf,EAAiCE,QAAjC,EAAmDkD,KAAnD,EAAkEK,SAAlE,EAAuFlD,eAAvF,EAA+G;AACxI,MAAMR,OAAO,GAAG;AACZC,YAAQ,EAAEA,QADE;AAEZC,aAAS,EAAEC,QAFC;AAGZC,aAAS,EAAED,QAHC;AAIZE,aAAS,EAAEF,QAJC;AAKZK,mBAAe,EAAEA,eALL;AAMZkD,aAAS,EAAEA;AANC,GAAhB;AASA,SAAOP,YAAY,CAACC,IAAD,EAAOpD,OAAP,EAAgBqD,KAAhB,CAAnB;AACH,CAXA","names":["Vector3","Matrix","Mesh","VertexData","CompatibilityOptions","CreateSphereVertexData","options","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","normalize","push","x","y","z","UseOpenGLOrientationForUV","verticesCount","length","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","CreateSphere","name","scene","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","SphereBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/sphereBuilder.ts"],"sourcesContent":["import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = options.segments || 32;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\n(Mesh as any).CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}