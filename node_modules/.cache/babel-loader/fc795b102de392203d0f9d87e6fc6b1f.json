{"ast":null,"code":"import { RenderingGroup } from \"./renderingGroup.js\";\n/**\n * This class is used by the onRenderingGroupObservable\n */\n\nvar RenderingGroupInfo =\n/** @class */\nfunction () {\n  function RenderingGroupInfo() {}\n\n  return RenderingGroupInfo;\n}();\n\nexport { RenderingGroupInfo };\n/**\n * This is the manager responsible of all the rendering for meshes sprites and particles.\n * It is enable to manage the different groups as well as the different necessary sort functions.\n * This should not be used directly aside of the few static configurations\n */\n\nvar RenderingManager =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new rendering group for a particular scene\n   * @param scene Defines the scene the groups belongs to\n   */\n  function RenderingManager(scene) {\n    /**\n     * @hidden\n     */\n    this._useSceneAutoClearSetup = false;\n    this._renderingGroups = new Array();\n    this._autoClearDepthStencil = {};\n    this._customOpaqueSortCompareFn = {};\n    this._customAlphaTestSortCompareFn = {};\n    this._customTransparentSortCompareFn = {};\n    this._renderingGroupInfo = new RenderingGroupInfo();\n    this._scene = scene;\n\n    for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n      this._autoClearDepthStencil[i] = {\n        autoClear: true,\n        depth: true,\n        stencil: true\n      };\n    }\n  }\n\n  RenderingManager.prototype._clearDepthStencilBuffer = function (depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    if (this._depthStencilBufferAlreadyCleaned) {\n      return;\n    }\n\n    this._scene.getEngine().clear(null, false, depth, stencil);\n\n    this._depthStencilBufferAlreadyCleaned = true;\n  };\n  /**\n   * Renders the entire managed groups. This is used by the scene or the different render targets.\n   * @param customRenderFunction\n   * @param activeMeshes\n   * @param renderParticles\n   * @param renderSprites\n   * @hidden\n   */\n\n\n  RenderingManager.prototype.render = function (customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n    // Update the observable context (not null as it only goes away on dispose)\n    var info = this._renderingGroupInfo;\n    info.scene = this._scene;\n    info.camera = this._scene.activeCamera; // Dispatch sprites\n\n    if (this._scene.spriteManagers && renderSprites) {\n      for (var index = 0; index < this._scene.spriteManagers.length; index++) {\n        var manager = this._scene.spriteManagers[index];\n        this.dispatchSprites(manager);\n      }\n    } // Render\n\n\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n      var renderingGroup = this._renderingGroups[index];\n\n      if (!renderingGroup || renderingGroup._empty) {\n        continue;\n      }\n\n      var renderingGroupMask = Math.pow(2, index);\n      info.renderingGroupId = index; // Before Observable\n\n      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask); // Clear depth/stencil if needed\n\n\n      if (RenderingManager.AUTOCLEAR) {\n        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n\n        if (autoClear && autoClear.autoClear) {\n          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n        }\n      } // Render\n\n\n      for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(index);\n      }\n\n      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n\n      for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {\n        var step = _c[_b];\n        step.action(index);\n      } // After Observable\n\n\n      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n    }\n  };\n  /**\n   * Resets the different information of the group to prepare a new frame\n   * @hidden\n   */\n\n\n  RenderingManager.prototype.reset = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.prepare();\n      }\n    }\n  };\n  /**\n   * Dispose and release the group and its associated resources.\n   * @hidden\n   */\n\n\n  RenderingManager.prototype.dispose = function () {\n    this.freeRenderingGroups();\n    this._renderingGroups.length = 0;\n    this._renderingGroupInfo = null;\n  };\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n\n\n  RenderingManager.prototype.freeRenderingGroups = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.dispose();\n      }\n    }\n  };\n\n  RenderingManager.prototype._prepareRenderingGroup = function (renderingGroupId) {\n    if (this._renderingGroups[renderingGroupId] === undefined) {\n      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n    }\n  };\n  /**\n   * Add a sprite manager to the rendering manager in order to render it this frame.\n   * @param spriteManager Define the sprite manager to render\n   */\n\n\n  RenderingManager.prototype.dispatchSprites = function (spriteManager) {\n    var renderingGroupId = spriteManager.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\n  };\n  /**\n   * Add a particle system to the rendering manager in order to render it this frame.\n   * @param particleSystem Define the particle system to render\n   */\n\n\n  RenderingManager.prototype.dispatchParticles = function (particleSystem) {\n    var renderingGroupId = particleSystem.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\n  };\n  /**\n   * Add a submesh to the manager in order to render it this frame\n   * @param subMesh The submesh to dispatch\n   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n\n\n  RenderingManager.prototype.dispatch = function (subMesh, mesh, material) {\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n\n    var renderingGroupId = mesh.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\n  };\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversely depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n\n\n  RenderingManager.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n\n    if (this._renderingGroups[renderingGroupId]) {\n      var group = this._renderingGroups[renderingGroupId];\n      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n    }\n  };\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n\n\n  RenderingManager.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._autoClearDepthStencil[renderingGroupId] = {\n      autoClear: autoClearDepthStencil,\n      depth: depth,\n      stencil: stencil\n    };\n  };\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n\n\n  RenderingManager.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._autoClearDepthStencil[index];\n  };\n  /**\n   * The max id used for rendering groups (not included)\n   */\n\n\n  RenderingManager.MAX_RENDERINGGROUPS = 4;\n  /**\n   * The min id used for rendering groups (included)\n   */\n\n  RenderingManager.MIN_RENDERINGGROUPS = 0;\n  /**\n   * Used to globally prevent autoclearing scenes.\n   */\n\n  RenderingManager.AUTOCLEAR = true;\n  return RenderingManager;\n}();\n\nexport { RenderingManager };","map":{"version":3,"mappings":"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","names":["RenderingGroup","scene","Array","RenderingGroupInfo","_scene","i","RenderingManager","MIN_RENDERINGGROUPS","MAX_RENDERINGGROUPS","_autoClearDepthStencil","autoClear","depth","stencil","_depthStencilBufferAlreadyCleaned","getEngine","clear","customRenderFunction","activeMeshes","renderParticles","renderSprites","info","_renderingGroupInfo","camera","activeCamera","spriteManagers","index","length","manager","dispatchSprites","renderingGroup","_renderingGroups","_empty","renderingGroupMask","Math","pow","renderingGroupId","onBeforeRenderingGroupObservable","notifyObservers","AUTOCLEAR","_useSceneAutoClearSetup","getAutoClearDepthStencilSetup","_clearDepthStencilBuffer","_beforeRenderingGroupDrawStage","_i","step","action","render","_afterRenderingGroupDrawStage","_b","onAfterRenderingGroupObservable","prepare","freeRenderingGroups","dispose","undefined","_customOpaqueSortCompareFn","_customAlphaTestSortCompareFn","_customTransparentSortCompareFn","spriteManager","_prepareRenderingGroup","particleSystem","dispatchParticles","subMesh","mesh","material","getMesh","dispatch","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","group","autoClearDepthStencil"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/renderingManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type SubMesh = import(\"../Meshes/subMesh\").SubMesh;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @param customRenderFunction\r\n     * @param activeMeshes\r\n     * @param renderParticles\r\n     * @param renderSprites\r\n     * @hidden\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = Math.pow(2, index);\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @hidden\r\n     */\r\n    public reset(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @hidden\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        const renderingGroupId = spriteManager.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        const renderingGroupId = particleSystem.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        const renderingGroupId = mesh.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}