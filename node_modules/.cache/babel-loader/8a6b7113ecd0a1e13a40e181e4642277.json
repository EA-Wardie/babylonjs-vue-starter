{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\n/**\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\n */\n\nvar AutoRotationBehavior =\n/** @class */\nfunction () {\n  function AutoRotationBehavior() {\n    this._zoomStopsAnimation = false;\n    this._idleRotationSpeed = 0.05;\n    this._idleRotationWaitTime = 2000;\n    this._idleRotationSpinupTime = 2000;\n    this._isPointerDown = false;\n    this._lastFrameTime = null;\n    this._lastInteractionTime = -Infinity;\n    this._cameraRotationSpeed = 0;\n    this._lastFrameRadius = 0;\n  }\n\n  Object.defineProperty(AutoRotationBehavior.prototype, \"name\", {\n    /**\n     * Gets the name of the behavior.\n     */\n    get: function get() {\n      return \"AutoRotation\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"zoomStopsAnimation\", {\n    /**\n     * Gets the flag that indicates if user zooming should stop animation.\n     */\n    get: function get() {\n      return this._zoomStopsAnimation;\n    },\n\n    /**\n     * Sets the flag that indicates if user zooming should stop animation.\n     */\n    set: function set(flag) {\n      this._zoomStopsAnimation = flag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpeed\", {\n    /**\n     * Gets the default speed at which the camera rotates around the model.\n     */\n    get: function get() {\n      return this._idleRotationSpeed;\n    },\n\n    /**\n     * Sets the default speed at which the camera rotates around the model.\n     */\n    set: function set(speed) {\n      this._idleRotationSpeed = speed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationWaitTime\", {\n    /**\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\n     */\n    get: function get() {\n      return this._idleRotationWaitTime;\n    },\n\n    /**\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\n     */\n    set: function set(time) {\n      this._idleRotationWaitTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpinupTime\", {\n    /**\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\n     */\n    get: function get() {\n      return this._idleRotationSpinupTime;\n    },\n\n    /**\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\n     */\n    set: function set(time) {\n      this._idleRotationSpinupTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"rotationInProgress\", {\n    /**\n     * Gets a value indicating if the camera is currently rotating because of this behavior\n     */\n    get: function get() {\n      return Math.abs(this._cameraRotationSpeed) > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initializes the behavior.\n   */\n\n  AutoRotationBehavior.prototype.init = function () {// Do nothing\n  };\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n\n\n  AutoRotationBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n\n    var scene = this._attachedCamera.getScene();\n\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        _this._isPointerDown = true;\n        return;\n      }\n\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        _this._isPointerDown = false;\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      var now = PrecisionDate.Now;\n      var dt = 0;\n\n      if (_this._lastFrameTime != null) {\n        dt = now - _this._lastFrameTime;\n      }\n\n      _this._lastFrameTime = now; // Stop the animation if there is user interaction and the animation should stop for this interaction\n\n      _this._applyUserInteraction();\n\n      var timeToRotation = now - _this._lastInteractionTime - _this._idleRotationWaitTime;\n      var scale = Math.max(Math.min(timeToRotation / _this._idleRotationSpinupTime, 1), 0);\n      _this._cameraRotationSpeed = _this._idleRotationSpeed * scale; // Step camera rotation by rotation speed\n\n      if (_this._attachedCamera) {\n        _this._attachedCamera.alpha -= _this._cameraRotationSpeed * (dt / 1000);\n      }\n    });\n  };\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n\n\n  AutoRotationBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    var scene = this._attachedCamera.getScene();\n\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n\n    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n\n    this._attachedCamera = null;\n  };\n  /**\n   * Force-reset the last interaction time\n   * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\n   */\n\n\n  AutoRotationBehavior.prototype.resetLastInteractionTime = function (customTime) {\n    this._lastInteractionTime = customTime !== null && customTime !== void 0 ? customTime : PrecisionDate.Now;\n  };\n  /**\n   * Returns true if user is scrolling.\n   * @return true if user is scrolling.\n   */\n\n\n  AutoRotationBehavior.prototype._userIsZooming = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    return this._attachedCamera.inertialRadiusOffset !== 0;\n  };\n\n  AutoRotationBehavior.prototype._shouldAnimationStopForInteraction = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    var zoomHasHitLimit = false;\n\n    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\n      zoomHasHitLimit = true;\n    } // Update the record of previous radius - works as an approx. indicator of hitting radius limits\n\n\n    this._lastFrameRadius = this._attachedCamera.radius;\n    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\n  };\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n\n\n  AutoRotationBehavior.prototype._applyUserInteraction = function () {\n    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\n      this._lastInteractionTime = PrecisionDate.Now;\n    }\n  }; // Tools\n\n\n  AutoRotationBehavior.prototype._userIsMoving = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  };\n\n  return AutoRotationBehavior;\n}();\n\nexport { AutoRotationBehavior };","map":{"version":3,"mappings":"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","names":["PointerEventTypes","PrecisionDate","Infinity","Object","AutoRotationBehavior","_zoomStopsAnimation","flag","_idleRotationSpeed","speed","_idleRotationWaitTime","time","_idleRotationSpinupTime","Math","abs","_cameraRotationSpeed","camera","_attachedCamera","scene","getScene","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","_this","_isPointerDown","POINTERUP","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","now","Now","dt","_lastFrameTime","_applyUserInteraction","timeToRotation","_lastInteractionTime","scale","max","min","alpha","remove","customTime","inertialRadiusOffset","zoomHasHitLimit","_lastFrameRadius","radius","_userIsZooming","_userIsMoving","_shouldAnimationStopForInteraction","inertialAlphaOffset","inertialBetaOffset","inertialPanningX","inertialPanningY"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Cameras/autoRotationBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @return true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}