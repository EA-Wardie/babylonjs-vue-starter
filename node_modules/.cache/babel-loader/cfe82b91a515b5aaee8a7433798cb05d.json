{"ast":null,"code":"import \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport { __decorate, __generator } from \"tslib\";\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\n */\n\nvar VertexData =\n/** @class */\nfunction () {\n  function VertexData() {\n    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\n  }\n  /**\n   * Uses the passed data array to set the set the values for the specified kind of data\n   * @param data a linear array of floating numbers\n   * @param kind the type of data that is being set, eg positions, colors etc\n   */\n\n\n  VertexData.prototype.set = function (data, kind) {\n    if (!data.length) {\n      Logger.Warn(\"Setting vertex data kind '\".concat(kind, \"' with an empty array\"));\n    }\n\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  };\n  /**\n   * Associates the vertexData to the passed Mesh.\n   * Sets it as updatable or not (default `false`)\n   * @param mesh the mesh the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns the VertexData\n   */\n\n\n  VertexData.prototype.applyToMesh = function (mesh, updatable) {\n    this._applyTo(mesh, updatable, false);\n\n    return this;\n  };\n  /**\n   * Associates the vertexData to the passed Geometry.\n   * Sets it as updatable or not (default `false`)\n   * @param geometry the geometry the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns VertexData\n   */\n\n\n  VertexData.prototype.applyToGeometry = function (geometry, updatable) {\n    this._applyTo(geometry, updatable, false);\n\n    return this;\n  };\n  /**\n   * Updates the associated mesh\n   * @param mesh the mesh to be updated\n   * @returns VertexData\n   */\n\n\n  VertexData.prototype.updateMesh = function (mesh) {\n    this._update(mesh);\n\n    return this;\n  };\n  /**\n   * Updates the associated geometry\n   * @param geometry the geometry to be updated\n   * @returns VertexData.\n   */\n\n\n  VertexData.prototype.updateGeometry = function (geometry) {\n    this._update(geometry);\n\n    return this;\n  };\n  /**\n   * @param meshOrGeometry\n   * @param updatable\n   * @param isAsync\n   * @hidden\n   */\n\n\n  VertexData.prototype._applyToCoroutine = function (meshOrGeometry, updatable, isAsync) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!this.positions) return [3\n          /*break*/\n          , 2];\n          meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          ];\n\n        case 1:\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          if (!this.normals) return [3\n          /*break*/\n          , 4];\n          meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          ];\n\n        case 3:\n          _a.sent();\n\n          _a.label = 4;\n\n        case 4:\n          if (!this.tangents) return [3\n          /*break*/\n          , 6];\n          meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 6];\n          return [4\n          /*yield*/\n          ];\n\n        case 5:\n          _a.sent();\n\n          _a.label = 6;\n\n        case 6:\n          if (!this.uvs) return [3\n          /*break*/\n          , 8];\n          meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 8];\n          return [4\n          /*yield*/\n          ];\n\n        case 7:\n          _a.sent();\n\n          _a.label = 8;\n\n        case 8:\n          if (!this.uvs2) return [3\n          /*break*/\n          , 10];\n          meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 10];\n          return [4\n          /*yield*/\n          ];\n\n        case 9:\n          _a.sent();\n\n          _a.label = 10;\n\n        case 10:\n          if (!this.uvs3) return [3\n          /*break*/\n          , 12];\n          meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 12];\n          return [4\n          /*yield*/\n          ];\n\n        case 11:\n          _a.sent();\n\n          _a.label = 12;\n\n        case 12:\n          if (!this.uvs4) return [3\n          /*break*/\n          , 14];\n          meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 14];\n          return [4\n          /*yield*/\n          ];\n\n        case 13:\n          _a.sent();\n\n          _a.label = 14;\n\n        case 14:\n          if (!this.uvs5) return [3\n          /*break*/\n          , 16];\n          meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 16];\n          return [4\n          /*yield*/\n          ];\n\n        case 15:\n          _a.sent();\n\n          _a.label = 16;\n\n        case 16:\n          if (!this.uvs6) return [3\n          /*break*/\n          , 18];\n          meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 18];\n          return [4\n          /*yield*/\n          ];\n\n        case 17:\n          _a.sent();\n\n          _a.label = 18;\n\n        case 18:\n          if (!this.colors) return [3\n          /*break*/\n          , 20];\n          meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 20];\n          return [4\n          /*yield*/\n          ];\n\n        case 19:\n          _a.sent();\n\n          _a.label = 20;\n\n        case 20:\n          if (!this.matricesIndices) return [3\n          /*break*/\n          , 22];\n          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 22];\n          return [4\n          /*yield*/\n          ];\n\n        case 21:\n          _a.sent();\n\n          _a.label = 22;\n\n        case 22:\n          if (!this.matricesWeights) return [3\n          /*break*/\n          , 24];\n          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 24];\n          return [4\n          /*yield*/\n          ];\n\n        case 23:\n          _a.sent();\n\n          _a.label = 24;\n\n        case 24:\n          if (!this.matricesIndicesExtra) return [3\n          /*break*/\n          , 26];\n          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 26];\n          return [4\n          /*yield*/\n          ];\n\n        case 25:\n          _a.sent();\n\n          _a.label = 26;\n\n        case 26:\n          if (!this.matricesWeightsExtra) return [3\n          /*break*/\n          , 28];\n          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 28];\n          return [4\n          /*yield*/\n          ];\n\n        case 27:\n          _a.sent();\n\n          _a.label = 28;\n\n        case 28:\n          if (!this.indices) return [3\n          /*break*/\n          , 31];\n          meshOrGeometry.setIndices(this.indices, null, updatable);\n          if (!isAsync) return [3\n          /*break*/\n          , 30];\n          return [4\n          /*yield*/\n          ];\n\n        case 29:\n          _a.sent();\n\n          _a.label = 30;\n\n        case 30:\n          return [3\n          /*break*/\n          , 32];\n\n        case 31:\n          meshOrGeometry.setIndices([], null);\n          _a.label = 32;\n\n        case 32:\n          return [2\n          /*return*/\n          , this];\n      }\n    });\n  };\n\n  VertexData.prototype._update = function (meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n\n    return this;\n  };\n\n  VertexData._TransformVector3Coordinates = function (coordinates, transformation, offset, length) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (length === void 0) {\n      length = coordinates.length;\n    }\n\n    var coordinate = TmpVectors.Vector3[0];\n    var transformedCoordinate = TmpVectors.Vector3[1];\n\n    for (var index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(coordinates, index, coordinate);\n      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\n      coordinates[index] = transformedCoordinate.x;\n      coordinates[index + 1] = transformedCoordinate.y;\n      coordinates[index + 2] = transformedCoordinate.z;\n    }\n  };\n\n  VertexData._TransformVector3Normals = function (normals, transformation, offset, length) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (length === void 0) {\n      length = normals.length;\n    }\n\n    var normal = TmpVectors.Vector3[0];\n    var transformedNormal = TmpVectors.Vector3[1];\n\n    for (var index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n    }\n  };\n\n  VertexData._TransformVector4Normals = function (normals, transformation, offset, length) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (length === void 0) {\n      length = normals.length;\n    }\n\n    var normal = TmpVectors.Vector4[0];\n    var transformedNormal = TmpVectors.Vector4[1];\n\n    for (var index = offset; index < offset + length; index += 4) {\n      Vector4.FromArrayToRef(normals, index, normal);\n      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n      normals[index + 3] = transformedNormal.w;\n    }\n  };\n\n  VertexData._FlipFaces = function (indices, offset, length) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (length === void 0) {\n      length = indices.length;\n    }\n\n    for (var index = offset; index < offset + length; index += 3) {\n      var tmp = indices[index + 1];\n      indices[index + 1] = indices[index + 2];\n      indices[index + 2] = tmp;\n    }\n  };\n  /**\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\n   * @param matrix the transforming matrix\n   * @returns the VertexData\n   */\n\n\n  VertexData.prototype.transform = function (matrix) {\n    var flip = matrix.determinant() < 0;\n\n    if (this.positions) {\n      VertexData._TransformVector3Coordinates(this.positions, matrix);\n    }\n\n    if (this.normals) {\n      VertexData._TransformVector3Normals(this.normals, matrix);\n    }\n\n    if (this.tangents) {\n      VertexData._TransformVector4Normals(this.tangents, matrix);\n    }\n\n    if (flip && this.indices) {\n      VertexData._FlipFaces(this.indices);\n    }\n\n    return this;\n  };\n  /**\n   * Merges the passed VertexData into the current one\n   * @param others the VertexData to be merged into the current one\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\n   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\n   * @returns the modified VertexData\n   */\n\n\n  VertexData.prototype.merge = function (others, use32BitsIndices, forceCloneIndices) {\n    if (use32BitsIndices === void 0) {\n      use32BitsIndices = false;\n    }\n\n    if (forceCloneIndices === void 0) {\n      forceCloneIndices = false;\n    }\n\n    var vertexDatas = Array.isArray(others) ? others.map(function (other) {\n      return [other, undefined];\n    }) : [[others, undefined]];\n    return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\n  };\n  /**\n   * @param transform\n   * @param vertexDatas\n   * @param use32BitsIndices\n   * @param isAsync\n   * @param forceCloneIndices\n   * @hidden\n   */\n\n\n  VertexData.prototype._mergeCoroutine = function (transform, vertexDatas, use32BitsIndices, isAsync, forceCloneIndices) {\n    var others, _i, others_1, other, totalIndices, sliceIndices, indices, indicesOffset, temp, positionsOffset, _a, vertexDatas_1, _b, other, transform_1, index;\n\n    var _this = this;\n\n    var _c, _d, _e, _f;\n\n    if (use32BitsIndices === void 0) {\n      use32BitsIndices = false;\n    }\n\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          this._validate();\n\n          others = vertexDatas.map(function (vertexData) {\n            return vertexData[0];\n          });\n\n          for (_i = 0, others_1 = others; _i < others_1.length; _i++) {\n            other = others_1[_i];\n\n            other._validate();\n\n            if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n              throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n            }\n          }\n\n          totalIndices = others.reduce(function (indexSum, vertexData) {\n            var _a, _b;\n\n            return indexSum + ((_b = (_a = vertexData.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n          }, (_d = (_c = this.indices) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0);\n          sliceIndices = forceCloneIndices || others.some(function (vertexData) {\n            return vertexData.indices === _this.indices;\n          });\n          indices = sliceIndices ? (_e = this.indices) === null || _e === void 0 ? void 0 : _e.slice() : this.indices;\n          if (!(totalIndices > 0)) return [3\n          /*break*/\n          , 4];\n          indicesOffset = (_f = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _f !== void 0 ? _f : 0;\n\n          if (!indices) {\n            indices = new Array(totalIndices);\n          }\n\n          if (indices.length !== totalIndices) {\n            if (Array.isArray(indices)) {\n              indices.length = totalIndices;\n            } else {\n              temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\n              temp.set(indices);\n              indices = temp;\n            }\n\n            if (transform && transform.determinant() < 0) {\n              VertexData._FlipFaces(indices, 0, indicesOffset);\n            }\n          }\n\n          positionsOffset = this.positions ? this.positions.length / 3 : 0;\n          _a = 0, vertexDatas_1 = vertexDatas;\n          _g.label = 1;\n\n        case 1:\n          if (!(_a < vertexDatas_1.length)) return [3\n          /*break*/\n          , 4];\n          _b = vertexDatas_1[_a], other = _b[0], transform_1 = _b[1];\n          if (!other.indices) return [3\n          /*break*/\n          , 3];\n\n          for (index = 0; index < other.indices.length; index++) {\n            indices[indicesOffset + index] = other.indices[index] + positionsOffset;\n          }\n\n          if (transform_1 && transform_1.determinant() < 0) {\n            VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\n          } // The call to _validate already checked for positions\n\n\n          positionsOffset += other.positions.length / 3;\n          indicesOffset += other.indices.length;\n          if (!isAsync) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          ];\n\n        case 2:\n          _g.sent();\n\n          _g.label = 3;\n\n        case 3:\n          _a++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          this.indices = indices;\n          this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map(function (other) {\n            return [other[0].positions, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 6];\n          return [4\n          /*yield*/\n          ];\n\n        case 5:\n          _g.sent();\n\n          _g.label = 6;\n\n        case 6:\n          this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map(function (other) {\n            return [other[0].normals, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 8];\n          return [4\n          /*yield*/\n          ];\n\n        case 7:\n          _g.sent();\n\n          _g.label = 8;\n\n        case 8:\n          this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map(function (other) {\n            return [other[0].tangents, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 10];\n          return [4\n          /*yield*/\n          ];\n\n        case 9:\n          _g.sent();\n\n          _g.label = 10;\n\n        case 10:\n          this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 12];\n          return [4\n          /*yield*/\n          ];\n\n        case 11:\n          _g.sent();\n\n          _g.label = 12;\n\n        case 12:\n          this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs2, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 14];\n          return [4\n          /*yield*/\n          ];\n\n        case 13:\n          _g.sent();\n\n          _g.label = 14;\n\n        case 14:\n          this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs3, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 16];\n          return [4\n          /*yield*/\n          ];\n\n        case 15:\n          _g.sent();\n\n          _g.label = 16;\n\n        case 16:\n          this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs4, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 18];\n          return [4\n          /*yield*/\n          ];\n\n        case 17:\n          _g.sent();\n\n          _g.label = 18;\n\n        case 18:\n          this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs5, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 20];\n          return [4\n          /*yield*/\n          ];\n\n        case 19:\n          _g.sent();\n\n          _g.label = 20;\n\n        case 20:\n          this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map(function (other) {\n            return [other[0].uvs6, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 22];\n          return [4\n          /*yield*/\n          ];\n\n        case 21:\n          _g.sent();\n\n          _g.label = 22;\n\n        case 22:\n          this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map(function (other) {\n            return [other[0].colors, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 24];\n          return [4\n          /*yield*/\n          ];\n\n        case 23:\n          _g.sent();\n\n          _g.label = 24;\n\n        case 24:\n          this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map(function (other) {\n            return [other[0].matricesIndices, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 26];\n          return [4\n          /*yield*/\n          ];\n\n        case 25:\n          _g.sent();\n\n          _g.label = 26;\n\n        case 26:\n          this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map(function (other) {\n            return [other[0].matricesWeights, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 28];\n          return [4\n          /*yield*/\n          ];\n\n        case 27:\n          _g.sent();\n\n          _g.label = 28;\n\n        case 28:\n          this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map(function (other) {\n            return [other[0].matricesIndicesExtra, other[1]];\n          }));\n          if (!isAsync) return [3\n          /*break*/\n          , 30];\n          return [4\n          /*yield*/\n          ];\n\n        case 29:\n          _g.sent();\n\n          _g.label = 30;\n\n        case 30:\n          this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map(function (other) {\n            return [other[0].matricesWeightsExtra, other[1]];\n          }));\n          return [2\n          /*return*/\n          , this];\n      }\n    });\n  };\n\n  VertexData._MergeElement = function (kind, source, transform, others) {\n    var nonNullOthers = others.filter(function (other) {\n      return other[0] !== null && other[0] !== undefined;\n    }); // If there is no source to copy and no other non-null sources then skip this element.\n\n    if (!source && nonNullOthers.length == 0) {\n      return source;\n    }\n\n    if (!source) {\n      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\n    }\n\n    var len = nonNullOthers.reduce(function (sumLen, elements) {\n      return sumLen + elements[0].length;\n    }, source.length);\n    var transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : function () {};\n\n    if (source instanceof Float32Array) {\n      // use non-loop method when the source is Float32Array\n      var ret32 = new Float32Array(len);\n      ret32.set(source);\n      transform && transformRange(ret32, transform, 0, source.length);\n      var offset = source.length;\n\n      for (var _i = 0, nonNullOthers_1 = nonNullOthers; _i < nonNullOthers_1.length; _i++) {\n        var _a = nonNullOthers_1[_i],\n            vertexData = _a[0],\n            transform_2 = _a[1];\n        ret32.set(vertexData, offset);\n        transform_2 && transformRange(ret32, transform_2, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n\n      return ret32;\n    } else {\n      // don't use concat as it is super slow, just loop for other cases\n      var ret = new Array(len);\n\n      for (var i = 0; i < source.length; i++) {\n        ret[i] = source[i];\n      }\n\n      transform && transformRange(ret, transform, 0, source.length);\n      var offset = source.length;\n\n      for (var _b = 0, nonNullOthers_2 = nonNullOthers; _b < nonNullOthers_2.length; _b++) {\n        var _c = nonNullOthers_2[_b],\n            vertexData = _c[0],\n            transform_3 = _c[1];\n\n        for (var i = 0; i < vertexData.length; i++) {\n          ret[offset + i] = vertexData[i];\n        }\n\n        transform_3 && transformRange(ret, transform_3, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n\n      return ret;\n    }\n  };\n\n  VertexData.prototype._validate = function () {\n    if (!this.positions) {\n      throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\n    }\n\n    var getElementCount = function getElementCount(kind, values) {\n      var stride = VertexBuffer.DeduceStride(kind);\n\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n\n      return values.length / stride;\n    };\n\n    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n\n    var validateElementCount = function validateElementCount(kind, values) {\n      var elementCount = getElementCount(kind, values);\n\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  };\n  /**\n   * Serializes the VertexData\n   * @returns a serialized object\n   */\n\n\n  VertexData.prototype.serialize = function () {\n    var serializationObject = {};\n\n    if (this.positions) {\n      serializationObject.positions = this.positions;\n    }\n\n    if (this.normals) {\n      serializationObject.normals = this.normals;\n    }\n\n    if (this.tangents) {\n      serializationObject.tangents = this.tangents;\n    }\n\n    if (this.uvs) {\n      serializationObject.uvs = this.uvs;\n    }\n\n    if (this.uvs2) {\n      serializationObject.uvs2 = this.uvs2;\n    }\n\n    if (this.uvs3) {\n      serializationObject.uvs3 = this.uvs3;\n    }\n\n    if (this.uvs4) {\n      serializationObject.uvs4 = this.uvs4;\n    }\n\n    if (this.uvs5) {\n      serializationObject.uvs5 = this.uvs5;\n    }\n\n    if (this.uvs6) {\n      serializationObject.uvs6 = this.uvs6;\n    }\n\n    if (this.colors) {\n      serializationObject.colors = this.colors;\n    }\n\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = this.matricesIndices;\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = this.matricesWeights;\n    }\n\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n    }\n\n    serializationObject.indices = this.indices;\n    return serializationObject;\n  }; // Statics\n\n  /**\n   * Extracts the vertexData from a mesh\n   * @param mesh the mesh from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n\n\n  VertexData.ExtractFromMesh = function (mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  };\n  /**\n   * Extracts the vertexData from the geometry\n   * @param geometry the geometry from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n\n\n  VertexData.ExtractFromGeometry = function (geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  };\n\n  VertexData._ExtractFrom = function (meshOrGeometry, copyWhenShared, forceCopy) {\n    var result = new VertexData();\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  };\n  /**\n   * Creates the VertexData for a Ribbon\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n   * * pathArray array of paths, each of which an array of successive Vector3\n   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n   * @param options.pathArray\n   * @param options.closeArray\n   * @param options.closePath\n   * @param options.offset\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @param options.invertUV\n   * @param options.uvs\n   * @param options.colors\n   * @returns the VertexData of the ribbon\n   * @deprecated use CreateRibbonVertexData instead\n   */\n\n\n  VertexData.CreateRibbon = function (options) {\n    throw _WarnImport(\"ribbonBuilder\");\n  };\n  /**\n   * Creates the VertexData for a box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * size sets the width, height and depth of the box to the value of size, optional default 1\n   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\n   */\n\n\n  VertexData.CreateBox = function (options) {\n    throw _WarnImport(\"boxBuilder\");\n  };\n  /**\n   * Creates the VertexData for a tiled box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * faceTiles sets the pattern, tile size and number of tiles for a face\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param options.pattern\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateTiledBoxVertexData instead\n   */\n\n\n  VertexData.CreateTiledBox = function (options) {\n    throw _WarnImport(\"tiledBoxBuilder\");\n  };\n  /**\n   * Creates the VertexData for a tiled plane\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * pattern a limited pattern arrangement depending on the number\n   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.pattern\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the tiled plane\n   * @deprecated use CreateTiledPlaneVertexData instead\n   */\n\n\n  VertexData.CreateTiledPlane = function (options) {\n    throw _WarnImport(\"tiledPlaneBuilder\");\n  };\n  /**\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * segments sets the number of horizontal strips optional, default 32\n   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.segments\n   * @param options.diameter\n   * @param options.diameterX\n   * @param options.diameterY\n   * @param options.diameterZ\n   * @param options.arc\n   * @param options.slice\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the ellipsoid\n   * @deprecated use CreateSphereVertexData instead\n   */\n\n\n  VertexData.CreateSphere = function (options) {\n    throw _WarnImport(\"sphereBuilder\");\n  };\n  /**\n   * Creates the VertexData for a cylinder, cone or prism\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * height sets the height (y direction) of the cylinder, optional, default 2\n   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n   * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * subdivisions` the number of rings along the cylinder height, optional, default 1\n   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.height\n   * @param options.diameterTop\n   * @param options.diameterBottom\n   * @param options.diameter\n   * @param options.tessellation\n   * @param options.subdivisions\n   * @param options.arc\n   * @param options.faceColors\n   * @param options.faceUV\n   * @param options.hasRings\n   * @param options.enclose\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the cylinder, cone or prism\n   * @deprecated please use CreateCylinderVertexData instead\n   */\n\n\n  VertexData.CreateCylinder = function (options) {\n    throw _WarnImport(\"cylinderBuilder\");\n  };\n  /**\n   * Creates the VertexData for a torus\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * diameter the diameter of the torus, optional default 1\n   * * thickness the diameter of the tube forming the torus, optional default 0.5\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.diameter\n   * @param options.thickness\n   * @param options.tessellation\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the torus\n   * @deprecated use CreateTorusVertexData instead\n   */\n\n\n  VertexData.CreateTorus = function (options) {\n    throw _WarnImport(\"torusBuilder\");\n  };\n  /**\n   * Creates the VertexData of the LineSystem\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n   *  - lines an array of lines, each line being an array of successive Vector3\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n   * @param options.lines\n   * @param options.colors\n   * @returns the VertexData of the LineSystem\n   * @deprecated use CreateLineSystemVertexData instead\n   */\n\n\n  VertexData.CreateLineSystem = function (options) {\n    throw _WarnImport(\"linesBuilder\");\n  };\n  /**\n   * Create the VertexData for a DashedLines\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n   *  - points an array successive Vector3\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n   *  - dashNb the intended total number of dashes, optional, default 200\n   * @param options.points\n   * @param options.dashSize\n   * @param options.gapSize\n   * @param options.dashNb\n   * @returns the VertexData for the DashedLines\n   * @deprecated use CreateDashedLinesVertexData instead\n   */\n\n\n  VertexData.CreateDashedLines = function (options) {\n    throw _WarnImport(\"linesBuilder\");\n  };\n  /**\n   * Creates the VertexData for a Ground\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   *  - width the width (x direction) of the ground, optional, default 1\n   *  - height the height (z direction) of the ground, optional, default 1\n   *  - subdivisions the number of subdivisions per side, optional, default 1\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.subdivisionsX\n   * @param options.subdivisionsY\n   * @returns the VertexData of the Ground\n   * @deprecated Please use CreateGroundVertexData instead\n   */\n\n\n  VertexData.CreateGround = function (options) {\n    throw _WarnImport(\"groundBuilder\");\n  };\n  /**\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   * * xmin the ground minimum X coordinate, optional, default -1\n   * * zmin the ground minimum Z coordinate, optional, default -1\n   * * xmax the ground maximum X coordinate, optional, default 1\n   * * zmax the ground maximum Z coordinate, optional, default 1\n   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n   * @param options.xmin\n   * @param options.zmin\n   * @param options.xmax\n   * @param options.zmax\n   * @param options.subdivisions\n   * @param options.subdivisions.w\n   * @param options.subdivisions.h\n   * @param options.precision\n   * @param options.precision.w\n   * @param options.precision.h\n   * @returns the VertexData of the TiledGround\n   * @deprecated use CreateTiledGroundVertexData instead\n   */\n\n\n  VertexData.CreateTiledGround = function (options) {\n    throw _WarnImport(\"groundBuilder\");\n  };\n  /**\n   * Creates the VertexData of the Ground designed from a heightmap\n   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n   * * width the width (x direction) of the ground\n   * * height the height (z direction) of the ground\n   * * subdivisions the number of subdivisions per side\n   * * minHeight the minimum altitude on the ground, optional, default 0\n   * * maxHeight the maximum altitude on the ground, optional default 1\n   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n   * * buffer the array holding the image color data\n   * * bufferWidth the width of image\n   * * bufferHeight the height of image\n   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.minHeight\n   * @param options.maxHeight\n   * @param options.colorFilter\n   * @param options.buffer\n   * @param options.bufferWidth\n   * @param options.bufferHeight\n   * @param options.alphaFilter\n   * @returns the VertexData of the Ground designed from a heightmap\n   * @deprecated use CreateGroundFromHeightMapVertexData instead\n   */\n\n\n  VertexData.CreateGroundFromHeightMap = function (options) {\n    throw _WarnImport(\"groundBuilder\");\n  };\n  /**\n   * Creates the VertexData for a Plane\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\n   * * size sets the width and height of the plane to the value of size, optional default 1\n   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreatePlaneVertexData instead\n   */\n\n\n  VertexData.CreatePlane = function (options) {\n    throw _WarnImport(\"planeBuilder\");\n  };\n  /**\n   * Creates the VertexData of the Disc or regular Polygon\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\n   * * radius the radius of the disc, optional default 0.5\n   * * tessellation the number of polygon sides, optional, default 64\n   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tessellation\n   * @param options.arc\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreateDiscVertexData instead\n   */\n\n\n  VertexData.CreateDisc = function (options) {\n    throw _WarnImport(\"discBuilder\");\n  };\n  /**\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n   * All parameters are provided by CreatePolygon as needed\n   * @param polygon a mesh built from polygonTriangulation.build()\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n   * @returns the VertexData of the Polygon\n   * @deprecated use CreatePolygonVertexData instead\n   */\n\n\n  VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _WarnImport(\"polygonBuilder\");\n  };\n  /**\n   * Creates the VertexData of the IcoSphere\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n   * * radius the radius of the IcoSphere, optional default 1\n   * * radiusX allows stretching in the x direction, optional, default radius\n   * * radiusY allows stretching in the y direction, optional, default radius\n   * * radiusZ allows stretching in the z direction, optional, default radius\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.radiusX\n   * @param options.radiusY\n   * @param options.radiusZ\n   * @param options.flat\n   * @param options.subdivisions\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the IcoSphere\n   * @deprecated use CreateIcoSphereVertexData instead\n   */\n\n\n  VertexData.CreateIcoSphere = function (options) {\n    throw _WarnImport(\"icoSphereBuilder\");\n  }; // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n\n  /**\n   * Creates the VertexData for a Polyhedron\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n   * * type provided types are:\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n   * * size the size of the IcoSphere, optional default 1\n   * * sizeX allows stretching in the x direction, optional, default size\n   * * sizeY allows stretching in the y direction, optional, default size\n   * * sizeZ allows stretching in the z direction, optional, default size\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.type\n   * @param options.size\n   * @param options.sizeX\n   * @param options.sizeY\n   * @param options.sizeZ\n   * @param options.custom\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.flat\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Polyhedron\n   * @deprecated use CreatePolyhedronVertexData instead\n   */\n\n\n  VertexData.CreatePolyhedron = function (options) {\n    throw _WarnImport(\"polyhedronBuilder\");\n  };\n  /**\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\n   * @returns the VertexData of the Capsule\n   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\n   */\n\n\n  VertexData.CreateCapsule = function (options) {\n    if (options === void 0) {\n      options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6\n      };\n    }\n\n    throw _WarnImport(\"capsuleBuilder\");\n  }; // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n\n  /**\n   * Creates the VertexData for a TorusKnot\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n   * * radius the radius of the torus knot, optional, default 2\n   * * tube the thickness of the tube, optional, default 0.5\n   * * radialSegments the number of sides on each tube segments, optional, default 32\n   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n   * * p the number of windings around the z axis, optional,  default 2\n   * * q the number of windings around the x axis, optional,  default 3\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tube\n   * @param options.radialSegments\n   * @param options.tubularSegments\n   * @param options.p\n   * @param options.q\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Torus Knot\n   * @deprecated use CreateTorusKnotVertexData instead\n   */\n\n\n  VertexData.CreateTorusKnot = function (options) {\n    throw _WarnImport(\"torusKnotBuilder\");\n  }; // Tools\n\n  /**\n   * Compute normals for given positions and indices\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\n   * * facetNormals : optional array of facet normals (vector3)\n   * * facetPositions : optional array of facet positions (vector3)\n   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n   * * bInfo : optional bounding info, required for facetPartitioning computation\n   * * bbSize : optional bounding box size data, required for facetPartitioning computation\n   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\n   * * useRightHandedSystem: optional boolean to for right handed system computation\n   * * depthSort : optional boolean to enable the facet depth sort computation\n   * * distanceTo : optional Vector3 to compute the facet depth from this location\n   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\n   * @param options.facetNormals\n   * @param options.facetPositions\n   * @param options.facetPartitioning\n   * @param options.ratio\n   * @param options.bInfo\n   * @param options.bbSize\n   * @param options.subDiv\n   * @param options.useRightHandedSystem\n   * @param options.depthSort\n   * @param options.distanceTo\n   * @param options.depthSortedFacets\n   */\n\n\n  VertexData.ComputeNormals = function (positions, indices, normals, options) {\n    // temporary scalar variables\n    var index = 0; // facet index\n\n    var p1p2x = 0.0; // p1p2 vector x coordinate\n\n    var p1p2y = 0.0; // p1p2 vector y coordinate\n\n    var p1p2z = 0.0; // p1p2 vector z coordinate\n\n    var p3p2x = 0.0; // p3p2 vector x coordinate\n\n    var p3p2y = 0.0; // p3p2 vector y coordinate\n\n    var p3p2z = 0.0; // p3p2 vector z coordinate\n\n    var faceNormalx = 0.0; // facet normal x coordinate\n\n    var faceNormaly = 0.0; // facet normal y coordinate\n\n    var faceNormalz = 0.0; // facet normal z coordinate\n\n    var length = 0.0; // facet normal length before normalization\n\n    var v1x = 0; // vector1 x index in the positions array\n\n    var v1y = 0; // vector1 y index in the positions array\n\n    var v1z = 0; // vector1 z index in the positions array\n\n    var v2x = 0; // vector2 x index in the positions array\n\n    var v2y = 0; // vector2 y index in the positions array\n\n    var v2z = 0; // vector2 z index in the positions array\n\n    var v3x = 0; // vector3 x index in the positions array\n\n    var v3y = 0; // vector3 y index in the positions array\n\n    var v3z = 0; // vector3 z index in the positions array\n\n    var computeFacetNormals = false;\n    var computeFacetPositions = false;\n    var computeFacetPartitioning = false;\n    var computeDepthSort = false;\n    var faceNormalSign = 1;\n    var ratio = 0;\n    var distanceTo = null;\n\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n      }\n    } // facetPartitioning reinit if needed\n\n\n    var xSubRatio = 0;\n    var ySubRatio = 0;\n    var zSubRatio = 0;\n    var subSq = 0;\n\n    if (computeFacetPartitioning && options && options.bbSize) {\n      //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    } // reset the normals\n\n\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    } // Loop : 1 indice triplet = 1 facet\n\n\n    var nbFaces = indices.length / 3 | 0;\n\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z]; // compute the face normal with the cross product\n\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x); // normalize this normal and store it in the array facetData\n\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        var ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        var oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        var oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        var b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        var b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        var b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        var b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        var b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        var b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        var b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        var b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        var b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        var block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        var block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        var block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        var block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array(); // push each facet index in each block containing the vertex\n\n        options.facetPartitioning[block_idx_v1].push(index);\n\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n\n      if (computeDepthSort && options && options.facetPositions) {\n        var dsf = options.depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      } // compute the normals anyway\n\n\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    } // last normalization of each normal\n\n\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  };\n  /**\n   * @param sideOrientation\n   * @param positions\n   * @param indices\n   * @param normals\n   * @param uvs\n   * @param frontUVs\n   * @param backUVs\n   * @hidden\n   */\n\n\n  VertexData._ComputeSides = function (sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    var li = indices.length;\n    var ln = normals.length;\n    var i;\n    var n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n\n      case VertexData.BACKSIDE:\n        // indices\n        for (i = 0; i < li; i += 3) {\n          var tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        } // normals\n\n\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n\n        break;\n\n      case VertexData.DOUBLESIDE:\n        {\n          // positions\n          var lp = positions.length;\n          var l = lp / 3;\n\n          for (var p = 0; p < lp; p++) {\n            positions[lp + p] = positions[p];\n          } // indices\n\n\n          for (i = 0; i < li; i += 3) {\n            indices[i + li] = indices[i + 2] + l;\n            indices[i + 1 + li] = indices[i + 1] + l;\n            indices[i + 2 + li] = indices[i] + l;\n          } // normals\n\n\n          for (n = 0; n < ln; n++) {\n            normals[ln + n] = -normals[n];\n          } // uvs\n\n\n          var lu = uvs.length;\n          var u = 0;\n\n          for (u = 0; u < lu; u++) {\n            uvs[u + lu] = uvs[u];\n          }\n\n          frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          u = 0;\n\n          for (i = 0; i < lu / 2; i++) {\n            uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n            uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n            uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n            uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n            u += 2;\n          }\n\n          break;\n        }\n    }\n  };\n  /**\n   * Applies VertexData created from the imported parameters to the geometry\n   * @param parsedVertexData the parsed data from an imported file\n   * @param geometry the geometry to apply the VertexData to\n   */\n\n\n  VertexData.ImportVertexData = function (parsedVertexData, geometry) {\n    var vertexData = new VertexData(); // positions\n\n    var positions = parsedVertexData.positions;\n\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    } // normals\n\n\n    var normals = parsedVertexData.normals;\n\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    } // tangents\n\n\n    var tangents = parsedVertexData.tangents;\n\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    } // uvs\n\n\n    var uvs = parsedVertexData.uvs;\n\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    } // uv2s\n\n\n    var uv2s = parsedVertexData.uv2s;\n\n    if (uv2s) {\n      vertexData.set(uv2s, VertexBuffer.UV2Kind);\n    } // uv3s\n\n\n    var uv3s = parsedVertexData.uv3s;\n\n    if (uv3s) {\n      vertexData.set(uv3s, VertexBuffer.UV3Kind);\n    } // uv4s\n\n\n    var uv4s = parsedVertexData.uv4s;\n\n    if (uv4s) {\n      vertexData.set(uv4s, VertexBuffer.UV4Kind);\n    } // uv5s\n\n\n    var uv5s = parsedVertexData.uv5s;\n\n    if (uv5s) {\n      vertexData.set(uv5s, VertexBuffer.UV5Kind);\n    } // uv6s\n\n\n    var uv6s = parsedVertexData.uv6s;\n\n    if (uv6s) {\n      vertexData.set(uv6s, VertexBuffer.UV6Kind);\n    } // colors\n\n\n    var colors = parsedVertexData.colors;\n\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n    } // matricesIndices\n\n\n    var matricesIndices = parsedVertexData.matricesIndices;\n\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    } // matricesWeights\n\n\n    var matricesWeights = parsedVertexData.matricesWeights;\n\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    } // indices\n\n\n    var indices = parsedVertexData.indices;\n\n    if (indices) {\n      vertexData.indices = indices;\n    }\n\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  };\n  /**\n   * Mesh side orientation : usually the external or front surface\n   */\n\n\n  VertexData.FRONTSIDE = 0;\n  /**\n   * Mesh side orientation : usually the internal or back surface\n   */\n\n  VertexData.BACKSIDE = 1;\n  /**\n   * Mesh side orientation : both internal and external or front and back surfaces\n   */\n\n  VertexData.DOUBLESIDE = 2;\n  /**\n   * Mesh side orientation : by default, `FRONTSIDE`\n   */\n\n  VertexData.DEFAULTSIDE = 0;\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var coordinates = _a[0];\n    return !Array.isArray(coordinates);\n  })], VertexData, \"_TransformVector3Coordinates\", null);\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var normals = _a[0];\n    return !Array.isArray(normals);\n  })], VertexData, \"_TransformVector3Normals\", null);\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var normals = _a[0];\n    return !Array.isArray(normals);\n  })], VertexData, \"_TransformVector4Normals\", null);\n\n  __decorate([nativeOverride.filter(function () {\n    var _a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      _a[_i] = arguments[_i];\n    }\n\n    var indices = _a[0];\n    return !Array.isArray(indices);\n  })], VertexData, \"_FlipFaces\", null);\n\n  return VertexData;\n}();\n\nexport { VertexData };","map":{"version":3,"mappings":"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","names":["Vector3","Vector4","TmpVectors","VertexBuffer","_WarnImport","Color4","Logger","nativeOverride","makeSyncFunction","runCoroutineSync","RuntimeError","ErrorCodes","_applyToCoroutine","bind","VertexData","data","kind","length","Warn","PositionKind","positions","NormalKind","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uvs2","UV3Kind","uvs3","UV4Kind","uvs4","UV5Kind","uvs5","UV6Kind","uvs6","ColorKind","colors","MatricesIndicesKind","matricesIndices","MatricesWeightsKind","matricesWeights","MatricesIndicesExtraKind","matricesIndicesExtra","MatricesWeightsExtraKind","matricesWeightsExtra","mesh","updatable","_applyTo","geometry","_update","meshOrGeometry","isAsync","setVerticesData","_a","indices","setIndices","updateExtends","makeItUnique","updateVerticesData","coordinates","transformation","offset","coordinate","transformedCoordinate","index","FromArrayToRef","TransformCoordinatesToRef","x","y","z","normal","transformedNormal","TransformNormalToRef","w","tmp","matrix","flip","determinant","_TransformVector3Coordinates","_TransformVector3Normals","_TransformVector4Normals","_FlipFaces","others","use32BitsIndices","forceCloneIndices","vertexDatas","Array","isArray","map","other","undefined","_mergeCoroutine","transform","_validate","vertexData","others_1","_i","Error","totalIndices","reduce","indexSum","_b","_c","_d","sliceIndices","some","_this","_e","slice","indicesOffset","_f","temp","Uint32Array","Uint16Array","set","positionsOffset","vertexDatas_1","transform_1","_g","_MergeElement","source","nonNullOthers","filter","len","sumLen","elements","transformRange","Float32Array","ret32","transform_2","ret","i","transform_3","MeshInvalidPositionsError","getElementCount","values","stride","DeduceStride","positionsElementCount","validateElementCount","elementCount","serializationObject","_isExpanded","copyWhenShared","forceCopy","_ExtractFrom","result","isVerticesDataPresent","getVerticesData","getIndices","options","polygon","sideOrientation","fUV","fColors","frontUVs","backUVs","wrap","orientation","Up","subdivisions","tessellation","height","radius","capSubdivisions","p1p2x","p1p2y","p1p2z","p3p2x","p3p2y","p3p2z","faceNormalx","faceNormaly","faceNormalz","v1x","v1y","v1z","v2x","v2y","v2z","v3x","v3y","v3z","computeFacetNormals","computeFacetPositions","computeFacetPartitioning","computeDepthSort","faceNormalSign","ratio","distanceTo","facetNormals","facetPositions","facetPartitioning","useRightHandedSystem","depthSort","Zero","xSubRatio","ySubRatio","zSubRatio","subSq","bbSize","subDiv","X","Y","Z","max","nbFaces","Math","sqrt","ox","floor","bInfo","minimum","oy","oz","b1x","b1y","b1z","b2x","b2y","b2z","b3x","b3y","b3z","block_idx_v1","block_idx_v2","block_idx_v3","block_idx_o","push","dsf","depthSortedFacets","ind","sqDistance","DistanceSquared","li","ln","n","DEFAULTSIDE","FRONTSIDE","BACKSIDE","DOUBLESIDE","lp","l","p","lu","u","parsedVertexData","uv2s","uv3s","uv4s","uv5s","uv6s","CheckColors4","setAllVerticesData","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/mesh.vertexData.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\ndeclare type Geometry = import(\"../Meshes/geometry\").Geometry;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\ndeclare type PolyhedronData = import(\"./geodesicMesh\").PolyhedronData;\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @param meshOrGeometry\r\n     * @param updatable\r\n     * @param isAsync\r\n     * @hidden\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false) {\r\n        const vertexDatas: [vertexData: VertexData, transform?: Matrix][] = Array.isArray(others) ? others.map((other) => [other, undefined]) : [[others, undefined]];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\r\n    }\r\n\r\n    /**\r\n     * @param transform\r\n     * @param vertexDatas\r\n     * @param use32BitsIndices\r\n     * @param isAsync\r\n     * @param forceCloneIndices\r\n     * @hidden\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: (readonly [vertexData: VertexData, transform?: Matrix])[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        const others = vertexDatas.map((vertexData) => vertexData[0]);\r\n\r\n        for (const other of others) {\r\n            other._validate();\r\n\r\n            if (\r\n                !this.normals !== !other.normals ||\r\n                !this.tangents !== !other.tangents ||\r\n                !this.uvs !== !other.uvs ||\r\n                !this.uvs2 !== !other.uvs2 ||\r\n                !this.uvs3 !== !other.uvs3 ||\r\n                !this.uvs4 !== !other.uvs4 ||\r\n                !this.uvs5 !== !other.uvs5 ||\r\n                !this.uvs6 !== !other.uvs6 ||\r\n                !this.colors !== !other.colors ||\r\n                !this.matricesIndices !== !other.matricesIndices ||\r\n                !this.matricesWeights !== !other.matricesWeights ||\r\n                !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n            ) {\r\n                throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n            }\r\n        }\r\n\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), this.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === this.indices);\r\n        let indices = sliceIndices ? this.indices?.slice() : this.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = this.positions ? this.positions.length / 3 : 0;\r\n            for (const [other, transform] of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            this.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].positions, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.normals = VertexData._MergeElement(\r\n            VertexBuffer.NormalKind,\r\n            this.normals,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].normals, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.tangents = VertexData._MergeElement(\r\n            VertexBuffer.TangentKind,\r\n            this.tangents,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].tangents, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs = VertexData._MergeElement(\r\n            VertexBuffer.UVKind,\r\n            this.uvs,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs2 = VertexData._MergeElement(\r\n            VertexBuffer.UV2Kind,\r\n            this.uvs2,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs2, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs3 = VertexData._MergeElement(\r\n            VertexBuffer.UV3Kind,\r\n            this.uvs3,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs3, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs4 = VertexData._MergeElement(\r\n            VertexBuffer.UV4Kind,\r\n            this.uvs4,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs4, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs5 = VertexData._MergeElement(\r\n            VertexBuffer.UV5Kind,\r\n            this.uvs5,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs5, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs6 = VertexData._MergeElement(\r\n            VertexBuffer.UV6Kind,\r\n            this.uvs6,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs6, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.colors = VertexData._MergeElement(\r\n            VertexBuffer.ColorKind,\r\n            this.colors,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].colors, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndices = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesKind,\r\n            this.matricesIndices,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndices, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeights = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsKind,\r\n            this.matricesWeights,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeights, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndicesExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesExtraKind,\r\n            this.matricesIndicesExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndicesExtra, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeightsExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsExtraKind,\r\n            this.matricesWeightsExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeightsExtra, other[1]])\r\n        );\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                ? VertexData._TransformVector3Normals\r\n                : kind === VertexBuffer.TangentKind\r\n                ? VertexData._TransformVector4Normals\r\n                : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = this.positions;\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = this.normals;\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = this.tangents;\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = this.uvs;\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = this.uvs2;\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = this.uvs3;\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = this.uvs4;\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = this.uvs5;\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = this.uvs6;\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = this.colors;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = this.matricesIndices;\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = this.matricesWeights;\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\r\n        }\r\n\r\n        serializationObject.indices = this.indices;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @param options.pathArray\r\n     * @param options.closeArray\r\n     * @param options.closePath\r\n     * @param options.offset\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @param options.invertUV\r\n     * @param options.uvs\r\n     * @param options.colors\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.pattern\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.segments\r\n     * @param options.diameter\r\n     * @param options.diameterX\r\n     * @param options.diameterY\r\n     * @param options.diameterZ\r\n     * @param options.arc\r\n     * @param options.slice\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.height\r\n     * @param options.diameterTop\r\n     * @param options.diameterBottom\r\n     * @param options.diameter\r\n     * @param options.tessellation\r\n     * @param options.subdivisions\r\n     * @param options.arc\r\n     * @param options.faceColors\r\n     * @param options.faceUV\r\n     * @param options.hasRings\r\n     * @param options.enclose\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.diameter\r\n     * @param options.thickness\r\n     * @param options.tessellation\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @param options.lines\r\n     * @param options.colors\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @param options.points\r\n     * @param options.dashSize\r\n     * @param options.gapSize\r\n     * @param options.dashNb\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.subdivisionsX\r\n     * @param options.subdivisionsY\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @param options.xmin\r\n     * @param options.zmin\r\n     * @param options.xmax\r\n     * @param options.zmax\r\n     * @param options.subdivisions\r\n     * @param options.subdivisions.w\r\n     * @param options.subdivisions.h\r\n     * @param options.precision\r\n     * @param options.precision.w\r\n     * @param options.precision.h\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.minHeight\r\n     * @param options.maxHeight\r\n     * @param options.colorFilter\r\n     * @param options.buffer\r\n     * @param options.bufferWidth\r\n     * @param options.bufferHeight\r\n     * @param options.alphaFilter\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tessellation\r\n     * @param options.arc\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.radiusX\r\n     * @param options.radiusY\r\n     * @param options.radiusZ\r\n     * @param options.flat\r\n     * @param options.subdivisions\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.type\r\n     * @param options.size\r\n     * @param options.sizeX\r\n     * @param options.sizeY\r\n     * @param options.sizeZ\r\n     * @param options.custom\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.flat\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tube\r\n     * @param options.radialSegments\r\n     * @param options.tubularSegments\r\n     * @param options.p\r\n     * @param options.q\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     * @param options.facetNormals\r\n     * @param options.facetPositions\r\n     * @param options.facetPartitioning\r\n     * @param options.ratio\r\n     * @param options.bInfo\r\n     * @param options.bbSize\r\n     * @param options.subDiv\r\n     * @param options.useRightHandedSystem\r\n     * @param options.depthSort\r\n     * @param options.distanceTo\r\n     * @param options.depthSortedFacets\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param sideOrientation\r\n     * @param positions\r\n     * @param indices\r\n     * @param normals\r\n     * @param uvs\r\n     * @param frontUVs\r\n     * @param backUVs\r\n     * @hidden\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uv2s = parsedVertexData.uv2s;\r\n        if (uv2s) {\r\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uv3s = parsedVertexData.uv3s;\r\n        if (uv3s) {\r\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uv4s = parsedVertexData.uv4s;\r\n        if (uv4s) {\r\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uv5s = parsedVertexData.uv5s;\r\n        if (uv5s) {\r\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uv6s = parsedVertexData.uv6s;\r\n        if (uv6s) {\r\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}