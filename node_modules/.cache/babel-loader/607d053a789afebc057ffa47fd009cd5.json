{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nvar NAME = \"MSFT_lod\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\n */\n\nvar MSFT_lod =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function MSFT_lod(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n\n    this.order = 100;\n    /**\n     * Maximum number of LODs to load, starting from the lowest LOD.\n     */\n\n    this.maxLODsToLoad = 10;\n    /**\n     * Observable raised when all node LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n\n    this.onNodeLODsLoadedObservable = new Observable();\n    /**\n     * Observable raised when all material LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n\n    this.onMaterialLODsLoadedObservable = new Observable();\n    this._bufferLODs = new Array();\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs = new Array();\n    this._nodePromiseLODs = new Array();\n    this._nodeBufferLODs = new Array();\n    this._materialIndexLOD = null;\n    this._materialSignalLODs = new Array();\n    this._materialPromiseLODs = new Array();\n    this._materialBufferLODs = new Array();\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  MSFT_lod.prototype.dispose = function () {\n    this._loader = null;\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs.length = 0;\n    this._nodePromiseLODs.length = 0;\n    this._nodeBufferLODs.length = 0;\n    this._materialIndexLOD = null;\n    this._materialSignalLODs.length = 0;\n    this._materialPromiseLODs.length = 0;\n    this._materialBufferLODs.length = 0;\n    this.onMaterialLODsLoadedObservable.clear();\n    this.onNodeLODsLoadedObservable.clear();\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype.onReady = function () {\n    var _this = this;\n\n    var _loop_1 = function _loop_1(indexLOD) {\n      var promise = Promise.all(this_1._nodePromiseLODs[indexLOD]).then(function () {\n        if (indexLOD !== 0) {\n          _this._loader.endPerformanceCounter(\"Node LOD \".concat(indexLOD));\n\n          _this._loader.log(\"Loaded node LOD \".concat(indexLOD));\n        }\n\n        _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n\n        if (indexLOD !== _this._nodePromiseLODs.length - 1) {\n          _this._loader.startPerformanceCounter(\"Node LOD \".concat(indexLOD + 1));\n\n          _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD + 1);\n\n          if (_this._nodeSignalLODs[indexLOD]) {\n            _this._nodeSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n\n      this_1._loader._completePromises.push(promise);\n    };\n\n    var this_1 = this;\n\n    for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n      _loop_1(indexLOD);\n    }\n\n    var _loop_2 = function _loop_2(indexLOD) {\n      var promise = Promise.all(this_2._materialPromiseLODs[indexLOD]).then(function () {\n        if (indexLOD !== 0) {\n          _this._loader.endPerformanceCounter(\"Material LOD \".concat(indexLOD));\n\n          _this._loader.log(\"Loaded material LOD \".concat(indexLOD));\n        }\n\n        _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n\n        if (indexLOD !== _this._materialPromiseLODs.length - 1) {\n          _this._loader.startPerformanceCounter(\"Material LOD \".concat(indexLOD + 1));\n\n          _this._loadBufferLOD(_this._materialBufferLODs, indexLOD + 1);\n\n          if (_this._materialSignalLODs[indexLOD]) {\n            _this._materialSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n\n      this_2._loader._completePromises.push(promise);\n    };\n\n    var this_2 = this;\n\n    for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n      _loop_2(indexLOD);\n    }\n  };\n  /**\n   * @param context\n   * @param scene\n   * @hidden\n   */\n\n\n  MSFT_lod.prototype.loadSceneAsync = function (context, scene) {\n    var promise = this._loader.loadSceneAsync(context, scene);\n\n    this._loadBufferLOD(this._bufferLODs, 0);\n\n    return promise;\n  };\n  /**\n   * @param context\n   * @param node\n   * @param assign\n   * @hidden\n   */\n\n\n  MSFT_lod.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      var firstPromise;\n\n      var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);\n\n      _this._loader.logOpen(\"\".concat(extensionContext));\n\n      var _loop_3 = function _loop_3(indexLOD) {\n        var nodeLOD = nodeLODs[indexLOD];\n\n        if (indexLOD !== 0) {\n          _this._nodeIndexLOD = indexLOD;\n          _this._nodeSignalLODs[indexLOD] = _this._nodeSignalLODs[indexLOD] || new Deferred();\n        }\n\n        var assignWrap = function assignWrap(babylonTransformNode) {\n          assign(babylonTransformNode);\n          babylonTransformNode.setEnabled(false);\n        };\n\n        var promise = _this._loader.loadNodeAsync(\"/nodes/\".concat(nodeLOD.index), nodeLOD, assignWrap).then(function (babylonMesh) {\n          if (indexLOD !== 0) {\n            // TODO: should not rely on _babylonTransformNode\n            var previousNodeLOD = nodeLODs[indexLOD - 1];\n\n            if (previousNodeLOD._babylonTransformNode) {\n              _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n\n              delete previousNodeLOD._babylonTransformNode;\n            }\n          }\n\n          babylonMesh.setEnabled(true);\n          return babylonMesh;\n        });\n\n        _this._nodePromiseLODs[indexLOD] = _this._nodePromiseLODs[indexLOD] || [];\n\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          _this._nodeIndexLOD = null;\n\n          _this._nodePromiseLODs[indexLOD].push(promise);\n        }\n      };\n\n      for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n        _loop_3(indexLOD);\n      }\n\n      _this._loader.logClose();\n\n      return firstPromise;\n    });\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMesh\n   * @param babylonDrawMode\n   * @param assign\n   * @hidden\n   */\n\n\n  MSFT_lod.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    var _this = this; // Don't load material LODs if already loading a node LOD.\n\n\n    if (this._nodeIndexLOD) {\n      return null;\n    }\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var firstPromise;\n\n      var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);\n\n      _this._loader.logOpen(\"\".concat(extensionContext));\n\n      var _loop_4 = function _loop_4(indexLOD) {\n        var materialLOD = materialLODs[indexLOD];\n\n        if (indexLOD !== 0) {\n          _this._materialIndexLOD = indexLOD;\n        }\n\n        var promise = _this._loader._loadMaterialAsync(\"/materials/\".concat(materialLOD.index), materialLOD, babylonMesh, babylonDrawMode, function (babylonMaterial) {\n          if (indexLOD === 0) {\n            assign(babylonMaterial);\n          }\n        }).then(function (babylonMaterial) {\n          if (indexLOD !== 0) {\n            assign(babylonMaterial); // TODO: should not rely on _data\n\n            var previousDataLOD = materialLODs[indexLOD - 1]._data;\n\n            if (previousDataLOD[babylonDrawMode]) {\n              _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n\n              delete previousDataLOD[babylonDrawMode];\n            }\n          }\n\n          return babylonMaterial;\n        });\n\n        _this._materialPromiseLODs[indexLOD] = _this._materialPromiseLODs[indexLOD] || [];\n\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          _this._materialIndexLOD = null;\n\n          _this._materialPromiseLODs[indexLOD].push(promise);\n        }\n      };\n\n      for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n        _loop_4(indexLOD);\n      }\n\n      _this._loader.logClose();\n\n      return firstPromise;\n    });\n  };\n  /**\n   * @param context\n   * @param property\n   * @param uri\n   * @hidden\n   */\n\n\n  MSFT_lod.prototype._loadUriAsync = function (context, property, uri) {\n    var _this = this; // Defer the loading of uris if loading a node or material LOD.\n\n\n    if (this._nodeIndexLOD !== null) {\n      this._loader.log(\"deferred\");\n\n      var previousIndexLOD = this._nodeIndexLOD - 1;\n      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () {\n        return _this._loader.loadUriAsync(context, property, uri);\n      });\n    } else if (this._materialIndexLOD !== null) {\n      this._loader.log(\"deferred\");\n\n      var previousIndexLOD = this._materialIndexLOD - 1;\n      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n      return this._materialSignalLODs[previousIndexLOD].promise.then(function () {\n        return _this._loader.loadUriAsync(context, property, uri);\n      });\n    }\n\n    return null;\n  };\n  /**\n   * @param context\n   * @param buffer\n   * @param byteOffset\n   * @param byteLength\n   * @hidden\n   */\n\n\n  MSFT_lod.prototype.loadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    if (this._loader.parent.useRangeRequests && !buffer.uri) {\n      if (!this._loader.bin) {\n        throw new Error(\"\".concat(context, \": Uri is missing or the binary glTF is missing its binary chunk\"));\n      }\n\n      var loadAsync = function loadAsync(bufferLODs, indexLOD) {\n        var start = byteOffset;\n        var end = start + byteLength - 1;\n        var bufferLOD = bufferLODs[indexLOD];\n\n        if (bufferLOD) {\n          bufferLOD.start = Math.min(bufferLOD.start, start);\n          bufferLOD.end = Math.max(bufferLOD.end, end);\n        } else {\n          bufferLOD = {\n            start: start,\n            end: end,\n            loaded: new Deferred()\n          };\n          bufferLODs[indexLOD] = bufferLOD;\n        }\n\n        return bufferLOD.loaded.promise.then(function (data) {\n          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n        });\n      };\n\n      this._loader.log(\"deferred\");\n\n      if (this._nodeIndexLOD !== null) {\n        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n      } else if (this._materialIndexLOD !== null) {\n        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n      } else {\n        return loadAsync(this._bufferLODs, 0);\n      }\n    }\n\n    return null;\n  };\n\n  MSFT_lod.prototype._loadBufferLOD = function (bufferLODs, indexLOD) {\n    var bufferLOD = bufferLODs[indexLOD];\n\n    if (bufferLOD) {\n      this._loader.log(\"Loading buffer range [\".concat(bufferLOD.start, \"-\").concat(bufferLOD.end, \"]\"));\n\n      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function (data) {\n        bufferLOD.loaded.resolve(data);\n      }, function (error) {\n        bufferLOD.loaded.reject(error);\n      });\n    }\n  };\n  /**\n   * Gets an array of LOD properties from lowest to highest.\n   * @param context\n   * @param property\n   * @param array\n   * @param ids\n   */\n\n\n  MSFT_lod.prototype._getLODs = function (context, property, array, ids) {\n    if (this.maxLODsToLoad <= 0) {\n      throw new Error(\"maxLODsToLoad must be greater than zero\");\n    }\n\n    var properties = new Array();\n\n    for (var i = ids.length - 1; i >= 0; i--) {\n      properties.push(ArrayItem.Get(\"\".concat(context, \"/ids/\").concat(ids[i]), array, ids[i]));\n\n      if (properties.length === this.maxLODsToLoad) {\n        return properties;\n      }\n    }\n\n    properties.push(property);\n    return properties;\n  };\n\n  MSFT_lod.prototype._disposeTransformNode = function (babylonTransformNode) {\n    var _this = this;\n\n    var babylonMaterials = new Array();\n    var babylonMaterial = babylonTransformNode.material;\n\n    if (babylonMaterial) {\n      babylonMaterials.push(babylonMaterial);\n    }\n\n    for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {\n      var babylonMesh = _a[_i];\n\n      if (babylonMesh.material) {\n        babylonMaterials.push(babylonMesh.material);\n      }\n    }\n\n    babylonTransformNode.dispose();\n    var babylonMaterialsToDispose = babylonMaterials.filter(function (babylonMaterial) {\n      return _this._loader.babylonScene.meshes.every(function (mesh) {\n        return mesh.material != babylonMaterial;\n      });\n    });\n\n    this._disposeMaterials(babylonMaterialsToDispose);\n  };\n\n  MSFT_lod.prototype._disposeMaterials = function (babylonMaterials) {\n    var babylonTextures = {};\n\n    for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {\n      var babylonMaterial = babylonMaterials_1[_i];\n\n      for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {\n        var babylonTexture = _b[_a];\n        babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n      }\n\n      babylonMaterial.dispose();\n    }\n\n    for (var uniqueId in babylonTextures) {\n      for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {\n        var babylonMaterial = _d[_c];\n\n        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n          delete babylonTextures[uniqueId];\n        }\n      }\n    }\n\n    for (var uniqueId in babylonTextures) {\n      babylonTextures[uniqueId].dispose();\n    }\n  };\n\n  return MSFT_lod;\n}();\n\nexport { MSFT_lod };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new MSFT_lod(loader);\n});","map":{"version":3,"mappings":"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","names":["Observable","Deferred","GLTFLoader","ArrayItem","NAME","loader","Array","_loader","enabled","isExtensionUsed","MSFT_lod","_nodeIndexLOD","_nodeSignalLODs","length","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","onMaterialLODsLoadedObservable","clear","onNodeLODsLoadedObservable","indexLOD","promise","Promise","all","this_1","then","_this","endPerformanceCounter","log","notifyObservers","startPerformanceCounter","_loadBufferLOD","resolve","_completePromises","push","this_2","context","scene","loadSceneAsync","_bufferLODs","node","assign","LoadExtensionAsync","name","extensionContext","extension","firstPromise","nodeLODs","_getLODs","gltf","nodes","ids","logOpen","nodeLOD","assignWrap","babylonTransformNode","setEnabled","loadNodeAsync","index","babylonMesh","previousNodeLOD","_babylonTransformNode","_disposeTransformNode","logClose","material","babylonDrawMode","materialLODs","materials","materialLOD","_loadMaterialAsync","babylonMaterial","previousDataLOD","_data","_disposeMaterials","property","uri","previousIndexLOD","loadUriAsync","buffer","byteOffset","byteLength","parent","useRangeRequests","bin","Error","loadAsync","bufferLODs","start","end","bufferLOD","Math","min","max","loaded","data","Uint8Array","concat","readAsync","error","reject","array","maxLODsToLoad","properties","i","Get","babylonMaterials","getChildMeshes","_i","dispose","babylonMaterialsToDispose","filter","babylonScene","meshes","every","mesh","babylonTextures","getActiveTextures","_a","babylonTexture","uniqueId","_c","hasTexture","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/MSFT_lod.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\r\n */\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param scene\r\n     * @hidden\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param node\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMesh\r\n     * @param babylonDrawMode\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param property\r\n     * @param uri\r\n     * @hidden\r\n     */\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param buffer\r\n     * @param byteOffset\r\n     * @param byteLength\r\n     * @hidden\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties = new Array<T>();\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials = new Array<Material>();\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));\r\n"]},"metadata":{},"sourceType":"module"}