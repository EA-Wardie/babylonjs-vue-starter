{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/**\n * This groups tools to convert HDR texture to native colors array.\n */\n\nvar HDRTools =\n/** @class */\nfunction () {\n  function HDRTools() {}\n\n  HDRTools._Ldexp = function (mantissa, exponent) {\n    if (exponent > 1023) {\n      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n\n    if (exponent < -1074) {\n      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n\n    return mantissa * Math.pow(2, exponent);\n  };\n\n  HDRTools._Rgbe2float = function (float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n      /*nonzero pixel*/\n      exponent = this._Ldexp(1.0, exponent - (128 + 8));\n      float32array[index + 0] = red * exponent;\n      float32array[index + 1] = green * exponent;\n      float32array[index + 2] = blue * exponent;\n    } else {\n      float32array[index + 0] = 0;\n      float32array[index + 1] = 0;\n      float32array[index + 2] = 0;\n    }\n  };\n\n  HDRTools._ReadStringLine = function (uint8array, startIndex) {\n    var line = \"\";\n    var character = \"\";\n\n    for (var i = startIndex; i < uint8array.length - startIndex; i++) {\n      character = String.fromCharCode(uint8array[i]);\n\n      if (character == \"\\n\") {\n        break;\n      }\n\n      line += character;\n    }\n\n    return line;\n  };\n  /**\n   * Reads header information from an RGBE texture stored in a native array.\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in  native array.\n   * @return The header information.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  HDRTools.RGBE_ReadHeader = function (uint8array) {\n    var height = 0;\n    var width = 0;\n\n    var line = this._ReadStringLine(uint8array, 0);\n\n    if (line[0] != \"#\" || line[1] != \"?\") {\n      throw \"Bad HDR Format.\";\n    }\n\n    var endOfHeader = false;\n    var findFormat = false;\n    var lineIndex = 0;\n\n    do {\n      lineIndex += line.length + 1;\n      line = this._ReadStringLine(uint8array, lineIndex);\n\n      if (line == \"FORMAT=32-bit_rle_rgbe\") {\n        findFormat = true;\n      } else if (line.length == 0) {\n        endOfHeader = true;\n      }\n    } while (!endOfHeader);\n\n    if (!findFormat) {\n      throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n\n    lineIndex += line.length + 1;\n    line = this._ReadStringLine(uint8array, lineIndex);\n    var sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n    var match = sizeRegexp.exec(line); // TODO. Support +Y and -X if needed.\n\n    if (!match || match.length < 3) {\n      throw \"HDR Bad header format, no size\";\n    }\n\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n\n    if (width < 8 || width > 0x7fff) {\n      throw \"HDR Bad header format, unsupported size\";\n    }\n\n    lineIndex += line.length + 1;\n    return {\n      height: height,\n      width: width,\n      dataPosition: lineIndex\n    };\n  };\n  /**\n   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n   * This RGBE texture needs to store the information as a panorama.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param buffer The binary file stored in an array buffer.\n   * @param size The expected size of the extracted cubemap.\n   * @return The Cube Map information.\n   */\n\n\n  HDRTools.GetCubeMapTextureData = function (buffer, size) {\n    var uint8array = new Uint8Array(buffer);\n    var hdrInfo = this.RGBE_ReadHeader(uint8array);\n    var data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n    var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n    return cubeMapData;\n  };\n  /**\n   * Returns the pixels data extracted from an RGBE texture.\n   * This pixels will be stored left to right up to down in the R G B order in one array.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in an array buffer.\n   * @param hdrInfo The header information of the file.\n   * @return The pixels data in RGB right to left up to down order.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  HDRTools.RGBE_ReadPixels = function (uint8array, hdrInfo) {\n    return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\n  };\n\n  HDRTools._RGBEReadPixelsRLE = function (uint8array, hdrInfo) {\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, count;\n    var dataIndex = hdrInfo.dataPosition;\n    var index = 0,\n        endIndex = 0,\n        i = 0;\n    var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n\n    var scanLineArray = new Uint8Array(scanLineArrayBuffer); // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      a = uint8array[dataIndex++];\n      b = uint8array[dataIndex++];\n      c = uint8array[dataIndex++];\n      d = uint8array[dataIndex++];\n\n      if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n        return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\n      }\n\n      if ((c << 8 | d) != scanline_width) {\n        throw \"HDR Bad header format, wrong scan line width\";\n      }\n\n      index = 0; // read each of the four channels for the scanline into the buffer\n\n      for (i = 0; i < 4; i++) {\n        endIndex = (i + 1) * scanline_width;\n\n        while (index < endIndex) {\n          a = uint8array[dataIndex++];\n          b = uint8array[dataIndex++];\n\n          if (a > 128) {\n            // a run of the same value\n            count = a - 128;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (run)\";\n            }\n\n            while (count-- > 0) {\n              scanLineArray[index++] = b;\n            }\n          } else {\n            // a non-run\n            count = a;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (non-run)\";\n            }\n\n            scanLineArray[index++] = b;\n\n            if (--count > 0) {\n              for (var j = 0; j < count; j++) {\n                scanLineArray[index++] = uint8array[dataIndex++];\n              }\n            }\n          }\n        }\n      } // now convert data from buffer into floats\n\n\n      for (i = 0; i < scanline_width; i++) {\n        a = scanLineArray[i];\n        b = scanLineArray[i + scanline_width];\n        c = scanLineArray[i + 2 * scanline_width];\n        d = scanLineArray[i + 3 * scanline_width];\n\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  HDRTools._RGBEReadPixelsNOTRLE = function (uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, i;\n    var dataIndex = hdrInfo.dataPosition; // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      for (i = 0; i < hdrInfo.width; i++) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  return HDRTools;\n}();\n\nexport { HDRTools };","map":{"version":3,"mappings":"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","names":["PanoramaToCubeMapTools","HDRTools","mantissa","exponent","Math","pow","float32array","red","green","blue","index","_Ldexp","uint8array","startIndex","line","character","i","length","String","fromCharCode","height","width","_ReadStringLine","endOfHeader","findFormat","lineIndex","sizeRegexp","match","exec","parseInt","dataPosition","buffer","size","Uint8Array","hdrInfo","RGBE_ReadHeader","data","RGBE_ReadPixels","cubeMapData","ConvertPanoramaToCubemap","_RGBEReadPixelsRLE","num_scanlines","scanline_width","a","b","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","ArrayBuffer","scanLineArray","resultBuffer","resultArray","Float32Array","_RGBEReadPixelsNOTRLE","j","_Rgbe2float"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Misc/HighDynamicRange/hdr.ts"],"sourcesContent":["import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n    private static _Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static _Rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n        if (exponent > 0) {\r\n            /*nonzero pixel*/\r\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        } else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static _ReadStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        let line = \"\";\r\n        let character = \"\";\r\n\r\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @return The header information.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        let height: number = 0;\r\n        let width: number = 0;\r\n\r\n        let line = this._ReadStringLine(uint8array, 0);\r\n        if (line[0] != \"#\" || line[1] != \"?\") {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        let endOfHeader = false;\r\n        let findFormat = false;\r\n        let lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += line.length + 1;\r\n            line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            } else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n        line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n        const match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @return The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo {\r\n        const uint8array = new Uint8Array(buffer);\r\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @return The pixels data in RGB right to left up to down order.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static _RGBEReadPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, count: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n        let index = 0,\r\n            endIndex = 0,\r\n            i = 0;\r\n\r\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    } else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (let j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static _RGBEReadPixelsNOTRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, i: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}