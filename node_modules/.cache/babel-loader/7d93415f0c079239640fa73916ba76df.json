{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\n/**\n * Creates lathe mesh.\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.radius\n * @param options.tessellation\n * @param options.clip\n * @param options.arc\n * @param options.closed\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.cap\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the lathe mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\n */\n\nexport function CreateLathe(name, options, scene) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc : 1.0;\n  var closed = options.closed === undefined ? true : options.closed;\n  var shape = options.shape;\n  var radius = options.radius || 1;\n  var tessellation = options.tessellation || 64;\n  var clip = options.clip || 0;\n  var updatable = options.updatable;\n\n  var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n  var cap = options.cap || Mesh.NO_CAP;\n  var pi2 = Math.PI * 2;\n  var paths = new Array();\n  var invertUV = options.invertUV || false;\n  var i = 0;\n  var p = 0;\n  var step = pi2 / tessellation * arc;\n  var rotated;\n  var path;\n\n  for (i = 0; i <= tessellation - clip; i++) {\n    path = [];\n\n    if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\n      path.push(new Vector3(0, shape[0].y, 0));\n      path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n    }\n\n    for (p = 0; p < shape.length; p++) {\n      rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n      path.push(rotated);\n    }\n\n    if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\n      path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n      path.push(new Vector3(0, shape[shape.length - 1].y, 0));\n    }\n\n    paths.push(path);\n  } // lathe ribbon\n\n\n  var lathe = CreateRibbon(name, {\n    pathArray: paths,\n    closeArray: closed,\n    sideOrientation: sideOrientation,\n    updatable: updatable,\n    invertUV: invertUV,\n    frontUVs: options.frontUVs,\n    backUVs: options.backUVs\n  }, scene);\n  return lathe;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function direction from the module\n */\n\nexport var LatheBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateLathe: CreateLathe\n};\n\nMesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\n  var options = {\n    shape: shape,\n    radius: radius,\n    tessellation: tessellation,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateLathe(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Mesh","CreateRibbon","CreateLathe","name","options","scene","arc","closed","undefined","shape","radius","tessellation","clip","updatable","sideOrientation","_GetDefaultSideOrientation","cap","NO_CAP","pi2","Math","PI","paths","Array","invertUV","i","p","step","rotated","path","CAP_START","CAP_ALL","push","y","cos","x","sin","length","CAP_END","lathe","pathArray","closeArray","frontUVs","backUVs","LatheBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/latheBuilder.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Creates lathe mesh.\r\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.clip\r\n * @param options.arc\r\n * @param options.closed\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.cap\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the lathe mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\r\n */\r\nexport function CreateLathe(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        clip?: number;\r\n        arc?: number;\r\n        closed?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        cap?: number;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const arc: number = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\r\n    const closed: boolean = options.closed === undefined ? true : options.closed;\r\n    const shape = options.shape;\r\n    const radius = options.radius || 1;\r\n    const tessellation = options.tessellation || 64;\r\n    const clip = options.clip || 0;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const cap = options.cap || Mesh.NO_CAP;\r\n    const pi2 = Math.PI * 2;\r\n    const paths = new Array();\r\n    const invertUV = options.invertUV || false;\r\n\r\n    let i = 0;\r\n    let p = 0;\r\n    const step = (pi2 / tessellation) * arc;\r\n    let rotated;\r\n    let path: Array<Vector3>;\r\n    for (i = 0; i <= tessellation - clip; i++) {\r\n        path = [];\r\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(0, shape[0].y, 0));\r\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n        }\r\n        for (p = 0; p < shape.length; p++) {\r\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n            path.push(rotated);\r\n        }\r\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n        }\r\n        paths.push(path);\r\n    }\r\n\r\n    // lathe ribbon\r\n    const lathe = CreateRibbon(\r\n        name,\r\n        { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs },\r\n        scene\r\n    );\r\n    return lathe;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function direction from the module\r\n */\r\nexport const LatheBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateLathe,\r\n};\r\n\r\n(Mesh as any).CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateLathe(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}