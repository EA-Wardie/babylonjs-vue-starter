{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\"; // Adds the parser to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, function (parsedData, scene, container, rootUrl) {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = new Array();\n    }\n\n    for (var index = 0; index < parsedData.effectLayers.length; index++) {\n      var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\n\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  var index = this.effectLayers.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\n * Defines the layer scene component responsible to manage any effect layers\n * in a given scene.\n */\n\n\nvar EffectLayerSceneComponent =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  function EffectLayerSceneComponent(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene || EngineStore.LastCreatedScene;\n\n    if (!this.scene) {\n      return;\n    }\n\n    this._engine = this.scene.getEngine();\n    this.scene.effectLayers = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  EffectLayerSceneComponent.prototype.register = function () {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  EffectLayerSceneComponent.prototype.rebuild = function () {\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var effectLayer = layers_1[_i];\n\n      effectLayer._rebuild();\n    }\n  };\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n\n\n  EffectLayerSceneComponent.prototype.serialize = function (serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\n      var effectLayer = layers_2[_i];\n\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  };\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n\n\n  EffectLayerSceneComponent.prototype.addFromContainer = function (container) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.addEffectLayer(o);\n    });\n  };\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n\n\n  EffectLayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.removeEffectLayer(o);\n\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  };\n  /**\n   * Disposes the component and the associated resources.\n   */\n\n\n  EffectLayerSceneComponent.prototype.dispose = function () {\n    var layers = this.scene.effectLayers;\n\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._isReadyForMesh = function (mesh, hardwareInstancedRendering) {\n    var currentRenderPassId = this._engine.currentRenderPassId;\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_3 = layers; _i < layers_3.length; _i++) {\n      var layer = layers_3[_i];\n\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n\n      var renderTarget = layer._mainTexture;\n      this._engine.currentRenderPassId = renderTarget.renderPassId;\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          this._engine.currentRenderPassId = currentRenderPassId;\n          return false;\n        }\n      }\n    }\n\n    this._engine.currentRenderPassId = currentRenderPassId;\n    return true;\n  };\n\n  EffectLayerSceneComponent.prototype._renderMainTexture = function (camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    var needRebind = false;\n    var layers = this.scene.effectLayers;\n\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n\n      for (var _i = 0, layers_4 = layers; _i < layers_4.length; _i++) {\n        var effectLayer = layers_4[_i];\n\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          var renderTarget = effectLayer._mainTexture;\n\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n\n      this.scene.incrementRenderId();\n    }\n\n    return needRebind;\n  };\n\n  EffectLayerSceneComponent.prototype._setStencil = function () {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._setStencilBack = function () {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._draw = function (renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n\n      var layers = this.scene.effectLayers;\n\n      for (var i = 0; i < layers.length; i++) {\n        var effectLayer = layers[i];\n\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n\n      this._engine.setDepthBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawCamera = function () {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawRenderingGroup = function (index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  };\n\n  return EffectLayerSceneComponent;\n}();\n\nexport { EffectLayerSceneComponent };\n\nEffectLayer._SceneComponentInitialization = function (scene) {\n  var component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":"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","names":["Camera","SceneComponentConstants","EffectLayer","AbstractScene","EngineStore","AddParser","NAME_EFFECTLAYER","parsedData","scene","container","rootUrl","effectLayers","Array","index","length","effectLayer","Parse","push","prototype","removeEffectLayer","toRemove","indexOf","splice","addEffectLayer","newEffectLayer","LastCreatedScene","_engine","getEngine","EffectLayerSceneComponent","_isReadyForMeshStage","registerStep","STEP_ISREADYFORMESH_EFFECTLAYER","_isReadyForMesh","_cameraDrawRenderTargetStage","STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER","_renderMainTexture","_beforeCameraDrawStage","STEP_BEFORECAMERADRAW_EFFECTLAYER","_setStencil","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW","_drawRenderingGroup","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_EFFECTLAYER","_setStencilBack","STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW","_drawCamera","layers","_i","_rebuild","serializationObject","serialize","forEach","o","_this","dispose","mesh","hardwareInstancedRendering","currentRenderPassId","layer","hasMesh","renderTarget","_mainTexture","renderPassId","subMeshes","_a","subMesh","isReady","camera","_renderEffects","_needStencil","needRebind","_previousStencilState","getStencilBuffer","shouldRender","cameraRigMode","RIG_MODE_NONE","_rigCameras","needStencil","_shouldRender","incrementRenderId","render","setStencilBuffer","renderingGroupId","setDepthBuffer","i","_draw","_isInIntermediateRendering","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Layers/effectLayerSceneComponent.ts"],"sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = new Array<EffectLayer>();\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of effect layers (highlights/glow) added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/highlight_layer\r\n         * @see https://doc.babylonjs.com/how_to/glow_layer\r\n         */\r\n        effectLayers: Array<EffectLayer>;\r\n\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeEffectLayer = function (toRemove: EffectLayer): number {\r\n    const index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.effectLayers = new Array<EffectLayer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}