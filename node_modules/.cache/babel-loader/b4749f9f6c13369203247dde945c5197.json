{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { __extends } from \"tslib\";\nimport { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\n\nvar CircleBuffer =\n/** @class */\nfunction () {\n  function CircleBuffer(numSamples, initializer) {\n    this._samples = [];\n    this._idx = 0;\n\n    for (var idx = 0; idx < numSamples; ++idx) {\n      this._samples.push(initializer ? initializer() : Vector2.Zero());\n    }\n  }\n\n  Object.defineProperty(CircleBuffer.prototype, \"length\", {\n    get: function get() {\n      return this._samples.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  CircleBuffer.prototype.push = function (x, y) {\n    this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\n    this.at(0).copyFromFloats(x, y);\n  };\n\n  CircleBuffer.prototype.at = function (idx) {\n    if (idx >= this._samples.length) {\n      throw new Error(\"Index out of bounds\");\n    }\n\n    return this._samples[(this._idx + idx) % this._samples.length];\n  };\n\n  return CircleBuffer;\n}();\n\nvar FirstStepDetector =\n/** @class */\nfunction () {\n  function FirstStepDetector() {\n    this._samples = new CircleBuffer(20);\n    this._entropy = 0;\n    this.onFirstStepDetected = new Observable();\n  }\n\n  FirstStepDetector.prototype.update = function (posX, posY, forwardX, forwardY) {\n    this._samples.push(posX, posY);\n\n    var origin = this._samples.at(0);\n\n    this._entropy *= this._entropyDecayFactor;\n    this._entropy += Vector2.Distance(origin, this._samples.at(1));\n\n    if (this._entropy > this._entropyThreshold) {\n      return;\n    }\n\n    var samePointIdx;\n\n    for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\n      if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\n        break;\n      }\n    }\n\n    if (samePointIdx === this._samples.length) {\n      return;\n    }\n\n    var apexDistSquared = -1;\n    var apexIdx = 0;\n\n    for (var distSquared = void 0, idx = 1; idx < samePointIdx; ++idx) {\n      distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\n\n      if (distSquared > apexDistSquared) {\n        apexIdx = idx;\n        apexDistSquared = distSquared;\n      }\n    }\n\n    if (apexDistSquared < this._apexSquaredDistanceThreshold) {\n      return;\n    }\n\n    var apex = this._samples.at(apexIdx);\n\n    var axis = apex.subtract(origin);\n    axis.normalize();\n    var vec = TmpVectors.Vector2[0];\n    var dot;\n    var sample;\n    var sumSquaredProjectionDistances = 0;\n\n    for (var idx = 1; idx < samePointIdx; ++idx) {\n      sample = this._samples.at(idx);\n      sample.subtractToRef(origin, vec);\n      dot = Vector2.Dot(axis, vec);\n      sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\n    }\n\n    if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\n      return;\n    }\n\n    var forwardVec = TmpVectors.Vector3[0];\n    forwardVec.set(forwardX, forwardY, 0);\n    var axisVec = TmpVectors.Vector3[1];\n    axisVec.set(axis.x, axis.y, 0);\n    var isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\n    var leftApex = origin.clone();\n    var rightApex = origin.clone();\n    apex.subtractToRef(origin, axis);\n\n    if (isApexLeft) {\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\n    } else {\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\n    }\n\n    this.onFirstStepDetected.notifyObservers({\n      leftApex: leftApex,\n      rightApex: rightApex,\n      currentPosition: origin,\n      currentStepDirection: isApexLeft ? \"right\" : \"left\"\n    });\n  };\n\n  FirstStepDetector.prototype.reset = function () {\n    for (var idx = 0; idx < this._samples.length; ++idx) {\n      this._samples.at(idx).copyFromFloats(0, 0);\n    }\n  };\n\n  Object.defineProperty(FirstStepDetector.prototype, \"_samePointCheckStartIdx\", {\n    get: function get() {\n      return Math.floor(this._samples.length / 3);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_samePointSquaredDistanceThreshold\", {\n    get: function get() {\n      return 0.03 * 0.03;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_apexSquaredDistanceThreshold\", {\n    get: function get() {\n      return 0.09 * 0.09;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_squaredProjectionDistanceThreshold\", {\n    get: function get() {\n      return 0.03 * 0.03;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_axisToApexShrinkFactor\", {\n    get: function get() {\n      return 0.8;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_axisToApexExtendFactor\", {\n    get: function get() {\n      return -1.6;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_entropyDecayFactor\", {\n    get: function get() {\n      return 0.93;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FirstStepDetector.prototype, \"_entropyThreshold\", {\n    get: function get() {\n      return 0.4;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return FirstStepDetector;\n}();\n\nvar WalkingTracker =\n/** @class */\nfunction () {\n  function WalkingTracker(leftApex, rightApex, currentPosition, currentStepDirection) {\n    this._leftApex = new Vector2();\n    this._rightApex = new Vector2();\n    this._currentPosition = new Vector2();\n    this._axis = new Vector2();\n    this._axisLength = -1;\n    this._forward = new Vector2();\n    this._steppingLeft = false;\n    this._t = -1;\n    this._maxT = -1;\n    this._maxTPosition = new Vector2();\n    this._vitality = 0;\n    this.onMovement = new Observable();\n    this.onFootfall = new Observable();\n\n    this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\n  }\n\n  WalkingTracker.prototype._reset = function (leftApex, rightApex, currentPosition, steppingLeft) {\n    this._leftApex.copyFrom(leftApex);\n\n    this._rightApex.copyFrom(rightApex);\n\n    this._steppingLeft = steppingLeft;\n\n    if (this._steppingLeft) {\n      this._leftApex.subtractToRef(this._rightApex, this._axis);\n\n      this._forward.copyFromFloats(-this._axis.y, this._axis.x);\n    } else {\n      this._rightApex.subtractToRef(this._leftApex, this._axis);\n\n      this._forward.copyFromFloats(this._axis.y, -this._axis.x);\n    }\n\n    this._axisLength = this._axis.length();\n\n    this._forward.scaleInPlace(1 / this._axisLength);\n\n    this._updateTAndVitality(currentPosition.x, currentPosition.y);\n\n    this._maxT = this._t;\n\n    this._maxTPosition.copyFrom(currentPosition);\n\n    this._vitality = 1;\n  };\n\n  WalkingTracker.prototype._updateTAndVitality = function (x, y) {\n    this._currentPosition.copyFromFloats(x, y);\n\n    if (this._steppingLeft) {\n      this._currentPosition.subtractInPlace(this._rightApex);\n    } else {\n      this._currentPosition.subtractInPlace(this._leftApex);\n    }\n\n    var priorT = this._t;\n    var dot = Vector2.Dot(this._currentPosition, this._axis);\n    this._t = dot / (this._axisLength * this._axisLength);\n\n    var projDistSquared = this._currentPosition.lengthSquared() - dot / this._axisLength * (dot / this._axisLength); // TODO: Extricate the magic.\n\n\n    this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\n  };\n\n  WalkingTracker.prototype.update = function (x, y) {\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n\n    var priorT = this._t;\n\n    this._updateTAndVitality(x, y);\n\n    if (this._t > this._maxT) {\n      this._maxT = this._t;\n\n      this._maxTPosition.copyFromFloats(x, y);\n    }\n\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n\n    if (this._t > priorT) {\n      this.onMovement.notifyObservers({\n        deltaT: this._t - priorT\n      });\n\n      if (priorT < 0.5 && this._t >= 0.5) {\n        this.onFootfall.notifyObservers({\n          foot: this._steppingLeft ? \"left\" : \"right\"\n        });\n      }\n    }\n\n    if (this._t < 0.95 * this._maxT) {\n      this._currentPosition.copyFromFloats(x, y);\n\n      if (this._steppingLeft) {\n        this._leftApex.copyFrom(this._maxTPosition);\n      } else {\n        this._rightApex.copyFrom(this._maxTPosition);\n      }\n\n      this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\n    }\n\n    if (this._axisLength < 0.03) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Object.defineProperty(WalkingTracker.prototype, \"_vitalityThreshold\", {\n    get: function get() {\n      return 0.1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WalkingTracker.prototype, \"forward\", {\n    get: function get() {\n      return this._forward;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return WalkingTracker;\n}();\n\nvar Walker =\n/** @class */\nfunction () {\n  function Walker(engine) {\n    var _this = this;\n\n    this._detector = new FirstStepDetector();\n    this._walker = null;\n    this._movement = new Vector2();\n    this._millisecondsSinceLastUpdate = Walker._MillisecondsPerUpdate;\n    this.movementThisFrame = Vector3.Zero();\n    this._engine = engine;\n\n    this._detector.onFirstStepDetected.add(function (event) {\n      if (!_this._walker) {\n        _this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\n\n        _this._walker.onFootfall.add(function () {\n          console.log(\"Footfall!\");\n        });\n\n        _this._walker.onMovement.add(function (event) {\n          _this._walker.forward.scaleAndAddToRef(0.024 * event.deltaT, _this._movement);\n        });\n      }\n    });\n  }\n\n  Object.defineProperty(Walker, \"_MillisecondsPerUpdate\", {\n    get: function get() {\n      // 15 FPS\n      return 1000 / 15;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Walker.prototype.update = function (position, forward) {\n    forward.y = 0;\n    forward.normalize(); // Enforce reduced framerate\n\n    this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\n\n    if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\n      this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\n\n      this._detector.update(position.x, position.z, forward.x, forward.z);\n\n      if (this._walker) {\n        var updated = this._walker.update(position.x, position.z);\n\n        if (!updated) {\n          this._walker = null;\n        }\n      }\n\n      this._movement.scaleInPlace(0.85);\n    }\n\n    this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\n  };\n\n  return Walker;\n}();\n/**\n * A module that will enable VR locomotion by detecting when the user walks in place.\n */\n\n\nvar WebXRWalkingLocomotion =\n/** @class */\nfunction (_super) {\n  __extends(WebXRWalkingLocomotion, _super);\n  /**\n   * Construct a new Walking Locomotion feature.\n   * @param sessionManager manager for the current XR session\n   * @param options creation options, prominently including the vector target for locomotion\n   */\n\n\n  function WebXRWalkingLocomotion(sessionManager, options) {\n    var _this = _super.call(this, sessionManager) || this;\n\n    _this._up = new Vector3();\n    _this._forward = new Vector3();\n    _this._position = new Vector3();\n    _this._movement = new Vector3();\n    _this._sessionManager = sessionManager;\n    _this.locomotionTarget = options.locomotionTarget;\n\n    if (_this._isLocomotionTargetWebXRCamera) {\n      Logger.Warn(\"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\");\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRWalkingLocomotion, \"Name\", {\n    /**\n     * The module's name.\n     */\n    get: function get() {\n      return WebXRFeatureName.WALKING_LOCOMOTION;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRWalkingLocomotion, \"Version\", {\n    /**\n     * The (Babylon) version of this module.\n     * This is an integer representing the implementation version.\n     * This number has no external basis.\n     */\n    get: function get() {\n      return 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRWalkingLocomotion.prototype, \"locomotionTarget\", {\n    /**\n     * The target to be articulated by walking locomotion.\n     * When the walking locomotion feature detects walking in place, this element's\n     * X and Z coordinates will be modified to reflect locomotion. This target should\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n     * of the WebXRCamera directly and is thus discouraged.\n     */\n    get: function get() {\n      return this._locomotionTarget;\n    },\n\n    /**\n     * The target to be articulated by walking locomotion.\n     * When the walking locomotion feature detects walking in place, this element's\n     * X and Z coordinates will be modified to reflect locomotion. This target should\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n     * of the WebXRCamera directly and is thus discouraged.\n     */\n    set: function set(locomotionTarget) {\n      this._locomotionTarget = locomotionTarget;\n      this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Checks whether this feature is compatible with the current WebXR session.\n   * Walking locomotion is only compatible with \"immersive-vr\" sessions.\n   * @returns true if compatible, false otherwise\n   */\n\n  WebXRWalkingLocomotion.prototype.isCompatible = function () {\n    return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\n  };\n  /**\n   * Attaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if attach succeeded, false otherwise\n   */\n\n\n  WebXRWalkingLocomotion.prototype.attach = function () {\n    if (!this.isCompatible || !_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._walker = new Walker(this._sessionManager.scene.getEngine());\n    return true;\n  };\n  /**\n   * Detaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if detach succeeded, false otherwise\n   */\n\n\n  WebXRWalkingLocomotion.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    this._walker = null;\n    return true;\n  };\n\n  WebXRWalkingLocomotion.prototype._onXRFrame = function (frame) {\n    var pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\n\n    if (!pose) {\n      return;\n    }\n\n    var handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\n    var m = pose.transform.matrix;\n\n    this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\n\n    this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\n\n    this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]); // Compute the nape position\n\n\n    this._forward.scaleAndAddToRef(0.05, this._position);\n\n    this._up.scaleAndAddToRef(-0.05, this._position);\n\n    this._walker.update(this._position, this._forward);\n\n    this._movement.copyFrom(this._walker.movementThisFrame);\n\n    if (!this._isLocomotionTargetWebXRCamera) {\n      Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\n    }\n\n    this.locomotionTarget.position.addInPlace(this._movement);\n  };\n\n  return WebXRWalkingLocomotion;\n}(WebXRAbstractFeature);\n\nexport { WebXRWalkingLocomotion }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRWalkingLocomotion.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRWalkingLocomotion(xrSessionManager, options);\n  };\n}, WebXRWalkingLocomotion.Version, false);","map":{"version":3,"mappings":"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","names":["TmpVectors","Vector2","Vector3","Logger","Observable","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","numSamples","initializer","idx","_samples","push","Zero","Object","CircleBuffer","length","x","y","_idx","at","copyFromFloats","Error","FirstStepDetector","posX","posY","forwardX","forwardY","origin","_entropy","_entropyDecayFactor","Distance","_entropyThreshold","samePointIdx","_samePointCheckStartIdx","DistanceSquared","_samePointSquaredDistanceThreshold","apexDistSquared","apexIdx","distSquared","_apexSquaredDistanceThreshold","apex","axis","subtract","normalize","vec","dot","sample","sumSquaredProjectionDistances","subtractToRef","Dot","lengthSquared","_squaredProjectionDistanceThreshold","forwardVec","set","axisVec","isApexLeft","Cross","z","leftApex","clone","rightApex","scaleAndAddToRef","_axisToApexShrinkFactor","_axisToApexExtendFactor","onFirstStepDetected","notifyObservers","currentPosition","currentStepDirection","Math","floor","_reset","WalkingTracker","steppingLeft","_leftApex","copyFrom","_rightApex","_steppingLeft","_axis","_forward","_axisLength","scaleInPlace","_updateTAndVitality","_maxT","_t","_maxTPosition","_vitality","_currentPosition","subtractInPlace","priorT","projDistSquared","max","_vitalityThreshold","onMovement","deltaT","onFootfall","foot","engine","Walker","_MillisecondsPerUpdate","_engine","_detector","add","event","_this","_walker","console","log","forward","_movement","position","_millisecondsSinceLastUpdate","getDeltaTime","update","updated","movementThisFrame","__extends","sessionManager","options","_super","_sessionManager","locomotionTarget","_isLocomotionTargetWebXRCamera","Warn","WebXRWalkingLocomotion","WALKING_LOCOMOTION","_locomotionTarget","getClassName","sessionMode","undefined","isCompatible","attach","call","scene","getEngine","detach","frame","pose","getViewerPose","baseReferenceSpace","handednessScalar","getScene","useRightHandedSystem","m","transform","matrix","_up","_position","TransformNormalToRef","getWorldMatrix","addInPlace","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRWalkingLocomotion.ts"],"sourcesContent":["import type { Engine } from \"../../Engines/engine\";\r\nimport { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\nclass CircleBuffer {\r\n    private _samples: Array<Vector2> = [];\r\n    private _idx: number = 0;\r\n\r\n    constructor(numSamples: number, initializer?: () => Vector2) {\r\n        for (let idx = 0; idx < numSamples; ++idx) {\r\n            this._samples.push(initializer ? initializer() : Vector2.Zero());\r\n        }\r\n    }\r\n\r\n    public get length() {\r\n        return this._samples.length;\r\n    }\r\n\r\n    public push(x: number, y: number) {\r\n        this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\r\n        this.at(0).copyFromFloats(x, y);\r\n    }\r\n\r\n    public at(idx: number) {\r\n        if (idx >= this._samples.length) {\r\n            throw new Error(\"Index out of bounds\");\r\n        }\r\n        return this._samples[(this._idx + idx) % this._samples.length];\r\n    }\r\n}\r\n\r\ninterface IDetectedStep {\r\n    leftApex: Vector2;\r\n    rightApex: Vector2;\r\n    currentPosition: Vector2;\r\n    currentStepDirection: \"left\" | \"right\";\r\n}\r\n\r\nclass FirstStepDetector {\r\n    private _samples = new CircleBuffer(20);\r\n    private _entropy = 0;\r\n\r\n    public onFirstStepDetected: Observable<IDetectedStep> = new Observable<IDetectedStep>();\r\n\r\n    public update(posX: number, posY: number, forwardX: number, forwardY: number) {\r\n        this._samples.push(posX, posY);\r\n        const origin = this._samples.at(0);\r\n\r\n        this._entropy *= this._entropyDecayFactor;\r\n        this._entropy += Vector2.Distance(origin, this._samples.at(1));\r\n        if (this._entropy > this._entropyThreshold) {\r\n            return;\r\n        }\r\n\r\n        let samePointIdx;\r\n        for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\r\n            if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (samePointIdx === this._samples.length) {\r\n            return;\r\n        }\r\n\r\n        let apexDistSquared = -1;\r\n        let apexIdx = 0;\r\n        for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\r\n            distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\r\n            if (distSquared > apexDistSquared) {\r\n                apexIdx = idx;\r\n                apexDistSquared = distSquared;\r\n            }\r\n        }\r\n\r\n        if (apexDistSquared < this._apexSquaredDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const apex = this._samples.at(apexIdx);\r\n        const axis = apex.subtract(origin);\r\n        axis.normalize();\r\n\r\n        const vec = TmpVectors.Vector2[0];\r\n        let dot;\r\n        let sample;\r\n        let sumSquaredProjectionDistances = 0;\r\n        for (let idx = 1; idx < samePointIdx; ++idx) {\r\n            sample = this._samples.at(idx);\r\n            sample.subtractToRef(origin, vec);\r\n            dot = Vector2.Dot(axis, vec);\r\n            sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\r\n        }\r\n\r\n        if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const forwardVec = TmpVectors.Vector3[0];\r\n        forwardVec.set(forwardX, forwardY, 0);\r\n        const axisVec = TmpVectors.Vector3[1];\r\n        axisVec.set(axis.x, axis.y, 0);\r\n        const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\r\n        const leftApex = origin.clone();\r\n        const rightApex = origin.clone();\r\n        apex.subtractToRef(origin, axis);\r\n        if (isApexLeft) {\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\r\n        } else {\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\r\n        }\r\n        this.onFirstStepDetected.notifyObservers({\r\n            leftApex: leftApex,\r\n            rightApex: rightApex,\r\n            currentPosition: origin,\r\n            currentStepDirection: isApexLeft ? \"right\" : \"left\",\r\n        });\r\n    }\r\n\r\n    public reset() {\r\n        for (let idx = 0; idx < this._samples.length; ++idx) {\r\n            this._samples.at(idx).copyFromFloats(0, 0);\r\n        }\r\n    }\r\n\r\n    private get _samePointCheckStartIdx() {\r\n        return Math.floor(this._samples.length / 3);\r\n    }\r\n\r\n    private get _samePointSquaredDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _apexSquaredDistanceThreshold() {\r\n        return 0.09 * 0.09;\r\n    }\r\n\r\n    private get _squaredProjectionDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _axisToApexShrinkFactor() {\r\n        return 0.8;\r\n    }\r\n\r\n    private get _axisToApexExtendFactor() {\r\n        return -1.6;\r\n    }\r\n\r\n    private get _entropyDecayFactor() {\r\n        return 0.93;\r\n    }\r\n\r\n    private get _entropyThreshold() {\r\n        return 0.4;\r\n    }\r\n}\r\n\r\nclass WalkingTracker {\r\n    private _leftApex = new Vector2();\r\n    private _rightApex = new Vector2();\r\n    private _currentPosition = new Vector2();\r\n    private _axis = new Vector2();\r\n    private _axisLength = -1;\r\n    private _forward = new Vector2();\r\n    private _steppingLeft = false;\r\n    private _t = -1;\r\n    private _maxT = -1;\r\n    private _maxTPosition = new Vector2();\r\n    private _vitality = 0;\r\n\r\n    public onMovement = new Observable<{ deltaT: number }>();\r\n    public onFootfall = new Observable<{ foot: \"left\" | \"right\" }>();\r\n\r\n    constructor(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, currentStepDirection: \"left\" | \"right\") {\r\n        this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\r\n    }\r\n\r\n    private _reset(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, steppingLeft: boolean) {\r\n        this._leftApex.copyFrom(leftApex);\r\n        this._rightApex.copyFrom(rightApex);\r\n        this._steppingLeft = steppingLeft;\r\n\r\n        if (this._steppingLeft) {\r\n            this._leftApex.subtractToRef(this._rightApex, this._axis);\r\n            this._forward.copyFromFloats(-this._axis.y, this._axis.x);\r\n        } else {\r\n            this._rightApex.subtractToRef(this._leftApex, this._axis);\r\n            this._forward.copyFromFloats(this._axis.y, -this._axis.x);\r\n        }\r\n        this._axisLength = this._axis.length();\r\n        this._forward.scaleInPlace(1 / this._axisLength);\r\n\r\n        this._updateTAndVitality(currentPosition.x, currentPosition.y);\r\n        this._maxT = this._t;\r\n        this._maxTPosition.copyFrom(currentPosition);\r\n\r\n        this._vitality = 1;\r\n    }\r\n\r\n    private _updateTAndVitality(x: number, y: number) {\r\n        this._currentPosition.copyFromFloats(x, y);\r\n\r\n        if (this._steppingLeft) {\r\n            this._currentPosition.subtractInPlace(this._rightApex);\r\n        } else {\r\n            this._currentPosition.subtractInPlace(this._leftApex);\r\n        }\r\n        const priorT = this._t;\r\n        const dot = Vector2.Dot(this._currentPosition, this._axis);\r\n        this._t = dot / (this._axisLength * this._axisLength);\r\n        const projDistSquared = this._currentPosition.lengthSquared() - (dot / this._axisLength) * (dot / this._axisLength);\r\n\r\n        // TODO: Extricate the magic.\r\n        this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\r\n    }\r\n\r\n    public update(x: number, y: number) {\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        const priorT = this._t;\r\n        this._updateTAndVitality(x, y);\r\n\r\n        if (this._t > this._maxT) {\r\n            this._maxT = this._t;\r\n            this._maxTPosition.copyFromFloats(x, y);\r\n        }\r\n\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        if (this._t > priorT) {\r\n            this.onMovement.notifyObservers({ deltaT: this._t - priorT });\r\n\r\n            if (priorT < 0.5 && this._t >= 0.5) {\r\n                this.onFootfall.notifyObservers({ foot: this._steppingLeft ? \"left\" : \"right\" });\r\n            }\r\n        }\r\n\r\n        if (this._t < 0.95 * this._maxT) {\r\n            this._currentPosition.copyFromFloats(x, y);\r\n            if (this._steppingLeft) {\r\n                this._leftApex.copyFrom(this._maxTPosition);\r\n            } else {\r\n                this._rightApex.copyFrom(this._maxTPosition);\r\n            }\r\n            this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\r\n        }\r\n\r\n        if (this._axisLength < 0.03) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private get _vitalityThreshold() {\r\n        return 0.1;\r\n    }\r\n\r\n    get forward() {\r\n        return this._forward;\r\n    }\r\n}\r\n\r\nclass Walker {\r\n    private _engine: Engine;\r\n    private _detector = new FirstStepDetector();\r\n    private _walker: Nullable<WalkingTracker> = null;\r\n    private _movement = new Vector2();\r\n    private _millisecondsSinceLastUpdate: number = Walker._MillisecondsPerUpdate;\r\n\r\n    private static get _MillisecondsPerUpdate(): number {\r\n        // 15 FPS\r\n        return 1000 / 15;\r\n    }\r\n\r\n    public movementThisFrame: Vector3 = Vector3.Zero();\r\n\r\n    constructor(engine: Engine) {\r\n        this._engine = engine;\r\n        this._detector.onFirstStepDetected.add((event) => {\r\n            if (!this._walker) {\r\n                this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\r\n                this._walker.onFootfall.add(() => {\r\n                    console.log(\"Footfall!\");\r\n                });\r\n                this._walker.onMovement.add((event) => {\r\n                    this._walker!.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    public update(position: Vector3, forward: Vector3) {\r\n        forward.y = 0;\r\n        forward.normalize();\r\n\r\n        // Enforce reduced framerate\r\n        this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\r\n        if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\r\n            this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\r\n            this._detector.update(position.x, position.z, forward.x, forward.z);\r\n            if (this._walker) {\r\n                const updated = this._walker.update(position.x, position.z);\r\n                if (!updated) {\r\n                    this._walker = null;\r\n                }\r\n            }\r\n            this._movement.scaleInPlace(0.85);\r\n        }\r\n\r\n        this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the walking locomotion feature.\r\n */\r\nexport interface IWebXRWalkingLocomotionOptions {\r\n    /**\r\n     * The target to be moved by walking locomotion. This should be the transform node\r\n     * which is the root of the XR space (i.e., the WebXRCamera's parent node). However,\r\n     * for simple cases and legacy purposes, articulating the WebXRCamera itself is also\r\n     * supported as a deprecated feature.\r\n     */\r\n    locomotionTarget: WebXRCamera | TransformNode;\r\n}\r\n\r\n/**\r\n * A module that will enable VR locomotion by detecting when the user walks in place.\r\n */\r\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name.\r\n     */\r\n    public static get Name(): string {\r\n        return WebXRFeatureName.WALKING_LOCOMOTION;\r\n    }\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number has no external basis.\r\n     */\r\n    public static get Version(): number {\r\n        return 1;\r\n    }\r\n\r\n    private _sessionManager: WebXRSessionManager;\r\n    private _up: Vector3 = new Vector3();\r\n    private _forward: Vector3 = new Vector3();\r\n    private _position: Vector3 = new Vector3();\r\n    private _movement: Vector3 = new Vector3();\r\n    private _walker: Nullable<Walker>;\r\n\r\n    private _locomotionTarget: WebXRCamera | TransformNode;\r\n    private _isLocomotionTargetWebXRCamera: boolean;\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public get locomotionTarget(): WebXRCamera | TransformNode {\r\n        return this._locomotionTarget;\r\n    }\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public set locomotionTarget(locomotionTarget: WebXRCamera | TransformNode) {\r\n        this._locomotionTarget = locomotionTarget;\r\n        this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Construct a new Walking Locomotion feature.\r\n     * @param sessionManager manager for the current XR session\r\n     * @param options creation options, prominently including the vector target for locomotion\r\n     */\r\n    public constructor(sessionManager: WebXRSessionManager, options: IWebXRWalkingLocomotionOptions) {\r\n        super(sessionManager);\r\n        this._sessionManager = sessionManager;\r\n        this.locomotionTarget = options.locomotionTarget;\r\n        if (this._isLocomotionTargetWebXRCamera) {\r\n            Logger.Warn(\r\n                \"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether this feature is compatible with the current WebXR session.\r\n     * Walking locomotion is only compatible with \"immersive-vr\" sessions.\r\n     * @returns true if compatible, false otherwise\r\n     */\r\n    public isCompatible(): boolean {\r\n        return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\r\n    }\r\n\r\n    /**\r\n     * Attaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if attach succeeded, false otherwise\r\n     */\r\n    public attach(): boolean {\r\n        if (!this.isCompatible || !super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = new Walker(this._sessionManager.scene.getEngine());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if detach succeeded, false otherwise\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = null;\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame): void {\r\n        const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\r\n\r\n        const m = pose.transform.matrix;\r\n        this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\r\n        this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\r\n        this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\r\n\r\n        // Compute the nape position\r\n        this._forward.scaleAndAddToRef(0.05, this._position);\r\n        this._up.scaleAndAddToRef(-0.05, this._position);\r\n        this._walker!.update(this._position, this._forward);\r\n        this._movement.copyFrom(this._walker!.movementThisFrame);\r\n        if (!this._isLocomotionTargetWebXRCamera) {\r\n            Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\r\n        }\r\n        this.locomotionTarget.position.addInPlace(this._movement);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRWalkingLocomotion.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRWalkingLocomotion(xrSessionManager, options);\r\n    },\r\n    WebXRWalkingLocomotion.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}