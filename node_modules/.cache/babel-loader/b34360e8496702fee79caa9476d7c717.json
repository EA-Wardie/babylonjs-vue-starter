{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\n\nThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (!texture) {\n    return;\n  } // Babylon's internalSizedFomat but gl's texImage2D internalFormat\n\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format); // Babylon's internalFormat but gl's texImage2D format\n\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var textureType = this._getWebGLTextureType(type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n    texture.format = format;\n    texture.type = type;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (texture.width % 4 !== 0) {\n    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n  }\n\n  if (compression && data) {\n    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);\n  } else {\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\n  }\n\n  if (texture.generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null); //  this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, // eslint-disable-next-line @typescript-eslint/no-unused-vars\ncreationFlags) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (creationFlags === void 0) {\n    creationFlags = 0;\n  }\n\n  var texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this.updateRawTexture(texture, data, format, invertY, compression, type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true); // Filters\n\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n  if (generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  var gl = this._gl;\n  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  texture.isCube = true;\n  texture.format = format;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n  } // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\n\n\n  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n\n  var width = size;\n  var height = width;\n  texture.width = width;\n  texture.height = height; // Double check on POT to generate Mips.\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (!isPot) {\n    generateMipMaps = false;\n  } // Upload data if needed. The texture won't be ready until then.\n\n\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true); // Filters\n\n\n  if (data && generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  return texture;\n};\n\nThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression, level) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  texture._bufferViewArray = data;\n  texture.format = format;\n  texture.type = type;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  var gl = this._gl;\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n\n  var needConversion = false;\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n    needConversion = true;\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (texture.width % 4 !== 0) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  } // Data are known to be in +X +Y +Z -X -Y -Z\n\n\n  for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n    var faceData = data[faceIndex];\n\n    if (compression) {\n      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);\n    } else {\n      if (needConversion) {\n        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\n      }\n\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\n    }\n  }\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (isPot && texture.generateMipMaps && level === 0) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null); // this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (samplingMode === void 0) {\n    samplingMode = 3;\n  }\n\n  if (invertY === void 0) {\n    invertY = false;\n  }\n\n  var gl = this._gl;\n  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);\n  texture.url = url;\n\n  this._internalTexturesCache.push(texture);\n\n  var onerror = function onerror(request, exception) {\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  var internalCallback = function internalCallback(data) {\n    var width = texture.width;\n    var faceDataArrays = callback(data);\n\n    if (!faceDataArrays) {\n      return;\n    }\n\n    if (mipmapGenerator) {\n      var textureType = _this._getWebGLTextureType(type);\n\n      var internalFormat = _this._getInternalFormat(format);\n\n      var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);\n\n      var needConversion = false;\n\n      if (internalFormat === gl.RGB) {\n        internalFormat = gl.RGBA;\n        needConversion = true;\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      _this._unpackFlipY(false);\n\n      var mipData = mipmapGenerator(faceDataArrays);\n\n      for (var level = 0; level < mipData.length; level++) {\n        var mipSize = width >> level;\n\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n          var mipFaceData = mipData[level][faceIndex];\n\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n\n          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n        }\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n    }\n\n    texture.isReady = true; // this.resetTextureCache();\n\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onLoad) {\n      onLoad();\n    }\n  };\n\n  this._loadFile(url, function (data) {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n\n  return texture;\n};\n/**\n * @param rgbData\n * @param width\n * @param height\n * @param textureType\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  var rgbaData;\n  var val1 = 1;\n\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  } // Convert each pixel.\n\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var index = (y * width + x) * 3;\n      var newIndex = (y * width + x) * 4; // Map Old Value to new value.\n\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2]; // Add fully opaque alpha channel.\n\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n\n  return rgbaData;\n}\n/**\n * Create a function for createRawTexture3D/createRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nfunction _makeCreateRawTextureFunction(is3D) {\n  return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\n    var texture = new InternalTexture(this, source);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n\n    if (is3D) {\n      texture.is3D = true;\n    } else {\n      texture.is2DArray = true;\n    }\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n\n    if (is3D) {\n      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n    } else {\n      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n    }\n\n    this._bindTextureDirectly(target, texture, true); // Filters\n\n\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n    if (generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null);\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n}\n\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\n/**\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nfunction _makeUpdateRawTextureFunction(is3D) {\n  return function (texture, data, format, invertY, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n\n    var internalType = this._getWebGLTextureType(textureType);\n\n    var internalFormat = this._getInternalFormat(format);\n\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\n\n    this._bindTextureDirectly(target, texture, true);\n\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n    }\n\n    if (texture.width % 4 !== 0) {\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n    }\n\n    if (compression && data) {\n      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);\n    } else {\n      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\n    }\n\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null); // this.resetTextureCache();\n\n\n    texture.isReady = true;\n  };\n}\n\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","Logger","Tools","ThinEngine","prototype","updateRawTexture","texture","data","format","invertY","compression","type","internalSizedFomat","_getRGBABufferInternalSizedFormat","internalFormat","_getInternalFormat","textureType","_getWebGLTextureType","_bindTextureDirectly","_gl","TEXTURE_2D","_unpackFlipY","undefined","_doNotHandleContextLost","_bufferView","_compression","width","pixelStorei","UNPACK_ALIGNMENT","compressedTexImage2D","getCaps","s3tc","height","texImage2D","generateMipMaps","generateMipmap","isReady","createRawTexture","samplingMode","creationFlags","Raw","baseWidth","baseHeight","filters","_getSamplingParameters","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","_internalTexturesCache","push","createRawCubeTexture","size","gl","CubeRaw","isCube","_bufferViewArray","RGB","RGBA","FLOAT","_caps","textureFloatLinearFiltering","Warn","HALF_FLOAT_OES","textureHalfFloatLinearFiltering","textureFloatRender","HALF_FLOAT","colorBufferFloat","isPot","needPOTTextures","IsExponentOfTwo","updateRawCubeTexture","TEXTURE_CUBE_MAP","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","level","needConversion","faceIndex","faceData","TEXTURE_CUBE_MAP_POSITIVE_X","_convertRGBtoRGBATextureData","createRawCubeTextureFromUrl","url","scene","noMipmap","callback","mipmapGenerator","onLoad","onError","_addPendingData","onerror","request","exception","_removePendingData","status","statusText","internalCallback","faceDataArrays","_this","mipData","length","mipSize","mipFaceData","_loadFile","offlineProvider","rgbData","rgbaData","val1","Float32Array","Uint16Array","Uint32Array","Uint8Array","x","y","index","newIndex","_makeCreateRawTextureFunction","is3D","depth","target","TEXTURE_3D","TEXTURE_2D_ARRAY","source","Raw3D","Raw2DArray","baseDepth","is2DArray","updateRawTexture3D","updateRawTexture2DArray","createRawTexture2DArray","createRawTexture3D","_makeUpdateRawTextureFunction","internalType","compressedTexImage3D","texImage3D"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/Extensions/engine.rawTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, type: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?._addPendingData(texture);\r\n    texture.url = url;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?._removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?._removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @param rgbData\r\n * @param width\r\n * @param height\r\n * @param textureType\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n"]},"metadata":{},"sourceType":"module"}