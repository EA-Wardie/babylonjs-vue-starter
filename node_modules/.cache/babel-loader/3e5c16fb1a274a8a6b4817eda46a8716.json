{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { Light } from \"@babylonjs/core/Lights/light.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nvar NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual)\n */\n\nvar KHR_lights =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_lights(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  KHR_lights.prototype.dispose = function () {\n    this._loader = null;\n    delete this._lights;\n  };\n  /** @hidden */\n\n\n  KHR_lights.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._lights = extension.lights;\n    }\n  };\n  /**\n   * @param context\n   * @param node\n   * @param assign\n   * @hidden\n   */\n\n\n  KHR_lights.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      return _this._loader.loadNodeAsync(context, node, function (babylonMesh) {\n        var babylonLight;\n        var light = ArrayItem.Get(extensionContext, _this._lights, extension.light);\n        var name = light.name || babylonMesh.name;\n        _this._loader.babylonScene._blockEntityCollection = !!_this._loader._assetContainer;\n\n        switch (light.type) {\n          case \"directional\"\n          /* DIRECTIONAL */\n          :\n            {\n              babylonLight = new DirectionalLight(name, Vector3.Backward(), _this._loader.babylonScene);\n              break;\n            }\n\n          case \"point\"\n          /* POINT */\n          :\n            {\n              babylonLight = new PointLight(name, Vector3.Zero(), _this._loader.babylonScene);\n              break;\n            }\n\n          case \"spot\"\n          /* SPOT */\n          :\n            {\n              var babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, _this._loader.babylonScene);\n              babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;\n              babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;\n              babylonLight = babylonSpotLight;\n              break;\n            }\n\n          default:\n            {\n              _this._loader.babylonScene._blockEntityCollection = false;\n              throw new Error(\"\".concat(extensionContext, \": Invalid light type (\").concat(light.type, \")\"));\n            }\n        }\n\n        babylonLight._parentContainer = _this._loader._assetContainer;\n        _this._loader.babylonScene._blockEntityCollection = false;\n        babylonLight.falloffType = Light.FALLOFF_GLTF;\n        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n        babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n        babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n        babylonLight.parent = babylonMesh;\n\n        _this._loader._babylonLights.push(babylonLight);\n\n        GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n        assign(babylonMesh);\n      });\n    });\n  };\n\n  return KHR_lights;\n}();\n\nexport { KHR_lights };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_lights(loader);\n});","map":{"version":3,"mappings":"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","names":["Vector3","Color3","DirectionalLight","PointLight","SpotLight","Light","GLTFLoader","ArrayItem","NAME","loader","_loader","enabled","isExtensionUsed","KHR_lights","_lights","extensions","gltf","name","extension","lights","context","node","assign","LoadExtensionAsync","extensionContext","_this","loadNodeAsync","babylonMesh","babylonLight","light","Get","babylonScene","_blockEntityCollection","_assetContainer","type","Backward","Zero","babylonSpotLight","angle","spot","outerConeAngle","Math","PI","innerAngle","innerConeAngle","Error","concat","_parentContainer","falloffType","FALLOFF_GLTF","diffuse","color","FromArray","White","intensity","undefined","range","Number","MAX_VALUE","parent","_babylonLights","push","AddPointerMetadata","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { IKHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual)\r\n */\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @hidden */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRLightsPunctual;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param node\r\n     * @param assign\r\n     * @hidden\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case IKHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case IKHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case IKHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_lights(loader));\r\n"]},"metadata":{},"sourceType":"module"}