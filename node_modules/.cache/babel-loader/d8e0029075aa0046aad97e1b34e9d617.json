{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { AnimationKeyInterpolation } from \"./animationKey.js\";\nimport { AnimationRange } from \"./animationRange.js\";\nimport { Node } from \"../node.js\";\nimport { Size } from \"../Maths/math.size.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n/**\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar _IAnimationState =\n/** @class */\nfunction () {\n  function _IAnimationState() {}\n\n  return _IAnimationState;\n}();\n\nexport { _IAnimationState };\n/**\n * Class used to store any kind of animation\n */\n\nvar Animation =\n/** @class */\nfunction () {\n  /**\n   * Initializes the animation\n   * @param name Name of the animation\n   * @param targetProperty Property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param dataType The data type of the animation\n   * @param loopMode The loop mode of the animation\n   * @param enableBlending Specifies if blending should be enabled\n   */\n  function Animation(\n  /**Name of the animation */\n  name,\n  /**Property to animate */\n  targetProperty,\n  /**The frames per second of the animation */\n  framePerSecond,\n  /**The data type of the animation */\n  dataType,\n  /**The loop mode of the animation */\n  loopMode,\n  /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\n     * Stores the easing function of the animation\n     */\n\n    this._easingFunction = null;\n    /**\n     * @hidden Internal use only\n     */\n\n    this._runtimeAnimations = new Array();\n    /**\n     * The set of event that will be linked to this animation\n     */\n\n    this._events = new Array();\n    /**\n     * Stores the blending speed of the animation\n     */\n\n    this.blendingSpeed = 0.01;\n    /**\n     * Stores the animation ranges for the animation\n     */\n\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n    this.uniqueId = Animation._UniqueIdGenerator++;\n  }\n  /**\n   * @param name\n   * @param targetProperty\n   * @param framePerSecond\n   * @param totalFrame\n   * @param from\n   * @param to\n   * @param loopMode\n   * @param easingFunction\n   * @hidden Internal use\n   */\n\n\n  Animation._PrepareAnimation = function (name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    var dataType = undefined;\n\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n\n    if (dataType == undefined) {\n      return null;\n    }\n\n    var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    var keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n\n    return animation;\n  };\n  /**\n   * Sets up an animation\n   * @param property The property to animate\n   * @param animationType The animation type to apply\n   * @param framePerSecond The frames per second of the animation\n   * @param easingFunction The easing function used in the animation\n   * @returns The created animation\n   */\n\n\n  Animation.CreateAnimation = function (property, animationType, framePerSecond, easingFunction) {\n    var animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  };\n  /**\n   * Create and start an animation on a node\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param target defines the target where the animation will take place\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second yo use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when animation end\n   * @param scene defines the hosting scene\n   * @returns the animatable created for this animation\n   */\n\n\n  Animation.CreateAndStartAnimation = function (name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    if (target.getScene) {\n      scene = target.getScene();\n    }\n\n    if (!scene) {\n      return null;\n    }\n\n    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\n   * Create and start an animation on a node and its descendants\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param node defines the root node where the animation will take place\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second to use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\n   * @returns the list of animatables created for all nodes\n   * @example https://www.babylonjs-playground.com/#MH0VLI\n   */\n\n\n  Animation.CreateAndStartHierarchyAnimation = function (name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    var scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\n   * Creates a new animation, merges it with the existing animations and starts it\n   * @param name Name of the animation\n   * @param node Node which contains the scene that begins the animations\n   * @param targetProperty Specifies which property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param totalFrame The total number of frames\n   * @param from The frame at the beginning of the animation\n   * @param to The frame at the end of the animation\n   * @param loopMode Specifies the loop mode of the animation\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\n   * @param onAnimationEnd Callback to run once the animation is complete\n   * @returns Nullable animation\n   */\n\n\n  Animation.CreateMergeAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\n   * @param sourceAnimation defines the Animation containing keyframes to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Animation to convert\n   * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\n   * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\n   * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\n   */\n\n\n  Animation.MakeAnimationAdditive = function (sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animation = sourceAnimation;\n\n    if (cloneOriginal) {\n      animation = sourceAnimation.clone();\n      animation.name = clonedName || animation.name;\n    }\n\n    if (!animation._keys.length) {\n      return animation;\n    }\n\n    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\n    var startIndex = 0;\n    var firstKey = animation._keys[0];\n    var endIndex = animation._keys.length - 1;\n    var lastKey = animation._keys[endIndex];\n    var valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    var referenceFound = false;\n    var from = firstKey.frame;\n    var to = lastKey.frame;\n\n    if (range) {\n      var rangeValue = animation.getRange(range);\n\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    }\n\n    var fromKeyFound = firstKey.frame === from;\n    var toKeyFound = lastKey.frame === to; // There's only one key, so use it\n\n    if (animation._keys.length === 1) {\n      var value = animation._getKeyValue(animation._keys[0]);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n      var value = animation._getKeyValue(firstKey.value);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Reference frame is after the last frame, so just use the last frame\n    else if (referenceFrame >= lastKey.frame) {\n      var value = animation._getKeyValue(lastKey.value);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Find key bookends, create them if they don't exist\n\n\n    var index = 0;\n\n    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\n      var currentKey = animation._keys[index];\n      var nextKey = animation._keys[index + 1]; // If reference frame wasn't found yet, check if we can interpolate to it\n\n      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\n        var value = void 0;\n\n        if (referenceFrame === currentKey.frame) {\n          value = animation._getKeyValue(currentKey.value);\n        } else if (referenceFrame === nextKey.frame) {\n          value = animation._getKeyValue(nextKey.value);\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          value = animation._interpolate(referenceFrame, animationState);\n        }\n\n        valueStore.referenceValue = value.clone ? value.clone() : value;\n        referenceFound = true;\n      } // If from key wasn't found yet, check if we can interpolate to it\n\n\n      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\n        if (from === currentKey.frame) {\n          startIndex = index;\n        } else if (from === nextKey.frame) {\n          startIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(from, animationState);\n\n          var key = {\n            frame: from,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          startIndex = index + 1;\n        }\n\n        fromKeyFound = true;\n      } // If to key wasn't found yet, check if we can interpolate to it\n\n\n      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\n        if (to === currentKey.frame) {\n          endIndex = index;\n        } else if (to === nextKey.frame) {\n          endIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(to, animationState);\n\n          var key = {\n            frame: to,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          endIndex = index + 1;\n        }\n\n        toKeyFound = true;\n      }\n\n      index++;\n    } // Conjugate the quaternion\n\n\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    } // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n      valueStore.referenceQuaternion.normalize().conjugateInPlace();\n    } // Subtract the reference value from all of the key values\n\n\n    for (index = startIndex; index <= endIndex; index++) {\n      var key = animation._keys[index]; // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n\n    return animation;\n  };\n  /**\n   * Transition property of an host to the target Value\n   * @param property The property to transition\n   * @param targetValue The target Value of the property\n   * @param host The object where the property to animate belongs\n   * @param scene Scene used to run the animation\n   * @param frameRate Framerate (in frame/s) to use\n   * @param transition The transition type we want to use\n   * @param duration The duration of the animation, in milliseconds\n   * @param onAnimationEnd Callback trigger at the end of the animation\n   * @returns Nullable animation\n   */\n\n\n  Animation.TransitionTo = function (property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    if (duration <= 0) {\n      host[property] = targetValue;\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      return null;\n    }\n\n    var endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n\n    if (!host.animations) {\n      host.animations = [];\n    }\n\n    host.animations.push(transition);\n    var animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  };\n\n  Object.defineProperty(Animation.prototype, \"runtimeAnimations\", {\n    /**\n     * Return the array of runtime animations currently using this animation\n     */\n    get: function get() {\n      return this._runtimeAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animation.prototype, \"hasRunningRuntimeAnimations\", {\n    /**\n     * Specifies if any of the runtime animations are currently running\n     */\n    get: function get() {\n      for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {\n        var runtimeAnimation = _a[_i];\n\n        if (!runtimeAnimation.isStopped()) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\n   * Converts the animation to a string\n   * @param fullDetails support for multiple levels of logging within scene loading\n   * @returns String form of the animation\n   */\n\n  Animation.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name_1 in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name_1;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\n   * Add an event to this animation\n   * @param event Event to add\n   */\n\n\n  Animation.prototype.addEvent = function (event) {\n    this._events.push(event);\n\n    this._events.sort(function (a, b) {\n      return a.frame - b.frame;\n    });\n  };\n  /**\n   * Remove all events found at the given frame\n   * @param frame The frame to remove events from\n   */\n\n\n  Animation.prototype.removeEvents = function (frame) {\n    for (var index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n\n        index--;\n      }\n    }\n  };\n  /**\n   * Retrieves all the events from the animation\n   * @returns Events from the animation\n   */\n\n\n  Animation.prototype.getEvents = function () {\n    return this._events;\n  };\n  /**\n   * Creates an animation range\n   * @param name Name of the animation range\n   * @param from Starting frame of the animation range\n   * @param to Ending frame of the animation\n   */\n\n\n  Animation.prototype.createRange = function (name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  };\n  /**\n   * Deletes an animation range by name\n   * @param name Name of the animation range to delete\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\n   */\n\n\n  Animation.prototype.deleteRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    var range = this._ranges[name];\n\n    if (!range) {\n      return;\n    }\n\n    if (deleteFrames) {\n      var from = range.from;\n      var to = range.to; // this loop MUST go high to low for multiple splices to work\n\n      for (var key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\n   * Gets the animation range by name, or null if not defined\n   * @param name Name of the animation range\n   * @returns Nullable animation range\n   */\n\n\n  Animation.prototype.getRange = function (name) {\n    return this._ranges[name];\n  };\n  /**\n   * Gets the key frames from the animation\n   * @returns The key frames of the animation\n   */\n\n\n  Animation.prototype.getKeys = function () {\n    return this._keys;\n  };\n  /**\n   * Gets the highest frame rate of the animation\n   * @returns Highest frame rate of the animation\n   */\n\n\n  Animation.prototype.getHighestFrame = function () {\n    var ret = 0;\n\n    for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n\n    return ret;\n  };\n  /**\n   * Gets the easing function of the animation\n   * @returns Easing function of the animation\n   */\n\n\n  Animation.prototype.getEasingFunction = function () {\n    return this._easingFunction;\n  };\n  /**\n   * Sets the easing function of the animation\n   * @param easingFunction A custom mathematical formula for animation\n   */\n\n\n  Animation.prototype.setEasingFunction = function (easingFunction) {\n    this._easingFunction = easingFunction;\n  };\n  /**\n   * Interpolates a scalar linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n\n\n  Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a scalar cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n\n\n  Animation.prototype.floatInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\n   * Interpolates a quaternion using a spherical linear interpolation\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a quaternion cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation curve\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  };\n  /**\n   * Interpolates a Vector3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated scalar value\n   */\n\n\n  Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a Vector3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns InterpolatedVector3 value\n   */\n\n\n  Animation.prototype.vector3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\n   * Interpolates a Vector2 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n\n\n  Animation.prototype.vector2InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a Vector2 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n\n\n  Animation.prototype.vector2InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\n   * Interpolates a size linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Size value\n   */\n\n\n  Animation.prototype.sizeInterpolateFunction = function (startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a Color3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n\n\n  Animation.prototype.color3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a Color3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n\n\n  Animation.prototype.color3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\n   * Interpolates a Color4 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n\n\n  Animation.prototype.color4InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Interpolates a Color4 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n\n\n  Animation.prototype.color4InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\n   * @param value\n   * @hidden Internal use only\n   */\n\n\n  Animation.prototype._getKeyValue = function (value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n\n    return value;\n  };\n  /**\n   * Evaluate the animation value at a given frame\n   * @param currentFrame defines the frame where we want to evaluate the animation\n   * @returns the animation value\n   */\n\n\n  Animation.prototype.evaluate = function (currentFrame) {\n    return this._interpolate(currentFrame, {\n      key: 0,\n      repeatCount: 0,\n      loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT\n    });\n  };\n  /**\n   * @param currentFrame\n   * @param state\n   * @hidden Internal use only\n   */\n\n\n  Animation.prototype._interpolate = function (currentFrame, state) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n\n    var keys = this._keys;\n\n    if (keys.length === 1) {\n      return this._getKeyValue(keys[0].value);\n    }\n\n    var startKeyIndex = state.key;\n\n    if (keys[startKeyIndex].frame >= currentFrame) {\n      while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\n        startKeyIndex--;\n      }\n    }\n\n    for (var key = startKeyIndex; key < keys.length - 1; key++) {\n      var endKey = keys[key + 1];\n\n      if (endKey.frame >= currentFrame) {\n        state.key = key;\n        var startKey = keys[key];\n\n        var startValue = this._getKeyValue(startKey.value);\n\n        var endValue = this._getKeyValue(endKey.value);\n\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n          if (endKey.frame > currentFrame) {\n            return startValue;\n          } else {\n            return endValue;\n          }\n        }\n\n        var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n        var frameDelta = endKey.frame - startKey.frame; // gradient : percent of currentFrame between the frame inf and the frame sup\n\n        var gradient = (currentFrame - startKey.frame) / frameDelta; // check for easingFunction and correction of gradient\n\n        var easingFunction = this.getEasingFunction();\n\n        if (easingFunction !== null) {\n          gradient = easingFunction.ease(gradient);\n        }\n\n        switch (this.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            {\n              var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return floatValue;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return state.offsetValue * state.repeatCount + floatValue;\n              }\n\n              break;\n            }\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            {\n              var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return quatValue;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\n              }\n\n              return quatValue;\n            }\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            {\n              var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return vec3Value;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return vec3Value.add(state.offsetValue.scale(state.repeatCount));\n              }\n\n              break;\n            }\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            {\n              var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return vec2Value;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return vec2Value.add(state.offsetValue.scale(state.repeatCount));\n              }\n\n              break;\n            }\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            {\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return this.sizeInterpolateFunction(startValue, endValue, gradient);\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n              }\n\n              break;\n            }\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            {\n              var color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return color3Value;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return color3Value.add(state.offsetValue.scale(state.repeatCount));\n              }\n\n              break;\n            }\n          // Color4\n\n          case Animation.ANIMATIONTYPE_COLOR4:\n            {\n              var color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);\n\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  return color4Value;\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  return color4Value.add(state.offsetValue.scale(state.repeatCount));\n              }\n\n              break;\n            }\n          // Matrix\n\n          case Animation.ANIMATIONTYPE_MATRIX:\n            {\n              switch (state.loopMode) {\n                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                  {\n                    if (Animation.AllowMatricesInterpolation) {\n                      return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                    }\n\n                    return startValue;\n                  }\n\n                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                  {\n                    return startValue;\n                  }\n              }\n\n              break;\n            }\n\n          default:\n            break;\n        }\n\n        break;\n      }\n    }\n\n    return this._getKeyValue(keys[keys.length - 1].value);\n  };\n  /**\n   * Defines the function to use to interpolate matrices\n   * @param startValue defines the start matrix\n   * @param endValue defines the end matrix\n   * @param gradient defines the gradient between both matrices\n   * @param result defines an optional target matrix where to store the interpolation\n   * @returns the interpolated matrix\n   */\n\n\n  Animation.prototype.matrixInterpolateFunction = function (startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n\n    return Matrix.Lerp(startValue, endValue, gradient);\n  };\n  /**\n   * Makes a copy of the animation\n   * @returns Cloned animation\n   */\n\n\n  Animation.prototype.clone = function () {\n    var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n\n    if (this._ranges) {\n      clone._ranges = {};\n\n      for (var name_2 in this._ranges) {\n        var range = this._ranges[name_2];\n\n        if (!range) {\n          continue;\n        }\n\n        clone._ranges[name_2] = range.clone();\n      }\n    }\n\n    return clone;\n  };\n  /**\n   * Sets the key frames of the animation\n   * @param values The animation key frames to set\n   */\n\n\n  Animation.prototype.setKeys = function (values) {\n    this._keys = values.slice(0);\n  };\n  /**\n   * Serializes the animation to an object\n   * @returns Serialized object\n   */\n\n\n  Animation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    var dataType = this.dataType;\n    serializationObject.keys = [];\n    var keys = this.getKeys();\n\n    for (var index = 0; index < keys.length; index++) {\n      var animationKey = keys[index];\n      var key = {};\n      key.frame = animationKey.frame;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent);\n          }\n\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.interpolation);\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent.asArray());\n          }\n\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.interpolation);\n          }\n\n          break;\n      }\n\n      serializationObject.keys.push(key);\n    }\n\n    serializationObject.ranges = [];\n\n    for (var name_3 in this._ranges) {\n      var source = this._ranges[name_3];\n\n      if (!source) {\n        continue;\n      }\n\n      var range = {};\n      range.name = name_3;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n\n    return serializationObject;\n  };\n  /**\n   * @param left\n   * @param right\n   * @param amount\n   * @hidden\n   */\n\n\n  Animation._UniversalLerp = function (left, right, amount) {\n    var constructor = left.constructor;\n\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  };\n  /**\n   * Parses an animation object and creates an animation\n   * @param parsedAnimation Parsed animation object\n   * @returns Animation object\n   */\n\n\n  Animation.Parse = function (parsedAnimation) {\n    var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    var dataType = parsedAnimation.dataType;\n    var keys = [];\n    var data;\n    var index;\n\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      var key = parsedAnimation.keys[index];\n      var inTangent = undefined;\n      var outTangent = undefined;\n      var interpolation = undefined;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n\n          if (key.values.length >= 2) {\n            inTangent = key.values[1];\n          }\n\n          if (key.values.length >= 3) {\n            outTangent = key.values[2];\n          }\n\n          if (key.values.length >= 4) {\n            interpolation = key.values[3];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n\n          if (key.values.length >= 8) {\n            var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n\n          if (key.values.length >= 12) {\n            var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n\n          if (key.values.length >= 13) {\n            interpolation = key.values[12];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n\n          if (key.values.length >= 17) {\n            interpolation = key.values[16];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n\n          if (key.values[3]) {\n            inTangent = Color3.FromArray(key.values[3]);\n          }\n\n          if (key.values[4]) {\n            outTangent = Color3.FromArray(key.values[4]);\n          }\n\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n\n          if (key.values[4]) {\n            inTangent = Color4.FromArray(key.values[4]);\n          }\n\n          if (key.values[5]) {\n            outTangent = Color4.FromArray(key.values[5]);\n          }\n\n          if (key.values[6]) {\n            interpolation = Color4.FromArray(key.values[6]);\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n\n          if (key.values[3]) {\n            inTangent = Vector3.FromArray(key.values[3]);\n          }\n\n          if (key.values[4]) {\n            outTangent = Vector3.FromArray(key.values[4]);\n          }\n\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n\n          break;\n      }\n\n      var keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n\n      if (interpolation != undefined) {\n        keyData.interpolation = interpolation;\n      }\n\n      keys.push(keyData);\n    }\n\n    animation.setKeys(keys);\n\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n\n    return animation;\n  };\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n\n\n  Animation.AppendSerializedAnimations = function (source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  };\n  /**\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @returns a promise that will resolve to the new animation or an array of animations\n   */\n\n\n  Animation.ParseFromFileAsync = function (name, url) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n\n            if (serializationObject.animations) {\n              serializationObject = serializationObject.animations;\n            }\n\n            if (serializationObject.length) {\n              var output = new Array();\n\n              for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {\n                var serializedAnimation = serializationObject_1[_i];\n                output.push(_this.Parse(serializedAnimation));\n              }\n\n              resolve(output);\n            } else {\n              var output = _this.Parse(serializationObject);\n\n              if (name) {\n                output.name = name;\n              }\n\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @returns a promise that will resolve to the new animation or a new array of animations\n   */\n\n\n  Animation.CreateFromSnippetAsync = function (snippetId) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n\n            if (snippet.animations) {\n              var serializationObject = JSON.parse(snippet.animations);\n              var outputs = new Array();\n\n              for (var _i = 0, _a = serializationObject.animations; _i < _a.length; _i++) {\n                var serializedAnimation = _a[_i];\n\n                var output = _this.Parse(serializedAnimation);\n\n                output.snippetId = snippetId;\n                outputs.push(output);\n              }\n\n              resolve(outputs);\n            } else {\n              var serializationObject = JSON.parse(snippet.animation);\n\n              var output = _this.Parse(serializationObject);\n\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n\n  Animation._UniqueIdGenerator = 0;\n  /**\n   * Use matrix interpolation instead of using direct key value when animating matrices\n   */\n\n  Animation.AllowMatricesInterpolation = false;\n  /**\n   * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\n   */\n\n  Animation.AllowMatrixDecomposeForInterpolation = true;\n  /** Define the Url to load snippets */\n\n  Animation.SnippetUrl = \"https://snippet.babylonjs.com\"; // Statics\n\n  /**\n   * Float animation type\n   */\n\n  Animation.ANIMATIONTYPE_FLOAT = 0;\n  /**\n   * Vector3 animation type\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR3 = 1;\n  /**\n   * Quaternion animation type\n   */\n\n  Animation.ANIMATIONTYPE_QUATERNION = 2;\n  /**\n   * Matrix animation type\n   */\n\n  Animation.ANIMATIONTYPE_MATRIX = 3;\n  /**\n   * Color3 animation type\n   */\n\n  Animation.ANIMATIONTYPE_COLOR3 = 4;\n  /**\n   * Color3 animation type\n   */\n\n  Animation.ANIMATIONTYPE_COLOR4 = 7;\n  /**\n   * Vector2 animation type\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR2 = 5;\n  /**\n   * Size animation type\n   */\n\n  Animation.ANIMATIONTYPE_SIZE = 6;\n  /**\n   * Relative Loop Mode\n   */\n\n  Animation.ANIMATIONLOOPMODE_RELATIVE = 0;\n  /**\n   * Cycle Loop Mode\n   */\n\n  Animation.ANIMATIONLOOPMODE_CYCLE = 1;\n  /**\n   * Constant Loop Mode\n   */\n\n  Animation.ANIMATIONLOOPMODE_CONSTANT = 2;\n  return Animation;\n}();\n\nexport { Animation };\nRegisterClass(\"BABYLON.Animation\", Animation);\n\nNode._AnimationRangeFactory = function (name, from, to) {\n  return new AnimationRange(name, from, to);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Vector2","Matrix","TmpVectors","Color3","Color4","Scalar","SerializationHelper","RegisterClass","AnimationKeyInterpolation","AnimationRange","Node","Size","WebRequest","name","targetProperty","framePerSecond","dataType","loopMode","enableBlending","Array","targetPropertyPath","split","undefined","Animation","ANIMATIONLOOPMODE_CYCLE","uniqueId","_UniqueIdGenerator","totalFrame","from","to","easingFunction","isNaN","parseFloat","isFinite","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_COLOR4","ANIMATIONTYPE_SIZE","animation","keys","frame","value","setKeys","setEasingFunction","property","animationType","ANIMATIONLOOPMODE_CONSTANT","target","onAnimationEnd","scene","_PrepareAnimation","getScene","beginDirectAnimation","node","directDescendantsOnly","beginDirectHierarchyAnimation","animations","push","beginAnimation","sourceAnimation","referenceFrame","range","cloneOriginal","clonedName","clone","_keys","length","startIndex","firstKey","endIndex","lastKey","valueStore","referenceValue","referencePosition","referenceQuaternion","referenceScaling","keyPosition","keyQuaternion","keyScaling","referenceFound","rangeValue","getRange","fromKeyFound","toKeyFound","_getKeyValue","index","currentKey","nextKey","animationState","key","repeatCount","_interpolate","splice","normalize","conjugateInPlace","ANIMATIONTYPE_MATRIX","decompose","subtractInPlace","divideInPlace","multiplyToRef","ComposeToRef","subtractToRef","width","height","targetValue","host","frameRate","transition","duration","endFrame","Object","_runtimeAnimations","_i","runtimeAnimation","isStopped","fullDetails","ret","_ranges","first","name_1","event","_events","sort","a","b","deleteFrames","nKeys","_easingFunction","startValue","endValue","gradient","Lerp","outTangent","inTangent","Hermite","Slerp","currentFrame","state","highLimitValue","startKeyIndex","endKey","startKey","interpolation","STEP","useTangent","frameDelta","getEasingFunction","ease","floatValue","floatInterpolateFunctionWithTangents","floatInterpolateFunction","ANIMATIONLOOPMODE_RELATIVE","offsetValue","quatValue","quaternionInterpolateFunctionWithTangents","scale","quaternionInterpolateFunction","addInPlace","vec3Value","vector3InterpolateFunctionWithTangents","vector3InterpolateFunction","add","vec2Value","vector2InterpolateFunctionWithTangents","vector2InterpolateFunction","sizeInterpolateFunction","color3Value","color3InterpolateFunctionWithTangents","color3InterpolateFunction","color4Value","color4InterpolateFunctionWithTangents","color4InterpolateFunction","AllowMatricesInterpolation","matrixInterpolateFunction","workValue","result","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","join","blendingSpeed","name_2","values","slice","serializationObject","loopBehavior","getKeys","animationKey","asArray","ranges","name_3","source","left","right","amount","constructor","toFixed","parsedAnimation","data","FromArray","_inTangent","equals","Zero","_outTangent","keyData","createRange","destination","AppendSerializedAnimations","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","parse","responseText","output","serializedAnimation","_this","Parse","open","send","snippetId","snippet","jsonPayload","outputs","SnippetUrl","replace","_AnimationRangeFactory"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Animations/animation.ts"],"sourcesContent":["import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\ndeclare type RuntimeAnimation = import(\"./runtimeAnimation\").RuntimeAnimation;\r\n\r\n/**\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @param name\r\n     * @param targetProperty\r\n     * @param framePerSecond\r\n     * @param totalFrame\r\n     * @param from\r\n     * @param to\r\n     * @param loopMode\r\n     * @param easingFunction\r\n     * @hidden Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): Animation {\r\n        let animation = sourceAnimation;\r\n\r\n        if (cloneOriginal) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = clonedName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let referenceFound = false;\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (range) {\r\n            const rangeValue = animation.getRange(range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        }\r\n        let fromKeyFound = firstKey.frame === from;\r\n        let toKeyFound = lastKey.frame === to;\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Find key bookends, create them if they don't exist\r\n        let index = 0;\r\n        while (!referenceFound || !fromKeyFound || (!toKeyFound && index < animation._keys.length - 1)) {\r\n            const currentKey = animation._keys[index];\r\n            const nextKey = animation._keys[index + 1];\r\n\r\n            // If reference frame wasn't found yet, check if we can interpolate to it\r\n            if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\r\n                let value;\r\n\r\n                if (referenceFrame === currentKey.frame) {\r\n                    value = animation._getKeyValue(currentKey.value);\r\n                } else if (referenceFrame === nextKey.frame) {\r\n                    value = animation._getKeyValue(nextKey.value);\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    value = animation._interpolate(referenceFrame, animationState);\r\n                }\r\n\r\n                valueStore.referenceValue = value.clone ? value.clone() : value;\r\n                referenceFound = true;\r\n            }\r\n\r\n            // If from key wasn't found yet, check if we can interpolate to it\r\n            if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\r\n                if (from === currentKey.frame) {\r\n                    startIndex = index;\r\n                } else if (from === nextKey.frame) {\r\n                    startIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(from, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: from,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    startIndex = index + 1;\r\n                }\r\n\r\n                fromKeyFound = true;\r\n            }\r\n\r\n            // If to key wasn't found yet, check if we can interpolate to it\r\n            if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\r\n                if (to === currentKey.frame) {\r\n                    endIndex = index;\r\n                } else if (to === nextKey.frame) {\r\n                    endIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(to, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: to,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    endIndex = index + 1;\r\n                }\r\n\r\n                toKeyFound = true;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (index = startIndex; index <= endIndex; index++) {\r\n            const key = animation._keys[index];\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @param value\r\n     * @hidden Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        return this._interpolate(currentFrame, {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param currentFrame\r\n     * @param state\r\n     * @hidden Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        if (keys.length === 1) {\r\n            return this._getKeyValue(keys[0].value);\r\n        }\r\n\r\n        let startKeyIndex = state.key;\r\n\r\n        if (keys[startKeyIndex].frame >= currentFrame) {\r\n            while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\r\n                startKeyIndex--;\r\n            }\r\n        }\r\n\r\n        for (let key = startKeyIndex; key < keys.length - 1; key++) {\r\n            const endKey = keys[key + 1];\r\n\r\n            if (endKey.frame >= currentFrame) {\r\n                state.key = key;\r\n                const startKey = keys[key];\r\n                const startValue = this._getKeyValue(startKey.value);\r\n                const endValue = this._getKeyValue(endKey.value);\r\n                if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n                    if (endKey.frame > currentFrame) {\r\n                        return startValue;\r\n                    } else {\r\n                        return endValue;\r\n                    }\r\n                }\r\n\r\n                const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n                const frameDelta = endKey.frame - startKey.frame;\r\n\r\n                // gradient : percent of currentFrame between the frame inf and the frame sup\r\n                let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n                // check for easingFunction and correction of gradient\r\n                const easingFunction = this.getEasingFunction();\r\n                if (easingFunction !== null) {\r\n                    gradient = easingFunction.ease(gradient);\r\n                }\r\n\r\n                switch (this.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT: {\r\n                        const floatValue = useTangent\r\n                            ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                            : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return floatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return state.offsetValue * state.repeatCount + floatValue;\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                        const quatValue = useTangent\r\n                            ? this.quaternionInterpolateFunctionWithTangents(\r\n                                  startValue,\r\n                                  startKey.outTangent.scale(frameDelta),\r\n                                  endValue,\r\n                                  endKey.inTangent.scale(frameDelta),\r\n                                  gradient\r\n                              )\r\n                            : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return quatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n\r\n                        return quatValue;\r\n                    }\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                        const vec3Value = useTangent\r\n                            ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                            : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec3Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                        const vec2Value = useTangent\r\n                            ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                            : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec2Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE: {\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3: {\r\n                        const color3Value = useTangent\r\n                            ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                            : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return color3Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return color3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Color4\r\n                    case Animation.ANIMATIONTYPE_COLOR4: {\r\n                        const color4Value = useTangent\r\n                            ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                            : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return color4Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return color4Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        break;\r\n                    }\r\n                    // Matrix\r\n                    case Animation.ANIMATIONTYPE_MATRIX: {\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT: {\r\n                                if (Animation.AllowMatricesInterpolation) {\r\n                                    return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                                }\r\n                                return startValue;\r\n                            }\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE: {\r\n                                return startValue;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this._getKeyValue(keys[keys.length - 1].value);\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>): void {\r\n        this._keys = values.slice(0);\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n\r\n    /**\r\n     * @param left\r\n     * @param right\r\n     * @param amount\r\n     * @hidden\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n"]},"metadata":{},"sourceType":"module"}