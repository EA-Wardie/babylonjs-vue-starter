{"ast":null,"code":"import \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nvar meshIdProvider = 0;\n/**\n * The mesh detector is used to detect meshes in the real world when in AR\n */\n\nvar WebXRMeshDetector =\n/** @class */\nfunction (_super) {\n  __extends(WebXRMeshDetector, _super);\n\n  function WebXRMeshDetector(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._detectedMeshes = new Map();\n    /**\n     * Observers registered here will be executed when a new mesh was added to the session\n     */\n\n    _this.onMeshAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when a mesh is no longer detected in the session\n     */\n\n    _this.onMeshRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing mesh updates\n     */\n\n    _this.onMeshUpdatedObservable = new Observable();\n    _this.xrNativeFeatureName = \"mesh-detection\";\n\n    if (_this._xrSessionManager.session) {\n      _this._init();\n    } else {\n      _this._xrSessionManager.onXRSessionInit.addOnce(function () {\n        _this._init();\n      });\n    }\n\n    return _this;\n  }\n\n  WebXRMeshDetector.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    } // Only supported by BabylonNative\n\n\n    if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n      this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\n    }\n\n    if (!this._options.doNotRemoveMeshesOnSessionEnded) {\n      this._detectedMeshes.forEach(function (mesh) {\n        _this.onMeshRemovedObservable.notifyObservers(mesh);\n      });\n\n      this._detectedMeshes.clear();\n    }\n\n    return true;\n  };\n\n  WebXRMeshDetector.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onMeshUpdatedObservable.clear();\n  };\n\n  WebXRMeshDetector.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    var _a; // TODO remove try catch\n\n\n    try {\n      if (!this.attached || !frame) {\n        return;\n      }\n\n      var detectedMeshes_1 = (_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedMeshes;\n\n      if (detectedMeshes_1) {\n        var toRemove_1 = new Set();\n\n        this._detectedMeshes.forEach(function (vertexData, xrMesh) {\n          if (!detectedMeshes_1.has(xrMesh)) {\n            toRemove_1.add(xrMesh);\n          }\n        });\n\n        toRemove_1.forEach(function (xrMesh) {\n          var vertexData = _this._detectedMeshes.get(xrMesh);\n\n          if (vertexData) {\n            _this.onMeshRemovedObservable.notifyObservers(vertexData);\n\n            _this._detectedMeshes[\"delete\"](xrMesh);\n          }\n        }); // now check for new ones\n\n        detectedMeshes_1.forEach(function (xrMesh) {\n          if (!_this._detectedMeshes.has(xrMesh)) {\n            var partialVertexData = {\n              id: meshIdProvider++,\n              xrMesh: xrMesh\n            };\n\n            var vertexData = _this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\n\n            _this._detectedMeshes.set(xrMesh, vertexData);\n\n            _this.onMeshAddedObservable.notifyObservers(vertexData);\n          } else {\n            // updated?\n            if (xrMesh.lastChangedTime === _this._xrSessionManager.currentTimestamp) {\n              var vertexData = _this._detectedMeshes.get(xrMesh);\n\n              if (vertexData) {\n                _this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\n\n                _this.onMeshUpdatedObservable.notifyObservers(vertexData);\n              }\n            }\n          }\n        });\n      }\n    } catch (error) {\n      console.log(error.stack);\n    }\n  };\n\n  WebXRMeshDetector.prototype._init = function () {\n    // Only supported by BabylonNative\n    if (this._xrSessionManager.isNative) {\n      if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n        this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\n      }\n\n      if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\n        this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\n      }\n    }\n  };\n\n  WebXRMeshDetector.prototype._updateVertexDataWithXRMesh = function (xrMesh, mesh, xrFrame) {\n    mesh.xrMesh = xrMesh;\n    mesh.worldParentNode = this._options.worldParentNode;\n\n    if (this._options.convertCoordinateSystems) {\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mesh.positions = new Float32Array(xrMesh.positions.length);\n\n        for (var i = 0; i < xrMesh.positions.length; i += 3) {\n          mesh.positions[i] = xrMesh.positions[i];\n          mesh.positions[i + 1] = xrMesh.positions[i + 1];\n          mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];\n        }\n\n        if (xrMesh.normals) {\n          mesh.normals = new Float32Array(xrMesh.normals.length);\n\n          for (var i = 0; i < xrMesh.normals.length; i += 3) {\n            mesh.normals[i] = xrMesh.normals[i];\n            mesh.normals[i + 1] = xrMesh.normals[i + 1];\n            mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\n          }\n        }\n      } else {\n        mesh.positions = xrMesh.positions;\n        mesh.normals = xrMesh.normals;\n      } // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\n\n\n      mesh.indices = xrMesh.indices; // matrix\n\n      var pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\n\n      if (pose) {\n        var mat = mesh.transformationMatrix || new Matrix();\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n\n        mesh.transformationMatrix = mat;\n\n        if (this._options.worldParentNode) {\n          mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n        }\n      }\n    }\n\n    return mesh;\n  };\n  /**\n   * The module's name\n   */\n\n\n  WebXRMeshDetector.Name = WebXRFeatureName.MESH_DETECTION;\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number does not correspond to the WebXR specs version\n   */\n\n  WebXRMeshDetector.Version = 1;\n  return WebXRMeshDetector;\n}(WebXRAbstractFeature);\n\nexport { WebXRMeshDetector };\nWebXRFeaturesManager.AddWebXRFeature(WebXRMeshDetector.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRMeshDetector(xrSessionManager, options);\n  };\n}, WebXRMeshDetector.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","WebXRAbstractFeature","Matrix","Observable","meshIdProvider","__extends","_xrSessionManager","_options","_super","_this","Map","xrNativeFeatureName","session","_init","onXRSessionInit","addOnce","WebXRMeshDetector","detach","call","isNative","trySetMeshDetectorEnabled","doNotRemoveMeshesOnSessionEnded","_detectedMeshes","forEach","mesh","onMeshRemovedObservable","notifyObservers","clear","dispose","onMeshAddedObservable","onMeshUpdatedObservable","frame","attached","detectedMeshes_1","worldInformation","_a","detectedMeshes","toRemove_1","Set","vertexData","xrMesh","has","add","get","partialVertexData","id","_updateVertexDataWithXRMesh","set","lastChangedTime","currentTimestamp","error","console","log","stack","preferredDetectorOptions","trySetPreferredMeshDetectorOptions","xrFrame","worldParentNode","convertCoordinateSystems","scene","useRightHandedSystem","positions","Float32Array","length","i","normals","indices","pose","getPose","meshSpace","referenceSpace","mat","transformationMatrix","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","multiplyToRef","getWorldMatrix","MESH_DETECTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/XR/features/WebXRMeshDetector.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Matrix } from \"../../Maths/math\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Options used in the mesh detector module\r\n */\r\nexport interface IWebXRMeshDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * If set to true a reference of the created meshes will be kept until the next session starts\r\n     * If not defined, meshes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveMeshesOnSessionEnded?: boolean;\r\n    /**\r\n     * Preferred detector configuration, not all preferred options will be supported by all platforms.\r\n     */\r\n    preferredDetectorOptions?: XRGeometryDetectorOptions;\r\n    /**\r\n     * If set to true, WebXRMeshDetector will convert coordinate systems for meshes.\r\n     * If not defined, mesh conversions from right handed to left handed coordinate systems won't be conducted.\r\n     * Right handed mesh data will be available through IWebXRVertexData.xrMesh.\r\n     */\r\n    convertCoordinateSystems?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon interface for a XR mesh's vertex data.\r\n *\r\n * Currently not supported by WebXR, available only with BabylonNative\r\n */\r\nexport interface IWebXRVertexData {\r\n    /**\r\n     * A babylon-assigned ID for this mesh\r\n     */\r\n    id: number;\r\n    /**\r\n     * Data required for constructing a mesh in Babylon.js.\r\n     */\r\n    xrMesh: XRMesh;\r\n    /**\r\n     * The node to use to transform the local results to world coordinates.\r\n     * WorldParentNode will only exist if it was declared in the IWebXRMeshDetectorOptions.\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * An array of vertex positions in babylon space. right/left hand system is taken into account.\r\n     * Positions will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    positions?: Float32Array;\r\n    /**\r\n     * An array of indices in babylon space. Indices have a counterclockwise winding order.\r\n     * Indices will only be populated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    indices?: Uint32Array;\r\n    /**\r\n     * An array of vertex normals in babylon space. right/left hand system is taken into account.\r\n     * Normals will not be calculated if convertCoordinateSystems is undefined in the IWebXRMeshDetectorOptions.\r\n     * Different platforms may or may not support mesh normals when convertCoordinateSystems is set to true.\r\n     */\r\n    normals?: Float32Array;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the meshDefinition.\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module.\r\n     * TransformationMatrix will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    transformationMatrix?: Matrix;\r\n}\r\n\r\nlet meshIdProvider = 0;\r\n\r\n/**\r\n * The mesh detector is used to detect meshes in the real world when in AR\r\n */\r\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\r\n    private _detectedMeshes: Map<XRMesh, IWebXRVertexData> = new Map<XRMesh, IWebXRVertexData>();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MESH_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new mesh was added to the session\r\n     */\r\n    public onMeshAddedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a mesh is no longer detected in the session\r\n     */\r\n    public onMeshRemovedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing mesh updates\r\n     */\r\n    public onMeshUpdatedObservable: Observable<IWebXRVertexData> = new Observable();\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRMeshDetectorOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"mesh-detection\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        // Only supported by BabylonNative\r\n        if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n            this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\r\n        }\r\n\r\n        if (!this._options.doNotRemoveMeshesOnSessionEnded) {\r\n            this._detectedMeshes.forEach((mesh) => {\r\n                this.onMeshRemovedObservable.notifyObservers(mesh);\r\n            });\r\n\r\n            this._detectedMeshes.clear();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onMeshAddedObservable.clear();\r\n        this.onMeshRemovedObservable.clear();\r\n        this.onMeshUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // TODO remove try catch\r\n        try {\r\n            if (!this.attached || !frame) {\r\n                return;\r\n            }\r\n\r\n            const detectedMeshes = frame.worldInformation?.detectedMeshes;\r\n            if (detectedMeshes) {\r\n                const toRemove = new Set<XRMesh>();\r\n                this._detectedMeshes.forEach((vertexData, xrMesh) => {\r\n                    if (!detectedMeshes.has(xrMesh)) {\r\n                        toRemove.add(xrMesh);\r\n                    }\r\n                });\r\n                toRemove.forEach((xrMesh) => {\r\n                    const vertexData = this._detectedMeshes.get(xrMesh);\r\n                    if (vertexData) {\r\n                        this.onMeshRemovedObservable.notifyObservers(vertexData);\r\n                        this._detectedMeshes.delete(xrMesh);\r\n                    }\r\n                });\r\n\r\n                // now check for new ones\r\n                detectedMeshes.forEach((xrMesh) => {\r\n                    if (!this._detectedMeshes.has(xrMesh)) {\r\n                        const partialVertexData: Partial<IWebXRVertexData> = {\r\n                            id: meshIdProvider++,\r\n                            xrMesh: xrMesh,\r\n                        };\r\n                        const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\r\n                        this._detectedMeshes.set(xrMesh, vertexData);\r\n                        this.onMeshAddedObservable.notifyObservers(vertexData);\r\n                    } else {\r\n                        // updated?\r\n                        if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                            const vertexData = this._detectedMeshes.get(xrMesh);\r\n                            if (vertexData) {\r\n                                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\r\n                                this.onMeshUpdatedObservable.notifyObservers(vertexData);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.log(error.stack);\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        // Only supported by BabylonNative\r\n        if (this._xrSessionManager.isNative) {\r\n            if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n                this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\r\n            }\r\n\r\n            if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\r\n                this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateVertexDataWithXRMesh(xrMesh: XRMesh, mesh: Partial<IWebXRVertexData>, xrFrame: XRFrame): IWebXRVertexData {\r\n        mesh.xrMesh = xrMesh;\r\n        mesh.worldParentNode = this._options.worldParentNode;\r\n\r\n        if (this._options.convertCoordinateSystems) {\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mesh.positions = new Float32Array(xrMesh.positions.length);\r\n                for (let i = 0; i < xrMesh.positions.length; i += 3) {\r\n                    mesh.positions[i] = xrMesh.positions[i];\r\n                    mesh.positions[i + 1] = xrMesh.positions[i + 1];\r\n                    mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];\r\n                }\r\n\r\n                if (xrMesh.normals) {\r\n                    mesh.normals = new Float32Array(xrMesh.normals.length);\r\n                    for (let i = 0; i < xrMesh.normals.length; i += 3) {\r\n                        mesh.normals[i] = xrMesh.normals[i];\r\n                        mesh.normals[i + 1] = xrMesh.normals[i + 1];\r\n                        mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\r\n                    }\r\n                }\r\n            } else {\r\n                mesh.positions = xrMesh.positions;\r\n                mesh.normals = xrMesh.normals;\r\n            }\r\n\r\n            // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\r\n            mesh.indices = xrMesh.indices;\r\n\r\n            // matrix\r\n            const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\r\n            if (pose) {\r\n                const mat = mesh.transformationMatrix || new Matrix();\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                mesh.transformationMatrix = mat;\r\n                if (this._options.worldParentNode) {\r\n                    mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n                }\r\n            }\r\n        }\r\n\r\n        return <IWebXRVertexData>mesh;\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMeshDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMeshDetector(xrSessionManager, options);\r\n    },\r\n    WebXRMeshDetector.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module"}