{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { __assign, __decorate } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { UniformBuffer } from \"./uniformBuffer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nimport { MaterialHelper } from \"./materialHelper.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\nimport { MaterialStencilState } from \"./materialStencilState.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\n/**\n * Base class for the main features of a material in Babylon.js\n */\n\nvar Material =\n/** @class */\nfunction () {\n  /**\n   * Creates a material instance\n   * @param name defines the name of the material\n   * @param scene defines the scene to reference\n   * @param doNotAdd specifies if the material should be added to the scene\n   */\n  function Material(name, scene, doNotAdd) {\n    /**\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\n     */\n    this.shadowDepthWrapper = null;\n    /**\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\n     * This means that the material can keep using a previous shader while a new one is being compiled.\n     * This is mostly used when shader parallel compilation is supported (true by default)\n     */\n\n    this.allowShaderHotSwapping = true;\n    /**\n     * Gets or sets user defined metadata\n     */\n\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n\n    this.reservedDataStore = null;\n    /**\n     * Specifies if the ready state should be checked on each call\n     */\n\n    this.checkReadyOnEveryCall = false;\n    /**\n     * Specifies if the ready state should be checked once\n     */\n\n    this.checkReadyOnlyOnce = false;\n    /**\n     * The state of the material\n     */\n\n    this.state = \"\";\n    /**\n     * The alpha value of the material\n     */\n\n    this._alpha = 1.0;\n    /**\n     * Specifies if back face culling is enabled\n     */\n\n    this._backFaceCulling = true;\n    /**\n     * Specifies if back or front faces should be culled (when culling is enabled)\n     */\n\n    this._cullBackFaces = true;\n    /**\n     * Callback triggered when the material is compiled\n     */\n\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n\n    this.onError = null;\n    /**\n     * Callback triggered to get the render target textures\n     */\n\n    this.getRenderTargetTextures = null;\n    /**\n     * Specifies if the material should be serialized\n     */\n\n    this.doNotSerialize = false;\n    /**\n     * @hidden\n     */\n\n    this._storeEffectOnSubMeshes = false;\n    /**\n     * Stores the animations for the material\n     */\n\n    this.animations = null;\n    /**\n     * An event triggered when the material is disposed\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\n     * An observer which watches for dispose events\n     */\n\n    this._onDisposeObserver = null;\n    this._onUnBindObservable = null;\n    /**\n     * An observer which watches for bind events\n     */\n\n    this._onBindObserver = null;\n    /**\n     * Stores the value of the alpha mode\n     */\n\n    this._alphaMode = 2;\n    /**\n     * Stores the state of the need depth pre-pass value\n     */\n\n    this._needDepthPrePass = false;\n    /**\n     * Specifies if depth writing should be disabled\n     */\n\n    this.disableDepthWrite = false;\n    /**\n     * Specifies if color writing should be disabled\n     */\n\n    this.disableColorWrite = false;\n    /**\n     * Specifies if depth writing should be forced\n     */\n\n    this.forceDepthWrite = false;\n    /**\n     * Specifies the depth function that should be used. 0 means the default engine function\n     */\n\n    this.depthFunction = 0;\n    /**\n     * Specifies if there should be a separate pass for culling\n     */\n\n    this.separateCullingPass = false;\n    /**\n     * Stores the state specifying if fog should be enabled\n     */\n\n    this._fogEnabled = true;\n    /**\n     * Stores the size of points\n     */\n\n    this.pointSize = 1.0;\n    /**\n     * Stores the z offset Factor value\n     */\n\n    this.zOffset = 0;\n    /**\n     * Stores the z offset Units value\n     */\n\n    this.zOffsetUnits = 0;\n    /**\n     * Gives access to the stencil properties of the material\n     */\n\n    this.stencil = new MaterialStencilState();\n    /**\n     * Specifies if uniform buffers should be used\n     */\n\n    this._useUBO = false;\n    /**\n     * Stores the fill mode state\n     */\n\n    this._fillMode = Material.TriangleFillMode;\n    /**\n     * Specifies if the depth write state should be cached\n     */\n\n    this._cachedDepthWriteState = false;\n    /**\n     * Specifies if the color write state should be cached\n     */\n\n    this._cachedColorWriteState = false;\n    /**\n     * Specifies if the depth function state should be cached\n     */\n\n    this._cachedDepthFunctionState = 0;\n    /** @hidden */\n\n    this._indexInSceneMaterialArray = -1;\n    /** @hidden */\n\n    this.meshMap = null;\n    /** @hidden */\n\n    this._parentContainer = null;\n    /** @hidden */\n\n    this._uniformBufferLayoutBuilt = false;\n    this._eventInfo = {}; // will be initialized before each event notification\n\n    /** @hidden */\n\n    this._callbackPluginEventGeneric = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventIsReadyForSubMesh = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventPrepareDefines = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventHardBindForSubMesh = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventBindForSubMesh = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventHasRenderTargetTextures = function () {\n      return void 0;\n    };\n    /** @hidden */\n\n\n    this._callbackPluginEventFillRenderTargetTextures = function () {\n      return void 0;\n    };\n    /**\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n     */\n\n\n    this._forceAlphaTest = false;\n    /**\n     * The transparency mode of the material.\n     */\n\n    this._transparencyMode = null;\n    this.name = name;\n    var setScene = scene || EngineStore.LastCreatedScene;\n\n    if (!setScene) {\n      return;\n    }\n\n    this._scene = setScene;\n    this._dirtyCallbacks = {};\n    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);\n    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);\n    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);\n    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);\n    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);\n    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);\n    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);\n    this.id = name || Tools.RandomId();\n    this.uniqueId = this._scene.getUniqueId();\n    this._materialContext = this._scene.getEngine().createMaterialContext();\n    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\n    this._drawWrapper.materialContext = this._materialContext;\n\n    if (this._scene.useRightHandedSystem) {\n      this.sideOrientation = Material.ClockWiseSideOrientation;\n    } else {\n      this.sideOrientation = Material.CounterClockWiseSideOrientation;\n    }\n\n    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\n    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\n\n    if (!doNotAdd) {\n      this._scene.addMaterial(this);\n    }\n\n    if (this._scene.useMaterialMeshMap) {\n      this.meshMap = {};\n    }\n\n    Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\n  }\n\n  Object.defineProperty(Material.prototype, \"canRenderToMRT\", {\n    /**\n     * If the material can be rendered to several textures with MRT extension\n     */\n    get: function get() {\n      // By default, shaders are not compatible with MRTs\n      // Base classes should override that if their shader supports MRT\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alpha\", {\n    /**\n     * Gets the alpha value of the material\n     */\n    get: function get() {\n      return this._alpha;\n    },\n\n    /**\n     * Sets the alpha value of the material\n     */\n    set: function set(value) {\n      if (this._alpha === value) {\n        return;\n      }\n\n      this._alpha = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"backFaceCulling\", {\n    /**\n     * Gets the culling state\n     */\n    get: function get() {\n      return this._backFaceCulling;\n    },\n\n    /**\n     * Sets the culling state (true to enable culling, false to disable)\n     */\n    set: function set(value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n\n      this._backFaceCulling = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"cullBackFaces\", {\n    /**\n     * Gets the type of faces that should be culled\n     */\n    get: function get() {\n      return this._cullBackFaces;\n    },\n\n    /**\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\n     */\n    set: function set(value) {\n      if (this._cullBackFaces === value) {\n        return;\n      }\n\n      this._cullBackFaces = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"hasRenderTargetTextures\", {\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get: function get() {\n      this._eventInfo.hasRenderTargetTextures = false;\n\n      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n\n      return this._eventInfo.hasRenderTargetTextures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onDispose\", {\n    /**\n     * Called during a dispose event\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBindObservable\", {\n    /**\n     * An event triggered when the material is bound\n     */\n    get: function get() {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBind\", {\n    /**\n     * Called during a bind event\n     */\n    set: function set(callback) {\n      if (this._onBindObserver) {\n        this.onBindObservable.remove(this._onBindObserver);\n      }\n\n      this._onBindObserver = this.onBindObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onUnBindObservable\", {\n    /**\n     * An event triggered when the material is unbound\n     */\n    get: function get() {\n      if (!this._onUnBindObservable) {\n        this._onUnBindObservable = new Observable();\n      }\n\n      return this._onUnBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onEffectCreatedObservable\", {\n    /**\n     * An event triggered when the effect is (re)created\n     */\n    get: function get() {\n      if (!this._onEffectCreatedObservable) {\n        this._onEffectCreatedObservable = new Observable();\n      }\n\n      return this._onEffectCreatedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alphaMode\", {\n    /**\n     * Gets the value of the alpha mode\n     */\n    get: function get() {\n      return this._alphaMode;\n    },\n\n    /**\n     * Sets the value of the alpha mode.\n     *\n     * | Value | Type | Description |\n     * | --- | --- | --- |\n     * | 0 | ALPHA_DISABLE |   |\n     * | 1 | ALPHA_ADD |   |\n     * | 2 | ALPHA_COMBINE |   |\n     * | 3 | ALPHA_SUBTRACT |   |\n     * | 4 | ALPHA_MULTIPLY |   |\n     * | 5 | ALPHA_MAXIMIZED |   |\n     * | 6 | ALPHA_ONEONE |   |\n     * | 7 | ALPHA_PREMULTIPLIED |   |\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\n     * | 9 | ALPHA_INTERPOLATE |   |\n     * | 10 | ALPHA_SCREENMODE |   |\n     *\n     */\n    set: function set(value) {\n      if (this._alphaMode === value) {\n        return;\n      }\n\n      this._alphaMode = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"needDepthPrePass\", {\n    /**\n     * Gets the depth pre-pass value\n     */\n    get: function get() {\n      return this._needDepthPrePass;\n    },\n\n    /**\n     * Sets the need depth pre-pass value\n     */\n    set: function set(value) {\n      if (this._needDepthPrePass === value) {\n        return;\n      }\n\n      this._needDepthPrePass = value;\n\n      if (this._needDepthPrePass) {\n        this.checkReadyOnEveryCall = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"isPrePassCapable\", {\n    /**\n     * Can this material render to prepass\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fogEnabled\", {\n    /**\n     * Gets the value of the fog enabled state\n     */\n    get: function get() {\n      return this._fogEnabled;\n    },\n\n    /**\n     * Sets the state for enabling fog\n     */\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"wireframe\", {\n    get: function get() {\n      switch (this._fillMode) {\n        case Material.WireFrameFillMode:\n        case Material.LineListDrawMode:\n        case Material.LineLoopDrawMode:\n        case Material.LineStripDrawMode:\n          return true;\n      }\n\n      return this._scene.forceWireframe;\n    },\n\n    /**\n     * Sets the state of wireframe mode\n     */\n    set: function set(value) {\n      this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"pointsCloud\", {\n    /**\n     * Gets the value specifying if point clouds are enabled\n     */\n    get: function get() {\n      switch (this._fillMode) {\n        case Material.PointFillMode:\n        case Material.PointListDrawMode:\n          return true;\n      }\n\n      return this._scene.forcePointsCloud;\n    },\n\n    /**\n     * Sets the state of point cloud mode\n     */\n    set: function set(value) {\n      this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fillMode\", {\n    /**\n     * Gets the material fill mode\n     */\n    get: function get() {\n      return this._fillMode;\n    },\n\n    /**\n     * Sets the material fill mode\n     */\n    set: function set(value) {\n      if (this._fillMode === value) {\n        return;\n      }\n\n      this._fillMode = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  Material.prototype._getDrawWrapper = function () {\n    return this._drawWrapper;\n  };\n  /**\n   * @param drawWrapper\n   * @hidden\n   */\n\n\n  Material.prototype._setDrawWrapper = function (drawWrapper) {\n    this._drawWrapper = drawWrapper;\n  };\n  /**\n   * Returns a string representation of the current material\n   * @param fullDetails defines a boolean indicating which levels of logging is desired\n   * @returns a string with material information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    return ret;\n  };\n  /**\n   * Gets the class name of the material\n   * @returns a string with the class name of the material\n   */\n\n\n  Material.prototype.getClassName = function () {\n    return \"Material\";\n  };\n\n  Object.defineProperty(Material.prototype, \"isFrozen\", {\n    /**\n     * Specifies if updates for the material been locked\n     */\n    get: function get() {\n      return this.checkReadyOnlyOnce;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Locks updates for the material\n   */\n\n  Material.prototype.freeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = true;\n  };\n  /**\n   * Unlocks updates for the material\n   */\n\n\n  Material.prototype.unfreeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = false;\n  };\n  /**\n   * Specifies if the material is ready to be used\n   * @param mesh defines the mesh to check\n   * @param useInstances specifies if instances should be used\n   * @returns a boolean indicating if the material is ready to be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.isReady = function (mesh, useInstances) {\n    return true;\n  };\n  /**\n   * Specifies that the submesh is ready to be used\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    var defines = subMesh.materialDefines;\n\n    if (!defines) {\n      return false;\n    }\n\n    this._eventInfo.isReadyForSubMesh = true;\n    this._eventInfo.defines = defines;\n\n    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n\n    return this._eventInfo.isReadyForSubMesh;\n  };\n  /**\n   * Returns the material effect\n   * @returns the effect associated with the material\n   */\n\n\n  Material.prototype.getEffect = function () {\n    return this._drawWrapper.effect;\n  };\n  /**\n   * Returns the current scene\n   * @returns a Scene\n   */\n\n\n  Material.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(Material.prototype, \"transparencyMode\", {\n    /**\n     * Gets the current transparency mode.\n     */\n    get: function get() {\n      return this._transparencyMode;\n    },\n\n    /**\n     * Sets the transparency mode of the material.\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 0     | OPAQUE                              |             |\n     * | 1     | ALPHATEST                           |             |\n     * | 2     | ALPHABLEND                          |             |\n     * | 3     | ALPHATESTANDBLEND                   |             |\n     *\n     */\n    set: function set(value) {\n      if (this._transparencyMode === value) {\n        return;\n      }\n\n      this._transparencyMode = value;\n      this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\n\n      this._markAllSubMeshesAsTexturesAndMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"_disableAlphaBlending\", {\n    /**\n     * Returns true if alpha blending should be disabled.\n     */\n    get: function get() {\n      return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Specifies whether or not this material should be rendered in alpha blend mode.\n   * @returns a boolean specifying if alpha blending is needed\n   */\n\n  Material.prototype.needAlphaBlending = function () {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n\n    return this.alpha < 1.0;\n  };\n  /**\n   * Specifies if the mesh will require alpha blending\n   * @param mesh defines the mesh to check\n   * @returns a boolean specifying if alpha blending is needed for the mesh\n   */\n\n\n  Material.prototype.needAlphaBlendingForMesh = function (mesh) {\n    if (this._disableAlphaBlending && mesh.visibility >= 1.0) {\n      return false;\n    }\n\n    return this.needAlphaBlending() || mesh.visibility < 1.0 || mesh.hasVertexAlpha;\n  };\n  /**\n   * Specifies whether or not this material should be rendered in alpha test mode.\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n\n\n  Material.prototype.needAlphaTesting = function () {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Specifies if material alpha testing should be turned on for the mesh\n   * @param mesh defines the mesh to check\n   */\n\n\n  Material.prototype._shouldTurnAlphaTestOn = function (mesh) {\n    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\n  };\n  /**\n   * Gets the texture used for the alpha test\n   * @returns the texture to use for alpha testing\n   */\n\n\n  Material.prototype.getAlphaTestTexture = function () {\n    return null;\n  };\n  /**\n   * Marks the material to indicate that it needs to be re-calculated\n   */\n\n\n  Material.prototype.markDirty = function () {\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n      var mesh = meshes_1[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh.effect) {\n          continue;\n        }\n\n        subMesh.effect._wasPreviouslyReady = false;\n      }\n    }\n  };\n  /**\n   * @param effect\n   * @param overrideOrientation\n   * @hidden\n   */\n\n\n  Material.prototype._preBind = function (effect, overrideOrientation) {\n    if (overrideOrientation === void 0) {\n      overrideOrientation = null;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\n    var reverse = orientation === Material.ClockWiseSideOrientation;\n    engine.enableEffect(effect ? effect : this._getDrawWrapper());\n    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this.cullBackFaces, this.stencil, this.zOffsetUnits);\n    return reverse;\n  };\n  /**\n   * Binds the material to the mesh\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh to bind the material to\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.bind = function (world, mesh) {};\n  /**\n   * Initializes the uniform buffer layout for the shader.\n   */\n\n\n  Material.prototype.buildUniformLayout = function () {\n    var ubo = this._uniformBuffer;\n    this._eventInfo.ubo = ubo;\n\n    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\n\n    ubo.create();\n    this._uniformBufferLayoutBuilt = true;\n  };\n  /**\n   * Binds the submesh to the material\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n\n\n  Material.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._eventInfo.subMesh = subMesh;\n\n    this._callbackPluginEventBindForSubMesh(this._eventInfo);\n  };\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.bindOnlyWorldMatrix = function (world) {};\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   */\n\n\n  Material.prototype.bindView = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  };\n  /**\n   * Binds the view projection and projection matrices to the effect\n   * @param effect defines the effect to bind the view projection and projection matrices to\n   */\n\n\n  Material.prototype.bindViewProjection = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n      effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  };\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   * @param variableName name of the shader variable that will hold the eye position\n   */\n\n\n  Material.prototype.bindEyePosition = function (effect, variableName) {\n    if (!this._useUBO) {\n      this._scene.bindEyePosition(effect, variableName);\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  };\n  /**\n   * Processes to execute after binding the material to a mesh\n   * @param mesh defines the rendered mesh\n   * @param effect\n   */\n\n\n  Material.prototype._afterBind = function (mesh, effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    this._scene._cachedMaterial = this;\n\n    if (this._needToBindSceneUbo) {\n      if (effect) {\n        this._needToBindSceneUbo = false;\n        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n\n        this._scene.finalizeSceneUbo();\n      }\n    }\n\n    if (mesh) {\n      this._scene._cachedVisibility = mesh.visibility;\n    } else {\n      this._scene._cachedVisibility = 1;\n    }\n\n    if (this._onBindObservable && mesh) {\n      this._onBindObservable.notifyObservers(mesh);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthWriteState = engine.getDepthWrite();\n      engine.setDepthWrite(false);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedColorWriteState = engine.getColorWrite();\n      engine.setColorWrite(false);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\n      engine.setDepthFunction(this.depthFunction);\n    }\n  };\n  /**\n   * Unbinds the material from the mesh\n   */\n\n\n  Material.prototype.unbind = function () {\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.notifyObservers(this);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthFunction(this._cachedDepthFunctionState);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthWrite(this._cachedDepthWriteState);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setColorWrite(this._cachedColorWriteState);\n    }\n  };\n  /**\n   * Returns the animatable textures.\n   * @returns - Array of animatable textures.\n   */\n\n\n  Material.prototype.getAnimatables = function () {\n    this._eventInfo.animatables = [];\n\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\n\n    return this._eventInfo.animatables;\n  };\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n\n\n  Material.prototype.getActiveTextures = function () {\n    this._eventInfo.activeTextures = [];\n\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\n\n    return this._eventInfo.activeTextures;\n  };\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n\n\n  Material.prototype.hasTexture = function (texture) {\n    this._eventInfo.hasTexture = false;\n    this._eventInfo.texture = texture;\n\n    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\n\n    return this._eventInfo.hasTexture;\n  };\n  /**\n   * Makes a duplicate of the material, and gives it a new name\n   * @param name defines the new name for the duplicated material\n   * @returns the cloned material\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.clone = function (name) {\n    return null;\n  };\n  /**\n   * Gets the meshes bound to the material\n   * @returns an array of meshes bound to the material\n   */\n\n\n  Material.prototype.getBindedMeshes = function () {\n    var _this = this;\n\n    if (this.meshMap) {\n      var result = new Array();\n\n      for (var meshId in this.meshMap) {\n        var mesh = this.meshMap[meshId];\n\n        if (mesh) {\n          result.push(mesh);\n        }\n      }\n\n      return result;\n    } else {\n      var meshes = this._scene.meshes;\n      return meshes.filter(function (mesh) {\n        return mesh.material === _this;\n      });\n    }\n  };\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh associated with this material\n   * @param onCompiled defines a function to execute once the material is compiled\n   * @param options defines the options to configure the compilation\n   * @param onError defines a function to execute if the material fails compiling\n   */\n\n\n  Material.prototype.forceCompilation = function (mesh, onCompiled, options, onError) {\n    var _this = this;\n\n    var localOptions = __assign({\n      clipPlane: false,\n      useInstances: false\n    }, options);\n\n    var scene = this.getScene();\n    var currentHotSwapingState = this.allowShaderHotSwapping;\n    this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\n\n    var checkReady = function checkReady() {\n      if (!_this._scene || !_this._scene.getEngine()) {\n        return;\n      }\n\n      var clipPlaneState = scene.clipPlane;\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = new Plane(0, 0, 0, 1);\n      }\n\n      if (_this._storeEffectOnSubMeshes) {\n        var allDone = true,\n            lastError = null;\n\n        if (mesh.subMeshes) {\n          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\n\n          if (tempSubMesh.materialDefines) {\n            tempSubMesh.materialDefines._renderId = -1;\n          }\n\n          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\n            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\n              lastError = tempSubMesh.effect.getCompilationError();\n            } else {\n              allDone = false;\n              setTimeout(checkReady, 16);\n            }\n          }\n        }\n\n        if (allDone) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (lastError) {\n            if (onError) {\n              onError(lastError);\n            }\n          }\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        }\n      } else {\n        if (_this.isReady()) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        } else {\n          setTimeout(checkReady, 16);\n        }\n      }\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = clipPlaneState;\n      }\n    };\n\n    checkReady();\n  };\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh that will use this material\n   * @param options defines additional options for compiling the shaders\n   * @returns a promise that resolves when the compilation completes\n   */\n\n\n  Material.prototype.forceCompilationAsync = function (mesh, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.forceCompilation(mesh, function () {\n        resolve();\n      }, options, function (reason) {\n        reject(reason);\n      });\n    });\n  };\n  /**\n   * Marks a define in the material to indicate that it needs to be re-computed\n   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\n   */\n\n\n  Material.prototype.markAsDirty = function (flag) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    Material._DirtyCallbackArray.length = 0;\n\n    if (flag & Material.TextureDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\n    }\n\n    if (flag & Material.LightDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\n    }\n\n    if (flag & Material.FresnelDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\n    }\n\n    if (flag & Material.AttributesDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\n    }\n\n    if (flag & Material.MiscDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\n    }\n\n    if (flag & Material.PrePassDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\n    }\n\n    if (Material._DirtyCallbackArray.length) {\n      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\n    }\n\n    this.getScene().resetCachedMaterial();\n  };\n  /**\n   * Resets the draw wrappers cache for all submeshes that are using this material\n   */\n\n\n  Material.prototype.resetDrawCache = function () {\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {\n      var mesh = meshes_2[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        subMesh.resetDrawCache();\n      }\n    }\n  };\n  /**\n   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\n   * @param func defines a function which checks material defines against the submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsDirty = function (func) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {\n      var mesh = meshes_3[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a]; // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\n\n        if (mesh._renderId === 0 || subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        for (var _c = 0, _d = subMesh._drawWrappers; _c < _d.length; _c++) {\n          var drawWrapper = _d[_c];\n\n          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n            continue;\n          }\n\n          if (this._materialContext === drawWrapper.materialContext) {\n            func(drawWrapper.defines);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Indicates that the scene should check if the rendering now needs a prepass\n   */\n\n\n  Material.prototype._markScenePrePassDirty = function () {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var prePassRenderer = this.getScene().enablePrePassRenderer();\n\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  };\n  /**\n   * Indicates that we need to re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAllDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\n  };\n  /**\n   * Indicates that image processing needs to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsImageProcessingDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\n  };\n  /**\n   * Indicates that textures need to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\n  };\n  /**\n   * Indicates that fresnel needs to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\n  };\n  /**\n   * Indicates that fresnel and misc need to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\n  };\n  /**\n   * Indicates that lights need to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsLightsDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\n  };\n  /**\n   * Indicates that attributes need to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAttributesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\n  };\n  /**\n   * Indicates that misc needs to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\n   * Indicates that prepass needs to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsPrePassDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\n   * Indicates that textures and misc need to be re-calculated for all submeshes\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\n  };\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Material.prototype.setPrePassRenderer = function (prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  };\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n\n\n  Material.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    var scene = this.getScene(); // Animations\n\n    scene.stopAnimation(this);\n    scene.freeProcessedMaterials(); // Remove from scene\n\n    scene.removeMaterial(this);\n    this._eventInfo.forceDisposeTextures = forceDisposeTextures;\n\n    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\n\n    if (this._parentContainer) {\n      var index = this._parentContainer.materials.indexOf(this);\n\n      if (index > -1) {\n        this._parentContainer.materials.splice(index, 1);\n      }\n\n      this._parentContainer = null;\n    }\n\n    if (notBoundToMesh !== true) {\n      // Remove from meshes\n      if (this.meshMap) {\n        for (var meshId in this.meshMap) {\n          var mesh = this.meshMap[meshId];\n\n          if (mesh) {\n            mesh.material = null; // will set the entry in the map to undefined\n\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      } else {\n        var meshes = scene.meshes;\n\n        for (var _i = 0, meshes_4 = meshes; _i < meshes_4.length; _i++) {\n          var mesh = meshes_4[_i];\n\n          if (mesh.material === this && !mesh.sourceMesh) {\n            mesh.material = null;\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      }\n    }\n\n    this._uniformBuffer.dispose(); // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n\n\n    if (forceDisposeEffect && this._drawWrapper.effect) {\n      if (!this._storeEffectOnSubMeshes) {\n        this._drawWrapper.effect.dispose();\n      }\n\n      this._drawWrapper.effect = null;\n    }\n\n    this.metadata = null; // Callback\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n\n    if (this._onBindObservable) {\n      this._onBindObservable.clear();\n    }\n\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.clear();\n    }\n\n    if (this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable.clear();\n    }\n  };\n  /**\n   * @param mesh\n   * @param forceDisposeEffect\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  Material.prototype.releaseVertexArrayObject = function (mesh, forceDisposeEffect) {\n    if (mesh.geometry) {\n      var geometry = mesh.geometry;\n\n      if (this._storeEffectOnSubMeshes) {\n        for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {\n          var subMesh = _a[_i];\n\n          geometry._releaseVertexArrayObject(subMesh.effect);\n\n          if (forceDisposeEffect && subMesh.effect) {\n            subMesh.effect.dispose();\n          }\n        }\n      } else {\n        geometry._releaseVertexArrayObject(this._drawWrapper.effect);\n      }\n    }\n  };\n  /**\n   * Serializes this material\n   * @returns the serialized material object\n   */\n\n\n  Material.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.stencil = this.stencil.serialize();\n    serializationObject.uniqueId = this.uniqueId;\n    return serializationObject;\n  };\n  /**\n   * Creates a material from parsed material data\n   * @param parsedMaterial defines parsed material data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures\n   * @returns a new material\n   */\n\n\n  Material.Parse = function (parsedMaterial, scene, rootUrl) {\n    if (!parsedMaterial.customType) {\n      parsedMaterial.customType = \"BABYLON.StandardMaterial\";\n    } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n      parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n\n      if (!BABYLON.LegacyPBRMaterial) {\n        Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n        return null;\n      }\n    }\n\n    var materialType = Tools.Instantiate(parsedMaterial.customType);\n    var material = materialType.Parse(parsedMaterial, scene, rootUrl);\n    material._loadedUniqueId = parsedMaterial.uniqueId;\n    return material;\n  };\n  /**\n   * Returns the triangle fill mode\n   */\n\n\n  Material.TriangleFillMode = 0;\n  /**\n   * Returns the wireframe mode\n   */\n\n  Material.WireFrameFillMode = 1;\n  /**\n   * Returns the point fill mode\n   */\n\n  Material.PointFillMode = 2;\n  /**\n   * Returns the point list draw mode\n   */\n\n  Material.PointListDrawMode = 3;\n  /**\n   * Returns the line list draw mode\n   */\n\n  Material.LineListDrawMode = 4;\n  /**\n   * Returns the line loop draw mode\n   */\n\n  Material.LineLoopDrawMode = 5;\n  /**\n   * Returns the line strip draw mode\n   */\n\n  Material.LineStripDrawMode = 6;\n  /**\n   * Returns the triangle strip draw mode\n   */\n\n  Material.TriangleStripDrawMode = 7;\n  /**\n   * Returns the triangle fan draw mode\n   */\n\n  Material.TriangleFanDrawMode = 8;\n  /**\n   * Stores the clock-wise side orientation\n   */\n\n  Material.ClockWiseSideOrientation = 0;\n  /**\n   * Stores the counter clock-wise side orientation\n   */\n\n  Material.CounterClockWiseSideOrientation = 1;\n  /**\n   * The dirty texture flag value\n   */\n\n  Material.TextureDirtyFlag = 1;\n  /**\n   * The dirty light flag value\n   */\n\n  Material.LightDirtyFlag = 2;\n  /**\n   * The dirty fresnel flag value\n   */\n\n  Material.FresnelDirtyFlag = 4;\n  /**\n   * The dirty attribute flag value\n   */\n\n  Material.AttributesDirtyFlag = 8;\n  /**\n   * The dirty misc flag value\n   */\n\n  Material.MiscDirtyFlag = 16;\n  /**\n   * The dirty prepass flag value\n   */\n\n  Material.PrePassDirtyFlag = 32;\n  /**\n   * The all dirty flag value\n   */\n\n  Material.AllDirtyFlag = 63;\n  /**\n   * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n   */\n\n  Material.MATERIAL_OPAQUE = 0;\n  /**\n   * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n   */\n\n  Material.MATERIAL_ALPHATEST = 1;\n  /**\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n   */\n\n  Material.MATERIAL_ALPHABLEND = 2;\n  /**\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n   * They are also discarded below the alpha cutoff threshold to improve performances.\n   */\n\n  Material.MATERIAL_ALPHATESTANDBLEND = 3;\n  /**\n   * The Whiteout method is used to blend normals.\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\n  /**\n   * The Reoriented Normal Mapping method is used to blend normals.\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;\n  /**\n   * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\n   */\n\n  Material.OnEventObservable = new Observable();\n\n  Material._AllDirtyCallBack = function (defines) {\n    return defines.markAllAsDirty();\n  };\n\n  Material._ImageProcessingDirtyCallBack = function (defines) {\n    return defines.markAsImageProcessingDirty();\n  };\n\n  Material._TextureDirtyCallBack = function (defines) {\n    return defines.markAsTexturesDirty();\n  };\n\n  Material._FresnelDirtyCallBack = function (defines) {\n    return defines.markAsFresnelDirty();\n  };\n\n  Material._MiscDirtyCallBack = function (defines) {\n    return defines.markAsMiscDirty();\n  };\n\n  Material._PrePassDirtyCallBack = function (defines) {\n    return defines.markAsPrePassDirty();\n  };\n\n  Material._LightsDirtyCallBack = function (defines) {\n    return defines.markAsLightDirty();\n  };\n\n  Material._AttributeDirtyCallBack = function (defines) {\n    return defines.markAsAttributesDirty();\n  };\n\n  Material._FresnelAndMiscDirtyCallBack = function (defines) {\n    Material._FresnelDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._TextureAndMiscDirtyCallBack = function (defines) {\n    Material._TextureDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._DirtyCallbackArray = [];\n\n  Material._RunDirtyCallBacks = function (defines) {\n    for (var _i = 0, _a = Material._DirtyCallbackArray; _i < _a.length; _i++) {\n      var cb = _a[_i];\n      cb(defines);\n    }\n  };\n\n  __decorate([serialize()], Material.prototype, \"id\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"name\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"metadata\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"state\", void 0);\n\n  __decorate([serialize(\"alpha\")], Material.prototype, \"_alpha\", void 0);\n\n  __decorate([serialize(\"backFaceCulling\")], Material.prototype, \"_backFaceCulling\", void 0);\n\n  __decorate([serialize(\"cullBackFaces\")], Material.prototype, \"_cullBackFaces\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"sideOrientation\", void 0);\n\n  __decorate([serialize(\"alphaMode\")], Material.prototype, \"_alphaMode\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"_needDepthPrePass\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableColorWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"forceDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"depthFunction\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"separateCullingPass\", void 0);\n\n  __decorate([serialize(\"fogEnabled\")], Material.prototype, \"_fogEnabled\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointSize\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"zOffset\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"zOffsetUnits\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointsCloud\", null);\n\n  __decorate([serialize()], Material.prototype, \"fillMode\", null);\n\n  __decorate([serialize()], Material.prototype, \"transparencyMode\", null);\n\n  return Material;\n}();\n\nexport { Material };","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Tools","Observable","EngineStore","SubMesh","UniformBuffer","Logger","Plane","MaterialHelper","DrawWrapper","MaterialStencilState","MaterialPluginEvent","name","scene","doNotAdd","Material","TriangleFillMode","setScene","LastCreatedScene","_scene","_dirtyCallbacks","_markAllSubMeshesAsTexturesDirty","bind","_markAllSubMeshesAsLightsDirty","_markAllSubMeshesAsFresnelDirty","_markAllSubMeshesAsAttributesDirty","_markAllSubMeshesAsMiscDirty","_markAllSubMeshesAsPrePassDirty","_markAllSubMeshesAsAllDirty","id","RandomId","uniqueId","getUniqueId","_materialContext","getEngine","createMaterialContext","_drawWrapper","materialContext","useRightHandedSystem","sideOrientation","ClockWiseSideOrientation","CounterClockWiseSideOrientation","_uniformBuffer","undefined","_useUBO","getScene","supportsUniformBuffers","addMaterial","useMaterialMeshMap","meshMap","OnEventObservable","notifyObservers","Created","Object","_alpha","value","markAsDirty","MiscDirtyFlag","_backFaceCulling","TextureDirtyFlag","_cullBackFaces","_eventInfo","hasRenderTargetTextures","_callbackPluginEventHasRenderTargetTextures","callback","_onDisposeObserver","onDisposeObservable","remove","add","_onBindObservable","_onBindObserver","onBindObservable","_onUnBindObservable","_onEffectCreatedObservable","_alphaMode","_needDepthPrePass","checkReadyOnEveryCall","_fogEnabled","_fillMode","WireFrameFillMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","forceWireframe","fillMode","PointFillMode","PointListDrawMode","forcePointsCloud","drawWrapper","fullDetails","ret","checkReadyOnlyOnce","markDirty","mesh","useInstances","subMesh","defines","materialDefines","isReadyForSubMesh","_callbackPluginEventIsReadyForSubMesh","effect","_transparencyMode","_forceAlphaTest","MATERIAL_ALPHATESTANDBLEND","_markAllSubMeshesAsTexturesAndMiscDirty","MATERIAL_OPAQUE","MATERIAL_ALPHATEST","_disableAlphaBlending","alpha","visibility","needAlphaBlending","hasVertexAlpha","needAlphaBlendingForMesh","needAlphaTesting","meshes","_i","subMeshes","_a","getMaterial","_wasPreviouslyReady","overrideOrientation","engine","orientation","reverse","enableEffect","_getDrawWrapper","setState","backFaceCulling","zOffset","cullBackFaces","stencil","zOffsetUnits","world","ubo","_callbackPluginEventGeneric","PrepareUniformBuffer","create","_uniformBufferLayoutBuilt","_callbackPluginEventBindForSubMesh","setMatrix","getViewMatrix","_needToBindSceneUbo","getTransformMatrix","getProjectionMatrix","variableName","bindEyePosition","_cachedMaterial","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","_cachedVisibility","disableDepthWrite","_cachedDepthWriteState","getDepthWrite","setDepthWrite","disableColorWrite","_cachedColorWriteState","getColorWrite","setColorWrite","depthFunction","_cachedDepthFunctionState","getDepthFunction","setDepthFunction","animatables","GetAnimatables","activeTextures","GetActiveTextures","texture","hasTexture","HasTexture","result","Array","meshId","push","filter","material","_this","onCompiled","options","onError","localOptions","clipPlane","currentHotSwapingState","allowShaderHotSwapping","checkReady","clipPlaneState","_storeEffectOnSubMeshes","allDone","lastError","tempSubMesh","_renderId","getCompilationError","allFallbacksProcessed","setTimeout","isReady","Promise","resolve","reject","forceCompilation","reason","flag","blockMaterialDirtyMechanism","_DirtyCallbackArray","length","_TextureDirtyCallBack","LightDirtyFlag","_LightsDirtyCallBack","FresnelDirtyFlag","_FresnelDirtyCallBack","AttributesDirtyFlag","_AttributeDirtyCallBack","_MiscDirtyCallBack","PrePassDirtyFlag","_PrePassDirtyCallBack","_markAllSubMeshesAsDirty","_RunDirtyCallBacks","resetCachedMaterial","resetDrawCache","func","_drawWrappers","_c","markAllAsDirty","prePassRenderer","enablePrePassRenderer","_AllDirtyCallBack","_ImageProcessingDirtyCallBack","_FresnelAndMiscDirtyCallBack","_TextureAndMiscDirtyCallBack","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","stopAnimation","freeProcessedMaterials","removeMaterial","Disposed","_parentContainer","index","materials","indexOf","splice","releaseVertexArrayObject","sourceMesh","dispose","metadata","clear","geometry","_releaseVertexArrayObject","serializationObject","Serialize","parsedMaterial","rootUrl","customType","overloadedAlbedo","BABYLON","LegacyPBRMaterial","Error","materialType","Instantiate","Parse","_loadedUniqueId","markAsImageProcessingDirty","markAsTexturesDirty","markAsFresnelDirty","markAsMiscDirty","markAsPrePassDirty","markAsLightDirty","markAsAttributesDirty","cb","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/material.ts"],"sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\n\r\ndeclare type PrePassRenderer = import(\"../Rendering/prePassRenderer\").PrePassRenderer;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type InstancedMesh = import(\"../Meshes/instancedMesh\").InstancedMesh;\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @hidden */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n        this._alpha = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: number;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    /**\r\n     * @hidden\r\n     * Stores the effects for the material\r\n     */\r\n    protected _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @hidden */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @param drawWrapper\r\n     * @hidden\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @hidden\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @hidden */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @hidden */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /** @hidden */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @hidden */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @hidden */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @hidden */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        if (this._scene.useRightHandedSystem) {\r\n            this.sideOrientation = Material.ClockWiseSideOrientation;\r\n        } else {\r\n            this.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n        }\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    protected _forceAlphaTest = false;\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._disableAlphaBlending && mesh.visibility >= 1.0) {\r\n            return false;\r\n        }\r\n\r\n        return this.needAlphaBlending() || mesh.visibility < 1.0 || mesh.hasVertexAlpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     */\r\n    protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean {\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     */\r\n    public markDirty(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.effect) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.effect._wasPreviouslyReady = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param effect\r\n     * @param overrideOrientation\r\n     * @hidden\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this.cullBackFaces, this.stencil, this.zOffsetUnits);\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect\r\n     */\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result = new Array<AbstractMesh>();\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                if (mesh._renderId === 0 || subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    if (mesh) {\r\n                        mesh.material = null; // will set the entry in the map to undefined\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n                        mesh.material = null;\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (forceDisposeEffect && this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param mesh\r\n     * @param forceDisposeEffect\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private releaseVertexArrayObject(mesh: AbstractMesh, forceDisposeEffect?: boolean) {\r\n        if ((<Mesh>mesh).geometry) {\r\n            const geometry = <Geometry>(<Mesh>mesh).geometry;\r\n            if (this._storeEffectOnSubMeshes) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    geometry._releaseVertexArrayObject(subMesh.effect);\r\n                    if (forceDisposeEffect && subMesh.effect) {\r\n                        subMesh.effect.dispose();\r\n                    }\r\n                }\r\n            } else {\r\n                geometry._releaseVertexArrayObject(this._drawWrapper.effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n        return material;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}