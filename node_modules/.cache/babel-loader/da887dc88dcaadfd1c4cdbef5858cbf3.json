{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.join.js\";\n\nvar _a;\n\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * A list of the currently available features without referencing them\n */\n\nvar WebXRFeatureName =\n/** @class */\nfunction () {\n  function WebXRFeatureName() {}\n  /**\n   * The name of the anchor system feature\n   */\n\n\n  WebXRFeatureName.ANCHOR_SYSTEM = \"xr-anchor-system\";\n  /**\n   * The name of the background remover feature\n   */\n\n  WebXRFeatureName.BACKGROUND_REMOVER = \"xr-background-remover\";\n  /**\n   * The name of the hit test feature\n   */\n\n  WebXRFeatureName.HIT_TEST = \"xr-hit-test\";\n  /**\n   * The name of the mesh detection feature\n   */\n\n  WebXRFeatureName.MESH_DETECTION = \"xr-mesh-detection\";\n  /**\n   * physics impostors for xr controllers feature\n   */\n\n  WebXRFeatureName.PHYSICS_CONTROLLERS = \"xr-physics-controller\";\n  /**\n   * The name of the plane detection feature\n   */\n\n  WebXRFeatureName.PLANE_DETECTION = \"xr-plane-detection\";\n  /**\n   * The name of the pointer selection feature\n   */\n\n  WebXRFeatureName.POINTER_SELECTION = \"xr-controller-pointer-selection\";\n  /**\n   * The name of the teleportation feature\n   */\n\n  WebXRFeatureName.TELEPORTATION = \"xr-controller-teleportation\";\n  /**\n   * The name of the feature points feature.\n   */\n\n  WebXRFeatureName.FEATURE_POINTS = \"xr-feature-points\";\n  /**\n   * The name of the hand tracking feature.\n   */\n\n  WebXRFeatureName.HAND_TRACKING = \"xr-hand-tracking\";\n  /**\n   * The name of the image tracking feature\n   */\n\n  WebXRFeatureName.IMAGE_TRACKING = \"xr-image-tracking\";\n  /**\n   * The name of the near interaction feature\n   */\n\n  WebXRFeatureName.NEAR_INTERACTION = \"xr-near-interaction\";\n  /**\n   * The name of the DOM overlay feature\n   */\n\n  WebXRFeatureName.DOM_OVERLAY = \"xr-dom-overlay\";\n  /**\n   * The name of the movement feature\n   */\n\n  WebXRFeatureName.MOVEMENT = \"xr-controller-movement\";\n  /**\n   * The name of the light estimation feature\n   */\n\n  WebXRFeatureName.LIGHT_ESTIMATION = \"xr-light-estimation\";\n  /**\n   * The name of the eye tracking feature\n   */\n\n  WebXRFeatureName.EYE_TRACKING = \"xr-eye-tracking\";\n  /**\n   * The name of the walking locomotion feature\n   */\n\n  WebXRFeatureName.WALKING_LOCOMOTION = \"xr-walking-locomotion\";\n  /**\n   * The name of the composition layers feature\n   */\n\n  WebXRFeatureName.LAYERS = \"xr-layers\";\n  return WebXRFeatureName;\n}();\n\nexport { WebXRFeatureName };\n/**\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\n * It is mainly used in AR sessions.\n *\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\n */\n\nvar WebXRFeaturesManager =\n/** @class */\nfunction () {\n  /**\n   * constructs a new features manages.\n   *\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   */\n  function WebXRFeaturesManager(_xrSessionManager) {\n    var _this = this;\n\n    this._xrSessionManager = _xrSessionManager;\n    this._features = {}; // when session starts / initialized - attach\n\n    this._xrSessionManager.onXRSessionInit.add(function () {\n      _this.getEnabledFeatures().forEach(function (featureName) {\n        var feature = _this._features[featureName];\n\n        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\n          _this.attachFeature(featureName);\n        }\n      });\n    }); // when session ends - detach\n\n\n    this._xrSessionManager.onXRSessionEnded.add(function () {\n      _this.getEnabledFeatures().forEach(function (featureName) {\n        var feature = _this._features[featureName];\n\n        if (feature.enabled && feature.featureImplementation.attached) {\n          // detach, but don't disable!\n          _this.detachFeature(featureName);\n        }\n      });\n    });\n  }\n  /**\n   * Used to register a module. After calling this function a developer can use this feature in the scene.\n   * Mainly used internally.\n   *\n   * @param featureName the name of the feature to register\n   * @param constructorFunction the function used to construct the module\n   * @param version the (babylon) version of the module\n   * @param stable is that a stable version of this module\n   */\n\n\n  WebXRFeaturesManager.AddWebXRFeature = function (featureName, constructorFunction, version, stable) {\n    if (version === void 0) {\n      version = 1;\n    }\n\n    if (stable === void 0) {\n      stable = false;\n    }\n\n    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || {\n      latest: version\n    };\n\n    if (version > this._AvailableFeatures[featureName].latest) {\n      this._AvailableFeatures[featureName].latest = version;\n    }\n\n    if (stable) {\n      this._AvailableFeatures[featureName].stable = version;\n    }\n\n    this._AvailableFeatures[featureName][version] = constructorFunction;\n  };\n  /**\n   * Returns a constructor of a specific feature.\n   *\n   * @param featureName the name of the feature to construct\n   * @param version the version of the feature to load\n   * @param xrSessionManager the xrSessionManager. Used to construct the module\n   * @param options optional options provided to the module.\n   * @returns a function that, when called, will return a new instance of this feature\n   */\n\n\n  WebXRFeaturesManager.ConstructFeature = function (featureName, version, xrSessionManager, options) {\n    if (version === void 0) {\n      version = 1;\n    }\n\n    var constructorFunction = this._AvailableFeatures[featureName][version];\n\n    if (!constructorFunction) {\n      // throw an error? return nothing?\n      throw new Error(\"feature not found\");\n    }\n\n    return constructorFunction(xrSessionManager, options);\n  };\n  /**\n   * Can be used to return the list of features currently registered\n   *\n   * @returns an Array of available features\n   */\n\n\n  WebXRFeaturesManager.GetAvailableFeatures = function () {\n    return Object.keys(this._AvailableFeatures);\n  };\n  /**\n   * Gets the versions available for a specific feature\n   * @param featureName the name of the feature\n   * @returns an array with the available versions\n   */\n\n\n  WebXRFeaturesManager.GetAvailableVersions = function (featureName) {\n    return Object.keys(this._AvailableFeatures[featureName]);\n  };\n  /**\n   * Return the latest unstable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n\n\n  WebXRFeaturesManager.GetLatestVersionOfFeature = function (featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;\n  };\n  /**\n   * Return the latest stable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n\n\n  WebXRFeaturesManager.GetStableVersionOfFeature = function (featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;\n  };\n  /**\n   * Attach a feature to the current session. Mainly used when session started to start the feature effect.\n   * Can be used during a session to start a feature\n   * @param featureName the name of feature to attach\n   */\n\n\n  WebXRFeaturesManager.prototype.attachFeature = function (featureName) {\n    var feature = this._features[featureName];\n\n    if (feature && feature.enabled && !feature.featureImplementation.attached) {\n      feature.featureImplementation.attach();\n    }\n  };\n  /**\n   * Can be used inside a session or when the session ends to detach a specific feature\n   * @param featureName the name of the feature to detach\n   */\n\n\n  WebXRFeaturesManager.prototype.detachFeature = function (featureName) {\n    var feature = this._features[featureName];\n\n    if (feature && feature.featureImplementation.attached) {\n      feature.featureImplementation.detach();\n    }\n  };\n  /**\n   * Used to disable an already-enabled feature\n   * The feature will be disposed and will be recreated once enabled.\n   * @param featureName the feature to disable\n   * @returns true if disable was successful\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  WebXRFeaturesManager.prototype.disableFeature = function (featureName) {\n    var name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    var feature = this._features[name];\n\n    if (feature && feature.enabled) {\n      feature.enabled = false;\n      this.detachFeature(name);\n      feature.featureImplementation.dispose();\n      delete this._features[name];\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * dispose this features manager\n   */\n\n\n  WebXRFeaturesManager.prototype.dispose = function () {\n    var _this = this;\n\n    this.getEnabledFeatures().forEach(function (feature) {\n      _this.disableFeature(feature);\n    });\n  };\n  /**\n   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\n   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\n   *\n   * @param featureName the name of the feature to load or the class of the feature\n   * @param version optional version to load. if not provided the latest version will be enabled\n   * @param moduleOptions options provided to the module. Ses the module documentation / constructor\n   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\n   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\n   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\n   */\n\n\n  WebXRFeaturesManager.prototype.enableFeature = function ( // eslint-disable-next-line @typescript-eslint/naming-convention\n  featureName, version, moduleOptions, attachIfPossible, required) {\n    var _this = this;\n\n    if (version === void 0) {\n      version = \"latest\";\n    }\n\n    if (moduleOptions === void 0) {\n      moduleOptions = {};\n    }\n\n    if (attachIfPossible === void 0) {\n      attachIfPossible = true;\n    }\n\n    if (required === void 0) {\n      required = true;\n    }\n\n    var name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    var versionToLoad = 0;\n\n    if (typeof version === \"string\") {\n      if (!version) {\n        throw new Error(\"Error in provided version - \".concat(name, \" (\").concat(version, \")\"));\n      }\n\n      if (version === \"stable\") {\n        versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\n      } else if (version === \"latest\") {\n        versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\n      } else {\n        // try loading the number the string represents\n        versionToLoad = +version;\n      }\n\n      if (versionToLoad === -1 || isNaN(versionToLoad)) {\n        throw new Error(\"feature not found - \".concat(name, \" (\").concat(version, \")\"));\n      }\n    } else {\n      versionToLoad = version;\n    } // check if there is a feature conflict\n\n\n    var conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\n\n    if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\n      throw new Error(\"Feature \".concat(name, \" cannot be enabled while \").concat(conflictingFeature, \" is enabled.\"));\n    } // check if already initialized\n\n\n    var feature = this._features[name];\n    var constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\n\n    if (!constructFunction) {\n      // report error?\n      throw new Error(\"feature not found - \".concat(name));\n    }\n    /* If the feature is already enabled, detach and dispose it, and create a new one */\n\n\n    if (feature) {\n      this.disableFeature(name);\n    }\n\n    var constructed = constructFunction();\n\n    if (constructed.dependsOn) {\n      var dependentsFound = constructed.dependsOn.every(function (featureName) {\n        return !!_this._features[featureName];\n      });\n\n      if (!dependentsFound) {\n        throw new Error(\"Dependant features missing. Make sure the following features are enabled - \".concat(constructed.dependsOn.join(\", \")));\n      }\n    }\n\n    if (constructed.isCompatible()) {\n      this._features[name] = {\n        featureImplementation: constructed,\n        enabled: true,\n        version: versionToLoad,\n        required: required\n      };\n\n      if (attachIfPossible) {\n        // if session started already, request and enable\n        if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\n          // enable feature\n          this.attachFeature(name);\n        }\n      } else {\n        // disable auto-attach when session starts\n        this._features[name].featureImplementation.disableAutoAttach = true;\n      }\n\n      return this._features[name].featureImplementation;\n    } else {\n      if (required) {\n        throw new Error(\"required feature not compatible\");\n      } else {\n        Tools.Warn(\"Feature \".concat(name, \" not compatible with the current environment/browser and was not enabled.\"));\n        return constructed;\n      }\n    }\n  };\n  /**\n   * get the implementation of an enabled feature.\n   * @param featureName the name of the feature to load\n   * @returns the feature class, if found\n   */\n\n\n  WebXRFeaturesManager.prototype.getEnabledFeature = function (featureName) {\n    return this._features[featureName] && this._features[featureName].featureImplementation;\n  };\n  /**\n   * Get the list of enabled features\n   * @returns an array of enabled features\n   */\n\n\n  WebXRFeaturesManager.prototype.getEnabledFeatures = function () {\n    return Object.keys(this._features);\n  };\n  /**\n   * This function will extend the session creation configuration object with enabled features.\n   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\n   * according to the defined \"required\" variable, provided during enableFeature call\n   * @param xrSessionInit the xr Session init object to extend\n   *\n   * @returns an extended XRSessionInit object\n   */\n\n\n  WebXRFeaturesManager.prototype._extendXRSessionInitObject = function (xrSessionInit) {\n    return __awaiter(this, void 0, void 0, function () {\n      var enabledFeatures, _i, enabledFeatures_1, featureName, feature, nativeName, extended;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            enabledFeatures = this.getEnabledFeatures();\n            _i = 0, enabledFeatures_1 = enabledFeatures;\n            _a.label = 1;\n\n          case 1:\n            if (!(_i < enabledFeatures_1.length)) return [3\n            /*break*/\n            , 4];\n            featureName = enabledFeatures_1[_i];\n            feature = this._features[featureName];\n            nativeName = feature.featureImplementation.xrNativeFeatureName;\n\n            if (nativeName) {\n              if (feature.required) {\n                xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\n\n                if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\n                  xrSessionInit.requiredFeatures.push(nativeName);\n                }\n              } else {\n                xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\n\n                if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\n                  xrSessionInit.optionalFeatures.push(nativeName);\n                }\n              }\n            }\n\n            if (!feature.featureImplementation.getXRSessionInitExtension) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , feature.featureImplementation.getXRSessionInitExtension()];\n\n          case 2:\n            extended = _a.sent();\n            xrSessionInit = __assign(__assign({}, xrSessionInit), extended);\n            _a.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , xrSessionInit];\n        }\n      });\n    });\n  };\n\n  WebXRFeaturesManager._AvailableFeatures = {};\n  /**\n   * The key is the feature to check and the value is the feature that conflicts.\n   */\n\n  WebXRFeaturesManager._ConflictingFeatures = (_a = {}, _a[WebXRFeatureName.TELEPORTATION] = WebXRFeatureName.MOVEMENT, _a[WebXRFeatureName.MOVEMENT] = WebXRFeatureName.TELEPORTATION, _a);\n  return WebXRFeaturesManager;\n}();\n\nexport { WebXRFeaturesManager };","map":{"version":3,"mappings":"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","names":["Tools","WebXRFeatureName","_xrSessionManager","onXRSessionInit","add","_this","getEnabledFeatures","forEach","featureName","feature","_features","enabled","featureImplementation","attached","disableAutoAttach","attachFeature","onXRSessionEnded","detachFeature","WebXRFeaturesManager","constructorFunction","version","stable","_AvailableFeatures","latest","xrSessionManager","options","Error","Object","keys","attach","detach","name","Name","dispose","disableFeature","moduleOptions","attachIfPossible","required","versionToLoad","concat","GetStableVersionOfFeature","GetLatestVersionOfFeature","isNaN","conflictingFeature","_ConflictingFeatures","undefined","indexOf","constructFunction","ConstructFeature","constructed","dependsOn","dependentsFound","every","join","isCompatible","session","Warn","xrSessionInit","enabledFeatures","enabledFeatures_1","_i","nativeName","xrNativeFeatureName","requiredFeatures","push","optionalFeatures","getXRSessionInitExtension","extended","_a","TELEPORTATION","MOVEMENT"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRFeaturesManager.ts"],"sourcesContent":["import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}