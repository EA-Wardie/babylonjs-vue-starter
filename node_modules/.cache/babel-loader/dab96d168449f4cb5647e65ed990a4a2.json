{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n  get: function get() {\n    return this._forceShowBoundingBoxes || false;\n  },\n  set: function set(value) {\n    this._forceShowBoundingBoxes = value; // Lazyly creates a BB renderer if needed.\n\n    if (value) {\n      this.getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.getBoundingBoxRenderer = function () {\n  if (!this._boundingBoxRenderer) {\n    this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n  }\n\n  return this._boundingBoxRenderer;\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n  get: function get() {\n    return this._showBoundingBox || false;\n  },\n  set: function set(value) {\n    this._showBoundingBox = value; // Lazyly creates a BB renderer if needed.\n\n    if (value) {\n      this.getScene().getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\n\nvar BoundingBoxRenderer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new bounding box renderer in a scene.\n   * @param scene the scene the  renderer renders in\n   */\n  function BoundingBoxRenderer(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n    /**\n     * Color of the bounding box lines placed in front of an object\n     */\n\n    this.frontColor = new Color3(1, 1, 1);\n    /**\n     * Color of the bounding box lines placed behind an object\n     */\n\n    this.backColor = new Color3(0.1, 0.1, 0.1);\n    /**\n     * Defines if the renderer should show the back lines or not\n     */\n\n    this.showBackLines = true;\n    /**\n     * Observable raised before rendering a bounding box\n     */\n\n    this.onBeforeBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after rendering a bounding box\n     */\n\n    this.onAfterBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after resources are created\n     */\n\n    this.onResourcesReadyObservable = new Observable();\n    /**\n     * When false, no bounding boxes will be rendered\n     */\n\n    this.enabled = true;\n    /**\n     * @hidden\n     */\n\n    this.renderList = new SmartArray(32);\n    this._vertexBuffers = {};\n    this._fillIndexBuffer = null;\n    this._fillIndexData = null;\n    this.scene = scene;\n\n    scene._addComponent(this);\n\n    this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n\n    this._buildUniformLayout(this._uniformBufferFront);\n\n    this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n\n    this._buildUniformLayout(this._uniformBufferBack);\n  }\n\n  BoundingBoxRenderer.prototype._buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"color\", 4);\n    ubo.addUniform(\"world\", 16);\n    ubo.addUniform(\"viewProjection\", 16);\n    ubo.addUniform(\"viewProjectionR\", 16);\n    ubo.create();\n  };\n  /**\n   * Registers the component in a given scene\n   */\n\n\n  BoundingBoxRenderer.prototype.register = function () {\n    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n\n    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n\n    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n  };\n\n  BoundingBoxRenderer.prototype._evaluateSubMesh = function (mesh, subMesh) {\n    if (mesh.showSubMeshesBoundingBox) {\n      var boundingInfo = subMesh.getBoundingInfo();\n\n      if (boundingInfo !== null && boundingInfo !== undefined) {\n        boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n        this.renderList.push(boundingInfo.boundingBox);\n      }\n    }\n  };\n\n  BoundingBoxRenderer.prototype._preActiveMesh = function (mesh) {\n    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n      var boundingInfo = mesh.getBoundingInfo();\n      boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n      this.renderList.push(boundingInfo.boundingBox);\n    }\n  };\n\n  BoundingBoxRenderer.prototype._prepareResources = function () {\n    if (this._colorShader) {\n      return;\n    }\n\n    this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, false);\n    this._colorShader.reservedDataStore = {\n      hidden: true\n    };\n    this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, true);\n    this._colorShaderForOcclusionQuery.reservedDataStore = {\n      hidden: true\n    };\n    var engine = this.scene.getEngine();\n    var boxdata = CreateBoxVertexData({\n      size: 1.0\n    });\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n\n    this._createIndexBuffer();\n\n    this._fillIndexData = boxdata.indices;\n    this.onResourcesReadyObservable.notifyObservers(this);\n  };\n\n  BoundingBoxRenderer.prototype._createIndexBuffer = function () {\n    var engine = this.scene.getEngine();\n    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n  };\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n\n\n  BoundingBoxRenderer.prototype.rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n  };\n  /**\n   * @hidden\n   */\n\n\n  BoundingBoxRenderer.prototype.reset = function () {\n    this.renderList.reset();\n  };\n  /**\n   * Render the bounding boxes of a specific rendering group\n   * @param renderingGroupId defines the rendering group to render\n   */\n\n\n  BoundingBoxRenderer.prototype.render = function (renderingGroupId) {\n    var _a, _b;\n\n    if (this.renderList.length === 0 || !this.enabled) {\n      return;\n    }\n\n    this._prepareResources();\n\n    if (!this._colorShader.isReady()) {\n      return;\n    }\n\n    var engine = this.scene.getEngine();\n    engine.setDepthWrite(false);\n    var frontColor = this.frontColor.toColor4();\n    var backColor = this.backColor.toColor4();\n    var transformMatrix = this.scene.getTransformMatrix();\n\n    for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n      var boundingBox = this.renderList.data[boundingBoxIndex];\n\n      if (boundingBox._tag !== renderingGroupId) {\n        continue;\n      }\n\n      this._createWrappersForBoundingBox(boundingBox);\n\n      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n      var min = boundingBox.minimum;\n      var max = boundingBox.maximum;\n      var diff = max.subtract(min);\n      var median = min.add(diff.scale(0.5));\n      var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n      var useReverseDepthBuffer = engine.useReverseDepthBuffer;\n\n      if (this.showBackLines) {\n        var drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();\n\n        this._colorShader._preBind(drawWrapperBack);\n\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect()); // Back\n\n        if (useReverseDepthBuffer) {\n          engine.setDepthFunctionToLessOrEqual();\n        } else {\n          engine.setDepthFunctionToGreaterOrEqual();\n        }\n\n        this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n\n        this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\n\n        this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n\n        this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n\n        this._uniformBufferBack.update(); // Draw order\n\n\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      }\n\n      var drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();\n\n      this._colorShader._preBind(drawWrapperFront);\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect()); // Front\n\n      if (useReverseDepthBuffer) {\n        engine.setDepthFunctionToGreater();\n      } else {\n        engine.setDepthFunctionToLess();\n      }\n\n      this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n\n      this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\n\n      this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n\n      this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n\n      this._uniformBufferFront.update(); // Draw order\n\n\n      engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n    }\n\n    this._colorShader.unbind();\n\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n  };\n\n  BoundingBoxRenderer.prototype._createWrappersForBoundingBox = function (boundingBox) {\n    if (!boundingBox._drawWrapperFront) {\n      var engine = this.scene.getEngine();\n      boundingBox._drawWrapperFront = new DrawWrapper(engine);\n      boundingBox._drawWrapperBack = new DrawWrapper(engine);\n\n      boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n\n      boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n    }\n  };\n  /**\n   * In case of occlusion queries, we can render the occlusion bounding box through this method\n   * @param mesh Define the mesh to render the occlusion bounding box for\n   */\n\n\n  BoundingBoxRenderer.prototype.renderOcclusionBoundingBox = function (mesh) {\n    var engine = this.scene.getEngine();\n\n    if (this._renderPassIdForOcclusionQuery === undefined) {\n      this._renderPassIdForOcclusionQuery = engine.createRenderPassId(\"Render pass for occlusion query\");\n    }\n\n    var currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n\n    this._prepareResources();\n\n    var subMesh = mesh.subMeshes[0];\n\n    if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n      engine.currentRenderPassId = currentRenderPassId;\n      return;\n    }\n\n    if (!this._fillIndexBuffer) {\n      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n    }\n\n    var useReverseDepthBuffer = engine.useReverseDepthBuffer;\n    engine.setDepthWrite(false);\n    engine.setColorWrite(false);\n    var boundingBox = mesh.getBoundingInfo().boundingBox;\n    var min = boundingBox.minimum;\n    var max = boundingBox.maximum;\n    var diff = max.subtract(min);\n    var median = min.add(diff.scale(0.5));\n    var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n    var drawWrapper = subMesh._drawWrapper;\n\n    this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n\n    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n\n    if (useReverseDepthBuffer) {\n      engine.setDepthFunctionToGreater();\n    } else {\n      engine.setDepthFunctionToLess();\n    }\n\n    this.scene.resetCachedMaterial();\n\n    this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n\n    this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n\n    this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n\n    this._uniformBufferFront.update();\n\n    engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n\n    this._colorShaderForOcclusionQuery.unbind();\n\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n    engine.setColorWrite(true);\n    engine.currentRenderPassId = currentRenderPassId;\n  };\n  /**\n   * Dispose and release the resources attached to this renderer.\n   */\n\n\n  BoundingBoxRenderer.prototype.dispose = function () {\n    if (this._renderPassIdForOcclusionQuery !== undefined) {\n      this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n      this._renderPassIdForOcclusionQuery = undefined;\n    }\n\n    if (!this._colorShader) {\n      return;\n    }\n\n    this.onBeforeBoxRenderingObservable.clear();\n    this.onAfterBoxRenderingObservable.clear();\n    this.onResourcesReadyObservable.clear();\n    this.renderList.dispose();\n\n    this._colorShader.dispose();\n\n    this._colorShaderForOcclusionQuery.dispose();\n\n    this._uniformBufferFront.dispose();\n\n    this._uniformBufferBack.dispose();\n\n    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n    if (this._fillIndexBuffer) {\n      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n\n      this._fillIndexBuffer = null;\n    }\n  };\n\n  return BoundingBoxRenderer;\n}();\n\nexport { BoundingBoxRenderer };","map":{"version":3,"mappings":"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","names":["Scene","VertexBuffer","AbstractMesh","Matrix","SmartArray","SceneComponentConstants","Material","ShaderMaterial","Color3","Observable","DrawWrapper","UniformBuffer","CreateBoxVertexData","Object","defineProperty","prototype","get","_forceShowBoundingBoxes","set","value","getBoundingBoxRenderer","enumerable","configurable","_boundingBoxRenderer","BoundingBoxRenderer","_showBoundingBox","getScene","scene","NAME_BOUNDINGBOXRENDERER","_addComponent","_uniformBufferFront","getEngine","undefined","isWebGPU","_buildUniformLayout","_uniformBufferBack","ubo","addUniform","create","_beforeEvaluateActiveMeshStage","registerStep","STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER","reset","_preActiveMeshStage","STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER","_preActiveMesh","_evaluateSubMeshStage","STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER","_evaluateSubMesh","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER","render","mesh","subMesh","showSubMeshesBoundingBox","boundingInfo","getBoundingInfo","boundingBox","_tag","renderingGroupId","renderList","push","showBoundingBox","forceShowBoundingBoxes","_colorShader","attributes","PositionKind","uniforms","uniformBuffers","reservedDataStore","hidden","_colorShaderForOcclusionQuery","engine","boxdata","size","_vertexBuffers","positions","_createIndexBuffer","_fillIndexData","indices","onResourcesReadyObservable","notifyObservers","_indexBuffer","createIndexBuffer","vb","_rebuild","length","enabled","_prepareResources","isReady","setDepthWrite","frontColor","toColor4","backColor","transformMatrix","getTransformMatrix","boundingBoxIndex","data","_createWrappersForBoundingBox","onBeforeBoxRenderingObservable","min","minimum","max","maximum","diff","subtract","median","add","scale","worldMatrix","Scaling","x","y","z","multiply","Translation","getWorldMatrix","useReverseDepthBuffer","showBackLines","drawWrapperBack","_drawWrapperBack","_a","_getDrawWrapper","_preBind","bindBuffers","getEffect","setDepthFunctionToLessOrEqual","setDepthFunctionToGreaterOrEqual","bindToEffect","effect","updateDirectColor4","updateMatrix","update","drawElementsType","LineListDrawMode","drawWrapperFront","_drawWrapperFront","_b","setDepthFunctionToGreater","setDepthFunctionToLess","onAfterBoxRenderingObservable","unbind","setEffect","_renderPassIdForOcclusionQuery","createRenderPassId","currentRenderPassId","subMeshes","hasBoundingInfo","_fillIndexBuffer","setColorWrite","drawWrapper","_drawWrapper","resetCachedMaterial","TriangleFillMode","releaseRenderPassId","clear","dispose","buffer","_releaseBuffer"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/boundingBoxRenderer.ts"],"sourcesContent":["import { Scene } from \"../scene\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { BoundingBox } from \"../Culling/boundingBox\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder\";\r\n\r\nimport \"../Shaders/boundingBoxRenderer.fragment\";\r\nimport \"../Shaders/boundingBoxRenderer.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden (Backing field) */\r\n        _boundingBoxRenderer: BoundingBoxRenderer;\r\n\r\n        /** @hidden (Backing field) */\r\n        _forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if all bounding boxes must be rendered\r\n         */\r\n        forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets the bounding box renderer associated with the scene\r\n         * @returns a BoundingBoxRenderer\r\n         */\r\n        getBoundingBoxRenderer(): BoundingBoxRenderer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\r\n    get: function (this: Scene) {\r\n        return this._forceShowBoundingBoxes || false;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        this._forceShowBoundingBoxes = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getBoundingBoxRenderer = function (): BoundingBoxRenderer {\r\n    if (!this._boundingBoxRenderer) {\r\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\r\n    }\r\n\r\n    return this._boundingBoxRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden (Backing field) */\r\n        _showBoundingBox: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)\r\n         */\r\n        showBoundingBox: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._showBoundingBox || false;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._showBoundingBox = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getScene().getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Component responsible of rendering the bounding box of the meshes in a scene.\r\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\r\n */\r\nexport class BoundingBoxRenderer implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Color of the bounding box lines placed in front of an object\r\n     */\r\n    public frontColor = new Color3(1, 1, 1);\r\n    /**\r\n     * Color of the bounding box lines placed behind an object\r\n     */\r\n    public backColor = new Color3(0.1, 0.1, 0.1);\r\n    /**\r\n     * Defines if the renderer should show the back lines or not\r\n     */\r\n    public showBackLines = true;\r\n\r\n    /**\r\n     * Observable raised before rendering a bounding box\r\n     */\r\n    public onBeforeBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after rendering a bounding box\r\n     */\r\n    public onAfterBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after resources are created\r\n     */\r\n    public onResourcesReadyObservable = new Observable<BoundingBoxRenderer>();\r\n\r\n    /**\r\n     * When false, no bounding boxes will be rendered\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public renderList = new SmartArray<BoundingBox>(32);\r\n\r\n    private _colorShader: ShaderMaterial;\r\n    private _colorShaderForOcclusionQuery: ShaderMaterial;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: DataBuffer;\r\n    private _fillIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _fillIndexData: Nullable<IndicesArray> = null;\r\n    private _uniformBufferFront: UniformBuffer;\r\n    private _uniformBufferBack: UniformBuffer;\r\n    private _renderPassIdForOcclusionQuery: number;\r\n\r\n    /**\r\n     * Instantiates a new bounding box renderer in a scene.\r\n     * @param scene the scene the  renderer renders in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        scene._addComponent(this);\r\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferFront);\r\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferBack);\r\n    }\r\n\r\n    private _buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"color\", 4);\r\n        ubo.addUniform(\"world\", 16);\r\n        ubo.addUniform(\"viewProjection\", 16);\r\n        ubo.addUniform(\"viewProjectionR\", 16);\r\n        ubo.create();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\r\n\r\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\r\n\r\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\r\n    }\r\n\r\n    private _evaluateSubMesh(mesh: AbstractMesh, subMesh: SubMesh): void {\r\n        if (mesh.showSubMeshesBoundingBox) {\r\n            const boundingInfo = subMesh.getBoundingInfo();\r\n            if (boundingInfo !== null && boundingInfo !== undefined) {\r\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n                this.renderList.push(boundingInfo.boundingBox);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _preActiveMesh(mesh: AbstractMesh): void {\r\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n            this.renderList.push(boundingInfo.boundingBox);\r\n        }\r\n    }\r\n\r\n    private _prepareResources(): void {\r\n        if (this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\r\n            \"colorShader\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            false\r\n        );\r\n\r\n        this._colorShader.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\r\n            \"colorShaderOccQuery\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            true\r\n        );\r\n\r\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const engine = this.scene.getEngine();\r\n        const boxdata = CreateBoxVertexData({ size: 1.0 });\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, <FloatArray>boxdata.positions, VertexBuffer.PositionKind, false);\r\n        this._createIndexBuffer();\r\n        this._fillIndexData = boxdata.indices;\r\n        this.onResourcesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this.scene.getEngine();\r\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public reset(): void {\r\n        this.renderList.reset();\r\n    }\r\n\r\n    /**\r\n     * Render the bounding boxes of a specific rendering group\r\n     * @param renderingGroupId defines the rendering group to render\r\n     */\r\n    public render(renderingGroupId: number): void {\r\n        if (this.renderList.length === 0 || !this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this._prepareResources();\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.scene.getEngine();\r\n        engine.setDepthWrite(false);\r\n\r\n        const frontColor = this.frontColor.toColor4();\r\n        const backColor = this.backColor.toColor4();\r\n        const transformMatrix = this.scene.getTransformMatrix();\r\n\r\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\r\n            const boundingBox = this.renderList.data[boundingBoxIndex];\r\n            if (boundingBox._tag !== renderingGroupId) {\r\n                continue;\r\n            }\r\n\r\n            this._createWrappersForBoundingBox(boundingBox);\r\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\r\n\r\n            const min = boundingBox.minimum;\r\n            const max = boundingBox.maximum;\r\n            const diff = max.subtract(min);\r\n            const median = min.add(diff.scale(0.5));\r\n\r\n            const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n            const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n            if (this.showBackLines) {\r\n                const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();\r\n\r\n                this._colorShader._preBind(drawWrapperBack);\r\n\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n                // Back\r\n                if (useReverseDepthBuffer) {\r\n                    engine.setDepthFunctionToLessOrEqual();\r\n                } else {\r\n                    engine.setDepthFunctionToGreaterOrEqual();\r\n                }\r\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect!, \"BoundingBoxRenderer\");\r\n                this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\r\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\r\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\r\n                this._uniformBufferBack.update();\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n            }\r\n\r\n            const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();\r\n\r\n            this._colorShader._preBind(drawWrapperFront);\r\n\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n            // Front\r\n            if (useReverseDepthBuffer) {\r\n                engine.setDepthFunctionToGreater();\r\n            } else {\r\n                engine.setDepthFunctionToLess();\r\n            }\r\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect!, \"BoundingBoxRenderer\");\r\n            this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\r\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\r\n            this._uniformBufferFront.update();\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n\r\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\r\n        }\r\n        this._colorShader.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    private _createWrappersForBoundingBox(boundingBox: BoundingBox): void {\r\n        if (!boundingBox._drawWrapperFront) {\r\n            const engine = this.scene.getEngine();\r\n\r\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\r\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\r\n\r\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\r\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\r\n     * @param mesh Define the mesh to render the occlusion bounding box for\r\n     */\r\n    public renderOcclusionBoundingBox(mesh: AbstractMesh): void {\r\n        const engine = this.scene.getEngine();\r\n\r\n        if (this._renderPassIdForOcclusionQuery === undefined) {\r\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\r\n        }\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\r\n\r\n        this._prepareResources();\r\n\r\n        const subMesh = mesh.subMeshes[0];\r\n\r\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\r\n            engine.currentRenderPassId = currentRenderPassId;\r\n            return;\r\n        }\r\n\r\n        if (!this._fillIndexBuffer) {\r\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData!);\r\n        }\r\n\r\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n        engine.setDepthWrite(false);\r\n        engine.setColorWrite(false);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        const min = boundingBox.minimum;\r\n        const max = boundingBox.maximum;\r\n        const diff = max.subtract(min);\r\n        const median = min.add(diff.scale(0.5));\r\n\r\n        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\r\n\r\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, <Effect>drawWrapper.effect);\r\n\r\n        if (useReverseDepthBuffer) {\r\n            engine.setDepthFunctionToGreater();\r\n        } else {\r\n            engine.setDepthFunctionToLess();\r\n        }\r\n\r\n        this.scene.resetCachedMaterial();\r\n\r\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect!, \"BoundingBoxRenderer\");\r\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\r\n        this._uniformBufferFront.update();\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\r\n\r\n        this._colorShaderForOcclusionQuery.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n        engine.setColorWrite(true);\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the resources attached to this renderer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\r\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\r\n            this._renderPassIdForOcclusionQuery = undefined as any;\r\n        }\r\n\r\n        if (!this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeBoxRenderingObservable.clear();\r\n        this.onAfterBoxRenderingObservable.clear();\r\n        this.onResourcesReadyObservable.clear();\r\n\r\n        this.renderList.dispose();\r\n\r\n        this._colorShader.dispose();\r\n        this._colorShaderForOcclusionQuery.dispose();\r\n\r\n        this._uniformBufferFront.dispose();\r\n        this._uniformBufferBack.dispose();\r\n\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n\r\n        if (this._fillIndexBuffer) {\r\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\r\n            this._fillIndexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}