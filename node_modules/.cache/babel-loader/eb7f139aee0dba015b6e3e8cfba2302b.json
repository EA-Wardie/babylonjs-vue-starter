{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Scene } from \"../../scene.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\n/**\n * Base behavior for six degrees of freedom interactions in XR experiences.\n * Creates virtual meshes that are dragged around\n * And observables for position/rotation changes\n */\n\nvar BaseSixDofDragBehavior =\n/** @class */\nfunction () {\n  function BaseSixDofDragBehavior() {\n    this._attachedToElement = false;\n    this._virtualMeshesInfo = {};\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    this._dragType = {\n      NONE: 0,\n      DRAG: 1,\n      DRAG_WITH_CONTROLLER: 2,\n      NEAR_DRAG: 3\n    };\n    this._moving = false;\n    this._dragging = this._dragType.NONE;\n    /**\n     * The list of child meshes that can receive drag events\n     * If `null`, all child meshes will receive drag event\n     */\n\n    this.draggableMeshes = null;\n    /**\n     * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)\n     */\n\n    this.zDragFactor = 3;\n    /**\n     * In case of multipointer interaction, all pointer ids currently active are stored here\n     */\n\n    this.currentDraggingPointerIds = [];\n    /**\n    /**\n     * If camera controls should be detached during the drag\n     */\n\n    this.detachCameraControls = true;\n    /**\n     * Fires each time a drag starts\n     */\n\n    this.onDragStartObservable = new Observable();\n    /**\n     * Fires each time a drag happens\n     */\n\n    this.onDragObservable = new Observable();\n    /**\n     *  Fires each time a drag ends (eg. mouse release after drag)\n     */\n\n    this.onDragEndObservable = new Observable();\n    /**\n     * Should the behavior allow simultaneous pointers to interact with the owner node.\n     */\n\n    this.allowMultiPointer = true;\n  }\n\n  Object.defineProperty(BaseSixDofDragBehavior.prototype, \"currentDraggingPointerId\", {\n    /**\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\n     */\n    get: function get() {\n      if (this.currentDraggingPointerIds[0] !== undefined) {\n        return this.currentDraggingPointerIds[0];\n      }\n\n      return -1;\n    },\n    set: function set(value) {\n      this.currentDraggingPointerIds[0] = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseSixDofDragBehavior.prototype, \"currentDraggingPointerID\", {\n    /**\n     * Get or set the currentDraggingPointerId\n     * @deprecated Please use currentDraggingPointerId instead\n     */\n    get: function get() {\n      return this.currentDraggingPointerId;\n    },\n    set: function set(currentDraggingPointerID) {\n      this.currentDraggingPointerId = currentDraggingPointerID;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseSixDofDragBehavior.prototype, \"name\", {\n    /**\n     *  The name of the behavior\n     */\n    get: function get() {\n      return \"BaseSixDofDrag\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseSixDofDragBehavior.prototype, \"isMoving\", {\n    /**\n     *  Returns true if the attached mesh is currently moving with this behavior\n     */\n    get: function get() {\n      return this._moving;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   *  Initializes the behavior\n   */\n\n  BaseSixDofDragBehavior.prototype.init = function () {};\n\n  Object.defineProperty(BaseSixDofDragBehavior.prototype, \"_pointerCamera\", {\n    /**\n     * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera\n     */\n    get: function get() {\n      if (this._scene.cameraToUseForPointers) {\n        return this._scene.cameraToUseForPointers;\n      } else {\n        return this._scene.activeCamera;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BaseSixDofDragBehavior.prototype._createVirtualMeshInfo = function () {\n    // Setup virtual meshes to be used for dragging without dirtying the existing scene\n    var dragMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\n    dragMesh.rotationQuaternion = new Quaternion();\n    var originMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\n    originMesh.rotationQuaternion = new Quaternion();\n    var pivotMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\n    pivotMesh.rotationQuaternion = new Quaternion();\n    return {\n      dragging: false,\n      moving: false,\n      dragMesh: dragMesh,\n      originMesh: originMesh,\n      pivotMesh: pivotMesh,\n      startingPivotPosition: new Vector3(),\n      startingPivotOrientation: new Quaternion(),\n      startingPosition: new Vector3(),\n      startingOrientation: new Quaternion(),\n      lastOriginPosition: new Vector3(),\n      lastDragPosition: new Vector3()\n    };\n  };\n\n  BaseSixDofDragBehavior.prototype._resetVirtualMeshesPosition = function () {\n    for (var i = 0; i < this.currentDraggingPointerIds.length; i++) {\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\n\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);\n\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);\n\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);\n\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);\n\n      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);\n    }\n  };\n\n  BaseSixDofDragBehavior.prototype._pointerUpdate2D = function (ray, pointerId, zDragFactor) {\n    if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {\n      ray.origin.copyFrom(this._pointerCamera.globalPosition);\n      zDragFactor = 0;\n    }\n\n    var virtualMeshesInfo = this._virtualMeshesInfo[pointerId]; // Calculate controller drag distance in controller space\n\n    var originDragDifference = TmpVectors.Vector3[0];\n    ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);\n    virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);\n    var localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);\n    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\n    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\n\n    this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);\n\n    this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor); // Update the controller position\n\n\n    virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);\n    var lookAt = TmpVectors.Vector3[0];\n    ray.origin.addToRef(ray.direction, lookAt);\n    virtualMeshesInfo.originMesh.lookAt(lookAt);\n    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\n    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\n  };\n\n  BaseSixDofDragBehavior.prototype._pointerUpdateXR = function (controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {\n    var virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\n    virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);\n\n    if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {\n      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);\n    } else {\n      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);\n    }\n\n    virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);\n    virtualMeshesInfo.dragMesh.computeWorldMatrix(true); // Z scaling logic\n\n    if (zDragFactor !== 0) {\n      // Camera.getForwardRay modifies TmpVectors.Vector[0-3], so cache it in advance\n      var cameraForwardVec = TmpVectors.Vector3[0];\n      var originDragDirection = TmpVectors.Vector3[1];\n      cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);\n      virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);\n      virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\n      var controllerDragDistance = originDragDirection.length();\n      originDragDirection.normalize();\n      var cameraToDrag = TmpVectors.Vector3[2];\n      var controllerToDrag = TmpVectors.Vector3[3];\n      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);\n      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);\n      var controllerToDragDistance = controllerToDrag.length();\n      cameraToDrag.normalize();\n      controllerToDrag.normalize();\n      var controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);\n      var zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance; // Prevent pulling the mesh through the controller\n\n      var minDistanceFromControllerToDragMesh = 0.01;\n\n      if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {\n        zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);\n      }\n\n      controllerToDrag.scaleInPlace(zOffsetScaling);\n      controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);\n      virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);\n      controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);\n      virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);\n    }\n  };\n  /**\n   * Attaches the scale behavior the passed in mesh\n   * @param ownerNode The mesh that will be scaled around once attached\n   */\n\n\n  BaseSixDofDragBehavior.prototype.attach = function (ownerNode) {\n    var _this = this;\n\n    this._ownerNode = ownerNode;\n    this._scene = this._ownerNode.getScene();\n\n    if (!BaseSixDofDragBehavior._virtualScene) {\n      BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), {\n        virtual: true\n      });\n\n      BaseSixDofDragBehavior._virtualScene.detachControl();\n    }\n\n    var pickPredicate = function pickPredicate(m) {\n      return _this._ownerNode === m || m.isDescendantOf(_this._ownerNode) && (!_this.draggableMeshes || _this.draggableMeshes.indexOf(m) !== -1);\n    };\n\n    this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo) {\n      var pointerId = pointerInfo.event.pointerId;\n\n      if (!_this._virtualMeshesInfo[pointerId]) {\n        _this._virtualMeshesInfo[pointerId] = _this._createVirtualMeshInfo();\n      }\n\n      var virtualMeshesInfo = _this._virtualMeshesInfo[pointerId];\n      var isXRPointer = pointerInfo.event.pointerType === \"xr\";\n\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isXRPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {\n          if (!_this.allowMultiPointer && _this.currentDraggingPointerIds.length > 0) {\n            return;\n          }\n\n          if (_this._pointerCamera && _this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !_this._pointerCamera._isLeftCamera && !_this._pointerCamera._isRightCamera) {\n            pointerInfo.pickInfo.ray.origin.copyFrom(_this._pointerCamera.globalPosition);\n          }\n\n          _this._ownerNode.computeWorldMatrix(true);\n\n          var virtualMeshesInfo_1 = _this._virtualMeshesInfo[pointerId];\n\n          if (isXRPointer) {\n            _this._dragging = pointerInfo.pickInfo.originMesh ? _this._dragType.NEAR_DRAG : _this._dragType.DRAG_WITH_CONTROLLER;\n            virtualMeshesInfo_1.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);\n\n            if (_this._dragging === _this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {\n              virtualMeshesInfo_1.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);\n            } else {\n              virtualMeshesInfo_1.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);\n            }\n          } else {\n            _this._dragging = _this._dragType.DRAG;\n            virtualMeshesInfo_1.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);\n          }\n\n          virtualMeshesInfo_1.lastOriginPosition.copyFrom(virtualMeshesInfo_1.originMesh.position);\n          virtualMeshesInfo_1.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);\n          virtualMeshesInfo_1.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);\n          virtualMeshesInfo_1.pivotMesh.position.copyFrom(_this._ownerNode.getAbsolutePivotPoint());\n          virtualMeshesInfo_1.pivotMesh.rotationQuaternion.copyFrom(_this._ownerNode.absoluteRotationQuaternion);\n          virtualMeshesInfo_1.startingPosition.copyFrom(virtualMeshesInfo_1.dragMesh.position);\n          virtualMeshesInfo_1.startingPivotPosition.copyFrom(virtualMeshesInfo_1.pivotMesh.position);\n          virtualMeshesInfo_1.startingOrientation.copyFrom(virtualMeshesInfo_1.dragMesh.rotationQuaternion);\n          virtualMeshesInfo_1.startingPivotOrientation.copyFrom(virtualMeshesInfo_1.pivotMesh.rotationQuaternion);\n\n          if (isXRPointer) {\n            virtualMeshesInfo_1.originMesh.addChild(virtualMeshesInfo_1.dragMesh);\n            virtualMeshesInfo_1.originMesh.addChild(virtualMeshesInfo_1.pivotMesh);\n          } else {\n            virtualMeshesInfo_1.originMesh.lookAt(virtualMeshesInfo_1.dragMesh.position);\n          } // Update state\n\n\n          virtualMeshesInfo_1.dragging = true;\n\n          if (_this.currentDraggingPointerIds.indexOf(pointerId) === -1) {\n            _this.currentDraggingPointerIds.push(pointerId);\n          } // Detach camera controls\n\n\n          if (_this.detachCameraControls && _this._pointerCamera && !_this._pointerCamera.leftCamera) {\n            if (_this._pointerCamera.inputs && _this._pointerCamera.inputs.attachedToElement) {\n              _this._pointerCamera.detachControl();\n\n              _this._attachedToElement = true;\n            } else {\n              _this._attachedToElement = false;\n            }\n          }\n\n          _this._targetDragStart(virtualMeshesInfo_1.pivotMesh.position, virtualMeshesInfo_1.pivotMesh.rotationQuaternion, pointerId);\n\n          _this.onDragStartObservable.notifyObservers({\n            position: virtualMeshesInfo_1.pivotMesh.position\n          });\n        }\n      } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {\n        var registeredPointerIndex = _this.currentDraggingPointerIds.indexOf(pointerId); // Update state\n\n\n        virtualMeshesInfo.dragging = false;\n\n        if (registeredPointerIndex !== -1) {\n          _this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);\n\n          if (_this.currentDraggingPointerIds.length === 0) {\n            _this._moving = false;\n            _this._dragging = _this._dragType.NONE; // Reattach camera controls\n\n            if (_this.detachCameraControls && _this._attachedToElement && _this._pointerCamera && !_this._pointerCamera.leftCamera) {\n              _this._pointerCamera.attachControl(true);\n\n              _this._attachedToElement = false;\n            }\n          }\n\n          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\n          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\n\n          _this._targetDragEnd(pointerId);\n\n          _this.onDragEndObservable.notifyObservers({});\n        }\n      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\n        var registeredPointerIndex = _this.currentDraggingPointerIds.indexOf(pointerId);\n\n        if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {\n          var zDragFactor = _this.zDragFactor; // 2 pointer interaction should not have a z axis drag factor\n          // as well as near interaction\n\n          if (_this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {\n            zDragFactor = 0;\n          }\n\n          _this._ownerNode.computeWorldMatrix(true);\n\n          if (!isXRPointer) {\n            _this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);\n          } else {\n            _this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);\n          } // Get change in rotation\n\n\n          _this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);\n\n          _this._tmpQuaternion.x = -_this._tmpQuaternion.x;\n          _this._tmpQuaternion.y = -_this._tmpQuaternion.y;\n          _this._tmpQuaternion.z = -_this._tmpQuaternion.z;\n          virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._tmpQuaternion);\n          virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, _this._tmpVector);\n\n          _this.onDragObservable.notifyObservers({\n            delta: _this._tmpVector,\n            position: virtualMeshesInfo.pivotMesh.position,\n            pickInfo: pointerInfo.pickInfo\n          }); // Notify herited methods and observables\n\n\n          _this._targetDrag(_this._tmpVector, _this._tmpQuaternion, pointerId);\n\n          virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);\n          _this._moving = true;\n        }\n      }\n    });\n  };\n\n  BaseSixDofDragBehavior.prototype._applyZOffset = function (node, localOriginDragDifference, zDragFactor) {\n    // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away\n    node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;\n\n    if (node.position.z < 0) {\n      node.position.z = 0;\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  BaseSixDofDragBehavior.prototype._targetDragStart = function (worldPosition, worldRotation, pointerId) {// Herited classes can override that\n  };\n\n  BaseSixDofDragBehavior.prototype._targetDrag = function (worldDeltaPosition, worldDeltaRotation, pointerId) {// Herited classes can override that\n  };\n\n  BaseSixDofDragBehavior.prototype._targetDragEnd = function (pointerId) {// Herited classes can override that\n  };\n  /**\n   * Detaches the behavior from the mesh\n   */\n\n\n  BaseSixDofDragBehavior.prototype.detach = function () {\n    if (this._scene) {\n      if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\n        this._pointerCamera.attachControl(true);\n\n        this._attachedToElement = false;\n      }\n\n      this._scene.onPointerObservable.remove(this._pointerObserver);\n    }\n\n    for (var pointerId in this._virtualMeshesInfo) {\n      this._virtualMeshesInfo[pointerId].originMesh.dispose();\n\n      this._virtualMeshesInfo[pointerId].dragMesh.dispose();\n    }\n\n    this.onDragEndObservable.clear();\n    this.onDragObservable.clear();\n    this.onDragStartObservable.clear();\n  };\n\n  return BaseSixDofDragBehavior;\n}();\n\nexport { BaseSixDofDragBehavior };","map":{"version":3,"mappings":"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","names":["AbstractMesh","Scene","PointerEventTypes","Vector3","Quaternion","TmpVectors","Observable","Camera","NONE","DRAG","DRAG_WITH_CONTROLLER","NEAR_DRAG","_dragType","Object","BaseSixDofDragBehavior","currentDraggingPointerIds","undefined","value","currentDraggingPointerId","currentDraggingPointerID","_moving","_scene","cameraToUseForPointers","activeCamera","dragMesh","_virtualScene","rotationQuaternion","originMesh","pivotMesh","dragging","moving","startingPivotPosition","startingPivotOrientation","startingPosition","startingOrientation","lastOriginPosition","lastDragPosition","i","length","_virtualMeshesInfo","position","copyFrom","_ownerNode","getAbsolutePivotPoint","ray","pointerId","zDragFactor","_pointerCamera","cameraRigMode","RIG_MODE_NONE","_isLeftCamera","_isRightCamera","origin","globalPosition","virtualMeshesInfo","originDragDifference","subtractToRef","localOriginDragDifference","Dot","direction","addChild","_applyZOffset","lookAt","addToRef","removeChild","controllerAimTransform","controllerGripTransform","_dragging","computeWorldMatrix","cameraForwardVec","originDragDirection","getForwardRay","controllerDragDistance","normalize","cameraToDrag","controllerToDrag","absolutePosition","controllerToDragDistance","controllerDragScaling","Math","abs","zOffsetScaling","minDistanceFromControllerToDragMesh","min","scaleInPlace","_tmpVector","setAbsolutePosition","ownerNode","getScene","getEngine","virtual","detachControl","pickPredicate","m","_this","isDescendantOf","draggableMeshes","indexOf","_pointerObserver","onPointerObservable","add","pointerInfo","event","_createVirtualMeshInfo","isXRPointer","pointerType","type","POINTERDOWN","pickInfo","hit","pickedMesh","pickedPoint","aimTransform","allowMultiPointer","virtualMeshesInfo_1","gripTransform","absoluteRotationQuaternion","push","detachCameraControls","leftCamera","inputs","attachedToElement","_attachedToElement","_targetDragStart","onDragStartObservable","notifyObservers","POINTERUP","POINTERDOUBLETAP","registeredPointerIndex","splice","attachControl","_targetDragEnd","onDragEndObservable","POINTERMOVE","_pointerUpdate2D","_pointerUpdateXR","_tmpQuaternion","x","y","z","multiplyToRef","onDragObservable","delta","_targetDrag","node","worldPosition","worldRotation","worldDeltaPosition","worldDeltaRotation","remove","dispose","clear"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Behaviors/Meshes/baseSixDofDragBehavior.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Data store to track virtual pointers movement\r\n */\r\ntype VirtualMeshInfo = {\r\n    dragging: boolean;\r\n    moving: boolean;\r\n    dragMesh: AbstractMesh;\r\n    originMesh: AbstractMesh;\r\n    pivotMesh: AbstractMesh;\r\n    startingPivotPosition: Vector3;\r\n    startingPivotOrientation: Quaternion;\r\n    startingPosition: Vector3;\r\n    startingOrientation: Quaternion;\r\n    lastOriginPosition: Vector3;\r\n    lastDragPosition: Vector3;\r\n};\r\n\r\n/**\r\n * Base behavior for six degrees of freedom interactions in XR experiences.\r\n * Creates virtual meshes that are dragged around\r\n * And observables for position/rotation changes\r\n */\r\nexport class BaseSixDofDragBehavior implements Behavior<Mesh> {\r\n    protected static _virtualScene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _attachedToElement: boolean = false;\r\n    protected _virtualMeshesInfo: {\r\n        [id: number]: VirtualMeshInfo;\r\n    } = {};\r\n\r\n    private _tmpVector: Vector3 = new Vector3();\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n\r\n    protected _dragType = {\r\n        NONE: 0,\r\n        DRAG: 1,\r\n        DRAG_WITH_CONTROLLER: 2,\r\n        NEAR_DRAG: 3,\r\n    };\r\n\r\n    protected _scene: Scene;\r\n    protected _moving = false;\r\n    protected _ownerNode: TransformNode;\r\n    protected _dragging = this._dragType.NONE;\r\n\r\n    /**\r\n     * The list of child meshes that can receive drag events\r\n     * If `null`, all child meshes will receive drag event\r\n     */\r\n    public draggableMeshes: Nullable<AbstractMesh[]> = null;\r\n\r\n    /**\r\n     * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)\r\n     */\r\n    public zDragFactor = 3;\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public get currentDraggingPointerId() {\r\n        if (this.currentDraggingPointerIds[0] !== undefined) {\r\n            return this.currentDraggingPointerIds[0];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public set currentDraggingPointerId(value: number) {\r\n        this.currentDraggingPointerIds[0] = value;\r\n    }\r\n\r\n    /**\r\n     * In case of multipointer interaction, all pointer ids currently active are stored here\r\n     */\r\n    public currentDraggingPointerIds: number[] = [];\r\n\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * Fires each time a drag starts\r\n     */\r\n    public onDragStartObservable = new Observable<{ position: Vector3 }>();\r\n    /**\r\n     * Fires each time a drag happens\r\n     */\r\n    public onDragObservable = new Observable<{ delta: Vector3; position: Vector3; pickInfo: PickingInfo }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\r\n    public onDragEndObservable = new Observable<{}>();\r\n\r\n    /**\r\n     * Should the behavior allow simultaneous pointers to interact with the owner node.\r\n     */\r\n    public allowMultiPointer: boolean = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"BaseSixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Returns true if the attached mesh is currently moving with this behavior\r\n     */\r\n    public get isMoving(): boolean {\r\n        return this._moving;\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera\r\n     */\r\n    private get _pointerCamera() {\r\n        if (this._scene.cameraToUseForPointers) {\r\n            return this._scene.cameraToUseForPointers;\r\n        } else {\r\n            return this._scene.activeCamera;\r\n        }\r\n    }\r\n\r\n    private _createVirtualMeshInfo() {\r\n        // Setup virtual meshes to be used for dragging without dirtying the existing scene\r\n\r\n        const dragMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        dragMesh.rotationQuaternion = new Quaternion();\r\n        const originMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        originMesh.rotationQuaternion = new Quaternion();\r\n        const pivotMesh = new AbstractMesh(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        pivotMesh.rotationQuaternion = new Quaternion();\r\n\r\n        return {\r\n            dragging: false,\r\n            moving: false,\r\n            dragMesh,\r\n            originMesh,\r\n            pivotMesh,\r\n            startingPivotPosition: new Vector3(),\r\n            startingPivotOrientation: new Quaternion(),\r\n            startingPosition: new Vector3(),\r\n            startingOrientation: new Quaternion(),\r\n            lastOriginPosition: new Vector3(),\r\n            lastDragPosition: new Vector3(),\r\n        };\r\n    }\r\n\r\n    protected _resetVirtualMeshesPosition() {\r\n        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion!);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion!\r\n            );\r\n        }\r\n    }\r\n\r\n    private _pointerUpdate2D(ray: Ray, pointerId: number, zDragFactor: number) {\r\n        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {\r\n            ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n            zDragFactor = 0;\r\n        }\r\n\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n        // Calculate controller drag distance in controller space\r\n        const originDragDifference = TmpVectors.Vector3[0];\r\n        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);\r\n        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);\r\n        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);\r\n\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n\r\n        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);\r\n        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);\r\n\r\n        // Update the controller position\r\n        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);\r\n        const lookAt = TmpVectors.Vector3[0];\r\n        ray.origin.addToRef(ray.direction, lookAt);\r\n        virtualMeshesInfo.originMesh.lookAt(lookAt);\r\n\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n    }\r\n\r\n    private _pointerUpdateXR(controllerAimTransform: TransformNode, controllerGripTransform: Nullable<TransformNode>, pointerId: number, zDragFactor: number) {\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);\r\n        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerGripTransform.rotationQuaternion!);\r\n        } else {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerAimTransform.rotationQuaternion!);\r\n        }\r\n\r\n        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);\r\n        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);\r\n\r\n        // Z scaling logic\r\n        if (zDragFactor !== 0) {\r\n            // Camera.getForwardRay modifies TmpVectors.Vector[0-3], so cache it in advance\r\n            const cameraForwardVec = TmpVectors.Vector3[0];\r\n            const originDragDirection = TmpVectors.Vector3[1];\r\n            cameraForwardVec.copyFrom(this._pointerCamera!.getForwardRay().direction);\r\n            virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);\r\n            virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n            const controllerDragDistance = originDragDirection.length();\r\n            originDragDirection.normalize();\r\n\r\n            const cameraToDrag = TmpVectors.Vector3[2];\r\n            const controllerToDrag = TmpVectors.Vector3[3];\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera!.globalPosition, cameraToDrag);\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);\r\n            const controllerToDragDistance = controllerToDrag.length();\r\n            cameraToDrag.normalize();\r\n            controllerToDrag.normalize();\r\n\r\n            const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);\r\n            let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;\r\n\r\n            // Prevent pulling the mesh through the controller\r\n            const minDistanceFromControllerToDragMesh = 0.01;\r\n            if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {\r\n                zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);\r\n            }\r\n            controllerToDrag.scaleInPlace(zOffsetScaling);\r\n\r\n            controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);\r\n            controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: TransformNode): void {\r\n        this._ownerNode = ownerNode;\r\n        this._scene = this._ownerNode.getScene();\r\n        if (!BaseSixDofDragBehavior._virtualScene) {\r\n            BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n            BaseSixDofDragBehavior._virtualScene.detachControl();\r\n        }\r\n\r\n        const pickPredicate = (m: AbstractMesh) => {\r\n            return this._ownerNode === m || (m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1));\r\n        };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n            if (!this._virtualMeshesInfo[pointerId]) {\r\n                this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();\r\n            }\r\n            const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n            const isXRPointer = (<IPointerEvent>pointerInfo.event).pointerType === \"xr\";\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    !virtualMeshesInfo.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    (!isXRPointer || pointerInfo.pickInfo.aimTransform) &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if (!this.allowMultiPointer && this.currentDraggingPointerIds.length > 0) {\r\n                        return;\r\n                    }\r\n\r\n                    if (\r\n                        this._pointerCamera &&\r\n                        this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE &&\r\n                        !this._pointerCamera._isLeftCamera &&\r\n                        !this._pointerCamera._isRightCamera\r\n                    ) {\r\n                        pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n                    if (isXRPointer) {\r\n                        this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform!.position);\r\n                        if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion!);\r\n                        } else {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.aimTransform!.rotationQuaternion!);\r\n                        }\r\n                    } else {\r\n                        this._dragging = this._dragType.DRAG;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    }\r\n\r\n                    virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n\r\n                    virtualMeshesInfo.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n\r\n                    virtualMeshesInfo.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n                    virtualMeshesInfo.pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.absoluteRotationQuaternion);\r\n\r\n                    virtualMeshesInfo.startingPosition.copyFrom(virtualMeshesInfo.dragMesh.position);\r\n                    virtualMeshesInfo.startingPivotPosition.copyFrom(virtualMeshesInfo.pivotMesh.position);\r\n                    virtualMeshesInfo.startingOrientation.copyFrom(virtualMeshesInfo.dragMesh.rotationQuaternion!);\r\n                    virtualMeshesInfo.startingPivotOrientation.copyFrom(virtualMeshesInfo.pivotMesh.rotationQuaternion!);\r\n\r\n                    if (isXRPointer) {\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n                    } else {\r\n                        virtualMeshesInfo.originMesh.lookAt(virtualMeshesInfo.dragMesh.position);\r\n                    }\r\n\r\n                    // Update state\r\n                    virtualMeshesInfo.dragging = true;\r\n\r\n                    if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {\r\n                        this.currentDraggingPointerIds.push(pointerId);\r\n                    }\r\n\r\n                    // Detach camera controls\r\n                    if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                        if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {\r\n                            this._pointerCamera.detachControl();\r\n                            this._attachedToElement = true;\r\n                        } else {\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    this._targetDragStart(virtualMeshesInfo.pivotMesh.position, virtualMeshesInfo.pivotMesh.rotationQuaternion!, pointerId);\r\n                    this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo.pivotMesh.position });\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                // Update state\r\n                virtualMeshesInfo.dragging = false;\r\n\r\n                if (registeredPointerIndex !== -1) {\r\n                    this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);\r\n                    if (this.currentDraggingPointerIds.length === 0) {\r\n                        this._moving = false;\r\n                        this._dragging = this._dragType.NONE;\r\n\r\n                        // Reattach camera controls\r\n                        if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                            this._pointerCamera.attachControl(true);\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n                    this._targetDragEnd(pointerId);\r\n                    this.onDragEndObservable.notifyObservers({});\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {\r\n                    let zDragFactor = this.zDragFactor;\r\n\r\n                    // 2 pointer interaction should not have a z axis drag factor\r\n                    // as well as near interaction\r\n                    if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {\r\n                        zDragFactor = 0;\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    if (!isXRPointer) {\r\n                        this._pointerUpdate2D(pointerInfo.pickInfo.ray!, pointerId, zDragFactor);\r\n                    } else {\r\n                        this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform!, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);\r\n                    }\r\n\r\n                    // Get change in rotation\r\n                    this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);\r\n                    this._tmpQuaternion.x = -this._tmpQuaternion.x;\r\n                    this._tmpQuaternion.y = -this._tmpQuaternion.y;\r\n                    this._tmpQuaternion.z = -this._tmpQuaternion.z;\r\n                    virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);\r\n                    virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);\r\n\r\n                    this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });\r\n\r\n                    // Notify herited methods and observables\r\n                    this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);\r\n\r\n                    this._moving = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _applyZOffset(node: TransformNode, localOriginDragDifference: number, zDragFactor: number) {\r\n        // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away\r\n        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;\r\n        if (node.position.z < 0) {\r\n            node.position.z = 0;\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _targetDragStart(worldPosition: Vector3, worldRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDragEnd(pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        if (this._scene) {\r\n            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                this._pointerCamera.attachControl(true);\r\n                this._attachedToElement = false;\r\n            }\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        for (const pointerId in this._virtualMeshesInfo) {\r\n            this._virtualMeshesInfo[pointerId].originMesh.dispose();\r\n            this._virtualMeshesInfo[pointerId].dragMesh.dispose();\r\n        }\r\n\r\n        this.onDragEndObservable.clear();\r\n        this.onDragObservable.clear();\r\n        this.onDragStartObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}