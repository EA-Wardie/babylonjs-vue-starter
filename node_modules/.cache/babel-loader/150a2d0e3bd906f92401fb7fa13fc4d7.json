{"ast":null,"code":"import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a cylinder, cone or prism\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * height sets the height (y direction) of the cylinder, optional, default 2\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the cylinder, cone or prism\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport function CreateCylinderVertexData(options) {\n  var height = options.height || 2;\n  var diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n  var diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n  diameterTop = diameterTop || 0.00001; // Prevent broken normals\n\n  diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n\n  var tessellation = options.tessellation || 24;\n  var subdivisions = options.subdivisions || 1;\n  var hasRings = options.hasRings ? true : false;\n  var enclose = options.enclose ? true : false;\n  var cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var faceUV = options.faceUV || new Array(3);\n  var faceColors = options.faceColors; // default face colors and UV if undefined\n\n  var quadNb = arc !== 1 && enclose ? 2 : 0;\n  var ringNb = hasRings ? subdivisions : 1;\n  var surfaceNb = 2 + (1 + quadNb) * ringNb;\n  var f;\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceUV && faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n  }\n\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var colors = new Array();\n  var angleStep = Math.PI * 2 * arc / tessellation;\n  var angle;\n  var h;\n  var radius;\n  var tan = (diameterBottom - diameterTop) / 2 / height;\n  var ringVertex = Vector3.Zero();\n  var ringNormal = Vector3.Zero();\n  var ringFirstVertex = Vector3.Zero();\n  var ringFirstNormal = Vector3.Zero();\n  var quadNormal = Vector3.Zero();\n  var Y = Axis.Y; // positions, normals, uvs\n\n  var i;\n  var j;\n  var r;\n  var ringIdx = 1;\n  var s = 1; // surface index\n\n  var cs = 0;\n  var v = 0;\n\n  for (i = 0; i <= subdivisions; i++) {\n    h = i / subdivisions;\n    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n\n    for (r = 0; r < ringIdx; r++) {\n      if (hasRings) {\n        s += r;\n      }\n\n      if (enclose) {\n        s += 2 * r;\n      }\n\n      for (j = 0; j <= tessellation; j++) {\n        angle = j * angleStep; // position\n\n        ringVertex.x = Math.cos(-angle) * radius;\n        ringVertex.y = -height / 2 + h * height;\n        ringVertex.z = Math.sin(-angle) * radius; // normal\n\n        if (diameterTop === 0 && i === subdivisions) {\n          // if no top cap, reuse former normals\n          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n        } else {\n          ringNormal.x = ringVertex.x;\n          ringNormal.z = ringVertex.z;\n          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n          ringNormal.normalize();\n        } // keep first ring vertex values for enclose\n\n\n        if (j === 0) {\n          ringFirstVertex.copyFrom(ringVertex);\n          ringFirstNormal.copyFrom(ringNormal);\n        }\n\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s].y : faceUV[s].w;\n        } else {\n          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n        }\n\n        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n\n        if (faceColors) {\n          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n        }\n      } // if enclose, add four vertices and their dedicated normals\n\n\n      if (arc !== 1 && enclose) {\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n        Vector3.CrossToRef(Y, ringNormal, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n        } else {\n          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n        }\n\n        uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n        } else {\n          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n        }\n\n        uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n\n        if (faceColors) {\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n        }\n      }\n\n      if (cs !== s) {\n        cs = s;\n      }\n    }\n  } // indices\n\n\n  var e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n\n  i = 0;\n\n  for (s = 0; s < subdivisions; s++) {\n    var i0 = 0;\n    var i1 = 0;\n    var i2 = 0;\n    var i3 = 0;\n\n    for (j = 0; j < tessellation; j++) {\n      i0 = i * (e + 1) + j;\n      i1 = (i + 1) * (e + 1) + j;\n      i2 = i * (e + 1) + (j + 1);\n      i3 = (i + 1) * (e + 1) + (j + 1);\n      indices.push(i0, i1, i2);\n      indices.push(i3, i2, i1);\n    }\n\n    if (arc !== 1 && enclose) {\n      // if enclose, add two quads\n      indices.push(i0 + 2, i1 + 2, i2 + 2);\n      indices.push(i3 + 2, i2 + 2, i1 + 2);\n      indices.push(i0 + 4, i1 + 4, i2 + 4);\n      indices.push(i3 + 4, i2 + 4, i1 + 4);\n    }\n\n    i = hasRings ? i + 2 : i + 1;\n  } // Caps\n\n\n  var createCylinderCap = function createCylinderCap(isTop) {\n    var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n\n    if (radius === 0) {\n      return;\n    } // Cap positions, normals & uvs\n\n\n    var angle;\n    var circleVector;\n    var i;\n    var u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n    var c = null;\n\n    if (faceColors) {\n      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n    } // cap center\n\n\n    var vbase = positions.length / 3;\n    var offset = isTop ? height / 2 : -height / 2;\n    var center = new Vector3(0, offset, 0);\n    positions.push(center.x, center.y, center.z);\n    normals.push(0, isTop ? 1 : -1, 0);\n    var v = u.y + (u.w - u.y) * 0.5;\n    uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n\n    if (c) {\n      colors.push(c.r, c.g, c.b, c.a);\n    }\n\n    var textureScale = new Vector2(0.5, 0.5);\n\n    for (i = 0; i <= tessellation; i++) {\n      angle = Math.PI * 2 * i * arc / tessellation;\n      var cos = Math.cos(-angle);\n      var sin = Math.sin(-angle);\n      circleVector = new Vector3(cos * radius, offset, sin * radius);\n      var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n      positions.push(circleVector.x, circleVector.y, circleVector.z);\n      normals.push(0, isTop ? 1 : -1, 0);\n      var v_1 = u.y + (u.w - u.y) * textureCoordinate.y;\n      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v_1 : v_1);\n\n      if (c) {\n        colors.push(c.r, c.g, c.b, c.a);\n      }\n    } // Cap indices\n\n\n    for (i = 0; i < tessellation; i++) {\n      if (!isTop) {\n        indices.push(vbase);\n        indices.push(vbase + (i + 1));\n        indices.push(vbase + (i + 2));\n      } else {\n        indices.push(vbase);\n        indices.push(vbase + (i + 2));\n        indices.push(vbase + (i + 1));\n      }\n    }\n  }; // add caps to geometry based on cap parameter\n\n\n  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n    createCylinderCap(false);\n  }\n\n  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n    createCylinderCap(true);\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    vertexData.colors = colors;\n  }\n\n  return vertexData;\n}\n/**\n * Creates a cylinder or a cone mesh\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n * * If `enclose` is false, a ring surface is one element.\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.updatable\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the cylinder mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\n */\n\nexport function CreateCylinder(name, options, scene) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var cylinder = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  cylinder._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreateCylinderVertexData(options);\n  vertexData.applyToMesh(cylinder, options.updatable);\n  return cylinder;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated Please use CreateCylinder directly\n */\n\nexport var CylinderBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCylinder: CreateCylinder\n};\nVertexData.CreateCylinder = CreateCylinderVertexData;\n\nMesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\n  if (scene === undefined || !(scene instanceof Scene)) {\n    if (scene !== undefined) {\n      sideOrientation = updatable || Mesh.DEFAULTSIDE;\n      updatable = scene;\n    }\n\n    scene = subdivisions;\n    subdivisions = 1;\n  }\n\n  var options = {\n    height: height,\n    diameterTop: diameterTop,\n    diameterBottom: diameterBottom,\n    tessellation: tessellation,\n    subdivisions: subdivisions,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateCylinder(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector4","Vector3","Vector2","Color4","Mesh","VertexData","Scene","Axis","CompatibilityOptions","CreateCylinderVertexData","options","height","diameterTop","diameter","diameterBottom","tessellation","subdivisions","hasRings","enclose","cap","CAP_ALL","arc","sideOrientation","DEFAULTSIDE","faceUV","Array","faceColors","quadNb","ringNb","surfaceNb","f","undefined","indices","positions","normals","uvs","colors","angleStep","Math","PI","angle","h","radius","tan","ringVertex","Zero","ringNormal","ringFirstVertex","ringFirstNormal","quadNormal","Y","i","j","r","ringIdx","s","cs","v","x","cos","y","z","sin","length","sqrt","normalize","copyFrom","push","w","UseOpenGLOrientationForUV","g","b","a","CrossToRef","e","i0","i1","i2","i3","createCylinderCap","isTop","circleVector","u","c","vbase","offset","center","textureScale","textureCoordinate","v_1","CAP_START","CAP_END","_ComputeSides","frontUVs","backUVs","vertexData","CreateCylinder","name","scene","cylinder","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","CylinderBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/cylinderBuilder.ts"],"sourcesContent":["import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = options.tessellation || 24;\r\n    const subdivisions: number = options.subdivisions || 1;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    const colors = new Array<number>();\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.updatable\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\n(Mesh as any).CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}