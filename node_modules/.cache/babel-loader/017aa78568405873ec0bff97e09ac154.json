{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport { Vector2, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { PolygonMeshBuilder } from \"../polygonMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n * All parameters are provided by CreatePolygon as needed\n * @param polygon a mesh built from polygonTriangulation.build()\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n * @returns the VertexData of the Polygon\n */\n\nexport function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {\n  var faceUV = fUV || new Array(3);\n  var faceColors = fColors;\n  var colors = [];\n  var wrap = wrp || false; // default face colors and UV if undefined\n\n  for (var f = 0; f < 3; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var positions = polygon.getVerticesData(VertexBuffer.PositionKind);\n  var normals = polygon.getVerticesData(VertexBuffer.NormalKind);\n  var uvs = polygon.getVerticesData(VertexBuffer.UVKind);\n  var indices = polygon.getIndices();\n  var startIndex = positions.length / 9;\n  var disp = 0;\n  var distX = 0;\n  var distZ = 0;\n  var dist = 0;\n  var totalLen = 0;\n  var cumulate = [0];\n\n  if (wrap) {\n    for (var idx_1 = startIndex; idx_1 < positions.length / 3; idx_1 += 4) {\n      distX = positions[3 * (idx_1 + 2)] - positions[3 * idx_1];\n      distZ = positions[3 * (idx_1 + 2) + 2] - positions[3 * idx_1 + 2];\n      dist = Math.sqrt(distX * distX + distZ * distZ);\n      totalLen += dist;\n      cumulate.push(totalLen);\n    }\n  } // set face colours and textures\n\n\n  var idx = 0;\n  var face = 0;\n\n  for (var index = 0; index < normals.length; index += 3) {\n    //Edge Face  no. 1\n    if (Math.abs(normals[index + 1]) < 0.001) {\n      face = 1;\n    } //Top Face  no. 0\n\n\n    if (Math.abs(normals[index + 1] - 1) < 0.001) {\n      face = 0;\n    } //Bottom Face  no. 2\n\n\n    if (Math.abs(normals[index + 1] + 1) < 0.001) {\n      face = 2;\n    }\n\n    idx = index / 3;\n\n    if (face === 1) {\n      disp = idx - startIndex;\n\n      if (disp % 4 < 1.5) {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].x;\n        }\n      } else {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].z;\n        }\n      }\n\n      if (disp % 2 === 0) {\n        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\n      } else {\n        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\n      }\n    } else {\n      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n\n      if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n        uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\n      }\n    }\n\n    if (faceColors) {\n      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n}\n/**\n * Creates a polygon mesh\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\n * * Remember you can only change the shape positions, not their number when updating a polygon\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.smoothingThreshold\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\n\nexport function CreatePolygon(name, options, scene, earcutInjection) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  var shape = options.shape;\n  var holes = options.holes || [];\n  var depth = options.depth || 0;\n  var smoothingThreshold = options.smoothingThreshold || 2;\n  var contours = [];\n  var hole = [];\n\n  for (var i = 0; i < shape.length; i++) {\n    contours[i] = new Vector2(shape[i].x, shape[i].z);\n  }\n\n  var epsilon = 0.00000001;\n\n  if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n    contours.pop();\n  }\n\n  var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);\n\n  for (var hNb = 0; hNb < holes.length; hNb++) {\n    hole = [];\n\n    for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n      hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n    }\n\n    polygonTriangulation.addHole(hole);\n  } //updatability is set during applyToMesh; setting to true in triangulation build produces errors\n\n\n  var polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\n  polygon._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\n  vertexData.applyToMesh(polygon, options.updatable);\n  return polygon;\n}\n/**\n * Creates an extruded polygon mesh, with depth in the Y direction.\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\n * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\n\nexport function ExtrudePolygon(name, options, scene, earcutInjection) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  return CreatePolygon(name, options, scene, earcutInjection);\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\n\nexport var PolygonBuilder = {\n  ExtrudePolygon: ExtrudePolygon,\n  CreatePolygon: CreatePolygon\n};\nVertexData.CreatePolygon = CreatePolygonVertexData;\n\nMesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return CreatePolygon(name, options, scene, earcutInjection);\n};\n\nMesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    depth: depth,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return ExtrudePolygon(name, options, scene, earcutInjection);\n};","map":{"version":3,"mappings":"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","names":["Vector2","Vector4","Color4","Mesh","VertexData","PolygonMeshBuilder","VertexBuffer","EngineStore","CompatibilityOptions","CreatePolygonVertexData","polygon","sideOrientation","fUV","fColors","frontUVs","backUVs","wrp","faceUV","Array","faceColors","colors","wrap","f","undefined","positions","getVerticesData","PositionKind","normals","NormalKind","uvs","UVKind","indices","getIndices","startIndex","length","disp","distX","distZ","dist","totalLen","cumulate","idx_1","Math","sqrt","push","idx","face","index","abs","x","z","floor","UseOpenGLOrientationForUV","w","y","r","g","b","a","_ComputeSides","vertexData","totalColors","DOUBLESIDE","concat","CreatePolygon","name","options","scene","earcutInjection","_GetDefaultSideOrientation","shape","holes","depth","smoothingThreshold","contours","hole","i","epsilon","equalsWithEpsilon","pop","polygonTriangulation","LastCreatedScene","hNb","hPoint","addHole","build","_originalBuilderSideOrientation","applyToMesh","updatable","ExtrudePolygon","PolygonBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/polygonBuilder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n * All parameters are provided by CreatePolygon as needed\r\n * @param polygon a mesh built from polygonTriangulation.build()\r\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n * @returns the VertexData of the Polygon\r\n */\r\nexport function CreatePolygonVertexData(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    const faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    const faceColors = fColors;\r\n    const colors = [];\r\n    const wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    const indices = <IndicesArray>polygon.getIndices();\r\n    const startIndex = positions.length / 9;\r\n    let disp = 0;\r\n    let distX = 0;\r\n    let distZ = 0;\r\n    let dist = 0;\r\n    let totalLen = 0;\r\n    const cumulate = [0];\r\n    if (wrap) {\r\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    let idx: number = 0;\r\n    let face: number = 0;\r\n    for (let index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            } else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\r\n            } else {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\r\n            }\r\n        } else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\r\n            }\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polygon mesh\r\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n * * Remember you can only change the shape positions, not their number when updating a polygon\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.smoothingThreshold\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function CreatePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        smoothingThreshold?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const shape = options.shape;\r\n    const holes = options.holes || [];\r\n    const depth = options.depth || 0;\r\n    const smoothingThreshold = options.smoothingThreshold || 2;\r\n    const contours: Array<Vector2> = [];\r\n    let hole: Array<Vector2> = [];\r\n\r\n    for (let i = 0; i < shape.length; i++) {\r\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n    }\r\n    const epsilon = 0.00000001;\r\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n        contours.pop();\r\n    }\r\n\r\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n    for (let hNb = 0; hNb < holes.length; hNb++) {\r\n        hole = [];\r\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n        }\r\n        polygonTriangulation.addHole(hole);\r\n    }\r\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\r\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\r\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n    vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n    return polygon;\r\n}\r\n\r\n/**\r\n * Creates an extruded polygon mesh, with depth in the Y direction.\r\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function ExtrudePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const PolygonBuilder = {\r\n    ExtrudePolygon,\r\n    CreatePolygon,\r\n};\r\n\r\nVertexData.CreatePolygon = CreatePolygonVertexData;\r\n(Mesh as any).CreatePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\n(Mesh as any).ExtrudePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    depth: number,\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}