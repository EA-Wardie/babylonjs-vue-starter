{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { Color3, Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Vector2, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\n/**\n * Class used to load mesh data from OBJ content\n */\n\nvar SolidParser =\n/** @class */\nfunction () {\n  /**\n   * Creates a new SolidParser\n   * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n   * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n   * @param loadingOptions defines the loading options to use\n   */\n  function SolidParser(materialToUse, babylonMeshesArray, loadingOptions) {\n    this._positions = []; //values for the positions of vertices\n\n    this._normals = []; //Values for the normals\n\n    this._uvs = []; //Values for the textures\n\n    this._colors = [];\n    this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n\n    this._indicesForBabylon = []; //The list of indices for VertexData\n\n    this._wrappedPositionForBabylon = []; //The list of position in vectors\n\n    this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n\n    this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n\n    this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n\n    this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n\n    this._curPositionInIndices = 0;\n    this._hasMeshes = false; //Meshes are defined in the file\n\n    this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n\n    this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n\n    this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n\n    this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n\n    this._triangles = []; //Indices from new triangles coming from polygons\n\n    this._materialNameFromObj = \"\"; //The name of the current material\n\n    this._objMeshName = \"\"; //The name of the current obj mesh\n\n    this._increment = 1; //Id for meshes created by the multimaterial\n\n    this._isFirstMaterial = true;\n    this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n    this._materialToUse = materialToUse;\n    this._babylonMeshesArray = babylonMeshesArray;\n    this._loadingOptions = loadingOptions;\n  }\n  /**\n   * Search for obj in the given array.\n   * This function is called to check if a couple of data already exists in an array.\n   *\n   * If found, returns the index of the founded tuple index. Returns -1 if not found\n   * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n   * @param obj Array<number>\n   * @returns {boolean}\n   */\n\n\n  SolidParser.prototype._isInArray = function (arr, obj) {\n    if (!arr[obj[0]]) {\n      arr[obj[0]] = {\n        normals: [],\n        idx: []\n      };\n    }\n\n    var idx = arr[obj[0]].normals.indexOf(obj[1]);\n    return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n  };\n\n  SolidParser.prototype._isInArrayUV = function (arr, obj) {\n    if (!arr[obj[0]]) {\n      arr[obj[0]] = {\n        normals: [],\n        idx: [],\n        uv: []\n      };\n    }\n\n    var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n    if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n      return arr[obj[0]].idx[idx];\n    }\n\n    return -1;\n  };\n  /**\n   * This function set the data for each triangle.\n   * Data are position, normals and uvs\n   * If a tuple of (position, normal) is not set, add the data into the corresponding array\n   * If the tuple already exist, add only their indice\n   *\n   * @param indicePositionFromObj Integer The index in positions array\n   * @param indiceUvsFromObj Integer The index in uvs array\n   * @param indiceNormalFromObj Integer The index in normals array\n   * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n   * @param textureVectorFromOBJ Vector3 The value of uvs\n   * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n   * @param positionColorsFromOBJ\n   */\n\n\n  SolidParser.prototype._setData = function (indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {\n    //Check if this tuple already exists in the list of tuples\n    var _index;\n\n    if (this._loadingOptions.optimizeWithUV) {\n      _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\n    } else {\n      _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\n    } //If it not exists\n\n\n    if (_index === -1) {\n      //Add an new indice.\n      //The array of indices is only an array with his length equal to the number of triangles - 1.\n      //We add vertices data in this order\n      this._indicesForBabylon.push(this._wrappedPositionForBabylon.length); //Push the position of vertice for Babylon\n      //Each element is a Vector3(x,y,z)\n\n\n      this._wrappedPositionForBabylon.push(positionVectorFromOBJ); //Push the uvs for Babylon\n      //Each element is a Vector3(u,v)\n\n\n      this._wrappedUvsForBabylon.push(textureVectorFromOBJ); //Push the normals for Babylon\n      //Each element is a Vector3(x,y,z)\n\n\n      this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n\n      if (positionColorsFromOBJ !== undefined) {\n        //Push the colors for Babylon\n        //Each element is a BABYLON.Color4(r,g,b,a)\n        this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\n      } //Add the tuple in the comparison list\n\n\n      this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n\n      this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\n\n      if (this._loadingOptions.optimizeWithUV) {\n        this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\n      }\n    } else {\n      //The tuple already exists\n      //Add the index of the already existing tuple\n      //At this index we can get the value of position, normal, color and uvs of vertex\n      this._indicesForBabylon.push(_index);\n    }\n  };\n  /**\n   * Transform Vector() and BABYLON.Color() objects into numbers in an array\n   */\n\n\n  SolidParser.prototype._unwrapData = function () {\n    //Every array has the same length\n    for (var l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n      //Push the x, y, z values of each element in the unwrapped array\n      this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n\n      this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n\n      this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n\n\n      if (this._loadingOptions.importVertexColors) {\n        //Push the r, g, b, a values of each element in the unwrapped array\n        this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n      }\n    } // Reset arrays for the next new meshes\n\n\n    this._wrappedPositionForBabylon = [];\n    this._wrappedNormalsForBabylon = [];\n    this._wrappedUvsForBabylon = [];\n    this._wrappedColorsForBabylon = [];\n    this._tuplePosNorm = [];\n    this._curPositionInIndices = 0;\n  };\n  /**\n   * Create triangles from polygons\n   * It is important to notice that a triangle is a polygon\n   * We get 5 patterns of face defined in OBJ File :\n   * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n   * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n   * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n   * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n   * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n   * Each pattern is divided by the same method\n   * @param faces Array[String] The indices of elements\n   * @param v Integer The variable to increment\n   */\n\n\n  SolidParser.prototype._getTriangles = function (faces, v) {\n    //Work for each element of the array\n    for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n      //Add on the triangle variable the indexes to obtain triangles\n      this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n    } //Result obtained after 2 iterations:\n    //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n    //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n    //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n    //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n    //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n\n  };\n  /**\n   * Create triangles and push the data for each polygon for the pattern 1\n   * In this pattern we get vertice positions\n   * @param face\n   * @param v\n   */\n\n\n  SolidParser.prototype._setDataForCurrentFaceWithPattern1 = function (face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v); //For each element in the triangles array.\n    //This var could contains 1 to an infinity of triangles\n\n\n    for (var k = 0; k < this._triangles.length; k++) {\n      // Set position indice\n      var indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n\n      this._setData(indicePositionFromObj, 0, 0, // In the pattern 1, normals and uvs are not defined\n      this._positions[indicePositionFromObj], // Get the vectors data\n      Vector2.Zero(), Vector3.Up(), // Create default vectors\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    } //Reset variable for the next line\n\n\n    this._triangles = [];\n  };\n  /**\n   * Create triangles and push the data for each polygon for the pattern 2\n   * In this pattern we get vertice positions and uvsu\n   * @param face\n   * @param v\n   */\n\n\n  SolidParser.prototype._setDataForCurrentFaceWithPattern2 = function (face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n\n    for (var k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1/1\"\n      //Split the data for getting position and uv\n      var point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n      //Set position indice\n\n\n      var indicePositionFromObj = parseInt(point[0]) - 1; //Set uv indice\n\n      var indiceUvsFromObj = parseInt(point[1]) - 1;\n\n      this._setData(indicePositionFromObj, indiceUvsFromObj, 0, //Default value for normals\n      this._positions[indicePositionFromObj], //Get the values for each element\n      this._uvs[indiceUvsFromObj], Vector3.Up(), //Default value for normals\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    } //Reset variable for the next line\n\n\n    this._triangles = [];\n  };\n  /**\n   * Create triangles and push the data for each polygon for the pattern 3\n   * In this pattern we get vertice positions, uvs and normals\n   * @param face\n   * @param v\n   */\n\n\n  SolidParser.prototype._setDataForCurrentFaceWithPattern3 = function (face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n\n    for (var k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1/1/1\"\n      //Split the data for getting position, uv, and normals\n      var point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n      // Set position indice\n\n\n      var indicePositionFromObj = parseInt(point[0]) - 1; // Set uv indice\n\n      var indiceUvsFromObj = parseInt(point[1]) - 1; // Set normal indice\n\n      var indiceNormalFromObj = parseInt(point[2]) - 1;\n\n      this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj] //Set the vector for each component\n      );\n    } //Reset variable for the next line\n\n\n    this._triangles = [];\n  };\n  /**\n   * Create triangles and push the data for each polygon for the pattern 4\n   * In this pattern we get vertice positions and normals\n   * @param face\n   * @param v\n   */\n\n\n  SolidParser.prototype._setDataForCurrentFaceWithPattern4 = function (face, v) {\n    this._getTriangles(face, v);\n\n    for (var k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1//1\"\n      //Split the data for getting position and normals\n      var point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n      // We check indices, and normals\n\n\n      var indicePositionFromObj = parseInt(point[0]) - 1;\n      var indiceNormalFromObj = parseInt(point[1]) - 1;\n\n      this._setData(indicePositionFromObj, 1, //Default value for uv\n      indiceNormalFromObj, this._positions[indicePositionFromObj], //Get each vector of data\n      Vector2.Zero(), this._normals[indiceNormalFromObj], this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    } //Reset variable for the next line\n\n\n    this._triangles = [];\n  };\n  /*\n   * Create triangles and push the data for each polygon for the pattern 3\n   * In this pattern we get vertice positions, uvs and normals\n   * @param face\n   * @param v\n   */\n\n\n  SolidParser.prototype._setDataForCurrentFaceWithPattern5 = function (face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n\n    for (var k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"-1/-1/-1\"\n      //Split the data for getting position, uv, and normals\n      var point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n      // Set position indice\n\n\n      var indicePositionFromObj = this._positions.length + parseInt(point[0]); // Set uv indice\n\n      var indiceUvsFromObj = this._uvs.length + parseInt(point[1]); // Set normal indice\n\n      var indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n\n      this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj], //Set the vector for each component\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    } //Reset variable for the next line\n\n\n    this._triangles = [];\n  };\n\n  SolidParser.prototype._addPreviousObjMesh = function () {\n    //Check if it is not the first mesh. Otherwise we don't have data.\n    if (this._meshesFromObj.length > 0) {\n      //Get the previous mesh for applying the data about the faces\n      //=> in obj file, faces definition append after the name of the mesh\n      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1]; //Set the data into Array for the mesh\n\n      this._unwrapData(); // Reverse tab. Otherwise face are displayed in the wrong sens\n\n\n      this._indicesForBabylon.reverse(); //Set the information for the mesh\n      //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n\n\n      this._handledMesh.indices = this._indicesForBabylon.slice();\n      this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n      this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n      this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n\n      if (this._loadingOptions.importVertexColors) {\n        this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n      } //Reset the array for the next mesh\n\n\n      this._indicesForBabylon = [];\n      this._unwrappedPositionsForBabylon = [];\n      this._unwrappedColorsForBabylon = [];\n      this._unwrappedNormalsForBabylon = [];\n      this._unwrappedUVForBabylon = [];\n    }\n  };\n\n  SolidParser.prototype._optimizeNormals = function (mesh) {\n    var positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n    var mapVertices = {};\n\n    if (!positions || !normals) {\n      return;\n    }\n\n    for (var i = 0; i < positions.length / 3; i++) {\n      var x = positions[i * 3 + 0];\n      var y = positions[i * 3 + 1];\n      var z = positions[i * 3 + 2];\n      var key = x + \"_\" + y + \"_\" + z;\n      var lst = mapVertices[key];\n\n      if (!lst) {\n        lst = [];\n        mapVertices[key] = lst;\n      }\n\n      lst.push(i);\n    }\n\n    var normal = new Vector3();\n\n    for (var key in mapVertices) {\n      var lst = mapVertices[key];\n\n      if (lst.length < 2) {\n        continue;\n      }\n\n      var v0Idx = lst[0];\n\n      for (var i = 1; i < lst.length; ++i) {\n        var vIdx = lst[i];\n        normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n        normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n        normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n      }\n\n      normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n      normal.normalize();\n\n      for (var i = 0; i < lst.length; ++i) {\n        var vIdx = lst[i];\n        normals[vIdx * 3 + 0] = normal.x;\n        normals[vIdx * 3 + 1] = normal.y;\n        normals[vIdx * 3 + 2] = normal.z;\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n  };\n  /**\n   * Function used to parse an OBJ string\n   * @param meshesNames defines the list of meshes to load (all if not defined)\n   * @param data defines the OBJ string\n   * @param scene defines the hosting scene\n   * @param assetContainer defines the asset container to load data in\n   * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n   */\n\n\n  SolidParser.prototype.parse = function (meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n    var _a; // Split the file into lines\n\n\n    var lines = data.split(\"\\n\"); // Look at each line\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i].trim().replace(/\\s\\s/g, \" \");\n      var result = void 0; // Comment or newLine\n\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue; //Get information about one position possible for the vertices\n      } else if (SolidParser.VertexPattern.test(line)) {\n        result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n        // Value of result with line: \"v 1.0 2.0 3.0\"\n        // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n        // Create a Vector3 with the position x, y, z\n\n        this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n\n        if (this._loadingOptions.importVertexColors) {\n          if (result.length >= 7) {\n            var r = parseFloat(result[4]);\n            var g = parseFloat(result[5]);\n            var b = parseFloat(result[6]);\n\n            this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n          } else {\n            // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n            this._colors.push(this._grayColor);\n          }\n        }\n      } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n        //Create a Vector3 with the normals x, y, z\n        //Value of result\n        // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n        //Add the Vector in the list of normals\n        this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n      } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n        //Create a Vector2 with the normals u, v\n        //Value of result\n        // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n        //Add the Vector in the list of uvs\n        this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y)); //Identify patterns of faces\n        //Face could be defined in different type of pattern\n\n      } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n        //Value of result:\n        //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n        //Value of result\n        //[\"f 1 2 3\", \"1 2 3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n        1); // Define a mesh or an object\n        // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n\n      } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n        // Create a new mesh corresponding to the name of the group.\n        // Definition of the mesh\n        var objMesh = {\n          name: line.substring(2).trim(),\n          indices: undefined,\n          positions: undefined,\n          normals: undefined,\n          uvs: undefined,\n          colors: undefined,\n          materialName: \"\"\n        };\n\n        this._addPreviousObjMesh(); //Push the last mesh created with only the name\n\n\n        this._meshesFromObj.push(objMesh); //Set this variable to indicate that now meshesFromObj has objects defined inside\n\n\n        this._hasMeshes = true;\n        this._isFirstMaterial = true;\n        this._increment = 1; //Keyword for applying a material\n      } else if (SolidParser.UseMtlDescriptor.test(line)) {\n        //Get the name of the material\n        this._materialNameFromObj = line.substring(7).trim(); //If this new material is in the same mesh\n\n        if (!this._isFirstMaterial || !this._hasMeshes) {\n          //Set the data for the previous mesh\n          this._addPreviousObjMesh(); //Create a new mesh\n\n\n          var objMesh = //Set the name of the current obj mesh\n          {\n            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(),\n            indices: undefined,\n            positions: undefined,\n            normals: undefined,\n            uvs: undefined,\n            colors: undefined,\n            materialName: this._materialNameFromObj\n          };\n          this._increment++; //If meshes are already defined\n\n          this._meshesFromObj.push(objMesh);\n\n          this._hasMeshes = true;\n        } //Set the material name if the previous line define a mesh\n\n\n        if (this._hasMeshes && this._isFirstMaterial) {\n          //Set the material name to the previous mesh (1 material per mesh)\n          this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n          this._isFirstMaterial = false;\n        } // Keyword for loading the mtl file\n\n      } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n        // Get the name of mtl file\n        onFileToLoadFound(line.substring(7).trim()); // Apply smoothing\n      } else if (SolidParser.SmoothDescriptor.test(line)) {// smooth shading => apply smoothing\n        // Today I don't know it work with babylon and with obj.\n        // With the obj file  an integer is set\n      } else {\n        //If there is another possibility\n        console.log(\"Unhandled expression at line : \" + line);\n      }\n    } // At the end of the file, add the last mesh into the meshesFromObj array\n\n\n    if (this._hasMeshes) {\n      // Set the data for the last mesh\n      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1]; //Reverse indices for displaying faces in the good sense\n\n      this._indicesForBabylon.reverse(); //Get the good array\n\n\n      this._unwrapData(); //Set array\n\n\n      this._handledMesh.indices = this._indicesForBabylon;\n      this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n      this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n      this._handledMesh.uvs = this._unwrappedUVForBabylon;\n\n      if (this._loadingOptions.importVertexColors) {\n        this._handledMesh.colors = this._unwrappedColorsForBabylon;\n      }\n    } // If any o or g keyword not found, create a mesh with a random id\n\n\n    if (!this._hasMeshes) {\n      var newMaterial = null;\n\n      if (this._indicesForBabylon.length) {\n        // reverse tab of indices\n        this._indicesForBabylon.reverse(); //Get positions normals uvs\n\n\n        this._unwrapData();\n      } else {\n        // There is no indices in the file. We will have to switch to point cloud rendering\n        for (var _i = 0, _b = this._positions; _i < _b.length; _i++) {\n          var pos = _b[_i];\n\n          this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n        }\n\n        if (this._normals.length) {\n          for (var _c = 0, _d = this._normals; _c < _d.length; _c++) {\n            var normal = _d[_c];\n\n            this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n          }\n        }\n\n        if (this._uvs.length) {\n          for (var _e = 0, _f = this._uvs; _e < _f.length; _e++) {\n            var uv = _f[_e];\n\n            this._unwrappedUVForBabylon.push(uv.x, uv.y);\n          }\n        }\n\n        if (this._colors.length) {\n          for (var _g = 0, _h = this._colors; _g < _h.length; _g++) {\n            var color = _h[_g];\n\n            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n          }\n        }\n\n        if (!this._materialNameFromObj) {\n          // Create a material with point cloud on\n          newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n          newMaterial.pointsCloud = true;\n          this._materialNameFromObj = newMaterial.name;\n\n          if (!this._normals.length) {\n            newMaterial.disableLighting = true;\n            newMaterial.emissiveColor = Color3.White();\n          }\n        }\n      } //Set data for one mesh\n\n\n      this._meshesFromObj.push({\n        name: Geometry.RandomId(),\n        indices: this._indicesForBabylon,\n        positions: this._unwrappedPositionsForBabylon,\n        colors: this._unwrappedColorsForBabylon,\n        normals: this._unwrappedNormalsForBabylon,\n        uvs: this._unwrappedUVForBabylon,\n        materialName: this._materialNameFromObj,\n        directMaterial: newMaterial\n      });\n    } //Set data for each mesh\n\n\n    for (var j = 0; j < this._meshesFromObj.length; j++) {\n      //check meshesNames (stlFileLoader)\n      if (meshesNames && this._meshesFromObj[j].name) {\n        if (meshesNames instanceof Array) {\n          if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n            continue;\n          }\n        } else {\n          if (this._meshesFromObj[j].name !== meshesNames) {\n            continue;\n          }\n        }\n      } //Get the current mesh\n      //Set the data with VertexBuffer for each mesh\n\n\n      this._handledMesh = this._meshesFromObj[j]; //Create a Mesh with the name of the obj mesh\n\n      scene._blockEntityCollection = !!assetContainer;\n      var babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n      babylonMesh._parentContainer = assetContainer;\n      scene._blockEntityCollection = false; //Push the name of the material to an array\n      //This is indispensable for the importMesh function\n\n      this._materialToUse.push(this._meshesFromObj[j].materialName);\n\n      if (((_a = this._handledMesh.positions) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        //Push the mesh into an array\n        this._babylonMeshesArray.push(babylonMesh);\n\n        continue;\n      }\n\n      var vertexData = new VertexData(); //The container for the values\n      //Set the data for the babylonMesh\n\n      vertexData.uvs = this._handledMesh.uvs;\n      vertexData.indices = this._handledMesh.indices;\n      vertexData.positions = this._handledMesh.positions;\n\n      if (this._loadingOptions.computeNormals) {\n        var normals = new Array();\n        VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n        vertexData.normals = normals;\n      } else {\n        vertexData.normals = this._handledMesh.normals;\n      }\n\n      if (this._loadingOptions.importVertexColors) {\n        vertexData.colors = this._handledMesh.colors;\n      } //Set the data from the VertexBuffer to the current Mesh\n\n\n      vertexData.applyToMesh(babylonMesh);\n\n      if (this._loadingOptions.invertY) {\n        babylonMesh.scaling.y *= -1;\n      }\n\n      if (this._loadingOptions.optimizeNormals) {\n        this._optimizeNormals(babylonMesh);\n      } //Push the mesh into an array\n\n\n      this._babylonMeshesArray.push(babylonMesh);\n\n      if (this._handledMesh.directMaterial) {\n        babylonMesh.material = this._handledMesh.directMaterial;\n      }\n    }\n  }; // Descriptor\n\n  /** Object descriptor */\n\n\n  SolidParser.ObjectDescriptor = /^o/;\n  /** Group descriptor */\n\n  SolidParser.GroupDescriptor = /^g/;\n  /** Material lib descriptor */\n\n  SolidParser.MtlLibGroupDescriptor = /^mtllib /;\n  /** Use a material descriptor */\n\n  SolidParser.UseMtlDescriptor = /^usemtl /;\n  /** Smooth descriptor */\n\n  SolidParser.SmoothDescriptor = /^s /; // Patterns\n\n  /** Pattern used to detect a vertex */\n\n  SolidParser.VertexPattern = /v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n  /** Pattern used to detect a normal */\n\n  SolidParser.NormalPattern = /vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n  /** Pattern used to detect a UV set */\n\n  SolidParser.UVPattern = /vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n  /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\n\n  SolidParser.FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n  /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\n\n  SolidParser.FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n  /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\n\n  SolidParser.FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n  /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\n\n  SolidParser.FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n  /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\n\n  SolidParser.FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n  return SolidParser;\n}();\n\nexport { SolidParser };","map":{"version":3,"mappings":"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","names":["VertexBuffer","StandardMaterial","Color3","Color4","Vector2","Vector3","Geometry","Mesh","VertexData","materialToUse","babylonMeshesArray","loadingOptions","_materialToUse","_babylonMeshesArray","_loadingOptions","SolidParser","arr","obj","normals","idx","indexOf","uv","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_index","optimizeWithUV","_isInArrayUV","_tuplePosNorm","_isInArray","_indicesForBabylon","push","_wrappedPositionForBabylon","length","_wrappedUvsForBabylon","_wrappedNormalsForBabylon","undefined","_wrappedColorsForBabylon","_curPositionInIndices","l","_unwrappedPositionsForBabylon","x","y","z","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","importVertexColors","_unwrappedColorsForBabylon","r","g","b","a","faces","v","faceIndex","_triangles","face","_getTriangles","k","parseInt","_setData","_positions","Zero","Up","_colors","point","split","_uvs","_normals","_meshesFromObj","_handledMesh","_unwrapData","reverse","indices","slice","positions","uvs","colors","mesh","getVerticesData","PositionKind","NormalKind","mapVertices","i","key","lst","normal","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","meshesNames","data","scene","assetContainer","onFileToLoadFound","lines","line","trim","replace","result","charAt","VertexPattern","test","match","parseFloat","_grayColor","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","_setDataForCurrentFaceWithPattern3","FacePattern4","_setDataForCurrentFaceWithPattern4","FacePattern5","_setDataForCurrentFaceWithPattern5","FacePattern2","_setDataForCurrentFaceWithPattern2","FacePattern1","_setDataForCurrentFaceWithPattern1","GroupDescriptor","ObjectDescriptor","objMesh","name","substring","materialName","_addPreviousObjMesh","_hasMeshes","_isFirstMaterial","_increment","UseMtlDescriptor","_materialNameFromObj","_objMeshName","toString","MtlLibGroupDescriptor","SmoothDescriptor","console","log","newMaterial","_i","pos","_c","_e","_g","color","RandomId","pointsCloud","disableLighting","emissiveColor","White","directMaterial","j","Array","_blockEntityCollection","babylonMesh","_parentContainer","_a","vertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","_optimizeNormals","material"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/OBJ/solidParser.ts"],"sourcesContent":["import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices?: Array<number>;\r\n    positions?: Array<number>;\r\n    normals?: Array<number>;\r\n    colors?: Array<number>;\r\n    uvs?: Array<number>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: Boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     * @param positionColorsFromOBJ\r\n     */\r\n    private _setData(\r\n        indicePositionFromObj: number,\r\n        indiceUvsFromObj: number,\r\n        indiceNormalFromObj: number,\r\n        positionVectorFromOBJ: Vector3,\r\n        textureVectorFromOBJ: Vector2,\r\n        normalsVectorFromOBJ: Vector3,\r\n        positionColorsFromOBJ?: Color4\r\n    ) {\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\r\n            //Push the uvs for Babylon\r\n            //Each element is a Vector3(u,v)\r\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\r\n            //Push the normals for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\r\n\r\n            if (positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\r\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        //Every array has the same length\r\n        for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n            //Push the x, y, z values of each element in the unwrapped array\r\n            this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\r\n            this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\r\n            this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n            if (this._loadingOptions.importVertexColors) {\r\n                //Push the r, g, b, a values of each element in the unwrapped array\r\n                this._unwrappedColorsForBabylon.push(\r\n                    this._wrappedColorsForBabylon[l].r,\r\n                    this._wrappedColorsForBabylon[l].g,\r\n                    this._wrappedColorsForBabylon[l].b,\r\n                    this._wrappedColorsForBabylon[l].a\r\n                );\r\n            }\r\n        }\r\n        // Reset arrays for the next new meshes\r\n        this._wrappedPositionForBabylon = [];\r\n        this._wrappedNormalsForBabylon = [];\r\n        this._wrappedUvsForBabylon = [];\r\n        this._wrappedColorsForBabylon = [];\r\n        this._tuplePosNorm = [];\r\n        this._curPositionInIndices = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                0,\r\n                0, // In the pattern 1, normals and uvs are not defined\r\n                this._positions[indicePositionFromObj], // Get the vectors data\r\n                Vector2.Zero(),\r\n                Vector3.Up(), // Create default vectors\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvsu\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                0, //Default value for normals\r\n                this._positions[indicePositionFromObj], //Get the values for each element\r\n                this._uvs[indiceUvsFromObj],\r\n                Vector3.Up(), //Default value for normals\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj] //Set the vector for each component\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                1, //Default value for uv\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], //Get each vector of data\r\n                Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj],\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj], //Set the vector for each component\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            // Reverse tab. Otherwise face are displayed in the wrong sens\r\n            this._indicesForBabylon.reverse();\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon = [];\r\n            this._unwrappedPositionsForBabylon = [];\r\n            this._unwrappedColorsForBabylon = [];\r\n            this._unwrappedNormalsForBabylon = [];\r\n            this._unwrappedUVForBabylon = [];\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        // Split the file into lines\r\n        const lines = data.split(\"\\n\");\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n\r\n                //Get information about one position possible for the vertices\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: undefined,\r\n                    positions: undefined,\r\n                    normals: undefined,\r\n                    uvs: undefined,\r\n                    colors: undefined,\r\n                    materialName: \"\",\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: undefined,\r\n                            positions: undefined,\r\n                            normals: undefined,\r\n                            uvs: undefined,\r\n                            colors: undefined,\r\n                            materialName: this._materialNameFromObj,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                console.log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Reverse indices for displaying faces in the good sense\r\n            this._indicesForBabylon.reverse();\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                // reverse tab of indices\r\n                this._indicesForBabylon.reverse();\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._colors.length) {\r\n                    for (const color of this._colors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.uvs = this._handledMesh.uvs as FloatArray;\r\n            vertexData.indices = this._handledMesh.indices as IndicesArray;\r\n            vertexData.positions = this._handledMesh.positions as FloatArray;\r\n            if (this._loadingOptions.computeNormals) {\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals as FloatArray;\r\n            }\r\n            if (this._loadingOptions.importVertexColors) {\r\n                vertexData.colors = this._handledMesh.colors as FloatArray;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}