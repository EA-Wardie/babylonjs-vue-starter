{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Axis } from \"../Maths/math.js\";\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\n\nvar TextureDome =\n/** @class */\nfunction (_super) {\n  __extends(TextureDome, _super);\n  /**\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n   * @param name Element's name, child elements will append suffixes for their own names.\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n   * @param options An object containing optional or exposed sub element properties\n   * @param options.resolution\n   * @param options.clickToPlay\n   * @param options.autoPlay\n   * @param options.loop\n   * @param options.size\n   * @param options.poster\n   * @param options.faceForward\n   * @param options.useDirectMapping\n   * @param options.halfDomeMode\n   * @param options.crossEyeMode\n   * @param options.generateMipMaps\n   * @param options.mesh\n   * @param scene\n   * @param onError\n   */\n\n\n  function TextureDome(name, textureUrlOrElement, options, scene, // eslint-disable-next-line @typescript-eslint/naming-convention\n  onError) {\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.onError = onError;\n    _this._halfDome = false;\n    _this._crossEye = false;\n    _this._useDirectMapping = false;\n    _this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n\n    _this._onBeforeCameraRenderObserver = null;\n    /**\n     * Observable raised when an error occurred while loading the texture\n     */\n\n    _this.onLoadErrorObservable = new Observable();\n    /**\n     * Observable raised when the texture finished loading\n     */\n\n    _this.onLoadObservable = new Observable();\n    scene = _this.getScene(); // set defaults and manage values\n\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n\n    if (options.useDirectMapping === undefined) {\n      _this._useDirectMapping = true;\n    } else {\n      _this._useDirectMapping = options.useDirectMapping;\n    }\n\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n\n    _this._setReady(false);\n\n    if (!options.mesh) {\n      _this._mesh = CreateSphere(name + \"_mesh\", {\n        segments: options.resolution,\n        diameter: options.size,\n        updatable: false,\n        sideOrientation: Mesh.BACKSIDE\n      }, scene);\n    } else {\n      _this._mesh = options.mesh;\n    } // configure material\n\n\n    var material = _this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n\n    var texture = _this._initTexture(textureUrlOrElement, scene, options);\n\n    _this.texture = texture; // configure mesh\n\n    _this._mesh.material = material;\n    _this._mesh.parent = _this; // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n\n    _this._halfDomeMask = CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n\n    _this._halfDomeMask.rotate(Axis.X, -Math.PI / 2); // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n\n\n    _this._halfDomeMask.parent = _this._mesh;\n    _this._halfDome = !!options.halfDomeMode; // enable or disable according to the settings\n\n    _this._halfDomeMask.setEnabled(_this._halfDome);\n\n    _this._crossEye = !!options.crossEyeMode; // create\n\n    _this._texture.anisotropicFilteringLevel = 1;\n\n    _this._texture.onLoadObservable.addOnce(function () {\n      _this._setReady(true);\n    }); // Initial rotation\n\n\n    if (options.faceForward && scene.activeCamera) {\n      var camera = scene.activeCamera;\n      var forward = Vector3.Forward();\n      var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n\n    _this._changeTextureMode(_this._textureMode);\n\n    return _this;\n  }\n\n  Object.defineProperty(TextureDome.prototype, \"texture\", {\n    /**\n     * Gets the texture being displayed on the sphere\n     */\n    get: function get() {\n      return this._texture;\n    },\n\n    /**\n     * Sets the texture being displayed on the sphere\n     */\n    set: function set(newTexture) {\n      if (this._texture === newTexture) {\n        return;\n      }\n\n      this._texture = newTexture;\n\n      if (this._useDirectMapping) {\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.diffuseTexture = this._texture;\n      } else {\n        this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.reflectionTexture = this._texture;\n      }\n\n      this._changeTextureMode(this._textureMode);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"mesh\", {\n    /**\n     * Gets the mesh used for the dome.\n     */\n    get: function get() {\n      return this._mesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"fovMultiplier\", {\n    /**\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n     * Also see the options.resolution property.\n     */\n    get: function get() {\n      return this._material.fovMultiplier;\n    },\n    set: function set(value) {\n      this._material.fovMultiplier = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"textureMode\", {\n    /**\n     * Gets or set the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    get: function get() {\n      return this._textureMode;\n    },\n\n    /**\n     * Sets the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    set: function set(value) {\n      if (this._textureMode === value) {\n        return;\n      }\n\n      this._changeTextureMode(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"halfDome\", {\n    /**\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n     */\n    get: function get() {\n      return this._halfDome;\n    },\n\n    /**\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n     */\n    set: function set(enabled) {\n      this._halfDome = enabled;\n\n      this._halfDomeMask.setEnabled(enabled);\n\n      this._changeTextureMode(this._textureMode);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"crossEye\", {\n    /**\n     * Is it a cross-eye texture?\n     */\n    get: function get() {\n      return this._crossEye;\n    },\n\n    /**\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n     */\n    set: function set(enabled) {\n      this._crossEye = enabled;\n\n      this._changeTextureMode(this._textureMode);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"material\", {\n    /**\n     * The background material of this dome.\n     */\n    get: function get() {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureDome.prototype._changeTextureMode = function (value) {\n    var _this = this;\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this._textureMode = value; // Default Setup and Reset.\n\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n\n        break;\n\n      case TextureDome.MODE_SIDEBYSIDE:\n        {\n          // in half-dome mode the uScale should be double of 360 texture\n          // Use 0.99999 to boost perf by not switching program\n          this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n          var rightOffset_1 = this._halfDome ? 0.0 : 0.5;\n          var leftOffset_1 = this._halfDome ? -0.5 : 0.0;\n          this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n            var isRightCamera = camera.isRightCamera;\n\n            if (_this._crossEye) {\n              isRightCamera = !isRightCamera;\n            }\n\n            if (isRightCamera) {\n              _this._texture.uOffset = rightOffset_1;\n            } else {\n              _this._texture.uOffset = leftOffset_1;\n            }\n          });\n          break;\n        }\n\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n          var isRightCamera = camera.isRightCamera; // allow \"cross-eye\" if left and right were switched in this mode\n\n          if (_this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n\n          _this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  };\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n\n\n  TextureDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    this._texture.dispose();\n\n    this._mesh.dispose();\n\n    this._material.dispose();\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this.onLoadErrorObservable.clear();\n    this.onLoadObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\n   * Define the source as a Monoscopic panoramic 360/180.\n   */\n\n\n  TextureDome.MODE_MONOSCOPIC = 0;\n  /**\n   * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n   */\n\n  TextureDome.MODE_TOPBOTTOM = 1;\n  /**\n   * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n   */\n\n  TextureDome.MODE_SIDEBYSIDE = 2;\n  return TextureDome;\n}(TransformNode);\n\nexport { TextureDome };","map":{"version":3,"mappings":";;AACA,SAASA,aAAT,QAA8B,4BAA9B;AACA,SAASC,IAAT,QAAqB,mBAArB;AACA,SAASC,OAAT,QAAwB,kCAAxB;AACA,SAASC,kBAAT,QAAmC,+CAAnC;AACA,SAASC,YAAT,QAA6B,qCAA7B;AAGA,SAASC,UAAT,QAA2B,uBAA3B;AACA,SAASC,OAAT,QAAwB,yBAAxB;AACA,SAASC,IAAT,QAAqB,kBAArB;AAIA;;;;;;;AAMA;AAAA;AAAA;AAA6DC;AA8JzD;;;;;;;;;;;;;;;;;;;;;;AAoBA,uBACIC,IADJ,EAEIC,mBAFJ,EAGIC,OAHJ,EAiBIC,KAjBJ,EAkBI;AACUC,SAnBd,EAmBmF;AAArE;AAAAA;AAAqE;;AAnBnF,gBAqBIC,kBAAML,IAAN,EAAYG,KAAZ,KAAkB,IArBtB;;AAmBcG;AAvLNA,sBAAqB,KAArB;AACAA,sBAAqB,KAArB;AAEEA,8BAAoB,KAApB;AAkEAA,yBAAeC,WAAW,CAACC,eAA3B;AA8DV;;;;AAGQF,0CAA4D,IAA5D;AACR;;;;AAGOA,kCAAwB,IAAIV,UAAJ,EAAxB;AACP;;;;AAGOU,6BAAmB,IAAIV,UAAJ,EAAnB;AA6CHO,SAAK,GAAGG,KAAI,CAACG,QAAL,EAAR,CAJ+E,CAM/E;;AACAT,QAAI,GAAGA,IAAI,IAAI,aAAf;AACAE,WAAO,CAACQ,UAAR,GAAqBC,IAAI,CAACC,GAAL,CAASV,OAAO,CAACQ,UAAjB,IAAsC,CAAtC,IAA2C,EAAhE;AACAR,WAAO,CAACW,WAAR,GAAsBC,OAAO,CAACZ,OAAO,CAACW,WAAT,CAA7B;AACAX,WAAO,CAACa,QAAR,GAAmBb,OAAO,CAACa,QAAR,KAAqBC,SAArB,GAAiC,IAAjC,GAAwCF,OAAO,CAACZ,OAAO,CAACa,QAAT,CAAlE;AACAb,WAAO,CAACe,IAAR,GAAef,OAAO,CAACe,IAAR,KAAiBD,SAAjB,GAA6B,IAA7B,GAAoCF,OAAO,CAACZ,OAAO,CAACe,IAAT,CAA1D;AACAf,WAAO,CAACgB,IAAR,GAAeP,IAAI,CAACC,GAAL,CAASV,OAAO,CAACgB,IAAjB,MAAkCf,KAAK,CAACgB,YAAN,GAAqBhB,KAAK,CAACgB,YAAN,CAAmBC,IAAnB,GAA0B,IAA/C,GAAsD,IAAxF,CAAf;;AAEA,QAAIlB,OAAO,CAACmB,gBAAR,KAA6BL,SAAjC,EAA4C;AACxCV,WAAI,CAACgB,iBAAL,GAAyB,IAAzB;AACH,KAFD,MAEO;AACHhB,WAAI,CAACgB,iBAAL,GAAyBpB,OAAO,CAACmB,gBAAjC;AACH;;AAED,QAAInB,OAAO,CAACqB,WAAR,KAAwBP,SAA5B,EAAuC;AACnCd,aAAO,CAACqB,WAAR,GAAsB,IAAtB;AACH;;AAEDjB,SAAI,CAACkB,SAAL,CAAe,KAAf;;AACA,QAAI,CAACtB,OAAO,CAACuB,IAAb,EAAmB;AACfnB,WAAI,CAACoB,KAAL,GAAa/B,YAAY,CAACK,IAAI,GAAG,OAAR,EAAiB;AAAE2B,gBAAQ,EAAEzB,OAAO,CAACQ,UAApB;AAAgCkB,gBAAQ,EAAE1B,OAAO,CAACgB,IAAlD;AAAwDW,iBAAS,EAAE,KAAnE;AAA0EC,uBAAe,EAAEtC,IAAI,CAACuC;AAAhG,OAAjB,EAA6H5B,KAA7H,CAAzB;AACH,KAFD,MAEO;AACHG,WAAI,CAACoB,KAAL,GAAaxB,OAAO,CAACuB,IAArB;AACH,KA7B8E,CA8B/E;;;AACA,QAAMO,QAAQ,GAAI1B,KAAI,CAAC2B,SAAL,GAAiB,IAAIvC,kBAAJ,CAAuBM,IAAI,GAAG,WAA9B,EAA2CG,KAA3C,CAAnC;AACA6B,YAAQ,CAACE,qBAAT,GAAiC,IAAjC;AACAF,YAAQ,CAACG,aAAT,GAAyB,GAAzB;AACAH,YAAQ,CAACI,cAAT,GAA0B,KAA1B;;AAEA,QAAMC,OAAO,GAAG/B,KAAI,CAACgC,YAAL,CAAkBrC,mBAAlB,EAAuCE,KAAvC,EAA8CD,OAA9C,CAAhB;;AACAI,SAAI,CAAC+B,OAAL,GAAeA,OAAf,CArC+E,CAuC/E;;AACA/B,SAAI,CAACoB,KAAL,CAAWM,QAAX,GAAsBA,QAAtB;AACA1B,SAAI,CAACoB,KAAL,CAAWa,MAAX,GAAoBjC,KAApB,CAzC+E,CA2C/E;;AACAA,SAAI,CAACkC,aAAL,GAAqB7C,YAAY,CAAC,EAAD,EAAK;AAAE8C,WAAK,EAAE,GAAT;AAAcb,cAAQ,EAAE1B,OAAO,CAACgB,IAAR,GAAe,IAAvC;AAA6CS,cAAQ,EAAEzB,OAAO,CAACQ,UAAR,GAAqB,CAA5E;AAA+EoB,qBAAe,EAAEtC,IAAI,CAACuC;AAArG,KAAL,EAAsH5B,KAAtH,CAAjC;;AACAG,SAAI,CAACkC,aAAL,CAAmBE,MAAnB,CAA0B5C,IAAI,CAAC6C,CAA/B,EAAkC,CAAChC,IAAI,CAACiC,EAAN,GAAW,CAA7C,EA7C+E,CA8C/E;;;AACAtC,SAAI,CAACkC,aAAL,CAAmBD,MAAnB,GAA4BjC,KAAI,CAACoB,KAAjC;AACApB,SAAI,CAACuC,SAAL,GAAiB,CAAC,CAAC3C,OAAO,CAAC4C,YAA3B,CAhD+E,CAiD/E;;AACAxC,SAAI,CAACkC,aAAL,CAAmBO,UAAnB,CAA8BzC,KAAI,CAACuC,SAAnC;;AACAvC,SAAI,CAAC0C,SAAL,GAAiB,CAAC,CAAC9C,OAAO,CAAC+C,YAA3B,CAnD+E,CAqD/E;;AACA3C,SAAI,CAAC4C,QAAL,CAAcC,yBAAd,GAA0C,CAA1C;;AACA7C,SAAI,CAAC4C,QAAL,CAAcE,gBAAd,CAA+BC,OAA/B,CAAuC;AACnC/C,WAAI,CAACkB,SAAL,CAAe,IAAf;AACH,KAFD,EAvD+E,CA2D/E;;;AACA,QAAItB,OAAO,CAACqB,WAAR,IAAuBpB,KAAK,CAACgB,YAAjC,EAA+C;AAC3C,UAAMmC,MAAM,GAAGnD,KAAK,CAACgB,YAArB;AAEA,UAAMoC,OAAO,GAAG1D,OAAO,CAAC2D,OAAR,EAAhB;AACA,UAAMC,SAAS,GAAG5D,OAAO,CAAC6D,eAAR,CAAwBH,OAAxB,EAAiCD,MAAM,CAACK,aAAP,EAAjC,CAAlB;AACAF,eAAS,CAACG,SAAV;AAEAtD,WAAI,CAACuD,QAAL,CAAcC,CAAd,GAAkBnD,IAAI,CAACoD,IAAL,CAAUlE,OAAO,CAACmE,GAAR,CAAYT,OAAZ,EAAqBE,SAArB,CAAV,CAAlB;AACH;;AAEDnD,SAAI,CAAC2D,kBAAL,CAAwB3D,KAAI,CAAC4D,YAA7B;;;AACH;;AAjPDC,wBAAW5D,qBAAX,EAAW,SAAX,EAAkB;AAHlB;;;SAGA;AACI,aAAO,KAAK2C,QAAZ;AACH,KAFiB;;AAIlB;;;SAGA,aAAmBkB,UAAnB,EAAgC;AAC5B,UAAI,KAAKlB,QAAL,KAAkBkB,UAAtB,EAAkC;AAC9B;AACH;;AACD,WAAKlB,QAAL,GAAgBkB,UAAhB;;AACA,UAAI,KAAK9C,iBAAT,EAA4B;AACxB,aAAK4B,QAAL,CAAcmB,KAAd,GAAsB5E,OAAO,CAAC6E,iBAA9B;AACA,aAAKpB,QAAL,CAAcqB,KAAd,GAAsB9E,OAAO,CAAC6E,iBAA9B;AACA,aAAKrC,SAAL,CAAeuC,cAAf,GAAgC,KAAKtB,QAArC;AACH,OAJD,MAIO;AACH,aAAKA,QAAL,CAAcuB,eAAd,GAAgChF,OAAO,CAACiF,mCAAxC,CADG,CAC0E;;AAC7E,aAAKxB,QAAL,CAAcqB,KAAd,GAAsB9E,OAAO,CAAC6E,iBAA9B;AACA,aAAKrC,SAAL,CAAe0C,iBAAf,GAAmC,KAAKzB,QAAxC;AACH;;AACD,WAAKe,kBAAL,CAAwB,KAAKC,YAA7B;AACH,KAtBiB;qBAAA;;AAAA,GAAlB;AAoCAC,wBAAW5D,qBAAX,EAAW,MAAX,EAAe;AAHf;;;SAGA;AACI,aAAO,KAAKmB,KAAZ;AACH,KAFc;qBAAA;;AAAA,GAAf;AAaAyC,wBAAW5D,qBAAX,EAAW,eAAX,EAAwB;AAJxB;;;;SAIA;AACI,aAAO,KAAK0B,SAAL,CAAeE,aAAtB;AACH,KAFuB;SAGxB,aAAyByC,KAAzB,EAAsC;AAClC,WAAK3C,SAAL,CAAeE,aAAf,GAA+ByC,KAA/B;AACH,KALuB;qBAAA;;AAAA,GAAxB;AAcAT,wBAAW5D,qBAAX,EAAW,aAAX,EAAsB;AANtB;;;;;;SAMA;AACI,aAAO,KAAK2D,YAAZ;AACH,KAFqB;;AAGtB;;;;;;SAMA,aAAuBU,KAAvB,EAAoC;AAChC,UAAI,KAAKV,YAAL,KAAsBU,KAA1B,EAAiC;AAC7B;AACH;;AAED,WAAKX,kBAAL,CAAwBW,KAAxB;AACH,KAfqB;qBAAA;;AAAA,GAAtB;AAoBAT,wBAAW5D,qBAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA;AACI,aAAO,KAAKsC,SAAZ;AACH,KAFkB;;AAInB;;;SAGA,aAAoBgC,OAApB,EAAoC;AAChC,WAAKhC,SAAL,GAAiBgC,OAAjB;;AACA,WAAKrC,aAAL,CAAmBO,UAAnB,CAA8B8B,OAA9B;;AACA,WAAKZ,kBAAL,CAAwB,KAAKC,YAA7B;AACH,KAXkB;qBAAA;;AAAA,GAAnB;AAgBAC,wBAAW5D,qBAAX,EAAW,UAAX,EAAmB;AAKnB;;;SAGA;AACI,aAAO,KAAKyC,SAAZ;AACH,KAVkB;;AAHnB;;;SAGA,aAAoB6B,OAApB,EAAoC;AAChC,WAAK7B,SAAL,GAAiB6B,OAAjB;;AACA,WAAKZ,kBAAL,CAAwB,KAAKC,YAA7B;AACH,KAHkB;qBAAA;;AAAA,GAAnB;AAeAC,wBAAW5D,qBAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA;AACI,aAAO,KAAK0B,SAAZ;AACH,KAFkB;qBAAA;;AAAA,GAAnB;;AAmIU1B,6CAAV,UAA6BqE,KAA7B,EAA0C;AAA1C;;AACI,SAAKE,MAAL,CAAYC,8BAAZ,CAA2CC,MAA3C,CAAkD,KAAKC,6BAAvD;;AACA,SAAKf,YAAL,GAAoBU,KAApB,CAFsC,CAItC;;AACA,SAAK1B,QAAL,CAAcgC,MAAd,GAAuB,CAAvB;AACA,SAAKhC,QAAL,CAAciC,MAAd,GAAuB,CAAvB;AACA,SAAKjC,QAAL,CAAckC,OAAd,GAAwB,CAAxB;AACA,SAAKlC,QAAL,CAAcmC,OAAd,GAAwB,CAAxB;AACA,SAAKnC,QAAL,CAAcoC,IAAd,GAAqB,CAArB;;AAEA,YAAQV,KAAR;AACI,WAAKrE,WAAW,CAACC,eAAjB;AACI,YAAI,KAAKqC,SAAT,EAAoB;AAChB,eAAKK,QAAL,CAAcgC,MAAd,GAAuB,CAAvB;AACA,eAAKhC,QAAL,CAAckC,OAAd,GAAwB,CAAC,CAAzB;AACH;;AACD;;AACJ,WAAK7E,WAAW,CAACgF,eAAjB;AAAkC;AAC9B;AACA;AACA,eAAKrC,QAAL,CAAcgC,MAAd,GAAuB,KAAKrC,SAAL,GAAiB,OAAjB,GAA2B,GAAlD;AACA,cAAM2C,aAAW,GAAG,KAAK3C,SAAL,GAAiB,GAAjB,GAAuB,GAA3C;AACA,cAAM4C,YAAU,GAAG,KAAK5C,SAAL,GAAiB,CAAC,GAAlB,GAAwB,GAA3C;AACA,eAAKoC,6BAAL,GAAqC,KAAKH,MAAL,CAAYC,8BAAZ,CAA2CW,GAA3C,CAA+C,UAACpC,MAAD,EAAO;AACvF,gBAAIqC,aAAa,GAAGrC,MAAM,CAACqC,aAA3B;;AACA,gBAAIrF,KAAI,CAAC0C,SAAT,EAAoB;AAChB2C,2BAAa,GAAG,CAACA,aAAjB;AACH;;AACD,gBAAIA,aAAJ,EAAmB;AACfrF,mBAAI,CAAC4C,QAAL,CAAckC,OAAd,GAAwBI,aAAxB;AACH,aAFD,MAEO;AACHlF,mBAAI,CAAC4C,QAAL,CAAckC,OAAd,GAAwBK,YAAxB;AACH;AACJ,WAVoC,CAArC;AAWA;AACH;;AACD,WAAKlF,WAAW,CAACqF,cAAjB;AACI;AACA;AACA,aAAK1C,QAAL,CAAciC,MAAd,GAAuB,KAAKtC,SAAL,GAAiB,OAAjB,GAA2B,GAAlD;AACA,aAAKoC,6BAAL,GAAqC,KAAKH,MAAL,CAAYC,8BAAZ,CAA2CW,GAA3C,CAA+C,UAACpC,MAAD,EAAO;AACvF,cAAIqC,aAAa,GAAGrC,MAAM,CAACqC,aAA3B,CADuF,CAEvF;;AACA,cAAIrF,KAAI,CAAC0C,SAAT,EAAoB;AAChB2C,yBAAa,GAAG,CAACA,aAAjB;AACH;;AACDrF,eAAI,CAAC4C,QAAL,CAAcmC,OAAd,GAAwBM,aAAa,GAAG,GAAH,GAAS,GAA9C;AACH,SAPoC,CAArC;AAQA;AAtCR;AAwCH,GAnDS;AAqDV;;;;;;;AAKOpF,kCAAP,UAAesF,YAAf,EAAuCC,0BAAvC,EAAyE;AAAlC;AAAAA;AAAkC;;AACrE,SAAK5C,QAAL,CAAc6C,OAAd;;AACA,SAAKrE,KAAL,CAAWqE,OAAX;;AACA,SAAK9D,SAAL,CAAe8D,OAAf;;AAEA,SAAKjB,MAAL,CAAYC,8BAAZ,CAA2CC,MAA3C,CAAkD,KAAKC,6BAAvD;;AACA,SAAKe,qBAAL,CAA2BC,KAA3B;AACA,SAAK7C,gBAAL,CAAsB6C,KAAtB;;AAEA5F,qBAAM0F,OAAN,CAAaG,IAAb,CAAa,IAAb,EAAcL,YAAd,EAA4BC,0BAA5B;AACH,GAVM;AAzUP;;;;;AAGuBvF,gCAAkB,CAAlB;AACvB;;;;AAGuBA,+BAAiB,CAAjB;AACvB;;;;AAGuBA,gCAAkB,CAAlB;AAyU3B;AAAC,CArVD,CAA6DhB,aAA7D;;SAAsBgB","names":["TransformNode","Mesh","Texture","BackgroundMaterial","CreateSphere","Observable","Vector3","Axis","__extends","name","textureUrlOrElement","options","scene","onError","_super","_this","TextureDome","MODE_MONOSCOPIC","getScene","resolution","Math","abs","clickToPlay","Boolean","autoPlay","undefined","loop","size","activeCamera","maxZ","useDirectMapping","_useDirectMapping","faceForward","_setReady","mesh","_mesh","segments","diameter","updatable","sideOrientation","BACKSIDE","material","_material","useEquirectangularFOV","fovMultiplier","opacityFresnel","texture","_initTexture","parent","_halfDomeMask","slice","rotate","X","PI","_halfDome","halfDomeMode","setEnabled","_crossEye","crossEyeMode","_texture","anisotropicFilteringLevel","onLoadObservable","addOnce","camera","forward","Forward","direction","TransformNormal","getViewMatrix","normalize","rotation","y","acos","Dot","_changeTextureMode","_textureMode","Object","newTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","diffuseTexture","coordinatesMode","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","reflectionTexture","value","enabled","_scene","onBeforeCameraRenderObservable","remove","_onBeforeCameraRenderObserver","uScale","vScale","uOffset","vOffset","vAng","MODE_SIDEBYSIDE","rightOffset_1","leftOffset_1","add","isRightCamera","MODE_TOPBOTTOM","doNotRecurse","disposeMaterialAndTextures","dispose","onLoadErrorObservable","clear","call"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Helpers/textureDome.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Axis } from \"../Maths/math\";\r\n\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\n\r\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\r\n    /**\r\n     * Define the source as a Monoscopic panoramic 360/180.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = 0;\r\n    /**\r\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = 1;\r\n    /**\r\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = 2;\r\n\r\n    private _halfDome: boolean = false;\r\n    private _crossEye: boolean = false;\r\n\r\n    protected _useDirectMapping = false;\r\n\r\n    /**\r\n     * The texture being displayed on the sphere\r\n     */\r\n    protected _texture: T;\r\n\r\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\r\n    public get texture(): T {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\r\n    public set texture(newTexture: T) {\r\n        if (this._texture === newTexture) {\r\n            return;\r\n        }\r\n        this._texture = newTexture;\r\n        if (this._useDirectMapping) {\r\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.diffuseTexture = this._texture;\r\n        } else {\r\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.reflectionTexture = this._texture;\r\n        }\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * The skybox material\r\n     */\r\n    protected _material: BackgroundMaterial;\r\n\r\n    /**\r\n     * The surface used for the dome\r\n     */\r\n    protected _mesh: Mesh;\r\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\r\n    public get mesh(): Mesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\r\n     */\r\n    private _halfDomeMask: Mesh;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._material.fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        this._material.fovMultiplier = value;\r\n    }\r\n\r\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public get textureMode(): number {\r\n        return this._textureMode;\r\n    }\r\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public set textureMode(value: number) {\r\n        if (this._textureMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._changeTextureMode(value);\r\n    }\r\n\r\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\r\n    public get halfDome(): boolean {\r\n        return this._halfDome;\r\n    }\r\n\r\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\r\n    public set halfDome(enabled: boolean) {\r\n        this._halfDome = enabled;\r\n        this._halfDomeMask.setEnabled(enabled);\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\r\n    public set crossEye(enabled: boolean) {\r\n        this._crossEye = enabled;\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\r\n    public get crossEye(): boolean {\r\n        return this._crossEye;\r\n    }\r\n\r\n    /**\r\n     * The background material of this dome.\r\n     */\r\n    public get material(): BackgroundMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /**\r\n     * Observable raised when an error occurred while loading the texture\r\n     */\r\n    public onLoadErrorObservable = new Observable<string>();\r\n    /**\r\n     * Observable raised when the texture finished loading\r\n     */\r\n    public onLoadObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n     * @param name Element's name, child elements will append suffixes for their own names.\r\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n     * @param options An object containing optional or exposed sub element properties\r\n     * @param options.resolution\r\n     * @param options.clickToPlay\r\n     * @param options.autoPlay\r\n     * @param options.loop\r\n     * @param options.size\r\n     * @param options.poster\r\n     * @param options.faceForward\r\n     * @param options.useDirectMapping\r\n     * @param options.halfDomeMode\r\n     * @param options.crossEyeMode\r\n     * @param options.generateMipMaps\r\n     * @param options.mesh\r\n     * @param scene\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        name: string,\r\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\r\n        options: {\r\n            resolution?: number;\r\n            clickToPlay?: boolean;\r\n            autoPlay?: boolean;\r\n            loop?: boolean;\r\n            size?: number;\r\n            poster?: string;\r\n            faceForward?: boolean;\r\n            useDirectMapping?: boolean;\r\n            halfDomeMode?: boolean;\r\n            crossEyeMode?: boolean;\r\n            generateMipMaps?: boolean;\r\n            mesh?: Mesh;\r\n        },\r\n        scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(name, scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        // set defaults and manage values\r\n        name = name || \"textureDome\";\r\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\r\n        options.clickToPlay = Boolean(options.clickToPlay);\r\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\r\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\r\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\r\n\r\n        if (options.useDirectMapping === undefined) {\r\n            this._useDirectMapping = true;\r\n        } else {\r\n            this._useDirectMapping = options.useDirectMapping;\r\n        }\r\n\r\n        if (options.faceForward === undefined) {\r\n            options.faceForward = true;\r\n        }\r\n\r\n        this._setReady(false);\r\n        if (!options.mesh) {\r\n            this._mesh = CreateSphere(name + \"_mesh\", { segments: options.resolution, diameter: options.size, updatable: false, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        } else {\r\n            this._mesh = options.mesh;\r\n        }\r\n        // configure material\r\n        const material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\r\n        material.useEquirectangularFOV = true;\r\n        material.fovMultiplier = 1.0;\r\n        material.opacityFresnel = false;\r\n\r\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\r\n        this.texture = texture;\r\n\r\n        // configure mesh\r\n        this._mesh.material = material;\r\n        this._mesh.parent = this;\r\n\r\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\r\n        this._halfDomeMask = CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\r\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\r\n        this._halfDomeMask.parent = this._mesh;\r\n        this._halfDome = !!options.halfDomeMode;\r\n        // enable or disable according to the settings\r\n        this._halfDomeMask.setEnabled(this._halfDome);\r\n        this._crossEye = !!options.crossEyeMode;\r\n\r\n        // create\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n        this._texture.onLoadObservable.addOnce(() => {\r\n            this._setReady(true);\r\n        });\r\n\r\n        // Initial rotation\r\n        if (options.faceForward && scene.activeCamera) {\r\n            const camera = scene.activeCamera;\r\n\r\n            const forward = Vector3.Forward();\r\n            const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\r\n            direction.normalize();\r\n\r\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\r\n        }\r\n\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\r\n\r\n    protected _changeTextureMode(value: number): void {\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this._textureMode = value;\r\n\r\n        // Default Setup and Reset.\r\n        this._texture.uScale = 1;\r\n        this._texture.vScale = 1;\r\n        this._texture.uOffset = 0;\r\n        this._texture.vOffset = 0;\r\n        this._texture.vAng = 0;\r\n\r\n        switch (value) {\r\n            case TextureDome.MODE_MONOSCOPIC:\r\n                if (this._halfDome) {\r\n                    this._texture.uScale = 2;\r\n                    this._texture.uOffset = -1;\r\n                }\r\n                break;\r\n            case TextureDome.MODE_SIDEBYSIDE: {\r\n                // in half-dome mode the uScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\r\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\r\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    if (isRightCamera) {\r\n                        this._texture.uOffset = rightOffset;\r\n                    } else {\r\n                        this._texture.uOffset = leftOffset;\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case TextureDome.MODE_TOPBOTTOM:\r\n                // in half-dome mode the vScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    // allow \"cross-eye\" if left and right were switched in this mode\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\r\n                });\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.dispose();\r\n        this._mesh.dispose();\r\n        this._material.dispose();\r\n\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this.onLoadErrorObservable.clear();\r\n        this.onLoadObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}