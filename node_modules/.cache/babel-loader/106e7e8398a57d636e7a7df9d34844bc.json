{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Vector3, Vector4 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Condition, ValueCondition } from \"./condition.js\";\nimport { Action } from \"./action.js\";\nimport { DoNothingAction } from \"./directActions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { AbstractActionManager } from \"./abstractActionManager.js\";\n/**\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\n */\n\nvar ActionManager =\n/** @class */\nfunction (_super) {\n  __extends(ActionManager, _super);\n  /**\n   * Creates a new action manager\n   * @param scene defines the hosting scene\n   */\n\n\n  function ActionManager(scene) {\n    var _this = _super.call(this) || this;\n\n    scene = scene || EngineStore.LastCreatedScene;\n\n    if (!scene) {\n      return _this;\n    }\n\n    _this._scene = scene;\n    scene.actionManagers.push(_this);\n    return _this;\n  } // Methods\n\n  /**\n   * Releases all associated resources\n   */\n\n\n  ActionManager.prototype.dispose = function () {\n    var index = this._scene.actionManagers.indexOf(this);\n\n    for (var i = 0; i < this.actions.length; i++) {\n      var action = this.actions[i];\n      ActionManager.Triggers[action.trigger]--;\n\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n    }\n\n    if (index > -1) {\n      this._scene.actionManagers.splice(index, 1);\n    }\n  };\n  /**\n   * Gets hosting scene\n   * @returns the hosting scene\n   */\n\n\n  ActionManager.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\n   * Does this action manager handles actions of any of the given triggers\n   * @param triggers defines the triggers to be tested\n   * @return a boolean indicating whether one (or more) of the triggers is handled\n   */\n\n\n  ActionManager.prototype.hasSpecificTriggers = function (triggers) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (triggers.indexOf(action.trigger) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\n   * speed.\n   * @param triggerA defines the trigger to be tested\n   * @param triggerB defines the trigger to be tested\n   * @return a boolean indicating whether one (or more) of the triggers is handled\n   */\n\n\n  ActionManager.prototype.hasSpecificTriggers2 = function (triggerA, triggerB) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (triggerA == action.trigger || triggerB == action.trigger) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Does this action manager handles actions of a given trigger\n   * @param trigger defines the trigger to be tested\n   * @param parameterPredicate defines an optional predicate to filter triggers by parameter\n   * @return whether the trigger is handled\n   */\n\n\n  ActionManager.prototype.hasSpecificTrigger = function (trigger, parameterPredicate) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (action.trigger === trigger) {\n        if (parameterPredicate) {\n          if (parameterPredicate(action.getTriggerParameter())) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(ActionManager.prototype, \"hasPointerTriggers\", {\n    /**\n     * Does this action manager has pointer triggers\n     */\n    get: function get() {\n      for (var index = 0; index < this.actions.length; index++) {\n        var action = this.actions[index];\n\n        if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ActionManager.prototype, \"hasPickTriggers\", {\n    /**\n     * Does this action manager has pick triggers\n     */\n    get: function get() {\n      for (var index = 0; index < this.actions.length; index++) {\n        var action = this.actions[index];\n\n        if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Registers an action to this action manager\n   * @param action defines the action to be registered\n   * @return the action amended (prepared) after registration\n   */\n\n  ActionManager.prototype.registerAction = function (action) {\n    if (action.trigger === ActionManager.OnEveryFrameTrigger) {\n      if (this.getScene().actionManager !== this) {\n        Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\n        return null;\n      }\n    }\n\n    this.actions.push(action);\n\n    if (ActionManager.Triggers[action.trigger]) {\n      ActionManager.Triggers[action.trigger]++;\n    } else {\n      ActionManager.Triggers[action.trigger] = 1;\n    }\n\n    action._actionManager = this;\n\n    action._prepare();\n\n    return action;\n  };\n  /**\n   * Unregisters an action to this action manager\n   * @param action defines the action to be unregistered\n   * @return a boolean indicating whether the action has been unregistered\n   */\n\n\n  ActionManager.prototype.unregisterAction = function (action) {\n    var index = this.actions.indexOf(action);\n\n    if (index !== -1) {\n      this.actions.splice(index, 1);\n      ActionManager.Triggers[action.trigger] -= 1;\n\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n\n      action._actionManager = null;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Process a specific trigger\n   * @param trigger defines the trigger to process\n   * @param evt defines the event details to be processed\n   */\n\n\n  ActionManager.prototype.processTrigger = function (trigger, evt) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (action.trigger === trigger) {\n        if (evt) {\n          if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\n            var parameter = action.getTriggerParameter();\n\n            if (parameter && parameter !== evt.sourceEvent.keyCode) {\n              if (!parameter.toLowerCase) {\n                continue;\n              }\n\n              var lowerCase = parameter.toLowerCase();\n\n              if (lowerCase !== evt.sourceEvent.key) {\n                var unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\n                var actualkey = String.fromCharCode(unicode).toLowerCase();\n\n                if (actualkey !== lowerCase) {\n                  continue;\n                }\n              }\n            }\n          }\n        }\n\n        action._executeCurrent(evt);\n      }\n    }\n  };\n  /**\n   * @param target\n   * @param propertyPath\n   * @hidden\n   */\n\n\n  ActionManager.prototype._getEffectiveTarget = function (target, propertyPath) {\n    var properties = propertyPath.split(\".\");\n\n    for (var index = 0; index < properties.length - 1; index++) {\n      target = target[properties[index]];\n    }\n\n    return target;\n  };\n  /**\n   * @param propertyPath\n   * @hidden\n   */\n\n\n  ActionManager.prototype._getProperty = function (propertyPath) {\n    var properties = propertyPath.split(\".\");\n    return properties[properties.length - 1];\n  };\n  /**\n   * Serialize this manager to a JSON object\n   * @param name defines the property name to store this manager\n   * @returns a JSON representation of this manager\n   */\n\n\n  ActionManager.prototype.serialize = function (name) {\n    var root = {\n      children: new Array(),\n      name: name,\n      type: 3,\n      properties: new Array() // Empty for root but required\n\n    };\n\n    for (var i = 0; i < this.actions.length; i++) {\n      var triggerObject = {\n        type: 0,\n        children: new Array(),\n        name: ActionManager.GetTriggerName(this.actions[i].trigger),\n        properties: new Array()\n      };\n      var triggerOptions = this.actions[i].triggerOptions;\n\n      if (triggerOptions && typeof triggerOptions !== \"number\") {\n        if (triggerOptions.parameter instanceof Node) {\n          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\n        } else {\n          var parameter = {};\n          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\n\n          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\n            parameter._meshId = triggerOptions.parameter.mesh.id;\n          }\n\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: parameter\n          });\n        }\n      } // Serialize child action, recursively\n\n\n      this.actions[i].serialize(triggerObject); // Add serialized trigger\n\n      root.children.push(triggerObject);\n    }\n\n    return root;\n  };\n  /**\n   * Creates a new ActionManager from a JSON data\n   * @param parsedActions defines the JSON data to read from\n   * @param object defines the hosting mesh\n   * @param scene defines the hosting scene\n   */\n\n\n  ActionManager.Parse = function (parsedActions, object, scene) {\n    var actionManager = new ActionManager(scene);\n\n    if (object === null) {\n      scene.actionManager = actionManager;\n    } else {\n      object.actionManager = actionManager;\n    } // instanciate a new object\n\n\n    var instanciate = function instanciate(name, params) {\n      var internalClassType = GetClass(\"BABYLON.\" + name);\n\n      if (internalClassType) {\n        var newInstance = Object.create(internalClassType.prototype); // eslint-disable-next-line prefer-spread\n\n        newInstance.constructor.apply(newInstance, params);\n        return newInstance;\n      }\n    };\n\n    var parseParameter = function parseParameter(name, value, target, propertyPath) {\n      if (propertyPath === null) {\n        // String, boolean or float\n        var floatValue = parseFloat(value);\n\n        if (value === \"true\" || value === \"false\") {\n          return value === \"true\";\n        } else {\n          return isNaN(floatValue) ? value : floatValue;\n        }\n      }\n\n      var effectiveTarget = propertyPath.split(\".\");\n      var values = value.split(\",\"); // Get effective Target\n\n      for (var i = 0; i < effectiveTarget.length; i++) {\n        target = target[effectiveTarget[i]];\n      } // Return appropriate value with its type\n\n\n      if (typeof target === \"boolean\") {\n        return values[0] === \"true\";\n      }\n\n      if (typeof target === \"string\") {\n        return values[0];\n      } // Parameters with multiple values such as Vector3 etc.\n\n\n      var split = new Array();\n\n      for (var i = 0; i < values.length; i++) {\n        split.push(parseFloat(values[i]));\n      }\n\n      if (target instanceof Vector3) {\n        return Vector3.FromArray(split);\n      }\n\n      if (target instanceof Vector4) {\n        return Vector4.FromArray(split);\n      }\n\n      if (target instanceof Color3) {\n        return Color3.FromArray(split);\n      }\n\n      if (target instanceof Color4) {\n        return Color4.FromArray(split);\n      }\n\n      return parseFloat(values[0]);\n    }; // traverse graph per trigger\n\n\n    var traverse = function traverse(parsedAction, trigger, condition, action, combineArray) {\n      if (combineArray === void 0) {\n        combineArray = null;\n      }\n\n      if (parsedAction.detached) {\n        return;\n      }\n\n      var parameters = new Array();\n      var target = null;\n      var propertyPath = null;\n      var combine = parsedAction.combine && parsedAction.combine.length > 0; // Parameters\n\n      if (parsedAction.type === 2) {\n        parameters.push(actionManager);\n      } else {\n        parameters.push(trigger);\n      }\n\n      if (combine) {\n        var actions = new Array();\n\n        for (var j = 0; j < parsedAction.combine.length; j++) {\n          traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\n        }\n\n        parameters.push(actions);\n      } else {\n        for (var i = 0; i < parsedAction.properties.length; i++) {\n          var value = parsedAction.properties[i].value;\n          var name_1 = parsedAction.properties[i].name;\n          var targetType = parsedAction.properties[i].targetType;\n\n          if (name_1 === \"target\") {\n            if (targetType !== null && targetType === \"SceneProperties\") {\n              value = target = scene;\n            } else {\n              value = target = scene.getNodeByName(value);\n            }\n          } else if (name_1 === \"parent\") {\n            value = scene.getNodeByName(value);\n          } else if (name_1 === \"sound\") {\n            // Can not externalize to component, so only checks for the presence off the API.\n            if (scene.getSoundByName) {\n              value = scene.getSoundByName(value);\n            }\n          } else if (name_1 !== \"propertyPath\") {\n            if (parsedAction.type === 2 && name_1 === \"operator\") {\n              value = ValueCondition[value];\n            } else {\n              value = parseParameter(name_1, value, target, name_1 === \"value\" ? propertyPath : null);\n            }\n          } else {\n            propertyPath = value;\n          }\n\n          parameters.push(value);\n        }\n      }\n\n      if (combineArray === null) {\n        parameters.push(condition);\n      } else {\n        parameters.push(null);\n      } // If interpolate value action\n\n\n      if (parsedAction.name === \"InterpolateValueAction\") {\n        var param = parameters[parameters.length - 2];\n        parameters[parameters.length - 1] = param;\n        parameters[parameters.length - 2] = condition;\n      } // Action or condition(s) and not CombineAction\n\n\n      var newAction = instanciate(parsedAction.name, parameters);\n\n      if (newAction instanceof Condition && condition !== null) {\n        var nothing = new DoNothingAction(trigger, condition);\n\n        if (action) {\n          action.then(nothing);\n        } else {\n          actionManager.registerAction(nothing);\n        }\n\n        action = nothing;\n      }\n\n      if (combineArray === null) {\n        if (newAction instanceof Condition) {\n          condition = newAction;\n          newAction = action;\n        } else {\n          condition = null;\n\n          if (action) {\n            action.then(newAction);\n          } else {\n            actionManager.registerAction(newAction);\n          }\n        }\n      } else {\n        combineArray.push(newAction);\n      }\n\n      for (var i = 0; i < parsedAction.children.length; i++) {\n        traverse(parsedAction.children[i], trigger, condition, newAction, null);\n      }\n    }; // triggers\n\n\n    for (var i = 0; i < parsedActions.children.length; i++) {\n      var triggerParams = void 0;\n      var trigger = parsedActions.children[i];\n\n      if (trigger.properties.length > 0) {\n        var param = trigger.properties[0].value;\n        var value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\n\n        if (value._meshId) {\n          value.mesh = scene.getMeshById(value._meshId);\n        }\n\n        triggerParams = {\n          trigger: ActionManager[trigger.name],\n          parameter: value\n        };\n      } else {\n        triggerParams = ActionManager[trigger.name];\n      }\n\n      for (var j = 0; j < trigger.children.length; j++) {\n        if (!trigger.detached) {\n          traverse(trigger.children[j], triggerParams, null, null);\n        }\n      }\n    }\n  };\n  /**\n   * Get a trigger name by index\n   * @param trigger defines the trigger index\n   * @returns a trigger name\n   */\n\n\n  ActionManager.GetTriggerName = function (trigger) {\n    switch (trigger) {\n      case 0:\n        return \"NothingTrigger\";\n\n      case 1:\n        return \"OnPickTrigger\";\n\n      case 2:\n        return \"OnLeftPickTrigger\";\n\n      case 3:\n        return \"OnRightPickTrigger\";\n\n      case 4:\n        return \"OnCenterPickTrigger\";\n\n      case 5:\n        return \"OnPickDownTrigger\";\n\n      case 6:\n        return \"OnPickUpTrigger\";\n\n      case 7:\n        return \"OnLongPressTrigger\";\n\n      case 8:\n        return \"OnPointerOverTrigger\";\n\n      case 9:\n        return \"OnPointerOutTrigger\";\n\n      case 10:\n        return \"OnEveryFrameTrigger\";\n\n      case 11:\n        return \"OnIntersectionEnterTrigger\";\n\n      case 12:\n        return \"OnIntersectionExitTrigger\";\n\n      case 13:\n        return \"OnKeyDownTrigger\";\n\n      case 14:\n        return \"OnKeyUpTrigger\";\n\n      case 15:\n        return \"OnPickOutTrigger\";\n\n      default:\n        return \"\";\n    }\n  };\n  /**\n   * Nothing\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n\n  ActionManager.NothingTrigger = 0;\n  /**\n   * On pick\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPickTrigger = 1;\n  /**\n   * On left pick\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnLeftPickTrigger = 2;\n  /**\n   * On right pick\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnRightPickTrigger = 3;\n  /**\n   * On center pick\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnCenterPickTrigger = 4;\n  /**\n   * On pick down\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPickDownTrigger = 5;\n  /**\n   * On double pick\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnDoublePickTrigger = 6;\n  /**\n   * On pick up\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPickUpTrigger = 7;\n  /**\n   * On pick out.\n   * This trigger will only be raised if you also declared a OnPickDown\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPickOutTrigger = 16;\n  /**\n   * On long press\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnLongPressTrigger = 8;\n  /**\n   * On pointer over\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPointerOverTrigger = 9;\n  /**\n   * On pointer out\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnPointerOutTrigger = 10;\n  /**\n   * On every frame\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnEveryFrameTrigger = 11;\n  /**\n   * On intersection enter\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnIntersectionEnterTrigger = 12;\n  /**\n   * On intersection exit\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnIntersectionExitTrigger = 13;\n  /**\n   * On key down\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnKeyDownTrigger = 14;\n  /**\n   * On key up\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\n   */\n\n  ActionManager.OnKeyUpTrigger = 15;\n  return ActionManager;\n}(AbstractActionManager);\n\nexport { ActionManager };","map":{"version":3,"mappings":"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","names":["Vector3","Vector4","Color3","Color4","Condition","ValueCondition","Action","DoNothingAction","EngineStore","Logger","DeepCopier","GetClass","AbstractActionManager","__extends","scene","_super","LastCreatedScene","_this","_scene","actionManagers","push","ActionManager","index","indexOf","i","actions","length","action","Triggers","trigger","splice","triggers","triggerA","triggerB","parameterPredicate","getTriggerParameter","Object","OnPickTrigger","OnPointerOutTrigger","OnPickUpTrigger","OnEveryFrameTrigger","getScene","actionManager","Warn","_actionManager","_prepare","evt","OnKeyUpTrigger","OnKeyDownTrigger","parameter","sourceEvent","keyCode","toLowerCase","lowerCase","key","unicode","charCode","actualkey","String","fromCharCode","_executeCurrent","target","propertyPath","properties","split","name","root","children","Array","type","triggerObject","GetTriggerName","triggerOptions","Node","_GetTargetProperty","DeepCopy","mesh","_meshId","id","targetType","value","serialize","parsedActions","object","instanciate","params","internalClassType","newInstance","create","prototype","constructor","apply","parseParameter","floatValue","parseFloat","isNaN","effectiveTarget","values","FromArray","traverse","parsedAction","condition","combineArray","detached","parameters","combine","j","NothingTrigger","name_1","getNodeByName","getSoundByName","param","newAction","nothing","then","registerAction","triggerParams","getMeshByName","getMeshById"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Actions/actionManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Condition, ValueCondition } from \"./condition\";\r\nimport type { IAction } from \"./action\";\r\nimport { Action } from \"./action\";\r\nimport { DoNothingAction } from \"./directActions\";\r\n\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IActionEvent } from \"../Actions/actionEvent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { AbstractActionManager } from \"./abstractActionManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\r\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n */\r\nexport class ActionManager extends AbstractActionManager {\r\n    /**\r\n     * Nothing\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly NothingTrigger = Constants.ACTION_NothingTrigger;\r\n\r\n    /**\r\n     * On pick\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPickTrigger = Constants.ACTION_OnPickTrigger;\r\n\r\n    /**\r\n     * On left pick\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnLeftPickTrigger = Constants.ACTION_OnLeftPickTrigger;\r\n\r\n    /**\r\n     * On right pick\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnRightPickTrigger = Constants.ACTION_OnRightPickTrigger;\r\n\r\n    /**\r\n     * On center pick\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnCenterPickTrigger = Constants.ACTION_OnCenterPickTrigger;\r\n\r\n    /**\r\n     * On pick down\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPickDownTrigger = Constants.ACTION_OnPickDownTrigger;\r\n\r\n    /**\r\n     * On double pick\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnDoublePickTrigger = Constants.ACTION_OnDoublePickTrigger;\r\n\r\n    /**\r\n     * On pick up\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPickUpTrigger = Constants.ACTION_OnPickUpTrigger;\r\n    /**\r\n     * On pick out.\r\n     * This trigger will only be raised if you also declared a OnPickDown\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPickOutTrigger = Constants.ACTION_OnPickOutTrigger;\r\n\r\n    /**\r\n     * On long press\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnLongPressTrigger = Constants.ACTION_OnLongPressTrigger;\r\n\r\n    /**\r\n     * On pointer over\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPointerOverTrigger = Constants.ACTION_OnPointerOverTrigger;\r\n\r\n    /**\r\n     * On pointer out\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnPointerOutTrigger = Constants.ACTION_OnPointerOutTrigger;\r\n\r\n    /**\r\n     * On every frame\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnEveryFrameTrigger = Constants.ACTION_OnEveryFrameTrigger;\r\n    /**\r\n     * On intersection enter\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnIntersectionEnterTrigger = Constants.ACTION_OnIntersectionEnterTrigger;\r\n\r\n    /**\r\n     * On intersection exit\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnIntersectionExitTrigger = Constants.ACTION_OnIntersectionExitTrigger;\r\n\r\n    /**\r\n     * On key down\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnKeyDownTrigger = Constants.ACTION_OnKeyDownTrigger;\r\n\r\n    /**\r\n     * On key up\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n     */\r\n    public static readonly OnKeyUpTrigger = 15;\r\n\r\n    // Members\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new action manager\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        super();\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n\r\n        scene.actionManagers.push(this);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const index = this._scene.actionManagers.indexOf(this);\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const action = this.actions[i];\r\n            ActionManager.Triggers[action.trigger]--;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n        }\r\n\r\n        if (index > -1) {\r\n            this._scene.actionManagers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets hosting scene\r\n     * @returns the hosting scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers\r\n     * @param triggers defines the triggers to be tested\r\n     * @return a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers(triggers: number[]): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggers.indexOf(action.trigger) > -1) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\r\n     * speed.\r\n     * @param triggerA defines the trigger to be tested\r\n     * @param triggerB defines the trigger to be tested\r\n     * @return a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers2(triggerA: number, triggerB: number): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggerA == action.trigger || triggerB == action.trigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of a given trigger\r\n     * @param trigger defines the trigger to be tested\r\n     * @param parameterPredicate defines an optional predicate to filter triggers by parameter\r\n     * @return whether the trigger is handled\r\n     */\r\n    public hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (parameterPredicate) {\r\n                    if (parameterPredicate(action.getTriggerParameter())) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pointer triggers\r\n     */\r\n    public get hasPointerTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pick triggers\r\n     */\r\n    public get hasPickTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Registers an action to this action manager\r\n     * @param action defines the action to be registered\r\n     * @return the action amended (prepared) after registration\r\n     */\r\n    public registerAction(action: IAction): Nullable<IAction> {\r\n        if (action.trigger === ActionManager.OnEveryFrameTrigger) {\r\n            if (this.getScene().actionManager !== this) {\r\n                Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        this.actions.push(action);\r\n\r\n        if (ActionManager.Triggers[action.trigger]) {\r\n            ActionManager.Triggers[action.trigger]++;\r\n        } else {\r\n            ActionManager.Triggers[action.trigger] = 1;\r\n        }\r\n\r\n        action._actionManager = this;\r\n        action._prepare();\r\n\r\n        return action;\r\n    }\r\n\r\n    /**\r\n     * Unregisters an action to this action manager\r\n     * @param action defines the action to be unregistered\r\n     * @return a boolean indicating whether the action has been unregistered\r\n     */\r\n    public unregisterAction(action: IAction): Boolean {\r\n        const index = this.actions.indexOf(action);\r\n        if (index !== -1) {\r\n            this.actions.splice(index, 1);\r\n            ActionManager.Triggers[action.trigger] -= 1;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n            action._actionManager = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Process a specific trigger\r\n     * @param trigger defines the trigger to process\r\n     * @param evt defines the event details to be processed\r\n     */\r\n    public processTrigger(trigger: number, evt?: IActionEvent): void {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (evt) {\r\n                    if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\r\n                        const parameter = action.getTriggerParameter();\r\n\r\n                        if (parameter && parameter !== evt.sourceEvent.keyCode) {\r\n                            if (!parameter.toLowerCase) {\r\n                                continue;\r\n                            }\r\n                            const lowerCase = parameter.toLowerCase();\r\n\r\n                            if (lowerCase !== evt.sourceEvent.key) {\r\n                                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\r\n                                const actualkey = String.fromCharCode(unicode).toLowerCase();\r\n                                if (actualkey !== lowerCase) {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                action._executeCurrent(evt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param target\r\n     * @param propertyPath\r\n     * @hidden\r\n     */\r\n    public _getEffectiveTarget(target: any, propertyPath: string): any {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        for (let index = 0; index < properties.length - 1; index++) {\r\n            target = target[properties[index]];\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * @param propertyPath\r\n     * @hidden\r\n     */\r\n    public _getProperty(propertyPath: string): string {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        return properties[properties.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Serialize this manager to a JSON object\r\n     * @param name defines the property name to store this manager\r\n     * @returns a JSON representation of this manager\r\n     */\r\n    public serialize(name: string): any {\r\n        const root = {\r\n            children: new Array(),\r\n            name: name,\r\n            type: 3, // Root node\r\n            properties: new Array(), // Empty for root but required\r\n        };\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const triggerObject = {\r\n                type: 0, // Trigger\r\n                children: new Array(),\r\n                name: ActionManager.GetTriggerName(this.actions[i].trigger),\r\n                properties: new Array(),\r\n            };\r\n\r\n            const triggerOptions = this.actions[i].triggerOptions;\r\n\r\n            if (triggerOptions && typeof triggerOptions !== \"number\") {\r\n                if (triggerOptions.parameter instanceof Node) {\r\n                    triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\r\n                } else {\r\n                    const parameter = <any>{};\r\n                    DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\r\n\r\n                    if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\r\n                        parameter._meshId = triggerOptions.parameter.mesh.id;\r\n                    }\r\n\r\n                    triggerObject.properties.push({ name: \"parameter\", targetType: null, value: parameter });\r\n                }\r\n            }\r\n\r\n            // Serialize child action, recursively\r\n            this.actions[i].serialize(triggerObject);\r\n\r\n            // Add serialized trigger\r\n            root.children.push(triggerObject);\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ActionManager from a JSON data\r\n     * @param parsedActions defines the JSON data to read from\r\n     * @param object defines the hosting mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public static Parse(parsedActions: any, object: Nullable<AbstractMesh>, scene: Scene): void {\r\n        const actionManager = new ActionManager(scene);\r\n        if (object === null) {\r\n            scene.actionManager = actionManager;\r\n        } else {\r\n            object.actionManager = actionManager;\r\n        }\r\n\r\n        // instanciate a new object\r\n        const instanciate = (name: string, params: Array<any>): any => {\r\n            const internalClassType = GetClass(\"BABYLON.\" + name);\r\n            if (internalClassType) {\r\n                const newInstance: Object = Object.create(internalClassType.prototype);\r\n                // eslint-disable-next-line prefer-spread\r\n                newInstance.constructor.apply(newInstance, params);\r\n                return newInstance;\r\n            }\r\n        };\r\n\r\n        const parseParameter = (name: string, value: string, target: any, propertyPath: Nullable<string>): any => {\r\n            if (propertyPath === null) {\r\n                // String, boolean or float\r\n                const floatValue = parseFloat(value);\r\n\r\n                if (value === \"true\" || value === \"false\") {\r\n                    return value === \"true\";\r\n                } else {\r\n                    return isNaN(floatValue) ? value : floatValue;\r\n                }\r\n            }\r\n\r\n            const effectiveTarget = propertyPath.split(\".\");\r\n            const values = value.split(\",\");\r\n\r\n            // Get effective Target\r\n            for (let i = 0; i < effectiveTarget.length; i++) {\r\n                target = target[effectiveTarget[i]];\r\n            }\r\n\r\n            // Return appropriate value with its type\r\n            if (typeof target === \"boolean\") {\r\n                return values[0] === \"true\";\r\n            }\r\n\r\n            if (typeof target === \"string\") {\r\n                return values[0];\r\n            }\r\n\r\n            // Parameters with multiple values such as Vector3 etc.\r\n            const split = new Array<number>();\r\n            for (let i = 0; i < values.length; i++) {\r\n                split.push(parseFloat(values[i]));\r\n            }\r\n\r\n            if (target instanceof Vector3) {\r\n                return Vector3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Vector4) {\r\n                return Vector4.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color3) {\r\n                return Color3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color4) {\r\n                return Color4.FromArray(split);\r\n            }\r\n\r\n            return parseFloat(values[0]);\r\n        };\r\n\r\n        // traverse graph per trigger\r\n        const traverse = (parsedAction: any, trigger: any, condition: Nullable<Condition>, action: Nullable<Action>, combineArray: Nullable<Array<Action>> = null) => {\r\n            if (parsedAction.detached) {\r\n                return;\r\n            }\r\n\r\n            const parameters = new Array<any>();\r\n            let target: any = null;\r\n            let propertyPath: Nullable<string> = null;\r\n            const combine = parsedAction.combine && parsedAction.combine.length > 0;\r\n\r\n            // Parameters\r\n            if (parsedAction.type === 2) {\r\n                parameters.push(actionManager);\r\n            } else {\r\n                parameters.push(trigger);\r\n            }\r\n\r\n            if (combine) {\r\n                const actions = new Array<Action>();\r\n                for (let j = 0; j < parsedAction.combine.length; j++) {\r\n                    traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\r\n                }\r\n                parameters.push(actions);\r\n            } else {\r\n                for (let i = 0; i < parsedAction.properties.length; i++) {\r\n                    let value = parsedAction.properties[i].value;\r\n                    const name = parsedAction.properties[i].name;\r\n                    const targetType = parsedAction.properties[i].targetType;\r\n\r\n                    if (name === \"target\") {\r\n                        if (targetType !== null && targetType === \"SceneProperties\") {\r\n                            value = target = scene;\r\n                        } else {\r\n                            value = target = scene.getNodeByName(value);\r\n                        }\r\n                    } else if (name === \"parent\") {\r\n                        value = scene.getNodeByName(value);\r\n                    } else if (name === \"sound\") {\r\n                        // Can not externalize to component, so only checks for the presence off the API.\r\n                        if (scene.getSoundByName) {\r\n                            value = scene.getSoundByName(value);\r\n                        }\r\n                    } else if (name !== \"propertyPath\") {\r\n                        if (parsedAction.type === 2 && name === \"operator\") {\r\n                            value = (<any>ValueCondition)[value];\r\n                        } else {\r\n                            value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\r\n                        }\r\n                    } else {\r\n                        propertyPath = value;\r\n                    }\r\n\r\n                    parameters.push(value);\r\n                }\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                parameters.push(condition);\r\n            } else {\r\n                parameters.push(null);\r\n            }\r\n\r\n            // If interpolate value action\r\n            if (parsedAction.name === \"InterpolateValueAction\") {\r\n                const param = parameters[parameters.length - 2];\r\n                parameters[parameters.length - 1] = param;\r\n                parameters[parameters.length - 2] = condition;\r\n            }\r\n\r\n            // Action or condition(s) and not CombineAction\r\n            let newAction = instanciate(parsedAction.name, parameters);\r\n\r\n            if (newAction instanceof Condition && condition !== null) {\r\n                const nothing = new DoNothingAction(trigger, condition);\r\n\r\n                if (action) {\r\n                    action.then(nothing);\r\n                } else {\r\n                    actionManager.registerAction(nothing);\r\n                }\r\n\r\n                action = nothing;\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                if (newAction instanceof Condition) {\r\n                    condition = newAction;\r\n                    newAction = action;\r\n                } else {\r\n                    condition = null;\r\n                    if (action) {\r\n                        action.then(newAction);\r\n                    } else {\r\n                        actionManager.registerAction(newAction);\r\n                    }\r\n                }\r\n            } else {\r\n                combineArray.push(newAction);\r\n            }\r\n\r\n            for (let i = 0; i < parsedAction.children.length; i++) {\r\n                traverse(parsedAction.children[i], trigger, condition, newAction, null);\r\n            }\r\n        };\r\n\r\n        // triggers\r\n        for (let i = 0; i < parsedActions.children.length; i++) {\r\n            let triggerParams: any;\r\n            const trigger = parsedActions.children[i];\r\n\r\n            if (trigger.properties.length > 0) {\r\n                const param = trigger.properties[0].value;\r\n                const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\r\n\r\n                if (value._meshId) {\r\n                    value.mesh = scene.getMeshById(value._meshId);\r\n                }\r\n\r\n                triggerParams = { trigger: (<any>ActionManager)[trigger.name], parameter: value };\r\n            } else {\r\n                triggerParams = (<any>ActionManager)[trigger.name];\r\n            }\r\n\r\n            for (let j = 0; j < trigger.children.length; j++) {\r\n                if (!trigger.detached) {\r\n                    traverse(trigger.children[j], triggerParams, null, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a trigger name by index\r\n     * @param trigger defines the trigger index\r\n     * @returns a trigger name\r\n     */\r\n    public static GetTriggerName(trigger: number): string {\r\n        switch (trigger) {\r\n            case 0:\r\n                return \"NothingTrigger\";\r\n            case 1:\r\n                return \"OnPickTrigger\";\r\n            case 2:\r\n                return \"OnLeftPickTrigger\";\r\n            case 3:\r\n                return \"OnRightPickTrigger\";\r\n            case 4:\r\n                return \"OnCenterPickTrigger\";\r\n            case 5:\r\n                return \"OnPickDownTrigger\";\r\n            case 6:\r\n                return \"OnPickUpTrigger\";\r\n            case 7:\r\n                return \"OnLongPressTrigger\";\r\n            case 8:\r\n                return \"OnPointerOverTrigger\";\r\n            case 9:\r\n                return \"OnPointerOutTrigger\";\r\n            case 10:\r\n                return \"OnEveryFrameTrigger\";\r\n            case 11:\r\n                return \"OnIntersectionEnterTrigger\";\r\n            case 12:\r\n                return \"OnIntersectionExitTrigger\";\r\n            case 13:\r\n                return \"OnKeyDownTrigger\";\r\n            case 14:\r\n                return \"OnKeyUpTrigger\";\r\n            case 15:\r\n                return \"OnPickOutTrigger\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}