{"ast":null,"code":"import \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.math.log2.js\";\n\n/**\n * Scalar computation library\n */\nvar Scalar =\n/** @class */\nfunction () {\n  function Scalar() {}\n  /**\n   * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   * @param a number\n   * @param b number\n   * @param epsilon (default = 1.401298E-45)\n   * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   */\n\n\n  Scalar.WithinEpsilon = function (a, b, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = 1.401298e-45;\n    }\n\n    return Math.abs(a - b) <= epsilon;\n  };\n  /**\n   * Returns a string : the upper case translation of the number i to hexadecimal.\n   * @param i number\n   * @returns the upper case translation of the number i to hexadecimal.\n   */\n\n\n  Scalar.ToHex = function (i) {\n    var str = i.toString(16);\n\n    if (i <= 15) {\n      return (\"0\" + str).toUpperCase();\n    }\n\n    return str.toUpperCase();\n  };\n  /**\n   * Returns -1 if value is negative and +1 is value is positive.\n   * @param value the value\n   * @returns the value itself if it's equal to zero.\n   */\n\n\n  Scalar.Sign = function (value) {\n    value = +value; // convert to a number\n\n    if (value === 0 || isNaN(value)) {\n      return value;\n    }\n\n    return value > 0 ? 1 : -1;\n  };\n  /**\n   * Returns the value itself if it's between min and max.\n   * Returns min if the value is lower than min.\n   * Returns max if the value is greater than max.\n   * @param value the value to clmap\n   * @param min the min value to clamp to (default: 0)\n   * @param max the max value to clamp to (default: 1)\n   * @returns the clamped value\n   */\n\n\n  Scalar.Clamp = function (value, min, max) {\n    if (min === void 0) {\n      min = 0;\n    }\n\n    if (max === void 0) {\n      max = 1;\n    }\n\n    return Math.min(max, Math.max(min, value));\n  };\n  /**\n   * the log2 of value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n\n\n  Scalar.Log2 = function (value) {\n    return Math.log(value) * Math.LOG2E;\n  };\n  /**\n   * the floor part of a log2 value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n\n\n  Scalar.ILog2 = function (value) {\n    if (Math.log2) {\n      return Math.floor(Math.log2(value));\n    }\n\n    if (value < 0) {\n      return NaN;\n    } else if (value === 0) {\n      return -Infinity;\n    }\n\n    var n = 0;\n\n    if (value < 1) {\n      while (value < 1) {\n        n++;\n        value = value * 2;\n      }\n\n      n = -n;\n    } else if (value > 1) {\n      while (value > 1) {\n        n++;\n        value = Math.floor(value / 2);\n      }\n    }\n\n    return n;\n  };\n  /**\n   * Loops the value, so that it is never larger than length and never smaller than 0.\n   *\n   * This is similar to the modulo operator but it works with floating point numbers.\n   * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n   * With t = 5 and length = 2.5, the result would be 0.0.\n   * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n   * @param value the value\n   * @param length the length\n   * @returns the looped value\n   */\n\n\n  Scalar.Repeat = function (value, length) {\n    return value - Math.floor(value / length) * length;\n  };\n  /**\n   * Normalize the value between 0.0 and 1.0 using min and max values\n   * @param value value to normalize\n   * @param min max to normalize between\n   * @param max min to normalize between\n   * @returns the normalized value\n   */\n\n\n  Scalar.Normalize = function (value, min, max) {\n    return (value - min) / (max - min);\n  };\n  /**\n   * Denormalize the value from 0.0 and 1.0 using min and max values\n   * @param normalized value to denormalize\n   * @param min max to denormalize between\n   * @param max min to denormalize between\n   * @returns the denormalized value\n   */\n\n\n  Scalar.Denormalize = function (normalized, min, max) {\n    return normalized * (max - min) + min;\n  };\n  /**\n   * Calculates the shortest difference between two given angles given in degrees.\n   * @param current current angle in degrees\n   * @param target target angle in degrees\n   * @returns the delta\n   */\n\n\n  Scalar.DeltaAngle = function (current, target) {\n    var num = Scalar.Repeat(target - current, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return num;\n  };\n  /**\n   * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n   * @param tx value\n   * @param length length\n   * @returns The returned value will move back and forth between 0 and length\n   */\n\n\n  Scalar.PingPong = function (tx, length) {\n    var t = Scalar.Repeat(tx, length * 2.0);\n    return length - Math.abs(t - length);\n  };\n  /**\n   * Interpolates between min and max with smoothing at the limits.\n   *\n   * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n   * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n   * @param from from\n   * @param to to\n   * @param tx value\n   * @returns the smooth stepped value\n   */\n\n\n  Scalar.SmoothStep = function (from, to, tx) {\n    var t = Scalar.Clamp(tx);\n    t = -2.0 * t * t * t + 3.0 * t * t;\n    return to * t + from * (1.0 - t);\n  };\n  /**\n   * Moves a value current towards target.\n   *\n   * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n   * Negative values of maxDelta pushes the value away from target.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting value\n   */\n\n\n  Scalar.MoveTowards = function (current, target, maxDelta) {\n    var result = 0;\n\n    if (Math.abs(target - current) <= maxDelta) {\n      result = target;\n    } else {\n      result = current + Scalar.Sign(target - current) * maxDelta;\n    }\n\n    return result;\n  };\n  /**\n   * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   *\n   * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n   *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting angle\n   */\n\n\n  Scalar.MoveTowardsAngle = function (current, target, maxDelta) {\n    var num = Scalar.DeltaAngle(current, target);\n    var result = 0;\n\n    if (-maxDelta < num && num < maxDelta) {\n      result = target;\n    } else {\n      target = current + num;\n      result = Scalar.MoveTowards(current, target, maxDelta);\n    }\n\n    return result;\n  };\n  /**\n   * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n\n\n  Scalar.Lerp = function (start, end, amount) {\n    return start + (end - start) * amount;\n  };\n  /**\n   * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n\n\n  Scalar.LerpAngle = function (start, end, amount) {\n    var num = Scalar.Repeat(end - start, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return start + num * Scalar.Clamp(amount);\n  };\n  /**\n   * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n   * @param a start value\n   * @param b target value\n   * @param value value between a and b\n   * @returns the inverseLerp value\n   */\n\n\n  Scalar.InverseLerp = function (a, b, value) {\n    var result = 0;\n\n    if (a != b) {\n      result = Scalar.Clamp((value - a) / (b - a));\n    } else {\n      result = 0.0;\n    }\n\n    return result;\n  };\n  /**\n   * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n   * @see http://mathworld.wolfram.com/HermitePolynomial.html\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns hermite result\n   */\n\n\n  Scalar.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n  };\n  /**\n   * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n\n\n  Scalar.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n    var t2 = time * time;\n    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n  };\n  /**\n   * Returns a random float number between and min and max values\n   * @param min min value of random\n   * @param max max value of random\n   * @returns random value\n   */\n\n\n  Scalar.RandomRange = function (min, max) {\n    if (min === max) {\n      return min;\n    }\n\n    return Math.random() * (max - min) + min;\n  };\n  /**\n   * This function returns percentage of a number in a given range.\n   *\n   * RangeToPercent(40,20,60) will return 0.5 (50%)\n   * RangeToPercent(34,0,100) will return 0.34 (34%)\n   * @param number to convert to percentage\n   * @param min min range\n   * @param max max range\n   * @returns the percentage\n   */\n\n\n  Scalar.RangeToPercent = function (number, min, max) {\n    return (number - min) / (max - min);\n  };\n  /**\n   * This function returns number that corresponds to the percentage in a given range.\n   *\n   * PercentToRange(0.34,0,100) will return 34.\n   * @param percent to convert to number\n   * @param min min range\n   * @param max max range\n   * @returns the number\n   */\n\n\n  Scalar.PercentToRange = function (percent, min, max) {\n    return (max - min) * percent + min;\n  };\n  /**\n   * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n   * @param angle The angle to normalize in radian.\n   * @return The converted angle.\n   */\n\n\n  Scalar.NormalizeRadians = function (angle) {\n    // More precise but slower version kept for reference.\n    // angle = angle % Tools.TwoPi;\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n    //if (angle > Math.PI) {\n    //\tangle -= Tools.TwoPi;\n    //}\n    angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n    return angle;\n  };\n  /**\n   * Returns the highest common factor of two integers.\n   * @param a first parameter\n   * @param b second parameter\n   * @return HCF of a and b\n   */\n\n\n  Scalar.HCF = function (a, b) {\n    var r = a % b;\n\n    if (r === 0) {\n      return b;\n    }\n\n    return Scalar.HCF(b, r);\n  };\n  /**\n   * Two pi constants convenient for computation.\n   */\n\n\n  Scalar.TwoPi = Math.PI * 2;\n  return Scalar;\n}();\n\nexport { Scalar };","map":{"version":3,"mappings":"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","names":["Scalar","a","b","epsilon","Math","abs","i","str","toString","toUpperCase","value","isNaN","min","max","log","LOG2E","log2","floor","NaN","Infinity","n","length","normalized","current","target","num","Repeat","tx","t","from","to","Clamp","maxDelta","result","Sign","DeltaAngle","MoveTowards","start","end","amount","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","time","t2","random","number","percent","angle","TwoPi","PI","r","HCF"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Maths/math.scalar.ts"],"sourcesContent":["/**\r\n * Scalar computation library\r\n */\r\nexport class Scalar {\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    public static TwoPi: number = Math.PI * 2;\r\n\r\n    /**\r\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     * @param a number\r\n     * @param b number\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     */\r\n    public static WithinEpsilon(a: number, b: number, epsilon: number = 1.401298e-45): boolean {\r\n        return Math.abs(a - b) <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Returns a string : the upper case translation of the number i to hexadecimal.\r\n     * @param i number\r\n     * @returns the upper case translation of the number i to hexadecimal.\r\n     */\r\n    public static ToHex(i: number): string {\r\n        const str = i.toString(16);\r\n\r\n        if (i <= 15) {\r\n            return (\"0\" + str).toUpperCase();\r\n        }\r\n\r\n        return str.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    public static Sign(value: number): number {\r\n        value = +value; // convert to a number\r\n\r\n        if (value === 0 || isNaN(value)) {\r\n            return value;\r\n        }\r\n\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the value itself if it's between min and max.\r\n     * Returns min if the value is lower than min.\r\n     * Returns max if the value is greater than max.\r\n     * @param value the value to clmap\r\n     * @param min the min value to clamp to (default: 0)\r\n     * @param max the max value to clamp to (default: 1)\r\n     * @returns the clamped value\r\n     */\r\n    public static Clamp(value: number, min = 0, max = 1): number {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static Log2(value: number): number {\r\n        return Math.log(value) * Math.LOG2E;\r\n    }\r\n\r\n    /**\r\n     * the floor part of a log2 value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static ILog2(value: number): number {\r\n        if (Math.log2) {\r\n            return Math.floor(Math.log2(value));\r\n        }\r\n\r\n        if (value < 0) {\r\n            return NaN;\r\n        } else if (value === 0) {\r\n            return -Infinity;\r\n        }\r\n\r\n        let n = 0;\r\n        if (value < 1) {\r\n            while (value < 1) {\r\n                n++;\r\n                value = value * 2;\r\n            }\r\n            n = -n;\r\n        } else if (value > 1) {\r\n            while (value > 1) {\r\n                n++;\r\n                value = Math.floor(value / 2);\r\n            }\r\n        }\r\n\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * Loops the value, so that it is never larger than length and never smaller than 0.\r\n     *\r\n     * This is similar to the modulo operator but it works with floating point numbers.\r\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n     * With t = 5 and length = 2.5, the result would be 0.0.\r\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n     * @param value the value\r\n     * @param length the length\r\n     * @returns the looped value\r\n     */\r\n    public static Repeat(value: number, length: number): number {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n\r\n    /**\r\n     * Normalize the value between 0.0 and 1.0 using min and max values\r\n     * @param value value to normalize\r\n     * @param min max to normalize between\r\n     * @param max min to normalize between\r\n     * @returns the normalized value\r\n     */\r\n    public static Normalize(value: number, min: number, max: number): number {\r\n        return (value - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * Denormalize the value from 0.0 and 1.0 using min and max values\r\n     * @param normalized value to denormalize\r\n     * @param min max to denormalize between\r\n     * @param max min to denormalize between\r\n     * @returns the denormalized value\r\n     */\r\n    public static Denormalize(normalized: number, min: number, max: number): number {\r\n        return normalized * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * Calculates the shortest difference between two given angles given in degrees.\r\n     * @param current current angle in degrees\r\n     * @param target target angle in degrees\r\n     * @returns the delta\r\n     */\r\n    public static DeltaAngle(current: number, target: number): number {\r\n        let num: number = Scalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n     * @param tx value\r\n     * @param length length\r\n     * @returns The returned value will move back and forth between 0 and length\r\n     */\r\n    public static PingPong(tx: number, length: number): number {\r\n        const t: number = Scalar.Repeat(tx, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n\r\n    /**\r\n     * Interpolates between min and max with smoothing at the limits.\r\n     *\r\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tx value\r\n     * @returns the smooth stepped value\r\n     */\r\n    public static SmoothStep(from: number, to: number, tx: number): number {\r\n        let t: number = Scalar.Clamp(tx);\r\n        t = -2.0 * t * t * t + 3.0 * t * t;\r\n        return to * t + from * (1.0 - t);\r\n    }\r\n\r\n    /**\r\n     * Moves a value current towards target.\r\n     *\r\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n     * Negative values of maxDelta pushes the value away from target.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting value\r\n     */\r\n    public static MoveTowards(current: number, target: number, maxDelta: number): number {\r\n        let result: number = 0;\r\n        if (Math.abs(target - current) <= maxDelta) {\r\n            result = target;\r\n        } else {\r\n            result = current + Scalar.Sign(target - current) * maxDelta;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     *\r\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting angle\r\n     */\r\n    public static MoveTowardsAngle(current: number, target: number, maxDelta: number): number {\r\n        const num: number = Scalar.DeltaAngle(current, target);\r\n        let result: number = 0;\r\n        if (-maxDelta < num && num < maxDelta) {\r\n            result = target;\r\n        } else {\r\n            target = current + num;\r\n            result = Scalar.MoveTowards(current, target, maxDelta);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static Lerp(start: number, end: number, amount: number): number {\r\n        return start + (end - start) * amount;\r\n    }\r\n\r\n    /**\r\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static LerpAngle(start: number, end: number, amount: number): number {\r\n        let num: number = Scalar.Repeat(end - start, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return start + num * Scalar.Clamp(amount);\r\n    }\r\n\r\n    /**\r\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n     * @param a start value\r\n     * @param b target value\r\n     * @param value value between a and b\r\n     * @returns the inverseLerp value\r\n     */\r\n    public static InverseLerp(a: number, b: number, value: number): number {\r\n        let result: number = 0;\r\n        if (a != b) {\r\n            result = Scalar.Clamp((value - a) / (b - a));\r\n        } else {\r\n            result = 0.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns hermite result\r\n     */\r\n    public static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(value1: number, tangent1: number, value2: number, tangent2: number, time: number): number {\r\n        const t2 = time * time;\r\n        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\r\n    }\r\n\r\n    /**\r\n     * Returns a random float number between and min and max values\r\n     * @param min min value of random\r\n     * @param max max value of random\r\n     * @returns random value\r\n     */\r\n    public static RandomRange(min: number, max: number): number {\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        return Math.random() * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * This function returns percentage of a number in a given range.\r\n     *\r\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n     * @param number to convert to percentage\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the percentage\r\n     */\r\n    public static RangeToPercent(number: number, min: number, max: number): number {\r\n        return (number - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * This function returns number that corresponds to the percentage in a given range.\r\n     *\r\n     * PercentToRange(0.34,0,100) will return 34.\r\n     * @param percent to convert to number\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the number\r\n     */\r\n    public static PercentToRange(percent: number, min: number, max: number): number {\r\n        return (max - min) * percent + min;\r\n    }\r\n\r\n    /**\r\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n     * @param angle The angle to normalize in radian.\r\n     * @return The converted angle.\r\n     */\r\n    public static NormalizeRadians(angle: number): number {\r\n        // More precise but slower version kept for reference.\r\n        // angle = angle % Tools.TwoPi;\r\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n        //if (angle > Math.PI) {\r\n        //\tangle -= Tools.TwoPi;\r\n        //}\r\n\r\n        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\r\n\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @return HCF of a and b\r\n     */\r\n    public static HCF(a: number, b: number): number {\r\n        const r: number = a % b;\r\n        if (r === 0) {\r\n            return b;\r\n        }\r\n        return Scalar.HCF(b, r);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}