{"ast":null,"code":"import \"core-js/modules/es.array.join.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\n\nvar DepthRenderer =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a depth renderer\n   * @param scene The scene the renderer belongs to\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\n   */\n  function DepthRenderer(scene, type, camera, storeNonLinearDepth, samplingMode) {\n    if (type === void 0) {\n      type = 1;\n    }\n\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (storeNonLinearDepth === void 0) {\n      storeNonLinearDepth = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = this;\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n\n\n    this.enabled = true;\n    /** Force writing the transparent objects into the depth map */\n\n    this.forceDepthWriteTransparentMeshes = false;\n    /**\n     * Specifies that the depth renderer will only be used within\n     * the camera it is created for.\n     * This can help forcing its rendering during the camera processing.\n     */\n\n    this.useOnlyInActiveCamera = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this.isPacked = type === 0;\n\n    if (this.isPacked) {\n      this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n    }\n\n    DepthRenderer._SceneComponentInitialization(this._scene);\n\n    var engine = scene.getEngine();\n    this._camera = camera;\n\n    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n\n      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n    } // Render target\n\n\n    var format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(\"DepthRenderer\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null; // Camera to get depth map from to support multiple concurrent cameras\n\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false; // set default depth value to 1.0 (far away)\n\n    this._depthMap.onClearObservable.add(function (engine) {\n      engine.clear(_this._clearColor, true, true, true);\n    });\n\n    this._depthMap.onBeforeBindObservable.add(function () {\n      var _a;\n\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n    });\n\n    this._depthMap.onAfterUnbindObservable.add(function () {\n      var _a;\n\n      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n    });\n\n    this._depthMap.customIsReadyFunction = function (mesh, refreshRate) {\n      if (!mesh.isReady(false)) {\n        return false;\n      }\n\n      if (refreshRate === 0 && mesh.subMeshes) {\n        // full check: check that the effects are ready\n        for (var i = 0; i < mesh.subMeshes.length; ++i) {\n          var subMesh = mesh.subMeshes[i];\n          var renderingMesh = subMesh.getRenderingMesh();\n\n          var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n          var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n\n          if (!_this.isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }; // Custom render function\n\n\n    var renderSubMesh = function renderSubMesh(subMesh) {\n      var _a, _b;\n\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n      var scene = _this._scene;\n      var engine = scene.getEngine();\n      var material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      } // Culling\n\n\n      var detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n      var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n\n      if (detNeg) {\n        sideOrientation = sideOrientation === 0 ? 1 : 0;\n      }\n\n      var reverseSideOrientation = sideOrientation === 0;\n      engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      var camera = _this._camera || scene.activeCamera;\n\n      if (_this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        var renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n\n        var drawWrapper = subMesh._getDrawWrapper();\n\n        if (!drawWrapper && renderingMaterial) {\n          drawWrapper = renderingMaterial._getDrawWrapper();\n        }\n\n        var cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n\n        if (!drawWrapper) {\n          return;\n        }\n\n        var effect_1 = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect_1, material.fillMode);\n        }\n\n        if (!renderingMaterial) {\n          effect_1.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          effect_1.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        } else {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        }\n\n        var minZ = void 0,\n            maxZ = void 0;\n\n        if (cameraIsOrtho) {\n          minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n        } else {\n          minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n        }\n\n        effect_1.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n\n        if (!renderingMaterial) {\n          // Alpha test\n          if (material && material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n\n            if (alphaTexture) {\n              effect_1.setTexture(\"diffuseSampler\", alphaTexture);\n              effect_1.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bones\n\n\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            var skeleton = renderingMesh.skeleton;\n\n            if (skeleton.isUsingTextureForMatrices) {\n              var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n\n              if (!boneTexture) {\n                return;\n              }\n\n              effect_1.setTexture(\"boneSampler\", boneTexture);\n              effect_1.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n            } else {\n              effect_1.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n            }\n          } // Morph targets\n\n\n          MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);\n\n          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect_1);\n          }\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          return effect_1.setMatrix(\"world\", world);\n        });\n      }\n    };\n\n    this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (_this.forceDepthWriteTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      } else {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n      }\n    };\n  }\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n   */\n\n\n  DepthRenderer.prototype.setMaterialForRendering = function (mesh, material) {\n    this._depthMap.setMaterialForRendering(mesh, material);\n  };\n  /**\n   * Creates the depth rendering effect and checks if the effect is ready.\n   * @param subMesh The submesh to be used to render the depth map of\n   * @param useInstances If multiple world instances should be used\n   * @returns if the depth renderer is ready to render the depth map\n   */\n\n\n  DepthRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var _a;\n\n    var engine = this._scene.getEngine();\n\n    var mesh = subMesh.getMesh();\n    var renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n\n    var material = subMesh.getMaterial();\n\n    if (!material || material.disableDepthWrite) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind]; // Alpha test\n\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n      var skeleton = subMesh.getRenderingMesh().skeleton;\n\n      if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // None linear depth\n\n\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    } // Float Mode\n\n\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    } // Get correct effect\n\n\n    var drawWrapper = subMesh._getDrawWrapper(undefined, true);\n\n    var cachedDefines = drawWrapper.defines;\n    var join = defines.join(\"\\n\");\n\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, [\"world\", \"mBones\", \"boneTextureWidth\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"], [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n\n    return drawWrapper.effect.isReady();\n  };\n  /**\n   * Gets the texture which the depth map will be written to.\n   * @returns The depth map texture\n   */\n\n\n  DepthRenderer.prototype.getDepthMap = function () {\n    return this._depthMap;\n  };\n  /**\n   * Disposes of the depth renderer.\n   */\n\n\n  DepthRenderer.prototype.dispose = function () {\n    var keysToDelete = [];\n\n    for (var key in this._scene._depthRenderer) {\n      var depthRenderer = this._scene._depthRenderer[key];\n\n      if (depthRenderer === this) {\n        keysToDelete.push(key);\n      }\n    }\n\n    if (keysToDelete.length > 0) {\n      this._depthMap.dispose();\n\n      for (var _i = 0, keysToDelete_1 = keysToDelete; _i < keysToDelete_1.length; _i++) {\n        var key = keysToDelete_1[_i];\n        delete this._scene._depthRenderer[key];\n      }\n    }\n  };\n  /**\n   * @param _\n   * @hidden\n   */\n\n\n  DepthRenderer._SceneComponentInitialization = function (_) {\n    throw _WarnImport(\"DepthRendererSceneComponent\");\n  };\n\n  return DepthRenderer;\n}();\n\nexport { DepthRenderer };","map":{"version":3,"mappings":"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","names":["Color4","VertexBuffer","Texture","RenderTargetTexture","MaterialHelper","Camera","_WarnImport","scene","type","camera","storeNonLinearDepth","samplingMode","TRILINEAR_SAMPLINGMODE","_scene","_storeNonLinearDepth","isPacked","_clearColor","DepthRenderer","_SceneComponentInitialization","engine","getEngine","_camera","NEAREST_SAMPLINGMODE","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","format","_features","supportExtendedTextureFormats","_depthMap","width","getRenderWidth","height","getRenderHeight","undefined","wrapU","CLAMP_ADDRESSMODE","wrapV","refreshRate","renderParticles","renderList","activeCamera","ignoreCameraViewport","useCameraPostProcesses","onClearObservable","add","clear","_this","onBeforeBindObservable","_debugPushGroup","_a","onAfterUnbindObservable","_debugPopGroup","customIsReadyFunction","mesh","isReady","subMeshes","i","length","subMesh","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","hasThinInstances","renderSubMesh","effectiveMesh","getEffectiveMesh","material","getMaterial","_internalAbstractMeshDataInfo","_isActiveIntermediate","infiniteDistance","disableDepthWrite","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","overrideMaterialSideOrientation","reverseSideOrientation","setState","backFaceCulling","cullBackFaces","mustReturn","renderingMaterial","_materialForRenderPass","_b","currentRenderPassId","drawWrapper","_getDrawWrapper","cameraIsOrtho","mode","ORTHOGRAPHIC_CAMERA","effect_1","effect","enableEffect","_bind","fillMode","setMatrix","getTransformMatrix","getWorldMatrix","bindForSubMesh","minZ","maxZ","useReverseDepthBuffer","isNDCHalfZRange","setFloat2","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","useBones","computeBonesUsingShaders","skeleton","isUsingTextureForMatrices","boneTexture","getTransformMatrixTexture","setFloat","bones","setMatrices","getTransformMatrices","BindMorphTargetParameters","morphTargetManager","isUsingTextureForTargets","_processRendering","isInstance","world","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","data","forceDepthWriteTransparentMeshes","setMaterialForRendering","useInstances","getMesh","isReadyForSubMesh","defines","attribs","PositionKind","push","isVerticesDataPresent","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","numMorphInfluencers","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","keysToDelete","key","_depthRenderer","depthRenderer","dispose","_i","_"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/depthRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\n\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /** Force writing the transparent objects into the depth map */\r\n    public forceDepthWriteTransparentMeshes = false;\r\n\r\n    /**\r\n     * Specifies that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /**\r\n     * @param _\r\n     * @hidden\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"DepthRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._depthMap.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        type: number = Constants.TEXTURETYPE_FLOAT,\r\n        camera: Nullable<Camera> = null,\r\n        storeNonLinearDepth = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE\r\n    ) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this.isPacked) {\r\n            this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._camera = camera;\r\n\r\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\r\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n        }\r\n\r\n        // Render target\r\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\r\n        this._depthMap = new RenderTargetTexture(\r\n            \"DepthRenderer\",\r\n            { width: engine.getRenderWidth(), height: engine.getRenderHeight() },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            type,\r\n            false,\r\n            samplingMode,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            format\r\n        );\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this._clearColor, true, true, true);\r\n        });\r\n\r\n        this._depthMap.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(\"depth renderer\", 1);\r\n        });\r\n\r\n        this._depthMap.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._depthMap.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number) => {\r\n            if (!mesh.isReady(false)) {\r\n                return false;\r\n            }\r\n            if (refreshRate === 0 && mesh.subMeshes) {\r\n                // full check: check that the effects are ready\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering =\r\n                        engine.getCaps().instancedArrays &&\r\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling\r\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n            let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n            if (detNeg) {\r\n                sideOrientation =\r\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\r\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\r\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                engine.getCaps().instancedArrays &&\r\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n            const camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (!drawWrapper && renderingMaterial) {\r\n                    drawWrapper = renderingMaterial._getDrawWrapper();\r\n                }\r\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!renderingMaterial) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                } else {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                }\r\n\r\n                let minZ: number, maxZ: number;\r\n\r\n                if (cameraIsOrtho) {\r\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                } else {\r\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\r\n                }\r\n\r\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\r\n\r\n                if (!renderingMaterial) {\r\n                    // Alpha test\r\n                    if (material && material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        const skeleton = renderingMesh.skeleton;\r\n\r\n                        if (skeleton.isUsingTextureForMatrices) {\r\n                            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                            if (!boneTexture) {\r\n                                return;\r\n                            }\r\n\r\n                            effect.setTexture(\"boneSampler\", boneTexture);\r\n                            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                        } else {\r\n                            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                        }\r\n                    }\r\n\r\n                    // Morph targets\r\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                    effect.setMatrix(\"world\", world)\r\n                );\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.forceDepthWriteTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            } else {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material || material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n\r\n            const skeleton = subMesh.getRenderingMesh().skeleton;\r\n\r\n            if (skeleton?.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\r\n                    \"depth\",\r\n                    attribs,\r\n                    [\r\n                        \"world\",\r\n                        \"mBones\",\r\n                        \"boneTextureWidth\",\r\n                        \"viewProjection\",\r\n                        \"diffuseMatrix\",\r\n                        \"depthValues\",\r\n                        \"morphTargetInfluences\",\r\n                        \"morphTargetTextureInfo\",\r\n                        \"morphTargetTextureIndices\",\r\n                    ],\r\n                    [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"],\r\n                    join,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: numMorphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        const keysToDelete = [];\r\n        for (const key in this._scene._depthRenderer) {\r\n            const depthRenderer = this._scene._depthRenderer[key];\r\n            if (depthRenderer === this) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n\r\n        if (keysToDelete.length > 0) {\r\n            this._depthMap.dispose();\r\n\r\n            for (const key of keysToDelete) {\r\n                delete this._scene._depthRenderer[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}