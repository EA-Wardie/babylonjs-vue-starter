{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport { __extends } from \"tslib\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { UniversalCamera } from \"../../Cameras/universalCamera.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { TargetCamera } from \"../targetCamera.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\n * @see https://doc.babylonjs.com/features/cameras\n */\n\nvar StereoscopicScreenUniversalCamera =\n/** @class */\nfunction (_super) {\n  __extends(StereoscopicScreenUniversalCamera, _super);\n  /**\n   * Creates a new StereoscopicScreenUniversalCamera\n   * @param name defines camera name\n   * @param position defines initial position\n   * @param scene defines the hosting scene\n   * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\n   * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\n   */\n\n\n  function StereoscopicScreenUniversalCamera(name, position, scene, distanceToProjectionPlane, distanceBetweenEyes) {\n    if (distanceToProjectionPlane === void 0) {\n      distanceToProjectionPlane = 1;\n    }\n\n    if (distanceBetweenEyes === void 0) {\n      distanceBetweenEyes = 0.065;\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n\n    _this._distanceBetweenEyes = distanceBetweenEyes;\n    _this._distanceToProjectionPlane = distanceToProjectionPlane;\n\n    _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\n      stereoHalfAngle: 0\n    });\n\n    _this._cameraRigParams.stereoHalfAngle = 0;\n    _this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\n    return _this;\n  }\n\n  Object.defineProperty(StereoscopicScreenUniversalCamera.prototype, \"distanceBetweenEyes\", {\n    /**\n     * distance between the eyes\n     */\n    get: function get() {\n      return this._distanceBetweenEyes;\n    },\n    set: function set(newValue) {\n      this._distanceBetweenEyes = newValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StereoscopicScreenUniversalCamera.prototype, \"distanceToProjectionPlane\", {\n    /**\n     * Distance to projection plane (should be the same units the like distance between the eyes)\n     */\n    get: function get() {\n      return this._distanceToProjectionPlane;\n    },\n    set: function set(newValue) {\n      this._distanceToProjectionPlane = newValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Gets camera class name\n   * @returns StereoscopicScreenUniversalCamera\n   */\n\n  StereoscopicScreenUniversalCamera.prototype.getClassName = function () {\n    return \"StereoscopicUniversalCamera\";\n  };\n  /**\n   * @param name\n   * @hidden\n   */\n\n\n  StereoscopicScreenUniversalCamera.prototype.createRigCamera = function (name) {\n    var camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\n    var transform = new TransformNode(\"tm_\" + name, this.getScene());\n    camera.parent = transform;\n    transform.setPivotMatrix(Matrix.Identity(), false);\n    camera.isRigCamera = true;\n    camera.rigParent = this;\n    return camera;\n  };\n  /**\n   * @hidden\n   */\n\n\n  StereoscopicScreenUniversalCamera.prototype._updateRigCameras = function () {\n    for (var cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n      var cam = this._rigCameras[cameraIndex];\n      cam.minZ = this.minZ;\n      cam.maxZ = this.maxZ;\n      cam.fov = this.fov;\n      cam.upVector.copyFrom(this.upVector);\n\n      if (cam.rotationQuaternion) {\n        cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        cam.rotation.copyFrom(this.rotation);\n      }\n\n      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n    }\n  };\n\n  StereoscopicScreenUniversalCamera.prototype._updateCamera = function (camera, cameraIndex) {\n    var b = this.distanceBetweenEyes / 2;\n    var z = b / this.distanceToProjectionPlane;\n    camera.position.copyFrom(this.position);\n    camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\n    var transform = camera.parent;\n    var m = transform.getPivotMatrix();\n    m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\n    m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\n    transform.setPivotMatrix(m, false);\n  };\n\n  StereoscopicScreenUniversalCamera.prototype._setRigMode = function () {\n    this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\n    this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n\n    for (var cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n    }\n  };\n\n  return StereoscopicScreenUniversalCamera;\n}(UniversalCamera);\n\nexport { StereoscopicScreenUniversalCamera };","map":{"version":3,"mappings":"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","names":["Camera","UniversalCamera","Matrix","Vector3","TargetCamera","TransformNode","Viewport","__extends","name","position","scene","distanceToProjectionPlane","distanceBetweenEyes","_super","_this","_distanceBetweenEyes","_distanceToProjectionPlane","setCameraRigMode","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","stereoHalfAngle","_cameraRigParams","interaxialDistance","Object","StereoscopicScreenUniversalCamera","newValue","camera","Zero","getScene","transform","parent","setPivotMatrix","Identity","isRigCamera","rigParent","cameraIndex","_rigCameras","length","cam","minZ","maxZ","fov","upVector","copyFrom","rotationQuaternion","rotation","_updateCamera","b","z","addInPlaceFromFloats","m","getPivotMatrix","setTranslationFromFloats","setRowFromFloats","viewport"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.ts"],"sourcesContent":["import { Camera } from \"../../Cameras/camera\";\r\nimport { UniversalCamera } from \"../../Cameras/universalCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { TargetCamera } from \"../targetCamera\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class StereoscopicScreenUniversalCamera extends UniversalCamera {\r\n    private _distanceToProjectionPlane: number;\r\n    private _distanceBetweenEyes: number;\r\n\r\n    public set distanceBetweenEyes(newValue: number) {\r\n        this._distanceBetweenEyes = newValue;\r\n    }\r\n\r\n    /**\r\n     * distance between the eyes\r\n     */\r\n    public get distanceBetweenEyes(): number {\r\n        return this._distanceBetweenEyes;\r\n    }\r\n\r\n    public set distanceToProjectionPlane(newValue: number) {\r\n        this._distanceToProjectionPlane = newValue;\r\n    }\r\n\r\n    /**\r\n     * Distance to projection plane (should be the same units the like distance between the eyes)\r\n     */\r\n    public get distanceToProjectionPlane(): number {\r\n        return this._distanceToProjectionPlane;\r\n    }\r\n    /**\r\n     * Creates a new StereoscopicScreenUniversalCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param scene defines the hosting scene\r\n     * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\r\n     * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, distanceToProjectionPlane: number = 1, distanceBetweenEyes: number = 0.065) {\r\n        super(name, position, scene);\r\n        this._distanceBetweenEyes = distanceBetweenEyes;\r\n        this._distanceToProjectionPlane = distanceToProjectionPlane;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\r\n            stereoHalfAngle: 0,\r\n        });\r\n        this._cameraRigParams.stereoHalfAngle = 0;\r\n        this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicScreenUniversalCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicUniversalCamera\";\r\n    }\r\n\r\n    /**\r\n     * @param name\r\n     * @hidden\r\n     */\r\n    public createRigCamera(name: string): Nullable<Camera> {\r\n        const camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\r\n        const transform = new TransformNode(\"tm_\" + name, this.getScene());\r\n        camera.parent = transform;\r\n        transform.setPivotMatrix(Matrix.Identity(), false);\r\n        camera.isRigCamera = true;\r\n        camera.rigParent = this;\r\n        return camera;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _updateRigCameras() {\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            const cam = this._rigCameras[cameraIndex] as TargetCamera;\r\n            cam.minZ = this.minZ;\r\n            cam.maxZ = this.maxZ;\r\n            cam.fov = this.fov;\r\n            cam.upVector.copyFrom(this.upVector);\r\n            if (cam.rotationQuaternion) {\r\n                cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n            } else {\r\n                cam.rotation.copyFrom(this.rotation);\r\n            }\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n\r\n    private _updateCamera(camera: TargetCamera, cameraIndex: number) {\r\n        const b = this.distanceBetweenEyes / 2;\r\n        const z = b / this.distanceToProjectionPlane;\r\n        camera.position.copyFrom(this.position);\r\n        camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\r\n        const transform = camera.parent as TransformNode;\r\n        const m = transform.getPivotMatrix();\r\n        m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\r\n        m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\r\n        transform.setPivotMatrix(m, false);\r\n    }\r\n\r\n    protected _setRigMode() {\r\n        this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\r\n        this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}