{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nvar NAME = \"KHR_materials_translucency\";\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\n * !!! Experimental Extension Subject to Changes !!!\n */\n\nvar KHR_materials_translucency =\n/** @class */\nfunction () {\n  /**\n   * @param loader\n   * @hidden\n   */\n  function KHR_materials_translucency(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n\n    this.order = 174;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n\n    if (this.enabled) {\n      loader.parent.transparencyAsCoverage = true;\n    }\n  }\n  /** @hidden */\n\n\n  KHR_materials_translucency.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /**\n   * @param context\n   * @param material\n   * @param babylonMaterial\n   * @hidden\n   */\n\n\n  KHR_materials_translucency.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n      return Promise.all(promises).then(function () {});\n    });\n  };\n\n  KHR_materials_translucency.prototype._loadTranslucentPropertiesAsync = function (context, material, babylonMaterial, extension) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(\"\".concat(context, \": Material type not supported\"));\n    }\n\n    var pbrMaterial = babylonMaterial; // Enables \"translucency\" texture which represents diffusely-transmitted light.\n\n    pbrMaterial.subSurface.isTranslucencyEnabled = true; // Since this extension models thin-surface transmission only, we must make the\n    // internal IOR == 1.0 and set the thickness to 0.\n\n    pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n    pbrMaterial.subSurface.minimumThickness = 0.0;\n    pbrMaterial.subSurface.maximumThickness = 0.0; // Albedo colour will tint transmission.\n\n    pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;\n\n    if (extension.translucencyFactor !== undefined) {\n      pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;\n    } else {\n      pbrMaterial.subSurface.translucencyIntensity = 0.0;\n      pbrMaterial.subSurface.isTranslucencyEnabled = false;\n      return Promise.resolve();\n    }\n\n    if (extension.translucencyTexture) {\n      extension.translucencyTexture.nonColorData = true;\n      return this._loader.loadTextureInfoAsync(\"\".concat(context, \"/translucencyTexture\"), extension.translucencyTexture).then(function (texture) {\n        pbrMaterial.subSurface.translucencyIntensityTexture = texture;\n      });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  return KHR_materials_translucency;\n}();\n\nexport { KHR_materials_translucency };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_translucency(loader);\n});","map":{"version":3,"mappings":"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","names":["PBRMaterial","GLTFLoader","NAME","loader","_loader","enabled","isExtensionUsed","parent","transparencyAsCoverage","KHR_materials_translucency","context","material","babylonMaterial","LoadExtensionAsync","name","extensionContext","extension","promises","Array","push","_this","loadMaterialBasePropertiesAsync","loadMaterialPropertiesAsync","_loadTranslucentPropertiesAsync","Promise","all","then","Error","pbrMaterial","subSurface","isTranslucencyEnabled","volumeIndexOfRefraction","minimumThickness","maximumThickness","useAlbedoToTintTranslucency","translucencyFactor","undefined","translucencyIntensity","resolve","translucencyTexture","nonColorData","loadTextureInfoAsync","texture","translucencyIntensityTexture","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_translucency.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTranslucency } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_translucency\";\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\nexport class KHR_materials_translucency implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @param context\r\n     * @param material\r\n     * @param babylonMaterial\r\n     * @hidden\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTranslucency>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadTranslucentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTranslucency): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial as PBRMaterial;\r\n\r\n        // Enables \"translucency\" texture which represents diffusely-transmitted light.\r\n        pbrMaterial.subSurface.isTranslucencyEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make the\r\n        // internal IOR == 1.0 and set the thickness to 0.\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;\r\n\r\n        if (extension.translucencyFactor !== undefined) {\r\n            pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;\r\n        } else {\r\n            pbrMaterial.subSurface.translucencyIntensity = 0.0;\r\n            pbrMaterial.subSurface.isTranslucencyEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (extension.translucencyTexture) {\r\n            (extension.translucencyTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/translucencyTexture`, extension.translucencyTexture).then((texture: BaseTexture) => {\r\n                pbrMaterial.subSurface.translucencyIntensityTexture = texture;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_translucency(loader));\r\n"]},"metadata":{},"sourceType":"module"}