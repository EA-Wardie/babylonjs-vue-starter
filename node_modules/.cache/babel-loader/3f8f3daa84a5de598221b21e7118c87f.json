{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { __extends } from \"tslib\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { VideoTexture } from \"../Materials/Textures/videoTexture.js\";\nimport { TextureDome } from \"./textureDome.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\n/**\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\n\nvar VideoDome =\n/** @class */\nfunction (_super) {\n  __extends(VideoDome, _super);\n\n  function VideoDome() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(VideoDome.prototype, \"videoTexture\", {\n    /**\n     * Get the video texture associated with this video dome\n     */\n    get: function get() {\n      return this._texture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VideoDome.prototype, \"videoMode\", {\n    /**\n     * Get the video mode of this dome\n     */\n    get: function get() {\n      return this.textureMode;\n    },\n\n    /**\n     * Set the video mode of this dome.\n     * @see textureMode\n     */\n    set: function set(value) {\n      this.textureMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VideoDome.prototype._initTexture = function (urlsOrElement, scene, options) {\n    var _this = this;\n\n    var tempOptions = {\n      loop: options.loop,\n      autoPlay: options.autoPlay,\n      autoUpdateTexture: true,\n      poster: options.poster\n    };\n    var texture = new VideoTexture((this.name || \"videoDome\") + \"_texture\", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions); // optional configuration\n\n    if (options.clickToPlay) {\n      this._pointerObserver = scene.onPointerObservable.add(function (pointerInfo) {\n        if (pointerInfo.type !== PointerEventTypes.POINTERUP) {\n          _this._texture.video.play();\n        }\n      });\n    }\n\n    this._textureObserver = texture.onLoadObservable.add(function () {\n      _this.onLoadObservable.notifyObservers();\n    });\n    return texture;\n  };\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n\n\n  VideoDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    this._texture.onLoadObservable.remove(this._textureObserver);\n\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\n   * Define the video source as a Monoscopic panoramic 360 video.\n   */\n\n\n  VideoDome.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\n  /**\n   * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\n   */\n\n  VideoDome.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\n  /**\n   * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\n   */\n\n  VideoDome.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;\n  return VideoDome;\n}(TextureDome);\n\nexport { VideoDome };","map":{"version":3,"mappings":";;;AACA,SAASA,OAAT,QAAwB,kCAAxB;AAEA,SAASC,YAAT,QAA6B,uCAA7B;AACA,SAASC,WAAT,QAA4B,kBAA5B;AAEA,SAASC,iBAAT,QAAkC,4BAAlC;AAIA;;;;;;;AAMA;AAAA;AAAA;AAA+BC;;AAA/B;;AAwEC;;AAvDGC,wBAAWC,mBAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA;AACI,aAAO,KAAKC,QAAZ;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAMAF,wBAAWC,mBAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA;AACI,aAAO,KAAKE,WAAZ;AACH,KAFmB;;AAGpB;;;;SAIA,aAAqBC,KAArB,EAAkC;AAC9B,WAAKD,WAAL,GAAmBC,KAAnB;AACH,KATmB;qBAAA;;AAAA,GAApB;;AAcUH,qCAAV,UAAuBI,aAAvB,EAA4EC,KAA5E,EAA0FC,OAA1F,EAAsG;AAAtG;;AACI,QAAMC,WAAW,GAAyB;AAAEC,UAAI,EAAEF,OAAO,CAACE,IAAhB;AAAsBC,cAAQ,EAAEH,OAAO,CAACG,QAAxC;AAAkDC,uBAAiB,EAAE,IAArE;AAA2EC,YAAM,EAAEL,OAAO,CAACK;AAA3F,KAA1C;AACA,QAAMC,OAAO,GAAG,IAAIjB,YAAJ,CACZ,CAAC,KAAKkB,IAAL,IAAa,WAAd,IAA6B,UADjB,EAEZT,aAFY,EAGZC,KAHY,EAIZC,OAAO,CAACQ,eAJI,EAKZ,KAAKC,iBALO,EAMZrB,OAAO,CAACsB,sBANI,EAOZT,WAPY,CAAhB,CAFkG,CAWlG;;AACA,QAAID,OAAO,CAACW,WAAZ,EAAyB;AACrB,WAAKC,gBAAL,GAAwBb,KAAK,CAACc,mBAAN,CAA0BC,GAA1B,CAA8B,UAACC,WAAD,EAAY;AAC9D,YAAIA,WAAW,CAACC,IAAZ,KAAqBzB,iBAAiB,CAAC0B,SAA3C,EAAsD;AAClDC,eAAI,CAACvB,QAAL,CAAcwB,KAAd,CAAoBC,IAApB;AACH;AACJ,OAJuB,CAAxB;AAKH;;AACD,SAAKC,gBAAL,GAAwBf,OAAO,CAACgB,gBAAR,CAAyBR,GAAzB,CAA6B;AACjDI,WAAI,CAACI,gBAAL,CAAsBC,eAAtB;AACH,KAFuB,CAAxB;AAGA,WAAOjB,OAAP;AACH,GAvBS;AAyBV;;;;;;;AAKOZ,gCAAP,UAAe8B,YAAf,EAAuCC,0BAAvC,EAAyE;AAAlC;AAAAA;AAAkC;;AACrE,SAAK9B,QAAL,CAAc2B,gBAAd,CAA+BI,MAA/B,CAAsC,KAAKL,gBAA3C;;AACA,SAAKM,MAAL,CAAYd,mBAAZ,CAAgCa,MAAhC,CAAuC,KAAKd,gBAA5C;;AACAgB,qBAAMC,OAAN,CAAaC,IAAb,CAAa,IAAb,EAAcN,YAAd,EAA4BC,0BAA5B;AACH,GAJM;AAlEP;;;;;AAGuB/B,8BAAkBJ,WAAW,CAACyC,eAA9B;AACvB;;;;AAGuBrC,6BAAiBJ,WAAW,CAAC0C,cAA7B;AACvB;;;;AAGuBtC,8BAAkBJ,WAAW,CAAC2C,eAA9B;AA4D3B;AAAC,CAxED,CAA+B3C,WAA/B;;SAAaI","names":["Texture","VideoTexture","TextureDome","PointerEventTypes","__extends","Object","VideoDome","_texture","textureMode","value","urlsOrElement","scene","options","tempOptions","loop","autoPlay","autoUpdateTexture","poster","texture","name","generateMipMaps","_useDirectMapping","TRILINEAR_SAMPLINGMODE","clickToPlay","_pointerObserver","onPointerObservable","add","pointerInfo","type","POINTERUP","_this","video","play","_textureObserver","onLoadObservable","notifyObservers","doNotRecurse","disposeMaterialAndTextures","remove","_scene","_super","dispose","call","MODE_MONOSCOPIC","MODE_TOPBOTTOM","MODE_SIDEBYSIDE"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Helpers/videoDome.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { VideoTextureSettings } from \"../Materials/Textures/videoTexture\";\r\nimport { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport { TextureDome } from \"./textureDome\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\n/**\r\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\r\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport class VideoDome extends TextureDome<VideoTexture> {\r\n    /**\r\n     * Define the video source as a Monoscopic panoramic 360 video.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\r\n    /**\r\n     * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;\r\n\r\n    /**\r\n     * Get the video texture associated with this video dome\r\n     */\r\n    public get videoTexture(): VideoTexture {\r\n        return this._texture;\r\n    }\r\n    /**\r\n     * Get the video mode of this dome\r\n     */\r\n    public get videoMode(): number {\r\n        return this.textureMode;\r\n    }\r\n    /**\r\n     * Set the video mode of this dome.\r\n     * @see textureMode\r\n     */\r\n    public set videoMode(value: number) {\r\n        this.textureMode = value;\r\n    }\r\n\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _textureObserver: Nullable<Observer<Texture>>;\r\n\r\n    protected _initTexture(urlsOrElement: string | string[] | HTMLVideoElement, scene: Scene, options: any): VideoTexture {\r\n        const tempOptions: VideoTextureSettings = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };\r\n        const texture = new VideoTexture(\r\n            (this.name || \"videoDome\") + \"_texture\",\r\n            urlsOrElement,\r\n            scene,\r\n            options.generateMipMaps,\r\n            this._useDirectMapping,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            tempOptions\r\n        );\r\n        // optional configuration\r\n        if (options.clickToPlay) {\r\n            this._pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type !== PointerEventTypes.POINTERUP) {\r\n                    this._texture.video.play();\r\n                }\r\n            });\r\n        }\r\n        this._textureObserver = texture.onLoadObservable.add(() => {\r\n            this.onLoadObservable.notifyObservers();\r\n        });\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.onLoadObservable.remove(this._textureObserver);\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}