{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from a point.\n * It emits the particles randomly between 2 given directions.\n */\n\nvar PointParticleEmitter =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance PointParticleEmitter\n   */\n  function PointParticleEmitter() {\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n    this.direction1 = new Vector3(0, 1.0, 0);\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n\n    this.direction2 = new Vector3(0, 1.0, 0);\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n\n\n  PointParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n\n\n  PointParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(0, 0, 0);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\n  };\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n\n\n  PointParticleEmitter.prototype.clone = function () {\n    var newOne = new PointParticleEmitter();\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n\n\n  PointParticleEmitter.prototype.applyToShader = function (uboOrEffect) {\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n\n\n  PointParticleEmitter.prototype.buildUniformLayout = function (ubo) {\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  };\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n\n\n  PointParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define POINTEMITTER\";\n  };\n  /**\n   * Returns the string \"PointParticleEmitter\"\n   * @returns a string containing the class name\n   */\n\n\n  PointParticleEmitter.prototype.getClassName = function () {\n    return \"PointParticleEmitter\";\n  };\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n\n\n  PointParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n\n\n  PointParticleEmitter.prototype.parse = function (serializationObject) {\n    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n  };\n\n  return PointParticleEmitter;\n}();\n\nexport { PointParticleEmitter };","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","Scalar","PointParticleEmitter","worldMatrix","directionToUpdate","particle","isLocal","randX","RandomRange","direction1","x","direction2","randY","y","randZ","z","copyFromFloats","TransformNormalFromFloatsToRef","positionToUpdate","TransformCoordinatesFromFloatsToRef","newOne","DeepCopy","uboOrEffect","setVector3","ubo","addUniform","serializationObject","type","getClassName","asArray","FromArrayToRef"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Particles/EmitterTypes/pointParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a point.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class PointParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Creates a new instance PointParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(0, 0, 0);\r\n            return;\r\n        }\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): PointParticleEmitter {\r\n        const newOne = new PointParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define POINTEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"PointParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}