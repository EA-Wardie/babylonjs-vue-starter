{"ast":null,"code":"import \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { __awaiter, __generator } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRSessionManager } from \"./webXRSessionManager.js\";\nimport { WebXRCamera } from \"./webXRCamera.js\";\nimport { WebXRState } from \"./webXRTypes.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { UniversalCamera } from \"../Cameras/universalCamera.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\n */\n\nvar WebXRExperienceHelper =\n/** @class */\nfunction () {\n  /**\n   * Creates a WebXRExperienceHelper\n   * @param _scene The scene the helper should be created in\n   */\n  function WebXRExperienceHelper(_scene) {\n    var _this = this;\n\n    this._scene = _scene;\n    this._nonVRCamera = null;\n    this._attachedToElement = false;\n    this._spectatorCamera = null;\n    this._originalSceneAutoClear = true;\n    this._supported = false;\n    this._spectatorMode = false;\n    /**\n     * Observers registered here will be triggered after the camera's initial transformation is set\n     * This can be used to set a different ground level or an extra rotation.\n     *\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\n     * to the position set after this observable is done executing.\n     */\n\n    this.onInitialXRPoseSetObservable = new Observable();\n    /**\n     * Fires when the state of the experience helper has changed\n     */\n\n    this.onStateChangedObservable = new Observable();\n    /**\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\n     */\n\n    this.state = WebXRState.NOT_IN_XR;\n    this.sessionManager = new WebXRSessionManager(_scene);\n    this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\n    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\n\n    _scene.onDisposeObservable.addOnce(function () {\n      _this.dispose();\n    });\n  }\n  /**\n   * Creates the experience helper\n   * @param scene the scene to attach the experience helper to\n   * @returns a promise for the experience helper\n   */\n\n\n  WebXRExperienceHelper.CreateAsync = function (scene) {\n    var helper = new WebXRExperienceHelper(scene);\n    return helper.sessionManager.initializeAsync().then(function () {\n      helper._supported = true;\n      return helper;\n    })[\"catch\"](function (e) {\n      helper._setState(WebXRState.NOT_IN_XR);\n\n      helper.dispose();\n      throw e;\n    });\n  };\n  /**\n   * Disposes of the experience helper\n   */\n\n\n  WebXRExperienceHelper.prototype.dispose = function () {\n    var _a;\n\n    this.exitXRAsync();\n    this.camera.dispose();\n    this.onStateChangedObservable.clear();\n    this.onInitialXRPoseSetObservable.clear();\n    this.sessionManager.dispose();\n    (_a = this._spectatorCamera) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    if (this._nonVRCamera) {\n      this._scene.activeCamera = this._nonVRCamera;\n    }\n  };\n  /**\n   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\n   * @param sessionMode options for the XR session\n   * @param referenceSpaceType frame of reference of the XR session\n   * @param renderTarget the output canvas that will be used to enter XR mode\n   * @param sessionCreationOptions optional XRSessionInit object to init the session with\n   * @returns promise that resolves after xr mode has entered\n   */\n\n\n  WebXRExperienceHelper.prototype.enterXRAsync = function (sessionMode, referenceSpaceType, renderTarget, sessionCreationOptions) {\n    var _a, _b;\n\n    if (renderTarget === void 0) {\n      renderTarget = this.sessionManager.getWebXRRenderTarget();\n    }\n\n    if (sessionCreationOptions === void 0) {\n      sessionCreationOptions = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var baseLayer, xrRenderState, e_1;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!this._supported) {\n              throw \"WebXR not supported in this browser or environment\";\n            }\n\n            this._setState(WebXRState.ENTERING_XR);\n\n            if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\n              sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\n              sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\n            }\n\n            return [4\n            /*yield*/\n            , this.featuresManager._extendXRSessionInitObject(sessionCreationOptions)];\n\n          case 1:\n            sessionCreationOptions = _c.sent(); // we currently recommend \"unbounded\" space in AR (#7959)\n\n            if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\n              Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\n            }\n\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions)];\n\n          case 3:\n            _c.sent();\n\n            return [4\n            /*yield*/\n            , this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType)];\n\n          case 4:\n            _c.sent();\n\n            return [4\n            /*yield*/\n            , renderTarget.initializeXRLayerAsync(this.sessionManager.session)];\n\n          case 5:\n            baseLayer = _c.sent();\n            xrRenderState = {\n              depthFar: this.camera.maxZ,\n              depthNear: this.camera.minZ\n            }; // The layers feature will have already initialized the xr session's layers on session init.\n\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\n              xrRenderState.baseLayer = baseLayer;\n            }\n\n            this.sessionManager.updateRenderState(xrRenderState); // run the render loop\n\n            this.sessionManager.runXRRenderLoop(); // Cache pre xr scene settings\n\n            this._originalSceneAutoClear = this._scene.autoClear;\n            this._nonVRCamera = this._scene.activeCamera;\n            this._attachedToElement = !!((_a = this._nonVRCamera) === null || _a === void 0 ? void 0 : _a.inputs.attachedToElement);\n            (_b = this._nonVRCamera) === null || _b === void 0 ? void 0 : _b.detachControl();\n            this._scene.activeCamera = this.camera; // do not compensate when AR session is used\n\n            if (sessionMode !== \"immersive-ar\") {\n              this._nonXRToXRCamera();\n            } else {\n              // Kept here, TODO - check if needed\n              this._scene.autoClear = false;\n              this.camera.compensateOnFirstFrame = false; // reset the camera's position to the origin\n\n              this.camera.position.set(0, 0, 0);\n              this.camera.rotationQuaternion.set(0, 0, 0, 1);\n            }\n\n            this.sessionManager.onXRSessionEnded.addOnce(function () {\n              // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\n              if (_this.state !== WebXRState.EXITING_XR) {\n                _this._setState(WebXRState.EXITING_XR);\n              } // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\n\n\n              _this.camera.rigCameras.forEach(function (c) {\n                c.outputRenderTarget = null;\n              }); // Restore scene settings\n\n\n              _this._scene.autoClear = _this._originalSceneAutoClear;\n              _this._scene.activeCamera = _this._nonVRCamera;\n\n              if (_this._attachedToElement && _this._nonVRCamera) {\n                _this._nonVRCamera.attachControl(!!_this._nonVRCamera.inputs.noPreventDefault);\n              }\n\n              if (sessionMode !== \"immersive-ar\" && _this.camera.compensateOnFirstFrame) {\n                if (_this._nonVRCamera.setPosition) {\n                  _this._nonVRCamera.setPosition(_this.camera.position);\n                } else {\n                  _this._nonVRCamera.position.copyFrom(_this.camera.position);\n                }\n              }\n\n              _this._setState(WebXRState.NOT_IN_XR);\n            }); // Wait until the first frame arrives before setting state to in xr\n\n            this.sessionManager.onXRFrameObservable.addOnce(function () {\n              _this._setState(WebXRState.IN_XR);\n            });\n            return [2\n            /*return*/\n            , this.sessionManager];\n\n          case 6:\n            e_1 = _c.sent();\n            console.log(e_1);\n            console.log(e_1.message);\n\n            this._setState(WebXRState.NOT_IN_XR);\n\n            throw e_1;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Exits XR mode and returns the scene to its original state\n   * @returns promise that resolves after xr mode has exited\n   */\n\n\n  WebXRExperienceHelper.prototype.exitXRAsync = function () {\n    // only exit if state is IN_XR\n    if (this.state !== WebXRState.IN_XR) {\n      return Promise.resolve();\n    }\n\n    this._setState(WebXRState.EXITING_XR);\n\n    return this.sessionManager.exitXRAsync();\n  };\n  /**\n   * Enable spectator mode for desktop VR experiences.\n   * When spectator mode is enabled a camera will be attached to the desktop canvas and will\n   * display the first rig camera's view on the desktop canvas.\n   * Please note that this will degrade performance, as it requires another camera render.\n   * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\n   */\n\n\n  WebXRExperienceHelper.prototype.enableSpectatorMode = function () {\n    var _this = this;\n\n    if (!this._spectatorMode) {\n      var updateSpectatorCamera_1 = function updateSpectatorCamera_1() {\n        if (_this._spectatorCamera) {\n          _this._spectatorCamera.position.copyFrom(_this.camera.rigCameras[0].globalPosition);\n\n          _this._spectatorCamera.rotationQuaternion.copyFrom(_this.camera.rigCameras[0].absoluteRotation);\n        }\n      };\n\n      var onStateChanged = function onStateChanged() {\n        if (_this.state === WebXRState.IN_XR) {\n          _this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), _this._scene);\n          _this._spectatorCamera.rotationQuaternion = new Quaternion();\n          _this._scene.activeCameras = [_this.camera, _this._spectatorCamera];\n\n          _this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera_1);\n\n          _this._scene.onAfterRenderCameraObservable.add(function (camera) {\n            if (camera === _this.camera) {\n              // reset the dimensions object for correct resizing\n              _this._scene.getEngine().framebufferDimensionsObject = null;\n            }\n          });\n        } else if (_this.state === WebXRState.EXITING_XR) {\n          _this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera_1);\n\n          _this._scene.activeCameras = null;\n        }\n      };\n\n      this._spectatorMode = true;\n      this.onStateChangedObservable.add(onStateChanged);\n      onStateChanged();\n    }\n  };\n\n  WebXRExperienceHelper.prototype._nonXRToXRCamera = function () {\n    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);\n    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n  };\n\n  WebXRExperienceHelper.prototype._setState = function (val) {\n    if (this.state === val) {\n      return;\n    }\n\n    this.state = val;\n    this.onStateChangedObservable.notifyObservers(this.state);\n  };\n\n  return WebXRExperienceHelper;\n}();\n\nexport { WebXRExperienceHelper };","map":{"version":3,"mappings":"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","names":["Observable","WebXRSessionManager","WebXRCamera","WebXRState","WebXRFeatureName","WebXRFeaturesManager","Logger","UniversalCamera","Quaternion","Vector3","_scene","NOT_IN_XR","sessionManager","camera","featuresManager","onDisposeObservable","addOnce","_this","dispose","WebXRExperienceHelper","scene","helper","initializeAsync","then","_supported","e","_setState","exitXRAsync","onStateChangedObservable","clear","onInitialXRPoseSetObservable","_spectatorCamera","_a","_nonVRCamera","activeCamera","sessionMode","referenceSpaceType","renderTarget","sessionCreationOptions","getWebXRRenderTarget","ENTERING_XR","optionalFeatures","push","_extendXRSessionInitObject","_c","Warn","initializeSessionAsync","setReferenceSpaceTypeAsync","initializeXRLayerAsync","session","baseLayer","xrRenderState","depthFar","maxZ","depthNear","minZ","getEnabledFeature","LAYERS","updateRenderState","runXRRenderLoop","_originalSceneAutoClear","autoClear","_attachedToElement","inputs","attachedToElement","_b","detachControl","_nonXRToXRCamera","compensateOnFirstFrame","position","set","rotationQuaternion","onXRSessionEnded","state","EXITING_XR","rigCameras","forEach","c","outputRenderTarget","attachControl","noPreventDefault","setPosition","copyFrom","onXRFrameObservable","IN_XR","console","log","e_1","message","Promise","resolve","_spectatorMode","updateSpectatorCamera_1","globalPosition","absoluteRotation","onStateChanged","Zero","activeCameras","add","onAfterRenderCameraObservable","getEngine","framebufferDimensionsObject","removeCallback","setTransformationFromNonVRCamera","notifyObservers","val"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/webXRExperienceHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n            const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                depthFar: this.camera.maxZ,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n            }\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            console.log(e);\r\n            console.log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     */\r\n    public enableSpectatorMode(): void {\r\n        if (!this._spectatorMode) {\r\n            const updateSpectatorCamera = () => {\r\n                if (this._spectatorCamera) {\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[0].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[0].absoluteRotation);\r\n                }\r\n            };\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            this._scene.getEngine().framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this._spectatorMode = true;\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}