{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\"; // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n\n/**\n * Creates the VertexData for a TorusKnot\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n * * radius the radius of the torus knot, optional, default 2\n * * tube the thickness of the tube, optional, default 0.5\n * * radialSegments the number of sides on each tube segments, optional, default 32\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n * * p the number of windings around the z axis, optional,  default 2\n * * q the number of windings around the x axis, optional,  default 3\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Torus Knot\n */\n\nexport function CreateTorusKnotVertexData(options) {\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var radius = options.radius || 2;\n  var tube = options.tube || 0.5;\n  var radialSegments = options.radialSegments || 32;\n  var tubularSegments = options.tubularSegments || 32;\n  var p = options.p || 2;\n  var q = options.q || 3;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // Helper\n\n  var getPos = function getPos(angle) {\n    var cu = Math.cos(angle);\n    var su = Math.sin(angle);\n    var quOverP = q / p * angle;\n    var cs = Math.cos(quOverP);\n    var tx = radius * (2 + cs) * 0.5 * cu;\n    var ty = radius * (2 + cs) * su * 0.5;\n    var tz = radius * Math.sin(quOverP) * 0.5;\n    return new Vector3(tx, ty, tz);\n  }; // Vertices\n\n\n  var i;\n  var j;\n\n  for (i = 0; i <= radialSegments; i++) {\n    var modI = i % radialSegments;\n    var u = modI / radialSegments * 2 * p * Math.PI;\n    var p1 = getPos(u);\n    var p2 = getPos(u + 0.01);\n    var tang = p2.subtract(p1);\n    var n = p2.add(p1);\n    var bitan = Vector3.Cross(tang, n);\n    n = Vector3.Cross(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n\n    for (j = 0; j < tubularSegments; j++) {\n      var modJ = j % tubularSegments;\n      var v = modJ / tubularSegments * 2 * Math.PI;\n      var cx = -tube * Math.cos(v);\n      var cy = tube * Math.sin(v);\n      positions.push(p1.x + cx * n.x + cy * bitan.x);\n      positions.push(p1.y + cx * n.y + cy * bitan.y);\n      positions.push(p1.z + cx * n.z + cy * bitan.z);\n      uvs.push(i / radialSegments);\n      uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\n    }\n  }\n\n  for (i = 0; i < radialSegments; i++) {\n    for (j = 0; j < tubularSegments; j++) {\n      var jNext = (j + 1) % tubularSegments;\n      var a = i * tubularSegments + j;\n      var b = (i + 1) * tubularSegments + j;\n      var c = (i + 1) * tubularSegments + jNext;\n      var d = i * tubularSegments + jNext;\n      indices.push(d);\n      indices.push(b);\n      indices.push(a);\n      indices.push(d);\n      indices.push(c);\n      indices.push(b);\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a torus knot mesh\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus knot mesh\n * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\n */\n\nexport function CreateTorusKnot(name, options, scene) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var torusKnot = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n  var vertexData = CreateTorusKnotVertexData(options);\n  vertexData.applyToMesh(torusKnot, options.updatable);\n  return torusKnot;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorusKnot instead\n */\n\nexport var TorusKnotBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTorusKnot: CreateTorusKnot\n};\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\n\nMesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\n  var options = {\n    radius: radius,\n    tube: tube,\n    radialSegments: radialSegments,\n    tubularSegments: tubularSegments,\n    p: p,\n    q: q,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateTorusKnot(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Mesh","VertexData","CompatibilityOptions","CreateTorusKnotVertexData","options","indices","Array","positions","normals","uvs","radius","tube","radialSegments","tubularSegments","p","q","sideOrientation","DEFAULTSIDE","getPos","angle","cu","Math","cos","su","sin","quOverP","cs","tx","ty","tz","i","j","modI","u","PI","p1","p2","tang","subtract","n","add","bitan","Cross","normalize","modJ","v","cx","cy","push","x","y","z","UseOpenGLOrientationForUV","jNext","a","b","c","d","ComputeNormals","_ComputeSides","frontUVs","backUVs","vertexData","CreateTorusKnot","name","scene","torusKnot","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TorusKnotBuilder"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Meshes/Builders/torusKnotBuilder.ts"],"sourcesContent":["import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n * * radius the radius of the torus knot, optional, default 2\r\n * * tube the thickness of the tube, optional, default 0.5\r\n * * radialSegments the number of sides on each tube segments, optional, default 32\r\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n * * p the number of windings around the z axis, optional,  default 2\r\n * * q the number of windings around the x axis, optional,  default 3\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: {\r\n    radius?: number;\r\n    tube?: number;\r\n    radialSegments?: number;\r\n    tubularSegments?: number;\r\n    p?: number;\r\n    q?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    const radius = options.radius || 2;\r\n    const tube = options.tube || 0.5;\r\n    const radialSegments = options.radialSegments || 32;\r\n    const tubularSegments = options.tubularSegments || 32;\r\n    const p = options.p || 2;\r\n    const q = options.q || 3;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    const getPos = (angle: number) => {\r\n        const cu = Math.cos(angle);\r\n        const su = Math.sin(angle);\r\n        const quOverP = (q / p) * angle;\r\n        const cs = Math.cos(quOverP);\r\n\r\n        const tx = radius * (2 + cs) * 0.5 * cu;\r\n        const ty = radius * (2 + cs) * su * 0.5;\r\n        const tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    let i: number;\r\n    let j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        const modI = i % radialSegments;\r\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\r\n        const p1 = getPos(u);\r\n        const p2 = getPos(u + 0.01);\r\n        const tang = p2.subtract(p1);\r\n        let n = p2.add(p1);\r\n\r\n        const bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const modJ = j % tubularSegments;\r\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\r\n            const cx = -tube * Math.cos(v);\r\n            const cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const jNext = (j + 1) % tubularSegments;\r\n            const a = i * tubularSegments + j;\r\n            const b = (i + 1) * tubularSegments + j;\r\n            const c = (i + 1) * tubularSegments + jNext;\r\n            const d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n */\r\nexport function CreateTorusKnot(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorusKnot,\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\n(Mesh as any).CreateTorusKnot = (\r\n    name: string,\r\n    radius: number,\r\n    tube: number,\r\n    radialSegments: number,\r\n    tubularSegments: number,\r\n    p: number,\r\n    q: number,\r\n    scene?: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}