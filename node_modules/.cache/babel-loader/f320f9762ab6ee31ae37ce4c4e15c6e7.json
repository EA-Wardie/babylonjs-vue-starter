{"ast":null,"code":"import \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\n\nvar MTLFileLoader =\n/** @class */\nfunction () {\n  function MTLFileLoader() {\n    /**\n     * All material loaded from the mtl will be set here\n     */\n    this.materials = [];\n  }\n  /**\n   * This function will read the mtl file and create each material described inside\n   * This function could be improve by adding :\n   * -some component missing (Ni, Tf...)\n   * -including the specific options available\n   *\n   * @param scene defines the scene the material will be created in\n   * @param data defines the mtl data to parse\n   * @param rootUrl defines the rooturl to use in order to load relative dependencies\n   * @param assetContainer defines the asset container to store the material in (can be null)\n   */\n\n\n  MTLFileLoader.prototype.parseMTL = function (scene, data, rootUrl, assetContainer) {\n    if (data instanceof ArrayBuffer) {\n      return;\n    } //Split the lines from the file\n\n\n    var lines = data.split(\"\\n\"); // whitespace char ie: [ \\t\\r\\n\\f]\n\n    var delimiter_pattern = /\\s+/; //Array with RGB colors\n\n    var color; //New material\n\n    var material = null; //Look at each line\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i].trim(); // Blank line or comment\n\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      } //Get the first parameter (keyword)\n\n\n      var pos = line.indexOf(\" \");\n      var key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase(); //Get the data following the key\n\n      var value = pos >= 0 ? line.substring(pos + 1).trim() : \"\"; //This mtl keyword will create the new material\n\n      if (key === \"newmtl\") {\n        //Check if it is the first material.\n        // Materials specifications are described after this keyword.\n        if (material) {\n          //Add the previous material in the material array.\n          this.materials.push(material);\n        } //Create a new material.\n        // value is the name of the material read in the mtl file\n\n\n        scene._blockEntityCollection = !!assetContainer;\n        material = new StandardMaterial(value, scene);\n        material._parentContainer = assetContainer;\n        scene._blockEntityCollection = false;\n      } else if (key === \"kd\" && material) {\n        // Diffuse color (color under white light) using RGB values\n        //value  = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat); //color = [r,g,b]\n        //Set tghe color into the material\n\n        material.diffuseColor = Color3.FromArray(color);\n      } else if (key === \"ka\" && material) {\n        // Ambient color (color under shadow) using RGB values\n        //value = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat); //color = [r,g,b]\n        //Set tghe color into the material\n\n        material.ambientColor = Color3.FromArray(color);\n      } else if (key === \"ks\" && material) {\n        // Specular color (color when light is reflected from shiny surface) using RGB values\n        //value = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat); //color = [r,g,b]\n        //Set the color into the material\n\n        material.specularColor = Color3.FromArray(color);\n      } else if (key === \"ke\" && material) {\n        // Emissive color using RGB values\n        color = value.split(delimiter_pattern, 3).map(parseFloat);\n        material.emissiveColor = Color3.FromArray(color);\n      } else if (key === \"ns\" && material) {\n        //value = \"Integer\"\n        material.specularPower = parseFloat(value);\n      } else if (key === \"d\" && material) {\n        //d is dissolve for current material. It mean alpha for BABYLON\n        material.alpha = parseFloat(value); //Texture\n        //This part can be improved by adding the possible options of texture\n      } else if (key === \"map_ka\" && material) {\n        // ambient texture map with a loaded image\n        //We must first get the folder of the image\n        material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_kd\" && material) {\n        // Diffuse texture map with a loaded image\n        material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_ks\" && material) {\n        // Specular texture map with a loaded image\n        //We must first get the folder of the image\n        material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_ns\") {//Specular\n        //Specular highlight component\n        //We must first get the folder of the image\n        //\n        //Not supported by BABYLON\n        //\n        //    continue;\n      } else if (key === \"map_bump\" && material) {\n        //The bump texture\n        var values = value.split(delimiter_pattern);\n        var bumpMultiplierIndex = values.indexOf(\"-bm\");\n        var bumpMultiplier = null;\n\n        if (bumpMultiplierIndex >= 0) {\n          bumpMultiplier = values[bumpMultiplierIndex + 1];\n          values.splice(bumpMultiplierIndex, 2); // remove\n        }\n\n        material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n\n        if (material.bumpTexture && bumpMultiplier !== null) {\n          material.bumpTexture.level = parseFloat(bumpMultiplier);\n        }\n      } else if (key === \"map_d\" && material) {\n        // The dissolve of the material\n        material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene); //Options for illumination\n      } else if (key === \"illum\") {\n        //Illumination\n        if (value === \"0\") {//That mean Kd == Kd\n        } else if (value === \"1\") {//Color on and Ambient on\n        } else if (value === \"2\") {//Highlight on\n        } else if (value === \"3\") {//Reflection on and Ray trace on\n        } else if (value === \"4\") {//Transparency: Glass on, Reflection: Ray trace on\n        } else if (value === \"5\") {//Reflection: Fresnel on and Ray trace on\n        } else if (value === \"6\") {//Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n        } else if (value === \"7\") {//Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n        } else if (value === \"8\") {//Reflection on and Ray trace off\n        } else if (value === \"9\") {//Transparency: Glass on, Reflection: Ray trace off\n        } else if (value === \"10\") {//Casts shadows onto invisible surfaces\n        }\n      } else {// console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n      }\n    } //At the end of the file, add the last material\n\n\n    if (material) {\n      this.materials.push(material);\n    }\n  };\n  /**\n   * Gets the texture for the material.\n   *\n   * If the material is imported from input file,\n   * We sanitize the url to ensure it takes the texture from aside the material.\n   *\n   * @param rootUrl The root url to load from\n   * @param value The value stored in the mtl\n   * @param scene\n   * @return The Texture\n   */\n\n\n  MTLFileLoader._GetTexture = function (rootUrl, value, scene) {\n    if (!value) {\n      return null;\n    }\n\n    var url = rootUrl; // Load from input file.\n\n    if (rootUrl === \"file:\") {\n      var lastDelimiter = value.lastIndexOf(\"\\\\\");\n\n      if (lastDelimiter === -1) {\n        lastDelimiter = value.lastIndexOf(\"/\");\n      }\n\n      if (lastDelimiter > -1) {\n        url += value.substr(lastDelimiter + 1);\n      } else {\n        url += value;\n      }\n    } // Not from input file.\n    else {\n      url += value;\n    }\n\n    return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n  };\n  /**\n   * Invert Y-Axis of referenced textures on load\n   */\n\n\n  MTLFileLoader.INVERT_TEXTURE_Y = true;\n  return MTLFileLoader;\n}();\n\nexport { MTLFileLoader };","map":{"version":3,"mappings":"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","names":["Color3","Texture","StandardMaterial","MTLFileLoader","scene","data","rootUrl","assetContainer","ArrayBuffer","lines","split","delimiter_pattern","color","material","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","value","materials","push","_blockEntityCollection","_parentContainer","map","parseFloat","diffuseColor","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","substr","INVERT_TEXTURE_Y"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/OBJ/mtlFileLoader.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiter_pattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiter_pattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @return The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substr(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}