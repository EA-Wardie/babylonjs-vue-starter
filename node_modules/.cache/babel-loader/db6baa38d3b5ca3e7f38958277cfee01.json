{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { DataReader } from \"@babylonjs/core/Misc/dataReader.js\";\nimport { GLTFValidation } from \"./glTFValidation.js\";\nimport { DecodeBase64UrlToBinary } from \"@babylonjs/core/Misc/fileTools.js\";\nimport { StringTools } from \"@babylonjs/core/Misc/stringTools.js\";\nimport { RuntimeError, ErrorCodes } from \"@babylonjs/core/Misc/error.js\";\n\nfunction _readAsync(arrayBuffer, byteOffset, byteLength) {\n  try {\n    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n/**\n * Mode that determines the coordinate system to use.\n */\n\n\nexport var GLTFLoaderCoordinateSystemMode;\n\n(function (GLTFLoaderCoordinateSystemMode) {\n  /**\n   * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\n   */\n  GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"AUTO\"] = 0] = \"AUTO\";\n  /**\n   * Sets the useRightHandedSystem flag on the scene.\n   */\n\n  GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"FORCE_RIGHT_HANDED\"] = 1] = \"FORCE_RIGHT_HANDED\";\n})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));\n/**\n * Mode that determines what animations will start.\n */\n\n\nexport var GLTFLoaderAnimationStartMode;\n\n(function (GLTFLoaderAnimationStartMode) {\n  /**\n   * No animation will start.\n   */\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"NONE\"] = 0] = \"NONE\";\n  /**\n   * The first animation will start.\n   */\n\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"FIRST\"] = 1] = \"FIRST\";\n  /**\n   * All animations will start.\n   */\n\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"ALL\"] = 2] = \"ALL\";\n})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));\n/**\n * Loader state.\n */\n\n\nexport var GLTFLoaderState;\n\n(function (GLTFLoaderState) {\n  /**\n   * The asset is loading.\n   */\n  GLTFLoaderState[GLTFLoaderState[\"LOADING\"] = 0] = \"LOADING\";\n  /**\n   * The asset is ready for rendering.\n   */\n\n  GLTFLoaderState[GLTFLoaderState[\"READY\"] = 1] = \"READY\";\n  /**\n   * The asset is completely loaded.\n   */\n\n  GLTFLoaderState[GLTFLoaderState[\"COMPLETE\"] = 2] = \"COMPLETE\";\n})(GLTFLoaderState || (GLTFLoaderState = {}));\n/**\n * File loader for loading glTF files into a scene.\n */\n\n\nvar GLTFFileLoader =\n/** @class */\nfunction () {\n  function GLTFFileLoader() {\n    // --------------\n    // Common options\n    // --------------\n\n    /**\n     * Raised when the asset has been parsed\n     */\n    this.onParsedObservable = new Observable(); // ----------\n    // V2 options\n    // ----------\n\n    /**\n     * The coordinate system mode. Defaults to AUTO.\n     */\n\n    this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\n    /**\n     * The animation start mode. Defaults to FIRST.\n     */\n\n    this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\n    /**\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\n     */\n\n    this.compileMaterials = false;\n    /**\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\n     */\n\n    this.useClipPlane = false;\n    /**\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\n     */\n\n    this.compileShadowGenerators = false;\n    /**\n     * Defines if the Alpha blended materials are only applied as coverage.\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\n     * If true, no extra effects are applied to transparent pixels.\n     */\n\n    this.transparencyAsCoverage = false;\n    /**\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\n     * Enabling will disable offline support and glTF validator.\n     * Defaults to false.\n     */\n\n    this.useRangeRequests = false;\n    /**\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\n     */\n\n    this.createInstances = true;\n    /**\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\n     */\n\n    this.alwaysComputeBoundingBox = false;\n    /**\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\n     */\n\n    this.loadAllMaterials = false;\n    /**\n     * If true, load only the materials defined in the file. Defaults to false.\n     */\n\n    this.loadOnlyMaterials = false;\n    /**\n     * If true, do not load any materials defined in the file. Defaults to false.\n     */\n\n    this.skipMaterials = false;\n    /**\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\n     */\n\n    this.useSRGBBuffers = true;\n    /**\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\n     */\n\n    this.targetFps = 60;\n    /**\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\n     */\n\n    this.alwaysComputeSkeletonRootNode = false;\n    /**\n     * Function called before loading a url referenced by the asset.\n     * @param url\n     */\n\n    this.preprocessUrlAsync = function (url) {\n      return Promise.resolve(url);\n    };\n    /**\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\n     */\n\n\n    this.onMeshLoadedObservable = new Observable();\n    /**\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\n     */\n\n    this.onTextureLoadedObservable = new Observable();\n    /**\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\n     */\n\n    this.onMaterialLoadedObservable = new Observable();\n    /**\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\n     */\n\n    this.onCameraLoadedObservable = new Observable();\n    /**\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\n     * For assets with LODs, raised when all of the LODs are complete.\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\n     */\n\n    this.onCompleteObservable = new Observable();\n    /**\n     * Observable raised when an error occurs.\n     */\n\n    this.onErrorObservable = new Observable();\n    /**\n     * Observable raised after the loader is disposed.\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\n     * Observable raised after a loader extension is created.\n     * Set additional options for a loader extension in this event.\n     */\n\n    this.onExtensionLoadedObservable = new Observable();\n    /**\n     * Defines if the loader should validate the asset.\n     */\n\n    this.validate = false;\n    /**\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\n     */\n\n    this.onValidatedObservable = new Observable();\n    this._loader = null;\n    this._state = null;\n    this._requests = new Array();\n    /**\n     * Name of the loader (\"gltf\")\n     */\n\n    this.name = \"gltf\";\n    /** @hidden */\n\n    this.extensions = {\n      \".gltf\": {\n        isBinary: false\n      },\n      \".glb\": {\n        isBinary: true\n      }\n    };\n    /**\n     * Observable raised when the loader state changes.\n     */\n\n    this.onLoaderStateChangedObservable = new Observable();\n    this._logIndentLevel = 0;\n    this._loggingEnabled = false;\n    /** @hidden */\n\n    this._log = this._logDisabled;\n    this._capturePerformanceCounters = false;\n    /** @hidden */\n\n    this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n    /** @hidden */\n\n    this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n  }\n\n  Object.defineProperty(GLTFFileLoader.prototype, \"onParsed\", {\n    /**\n     * Raised when the asset has been parsed\n     */\n    set: function set(callback) {\n      if (this._onParsedObserver) {\n        this.onParsedObservable.remove(this._onParsedObserver);\n      }\n\n      this._onParsedObserver = this.onParsedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onMeshLoaded\", {\n    /**\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\n     */\n    set: function set(callback) {\n      if (this._onMeshLoadedObserver) {\n        this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\n      }\n\n      this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onTextureLoaded\", {\n    /**\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\n     */\n    set: function set(callback) {\n      if (this._onTextureLoadedObserver) {\n        this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\n      }\n\n      this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onMaterialLoaded\", {\n    /**\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\n     */\n    set: function set(callback) {\n      if (this._onMaterialLoadedObserver) {\n        this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\n      }\n\n      this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onCameraLoaded\", {\n    /**\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\n     */\n    set: function set(callback) {\n      if (this._onCameraLoadedObserver) {\n        this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\n      }\n\n      this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onComplete\", {\n    /**\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\n     * For assets with LODs, raised when all of the LODs are complete.\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\n     */\n    set: function set(callback) {\n      if (this._onCompleteObserver) {\n        this.onCompleteObservable.remove(this._onCompleteObserver);\n      }\n\n      this._onCompleteObserver = this.onCompleteObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onError\", {\n    /**\n     * Callback raised when an error occurs.\n     */\n    set: function set(callback) {\n      if (this._onErrorObserver) {\n        this.onErrorObservable.remove(this._onErrorObserver);\n      }\n\n      this._onErrorObserver = this.onErrorObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onDispose\", {\n    /**\n     * Callback raised after the loader is disposed.\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onExtensionLoaded\", {\n    /**\n     * Callback raised after a loader extension is created.\n     */\n    set: function set(callback) {\n      if (this._onExtensionLoadedObserver) {\n        this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\n      }\n\n      this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"loggingEnabled\", {\n    /**\n     * Defines if the loader logging is enabled.\n     */\n    get: function get() {\n      return this._loggingEnabled;\n    },\n    set: function set(value) {\n      if (this._loggingEnabled === value) {\n        return;\n      }\n\n      this._loggingEnabled = value;\n\n      if (this._loggingEnabled) {\n        this._log = this._logEnabled;\n      } else {\n        this._log = this._logDisabled;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"capturePerformanceCounters\", {\n    /**\n     * Defines if the loader should capture performance counters.\n     */\n    get: function get() {\n      return this._capturePerformanceCounters;\n    },\n    set: function set(value) {\n      if (this._capturePerformanceCounters === value) {\n        return;\n      }\n\n      this._capturePerformanceCounters = value;\n\n      if (this._capturePerformanceCounters) {\n        this._startPerformanceCounter = this._startPerformanceCounterEnabled;\n        this._endPerformanceCounter = this._endPerformanceCounterEnabled;\n      } else {\n        this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n        this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onValidated\", {\n    /**\n     * Callback raised after a loader extension is created.\n     */\n    set: function set(callback) {\n      if (this._onValidatedObserver) {\n        this.onValidatedObservable.remove(this._onValidatedObserver);\n      }\n\n      this._onValidatedObserver = this.onValidatedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Disposes the loader, releases resources during load, and cancels any outstanding requests.\n   */\n\n  GLTFFileLoader.prototype.dispose = function () {\n    if (this._loader) {\n      this._loader.dispose();\n\n      this._loader = null;\n    }\n\n    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {\n      var request = _a[_i];\n      request.abort();\n    }\n\n    this._requests.length = 0;\n    delete this._progressCallback;\n\n    this.preprocessUrlAsync = function (url) {\n      return Promise.resolve(url);\n    };\n\n    this.onMeshLoadedObservable.clear();\n    this.onTextureLoadedObservable.clear();\n    this.onMaterialLoadedObservable.clear();\n    this.onCameraLoadedObservable.clear();\n    this.onCompleteObservable.clear();\n    this.onExtensionLoadedObservable.clear();\n    this.onDisposeObservable.notifyObservers(undefined);\n    this.onDisposeObservable.clear();\n  };\n  /**\n   * @param scene\n   * @param fileOrUrl\n   * @param onSuccess\n   * @param onProgress\n   * @param useArrayBuffer\n   * @param onError\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.loadFile = function (scene, fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    this._progressCallback = onProgress;\n    var rootUrl = fileOrUrl.name ? \"file:\" : Tools.GetFolderPath(fileOrUrl);\n    var fileName = fileOrUrl.name || Tools.GetFilename(fileOrUrl);\n\n    if (useArrayBuffer) {\n      if (this.useRangeRequests) {\n        if (this.validate) {\n          Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\n        }\n\n        var fileRequest_1 = {\n          abort: function abort() {},\n          onCompleteObservable: new Observable()\n        };\n        var dataBuffer = {\n          readAsync: function readAsync(byteOffset, byteLength) {\n            return new Promise(function (resolve, reject) {\n              _this._loadFile(scene, fileOrUrl, function (data) {\n                resolve(new Uint8Array(data));\n              }, true, function (error) {\n                reject(error);\n              }, function (webRequest) {\n                webRequest.setRequestHeader(\"Range\", \"bytes=\".concat(byteOffset, \"-\").concat(byteOffset + byteLength - 1));\n              });\n            });\n          },\n          byteLength: 0\n        };\n\n        this._unpackBinaryAsync(new DataReader(dataBuffer)).then(function (loaderData) {\n          fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);\n          onSuccess(loaderData);\n        }, onError ? function (error) {\n          return onError(undefined, error);\n        } : undefined);\n\n        return fileRequest_1;\n      }\n\n      return this._loadFile(scene, fileOrUrl, function (data) {\n        _this._validate(scene, data, rootUrl, fileName);\n\n        _this._unpackBinaryAsync(new DataReader({\n          readAsync: function readAsync(byteOffset, byteLength) {\n            return _readAsync(data, byteOffset, byteLength);\n          },\n          byteLength: data.byteLength\n        })).then(function (loaderData) {\n          onSuccess(loaderData);\n        }, onError ? function (error) {\n          return onError(undefined, error);\n        } : undefined);\n      }, true, onError);\n    }\n\n    return this._loadFile(scene, fileOrUrl, function (data) {\n      _this._validate(scene, data, rootUrl, fileName);\n\n      onSuccess({\n        json: _this._parseJson(data)\n      });\n    }, useArrayBuffer, onError);\n  };\n  /**\n   * @param meshesNames\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onProgress\n   * @param fileName\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \".concat(fileName || \"\"));\n\n      _this._loader = _this._getLoader(data);\n      return _this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\n    });\n  };\n  /**\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onProgress\n   * @param fileName\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \".concat(fileName || \"\"));\n\n      _this._loader = _this._getLoader(data);\n      return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\n    });\n  };\n  /**\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onProgress\n   * @param fileName\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \".concat(fileName || \"\"));\n\n      _this._loader = _this._getLoader(data); // Prepare the asset container.\n\n      var container = new AssetContainer(scene); // Get materials/textures when loading to add to container\n\n      var materials = [];\n\n      _this.onMaterialLoadedObservable.add(function (material) {\n        materials.push(material);\n      });\n\n      var textures = [];\n\n      _this.onTextureLoadedObservable.add(function (texture) {\n        textures.push(texture);\n      });\n\n      var cameras = [];\n\n      _this.onCameraLoadedObservable.add(function (camera) {\n        cameras.push(camera);\n      });\n\n      return _this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then(function (result) {\n        Array.prototype.push.apply(container.geometries, result.geometries);\n        Array.prototype.push.apply(container.meshes, result.meshes);\n        Array.prototype.push.apply(container.particleSystems, result.particleSystems);\n        Array.prototype.push.apply(container.skeletons, result.skeletons);\n        Array.prototype.push.apply(container.animationGroups, result.animationGroups);\n        Array.prototype.push.apply(container.materials, materials);\n        Array.prototype.push.apply(container.textures, textures);\n        Array.prototype.push.apply(container.lights, result.lights);\n        Array.prototype.push.apply(container.transformNodes, result.transformNodes);\n        Array.prototype.push.apply(container.cameras, cameras);\n        return container;\n      });\n    });\n  };\n  /**\n   * @param data\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.canDirectLoad = function (data) {\n    return data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1 || StringTools.StartsWith(data, \"data:base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\n    StringTools.StartsWith(data, \"data:;base64,\" + GLTFFileLoader._MagicBase64Encoded) || StringTools.StartsWith(data, \"data:application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) || StringTools.StartsWith(data, \"data:model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded);\n  };\n  /**\n   * @param scene\n   * @param data\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype.directLoad = function (scene, data) {\n    if (StringTools.StartsWith(data, \"base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\n    StringTools.StartsWith(data, \";base64,\" + GLTFFileLoader._MagicBase64Encoded) || StringTools.StartsWith(data, \"application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) || StringTools.StartsWith(data, \"model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)) {\n      var arrayBuffer_1 = DecodeBase64UrlToBinary(data);\n\n      this._validate(scene, arrayBuffer_1);\n\n      return this._unpackBinaryAsync(new DataReader({\n        readAsync: function readAsync(byteOffset, byteLength) {\n          return _readAsync(arrayBuffer_1, byteOffset, byteLength);\n        },\n        byteLength: arrayBuffer_1.byteLength\n      }));\n    }\n\n    this._validate(scene, data);\n\n    return Promise.resolve({\n      json: this._parseJson(data)\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.createPlugin = function () {\n    return new GLTFFileLoader();\n  };\n\n  Object.defineProperty(GLTFFileLoader.prototype, \"loaderState\", {\n    /**\n     * The loader state or null if the loader is not active.\n     */\n    get: function get() {\n      return this._state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns a promise that resolves when the asset is completely loaded.\n   * @returns a promise that resolves when the asset is completely loaded.\n   */\n\n  GLTFFileLoader.prototype.whenCompleteAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.onCompleteObservable.addOnce(function () {\n        resolve();\n      });\n\n      _this.onErrorObservable.addOnce(function (reason) {\n        reject(reason);\n      });\n    });\n  };\n  /**\n   * @param state\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype._setState = function (state) {\n    if (this._state === state) {\n      return;\n    }\n\n    this._state = state;\n    this.onLoaderStateChangedObservable.notifyObservers(this._state);\n\n    this._log(GLTFLoaderState[this._state]);\n  };\n  /**\n   * @param scene\n   * @param fileOrUrl\n   * @param onSuccess\n   * @param useArrayBuffer\n   * @param onError\n   * @param onOpened\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype._loadFile = function (scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = scene._loadFile(fileOrUrl, onSuccess, function (event) {\n      _this._onProgress(event, request);\n    }, true, useArrayBuffer, onError, onOpened);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._requests.splice(_this._requests.indexOf(request), 1);\n    });\n\n    this._requests.push(request);\n\n    return request;\n  };\n\n  GLTFFileLoader.prototype._onProgress = function (event, request) {\n    if (!this._progressCallback) {\n      return;\n    }\n\n    request._lengthComputable = event.lengthComputable;\n    request._loaded = event.loaded;\n    request._total = event.total;\n    var lengthComputable = true;\n    var loaded = 0;\n    var total = 0;\n\n    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {\n      var request_1 = _a[_i];\n\n      if (request_1._lengthComputable === undefined || request_1._loaded === undefined || request_1._total === undefined) {\n        return;\n      }\n\n      lengthComputable = lengthComputable && request_1._lengthComputable;\n      loaded += request_1._loaded;\n      total += request_1._total;\n    }\n\n    this._progressCallback({\n      lengthComputable: lengthComputable,\n      loaded: loaded,\n      total: lengthComputable ? total : 0\n    });\n  };\n\n  GLTFFileLoader.prototype._validate = function (scene, data, rootUrl, fileName) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    if (!this.validate) {\n      return;\n    }\n\n    this._startPerformanceCounter(\"Validate JSON\");\n\n    GLTFValidation.ValidateAsync(data, rootUrl, fileName, function (uri) {\n      return _this.preprocessUrlAsync(rootUrl + uri).then(function (url) {\n        return scene._loadFileAsync(url, undefined, true, true);\n      });\n    }).then(function (result) {\n      _this._endPerformanceCounter(\"Validate JSON\");\n\n      _this.onValidatedObservable.notifyObservers(result);\n\n      _this.onValidatedObservable.clear();\n    }, function (reason) {\n      _this._endPerformanceCounter(\"Validate JSON\");\n\n      Tools.Warn(\"Failed to validate: \".concat(reason.message));\n\n      _this.onValidatedObservable.clear();\n    });\n  };\n\n  GLTFFileLoader.prototype._getLoader = function (loaderData) {\n    var asset = loaderData.json.asset || {};\n\n    this._log(\"Asset version: \".concat(asset.version));\n\n    asset.minVersion && this._log(\"Asset minimum version: \".concat(asset.minVersion));\n    asset.generator && this._log(\"Asset generator: \".concat(asset.generator));\n\n    var version = GLTFFileLoader._parseVersion(asset.version);\n\n    if (!version) {\n      throw new Error(\"Invalid version: \" + asset.version);\n    }\n\n    if (asset.minVersion !== undefined) {\n      var minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\n\n      if (!minVersion) {\n        throw new Error(\"Invalid minimum version: \" + asset.minVersion);\n      }\n\n      if (GLTFFileLoader._compareVersion(minVersion, {\n        major: 2,\n        minor: 0\n      }) > 0) {\n        throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\n      }\n    }\n\n    var createLoaders = {\n      1: GLTFFileLoader._CreateGLTF1Loader,\n      2: GLTFFileLoader._CreateGLTF2Loader\n    };\n    var createLoader = createLoaders[version.major];\n\n    if (!createLoader) {\n      throw new Error(\"Unsupported version: \" + asset.version);\n    }\n\n    return createLoader(this);\n  };\n\n  GLTFFileLoader.prototype._parseJson = function (json) {\n    this._startPerformanceCounter(\"Parse JSON\");\n\n    this._log(\"JSON length: \".concat(json.length));\n\n    var parsed = JSON.parse(json);\n\n    this._endPerformanceCounter(\"Parse JSON\");\n\n    return parsed;\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryAsync = function (dataReader) {\n    var _this = this;\n\n    this._startPerformanceCounter(\"Unpack Binary\"); // Read magic + version + length + json length + json format\n\n\n    return dataReader.loadAsync(20).then(function () {\n      var Binary = {\n        Magic: 0x46546c67\n      };\n      var magic = dataReader.readUint32();\n\n      if (magic !== Binary.Magic) {\n        throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\n      }\n\n      var version = dataReader.readUint32();\n\n      if (_this.loggingEnabled) {\n        _this._log(\"Binary version: \".concat(version));\n      }\n\n      var length = dataReader.readUint32();\n\n      if (dataReader.buffer.byteLength !== 0 && length !== dataReader.buffer.byteLength) {\n        throw new Error(\"Length in header does not match actual data length: \".concat(length, \" != \").concat(dataReader.buffer.byteLength));\n      }\n\n      var unpacked;\n\n      switch (version) {\n        case 1:\n          {\n            unpacked = _this._unpackBinaryV1Async(dataReader, length);\n            break;\n          }\n\n        case 2:\n          {\n            unpacked = _this._unpackBinaryV2Async(dataReader, length);\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Unsupported version: \" + version);\n          }\n      }\n\n      _this._endPerformanceCounter(\"Unpack Binary\");\n\n      return unpacked;\n    });\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryV1Async = function (dataReader, length) {\n    var ContentFormat = {\n      JSON: 0\n    };\n    var contentLength = dataReader.readUint32();\n    var contentFormat = dataReader.readUint32();\n\n    if (contentFormat !== ContentFormat.JSON) {\n      throw new Error(\"Unexpected content format: \".concat(contentFormat));\n    }\n\n    var bodyLength = length - dataReader.byteOffset;\n    var data = {\n      json: this._parseJson(dataReader.readString(contentLength)),\n      bin: null\n    };\n\n    if (bodyLength !== 0) {\n      var startByteOffset_1 = dataReader.byteOffset;\n      data.bin = {\n        readAsync: function readAsync(byteOffset, byteLength) {\n          return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength);\n        },\n        byteLength: bodyLength\n      };\n    }\n\n    return Promise.resolve(data);\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryV2Async = function (dataReader, length) {\n    var _this = this;\n\n    var ChunkFormat = {\n      JSON: 0x4e4f534a,\n      BIN: 0x004e4942\n    }; // Read the JSON chunk header.\n\n    var chunkLength = dataReader.readUint32();\n    var chunkFormat = dataReader.readUint32();\n\n    if (chunkFormat !== ChunkFormat.JSON) {\n      throw new Error(\"First chunk format is not JSON\");\n    } // Bail if there are no other chunks.\n\n\n    if (dataReader.byteOffset + chunkLength === length) {\n      return dataReader.loadAsync(chunkLength).then(function () {\n        return {\n          json: _this._parseJson(dataReader.readString(chunkLength)),\n          bin: null\n        };\n      });\n    } // Read the JSON chunk and the length and type of the next chunk.\n\n\n    return dataReader.loadAsync(chunkLength + 8).then(function () {\n      var data = {\n        json: _this._parseJson(dataReader.readString(chunkLength)),\n        bin: null\n      };\n\n      var readAsync = function readAsync() {\n        var chunkLength = dataReader.readUint32();\n        var chunkFormat = dataReader.readUint32();\n\n        switch (chunkFormat) {\n          case ChunkFormat.JSON:\n            {\n              throw new Error(\"Unexpected JSON chunk\");\n            }\n\n          case ChunkFormat.BIN:\n            {\n              var startByteOffset_2 = dataReader.byteOffset;\n              data.bin = {\n                readAsync: function readAsync(byteOffset, byteLength) {\n                  return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);\n                },\n                byteLength: chunkLength\n              };\n              dataReader.skipBytes(chunkLength);\n              break;\n            }\n\n          default:\n            {\n              // ignore unrecognized chunkFormat\n              dataReader.skipBytes(chunkLength);\n              break;\n            }\n        }\n\n        if (dataReader.byteOffset !== length) {\n          return dataReader.loadAsync(8).then(readAsync);\n        }\n\n        return Promise.resolve(data);\n      };\n\n      return readAsync();\n    });\n  };\n\n  GLTFFileLoader._parseVersion = function (version) {\n    if (version === \"1.0\" || version === \"1.0.1\") {\n      return {\n        major: 1,\n        minor: 0\n      };\n    }\n\n    var match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return {\n      major: parseInt(match[1]),\n      minor: parseInt(match[2])\n    };\n  };\n\n  GLTFFileLoader._compareVersion = function (a, b) {\n    if (a.major > b.major) {\n      return 1;\n    }\n\n    if (a.major < b.major) {\n      return -1;\n    }\n\n    if (a.minor > b.minor) {\n      return 1;\n    }\n\n    if (a.minor < b.minor) {\n      return -1;\n    }\n\n    return 0;\n  };\n  /**\n   * @param message\n   * @hidden\n   */\n\n\n  GLTFFileLoader.prototype._logOpen = function (message) {\n    this._log(message);\n\n    this._logIndentLevel++;\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype._logClose = function () {\n    --this._logIndentLevel;\n  };\n\n  GLTFFileLoader.prototype._logEnabled = function (message) {\n    var spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\n\n    Logger.Log(\"\".concat(spaces).concat(message));\n  };\n\n  GLTFFileLoader.prototype._logDisabled = function (message) {};\n\n  GLTFFileLoader.prototype._startPerformanceCounterEnabled = function (counterName) {\n    Tools.StartPerformanceCounter(counterName);\n  };\n\n  GLTFFileLoader.prototype._startPerformanceCounterDisabled = function (counterName) {};\n\n  GLTFFileLoader.prototype._endPerformanceCounterEnabled = function (counterName) {\n    Tools.EndPerformanceCounter(counterName);\n  };\n\n  GLTFFileLoader.prototype._endPerformanceCounterDisabled = function (counterName) {}; // ----------\n  // V1 options\n  // ----------\n\n  /**\n   * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\n   * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\n   * Defaults to true.\n   * @hidden\n   */\n\n\n  GLTFFileLoader.IncrementalLoading = true;\n  /**\n   * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\n   * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\n   * @hidden\n   */\n\n  GLTFFileLoader.HomogeneousCoordinates = false;\n  GLTFFileLoader._MagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\n\n  GLTFFileLoader._logSpaces = \"                                \";\n  return GLTFFileLoader;\n}();\n\nexport { GLTFFileLoader };\n\nif (SceneLoader) {\n  SceneLoader.RegisterPlugin(new GLTFFileLoader());\n}","map":{"version":3,"mappings":"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","names":["Observable","Tools","SceneLoader","AssetContainer","Logger","DataReader","GLTFValidation","DecodeBase64UrlToBinary","StringTools","RuntimeError","ErrorCodes","readAsync","arrayBuffer","byteOffset","byteLength","Promise","resolve","Uint8Array","e","reject","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","AUTO","FIRST","url","Array","isBinary","_logDisabled","_startPerformanceCounterDisabled","_endPerformanceCounterDisabled","Object","GLTFFileLoader","callback","_onParsedObserver","onParsedObservable","remove","add","_onMeshLoadedObserver","onMeshLoadedObservable","_onTextureLoadedObserver","onTextureLoadedObservable","_onMaterialLoadedObserver","onMaterialLoadedObservable","_onCameraLoadedObserver","onCameraLoadedObservable","_onCompleteObserver","onCompleteObservable","_onErrorObserver","onErrorObservable","_onDisposeObserver","onDisposeObservable","_onExtensionLoadedObserver","onExtensionLoadedObservable","_loggingEnabled","value","_log","_logEnabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterEnabled","_endPerformanceCounter","_endPerformanceCounterEnabled","_onValidatedObserver","onValidatedObservable","_loader","dispose","_requests","_i","request","abort","length","_progressCallback","preprocessUrlAsync","clear","notifyObservers","undefined","scene","fileOrUrl","onSuccess","onProgress","useArrayBuffer","onError","rootUrl","name","GetFolderPath","fileName","GetFilename","useRangeRequests","validate","Warn","fileRequest_1","dataBuffer","_this","_loadFile","data","error","webRequest","setRequestHeader","concat","_unpackBinaryAsync","then","loaderData","_validate","json","_parseJson","meshesNames","_getLoader","importMeshAsync","loadAsync","container","materials","material","push","textures","texture","cameras","camera","result","prototype","apply","geometries","meshes","particleSystems","skeletons","animationGroups","lights","transformNodes","indexOf","StartsWith","_MagicBase64Encoded","arrayBuffer_1","_state","addOnce","reason","state","onLoaderStateChangedObservable","onOpened","event","_onProgress","splice","_lengthComputable","lengthComputable","_loaded","loaded","_total","total","request_1","ValidateAsync","uri","_loadFileAsync","message","asset","version","minVersion","generator","_parseVersion","Error","_compareVersion","major","minor","createLoaders","_CreateGLTF1Loader","_CreateGLTF2Loader","createLoader","parsed","JSON","parse","dataReader","Binary","Magic","magic","readUint32","GLTFLoaderUnexpectedMagicError","loggingEnabled","buffer","unpacked","_unpackBinaryV1Async","_unpackBinaryV2Async","ContentFormat","contentLength","contentFormat","bodyLength","readString","bin","startByteOffset_1","ChunkFormat","BIN","chunkLength","chunkFormat","startByteOffset_2","skipBytes","match","parseInt","a","b","_logIndentLevel","spaces","_logSpaces","substr","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","RegisterPlugin"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/glTFFileLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type {\r\n    ISceneLoaderPluginFactory,\r\n    ISceneLoaderPlugin,\r\n    ISceneLoaderPluginAsync,\r\n    ISceneLoaderProgressEvent,\r\n    ISceneLoaderPluginExtensions,\r\n    ISceneLoaderAsyncResult,\r\n} from \"core/Loading/sceneLoader\";\r\nimport { SceneLoader } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { StringTools } from \"core/Misc/stringTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: Object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @hidden */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @hidden */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: (loaderData: IGLTFLoaderData) => void) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        this._onParsedObserver = this.onParsedObservable.add(callback);\r\n    }\r\n\r\n    // ----------\r\n    // V1 options\r\n    // ----------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @hidden\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @hidden\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: (mesh: AbstractMesh) => void) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: (texture: BaseTexture) => void) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: (material: Material) => void) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: (camera: Camera) => void) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    private static _MagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public name = \"gltf\";\r\n\r\n    /** @hidden */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".gltf\": { isBinary: false },\r\n        \".glb\": { isBinary: true },\r\n    };\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param fileOrUrl\r\n     * @param onSuccess\r\n     * @param onProgress\r\n     * @param useArrayBuffer\r\n     * @param onError\r\n     * @hidden\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: any, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        this._progressCallback = onProgress;\r\n\r\n        const rootUrl = (fileOrUrl as File).name ? \"file:\" : Tools.GetFolderPath(fileOrUrl as string);\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, data as ArrayBuffer, rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        }\r\n\r\n        return this._loadFile(\r\n            scene,\r\n            fileOrUrl,\r\n            (data) => {\r\n                this._validate(scene, data, rootUrl, fileName);\r\n                onSuccess({ json: this._parseJson(data as string) });\r\n            },\r\n            useArrayBuffer,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param meshesNames\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onProgress\r\n     * @param fileName\r\n     * @hidden\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onProgress\r\n     * @param fileName\r\n     * @hidden\r\n     */\r\n    public loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onProgress\r\n     * @param fileName\r\n     * @hidden\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param data\r\n     * @hidden\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return (\r\n            (data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\r\n            StringTools.StartsWith(data, \"data:base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            StringTools.StartsWith(data, \"data:;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            StringTools.StartsWith(data, \"data:application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            StringTools.StartsWith(data, \"data:model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param data\r\n     * @hidden\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<any> {\r\n        if (\r\n            StringTools.StartsWith(data, \"base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            StringTools.StartsWith(data, \";base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            StringTools.StartsWith(data, \"application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            StringTools.StartsWith(data, \"model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, arrayBuffer);\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @hidden */\r\n    public createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader();\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param state\r\n     * @hidden\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param fileOrUrl\r\n     * @param onSuccess\r\n     * @param useArrayBuffer\r\n     * @param onError\r\n     * @param onOpened\r\n     * @hidden\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add((request) => {\r\n            this._requests.splice(this._requests.indexOf(request), 1);\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | ArrayBuffer, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => scene._loadFileAsync(url, undefined, true, true) as Promise<ArrayBuffer>);\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): Object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (dataReader.buffer.byteLength !== 0 && length !== dataReader.buffer.byteLength) {\r\n                throw new Error(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @hidden */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @param message\r\n     * @hidden\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @hidden */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @hidden */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\r\n}\r\n"]},"metadata":{},"sourceType":"module"}